,
  "Mali",
  "Malta",
  "Maroc",
  "Quần đảo Marshall",
  "Mauritanie",
  "Mauritius",
  "México",
  "Micronesia",
  "Moldova",
  "Monaco",
  "Mông Cổ",
  "Montenegro",
  "Mozambique",
  "Myanmar",
  "Namibia",
  "Nam Sudan",
  "Nam Phi",
  "Nauru",
  "Na Uy",
  "Nepal",
  "New Zealand",
  "Nicaragua",
  "Niger",
  "Nigeria",
  "Nga",
  "Nhật Bản",
  "Oman",
  "Pakistan",
  "Palau",
  "Palestine",
  "Panama",
  "Papua New Guinea",
  "Paraguay",
  "Peru",
  "Pháp",
  "Phần Lan",
  "Philippines",
  "Qatar",
  "România",
  "Rwanda",
  "Saint Kitts và Nevis",
  "Saint Lucia",
  "Saint Vincent và Grenadines",
  "Samoa",
  "San Marino",
  "São Tomé và Príncipe",
  "Séc",
  "Sénégal",
  "Serbia",
  "Seychelles",
  "Sierra Leone",
  "Singapore",
  "Síp",
  "Slovakia",
  "Slovenia",
  "Solomon",
  "Somalia",
  "Sri Lanka",
  "Sudan",
  "Suriname",
  "Swaziland",
  "Syria",
  "Tajikistan",
  "Tanzania",
  "Tây Ban Nha",
  "Tchad",
  "Thái Lan",
  "Thổ Nhĩ Kỳ",
  "Thụy Điển",
  "Thụy Sĩ",
  "Togo",
  "Tonga",
  "Triều Tiên",
  "Trinidad và Tobago",
  "Trung Quốc",
  "Trung Phi",
  "Tunisia",
  "Turkmenistan",
  "Tuvalu",
  "Úc",
  "Uganda",
  "Ukraina",
  "Uruguay",
  "Uzbekistan",
  "Vanuatu",
  "Vatican",
  "Venezuela",
  "Việt Nam",
  "Ý",
  "Yemen",
  "Zambia",
  "Zimbabwe"
];
module["exports"] = [
  "Việt Nam"
];
var address = {};
module['exports'] = address;
address.city_root = require("./city_root");
address.city = require("./city");
address.default_country = require("./default_country");
address.postcode = require("./postcode");
address.country = require("./country");
module["exports"] = [
  "#####"
];
module["exports"] = [
  "03# ### ####",
  "05# ### ####",
  "07# ### ####",
  "08# ### ####",
  "09# ### ####"
];
var cell_phone = {};
module['exports'] = cell_phone;
cell_phone.formats = require("./formats");
var company = {};
module['exports'] = company;
company.prefix = require("./prefix");
company.name = require("./name");
module["exports"] = [
  "#{prefix} #{Name.last_name}"
];
module["exports"] = [
  "Công ty",
  "Cty TNHH",
  "Cty",
  "Cửa hàng",
  "Trung tâm",
  "Chi nhánh"
];
var date = {};
module["exports"] = date;
date.month = require("./month");
date.weekday = require("./weekday");
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1799
module["exports"] = {
  wide: [
    "Tháng Giêng",
    "Tháng Hai",
    "Tháng Ba",
    "Tháng Tư",
    "Tháng Năm",
    "Tháng Sáu",
    "Tháng Bảy",
    "Tháng Tám",
    "Tháng Chín",
    "Tháng Mười",
    "Tháng Mười Một",
    "Tháng Mười Hai"
  ],
  // Property "wide_context" is optional, if not set then "wide" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  wide_context: [
    "Tháng Giêng",
    "Tháng Hai",
    "Tháng Ba",
    "Tháng Tư",
    "Tháng Năm",
    "Tháng Sáu",
    "Tháng Bảy",
    "Tháng Tám",
    "Tháng Chín",
    "Tháng Mười",
    "Tháng Mười Một",
    "Tháng Mười Hai"
  ],
  abbr: [
    "Tháng 1",
    "Tháng 2",
    "Tháng 3",
    "Tháng 4",
    "Tháng 5",
    "Tháng 6",
    "Tháng 7",
    "Tháng 8",
    "Tháng 9",
    "Tháng 10",
    "Tháng 11",
    "Tháng 12"
  ],
  // Property "abbr_context" is optional, if not set then "abbr" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  abbr_context: [
    "Tháng 1",
    "Tháng 2",
    "Tháng 3",
    "Tháng 4",
    "Tháng 5",
    "Tháng 6",
    "Tháng 7",
    "Tháng 8",
    "Tháng 9",
    "Tháng 10",
    "Tháng 11",
    "Tháng 12"
  ]
};
// Source: http://unicode.org/cldr/trac/browser/tags/release-27/common/main/en.xml#L1847
module["exports"] = {
  wide: [
    "Chủ nhật",
    "Thứ hai",
    "Thứ ba",
    "Thứ tư",
    "Thứ năm",
    "Thứ sáu",
    "Thứ bảy"
  ],
  // Property "wide_context" is optional, if not set then "wide" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  wide_context: [
    "Chủ nhật",
    "Thứ hai",
    "Thứ ba",
    "Thứ tư",
    "Thứ năm",
    "Thứ sáu",
    "Thứ bảy"
  ],
  abbr: [
    "CN",
    "T2",
    "T3",
    "T4",
    "T5",
    "T6",
    "T7",
  ],
  // Property "abbr_context" is optional, if not set then "abbr" will be used instead
  // It is used to specify a word in context, which may differ from a stand-alone word
  abbr_context: [
    "C.Nhật",
    "Thứ 2",
    "Thứ 3",
    "Thứ 4",
    "Thứ 5",
    "Thứ 6",
    "Thứ 7",
  ]
};
var vi = {};
module['exports'] = vi;
vi.title = "Vietnamese";
vi.address = require("./address");
vi.internet = require("./internet");
vi.phone_number = require("./phone_number");
vi.cell_phone = require("./cell_phone");
vi.name = require("./name");
vi.company = require("./company");
vi.lorem = require("./lorem");
vi.date = require("./date");
module["exports"] = [
  "com",
  "net",
  "info",
  "vn",
  "com.vn"
];
var internet = {};
module['exports'] = internet;
internet.domain_suffix = require("./domain_suffix");
var lorem = {};
module['exports'] = lorem;
lorem.words = require("./words");
module["exports"] = [
  "đã",
  "đang",
  "ừ",
  "ờ",
  "á",
  "không",
  "biết",
  "gì",
  "hết",
  "đâu",
  "nha",
  "thế",
  "thì",
  "là",
  "đánh",
  "đá",
  "đập",
  "phá",
  "viết",
  "vẽ",
  "tô",
  "thuê",
  "mướn",
  "mượn",
  "mua",
  "một",
  "hai",
  "ba",
  "bốn",
  "năm",
  "sáu",
  "bảy",
  "tám",
  "chín",
  "mười",
  "thôi",
  "việc",
  "nghỉ",
  "làm",
  "nhà",
  "cửa",
  "xe",
  "đạp",
  "ác",
  "độc",
  "khoảng",
  "khoan",
  "thuyền",
  "tàu",
  "bè",
  "lầu",
  "xanh",
  "đỏ",
  "tím",
  "vàng",
  "kim",
  "chỉ",
  "khâu",
  "may",
  "vá",
  "em",
  "anh",
  "yêu",
  "thương",
  "thích",
  "con",
  "cái",
  "bàn",
  "ghế",
  "tủ",
  "quần",
  "áo",
  "nón",
  "dép",
  "giày",
  "lỗi",
  "được",
  "ghét",
  "giết",
  "chết",
  "hết",
  "tôi",
  "bạn",
  "tui",
  "trời",
  "trăng",
  "mây",
  "gió",
  "máy",
  "hàng",
  "hóa",
  "leo",
  "núi",
  "bơi",
  "biển",
  "chìm",
  "xuồng",
  "nước",
  "ngọt",
  "ruộng",
  "đồng",
  "quê",
  "hương"
];
module.exports = [
  'An Bình',
  'An Di',
  'An Hạ',
  'An Hằng',
  'An Khê',
  'An Nhiên',
  'An Nhàn',
  'Anh Chi',
  'Anh Hương',
  'Anh Mai',
  'Anh Phương',
  'Anh Thi',
  'Anh Thy',
  'Anh Thơ',
  'Anh Thư',
  'Anh Thảo',
  'Anh Vũ',
  'Anh Ðào',
  'Ban Mai',
  'Bình Minh',
  'Bình Yên',
  'Bích Chiêu',
  'Bích Châu',
  'Bích Duyên',
  'Bích Hiền',
  'Bích Huệ',
  'Bích Hà',
  'Bích Hạnh',
  'Bích Hải',
  'Bích Hảo',
  'Bích Hậu',
  'Bích Hằng',
  'Bích Hồng',
  'Bích Hợp',
  'Bích Lam',
  'Bích Liên',
  'Bích Loan',
  'Bích Nga',
  'Bích Ngà',
  'Bích Ngân',
  'Bích Ngọc',
  'Bích Như',
  'Bích Phượng',
  'Bích Quyên',
  'Bích Quân',
  'Bích San',
  'Bích Thoa',
  'Bích Thu',
  'Bích Thảo',
  'Bích Thủy',
  'Bích Trang',
  'Bích Trâm',
  'Bích Ty',
  'Bích Vân',
  'Bích Ðiệp',
  'Bích Ðào',
  'Băng Băng',
  'Băng Tâm',
  'Bạch Cúc',
  'Bạch Hoa',
  'Bạch Kim',
  'Bạch Liên',
  'Bạch Loan',
  'Bạch Mai',
  'Bạch Quỳnh',
  'Bạch Trà',
  'Bạch Tuyết',
  'Bạch Vân',
  'Bạch Yến',
  'Bảo Anh',
  'Bảo Bình',
  'Bảo Châu',
  'Bảo Huệ',
  'Bảo Hà',
  'Bảo Hân',
  'Bảo Lan',
  'Bảo Lễ',
  'Bảo Ngọc',
  'Bảo Phương',
  'Bảo Quyên',
  'Bảo Quỳnh',
  'Bảo Thoa',
  'Bảo Thúy',
  'Bảo Tiên',
  'Bảo Trâm',
  'Bảo Trân',
  'Bảo Trúc',
  'Bảo Uyên',
  'Bảo Vy',
  'Bảo Vân',
  'Bội Linh',
  'Cam Thảo',
  'Chi Lan',
  'Chi Mai',
  'Chiêu Dương',
  'Cát Cát',
  'Cát Linh',
  'Cát Ly',
  'Cát Tiên',
  'Cát Tường',
  'Cẩm Hiền',
  'Cẩm Hường',
  'Cẩm Hạnh',
  'Cẩm Linh',
  'Cẩm Liên',
  'Cẩm Ly',
  'Cẩm Nhi',
  'Cẩm Nhung',
  'Cẩm Thúy',
  'Cẩm Tú',
  'Cẩm Vân',
  'Cẩm Yến',
  'Di Nhiên',
  'Diên Vỹ',
  'Diễm Chi',
  'Diễm Châu',
  'Diễm Hương',
  'Diễm Hạnh',
  'Diễm Hằng',
  'Diễm Khuê',
  'Diễm Kiều',
  'Diễm Liên',
  'Diễm Lộc',
  'Diễm My',
  'Diễm Phúc',
  'Diễm Phương',
  'Diễm Phước',
  'Diễm Phượng',
  'Diễm Quyên',
  'Diễm Quỳnh',
  'Diễm Thúy',
  'Diễm Thư',
  'Diễm Thảo',
  'Diễm Trang',
  'Diễm Trinh',
  'Diễm Uyên',
  'Diệp Anh',
  'Diệp Vy',
  'Diệu Anh',
  'Diệu Hiền',
  'Diệu Hoa',
  'Diệu Huyền',
  'Diệu Hương',
  'Diệu Hạnh',
  'Diệu Hằng',
  'Diệu Hồng',
  'Diệu Lan',
  'Diệu Linh',
  'Diệu Loan',
  'Diệu Nga',
  'Diệu Ngà',
  'Diệu Ngọc',
  'Diệu Nương',
  'Diệu Thiện',
  'Diệu Thúy',
  'Diệu Vân',
  'Diệu Ái',
  'Duy Hạnh',
  'Duy Mỹ',
  'Duy Uyên',
  'Duyên Hồng',
  'Duyên My',
  'Duyên Mỹ',
  'Duyên Nương',
  'Dã Lan',
  'Dã Lâm',
  'Dã Thảo',
  'Dạ Hương',
  'Dạ Lan',
  'Dạ Nguyệt',
  'Dạ Thi',
  'Dạ Thảo',
  'Dạ Yến',
  'Gia Hân',
  'Gia Khanh',
  'Gia Linh',
  'Gia Nhi',
  'Gia Quỳnh',
  'Giang Thanh',
  'Giang Thiên',
  'Giao Hưởng',
  'Giao Kiều',
  'Giao Linh',
  'Giáng Ngọc',
  'Giáng Tiên',
  'Giáng Uyên',
  'Hiếu Giang',
  'Hiếu Hạnh',
  'Hiếu Khanh',
  'Hiếu Minh',
  'Hiền Chung',
  'Hiền Hòa',
  'Hiền Mai',
  'Hiền Nhi',
  'Hiền Nương',
  'Hiền Thục',
  'Hiểu Lam',
  'Hiểu Vân',
  'Hoa Liên',
  'Hoa Lý',
  'Hoa Thiên',
  'Hoa Tiên',
  'Hoa Tranh',
  'Hoài An',
  'Hoài Giang',
  'Hoài Hương',
  'Hoài Phương',
  'Hoài Thương',
  'Hoài Trang',
  'Hoài Vỹ',
  'Hoàn Châu',
  'Hoàn Vi',
  'Hoàng Cúc',
  'Hoàng Hà',
  'Hoàng Kim',
  'Hoàng Lan',
  'Hoàng Mai',
  'Hoàng Miên',
  'Hoàng Nguyên',
  'Hoàng Oanh',
  'Hoàng Sa',
  'Hoàng Thư',
  'Hoàng Xuân',
  'Hoàng Yến',
  'Hoạ Mi',
  'Huyền Anh',
  'Huyền Diệu',
  'Huyền Linh',
  'Huyền Ngọc',
  'Huyền Nhi',
  'Huyền Thoại',
  'Huyền Thư',
  'Huyền Trang',
  'Huyền Trâm',
  'Huyền Trân',
  'Huệ An',
  'Huệ Hương',
  'Huệ Hồng',
  'Huệ Lan',
  'Huệ Linh',
  'Huệ Lâm',
  'Huệ My',
  'Huệ Phương',
  'Huệ Thương',
  'Huệ Ân',
  'Huỳnh Anh',
  'Hà Giang',
  'Hà Liên',
  'Hà Mi',
  'Hà My',
  'Hà Nhi',
  'Hà Phương',
  'Hà Thanh',
  'Hà Tiên',
  'Hàm Duyên',
  'Hàm Nghi',
  'Hàm Thơ',
  'Hàm Ý',
  'Hương Chi',
  'Hương Giang',
  'Hương Lan',
  'Hương Liên',
  'Hương Ly',
  'Hương Lâm',
  'Hương Mai',
  'Hương Nhi',
  'Hương Thu',
  'Hương Thảo',
  'Hương Thủy',
  'Hương Tiên',
  'Hương Trang',
  'Hương Trà',
  'Hương Xuân',
  'Hướng Dương',
  'Hạ Băng',
  'Hạ Giang',
  'Hạ Phương',
  'Hạ Tiên',
  'Hạ Uyên',
  'Hạ Vy',
  'Hạc Cúc',
  'Hạnh Chi',
  'Hạnh Dung',
  'Hạnh Linh',
  'Hạnh My',
  'Hạnh Nga',
  'Hạnh Nhơn',
  'Hạnh Phương',
  'Hạnh San',
  'Hạnh Thảo',
  'Hạnh Trang',
  'Hạnh Vi',
  'Hải Anh',
  'Hải Châu',
  'Hải Duyên',
  'Hải Dương',
  'Hải Miên',
  'Hải My',
  'Hải Mỹ',
  'Hải Ngân',
  'Hải Nhi',
  'Hải Phương',
  'Hải Phượng',
  'Hải San',
  'Hải Sinh',
  'Hải Thanh',
  'Hải Thảo',
  'Hải Thụy',
  'Hải Uyên',
  'Hải Vy',
  'Hải Vân',
  'Hải Yến',
  'Hải Ân',
  'Hải Ðường',
  'Hảo Nhi',
  'Hằng Anh',
  'Hằng Nga',
  'Họa Mi',
  'Hồ Diệp',
  'Hồng Anh',
  'Hồng Bạch Thảo',
  'Hồng Châu',
  'Hồng Diễm',
  'Hồng Giang',
  'Hồng Hoa',
  'Hồng Hà',
  'Hồng Hạnh',
  'Hồng Khanh',
  'Hồng Khuê',
  'Hồng Khôi',
  'Hồng Linh',
  'Hồng Liên',
  'Hồng Lâm',
  'Hồng Mai',
  'Hồng Nga',
  'Hồng Ngân',
  'Hồng Ngọc',
  'Hồng Nhung',
  'Hồng Như',
  'Hồng Nhạn',
  'Hồng Oanh',
  'Hồng Phúc',
  'Hồng Phương',
  'Hồng Quế',
  'Hồng Thu',
  'Hồng Thúy',
  'Hồng Thư',
  'Hồng Thảo',
  'Hồng Thắm',
  'Hồng Thủy',
  'Hồng Trúc',
  'Hồng Tâm',
  'Hồng Vân',
  'Hồng Xuân',
  'Hồng Ðiệp',
  'Hồng Ðào',
  'Hồng Đăng',
  'Khiết Linh',
  'Khiết Tâm',
  'Khuê Trung',
  'Khánh Chi',
  'Khánh Giang',
  'Khánh Giao',
  'Khánh Huyền',
  'Khánh Hà',
  'Khánh Hằng',
  'Khánh Linh',
  'Khánh Ly',
  'Khánh Mai',
  'Khánh My',
  'Khánh Ngân',
  'Khánh Ngọc',
  'Khánh Quyên',
  'Khánh Quỳnh',
  'Khánh Thủy',
  'Khánh Trang',
  'Khánh Vi',
  'Khánh Vy',
  'Khánh Vân',
  'Khúc Lan',
  'Khả Khanh',
  'Khả Tú',
  'Khả Ái',
  'Khải Ca',
  'Khải Hà',
  'Khải Tâm',
  'Kim Anh',
  'Kim Chi',
  'Kim Cương',
  'Kim Dung',
  'Kim Duyên',
  'Kim Hoa',
  'Kim Hương',
  'Kim Khanh',
  'Kim Khuyên',
  'Kim Khánh',
  'Kim Lan',
  'Kim Liên',
  'Kim Loan',
  'Kim Ly',
  'Kim Mai',
  'Kim Ngân',
  'Kim Ngọc',
  'Kim Oanh',
  'Kim Phượng',
  'Kim Quyên',
  'Kim Sa',
  'Kim Thanh',
  'Kim Thoa',
  'Kim Thu',
  'Kim Thy',
  'Kim Thông',
  'Kim Thư',
  'Kim Thảo',
  'Kim Thủy',
  'Kim Trang',
  'Kim Tuyến',
  'Kim Tuyết',
  'Kim Tuyền',
  'Kim Xuyến',
  'Kim Xuân',
  'Kim Yến',
  'Kim Ánh',
  'Kim Đan',
  'Kiết Hồng',
  'Kiết Trinh',
  'Kiều Anh',
  'Kiều Diễm',
  'Kiều Dung',
  'Kiều Giang',
  'Kiều Hoa',
  'Kiều Hạnh',
  'Kiều Khanh',
  'Kiều Loan',
  'Kiều Mai',
  'Kiều Minh',
  'Kiều Mỹ',
  'Kiều Nga',
  'Kiều Nguyệt',
  'Kiều Nương',
  'Kiều Thu',
  'Kiều Trang',
  'Kiều Trinh',
  'Kỳ Anh',
  'Kỳ Diệu',
  'Kỳ Duyên',
  'Lam Giang',
  'Lam Hà',
  'Lam Khê',
  'Lam Ngọc',
  'Lam Tuyền',
  'Lan Anh',
  'Lan Chi',
  'Lan Hương',
  'Lan Khuê',
  'Lan Ngọc',
  'Lan Nhi',
  'Lan Phương',
  'Lan Thương',
  'Lan Trúc',
  'Lan Vy',
  'Linh Chi',
  'Linh Châu',
  'Linh Duyên',
  'Linh Giang',
  'Linh Hà',
  'Linh Lan',
  'Linh Nhi',
  'Linh Phương',
  'Linh Phượng',
  'Linh San',
  'Linh Trang',
  'Linh Ðan',
  'Liên Chi',
  'Liên Hoa',
  'Liên Hương',
  'Liên Như',
  'Liên Phương',
  'Liên Trân',
  'Liễu Oanh',
  'Loan Châu',
  'Ly Châu',
  'Lâm Nhi',
  'Lâm Oanh',
  'Lâm Tuyền',
  'Lâm Uyên',
  'Lê Quỳnh',
  'Lưu Ly',
  'Lệ Băng',
  'Lệ Chi',
  'Lệ Giang',
  'Lệ Hoa',
  'Lệ Huyền',
  'Lệ Khanh',
  'Lệ Nga',
  'Lệ Nhi',
  'Lệ Quyên',
  'Lệ Quân',
  'Lệ Thanh',
  'Lệ Thu',
  'Lệ Thủy',
  'Lộc Uyên',
  'Lộc Uyển',
  'Lục Bình',
  'Mai Anh',
  'Mai Chi',
  'Mai Châu',
  'Mai Hiền',
  'Mai Hà',
  'Mai Hương',
  'Mai Hạ',
  'Mai Khanh',
  'Mai Khôi',
  'Mai Lan',
  'Mai Linh',
  'Mai Liên',
  'Mai Loan',
  'Mai Ly',
  'Mai Nhi',
  'Mai Phương',
  'Mai Quyên',
  'Mai Thanh',
  'Mai Thu',
  'Mai Thy',
  'Mai Thảo',
  'Mai Trinh',
  'Mai Tâm',
  'Mai Vy',
  'Minh An',
  'Minh Châu',
  'Minh Duyên',
  'Minh Hiền',
  'Minh Huyền',
  'Minh Huệ',
  'Minh Hà',
  'Minh Hương',
  'Minh Hạnh',
  'Minh Hằng',
  'Minh Hồng',
  'Minh Khai',
  'Minh Khuê',
  'Minh Loan',
  'Minh Minh',
  'Minh Nguyệt',
  'Minh Ngọc',
  'Minh Nhi',
  'Minh Như',
  'Minh Phương',
  'Minh Phượng',
  'Minh Thu',
  'Minh Thúy',
  'Minh Thư',
  'Minh Thương',
  'Minh Thảo',
  'Minh Thủy',
  'Minh Trang',
  'Minh Tuyết',
  'Minh Tuệ',
  'Minh Tâm',
  'Minh Uyên',
  'Minh Vy',
  'Minh Xuân',
  'Minh Yến',
  'Minh Đan',
  'Mậu Xuân',
  'Mộc Miên',
  'Mộng Hoa',
  'Mộng Hương',
  'Mộng Hằng',
  'Mộng Lan',
  'Mộng Liễu',
  'Mộng Nguyệt',
  'Mộng Nhi',
  'Mộng Quỳnh',
  'Mộng Thi',
  'Mộng Thu',
  'Mộng Tuyền',
  'Mộng Vi',
  'Mộng Vy',
  'Mộng Vân',
  'Mộng Ðiệp',
  'Mỹ Anh',
  'Mỹ Diễm',
  'Mỹ Dung',
  'Mỹ Duyên',
  'Mỹ Hiệp',
  'Mỹ Hoàn',
  'Mỹ Huyền',
  'Mỹ Huệ',
  'Mỹ Hường',
  'Mỹ Hạnh',
  'Mỹ Khuyên',
  'Mỹ Kiều',
  'Mỹ Lan',
  'Mỹ Loan',
  'Mỹ Lệ',
  'Mỹ Lợi',
  'Mỹ Nga',
  'Mỹ Ngọc',
  'Mỹ Nhi',
  'Mỹ Nhân',
  'Mỹ Nương',
  'Mỹ Phương',
  'Mỹ Phượng',
  'Mỹ Phụng',
  'Mỹ Thuần',
  'Mỹ Thuận',
  'Mỹ Trang',
  'Mỹ Trâm',
  'Mỹ Tâm',
  'Mỹ Uyên',
  'Mỹ Vân',
  'Mỹ Xuân',
  'Mỹ Yến',
  'Nghi Dung',
  'Nghi Minh',
  'Nghi Xuân',
  'Nguyên Hồng',
  'Nguyên Thảo',
  'Nguyết Ánh',
  'Nguyệt Anh',
  'Nguyệt Cát',
  'Nguyệt Cầm',
  'Nguyệt Hà',
  'Nguyệt Hồng',
  'Nguyệt Lan',
  'Nguyệt Minh',
  'Nguyệt Nga',
  'Nguyệt Quế',
  'Nguyệt Uyển',
  'Nguyệt Ánh',
  'Ngân Anh',
  'Ngân Hà',
  'Ngân Thanh',
  'Ngân Trúc',
  'Ngọc Anh',
  'Ngọc Bích',
  'Ngọc Cầm',
  'Ngọc Diệp',
  'Ngọc Dung',
  'Ngọc Hiền',
  'Ngọc Hoa',
  'Ngọc Hoan',
  'Ngọc Hoàn',
  'Ngọc Huyền',
  'Ngọc Huệ',
  'Ngọc Hà',
  'Ngọc Hân',
  'Ngọc Hạ',
  'Ngọc Hạnh',
  'Ngọc Hằng',
  'Ngọc Khanh',
  'Ngọc Khuê',
  'Ngọc Khánh',
  'Ngọc Lam',
  'Ngọc Lan',
  'Ngọc Linh',
  'Ngọc Liên',
  'Ngọc Loan',
  'Ngọc Ly',
  'Ngọc Lâm',
  'Ngọc Lý',
  'Ngọc Lệ',
  'Ngọc Mai',
  'Ngọc Nhi',
  'Ngọc Nữ',
  'Ngọc Oanh',
  'Ngọc Phụng',
  'Ngọc Quyên',
  'Ngọc Quế',
  'Ngọc Quỳnh',
  'Ngọc San',
  'Ngọc Sương',
  'Ngọc Thi',
  'Ngọc Thy',
  'Ngọc Thơ',
  'Ngọc Trinh',
  'Ngọc Trâm',
  'Ngọc Tuyết',
  'Ngọc Tâm',
  'Ngọc Tú',
  'Ngọc Uyên',
  'Ngọc Uyển',
  'Ngọc Vy',
  'Ngọc Vân',
  'Ngọc Yến',
  'Ngọc Ái',
  'Ngọc Ánh',
  'Ngọc Ðiệp',
  'Ngọc Ðàn',
  'Ngọc Ðào',
  'Nhan Hồng',
  'Nhã Hương',
  'Nhã Hồng',
  'Nhã Khanh',
  'Nhã Lý',
  'Nhã Mai',
  'Nhã Sương',
  'Nhã Thanh',
  'Nhã Trang',
  'Nhã Trúc',
  'Nhã Uyên',
  'Nhã Yến',
  'Nhã Ý',
  'Như Anh',
  'Như Bảo',
  'Như Hoa',
  'Như Hảo',
  'Như Hồng',
  'Như Loan',
  'Như Mai',
  'Như Ngà',
  'Như Ngọc',
  'Như Phương',
  'Như Quân',
  'Như Quỳnh',
  'Như Thảo',
  'Như Trân',
  'Như Tâm',
  'Như Ý',
  'Nhất Thương',
  'Nhật Dạ',
  'Nhật Hà',
  'Nhật Hạ',
  'Nhật Lan',
  'Nhật Linh',
  'Nhật Lệ',
  'Nhật Mai',
  'Nhật Phương',
  'Nhật Ánh',
  'Oanh Thơ',
  'Oanh Vũ',
  'Phi Khanh',
  'Phi Nhung',
  'Phi Nhạn',
  'Phi Phi',
  'Phi Phượng',
  'Phong Lan',
  'Phương An',
  'Phương Anh',
  'Phương Chi',
  'Phương Châu',
  'Phương Diễm',
  'Phương Dung',
  'Phương Giang',
  'Phương Hiền',
  'Phương Hoa',
  'Phương Hạnh',
  'Phương Lan',
  'Phương Linh',
  'Phương Liên',
  'Phương Loan',
  'Phương Mai',
  'Phương Nghi',
  'Phương Ngọc',
  'Phương Nhi',
  'Phương Nhung',
  'Phương Phương',
  'Phương Quyên',
  'Phương Quân',
  'Phương Quế',
  'Phương Quỳnh',
  'Phương Thanh',
  'Phương Thi',
  'Phương Thùy',
  'Phương Thảo',
  'Phương Thủy',
  'Phương Trang',
  'Phương Trinh',
  'Phương Trà',
  'Phương Trâm',
  'Phương Tâm',
  'Phương Uyên',
  'Phương Yến',
  'Phước Bình',
  'Phước Huệ',
  'Phượng Bích',
  'Phượng Liên',
  'Phượng Loan',
  'Phượng Lệ',
  'Phượng Nga',
  'Phượng Nhi',
  'Phượng Tiên',
  'Phượng Uyên',
  'Phượng Vy',
  'Phượng Vũ',
  'Phụng Yến',
  'Quế Anh',
  'Quế Chi',
  'Quế Linh',
  'Quế Lâm',
  'Quế Phương',
  'Quế Thu',
  'Quỳnh Anh',
  'Quỳnh Chi',
  'Quỳnh Dao',
  'Quỳnh Dung',
  'Quỳnh Giang',
  'Quỳnh Giao',
  'Quỳnh Hoa',
  'Quỳnh Hà',
  'Quỳnh Hương',
  'Quỳnh Lam',
  'Quỳnh Liên',
  'Quỳnh Lâm',
  'Quỳnh Nga',
  'Quỳnh Ngân',
  'Quỳnh Nhi',
  'Quỳnh Nhung',
  'Quỳnh Như',
  'Quỳnh Phương',
  'Quỳnh Sa',
  'Quỳnh Thanh',
  'Quỳnh Thơ',
  'Quỳnh Tiên',
  'Quỳnh Trang',
  'Quỳnh Trâm',
  'Quỳnh Vân',
  'Sao Băng',
  'Sao Mai',
  'Song Kê',
  'Song Lam',
  'Song Oanh',
  'Song Thư',
  'Sông Hà',
  'Sông Hương',
  'Sơn Ca',
  'Sơn Tuyền',
  'Sương Sương',
  'Thanh Bình',
  'Thanh Dân',
  'Thanh Giang',
  'Thanh Hiếu',
  'Thanh Hiền',
  'Thanh Hoa',
  'Thanh Huyền',
  'Thanh Hà',
  'Thanh Hương',
  'Thanh Hường',
  'Thanh Hạnh',
  'Thanh Hảo',
  'Thanh Hằng',
  'Thanh Hồng',
  'Thanh Kiều',
  'Thanh Lam',
  'Thanh Lan',
  'Thanh Loan',
  'Thanh Lâm',
  'Thanh Mai',
  'Thanh Mẫn',
  'Thanh Nga',
  'Thanh Nguyên',
  'Thanh Ngân',
  'Thanh Ngọc',
  'Thanh Nhung',
  'Thanh Nhàn',
  'Thanh Nhã',
  'Thanh Phương',
  'Thanh Thanh',
  'Thanh Thiên',
  'Thanh Thu',
  'Thanh Thúy',
  'Thanh Thư',
  'Thanh Thảo',
  'Thanh Thủy',
  'Thanh Trang',
  'Thanh Trúc',
  'Thanh Tuyết',
  'Thanh Tuyền',
  'Thanh Tâm',
  'Thanh Uyên',
  'Thanh Vy',
  'Thanh Vân',
  'Thanh Xuân',
  'Thanh Yến',
  'Thanh Đan',
  'Thi Cầm',
  'Thi Ngôn',
  'Thi Thi',
  'Thi Xuân',
  'Thi Yến',
  'Thiên Di',
  'Thiên Duyên',
  'Thiên Giang',
  'Thiên Hà',
  'Thiên Hương',
  'Thiên Khánh',
  'Thiên Kim',
  'Thiên Lam',
  'Thiên Lan',
  'Thiên Mai',
  'Thiên Mỹ',
  'Thiên Nga',
  'Thiên Nương',
  'Thiên Phương',
  'Thiên Thanh',
  'Thiên Thêu',
  'Thiên Thư',
  'Thiên Thảo',
  'Thiên Trang',
  'Thiên Tuyền',
  'Thiếu Mai',
  'Thiều Ly',
  'Thiện Mỹ',
  'Thiện Tiên',
  'Thu Duyên',
  'Thu Giang',
  'Thu Hiền',
  'Thu Hoài',
  'Thu Huyền',
  'Thu Huệ',
  'Thu Hà',
  'Thu Hậu',
  'Thu Hằng',
  'Thu Hồng',
  'Thu Linh',
  'Thu Liên',
  'Thu Loan',
  'Thu Mai',
  'Thu Minh',
  'Thu Nga',
  'Thu Nguyệt',
  'Thu Ngà',
  'Thu Ngân',
  'Thu Ngọc',
  'Thu Nhiên',
  'Thu Oanh',
  'Thu Phong',
  'Thu Phương',
  'Thu Phượng',
  'Thu Sương',
  'Thu Thuận',
  'Thu Thảo',
  'Thu Thủy',
  'Thu Trang',
  'Thu Việt',
  'Thu Vân',
  'Thu Vọng',
  'Thu Yến',
  'Thuần Hậu',
  'Thy Khanh',
  'Thy Oanh',
  'Thy Trúc',
  'Thy Vân',
  'Thái Chi',
  'Thái Hà',
  'Thái Hồng',
  'Thái Lan',
  'Thái Lâm',
  'Thái Thanh',
  'Thái Thảo',
  'Thái Tâm',
  'Thái Vân',
  'Thùy Anh',
  'Thùy Dung',
  'Thùy Dương',
  'Thùy Giang',
  'Thùy Linh',
  'Thùy Mi',
  'Thùy My',
  'Thùy Nhi',
  'Thùy Như',
  'Thùy Oanh',
  'Thùy Uyên',
  'Thùy Vân',
  'Thúy Anh',
  'Thúy Diễm',
  'Thúy Hiền',
  'Thúy Huyền',
  'Thúy Hà',
  'Thúy Hương',
  'Thúy Hường',
  'Thúy Hạnh',
  'Thúy Hằng',
  'Thúy Kiều',
  'Thúy Liên',
  'Thúy Liễu',
  'Thúy Loan',
  'Thúy Mai',
  'Thúy Minh',
  'Thúy My',
  'Thúy Nga',
  'Thúy Ngà',
  'Thúy Ngân',
  'Thúy Ngọc',
  'Thúy Phượng',
  'Thúy Quỳnh',
  'Thúy Vi',
  'Thúy Vy',
  'Thúy Vân',
  'Thơ Thơ',
  'Thư Lâm',
  'Thư Sương',
  'Thương Huyền',
  'Thương Nga',
  'Thương Thương',
  'Thường Xuân',
  'Thạch Thảo',
  'Thảo Hương',
  'Thảo Hồng',
  'Thảo Linh',
  'Thảo Ly',
  'Thảo Mai',
  'Thảo My',
  'Thảo Nghi',
  'Thảo Nguyên',
  'Thảo Nhi',
  'Thảo Quyên',
  'Thảo Tiên',
  'Thảo Trang',
  'Thảo Uyên',
  'Thảo Vy',
  'Thảo Vân',
  'Thục Anh',
  'Thục Khuê',
  'Thục Nhi',
  'Thục Oanh',
  'Thục Quyên',
  'Thục Trang',
  'Thục Trinh',
  'Thục Tâm',
  'Thục Uyên',
  'Thục Vân',
  'Thục Ðoan',
  'Thục Ðào',
  'Thục Ðình',
  'Thụy Du',
  'Thụy Khanh',
  'Thụy Linh',
  'Thụy Lâm',
  'Thụy Miên',
  'Thụy Nương',
  'Thụy Trinh',
  'Thụy Trâm',
  'Thụy Uyên',
  'Thụy Vân',
  'Thụy Ðào',
  'Thủy Hằng',
  'Thủy Hồng',
  'Thủy Linh',
  'Thủy Minh',
  'Thủy Nguyệt',
  'Thủy Quỳnh',
  'Thủy Tiên',
  'Thủy Trang',
  'Thủy Tâm',
  'Tinh Tú',
  'Tiên Phương',
  'Tiểu Mi',
  'Tiểu My',
  'Tiểu Quỳnh',
  'Trang Anh',
  'Trang Linh',
  'Trang Nhã',
  'Trang Tâm',
  'Trang Ðài',
  'Triều Nguyệt',
  'Triều Thanh',
  'Triệu Mẫn',
  'Trung Anh',
  'Trà Giang',
  'Trà My',
  'Trâm Anh',
  'Trâm Oanh',
  'Trân Châu',
  'Trúc Chi',
  'Trúc Lam',
  'Trúc Lan',
  'Trúc Linh',
  'Trúc Liên',
  'Trúc Loan',
  'Trúc Ly',
  'Trúc Lâm',
  'Trúc Mai',
  'Trúc Phương',
  'Trúc Quân',
  'Trúc Quỳnh',
  'Trúc Vy',
  'Trúc Vân',
  'Trúc Ðào',
  'Trúc Đào',
  'Trầm Hương',
  'Tuyết Anh',
  'Tuyết Băng',
  'Tuyết Chi',
  'Tuyết Hoa',
  'Tuyết Hân',
  'Tuyết Hương',
  'Tuyết Hồng',
  'Tuyết Lan',
  'Tuyết Loan',
  'Tuyết Lâm',
  'Tuyết Mai',
  'Tuyết Nga',
  'Tuyết Nhi',
  'Tuyết Nhung',
  'Tuyết Oanh',
  'Tuyết Thanh',
  'Tuyết Trinh',
  'Tuyết Trầm',
  'Tuyết Tâm',
  'Tuyết Vy',
  'Tuyết Vân',
  'Tuyết Xuân',
  'Tuyền Lâm',
  'Tuệ Lâm',
  'Tuệ Mẫn',
  'Tuệ Nhi',
  'Tâm Hiền',
  'Tâm Hạnh',
  'Tâm Hằng',
  'Tâm Khanh',
  'Tâm Linh',
  'Tâm Nguyên',
  'Tâm Nguyệt',
  'Tâm Nhi',
  'Tâm Như',
  'Tâm Thanh',
  'Tâm Trang',
  'Tâm Ðoan',
  'Tâm Đan',
  'Tùng Linh',
  'Tùng Lâm',
  'Tùng Quân',
  'Tùy Anh',
  'Tùy Linh',
  'Tú Anh',
  'Tú Ly',
  'Tú Nguyệt',
  'Tú Quyên',
  'Tú Quỳnh',
  'Tú Sương',
  'Tú Trinh',
  'Tú Tâm',
  'Tú Uyên',
  'Túy Loan',
  'Tường Chinh',
  'Tường Vi',
  'Tường Vy',
  'Tường Vân',
  'Tịnh Lâm',
  'Tịnh Nhi',
  'Tịnh Như',
  'Tịnh Tâm',
  'Tịnh Yên',
  'Tố Loan',
  'Tố Nga',
  'Tố Nhi',
  'Tố Quyên',
  'Tố Tâm',
  'Tố Uyên',
  'Từ Dung',
  'Từ Ân',
  'Uyên Minh',
  'Uyên My',
  'Uyên Nhi',
  'Uyên Phương',
  'Uyên Thi',
  'Uyên Thy',
  'Uyên Thơ',
  'Uyên Trâm',
  'Uyên Vi',
  'Uyển Khanh',
  'Uyển My',
  'Uyển Nghi',
  'Uyển Nhi',
  'Uyển Nhã',
  'Uyển Như',
  'Vi Quyên',
  'Vinh Diệu',
  'Việt Hà',
  'Việt Hương',
  'Việt Khuê',
  'Việt Mi',
  'Việt Nga',
  'Việt Nhi',
  'Việt Thi',
  'Việt Trinh',
  'Việt Tuyết',
  'Việt Yến',
  'Vy Lam',
  'Vy Lan',
  'Vàng Anh',
  'Vành Khuyên',
  'Vân Anh',
  'Vân Chi',
  'Vân Du',
  'Vân Hà',
  'Vân Hương',
  'Vân Khanh',
  'Vân Khánh',
  'Vân Linh',
  'Vân Ngọc',
  'Vân Nhi',
  'Vân Phi',
  'Vân Phương',
  'Vân Quyên',
  'Vân Quỳnh',
  'Vân Thanh',
  'Vân Thúy',
  'Vân Thường',
  'Vân Tiên',
  'Vân Trang',
  'Vân Trinh',
  'Vũ Hồng',
  'Xuyến Chi',
  'Xuân Bảo',
  'Xuân Dung',
  'Xuân Hiền',
  'Xuân Hoa',
  'Xuân Hân',
  'Xuân Hương',
  'Xuân Hạnh',
  'Xuân Lan',
  'Xuân Linh',
  'Xuân Liễu',
  'Xuân Loan',
  'Xuân Lâm',
  'Xuân Mai',
  'Xuân Nghi',
  'Xuân Ngọc',
  'Xuân Nhi',
  'Xuân Nhiên',
  'Xuân Nương',
  'Xuân Phương',
  'Xuân Phượng',
  'Xuân Thanh',
  'Xuân Thu',
  'Xuân Thảo',
  'Xuân Thủy',
  'Xuân Trang',
  'Xuân Tâm',
  'Xuân Uyên',
  'Xuân Vân',
  'Xuân Yến',
  'Xuân xanh',
  'Yên Bằng',
  'Yên Mai',
  'Yên Nhi',
  'Yên Ðan',
  'Yên Đan',
  'Yến Anh',
  'Yến Hồng',
  'Yến Loan',
  'Yến Mai',
  'Yến My',
  'Yến Nhi',
  'Yến Oanh',
  'Yến Phương',
  'Yến Phượng',
  'Yến Thanh',
  'Yến Thảo',
  'Yến Trang',
  'Yến Trinh',
  'Yến Trâm',
  'Yến Ðan',
  'Ái Hồng',
  'Ái Khanh',
  'Ái Linh',
  'Ái Nhi',
  'Ái Nhân',
  'Ái Thi',
  'Ái Thy',
  'Ái Vân',
  'Ánh Dương',
  'Ánh Hoa',
  'Ánh Hồng',
  'Ánh Linh',
  'Ánh Lệ',
  'Ánh Mai',
  'Ánh Nguyệt',
  'Ánh Ngọc',
  'Ánh Thơ',
  'Ánh Trang',
  'Ánh Tuyết',
  'Ánh Xuân',
  'Ðan Khanh',
  'Ðan Quỳnh',
  'Đan Thu',
  'Ðinh Hương',
  'Ðoan Thanh',
  'Ðoan Trang',
  'Ðài Trang',
  'Ðông Nghi',
  'Ðông Nhi',
  'Ðông Trà',
  'Ðông Tuyền',
  'Ðông Vy',
  'Ðông Ðào',
  'Ðồng Dao',
  'Ý Bình',
  'Ý Lan',
  'Ý Nhi',
  'Đan Linh',
  'Đan Quỳnh',
  'Đan Thanh',
  'Đan Thu',
  'Đan Thư',
  'Đan Tâm',
  'Đinh Hương',
  'Đoan Thanh',
  'Đoan Trang',
  'Đài Trang',
  'Đông Nghi',
  'Đông Trà',
  'Đông Tuyền',
  'Đông Vy',
  'Đơn Thuần',
  'Đức Hạnh',
  'Ấu Lăng',
];
const female_first_name = require('./female_first_name');
const male_first_name = require('./male_first_name');
module.exports = female_first_name.concat(male_first_name);
var name = {};
module['exports'] = name;
name.female_first_name = require('./female_first_name');
name.male_first_name = require('./male_first_name');
name.last_name = require('./last_name');
name.first_name = require('./first_name');
name.name = require('./name');
module["exports"] = [
  "Phạm",
  "Nguyễn",
  "Trần",
  "Lê",
  "Lý",
  "Hoàng",
  "Phan",
  "Vũ",
  "Tăng",
  "Đặng",
  "Bùi",
  "Đỗ",
  "Hồ",
  "Ngô",
  "Dương",
  "Đào",
  "Đoàn",
  "Vương",
  "Trịnh",
  "Đinh",
  "Lâm",
  "Phùng",
  "Mai",
  "Tô",
  "Trương",
  "Hà"
];
module.exports = [
  'An Cơ',
  'An Khang',
  'Ân Lai',
  'An Nam',
  'An Nguyên',
  'An Ninh',
  'An Tâm',
  'Ân Thiện',
  'An Tường',
  'Anh Ðức',
  'Anh Dũng',
  'Anh Duy',
  'Anh Hoàng',
  'Anh Khải',
  'Anh Khoa',
  'Anh Khôi',
  'Anh Minh',
  'Anh Quân',
  'Anh Quốc',
  'Anh Sơn',
  'Anh Tài',
  'Anh Thái',
  'Anh Tú',
  'Anh Tuấn',
  'Anh Tùng',
  'Anh Việt',
  'Anh Vũ',
  'Bá Cường',
  'Bá Kỳ',
  'Bá Lộc',
  'Bá Long',
  'Bá Phước',
  'Bá Thành',
  'Bá Thiện',
  'Bá Thịnh',
  'Bá Thúc',
  'Bá Trúc',
  'Bá Tùng',
  'Bách Du',
  'Bách Nhân',
  'Bằng Sơn',
  'Bảo An',
  'Bảo Bảo',
  'Bảo Chấn',
  'Bảo Ðịnh',
  'Bảo Duy',
  'Bảo Giang',
  'Bảo Hiển',
  'Bảo Hoa',
  'Bảo Hoàng',
  'Bảo Huy',
  'Bảo Huynh',
  'Bảo Huỳnh',
  'Bảo Khánh',
  'Bảo Lâm',
  'Bảo Long',
  'Bảo Pháp',
  'Bảo Quốc',
  'Bảo Sơn',
  'Bảo Thạch',
  'Bảo Thái',
  'Bảo Tín',
  'Bảo Toàn',
  'Bích Nhã',
  'Bình An',
  'Bình Dân',
  'Bình Ðạt',
  'Bình Ðịnh',
  'Bình Dương',
  'Bình Hòa',
  'Bình Minh',
  'Bình Nguyên',
  'Bình Quân',
  'Bình Thuận',
  'Bình Yên',
  'Bửu Chưởng',
  'Bửu Diệp',
  'Bữu Toại',
  'Cảnh Tuấn',
  'Cao Kỳ',
  'Cao Minh',
  'Cao Nghiệp',
  'Cao Nguyên',
  'Cao Nhân',
  'Cao Phong',
  'Cao Sĩ',
  'Cao Sơn',
  'Cao Sỹ',
  'Cao Thọ',
  'Cao Tiến',
  'Cát Tường',
  'Cát Uy',
  'Chấn Hùng',
  'Chấn Hưng',
  'Chấn Phong',
  'Chánh Việt',
  'Chế Phương',
  'Chí Anh',
  'Chí Bảo',
  'Chí Công',
  'Chí Dũng',
  'Chí Giang',
  'Chí Hiếu',
  'Chí Khang',
  'Chí Khiêm',
  'Chí Kiên',
  'Chí Nam',
  'Chí Sơn',
  'Chí Thanh',
  'Chí Thành',
  'Chiến Thắng',
  'Chiêu Minh',
  'Chiêu Phong',
  'Chiêu Quân',
  'Chính Tâm',
  'Chính Thuận',
  'Chính Trực',
  'Chuẩn Khoa',
  'Chung Thủy',
  'Công Án',
  'Công Ân',
  'Công Bằng',
  'Công Giang',
  'Công Hải',
  'Công Hào',
  'Công Hậu',
  'Công Hiếu',
  'Công Hoán',
  'Công Lập',
  'Công Lộc',
  'Công Luận',
  'Công Luật',
  'Công Lý',
  'Công Phụng',
  'Công Sinh',
  'Công Sơn',
  'Công Thành',
  'Công Tráng',
  'Công Tuấn',
  'Cường Dũng',
  'Cương Nghị',
  'Cương Quyết',
  'Cường Thịnh',
  'Ðắc Cường',
  'Ðắc Di',
  'Ðắc Lộ',
  'Ðắc Lực',
  'Ðắc Thái',
  'Ðắc Thành',
  'Ðắc Trọng',
  'Ðại Dương',
  'Ðại Hành',
  'Ðại Ngọc',
  'Ðại Thống',
  'Dân Hiệp',
  'Dân Khánh',
  'Ðan Quế',
  'Ðan Tâm',
  'Ðăng An',
  'Ðăng Ðạt',
  'Ðăng Khánh',
  'Ðăng Khoa',
  'Đăng Khương',
  'Ðăng Minh',
  'Đăng Quang',
  'Danh Nhân',
  'Danh Sơn',
  'Danh Thành',
  'Danh Văn',
  'Ðạt Dũng',
  'Ðạt Hòa',
  'Ðình Chiểu',
  'Ðình Chương',
  'Ðình Cường',
  'Ðình Diệu',
  'Ðình Ðôn',
  'Ðình Dương',
  'Ðình Hảo',
  'Ðình Hợp',
  'Ðình Kim',
  'Ðinh Lộc',
  'Ðình Lộc',
  'Ðình Luận',
  'Ðịnh Lực',
  'Ðình Nam',
  'Ðình Ngân',
  'Ðình Nguyên',
  'Ðình Nhân',
  'Ðình Phú',
  'Ðình Phúc',
  'Ðình Quảng',
  'Ðình Sang',
  'Ðịnh Siêu',
  'Ðình Thắng',
  'Ðình Thiện',
  'Ðình Toàn',
  'Ðình Trung',
  'Ðình Tuấn',
  'Ðoàn Tụ',
  'Ðồng Bằng',
  'Ðông Dương',
  'Ðông Hải',
  'Ðồng Khánh',
  'Ðông Nguyên',
  'Ðông Phong',
  'Ðông Phương',
  'Ðông Quân',
  'Ðông Sơn',
  'Ðức Ân',
  'Ðức Anh',
  'Ðức Bằng',
  'Ðức Bảo',
  'Ðức Bình',
  'Ðức Chính',
  'Ðức Duy',
  'Ðức Giang',
  'Ðức Hải',
  'Ðức Hạnh',
  'Đức Hòa',
  'Ðức Hòa',
  'Ðức Huy',
  'Ðức Khải',
  'Ðức Khang',
  'Ðức Khiêm',
  'Ðức Kiên',
  'Ðức Long',
  'Ðức Mạnh',
  'Ðức Minh',
  'Ðức Nhân',
  'Ðức Phi',
  'Ðức Phong',
  'Ðức Phú',
  'Ðức Quang',
  'Ðức Quảng',
  'Ðức Quyền',
  'Ðức Siêu',
  'Ðức Sinh',
  'Ðức Tài',
  'Ðức Tâm',
  'Ðức Thắng',
  'Ðức Thành',
  'Ðức Thọ',
  'Ðức Toàn',
  'Ðức Toản',
  'Ðức Trí',
  'Ðức Trung',
  'Ðức Tuấn',
  'Ðức Tuệ',
  'Ðức Tường',
  'Dũng Trí',
  'Dũng Việt',
  'Dương Anh',
  'Dương Khánh',
  'Duy An',
  'Duy Bảo',
  'Duy Cẩn',
  'Duy Cường',
  'Duy Hải',
  'Duy Hiền',
  'Duy Hiếu',
  'Duy Hoàng',
  'Duy Hùng',
  'Duy Khang',
  'Duy Khánh',
  'Duy Khiêm',
  'Duy Kính',
  'Duy Luận',
  'Duy Mạnh',
  'Duy Minh',
  'Duy Ngôn',
  'Duy Nhượng',
  'Duy Quang',
  'Duy Tâm',
  'Duy Tân',
  'Duy Thạch',
  'Duy Thắng',
  'Duy Thanh',
  'Duy Thành',
  'Duy Thông',
  'Duy Tiếp',
  'Duy Tuyền',
  'Gia Ân',
  'Gia Anh',
  'Gia Bạch',
  'Gia Bảo',
  'Gia Bình',
  'Gia Cần',
  'Gia Cẩn',
  'Gia Cảnh',
  'Gia Ðạo',
  'Gia Ðức',
  'Gia Hiệp',
  'Gia Hòa',
  'Gia Hoàng',
  'Gia Huấn',
  'Gia Hùng',
  'Gia Hưng',
  'Gia Huy',
  'Gia Khánh',
  'Gia Khiêm',
  'Gia Kiên',
  'Gia Kiệt',
  'Gia Lập',
  'Gia Minh',
  'Gia Nghị',
  'Gia Phong',
  'Gia Phúc',
  'Gia Phước',
  'Gia Thiện',
  'Gia Thịnh',
  'Gia Uy',
  'Gia Vinh',
  'Giang Lam',
  'Giang Nam',
  'Giang Sơn',
  'Giang Thiên',
  'Hà Hải',
  'Hải Bằng',
  'Hải Bình',
  'Hải Ðăng',
  'Hải Dương',
  'Hải Giang',
  'Hải Hà',
  'Hải Long',
  'Hải Lý',
  'Hải Nam',
  'Hải Nguyên',
  'Hải Phong',
  'Hải Quân',
  'Hải Sơn',
  'Hải Thụy',
  'Hán Lâm',
  'Hạnh Tường',
  'Hào Nghiệp',
  'Hạo Nhiên',
  'Hiền Minh',
  'Hiệp Dinh',
  'Hiệp Hà',
  'Hiệp Hào',
  'Hiệp Hiền',
  'Hiệp Hòa',
  'Hiệp Vũ',
  'Hiếu Dụng',
  'Hiếu Học',
  'Hiểu Lam',
  'Hiếu Liêm',
  'Hiếu Nghĩa',
  'Hiếu Phong',
  'Hiếu Thông',
  'Hồ Bắc',
  'Hồ Nam',
  'Hòa Bình',
  'Hòa Giang',
  'Hòa Hiệp',
  'Hòa Hợp',
  'Hòa Lạc',
  'Hòa Thái',
  'Hoài Bắc',
  'Hoài Nam',
  'Hoài Phong',
  'Hoài Thanh',
  'Hoài Tín',
  'Hoài Trung',
  'Hoài Việt',
  'Hoài Vỹ',
  'Hoàn Kiếm',
  'Hoàn Vũ',
  'Hoàng Ân',
  'Hoàng Duệ',
  'Hoàng Dũng',
  'Hoàng Giang',
  'Hoàng Hải',
  'Hoàng Hiệp',
  'Hoàng Khải',
  'Hoàng Khang',
  'Hoàng Khôi',
  'Hoàng Lâm',
  'Hoàng Linh',
  'Hoàng Long',
  'Hoàng Minh',
  'Hoàng Mỹ',
  'Hoàng Nam',
  'Hoàng Ngôn',
  'Hoàng Phát',
  'Hoàng Quân',
  'Hoàng Thái',
  'Hoàng Việt',
  'Hoàng Xuân',
  'Hồng Ðăng',
  'Hồng Đức',
  'Hồng Giang',
  'Hồng Lân',
  'Hồng Liêm',
  'Hồng Lĩnh',
  'Hồng Minh',
  'Hồng Nhật',
  'Hồng Nhuận',
  'Hồng Phát',
  'Hồng Quang',
  'Hồng Quý',
  'Hồng Sơn',
  'Hồng Thịnh',
  'Hồng Thụy',
  'Hồng Việt',
  'Hồng Vinh',
  'Huân Võ',
  'Hùng Anh',
  'Hùng Cường',
  'Hưng Ðạo',
  'Hùng Dũng',
  'Hùng Ngọc',
  'Hùng Phong',
  'Hùng Sơn',
  'Hùng Thịnh',
  'Hùng Tường',
  'Hướng Bình',
  'Hướng Dương',
  'Hướng Thiện',
  'Hướng Tiền',
  'Hữu Bào',
  'Hữu Bảo',
  'Hữu Bình',
  'Hữu Canh',
  'Hữu Cảnh',
  'Hữu Châu',
  'Hữu Chiến',
  'Hữu Cương',
  'Hữu Cường',
  'Hữu Ðạt',
  'Hữu Ðịnh',
  'Hữu Hạnh',
  'Hữu Hiệp',
  'Hữu Hoàng',
  'Hữu Hùng',
  'Hữu Khang',
  'Hữu Khanh',
  'Hữu Khoát',
  'Hữu Khôi',
  'Hữu Long',
  'Hữu Lương',
  'Hữu Minh',
  'Hữu Nam',
  'Hữu Nghị',
  'Hữu Nghĩa',
  'Hữu Phước',
  'Hữu Tài',
  'Hữu Tâm',
  'Hữu Tân',
  'Hữu Thắng',
  'Hữu Thiện',
  'Hữu Thọ',
  'Hữu Thống',
  'Hữu Thực',
  'Hữu Toàn',
  'Hữu Trác',
  'Hữu Trí',
  'Hữu Trung',
  'Hữu Từ',
  'Hữu Tường',
  'Hữu Vĩnh',
  'Hữu Vượng',
  'Huy Anh',
  'Huy Chiểu',
  'Huy Hà',
  'Huy Hoàng',
  'Huy Kha',
  'Huy Khánh',
  'Huy Khiêm',
  'Huy Lĩnh',
  'Huy Phong',
  'Huy Quang',
  'Huy Thành',
  'Huy Thông',
  'Huy Trân',
  'Huy Tuấn',
  'Huy Tường',
  'Huy Việt',
  'Huy Vũ',
  'Khắc Anh',
  'Khắc Công',
  'Khắc Dũng',
  'Khắc Duy',
  'Khắc Kỷ',
  'Khắc Minh',
  'Khắc Ninh',
  'Khắc Thành',
  'Khắc Triệu',
  'Khắc Trọng',
  'Khắc Tuấn',
  'Khắc Việt',
  'Khắc Vũ',
  'Khải Ca',
  'Khải Hòa',
  'Khai Minh',
  'Khải Tâm',
  'Khải Tuấn',
  'Khang Kiện',
  'Khánh An',
  'Khánh Bình',
  'Khánh Ðan',
  'Khánh Duy',
  'Khánh Giang',
  'Khánh Hải',
  'Khánh Hòa',
  'Khánh Hoàn',
  'Khánh Hoàng',
  'Khánh Hội',
  'Khánh Huy',
  'Khánh Minh',
  'Khánh Nam',
  'Khánh Văn',
  'Khoa Trưởng',
  'Khôi Nguyên',
  'Khởi Phong',
  'Khôi Vĩ',
  'Khương Duy',
  'Khuyến Học',
  'Kiên Bình',
  'Kiến Bình',
  'Kiên Cường',
  'Kiến Ðức',
  'Kiên Giang',
  'Kiên Lâm',
  'Kiên Trung',
  'Kiến Văn',
  'Kiệt Võ',
  'Kim Ðan',
  'Kim Hoàng',
  'Kim Long',
  'Kim Phú',
  'Kim Sơn',
  'Kim Thịnh',
  'Kim Thông',
  'Kim Toàn',
  'Kim Vượng',
  'Kỳ Võ',
  'Lạc Nhân',
  'Lạc Phúc',
  'Lâm Ðồng',
  'Lâm Dũng',
  'Lam Giang',
  'Lam Phương',
  'Lâm Trường',
  'Lâm Tường',
  'Lâm Viên',
  'Lâm Vũ',
  'Lập Nghiệp',
  'Lập Thành',
  'Liên Kiệt',
  'Long Giang',
  'Long Quân',
  'Long Vịnh',
  'Lương Quyền',
  'Lương Tài',
  'Lương Thiện',
  'Lương Tuyền',
  'Mạnh Cương',
  'Mạnh Cường',
  'Mạnh Ðình',
  'Mạnh Dũng',
  'Mạnh Hùng',
  'Mạnh Nghiêm',
  'Mạnh Quỳnh',
  'Mạnh Tấn',
  'Mạnh Thắng',
  'Mạnh Thiện',
  'Mạnh Trình',
  'Mạnh Trường',
  'Mạnh Tuấn',
  'Mạnh Tường',
  'Minh Ân',
  'Minh Anh',
  'Minh Cảnh',
  'Minh Dân',
  'Minh Ðan',
  'Minh Danh',
  'Minh Ðạt',
  'Minh Ðức',
  'Minh Dũng',
  'Minh Giang',
  'Minh Hải',
  'Minh Hào',
  'Minh Hiên',
  'Minh Hiếu',
  'Minh Hòa',
  'Minh Hoàng',
  'Minh Huấn',
  'Minh Hùng',
  'Minh Hưng',
  'Minh Huy',
  'Minh Hỷ',
  'Minh Khang',
  'Minh Khánh',
  'Minh Khiếu',
  'Minh Khôi',
  'Minh Kiệt',
  'Minh Kỳ',
  'Minh Lý',
  'Minh Mẫn',
  'Minh Nghĩa',
  'Minh Nhân',
  'Minh Nhật',
  'Minh Nhu',
  'Minh Quân',
  'Minh Quang',
  'Minh Quốc',
  'Minh Sơn',
  'Minh Tân',
  'Minh Thạc',
  'Minh Thái',
  'Minh Thắng',
  'Minh Thiện',
  'Minh Thông',
  'Minh Thuận',
  'Minh Tiến',
  'Minh Toàn',
  'Minh Trí',
  'Minh Triết',
  'Minh Triệu',
  'Minh Trung',
  'Minh Tú',
  'Minh Tuấn',
  'Minh Vu',
  'Minh Vũ',
  'Minh Vương',
  'Mộng Giác',
  'Mộng Hoàn',
  'Mộng Lâm',
  'Mộng Long',
  'Nam An',
  'Nam Dương',
  'Nam Hải',
  'Nam Hưng',
  'Nam Lộc',
  'Nam Nhật',
  'Nam Ninh',
  'Nam Phi',
  'Nam Phương',
  'Nam Sơn',
  'Nam Thanh',
  'Nam Thông',
  'Nam Tú',
  'Nam Việt',
  'Nghị Lực',
  'Nghị Quyền',
  'Nghĩa Dũng',
  'Nghĩa Hòa',
  'Ngọc Ẩn',
  'Ngọc Cảnh',
  'Ngọc Cường',
  'Ngọc Danh',
  'Ngọc Ðoàn',
  'Ngọc Dũng',
  'Ngọc Hải',
  'Ngọc Hiển',
  'Ngọc Huy',
  'Ngọc Khang',
  'Ngọc Khôi',
  'Ngọc Khương',
  'Ngọc Lai',
  'Ngọc Lân',
  'Ngọc Minh',
  'Ngọc Ngạn',
  'Ngọc Quang',
  'Ngọc Sơn',
  'Ngọc Thạch',
  'Ngọc Thiện',
  'Ngọc Thọ',
  'Ngọc Thuận',
  'Ngọc Tiển',
  'Ngọc Trụ',
  'Ngọc Tuấn',
  'Nguyên Bảo',
  'Nguyên Bổng',
  'Nguyên Ðan',
  'Nguyên Giang',
  'Nguyên Giáp',
  'Nguyễn Hải An',
  'Nguyên Hạnh',
  'Nguyên Khang',
  'Nguyên Khôi',
  'Nguyên Lộc',
  'Nguyên Nhân',
  'Nguyên Phong',
  'Nguyên Sử',
  'Nguyên Văn',
  'Nhân Nguyên',
  'Nhân Sâm',
  'Nhân Từ',
  'Nhân Văn',
  'Nhật Bảo Long',
  'Nhật Dũng',
  'Nhật Duy',
  'Nhật Hòa',
  'Nhật Hoàng',
  'Nhật Hồng',
  'Nhật Hùng',
  'Nhật Huy',
  'Nhật Khương',
  'Nhật Minh',
  'Nhật Nam',
  'Nhật Quân',
  'Nhật Quang',
  'Nhật Quốc',
  'Nhật Tấn',
  'Nhật Thịnh',
  'Nhất Tiến',
  'Nhật Tiến',
  'Như Khang',
  'Niệm Nhiên',
  'Phi Cường',
  'Phi Ðiệp',
  'Phi Hải',
  'Phi Hoàng',
  'Phi Hùng',
  'Phi Long',
  'Phi Nhạn',
  'Phong Châu',
  'Phong Dinh',
  'Phong Ðộ',
  'Phú Ân',
  'Phú Bình',
  'Phú Hải',
  'Phú Hiệp',
  'Phú Hùng',
  'Phú Hưng',
  'Phú Thịnh',
  'Phú Thọ',
  'Phú Thời',
  'Phúc Cường',
  'Phúc Ðiền',
  'Phúc Duy',
  'Phúc Hòa',
  'Phúc Hưng',
  'Phúc Khang',
  'Phúc Lâm',
  'Phục Lễ',
  'Phúc Nguyên',
  'Phúc Sinh',
  'Phúc Tâm',
  'Phúc Thịnh',
  'Phụng Việt',
  'Phước An',
  'Phước Lộc',
  'Phước Nguyên',
  'Phước Nhân',
  'Phước Sơn',
  'Phước Thiện',
  'Phượng Long',
  'Phương Nam',
  'Phương Phi',
  'Phương Thể',
  'Phương Trạch',
  'Phương Triều',
  'Quân Dương',
  'Quang Anh',
  'Quang Bửu',
  'Quảng Ðại',
  'Quang Danh',
  'Quang Ðạt',
  'Quảng Ðạt',
  'Quang Ðức',
  'Quang Dũng',
  'Quang Dương',
  'Quang Hà',
  'Quang Hải',
  'Quang Hòa',
  'Quang Hùng',
  'Quang Hưng',
  'Quang Hữu',
  'Quang Huy',
  'Quang Khải',
  'Quang Khanh',
  'Quang Lâm',
  'Quang Lân',
  'Quang Linh',
  'Quang Lộc',
  'Quang Minh',
  'Quang Nhân',
  'Quang Nhật',
  'Quang Ninh',
  'Quang Sáng',
  'Quang Tài',
  'Quang Thạch',
  'Quang Thái',
  'Quang Thắng',
  'Quang Thiên',
  'Quang Thịnh',
  'Quảng Thông',
  'Quang Thuận',
  'Quang Triều',
  'Quang Triệu',
  'Quang Trọng',
  'Quang Trung',
  'Quang Trường',
  'Quang Tú',
  'Quang Tuấn',
  'Quang Vinh',
  'Quang Vũ',
  'Quang Xuân',
  'Quốc Anh',
  'Quốc Bảo',
  'Quốc Bình',
  'Quốc Ðại',
  'Quốc Ðiền',
  'Quốc Hải',
  'Quốc Hạnh',
  'Quốc Hiền',
  'Quốc Hiển',
  'Quốc Hòa',
  'Quốc Hoài',
  'Quốc Hoàng',
  'Quốc Hùng',
  'Quốc Hưng',
  'Quốc Huy',
  'Quốc Khánh',
  'Quốc Mạnh',
  'Quốc Minh',
  'Quốc Mỹ',
  'Quốc Phong',
  'Quốc Phương',
  'Quốc Quân',
  'Quốc Quang',
  'Quốc Quý',
  'Quốc Thắng',
  'Quốc Thành',
  'Quốc Thiện',
  'Quốc Thịnh',
  'Quốc Thông',
  'Quốc Tiến',
  'Quốc Toản',
  'Quốc Trụ',
  'Quốc Trung',
  'Quốc Trường',
  'Quốc Tuấn',
  'Quốc Văn',
  'Quốc Việt',
  'Quốc Vinh',
  'Quốc Vũ',
  'Quý Khánh',
  'Quý Vĩnh',
  'Quyết Thắng',
  'Sĩ Hoàng',
  'Sơn Dương',
  'Sơn Giang',
  'Sơn Hà',
  'Sơn Hải',
  'Sơn Lâm',
  'Sơn Quân',
  'Sơn Quyền',
  'Sơn Trang',
  'Sơn Tùng',
  'Song Lam',
  'Sỹ Ðan',
  'Sỹ Hoàng',
  'Sỹ Phú',
  'Sỹ Thực',
  'Tạ Hiền',
  'Tài Ðức',
  'Tài Nguyên',
  'Tâm Thiện',
  'Tân Bình',
  'Tân Ðịnh',
  'Tấn Dũng',
  'Tấn Khang',
  'Tấn Lợi',
  'Tân Long',
  'Tấn Nam',
  'Tấn Phát',
  'Tân Phước',
  'Tấn Sinh',
  'Tấn Tài',
  'Tân Thành',
  'Tấn Thành',
  'Tấn Trình',
  'Tấn Trương',
  'Tất Bình',
  'Tất Hiếu',
  'Tất Hòa',
  'Thạch Sơn',
  'Thạch Tùng',
  'Thái Bình',
  'Thái Ðức',
  'Thái Dương',
  'Thái Duy',
  'Thái Hòa',
  'Thái Minh',
  'Thái Nguyên',
  'Thái San',
  'Thái Sang',
  'Thái Sơn',
  'Thái Tân',
  'Thái Tổ',
  'Thắng Cảnh',
  'Thắng Lợi',
  'Thăng Long',
  'Thành An',
  'Thành Ân',
  'Thành Châu',
  'Thành Công',
  'Thành Danh',
  'Thanh Ðạo',
  'Thành Ðạt',
  'Thành Ðệ',
  'Thanh Ðoàn',
  'Thành Doanh',
  'Thanh Hải',
  'Thanh Hào',
  'Thanh Hậu',
  'Thành Hòa',
  'Thanh Huy',
  'Thành Khiêm',
  'Thanh Kiên',
  'Thanh Liêm',
  'Thành Lợi',
  'Thanh Long',
  'Thành Long',
  'Thanh Minh',
  'Thành Nguyên',
  'Thành Nhân',
  'Thanh Phi',
  'Thanh Phong',
  'Thành Phương',
  'Thanh Quang',
  'Thành Sang',
  'Thanh Sơn',
  'Thanh Thế',
  'Thanh Thiên',
  'Thành Thiện',
  'Thanh Thuận',
  'Thành Tín',
  'Thanh Tịnh',
  'Thanh Toàn',
  'Thanh Toản',
  'Thanh Trung',
  'Thành Trung',
  'Thanh Tú',
  'Thanh Tuấn',
  'Thanh Tùng',
  'Thanh Việt',
  'Thanh Vinh',
  'Thành Vinh',
  'Thanh Vũ',
  'Thành Ý',
  'Thất Cương',
  'Thất Dũng',
  'Thất Thọ',
  'Thế An',
  'Thế Anh',
  'Thế Bình',
  'Thế Dân',
  'Thế Doanh',
  'Thế Dũng',
  'Thế Duyệt',
  'Thế Huấn',
  'Thế Hùng',
  'Thế Lâm',
  'Thế Lực',
  'Thế Minh',
  'Thế Năng',
  'Thế Phúc',
  'Thế Phương',
  'Thế Quyền',
  'Thế Sơn',
  'Thế Trung',
  'Thế Tường',
  'Thế Vinh',
  'Thiên An',
  'Thiên Ân',
  'Thiện Ân',
  'Thiên Bửu',
  'Thiên Ðức',
  'Thiện Ðức',
  'Thiện Dũng',
  'Thiện Giang',
  'Thiên Hưng',
  'Thiện Khiêm',
  'Thiên Lạc',
  'Thiện Luân',
  'Thiên Lương',
  'Thiện Lương',
  'Thiên Mạnh',
  'Thiện Minh',
  'Thiện Ngôn',
  'Thiên Phú',
  'Thiện Phước',
  'Thiện Sinh',
  'Thiện Tâm',
  'Thiện Thanh',
  'Thiện Tính',
  'Thiên Trí',
  'Thiếu Anh',
  'Thiệu Bảo',
  'Thiếu Cường',
  'Thịnh Cường',
  'Thời Nhiệm',
  'Thông Ðạt',
  'Thông Minh',
  'Thống Nhất',
  'Thông Tuệ',
  'Thụ Nhân',
  'Thu Sinh',
  'Thuận Anh',
  'Thuận Hòa',
  'Thuận Phong',
  'Thuận Phương',
  'Thuận Thành',
  'Thuận Toàn',
  'Thượng Cường',
  'Thượng Khang',
  'Thường Kiệt',
  'Thượng Liệt',
  'Thượng Năng',
  'Thượng Nghị',
  'Thượng Thuật',
  'Thường Xuân',
  'Thụy Du',
  'Thụy Long',
  'Thụy Miên',
  'Thụy Vũ',
  'Tích Ðức',
  'Tích Thiện',
  'Tiến Ðức',
  'Tiến Dũng',
  'Tiền Giang',
  'Tiến Hiệp',
  'Tiến Hoạt',
  'Tiến Võ',
  'Tiểu Bảo',
  'Toàn Thắng',
  'Tôn Lễ',
  'Trí Dũng',
  'Trí Hào',
  'Trí Hùng',
  'Trí Hữu',
  'Trí Liên',
  'Trí Minh',
  'Trí Thắng',
  'Trí Tịnh',
  'Triển Sinh',
  'Triệu Thái',
  'Triều Thành',
  'Trọng Chính',
  'Trọng Dũng',
  'Trọng Duy',
  'Trọng Hà',
  'Trọng Hiếu',
  'Trọng Hùng',
  'Trọng Khánh',
  'Trọng Kiên',
  'Trọng Nghĩa',
  'Trọng Nhân',
  'Trọng Tấn',
  'Trọng Trí',
  'Trọng Tường',
  'Trọng Việt',
  'Trọng Vinh',
  'Trúc Cương',
  'Trúc Sinh',
  'Trung Anh',
  'Trung Chính',
  'Trung Chuyên',
  'Trung Ðức',
  'Trung Dũng',
  'Trung Hải',
  'Trung Hiếu',
  'Trung Kiên',
  'Trung Lực',
  'Trung Nghĩa',
  'Trung Nguyên',
  'Trung Nhân',
  'Trung Thành',
  'Trung Thực',
  'Trung Việt',
  'Trường An',
  'Trường Chinh',
  'Trường Giang',
  'Trường Hiệp',
  'Trường Kỳ',
  'Trường Liên',
  'Trường Long',
  'Trường Nam',
  'Trường Nhân',
  'Trường Phát',
  'Trường Phu',
  'Trường Phúc',
  'Trường Sa',
  'Trường Sinh',
  'Trường Sơn',
  'Trường Thành',
  'Trường Vinh',
  'Trường Vũ',
  'Từ Ðông',
  'Tuấn Anh',
  'Tuấn Châu',
  'Tuấn Chương',
  'Tuấn Ðức',
  'Tuấn Dũng',
  'Tuấn Hải',
  'Tuấn Hoàng',
  'Tuấn Hùng',
  'Tuấn Khải',
  'Tuấn Khanh',
  'Tuấn Khoan',
  'Tuấn Kiệt',
  'Tuấn Linh',
  'Tuấn Long',
  'Tuấn Minh',
  'Tuấn Ngọc',
  'Tuấn Sĩ',
  'Tuấn Sỹ',
  'Tuấn Tài',
  'Tuấn Thành',
  'Tuấn Trung',
  'Tuấn Tú',
  'Tuấn Việt',
  'Tùng Anh',
  'Tùng Châu',
  'Tùng Lâm',
  'Tùng Linh',
  'Tùng Minh',
  'Tùng Quang',
  'Tường Anh',
  'Tường Lâm',
  'Tường Lân',
  'Tường Lĩnh',
  'Tường Minh',
  'Tường Nguyên',
  'Tường Phát',
  'Tường Vinh',
  'Tuyền Lâm',
  'Uy Phong',
  'Uy Vũ',
  'Vạn Hạnh',
  'Vạn Lý',
  'Văn Minh',
  'Vân Sơn',
  'Vạn Thắng',
  'Vạn Thông',
  'Văn Tuyển',
  'Viễn Cảnh',
  'Viễn Ðông',
  'Viễn Phương',
  'Viễn Thông',
  'Việt An',
  'Việt Anh',
  'Việt Chính',
  'Việt Cương',
  'Việt Cường',
  'Việt Dũng',
  'Việt Dương',
  'Việt Duy',
  'Việt Hải',
  'Việt Hoàng',
  'Việt Hồng',
  'Việt Hùng',
  'Việt Huy',
  'Việt Khải',
  'Việt Khang',
  'Việt Khoa',
  'Việt Khôi',
  'Việt Long',
  'Việt Ngọc',
  'Viết Nhân',
  'Việt Nhân',
  'Việt Phong',
  'Việt Phương',
  'Việt Quốc',
  'Việt Quyết',
  'Viết Sơn',
  'Việt Sơn',
  'Viết Tân',
  'Việt Thái',
  'Việt Thắng',
  'Việt Thanh',
  'Việt Thông',
  'Việt Thương',
  'Việt Tiến',
  'Việt Võ',
  'Vĩnh Ân',
  'Vinh Diệu',
  'Vĩnh Hải',
  'Vĩnh Hưng',
  'Vĩnh Long',
  'Vĩnh Luân',
  'Vinh Quốc',
  'Vĩnh Thọ',
  'Vĩnh Thụy',
  'Vĩnh Toàn',
  'Vũ Anh',
  'Vũ Minh',
  'Vương Gia',
  'Vương Triều',
  'Vương Triệu',
  'Vương Việt',
  'Xuân An',
  'Xuân Bình',
  'Xuân Cao',
  'Xuân Cung',
  'Xuân Hàm',
  'Xuân Hãn',
  'Xuân Hiếu',
  'Xuân Hòa',
  'Xuân Huy',
  'Xuân Khoa',
  'Xuân Kiên',
  'Xuân Lạc',
  'Xuân Lộc',
  'Xuân Minh',
  'Xuân Nam',
  'Xuân Ninh',
  'Xuân Phúc',
  'Xuân Quân',
  'Xuân Quý',
  'Xuân Sơn',
  'Xuân Thái',
  'Xuân Thiện',
  'Xuân Thuyết',
  'Xuân Trung',
  'Xuân Trường',
  'Xuân Tường',
  'Xuân Vũ',
  'Yên Bằng',
  'Yên Bình',
  'Yên Sơn',
];
module["exports"] = [
  "#{male_first_name} #{last_name}",
  "#{female_first_name} #{last_name}",
  "#{first_name} #{last_name}",

];
module["exports"] = [
  "02# #### ####",
  "02## #### ####"
];
var phone_number = {};
module['exports'] = phone_number;
phone_number.formats = require("./formats");
module["exports"] = [
  "#####",
  "####",
  "###",
  "##",
  "#"
];
module["exports"] = [
  "长",
  "上",
  "南",
  "西",
  "北",
  "诸",
  "宁",
  "珠",
  "武",
  "衡",
  "成",
  "福",
  "厦",
  "贵",
  "吉",
  "海",
  "太",
  "济",
  "安",
  "吉",
  "包"
];
module["exports"] = [
  "沙市",
  "京市",
  "宁市",
  "安市",
  "乡县",
  "海市",
  "码市",
  "汉市",
  "阳市",
  "都市",
  "州市",
  "门市",
  "阳市",
  "口市",
  "原市",
  "南市",
  "徽市",
  "林市",
  "头市"
];
module["exports"] = [
  "#{city_prefix}#{city_suffix}"
];
module["exports"] = [
  "中国"
];
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");
module["exports"] = [
  "######"
];
module["exports"] = [
  "京",
  "沪",
  "津",
  "渝",
  "黑",
  "吉",
  "辽",
  "蒙",
  "冀",
  "新",
  "甘",
  "青",
  "陕",
  "宁",
  "豫",
  "鲁",
  "晋",
  "皖",
  "鄂",
  "湘",
  "苏",
  "川",
  "黔",
  "滇",
  "桂",
  "藏",
  "浙",
  "赣",
  "粤",
  "闽",
  "台",
  "琼",
  "港",
  "澳"
];
module["exports"] = [
  "北京市",
  "上海市",
  "天津市",
  "重庆市",
  "黑龙江省",
  "吉林省",
  "辽宁省",
  "内蒙古",
  "河北省",
  "新疆",
  "甘肃省",
  "青海省",
  "陕西省",
  "宁夏",
  "河南省",
  "山东省",
  "山西省",
  "安徽省",
  "湖北省",
  "湖南省",
  "江苏省",
  "四川省",
  "贵州省",
  "云南省",
  "广西省",
  "西藏",
  "浙江省",
  "江西省",
  "广东省",
  "福建省",
  "台湾省",
  "海南省",
  "香港",
  "澳门"
];
module["exports"] = [
  "#{street_name}#{building_number}号"
];
module["exports"] = [
  "#{Name.last_name}#{street_suffix}"
];
module["exports"] = [
  "巷",
  "街",
  "路",
  "桥",
  "侬",
  "旁",
  "中心",
  "栋"
];
var zh_CN = {};
module['exports'] = zh_CN;
zh_CN.title = "Chinese";
zh_CN.address = require("./address");
zh_CN.name = require("./name");
zh_CN.phone_number = require("./phone_number");
module["exports"] = [
  "绍齐",
  "博文",
  "梓晨",
  "胤祥",
  "瑞霖",
  "明哲",
  "天翊",
  "凯瑞",
  "健雄",
  "耀杰",
  "潇然",
  "子涵",
  "越彬",
  "钰轩",
  "智辉",
  "致远",
  "俊驰",
  "雨泽",
  "烨磊",
  "晟睿",
  "文昊",
  "修洁",
  "黎昕",
  "远航",
  "旭尧",
  "鸿涛",
  "伟祺",
  "荣轩",
  "越泽",
  "浩宇",
  "瑾瑜",
  "皓轩",
  "擎苍",
  "擎宇",
  "志泽",
  "子轩",
  "睿渊",
  "弘文",
  "哲瀚",
  "雨泽",
  "楷瑞",
  "建辉",
  "晋鹏",
  "天磊",
  "绍辉",
  "泽洋",
  "鑫磊",
  "鹏煊",
  "昊强",
  "伟宸",
  "博超",
  "君浩",
  "子骞",
  "鹏涛",
  "炎彬",
  "鹤轩",
  "越彬",
  "风华",
  "靖琪",
  "明辉",
  "伟诚",
  "明轩",
  "健柏",
  "修杰",
  "志泽",
  "弘文",
  "峻熙",
  "嘉懿",
  "煜城",
  "懿轩",
  "烨伟",
  "苑博",
  "伟泽",
  "熠彤",
  "鸿煊",
  "博涛",
  "烨霖",
  "烨华",
  "煜祺",
  "智宸",
  "正豪",
  "昊然",
  "明杰",
  "立诚",
  "立轩",
  "立辉",
  "峻熙",
  "弘文",
  "熠彤",
  "鸿煊",
  "烨霖",
  "哲瀚",
  "鑫鹏",
  "昊天",
  "思聪",
  "展鹏",
  "笑愚",
  "志强",
  "炫明",
  "雪松",
  "思源",
  "智渊",
  "思淼",
  "晓啸",
  "天宇",
  "浩然",
  "文轩",
  "鹭洋",
  "振家",
  "乐驹",
  "晓博",
  "文博",
  "昊焱",
  "立果",
  "金鑫",
  "锦程",
  "嘉熙",
  "鹏飞",
  "子默",
  "思远",
  "浩轩",
  "语堂",
  "聪健",
  "明",
  "文",
  "果",
  "思",
  "鹏",
  "驰",
  "涛",
  "琪",
  "浩",
  "航",
  "彬"
];
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.name = require("./name");
module["exports"] = [
  "王",
  "李",
  "张",
  "刘",
  "陈",
  "杨",
  "黄",
  "吴",
  "赵",
  "周",
  "徐",
  "孙",
  "马",
  "朱",
  "胡",
  "林",
  "郭",
  "何",
  "高",
  "罗",
  "郑",
  "梁",
  "谢",
  "宋",
  "唐",
  "许",
  "邓",
  "冯",
  "韩",
  "曹",
  "曾",
  "彭",
  "萧",
  "蔡",
  "潘",
  "田",
  "董",
  "袁",
  "于",
  "余",
  "叶",
  "蒋",
  "杜",
  "苏",
  "魏",
  "程",
  "吕",
  "丁",
  "沈",
  "任",
  "姚",
  "卢",
  "傅",
  "钟",
  "姜",
  "崔",
  "谭",
  "廖",
  "范",
  "汪",
  "陆",
  "金",
  "石",
  "戴",
  "贾",
  "韦",
  "夏",
  "邱",
  "方",
  "侯",
  "邹",
  "熊",
  "孟",
  "秦",
  "白",
  "江",
  "阎",
  "薛",
  "尹",
  "段",
  "雷",
  "黎",
  "史",
  "龙",
  "陶",
  "贺",
  "顾",
  "毛",
  "郝",
  "龚",
  "邵",
  "万",
  "钱",
  "严",
  "赖",
  "覃",
  "洪",
  "武",
  "莫",
  "孔"
];
module["exports"] = [
  "#{first_name}#{last_name}"
];
module["exports"] = [
  "0##-########",
  "0###-########",
  "1##########"
];
var phone_number = {};
module['exports'] = phone_number;
phone_number.formats = require("./formats");
module["exports"] = [
  "####",
  "###",
  "##",
  "#"
];
module["exports"] = [
  "臺北",
  "新北",
  "桃園",
  "臺中",
  "臺南",
  "高雄",
  "基隆",
  "新竹",
  "嘉義",
  "苗栗",
  "彰化",
  "南投",
  "雲林",
  "屏東",
  "宜蘭",
  "花蓮",
  "臺東",
  "澎湖",
  "金門",
  "連江"
];
module["exports"] = [
  "縣",
  "市"
];
module["exports"] = [
  "#{city_prefix}#{city_suffix}"
];
module["exports"] = [
  "Taiwan (R.O.C.)"
];
var address = {};
module['exports'] = address;
address.city_prefix = require("./city_prefix");
address.city_suffix = require("./city_suffix");
address.building_number = require("./building_number");
address.street_suffix = require("./street_suffix");
address.postcode = require("./postcode");
address.state = require("./state");
address.state_abbr = require("./state_abbr");
address.city = require("./city");
address.street_name = require("./street_name");
address.street_address = require("./street_address");
address.default_country = require("./default_country");
module["exports"] = [
  "######"
];
module["exports"] = [
  "北",
  "新北",
  "桃",
  "中",
  "南",
  "高",
  "基",
  "竹市",
  "嘉市",
  "竹縣",
  "苗",
  "彰",
  "投",
  "雲",
  "嘉縣",
  "宜",
  "花",
  "東",
  "澎",
  "金",
  "馬"
];
module["exports"] = [
  "福建省",
  "台灣省"
];
module["exports"] = [
  "#{street_name}#{building_number}號"
];
module["exports"] = [
  "#{Name.last_name}#{street_suffix}"
];
module["exports"] = [
  "街",
  "路",
  "北路",
  "南路",
  "東路",
  "西路"
];
var zh_TW = {};
module['exports'] = zh_TW;
zh_TW.title = "Chinese (Taiwan)";
zh_TW.address = require("./address");
zh_TW.name = require("./name");
zh_TW.phone_number = require("./phone_number");
module["exports"] = [
  "紹齊",
  "博文",
  "梓晨",
  "胤祥",
  "瑞霖",
  "明哲",
  "天翊",
  "凱瑞",
  "健雄",
  "耀傑",
  "瀟然",
  "子涵",
  "越彬",
  "鈺軒",
  "智輝",
  "致遠",
  "俊馳",
  "雨澤",
  "燁磊",
  "晟睿",
  "文昊",
  "修潔",
  "黎昕",
  "遠航",
  "旭堯",
  "鴻濤",
  "偉祺",
  "榮軒",
  "越澤",
  "浩宇",
  "瑾瑜",
  "皓軒",
  "擎蒼",
  "擎宇",
  "志澤",
  "子軒",
  "睿淵",
  "弘文",
  "哲瀚",
  "雨澤",
  "楷瑞",
  "建輝",
  "晉鵬",
  "天磊",
  "紹輝",
  "澤洋",
  "鑫磊",
  "鵬煊",
  "昊強",
  "偉宸",
  "博超",
  "君浩",
  "子騫",
  "鵬濤",
  "炎彬",
  "鶴軒",
  "越彬",
  "風華",
  "靖琪",
  "明輝",
  "偉誠",
  "明軒",
  "健柏",
  "修傑",
  "志澤",
  "弘文",
  "峻熙",
  "嘉懿",
  "煜城",
  "懿軒",
  "燁偉",
  "苑博",
  "偉澤",
  "熠彤",
  "鴻煊",
  "博濤",
  "燁霖",
  "燁華",
  "煜祺",
  "智宸",
  "正豪",
  "昊然",
  "明杰",
  "立誠",
  "立軒",
  "立輝",
  "峻熙",
  "弘文",
  "熠彤",
  "鴻煊",
  "燁霖",
  "哲瀚",
  "鑫鵬",
  "昊天",
  "思聰",
  "展鵬",
  "笑愚",
  "志強",
  "炫明",
  "雪松",
  "思源",
  "智淵",
  "思淼",
  "曉嘯",
  "天宇",
  "浩然",
  "文軒",
  "鷺洋",
  "振家",
  "樂駒",
  "曉博",
  "文博",
  "昊焱",
  "立果",
  "金鑫",
  "錦程",
  "嘉熙",
  "鵬飛",
  "子默",
  "思遠",
  "浩軒",
  "語堂",
  "聰健"
];
var name = {};
module['exports'] = name;
name.first_name = require("./first_name");
name.last_name = require("./last_name");
name.name = require("./name");
module["exports"] = [
  "王",
  "李",
  "張",
  "劉",
  "陳",
  "楊",
  "黃",
  "吳",
  "趙",
  "週",
  "徐",
  "孫",
  "馬",
  "朱",
  "胡",
  "林",
  "郭",
  "何",
  "高",
  "羅",
  "鄭",
  "梁",
  "謝",
  "宋",
  "唐",
  "許",
  "鄧",
  "馮",
  "韓",
  "曹",
  "曾",
  "彭",
  "蕭",
  "蔡",
  "潘",
  "田",
  "董",
  "袁",
  "於",
  "餘",
  "葉",
  "蔣",
  "杜",
  "蘇",
  "魏",
  "程",
  "呂",
  "丁",
  "沈",
  "任",
  "姚",
  "盧",
  "傅",
  "鐘",
  "姜",
  "崔",
  "譚",
  "廖",
  "範",
  "汪",
  "陸",
  "金",
  "石",
  "戴",
  "賈",
  "韋",
  "夏",
  "邱",
  "方",
  "侯",
  "鄒",
  "熊",
  "孟",
  "秦",
  "白",
  "江",
  "閻",
  "薛",
  "尹",
  "段",
  "雷",
  "黎",
  "史",
  "龍",
  "陶",
  "賀",
  "顧",
  "毛",
  "郝",
  "龔",
  "邵",
  "萬",
  "錢",
  "嚴",
  "賴",
  "覃",
  "洪",
  "武",
  "莫",
  "孔"
];
module["exports"] = [
  "#{first_name}#{last_name}"
];
module["exports"] = [
  "0#-#######",
  "02-########",
  "09##-######"
];
var phone_number = {};
module['exports'] = phone_number;
phone_number.formats = require("./formats");
module["exports"] = [
  "South Africa"
];
var address = {};
module['exports'] = address;
address.default_country = require("./default_country");
address.postcode = require("./postcode");
module["exports"] = [
  "#####",
  "####"
];
module["exports"] = [
  "082 ### ####",
  "084 ### ####",
  "083 ### ####",
  "065 ### ####",
  "082#######",
  "082 #######"
];
var cell_phone = {};
module['exports'] = cell_phone;
cell_phone.formats = require("./formats");
var company = {};
module['exports'] = company;
company.suffix = require("./suffix");
module["exports"] = [
  "Pty Ltd",
  "Ltd",
  "CC"
];
var en_ZA = {};
module['exports'] = en_ZA;
en_ZA.title = "Zulu (South Africa)";
en_ZA.address = require("./address");
en_ZA.internet = require("./internet");
en_ZA.phone_number = require("./phone_number");
en_ZA.cell_phone = require("./cell_phone");
en_ZA.company = require("./company");
module["exports"] = [
  "co.za",
  "com",
  "org.za",
  "info",
  "net.za"
];
var internet = {};
module['exports'] = internet;
internet.domain_suffix = require("./domain_suffix");
module["exports"] = [
  "Ayanda",
  "Uluthando",
  "Nofoto",
  "Yibanathi",
  "Thadie",
  "Ulwazi",
  "Lerato",
  "Amahle",
  "Khulekani",
  "Jabulile",
  "Mthunzi",
  "Sindisiwe",
  "Inyoni",
  "Ntombizodwa",
  "Zobuhle",
  "Samukelisiwe",
  "Nonhlanhla",
  "Nhlakanipho",
  "Liyana",
  "Nonjabulo",
  "Ntokozo",
  "Nokuthula",
  "Buhle",
  "Isisa",
  "Thobeka",
  "Thabisa",
  "Zanele",
  "Sizani",
  "Nkosingiphile",
  "Mhambi",
  "Nomvula",
  "Thulisile",
  "Lukhona",
  "Mbalienhle",
  "Sizakele",
  "Khethiwe",
  "Nolwazi",
  "Sinenhlanhla",
  "Ayize",
  "Duduzile",
  "Busisiwe",
  "Hlengiwe",
  "Jabulile",
  "Khanyisile",
  "Nandi",
  "Ndondoloza",
  "Nozipho",
  "Nonkululeko",
  "Sibongile",
  "Siphephelo"
];module["exports"] = [
  "Ayanda",
  "Uluthando",
  "Nofoto",
  "Yibanathi",
  "Thadie",
  "Ulwazi",
  "Lerato",
  "Amahle",
  "Khulekani",
  "Jabulile",
  "Mthunzi",
  "Sindisiwe",
  "Inyoni",
  "Ntombizodwa",
  "Zobuhle",
  "Samukelisiwe",
  "Nonhlanhla",
  "Nhlakanipho",
  "Liyana",
  "Nonjabulo",
  "Ntokozo",
  "Nokuthula",
  "Buhle",
  "Isisa",
  "Thobeka",
  "Thabisa",
  "Zanele",
  "Sizani",
  "Nkosingiphile",
  "Mhambi",
  "Nomvula",
  "Thulisile",
  "Lukhona",
  "Mbalienhle",
  "Sizakele",
  "Khethiwe",
  "Nolwazi",
  "Sinenhlanhla",
  "Ayize",
  "Duduzile",
  "Busisiwe",
  "Hlengiwe",
  "Jabulile",
  "Khanyisile",
  "Nandi",
  "Ndondoloza",
  "Nozipho",
  "Nonkululeko",
  "Sibongile",
  "Siphephelo",
  "Bonginkosi",
  "Kagiso",
  "Bhekizizwe",
  "Bhekumbuso",
  "Shaka",
  "Funani",
  "Kgabu",
  "Solomon",
  "Gatsha",
  "Langa",
  "Phila",
  "Msizi",
  "Nkosiyabo",
  "Linda",
  "Mpilo",
  "Siyanda",
  "Nkanyezi",
  "Bafana",
  "Lwandle",
  "Sfiso",
  "Thulani",
  "Thando",
  "Sanele",
  "Anele",
  "Lungelo",
  "Dumisani",
  "Bangizwe",
  "Fanyana",
  "Bhekimuzi",
  "Mandla",
  "Maphikelela",
  "Mpumelelo",
  "Mthunzi",
  "Philani",
  "Musawenkosi",
  "Nkosenye",
  "Nkosinhle",
  "Phiwokwakhe",
  "Sifiso",
  "Zithulele",
  "Sithembiso",
  "Sipho",
  "Siphiwe",
  "Sibusiso",
  "Velaphi",
  "Thamsanqa",
  "Vusumuzi",
  "Themba",
  "Zenzele",
  "Ndleleni"
];
var name = {};
module['exports'] = name;
name.male_first_name = require("./male_first_name");
name.female_first_name = require("./female_first_name");
name.first_name = require("./first_name");
name.last_name = require("./last_name");module["exports"] = [
  "Bengu",
  "Bhengu",
  "Buthelezi",
  "Bhuyeni",
  "Bhembe",
  "Bhengani",
  "Bayeni",
  "Chiliza",
  "Cele",
  "Cebekhulu",
  "Dingiswayo",
  "Dlamini",
  "Dube",
  "Fuze",
  "Gwacela",
  "Gigaba",
  "Gumede",
  "Guliwe",
  "Gwala",
  "Gama",
  "Gumede",
  "Hlongwa",
  "Luthuli",
  "Msibi",
  "Mthethwa",
  "Mashinini",
  "Ndebele",
  "Ngubane",
  "Nondlela",
  "Nzimande",
  "Radebe",
  "Seme",
  "Senzangakhona",
  "Sondisa",
  "Zuma",
  "Dhlomo",
  "Nhleko",
  "Mabizela",
  "Khumalo",
  "Kunene",
  "Khawula",
  "Khuzwayo",
  "Lamula",
  "Lembede",
  "Lamula",
  "Mkhatshwa",
  "Moseley",
  "Mavundla",
  "Magoza",
  "Malinga",
  "Mbatha",
  "Mqwebu",
  "Mbende",
  "Maduma",
  "Mgenge",
  "Mehloluhlaza",
  "Maphisa",
  "Mfeka",
  "Mfumu",
  "Musi",
  "Mtolo",
  "Nonyana",
  "Ngema",
  "Ngwazi",
  "Nozulu",
  "Ntombela",
  "Ntanzi",
  "Mbuso",
  "Ngcolosi",
  "Gabhezi",
  "Nsele",
  "Nyanda",
  "Thusi",
  "Mbatha",
  "Biyela",
  "Gumede",
  "Nomvethe",
  "Ndandali",
  "Ncusi",
  "Sibiya",
  "Siyaya",
  "Sothole",
  "Sokhela",
  "Sithuli",
  "Shezi",
  "Siwele",
  "Tshabalala",
  "Thoyana",
  "Thumbeza",
  "Delazy",
  "Zungu",
  "Mthembu",
  "Vilakazi",
  "Vezi",
  "Mabhida",
  "Wosiyane",
  "Yengwa",
  "Zondo",
  "Zondi",
  "Zubane"
];module["exports"] = [
  "Bonginkosi",
  "Kagiso",
  "Bhekizizwe",
  "Bhekumbuso",
  "Shaka",
  "Funani",
  "Kgabu",
  "Solomon",
  "Gatsha",
  "Langa",
  "Phila",
  "Msizi",
  "Nkosiyabo",
  "Linda",
  "Mpilo",
  "Siyanda",
  "Nkanyezi",
  "Bafana",
  "Lwandle",
  "Sfiso",
  "Thulani",
  "Thando",
  "Sanele",
  "Anele",
  "Lungelo",
  "Dumisani",
  "Bangizwe",
  "Fanyana",
  "Bhekimuzi",
  "Mandla",
  "Maphikelela",
  "Mpumelelo",
  "Mthunzi",
  "Philani",
  "Musawenkosi",
  "Nkosenye",
  "Nkosinhle",
  "Phiwokwakhe",
  "Sifiso",
  "Zithulele",
  "Sithembiso",
  "Sipho",
  "Siphiwe",
  "Sibusiso",
  "Velaphi",
  "Thamsanqa",
  "Vusumuzi",
  "Themba",
  "Zenzele",
  "Ndleleni"
];module["exports"] = [
  "01# ### #####",
  "02# ### #####",
  "03# ### #####",
  "04# ### #####",
  "05# ### #####",
  "0800 ### ###",
  "0860 ### ###",
  "01#########",
  "01# ########",
];
var phone_number = {};
module['exports'] = phone_number;
phone_number.formats = require("./formats");

/**
 *
 * @namespace faker.lorem
 */
var Lorem = function (faker) {
  var self = this;
  var Helpers = faker.helpers;

  /**
   * generates a word of a specified length
   *
   * @method faker.lorem.word
   * @param {number} length length of the word that should be returned. Defaults to a random length
   */
  self.word = function (length) {
    var hasRightLength = function(word) { return word.length === length; };
    var properLengthWords;
    if(typeof length === 'undefined') {
      properLengthWords = faker.definitions.lorem.words;
    } else {
      properLengthWords = faker.definitions.lorem.words.filter(hasRightLength);
    }
    return faker.random.arrayElement(properLengthWords);
  };

  /**
   * generates a space separated list of words
   *
   * @method faker.lorem.words
   * @param {number} num number of words, defaults to 3
   */
  self.words = function (num) {
    if (typeof num == 'undefined') { num = 3; }
    var words = [];
    for (var i = 0; i < num; i++) {
      words.push(faker.lorem.word());
    }
    return words.join(' ');
  };

  /**
   * sentence
   *
   * @method faker.lorem.sentence
   * @param {number} wordCount defaults to a random number between 3 and 10
   * @param {number} range
   */
  self.sentence = function (wordCount, range) {
    if (typeof wordCount == 'undefined') { wordCount = faker.datatype.number({ min: 3, max: 10 }); }
    // if (typeof range == 'undefined') { range = 7; }

    // strange issue with the node_min_test failing for captialize, please fix and add faker.lorem.back
    //return  faker.lorem.words(wordCount + Helpers.randomNumber(range)).join(' ').capitalize();

    var sentence = faker.lorem.words(wordCount);
    return sentence.charAt(0).toUpperCase() + sentence.slice(1) + '.';
  };

  /**
   * slug
   *
   * @method faker.lorem.slug
   * @param {number} wordCount number of words, defaults to 3
   */
  self.slug = function (wordCount) {
    var words = faker.lorem.words(wordCount);
    return Helpers.slugify(words);
  };

  /**
   * sentences
   *
   * @method faker.lorem.sentences
   * @param {number} sentenceCount defautls to a random number between 2 and 6
   * @param {string} separator defaults to `' '`
   */
  self.sentences = function (sentenceCount, separator) {
    if (typeof sentenceCount === 'undefined') { sentenceCount = faker.datatype.number({ min: 2, max: 6 });}
    if (typeof separator == 'undefined') { separator = " "; }
    var sentences = [];
    for (sentenceCount; sentenceCount > 0; sentenceCount--) {
      sentences.push(faker.lorem.sentence());
    }
    return sentences.join(separator);
  };

  /**
   * paragraph
   *
   * @method faker.lorem.paragraph
   * @param {number} sentenceCount defaults to 3
   */
  self.paragraph = function (sentenceCount) {
    if (typeof sentenceCount == 'undefined') { sentenceCount = 3; }
    return faker.lorem.sentences(sentenceCount + faker.datatype.number(3));
  };

  /**
   * paragraphs
   *
   * @method faker.lorem.paragraphs
   * @param {number} paragraphCount defaults to 3
   * @param {string} separator defaults to `'\n \r'`
   */
  self.paragraphs = function (paragraphCount, separator) {
    if (typeof separator === "undefined") {
      separator = "\n \r";
    }
    if (typeof paragraphCount == 'undefined') { paragraphCount = 3; }
    var paragraphs = [];
    for (paragraphCount; paragraphCount > 0; paragraphCount--) {
      paragraphs.push(faker.lorem.paragraph());
    }
    return paragraphs.join(separator);
  }

  /**
   * returns random text based on a random lorem method
   *
   * @method faker.lorem.text
   * @param {number} times
   */
  self.text = function loremText (times) {
    var loremMethods = ['lorem.word', 'lorem.words', 'lorem.sentence', 'lorem.sentences', 'lorem.paragraph', 'lorem.paragraphs', 'lorem.lines'];
    var randomLoremMethod = faker.random.arrayElement(loremMethods);
    return faker.fake('{{' + randomLoremMethod + '}}');
  };

  /**
   * returns lines of lorem separated by `'\n'`
   *
   * @method faker.lorem.lines
   * @param {number} lineCount defaults to a random number between 1 and 5
   */
  self.lines = function lines (lineCount) {
    if (typeof lineCount === 'undefined') { lineCount = faker.datatype.number({ min: 1, max: 5 });}
    return faker.lorem.sentences(lineCount, '\n')
  };

  return self;
};


module["exports"] = Lorem;
var Gen = require('../vendor/mersenne').MersenneTwister19937;

function Mersenne() {
  var gen = new Gen();
  gen.init_genrand((new Date).getTime() % 1000000000);

  this.rand = function(max, min) {
    if (max === undefined)
    {
      min = 0;
      max = 32768;
    }
    return Math.floor(gen.genrand_real2() * (max - min) + min);
  }
  this.seed = function(S) {
    if (typeof(S) != 'number')
    {
      throw new Error("seed(S) must take numeric argument; is " + typeof(S));
    }
    gen.init_genrand(S);
  }
  this.seed_array = function(A) {
    if (typeof(A) != 'object')
    {
      throw new Error("seed_array(A) must take array of numbers; is " + typeof(A));
    }
    gen.init_by_array(A, A.length);
  }
}

module.exports = Mersenne;
/**
 *
 * @namespace faker.music
 */
var Music = function (faker) {
  var self = this;
  /**
     * genre
     *
     * @method faker.music.genre
     */
  self.genre = function () {
    return faker.random.arrayElement(faker.definitions.music.genre);
  };

  self.genre.schema = {
    "description": "Generates a genre.",
    "sampleResults": ["Rock", "Metal", "Pop"]
  };
};

module["exports"] = Music;
/**
 *
 * @namespace faker.name
 */
function Name (faker) {

  /**
   * firstName
   *
   * @method firstName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.firstName = function (gender) {
    if (typeof faker.definitions.name.male_first_name !== "undefined" && typeof faker.definitions.name.female_first_name !== "undefined") {
      // some locale datasets ( like ru ) have first_name split by gender. since the name.first_name field does not exist in these datasets,
      // we must randomly pick a name from either gender array so faker.name.firstName will return the correct locale data ( and not fallback )

      if(typeof gender === 'string') {
        if(gender.toLowerCase() === 'male') {
          gender = 0;
        }
        else if(gender.toLowerCase() === 'female') {
          gender = 1;
        }
      }

      if (typeof gender !== 'number') {
        if(typeof faker.definitions.name.first_name === "undefined") {
          gender = faker.datatype.number(1);
        }
        else {
          //Fall back to non-gendered names if they exist and gender wasn't specified
          return faker.random.arrayElement(faker.definitions.name.first_name);
        }
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.definitions.name.male_first_name)
      } else {
        return faker.random.arrayElement(faker.definitions.name.female_first_name);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.first_name);
  };

  /**
   * lastName
   *
   * @method lastName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.lastName = function (gender) {
    if (typeof faker.definitions.name.male_last_name !== "undefined" && typeof faker.definitions.name.female_last_name !== "undefined") {
      // some locale datasets ( like ru ) have last_name split by gender. i have no idea how last names can have genders, but also i do not speak russian
      // see above comment of firstName method
      if (typeof gender !== 'number') {
        gender = faker.datatype.number(1);
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.locales[faker.locale].name.male_last_name);
      } else {
        return faker.random.arrayElement(faker.locales[faker.locale].name.female_last_name);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.last_name);
  };

  /**
   * middleName
   *
   * @method middleName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.middleName = function (gender) {
    if (typeof faker.definitions.name.male_middle_name !== "undefined" && typeof faker.definitions.name.female_middle_name !== "undefined") {
      if (typeof gender !== 'number') {
        gender = faker.datatype.number(1);
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.locales[faker.locale].name.male_middle_name);
      } else {
        return faker.random.arrayElement(faker.locales[faker.locale].name.female_middle_name);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.middle_name);
  };

  /**
   * findName
   *
   * @method findName
   * @param {string} firstName
   * @param {string} lastName
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.findName = function (firstName, lastName, gender) {
    var r = faker.datatype.number(8);
    var prefix, suffix;
    // in particular locales first and last names split by gender,
    // thus we keep consistency by passing 0 as male and 1 as female
    if (typeof gender !== 'number') {
      gender = faker.datatype.number(1);
    }
    firstName = firstName || faker.name.firstName(gender);
    lastName = lastName || faker.name.lastName(gender);
    switch (r) {
      case 0:
        prefix = faker.name.prefix(gender);
        if (prefix) {
          return prefix + " " + firstName + " " + lastName;
        }
      case 1:
        suffix = faker.name.suffix(gender);
        if (suffix) {
          return firstName + " " + lastName + " " + suffix;
        }
    }

    return firstName + " " + lastName;
  };

  /**
   * jobTitle
   *
   * @method jobTitle
   * @memberof faker.name
   */
  this.jobTitle = function () {
    return  faker.name.jobDescriptor() + " " +
      faker.name.jobArea() + " " +
      faker.name.jobType();
  };

  /**
   * gender
   *
   * @method gender
   * @memberof faker.name
   */
  this.gender = function (binary) {
    if (binary) {
      return faker.random.arrayElement(faker.definitions.name.binary_gender);
    } else {
      return faker.random.arrayElement(faker.definitions.name.gender);
    }
  }
  
  /**
   * prefix
   *
   * @method prefix
   * @param {mixed} gender
   * @memberof faker.name
   */
  this.prefix = function (gender) {
    if (typeof faker.definitions.name.male_prefix !== "undefined" && typeof faker.definitions.name.female_prefix !== "undefined") {
      if (typeof gender !== 'number') {
        gender = faker.datatype.number(1);
      }
      if (gender === 0) {
        return faker.random.arrayElement(faker.locales[faker.locale].name.male_prefix);
      } else {
        return faker.random.arrayElement(faker.locales[faker.locale].name.female_prefix);
      }
    }
    return faker.random.arrayElement(faker.definitions.name.prefix);
  };

  /**
   * suffix
   *
   * @method suffix
   * @memberof faker.name
   */
  this.suffix = function () {
    return faker.random.arrayElement(faker.definitions.name.suffix);
  };

  /**
   * title
   *
   * @method title
   * @memberof faker.name
   */
  this.title = function() {
    var descriptor  = faker.random.arrayElement(faker.definitions.name.title.descriptor),
      level       = faker.random.arrayElement(faker.definitions.name.title.level),
      job         = faker.random.arrayElement(faker.definitions.name.title.job);

    return descriptor + " " + level + " " + job;
  };

  /**
   * jobDescriptor
   *
   * @method jobDescriptor
   * @memberof faker.name
   */
  this.jobDescriptor = function () {
    return faker.random.arrayElement(faker.definitions.name.title.descriptor);
  };

  /**
   * jobArea
   *
   * @method jobArea
   * @memberof faker.name
   */
  this.jobArea = function () {
    return faker.random.arrayElement(faker.definitions.name.title.level);
  };

  /**
   * jobType
   *
   * @method jobType
   * @memberof faker.name
   */
  this.jobType = function () {
    return faker.random.arrayElement(faker.definitions.name.title.job);
  };

}

module['exports'] = Name;
/**
 *
 * @namespace faker.phone
 */
var Phone = function (faker) {
  var self = this;

  /**
   * phoneNumber
   *
   * @method faker.phone.phoneNumber
   * @param {string} format
   * @memberOf faker.phone
   */
  self.phoneNumber = function (format) {
    format = format || faker.phone.phoneFormats();
    return faker.helpers.replaceSymbolWithNumber(format);
  };

  // FIXME: this is strange passing in an array index.
  /**
   * phoneNumberFormat
   *
   * @method faker.phone.phoneFormatsArrayIndex
   * @param phoneFormatsArrayIndex
   * @memberOf faker.phone
   */
  self.phoneNumberFormat = function (phoneFormatsArrayIndex) {
    phoneFormatsArrayIndex = phoneFormatsArrayIndex || 0;
    return faker.helpers.replaceSymbolWithNumber(faker.definitions.phone_number.formats[phoneFormatsArrayIndex]);
  };

  /**
   * phoneFormats
   *
   * @method faker.phone.phoneFormats
   */
  self.phoneFormats = function () {
    return faker.random.arrayElement(faker.definitions.phone_number.formats);
  };
  
  return self;

};

module['exports'] = Phone;
/**
 * Method to reduce array of characters
 * @param arr existing array of characters
 * @param values array of characters which should be removed
 * @return {*} new array without banned characters
 */
var arrayRemove = function (arr, values) {
  values.forEach(function(value){
    arr = arr.filter(function(ele){
      return ele !== value;
    });
  });
  return arr;
};

/**
 *
 * @namespace faker.random
 */
function Random (faker, seed) {
  // Use a user provided seed if it is an array or number
  if (Array.isArray(seed) && seed.length) {
    faker.mersenne.seed_array(seed);
  }
  else if(!isNaN(seed)) {
    faker.mersenne.seed(seed);
  }

  /**
   * @Deprecated
   * returns a single random number based on a max number or range
   *
   * @method faker.random.number
   * @param {mixed} options {min, max, precision}
   */
  this.number = function (options) {
    console.log("Deprecation Warning: faker.random.number is now located in faker.datatype.number");
    return faker.datatype.number(options);
  };

  /**
   * @Deprecated
   * returns a single random floating-point number based on a max number or range
   *
   * @method faker.random.float
   * @param {mixed} options
   */
  this.float = function (options) {
    console.log("Deprecation Warning: faker.random.float is now located in faker.datatype.float");
    return faker.datatype.float(options);
  };

  /**
   * takes an array and returns a random element of the array
   *
   * @method faker.random.arrayElement
   * @param {array} array
   */
  this.arrayElement = function (array) {
    array = array || ["a", "b", "c"];
    var r = faker.datatype.number({ max: array.length - 1 });
    return array[r];
  };

  /**
   * takes an array and returns a subset with random elements of the array
   *
   * @method faker.random.arrayElements
   * @param {array} array
   * @param {number} count number of elements to pick
   */
  this.arrayElements = function (array, count) {
    array = array || ["a", "b", "c"];

    if (typeof count !== 'number') {
      count = faker.datatype.number({ min: 1, max: array.length });
    } else if (count > array.length) {
      count = array.length;
    } else if (count < 0) {
      count = 0;
    }

    var arrayCopy = array.slice(0);
    var i = array.length;
    var min = i - count;
    var temp;
    var index;

    while (i-- > min) {
      index = Math.floor((i + 1) * faker.datatype.float({ min: 0, max: 0.99 }));
      temp = arrayCopy[index];
      arrayCopy[index] = arrayCopy[i];
      arrayCopy[i] = temp;
    }

    return arrayCopy.slice(min);
  };

  /**
   * takes an object and returns a random key or value
   *
   * @method faker.random.objectElement
   * @param {object} object
   * @param {mixed} field
   */
  this.objectElement = function (object, field) {
    object = object || { "foo": "bar", "too": "car" };
    var array = Object.keys(object);
    var key = faker.random.arrayElement(array);

    return field === "key" ? key : object[key];
  };

  /**
   * @Deprecated
   * uuid
   *
   * @method faker.random.uuid
   */
  this.uuid = function () {
    console.log("Deprecation Warning: faker.random.uuid is now located in faker.datatype.uuid");
    return faker.datatype.uuid();
  };

  /**
   * boolean
   *
   * @method faker.random.boolean
   */
  this.boolean = function () {
    console.log("Deprecation Warning: faker.random.boolean is now located in faker.datatype.boolean");
    return faker.datatype.boolean();
  };

  // TODO: have ability to return specific type of word? As in: noun, adjective, verb, etc
  /**
   * word
   *
   * @method faker.random.word
   * @param {string} type
   */
  this.word = function randomWord (type) {

    var wordMethods = [
      'commerce.department',
      'commerce.productName',
      'commerce.productAdjective',
      'commerce.productMaterial',
      'commerce.product',
      'commerce.color',

      'company.catchPhraseAdjective',
      'company.catchPhraseDescriptor',
      'company.catchPhraseNoun',
      'company.bsAdjective',
      'company.bsBuzz',
      'company.bsNoun',
      'address.streetSuffix',
      'address.county',
      'address.country',
      'address.state',

      'finance.accountName',
      'finance.transactionType',
      'finance.currencyName',

      'hacker.noun',
      'hacker.verb',
      'hacker.adjective',
      'hacker.ingverb',
      'hacker.abbreviation',

      'name.jobDescriptor',
      'name.jobArea',
      'name.jobType'];

    // randomly pick from the many faker methods that can generate words
    var randomWordMethod = faker.random.arrayElement(wordMethods);
    var result = faker.fake('{{' + randomWordMethod + '}}');
    return faker.random.arrayElement(result.split(' '));
  };

  /**
   * randomWords
   *
   * @method faker.random.words
   * @param {number} count defaults to a random value between 1 and 3
   */
  this.words = function randomWords (count) {
    var words = [];
    if (typeof count === "undefined") {
      count = faker.datatype.number({min:1, max: 3});
    }
    for (var i = 0; i<count; i++) {
      words.push(faker.random.word());
    }
    return words.join(' ');
  };

  /**
   * locale
   *
   * @method faker.random.image
   */
  this.image = function randomImage () {
    return faker.image.image();
  };

  /**
   * locale
   *
   * @method faker.random.locale
   */
  this.locale = function randomLocale () {
    return faker.random.arrayElement(Object.keys(faker.locales));
  };

  /**
   * alpha. returns lower/upper alpha characters based count and upcase options
   *
   * @method faker.random.alpha
   * @param {mixed} options // defaults to { count: 1, upcase: false, bannedChars: [] }
   */
  this.alpha = function alpha(options) {
    if (typeof options === "undefined") {
      options = {
        count: 1
      };
    } else if (typeof options === "number") {
      options = {
        count: options,
      };
    } else if (typeof options.count === "undefined") {
      options.count = 1;
    }

    if (typeof options.upcase === "undefined") {
      options.upcase = false;
    }
    if (typeof options.bannedChars ==="undefined"){
      options.bannedChars = [];
    }

    var wholeString = "";
    var charsArray = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
    if(options.bannedChars){
      charsArray = arrayRemove(charsArray,options.bannedChars);
    }
    for(var i = 0; i < options.count; i++) {
      wholeString += faker.random.arrayElement(charsArray);
    }

    return options.upcase ? wholeString.toUpperCase() : wholeString;
  }

  /**
   * alphaNumeric
   *
   * @method faker.random.alphaNumeric
   * @param {number} count defaults to 1
   * {mixed} options // defaults to { bannedChars: [] }
   * options.bannedChars - array of characters which should be banned in new string
   */
  this.alphaNumeric = function alphaNumeric(count, options) {
    if (typeof count === "undefined") {
      count = 1;
    }
    if (typeof options ==="undefined"){
      options = {};
    }
    if (typeof options.bannedChars ==="undefined"){
      options.bannedChars = [];
    }

    var wholeString = "";
    var charsArray = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
    if(options) {
      if (options.bannedChars) {
        charsArray = arrayRemove(charsArray, options.bannedChars);
      }
    }
    for(var i = 0; i < count; i++) {
      wholeString += faker.random.arrayElement(charsArray);
    }

    return wholeString;
  };

  /**
   * @Deprecated
   * hexaDecimal
   *
   * @method faker.random.hexaDecimal
   * @param {number} count defaults to 1
   */
  this.hexaDecimal = function hexaDecimal(count) {
    console.log("Deprecation Warning: faker.random.hexaDecimal is now located in faker.datatype.hexaDecimal");
    return faker.datatype.hexaDecimal(count);
  };

  return this;

}

module['exports'] = Random;
// generates fake data for many computer systems properties

var commonFileTypes = [
  "video",
  "audio",
  "image",
  "text",
  "application"
];

var commonMimeTypes = [
  "application/pdf",
  "audio/mpeg",
  "audio/wav",
  "image/png",
  "image/jpeg",
  "image/gif",
  "video/mp4",
  "video/mpeg",
  "text/html"
];

function setToArray(set) {
  // shortcut if Array.from is available
  if (Array.from) { return Array.from(set); }

  var array = [];
  set.forEach(function (item) {
    array.push(item);
  });
  return array;
}

/**
 *
 * @namespace faker.system
 */
function System(faker) {

  /**
   * generates a file name
   *
   * @method faker.system.fileName
   */
  this.fileName = function () {
    var str = faker.random.words(); 
    str = str
          .toLowerCase()
          .replace(/\W/g, "_") + "." + faker.system.fileExt();;
    return str;
  };

  /**
   * commonFileName
   *
   * @method faker.system.commonFileName
   * @param {string} ext
   */
  this.commonFileName = function (ext) {
    var str = faker.random.words();
    str = str
          .toLowerCase()
          .replace(/\W/g, "_");
    str += "." + (ext || faker.system.commonFileExt());
    return str;
  };

  /**
   * mimeType
   *
   * @method faker.system.mimeType
   */
  this.mimeType = function () {
    var typeSet = new Set();
    var extensionSet = new Set();
    var mimeTypes = faker.definitions.system.mimeTypes;

    Object.keys(mimeTypes).forEach(function (m) {
      var type = m.split("/")[0];

      typeSet.add(type);

      if (mimeTypes[m].extensions instanceof Array) {
        mimeTypes[m].extensions.forEach(function (ext) {
          extensionSet.add(ext);
        });
      }
    });

    var types = setToArray(typeSet);
    var extensions = setToArray(extensionSet);
    var mimeTypeKeys = Object.keys(faker.definitions.system.mimeTypes);

    return faker.random.arrayElement(mimeTypeKeys);
  };

  /**
   * returns a commonly used file type
   *
   * @method faker.system.commonFileType
   */
  this.commonFileType = function () {
    return faker.random.arrayElement(commonFileTypes);
  };

  /**
   * returns a commonly used file extension
   *
   * @method faker.system.commonFileExt
   */
  this.commonFileExt = function () {
    return faker.system.fileExt(faker.random.arrayElement(commonMimeTypes));
  };


  /**
   * returns any file type available as mime-type
   *
   * @method faker.system.fileType
   */
  this.fileType = function () {
    var typeSet = new Set();
    var extensionSet = new Set();
    var mimeTypes = faker.definitions.system.mimeTypes;

    Object.keys(mimeTypes).forEach(function (m) {
      var type = m.split("/")[0];

      typeSet.add(type);

      if (mimeTypes[m].extensions instanceof Array) {
        mimeTypes[m].extensions.forEach(function (ext) {
          extensionSet.add(ext);
        });
      }
    });

    var types = setToArray(typeSet);
    var extensions = setToArray(extensionSet);
    var mimeTypeKeys = Object.keys(faker.definitions.system.mimeTypes);
    return faker.random.arrayElement(types);

  };

  /**
   * fileExt
   *
   * @method faker.system.fileExt
   * @param {string} mimeType
   */
  this.fileExt = function (mimeType) {
    var typeSet = new Set();
    var extensionSet = new Set();
    var mimeTypes = faker.definitions.system.mimeTypes;

    Object.keys(mimeTypes).forEach(function (m) {
      var type = m.split("/")[0];

      typeSet.add(type);

      if (mimeTypes[m].extensions instanceof Array) {
        mimeTypes[m].extensions.forEach(function (ext) {
          extensionSet.add(ext);
        });
      }
    });

    var types = setToArray(typeSet);
    var extensions = setToArray(extensionSet);
    var mimeTypeKeys = Object.keys(faker.definitions.system.mimeTypes);

    if (mimeType) {
      var mimes = faker.definitions.system.mimeTypes;
      return faker.random.arrayElement(mimes[mimeType].extensions);
    }

    return faker.random.arrayElement(extensions);
  };

  /**
   * returns directory path
   *
   * @method faker.system.directoryPath
   */
  this.directoryPath = function () {
    var paths = faker.definitions.system.directoryPaths
    return faker.random.arrayElement(paths);
  };

  /**
   * returns file path
   *
   * @method faker.system.filePath
   */
  this.filePath = function () {
    return faker.fake("{{system.directoryPath}}/{{system.fileName}}.{{system.fileExt}}");
  };

  /**
   * semver
   *
   * @method faker.system.semver
   */
  this.semver = function () {
    return [faker.datatype.number(9),
      faker.datatype.number(9),
      faker.datatype.number(9)].join('.');
  }

}

module['exports'] = System;
/**
 *
 * @namespace faker.time
 */
var _Time = function(faker) {
  var self = this;

  /**
   * recent
   *
   * @method faker.time.recent
   * @param {string} outputType - 'abbr' || 'wide' || 'unix' (default choice)
   */
  self.recent = function(outputType) {
    if (typeof outputType === "undefined") {
      outputType = 'unix';
    }

    var date = new Date();
    switch (outputType) {
      case "abbr":
        date = date.toLocaleTimeString();
        break;
      case "wide":
        date = date.toTimeString();
        break;
      case "unix":
        date = date.getTime();
        break;
    }
    return date;
  };

  return self;
};

module["exports"] = _Time;
var uniqueExec = require('../vendor/unique');
/**
 *
 * @namespace faker.unique
 */
function Unique (faker) {

  // initialize unique module class variables

  // maximum time unique.exec will attempt to run before aborting
  var maxTime = 10;

  // maximum retries unique.exec will recurse before abortings ( max loop depth )
  var maxRetries = 10;

  // time the script started
  // var startTime = 0;

  /**
   * unique
   *
   * @method unique
   */
  this.unique = function unique (method, args, opts) {
    opts = opts || {};
    opts.startTime = new Date().getTime();
    if (typeof opts.maxTime !== 'number') {
      opts.maxTime = maxTime;
    }
    if (typeof opts.maxRetries !== 'number') {
      opts.maxRetries = maxRetries;
    }
    opts.currentIterations = 0;
    return uniqueExec.exec(method, args, opts);
  }
}

module['exports'] = Unique;/**
 *
 * @namespace faker.vehicle
 */
var Vehicle = function (faker) {
  var self = this;
  var fake = faker.fake;

  /**
   * vehicle
   *
   * @method faker.vehicle.vehicle
   */
  self.vehicle = function () {
    return fake('{{vehicle.manufacturer}} {{vehicle.model}}');
  };

  self.vehicle.schema = {
    "description": "Generates a random vehicle.",
    "sampleResults": ["BMW Explorer", "Ford Camry", "Lamborghini Ranchero"]
  };

  /**
   * manufacturer
   *
   * @method faker.vehicle.manufacturer
   */
  self.manufacturer = function () {
    return faker.random.arrayElement(faker.definitions.vehicle.manufacturer);
  };

  self.manufacturer.schema = {
    "description": "Generates a manufacturer name.",
    "sampleResults": ["Ford", "Jeep", "Tesla"]
  };


  /**
   * model
   *
   * @method faker.vehicle.model
   */
  self.model = function () {
    return faker.random.arrayElement(faker.definitions.vehicle.model);
  };

  self.model.schema = {
    "description": "Generates a vehicle model.",
    "sampleResults": ["Explorer", "Camry", "Ranchero"]
  };

  /**
   * type
   *
   * @method faker.vehicle.type
   */
  self.type = function () {
    return faker.random.arrayElement(faker.definitions.vehicle.type);
  };

  self.type.schema = {
    "description": "Generates a vehicle type.",
    "sampleResults": ["Coupe", "Convertable", "Sedan", "SUV"]
  };

  /**
   * fuel
   *
   * @method faker.vehicle.fuel
   */
  self.fuel = function () {
    return faker.random.arrayElement(faker.definitions.vehicle.fuel);
  };

  self.fuel.schema = {
    "description": "Generates a fuel type.",
    "sampleResults": ["Electric", "Gasoline", "Diesel"]
  };

  /**
   * vin
   *
   * @method faker.vehicle.vin
   */
  self.vin = function () {
    var bannedChars=['o','i','q'];
    return (
      faker.random.alphaNumeric(10, {bannedChars:bannedChars}) +
      faker.random.alpha({ count: 1, upcase: true ,bannedChars:bannedChars}) +
      faker.random.alphaNumeric(1, {bannedChars:bannedChars}) +
      faker.datatype.number({ min: 10000, max: 100000}) // return five digit #
    ).toUpperCase();
  };

  self.vin.schema = {
    "description": "Generates a valid VIN number.",
    "sampleResults": ["YV1MH682762184654", "3C7WRMBJ2EG208836"]
  };

  /**
   * color
   *
   * @method faker.vehicle.color
   */
  self.color = function () {
    return fake('{{commerce.color}}');
  };

  self.color.schema = {
    "description": "Generates a color",
    "sampleResults": ["red", "white", "black"]
  };

  /**
     * vrm
     *
     * @method faker.vehicle.vrm
     */
  self.vrm = function () {
    return (
      faker.random.alpha({ count: 2, upcase: true }) +
            faker.datatype.number({ min: 0, max: 9 }) +
            faker.datatype.number({ min: 0, max: 9 }) +
            faker.random.alpha({ count: 3, upcase: true })
    ).toUpperCase();
  };

  self.vrm.schema = {
    "description": "Generates a vehicle vrm",
    "sampleResults": ["MF56UPA", "GL19AAQ", "SF20TTA"]
  };

  /**
  * bicycle
  *
  * @method faker.vehicle.bicycle
  */
  self.bicycle = function () {
    return faker.random.arrayElement(faker.definitions.vehicle.bicycle_type);
  };

  self.bicycle.schema = {
    "description": "Generates a type of bicycle",
    "sampleResults": ["Adventure Road Bicycle", "City Bicycle", "Recumbent Bicycle"]
  };
};

module["exports"] = Vehicle;
var Faker = require('../lib');
var faker = new Faker({ locale: 'af_ZA', localeFallback: 'en' });
faker.locales['af_ZA'] = require('../lib/locales/af_ZA');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'ar', localeFallback: 'en' });
faker.locales['ar'] = require('../lib/locales/ar');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'az', localeFallback: 'en' });
faker.locales['az'] = require('../lib/locales/az');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'cz', localeFallback: 'en' });
faker.locales['cz'] = require('../lib/locales/cz');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'de_AT', localeFallback: 'en' });
faker.locales['de_AT'] = require('../lib/locales/de_AT');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'de_CH', localeFallback: 'en' });
faker.locales['de_CH'] = require('../lib/locales/de_CH');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'de', localeFallback: 'en' });
faker.locales['de'] = require('../lib/locales/de');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'el', localeFallback: 'en' });
faker.locales['el'] = require('../lib/locales/el');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_AU_ocker', localeFallback: 'en' });
faker.locales['en_AU_ocker'] = require('../lib/locales/en_AU_ocker');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_AU', localeFallback: 'en' });
faker.locales['en_AU'] = require('../lib/locales/en_AU');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_BORK', localeFallback: 'en' });
faker.locales['en_BORK'] = require('../lib/locales/en_BORK');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_CA', localeFallback: 'en' });
faker.locales['en_CA'] = require('../lib/locales/en_CA');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_GB', localeFallback: 'en' });
faker.locales['en_GB'] = require('../lib/locales/en_GB');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_GH', localeFallback: 'en' });
faker.locales['en_GH'] = require('../lib/locales/en_GH');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_IE', localeFallback: 'en' });
faker.locales['en_IE'] = require('../lib/locales/en_IE');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_IND', localeFallback: 'en' });
faker.locales['en_IND'] = require('../lib/locales/en_IND');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_NG', localeFallback: 'en' });
faker.locales['en_NG'] = require('../lib/locales/en_NG');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_US', localeFallback: 'en' });
faker.locales['en_US'] = require('../lib/locales/en_US');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en_ZA', localeFallback: 'en' });
faker.locales['en_ZA'] = require('../lib/locales/en_ZA');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'en', localeFallback: 'en' });
faker.locales['en'] = require('../lib/locales/en');

module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'es_MX', localeFallback: 'en' });
faker.locales['es_MX'] = require('../lib/locales/es_MX');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'es', localeFallback: 'en' });
faker.locales['es'] = require('../lib/locales/es');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'fa', localeFallback: 'en' });
faker.locales['fa'] = require('../lib/locales/fa');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'fi', localeFallback: 'en' });
faker.locales['fi'] = require('../lib/locales/fi');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;var Faker = require('../lib');
var faker = new Faker({ locale: 'fr_CA', localeFallback: 'en' });
faker.locales['fr_CA'] = require('../lib/locales/fr_CA');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'fr_CH', localeFallback: 'en' });
faker.locales['fr_CH'] = require('../lib/locales/fr_CH');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'fr', localeFallback: 'en' });
faker.locales['fr'] = require('../lib/locales/fr');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'ge', localeFallback: 'en' });
faker.locales['ge'] = require('../lib/locales/ge');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'he', localeFallback: 'en' });
faker.locales['he'] = require('../lib/locales/he');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'de', localeFallback: 'en' });
faker.locales['hr'] = require('../lib/locales/hr');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'hy', localeFallback: 'en' });
faker.locales['hy'] = require('../lib/locales/hy');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;var Faker = require('../lib');
var faker = new Faker({ locale: 'id_ID', localeFallback: 'en' });
faker.locales['id_ID'] = require('../lib/locales/id_ID');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'it', localeFallback: 'en' });
faker.locales['it'] = require('../lib/locales/it');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'ja', localeFallback: 'en' });
faker.locales['ja'] = require('../lib/locales/ja');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'ko', localeFallback: 'en' });
faker.locales['ko'] = require('../lib/locales/ko');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'nb_NO', localeFallback: 'en' });
faker.locales['nb_NO'] = require('../lib/locales/nb_NO');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'ne', localeFallback: 'en' });
faker.locales['ne'] = require('../lib/locales/ne');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'nl_BE', localeFallback: 'nl' });
faker.locales['nl_BE'] = require('../lib/locales/nl_BE');
faker.locales['nl'] = require('../lib/locales/nl');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'nl', localeFallback: 'en' });
faker.locales['nl'] = require('../lib/locales/nl');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'pl', localeFallback: 'en' });
faker.locales['pl'] = require('../lib/locales/pl');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'pt_BR', localeFallback: 'en' });
faker.locales['pt_BR'] = require('../lib/locales/pt_BR');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'pt_PT', localeFallback: 'en' });
faker.locales['pt_PT'] = require('../lib/locales/pt_PT');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
# Read Me

The files in this directory have been auto-generated from the `gulpfile`.

These file exist in order to allow users to require the `faker` library using a specific locale ( instead of the default behavior or loading all locales ).

Example:

``` js
var faker = require('../locale/en');
console.log(faker.name.findName());
```var Faker = require('../lib');
var faker = new Faker({ locale: 'ro', localeFallback: 'en' });
faker.locales['ro'] = require('../lib/locales/ro');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'ru', localeFallback: 'en' });
faker.locales['ru'] = require('../lib/locales/ru');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'sk', localeFallback: 'en' });
faker.locales['sk'] = require('../lib/locales/sk');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'sv', localeFallback: 'en' });
faker.locales['sv'] = require('../lib/locales/sv');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'tr', localeFallback: 'en' });
faker.locales['tr'] = require('../lib/locales/tr');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'uk', localeFallback: 'en' });
faker.locales['uk'] = require('../lib/locales/uk');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'vi', localeFallback: 'en' });
faker.locales['vi'] = require('../lib/locales/vi');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'zh_CN', localeFallback: 'en' });
faker.locales['zh_CN'] = require('../lib/locales/zh_CN');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'zh_TW', localeFallback: 'en' });
faker.locales['zh_TW'] = require('../lib/locales/zh_TW');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
var Faker = require('../lib');
var faker = new Faker({ locale: 'zu_ZA', localeFallback: 'en' });
faker.locales['zu_ZA'] = require('../lib/locales/zu_ZA');
faker.locales['en'] = require('../lib/locales/en');
module['exports'] = faker;
faker.js - Copyright (c) 2020
Marak Squires
http://github.com/marak/faker.js/

faker.js was inspired by and has used data definitions from:

 * https://github.com/stympy/faker/ - Copyright (c) 2007-2010 Benjamin Curtis
 * http://search.cpan.org/~jasonk/Data-Faker-0.07/ - Copyright 2004-2005 by Jason Kohles

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Npm.depends({
    'faker': '3.0.1'
});


Package.describe({
  summary: "Generate massive amounts of fake data in node.js and in the browser.",
  name: "practicalmeteor:faker",
  version: "3.0.1_1",
  git: "https://github.com/practicalmeteor/meteor-faker.git",
  documentation: 'Readme.md'
});


Package.onUse(function (api) {
  api.versionsFrom('1.0');

  api.addFiles('meteor/npm-require.js', 'server');

  api.addFiles('build/build/faker.js', 'client');

  api.export("faker", "server");
});


Package.onTest(function(api) {
  api.use(['practicalmeteor:faker', "coffeescript", "tinytest", 'practicalmeteor:chai']);

  api.addFiles("meteor/tests/faker-export-test.coffee");
});
{ "name": "@faker-js/faker", "description": "Generate massive amounts of fake contextual data", "version": "5.5.3", "contributors": [ "Marak Squires <marak.squires@gmail.com>" ], "repository": { "type": "git", "url": "http://github.com/Marak/Faker.js.git" }, "scripts": { "browser": "./node_modules/.bin/gulp browser", "jsdoc": "./node_modules/.bin/gulp jsdoc", "readme": "./node_modules/.bin/gulp readme", "lint": "node_modules/.bin/eslint ./lib/animal.js", "test": "node_modules/.bin/mocha test/*.*.js", "coverage": "nyc report --reporter=text-lcov | coveralls" }, "nyc": { "all": false, "include": [ "lib/**/*.js", "vendor/*.js" ], "exclude": [ "coverage", "locales", "modules", "white", "docs", "docker", "public", "reports", "tests", "node_modules" ], "reporter": [ "html", "lcov", "clover" ], "report-dir": "./reports/coverage" }, "devDependencies": { "browserify": "^16.5.2", "coveralls": "^3.1.0", "gulp": "^4.0.2", "gulp-gh-pages": "^0.5.4", "gulp-jsdoc3": "^3.0.0", "gulp-mustache": "^5.0.0", "gulp-rename": "^2.0.0", "gulp-uglify": "^3.0.2", "eslint": "^6.5.1", "ink-docstrap": "1.1.4", "jsdoc": "^3.4.0", "lint-staged": "^9.4.2", "lodash": "^4.6.1", "mocha": "^8.1.1", "node-minify": "*", "nyc": "^15.1.0", "optimist": "0.3.5", "sinon": "^9.0.3", "through2": "2.0.0", "vinyl-buffer": "^1.0.1", "vinyl-source-stream": "^2.0.0", "vinyl-transform": "^1.0.0" }, "license": "MIT", "main": "index.js", "dependencies": {} }
# faker.js - generate massive amounts of fake data in the browser and node.js

![Faker.js](https://raw.githubusercontent.com/Marak/faker.js/master/logo.png)

[![Build Status](https://travis-ci.org/Marak/faker.js.svg?branch=master)](https://travis-ci.org/Marak/faker.js) [![Coverage Status](https://coveralls.io/repos/github/Marak/faker.js/badge.svg?branch=master)](https://coveralls.io/github/Marak/faker.js?branch=master)

[![npm version](https://badge.fury.io/js/faker.svg)](http://badge.fury.io/js/faker)

[![OpenCollective](https://opencollective.com/fakerjs/backers/badge.svg)](#backers)
[![OpenCollective](https://opencollective.com/fakerjs/sponsors/badge.svg)](#sponsors)
[![Gitter chat](https://badges.gitter.im/marak/faker.js.png)](https://gitter.im/Faker-js/community)

## Demo

[https://rawgit.com/Marak/faker.js/master/examples/browser/index.html](https://rawgit.com/Marak/faker.js/master/examples/browser/index.html)

### Faker Cloud

Don't have a local development setup ready? 

Try our hosted version of Faker at [https://fakercloud.com/api](https://fakercloud.com/api)

https://github.com/faker/faker-cloud

## Usage

### Browser

```html
    <script src = "faker.js" type = "text/javascript"></script>
    <script>
      var randomName = faker.name.findName(); // Caitlyn Kerluke
      var randomEmail = faker.internet.email(); // Rusty@arne.info
      var randomCard = faker.helpers.createCard(); // random contact card containing many properties
    </script>
```

### Node.js

```js
    var faker = require('faker');

    var randomName = faker.name.findName(); // Rowan Nikolaus
    var randomEmail = faker.internet.email(); // Kassandra.Haley@erich.biz
    var randomCard = faker.helpers.createCard(); // random contact card containing many properties
```

## API

### JSDoc API Browser

[http://marak.github.io/faker.js/](http://marak.github.io/faker.js/)

### API Methods

* address
  * zipCode
  * zipCodeByState
  * city
  * cityPrefix
  * citySuffix
  * cityName
  * streetName
  * streetAddress
  * streetSuffix
  * streetPrefix
  * secondaryAddress
  * county
  * country
  * countryCode
  * state
  * stateAbbr
  * latitude
  * longitude
  * direction
  * cardinalDirection
  * ordinalDirection
  * nearbyGPSCoordinate
  * timeZone
* animal
  * dog
  * cat
  * snake
  * bear
  * lion
  * cetacean
  * horse
  * bird
  * cow
  * fish
  * crocodilia
  * insect
  * rabbit
  * type
* commerce
  * color
  * department
  * productName
  * price
  * productAdjective
  * productMaterial
  * product
  * productDescription
* company
  * suffixes
  * companyName
  * companySuffix
  * catchPhrase
  * bs
  * catchPhraseAdjective
  * catchPhraseDescriptor
  * catchPhraseNoun
  * bsAdjective
  * bsBuzz
  * bsNoun
* database
  * column
  * type
  * collation
  * engine
* datatype
  * number
  * float
  * datetime
  * string
  * uuid
  * boolean
  * hexaDecimal
  * json
  * array
* date
  * past
  * future
  * between
  * betweens
  * recent
  * soon
  * month
  * weekday
* fake
* finance
  * account
  * accountName
  * routingNumber
  * mask
  * amount
  * transactionType
  * currencyCode
  * currencyName
  * currencySymbol
  * bitcoinAddress
  * litecoinAddress
  * creditCardNumber
  * creditCardCVV
  * ethereumAddress
  * iban
  * bic
  * transactionDescription
* git
  * branch
  * commitEntry
  * commitMessage
  * commitSha
  * shortSha
* hacker
  * abbreviation
  * adjective
  * noun
  * verb
  * ingverb
  * phrase
* helpers
  * randomize
  * slugify
  * replaceSymbolWithNumber
  * replaceSymbols
  * replaceCreditCardSymbols
  * repeatString
  * regexpStyleStringParse
  * shuffle
  * mustache
  * createCard
  * contextualCard
  * userCard
  * createTransaction
* image
  * image
  * avatar
  * imageUrl
  * abstract
  * animals
  * business
  * cats
  * city
  * food
  * nightlife
  * fashion
  * people
  * nature
  * sports
  * technics
  * transport
  * dataUri
  * lorempixel
  * unsplash
  * lorempicsum
* internet
  * avatar
  * email
  * exampleEmail
  * userName
  * protocol
  * httpMethod
  * url
  * domainName
  * domainSuffix
  * domainWord
  * ip
  * ipv6
  * port
  * userAgent
  * color
  * mac
  * password
* lorem
  * word
  * words
  * sentence
  * slug
  * sentences
  * paragraph
  * paragraphs
  * text
  * lines
* mersenne
  * rand
  * seed
  * seed_array
* music
  * genre
* name
  * firstName
  * lastName
  * middleName
  * findName
  * jobTitle
  * gender
  * prefix
  * suffix
  * title
  * jobDescriptor
  * jobArea
  * jobType
* phone
  * phoneNumber
  * phoneNumberFormat
  * phoneFormats
* random
  * number
  * float
  * arrayElement
  * arrayElements
  * objectElement
  * uuid
  * boolean
  * word
  * words
  * image
  * locale
  * alpha
  * alphaNumeric
  * hexaDecimal
* system
  * fileName
  * commonFileName
  * mimeType
  * commonFileType
  * commonFileExt
  * fileType
  * fileExt
  * directoryPath
  * filePath
  * semver
* time
  * recent
* unique
* vehicle
  * vehicle
  * manufacturer
  * model
  * type
  * fuel
  * vin
  * color
  * vrm
  * bicycle


### Faker.fake()

faker.js contains a super useful generator method `Faker.fake` for combining faker API methods using a mustache string format.

**Example:**


``` js
console.log(faker.fake("{{name.lastName}}, {{name.firstName}} {{name.suffix}}"));
// outputs: "Marks, Dean Sr."
```


This will interpolate the format string with the value of methods `name.lastName()`, `name.firstName()`, and `name.suffix()`

## Localization

As of version `v2.0.0` faker.js has support for multiple localities.

The default language locale is set to English.

Setting a new locale is simple:

```js
// sets locale to de
faker.locale = "de";
```

 * az
 * ar
 * cz
 * de
 * de_AT
 * de_CH
 * en
 * en_AU
 * en_AU_ocker
 * en_BORK
 * en_CA
 * en_GB
 * en_IE
 * en_IND
 * en_US
 * en_ZA
 * es
 * es_MX
 * fa
 * fi
 * fr
 * fr_CA
 * fr_CH
 * ge
 * hy
 * hr
 * id_ID
 * it
 * ja
 * ko
 * nb_NO
 * ne
 * nl
 * nl_BE
 * pl
 * pt_BR
 * pt_PT
 * ro
 * ru
 * sk
 * sv
 * tr
 * uk
 * vi
 * zh_CN
 * zh_TW


### Individual Localization Packages

faker.js supports incremental loading of locales.

By default, requiring `faker` will include *all* locale data.

In a production environment, you may only want to include the locale data for a specific set of locales.

```js
// loads only de locale
var faker = require('faker/locale/de');
```

## Setting a randomness seed

If you want consistent results, you can set your own seed:

```js
faker.seed(123);

var firstRandom = faker.datatype.number();

// Setting the seed again resets the sequence.
faker.seed(123);

var secondRandom = faker.datatype.number();

console.log(firstRandom === secondRandom);
```

## Tests

```shell
npm install .
make test
```

You can view a code coverage report generated in coverage/lcov-report/index.html.

## Building faker.js

faker uses [gulp](http://gulpjs.com/) to automate its build process. Each build operation is a separate task which can be run independently.

### Browser Bundle

```shell
npm run browser
```

### Building JSDocs

[JSDOC](https://jsdoc.app/) v3 HTML API documentation

```shell
npm run jsdoc
```

### Building ReadMe

The `ReadMe.md` file for `faker.js` is automatically generated and should not be modified directly. All updates to `ReadMe.md` should be performed in `./build/src/docs.md` and then the build script should be run.

```shell
npm run readme
```

## Version Release Schedule

faker.js is a popular project used by many organizations and individuals in production settings. Major and Minor version releases are generally on a monthly schedule. Bugs fixes are addressed by severity and fixed as soon as possible.

If you require the absolute latest version of `faker.js` the `master` branch @ <http://github.com/marak/faker.js/> should always be up to date and working.

## Maintainer

#### Marak Squires

faker.js - Copyright (c) 2020
Marak Squires
www.marak.com
http://github.com/marak/faker.js/

faker.js was inspired by and has used data definitions from:

 * <https://github.com/stympy/faker/> - Copyright (c) 2007-2010 Benjamin Curtis
 * <http://search.cpan.org/~jasonk/Data-Faker-0.07/> - Copyright 2004-2005 by Jason Kohles

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

## Backers

Support us with a monthly donation and help us continue our activities. [[Become a backer](https://opencollective.com/fakerjs#backer)]

<a href="https://opencollective.com/fakerjs/backer/0/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/0/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/1/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/1/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/2/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/2/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/3/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/3/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/4/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/4/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/5/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/5/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/6/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/6/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/7/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/7/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/8/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/8/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/9/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/9/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/10/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/10/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/11/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/11/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/12/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/12/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/13/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/13/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/14/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/14/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/15/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/15/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/16/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/16/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/17/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/17/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/18/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/18/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/19/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/19/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/20/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/20/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/21/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/21/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/22/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/22/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/23/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/23/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/24/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/24/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/25/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/25/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/26/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/26/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/27/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/27/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/28/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/28/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/backer/29/website" target="_blank"><img src="https://opencollective.com/fakerjs/backer/29/avatar.svg"></a>

## Sponsors

Become a sponsor and get your logo on our README on Github with a link to your site. [[Become a sponsor](https://opencollective.com/fakerjs#sponsor)]

<a href="https://opencollective.com/fakerjs/sponsor/0/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/0/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/1/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/1/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/2/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/2/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/3/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/3/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/4/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/4/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/5/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/5/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/6/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/6/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/7/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/7/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/8/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/8/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/9/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/9/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/10/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/10/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/11/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/11/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/12/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/12/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/13/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/13/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/14/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/14/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/15/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/15/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/16/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/16/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/17/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/17/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/18/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/18/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/19/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/19/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/20/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/20/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/21/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/21/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/22/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/22/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/23/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/23/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/24/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/24/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/25/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/25/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/26/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/26/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/27/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/27/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/28/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/28/avatar.svg"></a>
<a href="https://opencollective.com/fakerjs/sponsor/29/website" target="_blank"><img src="https://opencollective.com/fakerjs/sponsor/29/avatar.svg"></a>
// this program is a JavaScript version of Mersenne Twister, with concealment and encapsulation in class,
// an almost straight conversion from the original program, mt19937ar.c,
// translated by y. okada on July 17, 2006.
// and modified a little at july 20, 2006, but there are not any substantial differences.
// in this program, procedure descriptions and comments of original source code were not removed.
// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.
// lines commented with /* and */ are original comments.
// lines commented with // are additional comments in this JavaScript version.
// before using this version, create at least one instance of MersenneTwister19937 class, and initialize the each state, given below in c comments, of all the instances.
/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

function MersenneTwister19937()
{
  /* constants should be scoped inside the class */
  var N, M, MATRIX_A, UPPER_MASK, LOWER_MASK;
  /* Period parameters */
  //c//#define N 624
  //c//#define M 397
  //c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
  //c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
  //c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */
  N = 624;
  M = 397;
  MATRIX_A = 0x9908b0df;   /* constant vector a */
  UPPER_MASK = 0x80000000; /* most significant w-r bits */
  LOWER_MASK = 0x7fffffff; /* least significant r bits */
  //c//static unsigned long mt[N]; /* the array for the state vector  */
  //c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */
  var mt = new Array(N);   /* the array for the state vector  */
  var mti = N+1;           /* mti==N+1 means mt[N] is not initialized */

  function unsigned32 (n1) // returns a 32-bits unsiged integer from an operand to which applied a bit operator.
  {
    return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1;
  }

  function subtraction32 (n1, n2) // emulates lowerflow of a c 32-bits unsiged integer variable, instead of the operator -. these both arguments must be non-negative integers expressible using unsigned 32 bits.
  {
    return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) : n1 - n2;
  }

  function addition32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator +. these both arguments must be non-negative integers expressible using unsigned 32 bits.
  {
    return unsigned32((n1 + n2) & 0xffffffff)
  }

  function multiplication32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator *. these both arguments must be non-negative integers expressible using unsigned 32 bits.
  {
    var sum = 0;
    for (var i = 0; i < 32; ++i){
      if ((n1 >>> i) & 0x1){
        sum = addition32(sum, unsigned32(n2 << i));
      }
    }
    return sum;
  }

  /* initializes mt[N] with a seed */
  //c//void init_genrand(unsigned long s)
  this.init_genrand = function (s)
  {
    //c//mt[0]= s & 0xffffffff;
    mt[0]= unsigned32(s & 0xffffffff);
    for (mti=1; mti<N; mti++) {
      mt[mti] =
			//c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
			addition32(multiplication32(1812433253, unsigned32(mt[mti-1] ^ (mt[mti-1] >>> 30))), mti);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array mt[].                        */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      //c//mt[mti] &= 0xffffffff;
      mt[mti] = unsigned32(mt[mti] & 0xffffffff);
      /* for >32 bit machines */
    }
  }

  /* initialize by an array with array-length */
  /* init_key is the array for initializing keys */
  /* key_length is its length */
  /* slight change for C++, 2004/2/26 */
  //c//void init_by_array(unsigned long init_key[], int key_length)
  this.init_by_array = function (init_key, key_length)
  {
    //c//int i, j, k;
    var i, j, k;
    //c//init_genrand(19650218);
    this.init_genrand(19650218);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
      //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))
      //c//	+ init_key[j] + j; /* non linear */
      mt[i] = addition32(addition32(unsigned32(mt[i] ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1664525)), init_key[j]), j);
      mt[i] =
			//c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
			unsigned32(mt[i] & 0xffffffff);
      i++; j++;
      if (i>=N) { mt[0] = mt[N-1]; i=1; }
      if (j>=key_length) {j=0;}
    }
    for (k=N-1; k; k--) {
      //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))
      //c//- i; /* non linear */
      mt[i] = subtraction32(unsigned32((dbg=mt[i]) ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1566083941)), i);
      //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
      mt[i] = unsigned32(mt[i] & 0xffffffff);
      i++;
      if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }
    mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
  }

  /* moved outside of genrand_int32() by jwatte 2010-11-17; generate less garbage */
  var mag01 = [0x0, MATRIX_A];

  /* generates a random number on [0,0xffffffff]-interval */
  //c//unsigned long genrand_int32(void)
  this.genrand_int32 = function ()
  {
    //c//unsigned long y;
    //c//static unsigned long mag01[2]={0x0UL, MATRIX_A};
    var y;
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
      //c//int kk;
      var kk;

      if (mti == N+1)   /* if init_genrand() has not been called, */
      //c//init_genrand(5489); /* a default initial seed is used */
      {this.init_genrand(5489);} /* a default initial seed is used */

      for (kk=0;kk<N-M;kk++) {
        //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
        //c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
        y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));
        mt[kk] = unsigned32(mt[kk+M] ^ (y >>> 1) ^ mag01[y & 0x1]);
      }
      for (;kk<N-1;kk++) {
        //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
        //c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
        y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));
        mt[kk] = unsigned32(mt[kk+(M-N)] ^ (y >>> 1) ^ mag01[y & 0x1]);
      }
      //c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
      //c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
      y = unsigned32((mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK));
      mt[N-1] = unsigned32(mt[M-1] ^ (y >>> 1) ^ mag01[y & 0x1]);
      mti = 0;
    }

    y = mt[mti++];

    /* Tempering */
    //c//y ^= (y >> 11);
    //c//y ^= (y << 7) & 0x9d2c5680;
    //c//y ^= (y << 15) & 0xefc60000;
    //c//y ^= (y >> 18);
    y = unsigned32(y ^ (y >>> 11));
    y = unsigned32(y ^ ((y << 7) & 0x9d2c5680));
    y = unsigned32(y ^ ((y << 15) & 0xefc60000));
    y = unsigned32(y ^ (y >>> 18));

    return y;
  }

  /* generates a random number on [0,0x7fffffff]-interval */
  //c//long genrand_int31(void)
  this.genrand_int31 = function ()
  {
    //c//return (genrand_int32()>>1);
    return (this.genrand_int32()>>>1);
  }

  /* generates a random number on [0,1]-real-interval */
  //c//double genrand_real1(void)
  this.genrand_real1 = function ()
  {
    //c//return genrand_int32()*(1.0/4294967295.0);
    return this.genrand_int32()*(1.0/4294967295.0);
    /* divided by 2^32-1 */
  }

  /* generates a random number on [0,1)-real-interval */
  //c//double genrand_real2(void)
  this.genrand_real2 = function ()
  {
    //c//return genrand_int32()*(1.0/4294967296.0);
    return this.genrand_int32()*(1.0/4294967296.0);
    /* divided by 2^32 */
  }

  /* generates a random number on (0,1)-real-interval */
  //c//double genrand_real3(void)
  this.genrand_real3 = function ()
  {
    //c//return ((genrand_int32()) + 0.5)*(1.0/4294967296.0);
    return ((this.genrand_int32()) + 0.5)*(1.0/4294967296.0);
    /* divided by 2^32 */
  }

  /* generates a random number on [0,1) with 53-bit resolution*/
  //c//double genrand_res53(void)
  this.genrand_res53 = function ()
  {
    //c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;
    var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }
  /* These real versions are due to Isaku Wada, 2002/01/09 added */
}

//  Exports: Public API

//  Export the twister class
exports.MersenneTwister19937 = MersenneTwister19937;
// the `unique` module
var unique = {};

// global results store
// currently uniqueness is global to entire faker instance
// this means that faker should currently *never* return duplicate values across all API methods when using `Faker.unique`
// it's possible in the future that some users may want to scope found per function call instead of faker instance
var found = {};

// global exclude list of results
// defaults to nothing excluded
var exclude = [];

// current iteration or retries of unique.exec ( current loop depth )
var currentIterations = 0;

// uniqueness compare function
// default behavior is to check value as key against object hash
var defaultCompare = function(obj, key) {
  if (typeof obj[key] === 'undefined') {
    return -1;
  }
  return 0;
};

// common error handler for messages
unique.errorMessage = function (now, code, opts) {
  console.error('error', code);
  console.log('found', Object.keys(found).length, 'unique entries before throwing error. \nretried:', currentIterations, '\ntotal time:', now - opts.startTime, 'ms');
  throw new Error(code + ' for uniqueness check \n\nMay not be able to generate any more unique values with current settings. \nTry adjusting maxTime or maxRetries parameters for faker.unique()')
};

unique.exec = function (method, args, opts) {
  //console.log(currentIterations)

  var now = new Date().getTime();

  opts = opts || {};
  opts.maxTime = opts.maxTime || 3;
  opts.maxRetries = opts.maxRetries || 50;
  opts.exclude = opts.exclude || exclude;
  opts.compare = opts.compare || defaultCompare;

  if (typeof opts.currentIterations !== 'number') {
    opts.currentIterations = 0;
  }

  if (typeof opts.startTime === 'undefined') {
    opts.startTime = new Date().getTime();
  }

  var startTime = opts.startTime;

  // support single exclude argument as string
  if (typeof opts.exclude === 'string') {
    opts.exclude = [opts.exclude];
  }

  if (opts.currentIterations > 0) {
    // console.log('iterating', currentIterations)
  }

  // console.log(now - startTime)
  if (now - startTime >= opts.maxTime) {
    return unique.errorMessage(now, 'Exceeded maxTime:' + opts.maxTime, opts);
  }

  if (opts.currentIterations >= opts.maxRetries) {
    return unique.errorMessage(now, 'Exceeded maxRetries:' + opts.maxRetries, opts);
  }

  // execute the provided method to find a potential satifised value
  var result = method.apply(this, args);

  // if the result has not been previously found, add it to the found array and return the value as it's unique
  if (opts.compare(found, result) === -1 && opts.exclude.indexOf(result) === -1) {
    found[result] = result;
    opts.currentIterations = 0;
    return result;
  } else {
    // console.log('conflict', result);
    opts.currentIterations++;
    return unique.exec(method, args, opts);
  }
};

module.exports = unique;
/*

Copyright (c) 2012-2014 Jeffrey Mealo

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

------------------------------------------------------------------------------------------------------------------------

Based loosely on Luka Pusic's PHP Script: http://360percents.com/posts/php-random-user-agent-generator/

The license for that script is as follows:

"THE BEER-WARE LICENSE" (Revision 42):

<pusic93@gmail.com> wrote this file. As long as you retain this notice you can do whatever you want with this stuff.
If we meet some day, and you think this stuff is worth it, you can buy me a beer in return. Luka Pusic

*/

exports.generate = function generate(faker) {

  function rnd(a, b) {
    //calling rnd() with no arguments is identical to rnd(0, 100)
    a = a || 0;
    b = b || 100;

    if (typeof b === 'number' && typeof a === 'number') {

      // 9/2018 - Added faker random to ensure mersenne and seed
      return faker.datatype.number({ min: a, max: b});

    }

    if (Object.prototype.toString.call(a) === "[object Array]") {
      //returns a random element from array (a), even weighting
      return faker.random.arrayElement(a);
    }

    if (a && typeof a === 'object') {
      //returns a random key from the passed object; keys are weighted by the decimal probability in their value
      return (function (obj) {
        var rand = rnd(0, 100) / 100, min = 0, max = 0, key, return_val;

        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            max = obj[key] + min;
            return_val = key;
            if (rand >= min && rand <= max) {
              break;
            }
            min = min + obj[key];
          }
        }

        return return_val;
      }(a));
    }

    throw new TypeError('Invalid arguments passed to rnd. (' + (b ? a + ', ' + b : a) + ')');
  }

  function randomLang() {
    return rnd(['AB', 'AF', 'AN', 'AR', 'AS', 'AZ', 'BE', 'BG', 'BN', 'BO', 'BR', 'BS', 'CA', 'CE', 'CO', 'CS',
      'CU', 'CY', 'DA', 'DE', 'EL', 'EN', 'EO', 'ES', 'ET', 'EU', 'FA', 'FI', 'FJ', 'FO', 'FR', 'FY',
      'GA', 'GD', 'GL', 'GV', 'HE', 'HI', 'HR', 'HT', 'HU', 'HY', 'ID', 'IS', 'IT', 'JA', 'JV', 'KA',
      'KG', 'KO', 'KU', 'KW', 'KY', 'LA', 'LB', 'LI', 'LN', 'LT', 'LV', 'MG', 'MK', 'MN', 'MO', 'MS',
      'MT', 'MY', 'NB', 'NE', 'NL', 'NN', 'NO', 'OC', 'PL', 'PT', 'RM', 'RO', 'RU', 'SC', 'SE', 'SK',
      'SL', 'SO', 'SQ', 'SR', 'SV', 'SW', 'TK', 'TR', 'TY', 'UK', 'UR', 'UZ', 'VI', 'VO', 'YI', 'ZH']);
  }

  function randomBrowserAndOS() {
    var browser = rnd({
        chrome:    .45132810566,
        iexplorer: .27477061836,
        firefox:   .19384170608,
        safari:    .06186781118,
        opera:     .01574236955
      }),
      os = {
        chrome:  {win: .89,  mac: .09 , lin: .02},
        firefox: {win: .83,  mac: .16,  lin: .01},
        opera:   {win: .91,  mac: .03 , lin: .06},
        safari:  {win: .04 , mac: .96  },
        iexplorer: ['win']
      };

    return [browser, rnd(os[browser])];
  }

  function randomProc(arch) {
    var procs = {
      lin:['i686', 'x86_64'],
      mac: {'Intel' : .48, 'PPC': .01, 'U; Intel':.48, 'U; PPC' :.01},
      win:['', 'WOW64', 'Win64; x64']
    };
    return rnd(procs[arch]);
  }

  function randomRevision(dots) {
    var return_val = '';
    //generate a random revision
    //dots = 2 returns .x.y where x & y are between 0 and 9
    for (var x = 0; x < dots; x++) {
      return_val += '.' + rnd(0, 9);
    }
    return return_val;
  }

  var version_string = {
    net: function () {
      return [rnd(1, 4), rnd(0, 9), rnd(10000, 99999), rnd(0, 9)].join('.');
    },
    nt: function () {
      return rnd(5, 6) + '.' + rnd(0, 3);
    },
    ie: function () {
      return rnd(7, 11);
    },
    trident: function () {
      return rnd(3, 7) + '.' + rnd(0, 1);
    },
    osx: function (delim) {
      return [10, rnd(5, 10), rnd(0, 9)].join(delim || '.');
    },
    chrome: function () {
      return [rnd(13, 39), 0, rnd(800, 899), 0].join('.');
    },
    presto: function () {
      return '2.9.' + rnd(160, 190);
    },
    presto2: function () {
      return rnd(10, 12) + '.00';
    },
    safari: function () {
      return rnd(531, 538) + '.' + rnd(0, 2) + '.' + rnd(0,2);
    }
  };

  var browser = {
    firefox: function firefox(arch) {
      //https://developer.mozilla.org/en-US/docs/Gecko_user_agent_string_reference
      var firefox_ver = rnd(5, 15) + randomRevision(2),
        gecko_ver = 'Gecko/20100101 Firefox/' + firefox_ver,
        proc = randomProc(arch),
        os_ver = (arch === 'win') ? '(Windows NT ' + version_string.nt() + ((proc) ? '; ' + proc : '')
          : (arch === 'mac') ? '(Macintosh; ' + proc + ' Mac OS X ' + version_string.osx()
            : '(X11; Linux ' + proc;

      return 'Mozilla/5.0 ' + os_ver + '; rv:' + firefox_ver.slice(0, -2) + ') ' + gecko_ver;
    },

    iexplorer: function iexplorer() {
      var ver = version_string.ie();

      if (ver >= 11) {
        //http://msdn.microsoft.com/en-us/library/ie/hh869301(v=vs.85).aspx
        return 'Mozilla/5.0 (Windows NT 6.' + rnd(1,3) + '; Trident/7.0; ' + rnd(['Touch; ', '']) + 'rv:11.0) like Gecko';
      }

      //http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx
      return 'Mozilla/5.0 (compatible; MSIE ' + ver + '.0; Windows NT ' + version_string.nt() + '; Trident/' +
                version_string.trident() + ((rnd(0, 1) === 1) ? '; .NET CLR ' + version_string.net() : '') + ')';
    },

    opera: function opera(arch) {
      //http://www.opera.com/docs/history/
      var presto_ver = ' Presto/' + version_string.presto() + ' Version/' + version_string.presto2() + ')',
        os_ver = (arch === 'win') ? '(Windows NT ' + version_string.nt() + '; U; ' + randomLang() + presto_ver
          : (arch === 'lin') ? '(X11; Linux ' + randomProc(arch) + '; U; ' + randomLang() + presto_ver
            : '(Macintosh; Intel Mac OS X ' + version_string.osx() + ' U; ' + randomLang() + ' Presto/' +
                version_string.presto() + ' Version/' + version_string.presto2() + ')';

      return 'Opera/' + rnd(9, 14) + '.' + rnd(0, 99) + ' ' + os_ver;
    },

    safari: function safari(arch) {
      var safari = version_string.safari(),
        ver = rnd(4, 7) + '.' + rnd(0,1) + '.' + rnd(0,10),
        os_ver = (arch === 'mac') ? '(Macintosh; ' + randomProc('mac') + ' Mac OS X '+ version_string.osx('_') + ' rv:' + rnd(2, 6) + '.0; '+ randomLang() + ') '
          : '(Windows; U; Windows NT ' + version_string.nt() + ')';

      return 'Mozilla/5.0 ' + os_ver + 'AppleWebKit/' + safari + ' (KHTML, like Gecko) Version/' + ver + ' Safari/' + safari;
    },

    chrome: function chrome(arch) {
      var safari = version_string.safari(),
        os_ver = (arch === 'mac') ? '(Macintosh; ' + randomProc('mac') + ' Mac OS X ' + version_string.osx('_') + ') '
          : (arch === 'win') ? '(Windows; U; Windows NT ' + version_string.nt() + ')'
            : '(X11; Linux ' + randomProc(arch);

      return 'Mozilla/5.0 ' + os_ver + ' AppleWebKit/' + safari + ' (KHTML, like Gecko) Chrome/' + version_string.chrome() + ' Safari/' + safari;
    }
  };

  var random = randomBrowserAndOS();
  return browser[random[0]](random[1]);
};
'use strict';

const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        /* c8 ignore start */
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        /* c8 ignore stop */
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => {
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        /* c8 ignore start */
                        const w = width || 0;
                        /* c8 ignore stop */
                        ts += ' '.repeat(w - mixin.stringWidth(ts) - 1);
                    }
                }
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        /* c8 ignore start */
        const leadingWhitespace = match ? match[0].length : 0;
        /* c8 ignore stop */
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimEnd());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimEnd() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimStart();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        /* c8 ignore start */
        let wrapWidth = col.width || 0;
        /* c8 ignore stop */
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset widths should be calculated.
        /* c8 ignore start */
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        /* c8 ignore stop */
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    /* c8 ignore start */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
/* c8 ignore stop */
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* c8 ignore start */
    if (strWidth >= width) {
        return str;
    }
    /* c8 ignore stop */
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        /* c8 ignore start */
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
        /* c8 ignore stop */
    });
}

// Bootstrap cliui with CommonJS dependencies:
const stringWidth = require('string-width-cjs');
const stripAnsi = require('strip-ansi-cjs');
const wrap = require('wrap-ansi-cjs');
function ui(opts) {
    return cliui(opts, {
        stringWidth,
        stripAnsi,
        wrap
    });
}

module.exports = ui;
interface UIOptions {
    width: number;
    wrap?: boolean;
    rows?: string[];
}
interface Column {
    text: string;
    width?: number;
    align?: "right" | "left" | "center";
    padding: number[];
    border?: boolean;
}
interface ColumnArray extends Array<Column> {
    span: boolean;
}
interface Line {
    hidden?: boolean;
    text: string;
    span?: boolean;
}
declare class UI {
    width: number;
    wrap: boolean;
    rows: ColumnArray[];
    constructor(opts: UIOptions);
    span(...args: ColumnArray): void;
    resetOutput(): void;
    div(...args: (Column | string)[]): ColumnArray;
    private shouldApplyLayoutDSL;
    private applyLayoutDSL;
    private colFromString;
    private measurePadding;
    toString(): string;
    rowToString(row: ColumnArray, lines: Line[]): Line[];
    // if the full 'source' can render in
    // the target line, do so.
    private renderInline;
    private rasterize;
    private negatePadding;
    private columnWidths;
}
declare function ui(opts: UIOptions): UI;
export { ui as default };
'use strict';
const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
export class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        /* c8 ignore start */
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        /* c8 ignore stop */
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => {
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        /* c8 ignore start */
                        const w = width || 0;
                        /* c8 ignore stop */
                        ts += ' '.repeat(w - mixin.stringWidth(ts) - 1);
                    }
                }
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        /* c8 ignore start */
        const leadingWhitespace = match ? match[0].length : 0;
        /* c8 ignore stop */
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimEnd());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimEnd() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimStart();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        /* c8 ignore start */
        let wrapWidth = col.width || 0;
        /* c8 ignore stop */
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset widths should be calculated.
        /* c8 ignore start */
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        /* c8 ignore stop */
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    /* c8 ignore start */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
/* c8 ignore stop */
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* c8 ignore start */
    if (strWidth >= width) {
        return str;
    }
    /* c8 ignore stop */
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin;
export function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        /* c8 ignore start */
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
        /* c8 ignore stop */
    });
}
// Bootstrap cliui with ESM dependencies:
import { cliui } from './build/lib/index.js'

import stringWidth from 'string-width'
import stripAnsi from 'strip-ansi'
import wrap from 'wrap-ansi'

export default function ui (opts) {
  return cliui(opts, {
    stringWidth,
    stripAnsi,
    wrap
  })
}
Copyright (c) 2015, Contributors

Permission to use, copy, modify, and/or distribute this software
for any purpose with or without fee is hereby granted, provided
that the above copyright notice and this permission notice
appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE
LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
export type Options = {
	/**
	Match only the first ANSI escape.

	@default false
	*/
	readonly onlyFirst: boolean;
};

/**
Regular expression for matching ANSI escape codes.

@example
```
import ansiRegex from 'ansi-regex';

ansiRegex().test('\u001B[4mcake\u001B[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001B[4mcake\u001B[0m'.match(ansiRegex());
//=> ['\u001B[4m', '\u001B[0m']

'\u001B[4mcake\u001B[0m'.match(ansiRegex({onlyFirst: true}));
//=> ['\u001B[4m']

'\u001B]8;;https://github.com\u0007click\u001B]8;;\u0007'.match(ansiRegex());
//=> ['\u001B]8;;https://github.com\u0007', '\u001B]8;;\u0007']
```
*/
export default function ansiRegex(options?: Options): RegExp;
export default function ansiRegex({onlyFirst = false} = {}) {
	// Valid string terminator sequences are BEL, ESC\, and 0x9c
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const pattern = [
		`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
	"name": "ansi-regex",
	"version": "6.1.0",
	"description": "Regular expression for matching ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/ansi-regex",
	"funding": "https://github.com/chalk/ansi-regex?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"types": "./index.d.ts",
	"sideEffects": false,
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"view-supported": "node fixtures/view-codes.js"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"command-line",
		"text",
		"regex",
		"regexp",
		"re",
		"match",
		"test",
		"find",
		"pattern"
	],
	"devDependencies": {
		"ansi-escapes": "^5.0.0",
		"ava": "^3.15.0",
		"tsd": "^0.21.0",
		"xo": "^0.54.2"
	}
}
# ansi-regex

> Regular expression for matching [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code)

## Install

```sh
npm install ansi-regex
```

## Usage

```js
import ansiRegex from 'ansi-regex';

ansiRegex().test('\u001B[4mcake\u001B[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001B[4mcake\u001B[0m'.match(ansiRegex());
//=> ['\u001B[4m', '\u001B[0m']

'\u001B[4mcake\u001B[0m'.match(ansiRegex({onlyFirst: true}));
//=> ['\u001B[4m']

'\u001B]8;;https://github.com\u0007click\u001B]8;;\u0007'.match(ansiRegex());
//=> ['\u001B]8;;https://github.com\u0007', '\u001B]8;;\u0007']
```

## API

### ansiRegex(options?)

Returns a regex for matching ANSI escape codes.

#### options

Type: `object`

##### onlyFirst

Type: `boolean`\
Default: `false` *(Matches any ANSI escape codes in a string)*

Match only the first ANSI escape.

## FAQ

### Why do you test for codes not in the ECMA 48 standard?

Some of the codes we run as a test are codes that we acquired finding various lists of non-standard or manufacturer specific codes. We test for both standard and non-standard codes, as most of them follow the same or similar format and can be safely matched in strings without the risk of removing actual string content. There are a few non-standard control codes that do not follow the traditional format (i.e. they end in numbers) thus forcing us to exclude them from the test because we cannot reliably match them.

On the historical side, those ECMA standards were established in the early 90's whereas the VT100, for example, was designed in the mid/late 70's. At that point in time, control codes were still pretty ungoverned and engineers used them for a multitude of things, namely to activate hardware ports that may have been proprietary. Somewhere else you see a similar 'anarchy' of codes is in the x86 architecture for processors; there are a ton of "interrupts" that can mean different things on certain brands of processors, most of which have been phased out.

## Maintainers

- [Sindre Sorhus](https://github.com/sindresorhus)
- [Josh Junon](https://github.com/qix-)
export interface CSPair { // eslint-disable-line @typescript-eslint/naming-convention
	/**
	The ANSI terminal control sequence for starting this style.
	*/
	readonly open: string;

	/**
	The ANSI terminal control sequence for ending this style.
	*/
	readonly close: string;
}

export interface ColorBase {
	/**
	The ANSI terminal control sequence for ending this color.
	*/
	readonly close: string;

	ansi(code: number): string;

	ansi256(code: number): string;

	ansi16m(red: number, green: number, blue: number): string;
}

export interface Modifier {
	/**
	Resets the current color chain.
	*/
	readonly reset: CSPair;

	/**
	Make text bold.
	*/
	readonly bold: CSPair;

	/**
	Emitting only a small amount of light.
	*/
	readonly dim: CSPair;

	/**
	Make text italic. (Not widely supported)
	*/
	readonly italic: CSPair;

	/**
	Make text underline. (Not widely supported)
	*/
	readonly underline: CSPair;

	/**
	Make text overline.

	Supported on VTE-based terminals, the GNOME terminal, mintty, and Git Bash.
	*/
	readonly overline: CSPair;

	/**
	Inverse background and foreground colors.
	*/
	readonly inverse: CSPair;

	/**
	Prints the text, but makes it invisible.
	*/
	readonly hidden: CSPair;

	/**
	Puts a horizontal line through the center of the text. (Not widely supported)
	*/
	readonly strikethrough: CSPair;
}

export interface ForegroundColor {
	readonly black: CSPair;
	readonly red: CSPair;
	readonly green: CSPair;
	readonly yellow: CSPair;
	readonly blue: CSPair;
	readonly cyan: CSPair;
	readonly magenta: CSPair;
	readonly white: CSPair;

	/**
	Alias for `blackBright`.
	*/
	readonly gray: CSPair;

	/**
	Alias for `blackBright`.
	*/
	readonly grey: CSPair;

	readonly blackBright: CSPair;
	readonly redBright: CSPair;
	readonly greenBright: CSPair;
	readonly yellowBright: CSPair;
	readonly blueBright: CSPair;
	readonly cyanBright: CSPair;
	readonly magentaBright: CSPair;
	readonly whiteBright: CSPair;
}

export interface BackgroundColor {
	readonly bgBlack: CSPair;
	readonly bgRed: CSPair;
	readonly bgGreen: CSPair;
	readonly bgYellow: CSPair;
	readonly bgBlue: CSPair;
	readonly bgCyan: CSPair;
	readonly bgMagenta: CSPair;
	readonly bgWhite: CSPair;

	/**
	Alias for `bgBlackBright`.
	*/
	readonly bgGray: CSPair;

	/**
	Alias for `bgBlackBright`.
	*/
	readonly bgGrey: CSPair;

	readonly bgBlackBright: CSPair;
	readonly bgRedBright: CSPair;
	readonly bgGreenBright: CSPair;
	readonly bgYellowBright: CSPair;
	readonly bgBlueBright: CSPair;
	readonly bgCyanBright: CSPair;
	readonly bgMagentaBright: CSPair;
	readonly bgWhiteBright: CSPair;
}

export interface ConvertColor {
	/**
	Convert from the RGB color space to the ANSI 256 color space.

	@param red - (`0...255`)
	@param green - (`0...255`)
	@param blue - (`0...255`)
	*/
	rgbToAnsi256(red: number, green: number, blue: number): number;

	/**
	Convert from the RGB HEX color space to the RGB color space.

	@param hex - A hexadecimal string containing RGB data.
	*/
	hexToRgb(hex: string): [red: number, green: number, blue: number];

	/**
	Convert from the RGB HEX color space to the ANSI 256 color space.

	@param hex - A hexadecimal string containing RGB data.
	*/
	hexToAnsi256(hex: string): number;

	/**
	Convert from the ANSI 256 color space to the ANSI 16 color space.

	@param code - A number representing the ANSI 256 color.
	*/
	ansi256ToAnsi(code: number): number;

	/**
	Convert from the RGB color space to the ANSI 16 color space.

	@param red - (`0...255`)
	@param green - (`0...255`)
	@param blue - (`0...255`)
	*/
	rgbToAnsi(red: number, green: number, blue: number): number;

	/**
	Convert from the RGB HEX color space to the ANSI 16 color space.

	@param hex - A hexadecimal string containing RGB data.
	*/
	hexToAnsi(hex: string): number;
}

/**
Basic modifier names.
*/
export type ModifierName = keyof Modifier;

/**
Basic foreground color names.

[More colors here.](https://github.com/chalk/chalk/blob/main/readme.md#256-and-truecolor-color-support)
*/
export type ForegroundColorName = keyof ForegroundColor;

/**
Basic background color names.

[More colors here.](https://github.com/chalk/chalk/blob/main/readme.md#256-and-truecolor-color-support)
*/
export type BackgroundColorName = keyof BackgroundColor;

/**
Basic color names. The combination of foreground and background color names.

[More colors here.](https://github.com/chalk/chalk/blob/main/readme.md#256-and-truecolor-color-support)
*/
export type ColorName = ForegroundColorName | BackgroundColorName;

/**
Basic modifier names.
*/
export const modifierNames: readonly ModifierName[];

/**
Basic foreground color names.
*/
export const foregroundColorNames: readonly ForegroundColorName[];

/**
Basic background color names.
*/
export const backgroundColorNames: readonly BackgroundColorName[];

/*
Basic color names. The combination of foreground and background color names.
*/
export const colorNames: readonly ColorName[];

declare const ansiStyles: {
	readonly modifier: Modifier;
	readonly color: ColorBase & ForegroundColor;
	readonly bgColor: ColorBase & BackgroundColor;
	readonly codes: ReadonlyMap<number, number>;
} & ForegroundColor & BackgroundColor & Modifier & ConvertColor;

export default ansiStyles;
const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

export const modifierNames = Object.keys(styles.modifier);
export const foregroundColorNames = Object.keys(styles.color);
export const backgroundColorNames = Object.keys(styles.bgColor);
export const colorNames = [...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value: (red, green, blue) => {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value: hex => {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value: code => {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles;
}

const ansiStyles = assembleStyles();

export default ansiStyles;
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
	"name": "ansi-styles",
	"version": "6.2.1",
	"description": "ANSI escape codes for styling strings in the terminal",
	"license": "MIT",
	"repository": "chalk/ansi-styles",
	"funding": "https://github.com/chalk/ansi-styles?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd",
		"screenshot": "svg-term --command='node screenshot' --out=screenshot.svg --padding=3 --width=55 --height=3 --at=1000 --no-cursor"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"devDependencies": {
		"ava": "^3.15.0",
		"svg-term-cli": "^2.1.1",
		"tsd": "^0.19.0",
		"xo": "^0.47.0"
	}
}
# ansi-styles

> [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors_and_Styles) for styling strings in the terminal

You probably want the higher-level [chalk](https://github.com/chalk/chalk) module for styling your strings.

![](screenshot.png)

## Install

```sh
npm install ansi-styles
```

## Usage

```js
import styles from 'ansi-styles';

console.log(`${styles.green.open}Hello world!${styles.green.close}`);


// Color conversion between 256/truecolor
// NOTE: When converting from truecolor to 256 colors, the original color
//       may be degraded to fit the new color palette. This means terminals
//       that do not support 16 million colors will best-match the
//       original color.
console.log(`${styles.color.ansi(styles.rgbToAnsi(199, 20, 250))}Hello World${styles.color.close}`)
console.log(`${styles.color.ansi256(styles.rgbToAnsi256(199, 20, 250))}Hello World${styles.color.close}`)
console.log(`${styles.color.ansi16m(...styles.hexToRgb('#abcdef'))}Hello World${styles.color.close}`)
```

## API

### `open` and `close`

Each style has an `open` and `close` property.

### `modifierNames`, `foregroundColorNames`, `backgroundColorNames`, and `colorNames`

All supported style strings are exposed as an array of strings for convenience. `colorNames` is the combination of `foregroundColorNames` and `backgroundColorNames`.

This can be useful if you need to validate input:

```js
import {modifierNames, foregroundColorNames} from 'ansi-styles';

console.log(modifierNames.includes('bold'));
//=> true

console.log(foregroundColorNames.includes('pink'));
//=> false
```

## Styles

### Modifiers

- `reset`
- `bold`
- `dim`
- `italic` *(Not widely supported)*
- `underline`
- `overline` *Supported on VTE-based terminals, the GNOME terminal, mintty, and Git Bash.*
- `inverse`
- `hidden`
- `strikethrough` *(Not widely supported)*

### Colors

- `black`
- `red`
- `green`
- `yellow`
- `blue`
- `magenta`
- `cyan`
- `white`
- `blackBright` (alias: `gray`, `grey`)
- `redBright`
- `greenBright`
- `yellowBright`
- `blueBright`
- `magentaBright`
- `cyanBright`
- `whiteBright`

### Background colors

- `bgBlack`
- `bgRed`
- `bgGreen`
- `bgYellow`
- `bgBlue`
- `bgMagenta`
- `bgCyan`
- `bgWhite`
- `bgBlackBright` (alias: `bgGray`, `bgGrey`)
- `bgRedBright`
- `bgGreenBright`
- `bgYellowBright`
- `bgBlueBright`
- `bgMagentaBright`
- `bgCyanBright`
- `bgWhiteBright`

## Advanced usage

By default, you get a map of styles, but the styles are also available as groups. They are non-enumerable so they don't show up unless you access them explicitly. This makes it easier to expose only a subset in a higher-level module.

- `styles.modifier`
- `styles.color`
- `styles.bgColor`

###### Example

```js
import styles from 'ansi-styles';

console.log(styles.color.green.open);
```

Raw escape codes (i.e. without the CSI escape prefix `\u001B[` and render mode postfix `m`) are available under `styles.codes`, which returns a `Map` with the open codes as keys and close codes as values.

###### Example

```js
import styles from 'ansi-styles';

console.log(styles.codes.get(36));
//=> 39
```

## 16 / 256 / 16 million (TrueColor) support

`ansi-styles` allows converting between various color formats and ANSI escapes, with support for 16, 256 and [16 million colors](https://gist.github.com/XVilka/8346728).

The following color spaces are supported:

- `rgb`
- `hex`
- `ansi256`
- `ansi`

To use these, call the associated conversion function with the intended output, for example:

```js
import styles from 'ansi-styles';

styles.color.ansi(styles.rgbToAnsi(100, 200, 15)); // RGB to 16 color ansi foreground code
styles.bgColor.ansi(styles.hexToAnsi('#C0FFEE')); // HEX to 16 color ansi foreground code

styles.color.ansi256(styles.rgbToAnsi256(100, 200, 15)); // RGB to 256 color ansi foreground code
styles.bgColor.ansi256(styles.hexToAnsi256('#C0FFEE')); // HEX to 256 color ansi foreground code

styles.color.ansi16m(100, 200, 15); // RGB to 16 million color foreground code
styles.bgColor.ansi16m(...styles.hexToRgb('#C0FFEE')); // Hex (RGB) to 16 million color foreground code
```

## Related

- [ansi-escapes](https://github.com/sindresorhus/ansi-escapes) - ANSI escape codes for manipulating the terminal

## Maintainers

- [Sindre Sorhus](https://github.com/sindresorhus)
- [Josh Junon](https://github.com/qix-)

## For enterprise

Available as part of the Tidelift Subscription.

The maintainers of `ansi-styles` and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/npm-ansi-styles?utm_source=npm-ansi-styles&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)
declare module 'emoji-regex/es2015' {
  function emojiRegex(): RegExp;

  export = emojiRegex;
}
"use strict";

module.exports = () => {
  // https://mths.be/emoji
  return /\u{1F3F4}\u{E0067}\u{E0062}(?:\u{E0077}\u{E006C}\u{E0073}|\u{E0073}\u{E0063}\u{E0074}|\u{E0065}\u{E006E}\u{E0067})\u{E007F}|(?:\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}-\u{1F3FE}]|(?:\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}-\u{1F3FD}\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}\u{1F3FC}\u{1F3FE}\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}\u{1F3FD}-\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FC}-\u{1F3FF}]|\u{1F468}(?:\u{1F3FB}(?:\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FF}]|\u{1F468}[\u{1F3FB}-\u{1F3FF}])|\u{1F91D}\u200D\u{1F468}[\u{1F3FC}-\u{1F3FF}]|[\u2695\u2696\u2708]\uFE0F|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]))?|[\u{1F3FC}-\u{1F3FF}]\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FF}]|\u{1F468}[\u{1F3FB}-\u{1F3FF}])|\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F468}|[\u{1F468}\u{1F469}]\u200D(?:\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}])|\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FE}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FE}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FD}\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FD}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}\u{1F3FC}\u{1F3FE}\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FC}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}\u{1F3FD}-\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:[\u{1F468}\u{1F469}]\u200D[\u{1F466}\u{1F467}]|[\u{1F466}\u{1F467}])|\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC})?|(?:\u{1F469}(?:\u{1F3FB}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}])|[\u{1F3FC}-\u{1F3FF}]\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}]))|\u{1F9D1}[\u{1F3FB}-\u{1F3FF}]\u200D\u{1F91D}\u200D\u{1F9D1})[\u{1F3FB}-\u{1F3FF}]|\u{1F469}\u200D\u{1F469}\u200D(?:\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}])|\u{1F469}(?:\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}])|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FE}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FD}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FC}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FB}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F9D1}(?:\u200D(?:\u{1F91D}\u200D\u{1F9D1}|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FE}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FD}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FC}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FB}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F469}\u200D\u{1F466}\u200D\u{1F466}|\u{1F469}\u200D\u{1F469}\u200D[\u{1F466}\u{1F467}]|\u{1F469}\u200D\u{1F467}\u200D[\u{1F466}\u{1F467}]|(?:\u{1F441}\uFE0F\u200D\u{1F5E8}|\u{1F9D1}(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u{1F3FB}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\u{1F469}(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u{1F3FB}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\u{1F636}\u200D\u{1F32B}|\u{1F3F3}\uFE0F\u200D\u26A7|\u{1F43B}\u200D\u2744|(?:[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}][\u{1F3FB}-\u{1F3FF}]|[\u{1F46F}\u{1F93C}\u{1F9DE}\u{1F9DF}])\u200D[\u2640\u2642]|[\u26F9\u{1F3CB}\u{1F3CC}\u{1F575}][\uFE0F\u{1F3FB}-\u{1F3FF}]\u200D[\u2640\u2642]|\u{1F3F4}\u200D\u2620|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}]\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299\u{1F170}\u{1F171}\u{1F17E}\u{1F17F}\u{1F202}\u{1F237}\u{1F321}\u{1F324}-\u{1F32C}\u{1F336}\u{1F37D}\u{1F396}\u{1F397}\u{1F399}-\u{1F39B}\u{1F39E}\u{1F39F}\u{1F3CD}\u{1F3CE}\u{1F3D4}-\u{1F3DF}\u{1F3F5}\u{1F3F7}\u{1F43F}\u{1F4FD}\u{1F549}\u{1F54A}\u{1F56F}\u{1F570}\u{1F573}\u{1F576}-\u{1F579}\u{1F587}\u{1F58A}-\u{1F58D}\u{1F5A5}\u{1F5A8}\u{1F5B1}\u{1F5B2}\u{1F5BC}\u{1F5C2}-\u{1F5C4}\u{1F5D1}-\u{1F5D3}\u{1F5DC}-\u{1F5DE}\u{1F5E1}\u{1F5E3}\u{1F5E8}\u{1F5EF}\u{1F5F3}\u{1F5FA}\u{1F6CB}\u{1F6CD}-\u{1F6CF}\u{1F6E0}-\u{1F6E5}\u{1F6E9}\u{1F6F0}\u{1F6F3}])\uFE0F|\u{1F3F3}\uFE0F\u200D\u{1F308}|\u{1F469}\u200D\u{1F467}|\u{1F469}\u200D\u{1F466}|\u{1F635}\u200D\u{1F4AB}|\u{1F62E}\u200D\u{1F4A8}|\u{1F415}\u200D\u{1F9BA}|\u{1F9D1}(?:\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC}|\u{1F3FB})?|\u{1F469}(?:\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC}|\u{1F3FB})?|\u{1F1FD}\u{1F1F0}|\u{1F1F6}\u{1F1E6}|\u{1F1F4}\u{1F1F2}|\u{1F408}\u200D\u2B1B|\u2764\uFE0F\u200D[\u{1F525}\u{1FA79}]|\u{1F441}\uFE0F|\u{1F3F3}\uFE0F|\u{1F1FF}[\u{1F1E6}\u{1F1F2}\u{1F1FC}]|\u{1F1FE}[\u{1F1EA}\u{1F1F9}]|\u{1F1FC}[\u{1F1EB}\u{1F1F8}]|\u{1F1FB}[\u{1F1E6}\u{1F1E8}\u{1F1EA}\u{1F1EC}\u{1F1EE}\u{1F1F3}\u{1F1FA}]|\u{1F1FA}[\u{1F1E6}\u{1F1EC}\u{1F1F2}\u{1F1F3}\u{1F1F8}\u{1F1FE}\u{1F1FF}]|\u{1F1F9}[\u{1F1E6}\u{1F1E8}\u{1F1E9}\u{1F1EB}-\u{1F1ED}\u{1F1EF}-\u{1F1F4}\u{1F1F7}\u{1F1F9}\u{1F1FB}\u{1F1FC}\u{1F1FF}]|\u{1F1F8}[\u{1F1E6}-\u{1F1EA}\u{1F1EC}-\u{1F1F4}\u{1F1F7}-\u{1F1F9}\u{1F1FB}\u{1F1FD}-\u{1F1FF}]|\u{1F1F7}[\u{1F1EA}\u{1F1F4}\u{1F1F8}\u{1F1FA}\u{1F1FC}]|\u{1F1F5}[\u{1F1E6}\u{1F1EA}-\u{1F1ED}\u{1F1F0}-\u{1F1F3}\u{1F1F7}-\u{1F1F9}\u{1F1FC}\u{1F1FE}]|\u{1F1F3}[\u{1F1E6}\u{1F1E8}\u{1F1EA}-\u{1F1EC}\u{1F1EE}\u{1F1F1}\u{1F1F4}\u{1F1F5}\u{1F1F7}\u{1F1FA}\u{1F1FF}]|\u{1F1F2}[\u{1F1E6}\u{1F1E8}-\u{1F1ED}\u{1F1F0}-\u{1F1FF}]|\u{1F1F1}[\u{1F1E6}-\u{1F1E8}\u{1F1EE}\u{1F1F0}\u{1F1F7}-\u{1F1FB}\u{1F1FE}]|\u{1F1F0}[\u{1F1EA}\u{1F1EC}-\u{1F1EE}\u{1F1F2}\u{1F1F3}\u{1F1F5}\u{1F1F7}\u{1F1FC}\u{1F1FE}\u{1F1FF}]|\u{1F1EF}[\u{1F1EA}\u{1F1F2}\u{1F1F4}\u{1F1F5}]|\u{1F1EE}[\u{1F1E8}-\u{1F1EA}\u{1F1F1}-\u{1F1F4}\u{1F1F6}-\u{1F1F9}]|\u{1F1ED}[\u{1F1F0}\u{1F1F2}\u{1F1F3}\u{1F1F7}\u{1F1F9}\u{1F1FA}]|\u{1F1EC}[\u{1F1E6}\u{1F1E7}\u{1F1E9}-\u{1F1EE}\u{1F1F1}-\u{1F1F3}\u{1F1F5}-\u{1F1FA}\u{1F1FC}\u{1F1FE}]|\u{1F1EB}[\u{1F1EE}-\u{1F1F0}\u{1F1F2}\u{1F1F4}\u{1F1F7}]|\u{1F1EA}[\u{1F1E6}\u{1F1E8}\u{1F1EA}\u{1F1EC}\u{1F1ED}\u{1F1F7}-\u{1F1FA}]|\u{1F1E9}[\u{1F1EA}\u{1F1EC}\u{1F1EF}\u{1F1F0}\u{1F1F2}\u{1F1F4}\u{1F1FF}]|\u{1F1E8}[\u{1F1E6}\u{1F1E8}\u{1F1E9}\u{1F1EB}-\u{1F1EE}\u{1F1F0}-\u{1F1F5}\u{1F1F7}\u{1F1FA}-\u{1F1FF}]|\u{1F1E7}[\u{1F1E6}\u{1F1E7}\u{1F1E9}-\u{1F1EF}\u{1F1F1}-\u{1F1F4}\u{1F1F6}-\u{1F1F9}\u{1F1FB}\u{1F1FC}\u{1F1FE}\u{1F1FF}]|\u{1F1E6}[\u{1F1E8}-\u{1F1EC}\u{1F1EE}\u{1F1F1}\u{1F1F2}\u{1F1F4}\u{1F1F6}-\u{1F1FA}\u{1F1FC}\u{1F1FD}\u{1F1FF}]|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}][\u{1F3FB}-\u{1F3FF}]|[\u26F9\u{1F3CB}\u{1F3CC}\u{1F575}][\uFE0F\u{1F3FB}-\u{1F3FF}]|\u{1F3F4}|[\u270A\u270B\u{1F385}\u{1F3C2}\u{1F3C7}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}\u{1F467}\u{1F46B}-\u{1F46D}\u{1F472}\u{1F474}-\u{1F476}\u{1F478}\u{1F47C}\u{1F483}\u{1F485}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F57A}\u{1F595}\u{1F596}\u{1F64C}\u{1F64F}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91C}\u{1F91E}\u{1F91F}\u{1F930}-\u{1F934}\u{1F936}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9BB}\u{1F9D2}\u{1F9D3}\u{1F9D5}][\u{1F3FB}-\u{1F3FF}]|[\u261D\u270C\u270D\u{1F574}\u{1F590}][\uFE0F\u{1F3FB}-\u{1F3FF}]|[\u270A\u270B\u{1F385}\u{1F3C2}\u{1F3C7}\u{1F408}\u{1F415}\u{1F43B}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}\u{1F467}\u{1F46B}-\u{1F46D}\u{1F472}\u{1F474}-\u{1F476}\u{1F478}\u{1F47C}\u{1F483}\u{1F485}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F57A}\u{1F595}\u{1F596}\u{1F62E}\u{1F635}\u{1F636}\u{1F64C}\u{1F64F}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91C}\u{1F91E}\u{1F91F}\u{1F930}-\u{1F934}\u{1F936}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9BB}\u{1F9D2}\u{1F9D3}\u{1F9D5}]|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}]|[\u{1F46F}\u{1F93C}\u{1F9DE}\u{1F9DF}]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55\u{1F004}\u{1F0CF}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F201}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F236}\u{1F238}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F320}\u{1F32D}-\u{1F335}\u{1F337}-\u{1F37C}\u{1F37E}-\u{1F384}\u{1F386}-\u{1F393}\u{1F3A0}-\u{1F3C1}\u{1F3C5}\u{1F3C6}\u{1F3C8}\u{1F3C9}\u{1F3CF}-\u{1F3D3}\u{1F3E0}-\u{1F3F0}\u{1F3F8}-\u{1F407}\u{1F409}-\u{1F414}\u{1F416}-\u{1F43A}\u{1F43C}-\u{1F43E}\u{1F440}\u{1F444}\u{1F445}\u{1F451}-\u{1F465}\u{1F46A}\u{1F479}-\u{1F47B}\u{1F47D}-\u{1F480}\u{1F484}\u{1F488}-\u{1F48E}\u{1F490}\u{1F492}-\u{1F4A9}\u{1F4AB}-\u{1F4FC}\u{1F4FF}-\u{1F53D}\u{1F54B}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F5A4}\u{1F5FB}-\u{1F62D}\u{1F62F}-\u{1F634}\u{1F637}-\u{1F644}\u{1F648}-\u{1F64A}\u{1F680}-\u{1F6A2}\u{1F6A4}-\u{1F6B3}\u{1F6B7}-\u{1F6BF}\u{1F6C1}-\u{1F6C5}\u{1F6D0}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6EB}\u{1F6EC}\u{1F6F4}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F90D}\u{1F90E}\u{1F910}-\u{1F917}\u{1F91D}\u{1F920}-\u{1F925}\u{1F927}-\u{1F92F}\u{1F93A}\u{1F93F}-\u{1F945}\u{1F947}-\u{1F976}\u{1F978}\u{1F97A}-\u{1F9B4}\u{1F9B7}\u{1F9BA}\u{1F9BC}-\u{1F9CB}\u{1F9D0}\u{1F9E0}-\u{1F9FF}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7A}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAA8}\u{1FAB0}-\u{1FAB6}\u{1FAC0}-\u{1FAC2}\u{1FAD0}-\u{1FAD6}]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55\u{1F004}\u{1F0CF}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F1E6}-\u{1F1FF}\u{1F201}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F236}\u{1F238}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F320}\u{1F32D}-\u{1F335}\u{1F337}-\u{1F37C}\u{1F37E}-\u{1F393}\u{1F3A0}-\u{1F3CA}\u{1F3CF}-\u{1F3D3}\u{1F3E0}-\u{1F3F0}\u{1F3F4}\u{1F3F8}-\u{1F43E}\u{1F440}\u{1F442}-\u{1F4FC}\u{1F4FF}-\u{1F53D}\u{1F54B}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F57A}\u{1F595}\u{1F596}\u{1F5A4}\u{1F5FB}-\u{1F64F}\u{1F680}-\u{1F6C5}\u{1F6CC}\u{1F6D0}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6EB}\u{1F6EC}\u{1F6F4}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F90C}-\u{1F93A}\u{1F93C}-\u{1F945}\u{1F947}-\u{1F978}\u{1F97A}-\u{1F9CB}\u{1F9CD}-\u{1F9FF}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7A}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAA8}\u{1FAB0}-\u{1FAB6}\u{1FAC0}-\u{1FAC2}\u{1FAD0}-\u{1FAD6}]|[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299\u{1F004}\u{1F0CF}\u{1F170}\u{1F171}\u{1F17E}\u{1F17F}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F1E6}-\u{1F1FF}\u{1F201}\u{1F202}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F321}\u{1F324}-\u{1F393}\u{1F396}\u{1F397}\u{1F399}-\u{1F39B}\u{1F39E}-\u{1F3F0}\u{1F3F3}-\u{1F3F5}\u{1F3F7}-\u{1F4FD}\u{1F4FF}-\u{1F53D}\u{1F549}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F56F}\u{1F570}\u{1F573}-\u{1F57A}\u{1F587}\u{1F58A}-\u{1F58D}\u{1F590}\u{1F595}\u{1F596}\u{1F5A4}\u{1F5A5}\u{1F5A8}\u{1F5B1}\u{1F5B2}\u{1F5BC}\u{1F5C2}-\u{1F5C4}\u{1F5D1}-\u{1F5D3}\u{1F5DC}-\u{1F5DE}\u{1F5E1}\u{1F5E3}\u{1F5E8}\u{1F5EF}\u{1F5F3}\u{1F5FA}-\u{1F64F}\u{1F680}-\u{1F6C5}\u{1F6CB}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6E0}-\u{1F6E5}\u{1F6E9}\u{1F6EB}\u{1F6EC}\u{1F6F0}\u{1F6F3}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F90C}-\u{1F93A}\u{1F93C}-\u{1F945}\u{1F947}-\u{1F978}\u{1F97A}-\u{1F9CB}\u{1F9CD}-\u{1F9FF}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7A}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAA8}\u{1FAB0}-\u{1FAB6}\u{1FAC0}-\u{1FAC2}\u{1FAD0}-\u{1FAD6}]\uFE0F|[\u261D\u26F9\u270A-\u270D\u{1F385}\u{1F3C2}-\u{1F3C4}\u{1F3C7}\u{1F3CA}-\u{1F3CC}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}-\u{1F478}\u{1F47C}\u{1F481}-\u{1F483}\u{1F485}-\u{1F487}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F574}\u{1F575}\u{1F57A}\u{1F590}\u{1F595}\u{1F596}\u{1F645}-\u{1F647}\u{1F64B}-\u{1F64F}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91F}\u{1F926}\u{1F930}-\u{1F939}\u{1F93C}-\u{1F93E}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9B8}\u{1F9B9}\u{1F9BB}\u{1F9CD}-\u{1F9CF}\u{1F9D1}-\u{1F9DD}]/gu;
};
declare module 'emoji-regex/es2015/RGI_Emoji' {
  function emojiRegex(): RegExp;

  export = emojiRegex;
}
"use strict";

module.exports = () => {
  // https://mths.be/emoji
  return /\u{1F3F4}\u{E0067}\u{E0062}(?:\u{E0077}\u{E006C}\u{E0073}|\u{E0073}\u{E0063}\u{E0074}|\u{E0065}\u{E006E}\u{E0067})\u{E007F}|(?:\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}-\u{1F3FE}]|(?:\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}-\u{1F3FD}\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}\u{1F3FC}\u{1F3FE}\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}\u{1F3FD}-\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FC}-\u{1F3FF}]|\u{1F468}(?:\u{1F3FB}(?:\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FF}]|\u{1F468}[\u{1F3FB}-\u{1F3FF}])|\u{1F91D}\u200D\u{1F468}[\u{1F3FC}-\u{1F3FF}]|[\u2695\u2696\u2708]\uFE0F|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]))?|[\u{1F3FC}-\u{1F3FF}]\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FF}]|\u{1F468}[\u{1F3FB}-\u{1F3FF}])|\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F468}|[\u{1F468}\u{1F469}]\u200D(?:\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}])|\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FE}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FE}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FD}\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FD}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}\u{1F3FC}\u{1F3FE}\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FC}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}\u{1F3FD}-\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:[\u{1F468}\u{1F469}]\u200D[\u{1F466}\u{1F467}]|[\u{1F466}\u{1F467}])|\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC})?|(?:\u{1F469}(?:\u{1F3FB}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}])|[\u{1F3FC}-\u{1F3FF}]\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}]))|\u{1F9D1}[\u{1F3FB}-\u{1F3FF}]\u200D\u{1F91D}\u200D\u{1F9D1})[\u{1F3FB}-\u{1F3FF}]|\u{1F469}\u200D\u{1F469}\u200D(?:\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}])|\u{1F469}(?:\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}])|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FE}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FD}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FC}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FB}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F9D1}(?:\u200D(?:\u{1F91D}\u200D\u{1F9D1}|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FE}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FD}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FC}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FB}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F469}\u200D\u{1F466}\u200D\u{1F466}|\u{1F469}\u200D\u{1F469}\u200D[\u{1F466}\u{1F467}]|\u{1F469}\u200D\u{1F467}\u200D[\u{1F466}\u{1F467}]|(?:\u{1F441}\uFE0F\u200D\u{1F5E8}|\u{1F9D1}(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u{1F3FB}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\u{1F469}(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u{1F3FB}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\u{1F636}\u200D\u{1F32B}|\u{1F3F3}\uFE0F\u200D\u26A7|\u{1F43B}\u200D\u2744|(?:[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}][\u{1F3FB}-\u{1F3FF}]|[\u{1F46F}\u{1F93C}\u{1F9DE}\u{1F9DF}])\u200D[\u2640\u2642]|[\u26F9\u{1F3CB}\u{1F3CC}\u{1F575}][\uFE0F\u{1F3FB}-\u{1F3FF}]\u200D[\u2640\u2642]|\u{1F3F4}\u200D\u2620|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}]\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299\u{1F170}\u{1F171}\u{1F17E}\u{1F17F}\u{1F202}\u{1F237}\u{1F321}\u{1F324}-\u{1F32C}\u{1F336}\u{1F37D}\u{1F396}\u{1F397}\u{1F399}-\u{1F39B}\u{1F39E}\u{1F39F}\u{1F3CD}\u{1F3CE}\u{1F3D4}-\u{1F3DF}\u{1F3F5}\u{1F3F7}\u{1F43F}\u{1F4FD}\u{1F549}\u{1F54A}\u{1F56F}\u{1F570}\u{1F573}\u{1F576}-\u{1F579}\u{1F587}\u{1F58A}-\u{1F58D}\u{1F5A5}\u{1F5A8}\u{1F5B1}\u{1F5B2}\u{1F5BC}\u{1F5C2}-\u{1F5C4}\u{1F5D1}-\u{1F5D3}\u{1F5DC}-\u{1F5DE}\u{1F5E1}\u{1F5E3}\u{1F5E8}\u{1F5EF}\u{1F5F3}\u{1F5FA}\u{1F6CB}\u{1F6CD}-\u{1F6CF}\u{1F6E0}-\u{1F6E5}\u{1F6E9}\u{1F6F0}\u{1F6F3}])\uFE0F|\u{1F3F3}\uFE0F\u200D\u{1F308}|\u{1F469}\u200D\u{1F467}|\u{1F469}\u200D\u{1F466}|\u{1F635}\u200D\u{1F4AB}|\u{1F62E}\u200D\u{1F4A8}|\u{1F415}\u200D\u{1F9BA}|\u{1F9D1}(?:\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC}|\u{1F3FB})?|\u{1F469}(?:\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC}|\u{1F3FB})?|\u{1F1FD}\u{1F1F0}|\u{1F1F6}\u{1F1E6}|\u{1F1F4}\u{1F1F2}|\u{1F408}\u200D\u2B1B|\u2764\uFE0F\u200D[\u{1F525}\u{1FA79}]|\u{1F441}\uFE0F|\u{1F3F3}\uFE0F|\u{1F1FF}[\u{1F1E6}\u{1F1F2}\u{1F1FC}]|\u{1F1FE}[\u{1F1EA}\u{1F1F9}]|\u{1F1FC}[\u{1F1EB}\u{1F1F8}]|\u{1F1FB}[\u{1F1E6}\u{1F1E8}\u{1F1EA}\u{1F1EC}\u{1F1EE}\u{1F1F3}\u{1F1FA}]|\u{1F1FA}[\u{1F1E6}\u{1F1EC}\u{1F1F2}\u{1F1F3}\u{1F1F8}\u{1F1FE}\u{1F1FF}]|\u{1F1F9}[\u{1F1E6}\u{1F1E8}\u{1F1E9}\u{1F1EB}-\u{1F1ED}\u{1F1EF}-\u{1F1F4}\u{1F1F7}\u{1F1F9}\u{1F1FB}\u{1F1FC}\u{1F1FF}]|\u{1F1F8}[\u{1F1E6}-\u{1F1EA}\u{1F1EC}-\u{1F1F4}\u{1F1F7}-\u{1F1F9}\u{1F1FB}\u{1F1FD}-\u{1F1FF}]|\u{1F1F7}[\u{1F1EA}\u{1F1F4}\u{1F1F8}\u{1F1FA}\u{1F1FC}]|\u{1F1F5}[\u{1F1E6}\u{1F1EA}-\u{1F1ED}\u{1F1F0}-\u{1F1F3}\u{1F1F7}-\u{1F1F9}\u{1F1FC}\u{1F1FE}]|\u{1F1F3}[\u{1F1E6}\u{1F1E8}\u{1F1EA}-\u{1F1EC}\u{1F1EE}\u{1F1F1}\u{1F1F4}\u{1F1F5}\u{1F1F7}\u{1F1FA}\u{1F1FF}]|\u{1F1F2}[\u{1F1E6}\u{1F1E8}-\u{1F1ED}\u{1F1F0}-\u{1F1FF}]|\u{1F1F1}[\u{1F1E6}-\u{1F1E8}\u{1F1EE}\u{1F1F0}\u{1F1F7}-\u{1F1FB}\u{1F1FE}]|\u{1F1F0}[\u{1F1EA}\u{1F1EC}-\u{1F1EE}\u{1F1F2}\u{1F1F3}\u{1F1F5}\u{1F1F7}\u{1F1FC}\u{1F1FE}\u{1F1FF}]|\u{1F1EF}[\u{1F1EA}\u{1F1F2}\u{1F1F4}\u{1F1F5}]|\u{1F1EE}[\u{1F1E8}-\u{1F1EA}\u{1F1F1}-\u{1F1F4}\u{1F1F6}-\u{1F1F9}]|\u{1F1ED}[\u{1F1F0}\u{1F1F2}\u{1F1F3}\u{1F1F7}\u{1F1F9}\u{1F1FA}]|\u{1F1EC}[\u{1F1E6}\u{1F1E7}\u{1F1E9}-\u{1F1EE}\u{1F1F1}-\u{1F1F3}\u{1F1F5}-\u{1F1FA}\u{1F1FC}\u{1F1FE}]|\u{1F1EB}[\u{1F1EE}-\u{1F1F0}\u{1F1F2}\u{1F1F4}\u{1F1F7}]|\u{1F1EA}[\u{1F1E6}\u{1F1E8}\u{1F1EA}\u{1F1EC}\u{1F1ED}\u{1F1F7}-\u{1F1FA}]|\u{1F1E9}[\u{1F1EA}\u{1F1EC}\u{1F1EF}\u{1F1F0}\u{1F1F2}\u{1F1F4}\u{1F1FF}]|\u{1F1E8}[\u{1F1E6}\u{1F1E8}\u{1F1E9}\u{1F1EB}-\u{1F1EE}\u{1F1F0}-\u{1F1F5}\u{1F1F7}\u{1F1FA}-\u{1F1FF}]|\u{1F1E7}[\u{1F1E6}\u{1F1E7}\u{1F1E9}-\u{1F1EF}\u{1F1F1}-\u{1F1F4}\u{1F1F6}-\u{1F1F9}\u{1F1FB}\u{1F1FC}\u{1F1FE}\u{1F1FF}]|\u{1F1E6}[\u{1F1E8}-\u{1F1EC}\u{1F1EE}\u{1F1F1}\u{1F1F2}\u{1F1F4}\u{1F1F6}-\u{1F1FA}\u{1F1FC}\u{1F1FD}\u{1F1FF}]|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}][\u{1F3FB}-\u{1F3FF}]|[\u26F9\u{1F3CB}\u{1F3CC}\u{1F575}][\uFE0F\u{1F3FB}-\u{1F3FF}]|\u{1F3F4}|[\u270A\u270B\u{1F385}\u{1F3C2}\u{1F3C7}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}\u{1F467}\u{1F46B}-\u{1F46D}\u{1F472}\u{1F474}-\u{1F476}\u{1F478}\u{1F47C}\u{1F483}\u{1F485}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F57A}\u{1F595}\u{1F596}\u{1F64C}\u{1F64F}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91C}\u{1F91E}\u{1F91F}\u{1F930}-\u{1F934}\u{1F936}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9BB}\u{1F9D2}\u{1F9D3}\u{1F9D5}][\u{1F3FB}-\u{1F3FF}]|[\u261D\u270C\u270D\u{1F574}\u{1F590}][\uFE0F\u{1F3FB}-\u{1F3FF}]|[\u270A\u270B\u{1F385}\u{1F3C2}\u{1F3C7}\u{1F408}\u{1F415}\u{1F43B}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}\u{1F467}\u{1F46B}-\u{1F46D}\u{1F472}\u{1F474}-\u{1F476}\u{1F478}\u{1F47C}\u{1F483}\u{1F485}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F57A}\u{1F595}\u{1F596}\u{1F62E}\u{1F635}\u{1F636}\u{1F64C}\u{1F64F}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91C}\u{1F91E}\u{1F91F}\u{1F930}-\u{1F934}\u{1F936}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9BB}\u{1F9D2}\u{1F9D3}\u{1F9D5}]|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}]|[\u{1F46F}\u{1F93C}\u{1F9DE}\u{1F9DF}]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55\u{1F004}\u{1F0CF}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F201}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F236}\u{1F238}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F320}\u{1F32D}-\u{1F335}\u{1F337}-\u{1F37C}\u{1F37E}-\u{1F384}\u{1F386}-\u{1F393}\u{1F3A0}-\u{1F3C1}\u{1F3C5}\u{1F3C6}\u{1F3C8}\u{1F3C9}\u{1F3CF}-\u{1F3D3}\u{1F3E0}-\u{1F3F0}\u{1F3F8}-\u{1F407}\u{1F409}-\u{1F414}\u{1F416}-\u{1F43A}\u{1F43C}-\u{1F43E}\u{1F440}\u{1F444}\u{1F445}\u{1F451}-\u{1F465}\u{1F46A}\u{1F479}-\u{1F47B}\u{1F47D}-\u{1F480}\u{1F484}\u{1F488}-\u{1F48E}\u{1F490}\u{1F492}-\u{1F4A9}\u{1F4AB}-\u{1F4FC}\u{1F4FF}-\u{1F53D}\u{1F54B}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F5A4}\u{1F5FB}-\u{1F62D}\u{1F62F}-\u{1F634}\u{1F637}-\u{1F644}\u{1F648}-\u{1F64A}\u{1F680}-\u{1F6A2}\u{1F6A4}-\u{1F6B3}\u{1F6B7}-\u{1F6BF}\u{1F6C1}-\u{1F6C5}\u{1F6D0}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6EB}\u{1F6EC}\u{1F6F4}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F90D}\u{1F90E}\u{1F910}-\u{1F917}\u{1F91D}\u{1F920}-\u{1F925}\u{1F927}-\u{1F92F}\u{1F93A}\u{1F93F}-\u{1F945}\u{1F947}-\u{1F976}\u{1F978}\u{1F97A}-\u{1F9B4}\u{1F9B7}\u{1F9BA}\u{1F9BC}-\u{1F9CB}\u{1F9D0}\u{1F9E0}-\u{1F9FF}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7A}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAA8}\u{1FAB0}-\u{1FAB6}\u{1FAC0}-\u{1FAC2}\u{1FAD0}-\u{1FAD6}]/gu;
};
declare module 'emoji-regex/es2015/text' {
  function emojiRegex(): RegExp;

  export = emojiRegex;
}
"use strict";

module.exports = () => {
  // https://mths.be/emoji
  return /\u{1F3F4}\u{E0067}\u{E0062}(?:\u{E0077}\u{E006C}\u{E0073}|\u{E0073}\u{E0063}\u{E0074}|\u{E0065}\u{E006E}\u{E0067})\u{E007F}|(?:\u{1F9D1}\u{1F3FF}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}-\u{1F3FE}]|(?:\u{1F9D1}\u{1F3FE}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}-\u{1F3FD}\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FD}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}\u{1F3FC}\u{1F3FE}\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FC}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FB}\u{1F3FD}-\u{1F3FF}]|(?:\u{1F9D1}\u{1F3FB}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F9D1}|\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D[\u{1F468}\u{1F469}])[\u{1F3FC}-\u{1F3FF}]|\u{1F468}(?:\u{1F3FB}(?:\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FF}]|\u{1F468}[\u{1F3FB}-\u{1F3FF}])|\u{1F91D}\u200D\u{1F468}[\u{1F3FC}-\u{1F3FF}]|[\u2695\u2696\u2708]\uFE0F|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]))?|[\u{1F3FC}-\u{1F3FF}]\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FF}]|\u{1F468}[\u{1F3FB}-\u{1F3FF}])|\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D)?\u{1F468}|[\u{1F468}\u{1F469}]\u200D(?:\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}])|\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FE}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FE}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}-\u{1F3FD}\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FD}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}\u{1F3FC}\u{1F3FE}\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FC}\u200D(?:\u{1F91D}\u200D\u{1F468}[\u{1F3FB}\u{1F3FD}-\u{1F3FF}]|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:[\u{1F468}\u{1F469}]\u200D[\u{1F466}\u{1F467}]|[\u{1F466}\u{1F467}])|\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC})?|(?:\u{1F469}(?:\u{1F3FB}\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}])|[\u{1F3FC}-\u{1F3FF}]\u200D\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}]))|\u{1F9D1}[\u{1F3FB}-\u{1F3FF}]\u200D\u{1F91D}\u200D\u{1F9D1})[\u{1F3FB}-\u{1F3FF}]|\u{1F469}\u200D\u{1F469}\u200D(?:\u{1F466}\u200D\u{1F466}|\u{1F467}\u200D[\u{1F466}\u{1F467}])|\u{1F469}(?:\u200D(?:\u2764\uFE0F\u200D(?:\u{1F48B}\u200D[\u{1F468}\u{1F469}]|[\u{1F468}\u{1F469}])|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FE}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FD}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FC}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FB}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F9D1}(?:\u200D(?:\u{1F91D}\u200D\u{1F9D1}|[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F3FF}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FE}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FD}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FC}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}]|\u{1F3FB}\u200D[\u{1F33E}\u{1F373}\u{1F37C}\u{1F384}\u{1F393}\u{1F3A4}\u{1F3A8}\u{1F3EB}\u{1F3ED}\u{1F4BB}\u{1F4BC}\u{1F527}\u{1F52C}\u{1F680}\u{1F692}\u{1F9AF}-\u{1F9B3}\u{1F9BC}\u{1F9BD}])|\u{1F469}\u200D\u{1F466}\u200D\u{1F466}|\u{1F469}\u200D\u{1F469}\u200D[\u{1F466}\u{1F467}]|\u{1F469}\u200D\u{1F467}\u200D[\u{1F466}\u{1F467}]|(?:\u{1F441}\uFE0F\u200D\u{1F5E8}|\u{1F9D1}(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u{1F3FB}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\u{1F469}(?:\u{1F3FF}\u200D[\u2695\u2696\u2708]|\u{1F3FE}\u200D[\u2695\u2696\u2708]|\u{1F3FD}\u200D[\u2695\u2696\u2708]|\u{1F3FC}\u200D[\u2695\u2696\u2708]|\u{1F3FB}\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\u{1F636}\u200D\u{1F32B}|\u{1F3F3}\uFE0F\u200D\u26A7|\u{1F43B}\u200D\u2744|(?:[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}][\u{1F3FB}-\u{1F3FF}]|[\u{1F46F}\u{1F93C}\u{1F9DE}\u{1F9DF}])\u200D[\u2640\u2642]|[\u26F9\u{1F3CB}\u{1F3CC}\u{1F575}][\uFE0F\u{1F3FB}-\u{1F3FF}]\u200D[\u2640\u2642]|\u{1F3F4}\u200D\u2620|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}]\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299\u{1F170}\u{1F171}\u{1F17E}\u{1F17F}\u{1F202}\u{1F237}\u{1F321}\u{1F324}-\u{1F32C}\u{1F336}\u{1F37D}\u{1F396}\u{1F397}\u{1F399}-\u{1F39B}\u{1F39E}\u{1F39F}\u{1F3CD}\u{1F3CE}\u{1F3D4}-\u{1F3DF}\u{1F3F5}\u{1F3F7}\u{1F43F}\u{1F4FD}\u{1F549}\u{1F54A}\u{1F56F}\u{1F570}\u{1F573}\u{1F576}-\u{1F579}\u{1F587}\u{1F58A}-\u{1F58D}\u{1F5A5}\u{1F5A8}\u{1F5B1}\u{1F5B2}\u{1F5BC}\u{1F5C2}-\u{1F5C4}\u{1F5D1}-\u{1F5D3}\u{1F5DC}-\u{1F5DE}\u{1F5E1}\u{1F5E3}\u{1F5E8}\u{1F5EF}\u{1F5F3}\u{1F5FA}\u{1F6CB}\u{1F6CD}-\u{1F6CF}\u{1F6E0}-\u{1F6E5}\u{1F6E9}\u{1F6F0}\u{1F6F3}])\uFE0F|\u{1F3F3}\uFE0F\u200D\u{1F308}|\u{1F469}\u200D\u{1F467}|\u{1F469}\u200D\u{1F466}|\u{1F635}\u200D\u{1F4AB}|\u{1F62E}\u200D\u{1F4A8}|\u{1F415}\u200D\u{1F9BA}|\u{1F9D1}(?:\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC}|\u{1F3FB})?|\u{1F469}(?:\u{1F3FF}|\u{1F3FE}|\u{1F3FD}|\u{1F3FC}|\u{1F3FB})?|\u{1F1FD}\u{1F1F0}|\u{1F1F6}\u{1F1E6}|\u{1F1F4}\u{1F1F2}|\u{1F408}\u200D\u2B1B|\u2764\uFE0F\u200D[\u{1F525}\u{1FA79}]|\u{1F441}\uFE0F|\u{1F3F3}\uFE0F|\u{1F1FF}[\u{1F1E6}\u{1F1F2}\u{1F1FC}]|\u{1F1FE}[\u{1F1EA}\u{1F1F9}]|\u{1F1FC}[\u{1F1EB}\u{1F1F8}]|\u{1F1FB}[\u{1F1E6}\u{1F1E8}\u{1F1EA}\u{1F1EC}\u{1F1EE}\u{1F1F3}\u{1F1FA}]|\u{1F1FA}[\u{1F1E6}\u{1F1EC}\u{1F1F2}\u{1F1F3}\u{1F1F8}\u{1F1FE}\u{1F1FF}]|\u{1F1F9}[\u{1F1E6}\u{1F1E8}\u{1F1E9}\u{1F1EB}-\u{1F1ED}\u{1F1EF}-\u{1F1F4}\u{1F1F7}\u{1F1F9}\u{1F1FB}\u{1F1FC}\u{1F1FF}]|\u{1F1F8}[\u{1F1E6}-\u{1F1EA}\u{1F1EC}-\u{1F1F4}\u{1F1F7}-\u{1F1F9}\u{1F1FB}\u{1F1FD}-\u{1F1FF}]|\u{1F1F7}[\u{1F1EA}\u{1F1F4}\u{1F1F8}\u{1F1FA}\u{1F1FC}]|\u{1F1F5}[\u{1F1E6}\u{1F1EA}-\u{1F1ED}\u{1F1F0}-\u{1F1F3}\u{1F1F7}-\u{1F1F9}\u{1F1FC}\u{1F1FE}]|\u{1F1F3}[\u{1F1E6}\u{1F1E8}\u{1F1EA}-\u{1F1EC}\u{1F1EE}\u{1F1F1}\u{1F1F4}\u{1F1F5}\u{1F1F7}\u{1F1FA}\u{1F1FF}]|\u{1F1F2}[\u{1F1E6}\u{1F1E8}-\u{1F1ED}\u{1F1F0}-\u{1F1FF}]|\u{1F1F1}[\u{1F1E6}-\u{1F1E8}\u{1F1EE}\u{1F1F0}\u{1F1F7}-\u{1F1FB}\u{1F1FE}]|\u{1F1F0}[\u{1F1EA}\u{1F1EC}-\u{1F1EE}\u{1F1F2}\u{1F1F3}\u{1F1F5}\u{1F1F7}\u{1F1FC}\u{1F1FE}\u{1F1FF}]|\u{1F1EF}[\u{1F1EA}\u{1F1F2}\u{1F1F4}\u{1F1F5}]|\u{1F1EE}[\u{1F1E8}-\u{1F1EA}\u{1F1F1}-\u{1F1F4}\u{1F1F6}-\u{1F1F9}]|\u{1F1ED}[\u{1F1F0}\u{1F1F2}\u{1F1F3}\u{1F1F7}\u{1F1F9}\u{1F1FA}]|\u{1F1EC}[\u{1F1E6}\u{1F1E7}\u{1F1E9}-\u{1F1EE}\u{1F1F1}-\u{1F1F3}\u{1F1F5}-\u{1F1FA}\u{1F1FC}\u{1F1FE}]|\u{1F1EB}[\u{1F1EE}-\u{1F1F0}\u{1F1F2}\u{1F1F4}\u{1F1F7}]|\u{1F1EA}[\u{1F1E6}\u{1F1E8}\u{1F1EA}\u{1F1EC}\u{1F1ED}\u{1F1F7}-\u{1F1FA}]|\u{1F1E9}[\u{1F1EA}\u{1F1EC}\u{1F1EF}\u{1F1F0}\u{1F1F2}\u{1F1F4}\u{1F1FF}]|\u{1F1E8}[\u{1F1E6}\u{1F1E8}\u{1F1E9}\u{1F1EB}-\u{1F1EE}\u{1F1F0}-\u{1F1F5}\u{1F1F7}\u{1F1FA}-\u{1F1FF}]|\u{1F1E7}[\u{1F1E6}\u{1F1E7}\u{1F1E9}-\u{1F1EF}\u{1F1F1}-\u{1F1F4}\u{1F1F6}-\u{1F1F9}\u{1F1FB}\u{1F1FC}\u{1F1FE}\u{1F1FF}]|\u{1F1E6}[\u{1F1E8}-\u{1F1EC}\u{1F1EE}\u{1F1F1}\u{1F1F2}\u{1F1F4}\u{1F1F6}-\u{1F1FA}\u{1F1FC}\u{1F1FD}\u{1F1FF}]|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}][\u{1F3FB}-\u{1F3FF}]|[\u26F9\u{1F3CB}\u{1F3CC}\u{1F575}][\uFE0F\u{1F3FB}-\u{1F3FF}]|\u{1F3F4}|[\u270A\u270B\u{1F385}\u{1F3C2}\u{1F3C7}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}\u{1F467}\u{1F46B}-\u{1F46D}\u{1F472}\u{1F474}-\u{1F476}\u{1F478}\u{1F47C}\u{1F483}\u{1F485}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F57A}\u{1F595}\u{1F596}\u{1F64C}\u{1F64F}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91C}\u{1F91E}\u{1F91F}\u{1F930}-\u{1F934}\u{1F936}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9BB}\u{1F9D2}\u{1F9D3}\u{1F9D5}][\u{1F3FB}-\u{1F3FF}]|[\u261D\u270C\u270D\u{1F574}\u{1F590}][\uFE0F\u{1F3FB}-\u{1F3FF}]|[\u270A\u270B\u{1F385}\u{1F3C2}\u{1F3C7}\u{1F408}\u{1F415}\u{1F43B}\u{1F442}\u{1F443}\u{1F446}-\u{1F450}\u{1F466}\u{1F467}\u{1F46B}-\u{1F46D}\u{1F472}\u{1F474}-\u{1F476}\u{1F478}\u{1F47C}\u{1F483}\u{1F485}\u{1F48F}\u{1F491}\u{1F4AA}\u{1F57A}\u{1F595}\u{1F596}\u{1F62E}\u{1F635}\u{1F636}\u{1F64C}\u{1F64F}\u{1F6C0}\u{1F6CC}\u{1F90C}\u{1F90F}\u{1F918}-\u{1F91C}\u{1F91E}\u{1F91F}\u{1F930}-\u{1F934}\u{1F936}\u{1F977}\u{1F9B5}\u{1F9B6}\u{1F9BB}\u{1F9D2}\u{1F9D3}\u{1F9D5}]|[\u{1F3C3}\u{1F3C4}\u{1F3CA}\u{1F46E}\u{1F470}\u{1F471}\u{1F473}\u{1F477}\u{1F481}\u{1F482}\u{1F486}\u{1F487}\u{1F645}-\u{1F647}\u{1F64B}\u{1F64D}\u{1F64E}\u{1F6A3}\u{1F6B4}-\u{1F6B6}\u{1F926}\u{1F935}\u{1F937}-\u{1F939}\u{1F93D}\u{1F93E}\u{1F9B8}\u{1F9B9}\u{1F9CD}-\u{1F9CF}\u{1F9D4}\u{1F9D6}-\u{1F9DD}]|[\u{1F46F}\u{1F93C}\u{1F9DE}\u{1F9DF}]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55\u{1F004}\u{1F0CF}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F201}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F236}\u{1F238}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F320}\u{1F32D}-\u{1F335}\u{1F337}-\u{1F37C}\u{1F37E}-\u{1F384}\u{1F386}-\u{1F393}\u{1F3A0}-\u{1F3C1}\u{1F3C5}\u{1F3C6}\u{1F3C8}\u{1F3C9}\u{1F3CF}-\u{1F3D3}\u{1F3E0}-\u{1F3F0}\u{1F3F8}-\u{1F407}\u{1F409}-\u{1F414}\u{1F416}-\u{1F43A}\u{1F43C}-\u{1F43E}\u{1F440}\u{1F444}\u{1F445}\u{1F451}-\u{1F465}\u{1F46A}\u{1F479}-\u{1F47B}\u{1F47D}-\u{1F480}\u{1F484}\u{1F488}-\u{1F48E}\u{1F490}\u{1F492}-\u{1F4A9}\u{1F4AB}-\u{1F4FC}\u{1F4FF}-\u{1F53D}\u{1F54B}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F5A4}\u{1F5FB}-\u{1F62D}\u{1F62F}-\u{1F634}\u{1F637}-\u{1F644}\u{1F648}-\u{1F64A}\u{1F680}-\u{1F6A2}\u{1F6A4}-\u{1F6B3}\u{1F6B7}-\u{1F6BF}\u{1F6C1}-\u{1F6C5}\u{1F6D0}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6EB}\u{1F6EC}\u{1F6F4}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F90D}\u{1F90E}\u{1F910}-\u{1F917}\u{1F91D}\u{1F920}-\u{1F925}\u{1F927}-\u{1F92F}\u{1F93A}\u{1F93F}-\u{1F945}\u{1F947}-\u{1F976}\u{1F978}\u{1F97A}-\u{1F9B4}\u{1F9B7}\u{1F9BA}\u{1F9BC}-\u{1F9CB}\u{1F9D0}\u{1F9E0}-\u{1F9FF}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7A}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAA8}\u{1FAB0}-\u{1FAB6}\u{1FAC0}-\u{1FAC2}\u{1FAD0}-\u{1FAD6}]|[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299\u{1F004}\u{1F0CF}\u{1F170}\u{1F171}\u{1F17E}\u{1F17F}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F1E6}-\u{1F1FF}\u{1F201}\u{1F202}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F321}\u{1F324}-\u{1F393}\u{1F396}\u{1F397}\u{1F399}-\u{1F39B}\u{1F39E}-\u{1F3F0}\u{1F3F3}-\u{1F3F5}\u{1F3F7}-\u{1F4FD}\u{1F4FF}-\u{1F53D}\u{1F549}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F56F}\u{1F570}\u{1F573}-\u{1F57A}\u{1F587}\u{1F58A}-\u{1F58D}\u{1F590}\u{1F595}\u{1F596}\u{1F5A4}\u{1F5A5}\u{1F5A8}\u{1F5B1}\u{1F5B2}\u{1F5BC}\u{1F5C2}-\u{1F5C4}\u{1F5D1}-\u{1F5D3}\u{1F5DC}-\u{1F5DE}\u{1F5E1}\u{1F5E3}\u{1F5E8}\u{1F5EF}\u{1F5F3}\u{1F5FA}-\u{1F64F}\u{1F680}-\u{1F6C5}\u{1F6CB}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6E0}-\u{1F6E5}\u{1F6E9}\u{1F6EB}\u{1F6EC}\u{1F6F0}\u{1F6F3}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F90C}-\u{1F93A}\u{1F93C}-\u{1F945}\u{1F947}-\u{1F978}\u{1F97A}-\u{1F9CB}\u{1F9CD}-\u{1F9FF}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7A}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAA8}\u{1FAB0}-\u{1FAB6}\u{1FAC0}-\u{1FAC2}\u{1FAD0}-\u{1FAD6}]\uFE0F?/gu;
};
declare module 'emoji-regex' {
  function emojiRegex(): RegExp;

  export = emojiRegex;
}
"use strict";

module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
Copyright Mathias Bynens <https://mathiasbynens.be/>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
  "name": "emoji-regex",
  "version": "9.2.2",
  "description": "A regular expression to match all Emoji-only symbols as per the Unicode Standard.",
  "homepage": "https://mths.be/emoji-regex",
  "main": "index.js",
  "types": "index.d.ts",
  "keywords": [
    "unicode",
    "regex",
    "regexp",
    "regular expressions",
    "code points",
    "symbols",
    "characters",
    "emoji"
  ],
  "license": "MIT",
  "author": {
    "name": "Mathias Bynens",
    "url": "https://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/emoji-regex.git"
  },
  "bugs": "https://github.com/mathiasbynens/emoji-regex/issues",
  "files": [
    "LICENSE-MIT.txt",
    "index.js",
    "index.d.ts",
    "RGI_Emoji.js",
    "RGI_Emoji.d.ts",
    "text.js",
    "text.d.ts",
    "es2015"
  ],
  "scripts": {
    "build": "rm -rf -- es2015; babel src -d .; NODE_ENV=es2015 babel src es2015_types -D -d ./es2015; node script/inject-sequences.js",
    "test": "mocha",
    "test:watch": "npm run test -- --watch"
  },
  "devDependencies": {
    "@babel/cli": "^7.4.4",
    "@babel/core": "^7.4.4",
    "@babel/plugin-proposal-unicode-property-regex": "^7.4.4",
    "@babel/preset-env": "^7.4.4",
    "@unicode/unicode-13.0.0": "^1.0.3",
    "mocha": "^6.1.4",
    "regexgen": "^1.3.0"
  }
}
# emoji-regex [![Build status](https://travis-ci.org/mathiasbynens/emoji-regex.svg?branch=main)](https://travis-ci.org/mathiasbynens/emoji-regex)

_emoji-regex_ offers a regular expression to match all emoji symbols and sequences (including textual representations of emoji) as per the Unicode Standard.

This repository contains a script that generates this regular expression based on [Unicode data](https://github.com/node-unicode/node-unicode-data). Because of this, the regular expression can easily be updated whenever new emoji are added to the Unicode standard.

## Installation

Via [npm](https://www.npmjs.com/):

```bash
npm install emoji-regex
```

In [Node.js](https://nodejs.org/):

```js
const emojiRegex = require('emoji-regex/RGI_Emoji.js');
// Note: because the regular expression has the global flag set, this module
// exports a function that returns the regex rather than exporting the regular
// expression itself, to make it impossible to (accidentally) mutate the
// original regular expression.

const text = `
\u{231A}: ⌚ default emoji presentation character (Emoji_Presentation)
\u{2194}\u{FE0F}: ↔️ default text presentation character rendered as emoji
\u{1F469}: 👩 emoji modifier base (Emoji_Modifier_Base)
\u{1F469}\u{1F3FF}: 👩🏿 emoji modifier base followed by a modifier
`;

const regex = emojiRegex();
let match;
while (match = regex.exec(text)) {
  const emoji = match[0];
  console.log(`Matched sequence ${ emoji } — code points: ${ [...emoji].length }`);
}
```

Console output:

```
Matched sequence ⌚ — code points: 1
Matched sequence ⌚ — code points: 1
Matched sequence ↔️ — code points: 2
Matched sequence ↔️ — code points: 2
Matched sequence 👩 — code points: 1
Matched sequence 👩 — code points: 1
Matched sequence 👩🏿 — code points: 2
Matched sequence 👩🏿 — code points: 2
```

## Regular expression flavors

The package comes with three distinct regular expressions:

```js
// This is the recommended regular expression to use. It matches all
// emoji recommended for general interchange, as defined via the
// `RGI_Emoji` property in the Unicode Standard.
// https://unicode.org/reports/tr51/#def_rgi_set
// When in doubt, use this!
const emojiRegexRGI = require('emoji-regex/RGI_Emoji.js');

// This is the old regular expression, prior to `RGI_Emoji` being
// standardized. In addition to all `RGI_Emoji` sequences, it matches
// some emoji you probably don’t want to match (such as emoji component
// symbols that are not meant to be used separately).
const emojiRegex = require('emoji-regex/index.js');

// This regular expression matches even more emoji than the previous
// one, including emoji that render as text instead of icons (i.e.
// emoji that are not `Emoji_Presentation` symbols and that aren’t
// forced to render as emoji by a variation selector).
const emojiRegexText = require('emoji-regex/text.js');
```

Additionally, in environments which support ES2015 Unicode escapes, you may `require` ES2015-style versions of the regexes:

```js
const emojiRegexRGI = require('emoji-regex/es2015/RGI_Emoji.js');
const emojiRegex = require('emoji-regex/es2015/index.js');
const emojiRegexText = require('emoji-regex/es2015/text.js');
```

## For maintainers

### How to update emoji-regex after new Unicode Standard releases

1. Update the Unicode data dependency in `package.json` by running the following commands:

    ```sh
    # Example: updating from Unicode v12 to Unicode v13.
    npm uninstall @unicode/unicode-12.0.0
    npm install @unicode/unicode-13.0.0 --save-dev
    ````

1. Generate the new output:

    ```sh
    npm run build
    ```

1. Verify that tests still pass:

    ```sh
    npm test
    ```

1. Send a pull request with the changes, and get it reviewed & merged.

1. On the `main` branch, bump the emoji-regex version number in `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    Instead of `patch`, use `minor` or `major` [as needed](https://semver.org/).

    Note that this produces a Git commit + tag.

1. Push the release commit and tag:

    ```sh
    git push
    ```

    Our CI then automatically publishes the new release to npm.

## Author

| [![twitter/mathias](https://gravatar.com/avatar/24e08a9ea84deb17ae121074d0f17125?s=70)](https://twitter.com/mathias "Follow @mathias on Twitter") |
|---|
| [Mathias Bynens](https://mathiasbynens.be/) |

## License

_emoji-regex_ is available under the [MIT](https://mths.be/mit) license.
declare module 'emoji-regex/RGI_Emoji' {
  function emojiRegex(): RegExp;

  export = emojiRegex;
}
"use strict";

module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]/g;
};
declare module 'emoji-regex/text' {
  function emojiRegex(): RegExp;

  export = emojiRegex;
}
"use strict";

module.exports = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F?/g;
};
export interface Options {
	/**
	Count [ambiguous width characters](https://www.unicode.org/reports/tr11/#Ambiguous) as having narrow width (count of 1) instead of wide width (count of 2).

	@default true
	*/
	readonly ambiguousIsNarrow: boolean;
}

/**
Get the visual width of a string - the number of columns required to display it.

Some Unicode characters are [fullwidth](https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms) and use double the normal width. [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) are stripped and doesn't affect the width.

@example
```
import stringWidth from 'string-width';

stringWidth('a');
//=> 1

stringWidth('古');
//=> 2

stringWidth('\u001B[1m古\u001B[22m');
//=> 2
```
*/
export default function stringWidth(string: string, options?: Options): number;
import stripAnsi from 'strip-ansi';
import eastAsianWidth from 'eastasianwidth';
import emojiRegex from 'emoji-regex';

export default function stringWidth(string, options = {}) {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	options = {
		ambiguousIsNarrow: true,
		...options
	};

	string = stripAnsi(string);

	if (string.length === 0) {
		return 0;
	}

	string = string.replace(emojiRegex(), '  ');

	const ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2;
	let width = 0;

	for (const character of string) {
		const codePoint = character.codePointAt(0);

		// Ignore control characters
		if (codePoint <= 0x1F || (codePoint >= 0x7F && codePoint <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (codePoint >= 0x300 && codePoint <= 0x36F) {
			continue;
		}

		const code = eastAsianWidth.eastAsianWidth(character);
		switch (code) {
			case 'F':
			case 'W':
				width += 2;
				break;
			case 'A':
				width += ambiguousCharacterWidth;
				break;
			default:
				width += 1;
		}
	}

	return width;
}
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
	"name": "string-width",
	"version": "5.1.2",
	"description": "Get the visual width of a string - the number of columns required to display it",
	"license": "MIT",
	"repository": "sindresorhus/string-width",
	"funding": "https://github.com/sponsors/sindresorhus",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"string",
		"character",
		"unicode",
		"width",
		"visual",
		"column",
		"columns",
		"fullwidth",
		"full-width",
		"full",
		"ansi",
		"escape",
		"codes",
		"cli",
		"command-line",
		"terminal",
		"console",
		"cjk",
		"chinese",
		"japanese",
		"korean",
		"fixed-width"
	],
	"dependencies": {
		"eastasianwidth": "^0.2.0",
		"emoji-regex": "^9.2.2",
		"strip-ansi": "^7.0.1"
	},
	"devDependencies": {
		"ava": "^3.15.0",
		"tsd": "^0.14.0",
		"xo": "^0.38.2"
	}
}
# string-width

> Get the visual width of a string - the number of columns required to display it

Some Unicode characters are [fullwidth](https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms) and use double the normal width. [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) are stripped and doesn't affect the width.

Useful to be able to measure the actual width of command-line output.

## Install

```
$ npm install string-width
```

## Usage

```js
import stringWidth from 'string-width';

stringWidth('a');
//=> 1

stringWidth('古');
//=> 2

stringWidth('\u001B[1m古\u001B[22m');
//=> 2
```

## API

### stringWidth(string, options?)

#### string

Type: `string`

The string to be counted.

#### options

Type: `object`

##### ambiguousIsNarrow

Type: `boolean`\
Default: `false`

Count [ambiguous width characters](https://www.unicode.org/reports/tr11/#Ambiguous) as having narrow width (count of 1) instead of wide width (count of 2).

## Related

- [string-width-cli](https://github.com/sindresorhus/string-width-cli) - CLI for this module
- [string-length](https://github.com/sindresorhus/string-length) - Get the real length of a string
- [widest-line](https://github.com/sindresorhus/widest-line) - Get the visual width of the widest line in a string

---

<div align="center">
	<b>
		<a href="https://tidelift.com/subscription/pkg/npm-string-width?utm_source=npm-string-width&utm_medium=referral&utm_campaign=readme">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>
/**
Strip [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from a string.

@example
```
import stripAnsi from 'strip-ansi';

stripAnsi('\u001B[4mUnicorn\u001B[0m');
//=> 'Unicorn'

stripAnsi('\u001B]8;;https://github.com\u0007Click\u001B]8;;\u0007');
//=> 'Click'
```
*/
export default function stripAnsi(string: string): string;
import ansiRegex from 'ansi-regex';

const regex = ansiRegex();

export default function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	// Even though the regex is global, we don't need to reset the `.lastIndex`
	// because unlike `.exec()` and `.test()`, `.replace()` does it automatically
	// and doing it manually has a performance penalty.
	return string.replace(regex, '');
}
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
	"name": "strip-ansi",
	"version": "7.1.0",
	"description": "Strip ANSI escape codes from a string",
	"license": "MIT",
	"repository": "chalk/strip-ansi",
	"funding": "https://github.com/chalk/strip-ansi?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": "./index.js",
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"strip",
		"trim",
		"remove",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-regex": "^6.0.1"
	},
	"devDependencies": {
		"ava": "^3.15.0",
		"tsd": "^0.17.0",
		"xo": "^0.44.0"
	}
}
# strip-ansi

> Strip [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from a string

## Install

```
$ npm install strip-ansi
```

## Usage

```js
import stripAnsi from 'strip-ansi';

stripAnsi('\u001B[4mUnicorn\u001B[0m');
//=> 'Unicorn'

stripAnsi('\u001B]8;;https://github.com\u0007Click\u001B]8;;\u0007');
//=> 'Click'
```

## strip-ansi for enterprise

Available as part of the Tidelift Subscription.

The maintainers of strip-ansi and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/npm-strip-ansi?utm_source=npm-strip-ansi&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

## Related

- [strip-ansi-cli](https://github.com/chalk/strip-ansi-cli) - CLI for this module
- [strip-ansi-stream](https://github.com/chalk/strip-ansi-stream) - Streaming version of this module
- [has-ansi](https://github.com/chalk/has-ansi) - Check if a string has ANSI escape codes
- [ansi-regex](https://github.com/chalk/ansi-regex) - Regular expression for matching ANSI escape codes
- [chalk](https://github.com/chalk/chalk) - Terminal string styling done right

## Maintainers

- [Sindre Sorhus](https://github.com/sindresorhus)
- [Josh Junon](https://github.com/qix-)

export type Options = {
	/**
	By default the wrap is soft, meaning long words may extend past the column width. Setting this to `true` will make it hard wrap at the column width.

	@default false
	*/
	readonly hard?: boolean;

	/**
	By default, an attempt is made to split words at spaces, ensuring that they don't extend past the configured columns. If wordWrap is `false`, each column will instead be completely filled splitting words as necessary.

	@default true
	*/
	readonly wordWrap?: boolean;

	/**
	Whitespace on all lines is removed by default. Set this option to `false` if you don't want to trim.

	@default true
	*/
	readonly trim?: boolean;
};

/**
Wrap words to the specified column width.

@param string - String with ANSI escape codes. Like one styled by [`chalk`](https://github.com/chalk/chalk). Newline characters will be normalized to `\n`.
@param columns - Number of columns to wrap the text to.

@example
```
import chalk from 'chalk';
import wrapAnsi from 'wrap-ansi';

const input = 'The quick brown ' + chalk.red('fox jumped over ') +
	'the lazy ' + chalk.green('dog and then ran away with the unicorn.');

console.log(wrapAnsi(input, 20));
```
*/
export default function wrapAnsi(string: string, columns: number, options?: Options): string;
import stringWidth from 'string-width';
import stripAnsi from 'strip-ansi';
import ansiStyles from 'ansi-styles';

const ESCAPES = new Set([
	'\u001B',
	'\u009B',
]);

const END_CODE = 39;
const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

const wrapAnsiCode = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => {
	const characters = [...word];

	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);

		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}

		if (ESCAPES.has(character)) {
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
		}

		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) {
				isInsideEscape = false;
			}

			continue;
		}

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = string => {
	const words = string.split(' ');
	let last = words.length;

	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return string;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	let returnValue = '';
	let escapeCode;
	let escapeUrl;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows[rows.length - 1].trimStart();
		}

		let rowLength = stringWidth(rows[rows.length - 1]);

		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			}

			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}

		// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}

			wrapWord(rows, word, columns);
			continue;
		}

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows.push('');
		}

		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}

		rows[rows.length - 1] += word;
	}

	if (options.trim !== false) {
		rows = rows.map(row => stringVisibleTrimSpacesRight(row));
	}

	const pre = [...rows.join('\n')];

	for (const [index, character] of pre.entries()) {
		returnValue += character;

		if (ESCAPES.has(character)) {
			const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join('')) || {groups: {}};
			if (groups.code !== undefined) {
				const code = Number.parseFloat(groups.code);
				escapeCode = code === END_CODE ? undefined : code;
			} else if (groups.uri !== undefined) {
				escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
			}
		}

		const code = ansiStyles.codes.get(Number(escapeCode));

		if (pre[index + 1] === '\n') {
			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink('');
			}

			if (escapeCode && code) {
				returnValue += wrapAnsiCode(code);
			}
		} else if (character === '\n') {
			if (escapeCode && code) {
				returnValue += wrapAnsiCode(escapeCode);
			}

			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink(escapeUrl);
			}
		}
	}

	return returnValue;
};

// For each newline, invoke the method separately
export default function wrapAnsi(string, columns, options) {
	return String(string)
		.normalize()
		.replace(/\r\n/g, '\n')
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
}
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
	"name": "wrap-ansi",
	"version": "8.1.0",
	"description": "Wordwrap a string with ANSI escape codes",
	"license": "MIT",
	"repository": "chalk/wrap-ansi",
	"funding": "https://github.com/chalk/wrap-ansi?sponsor=1",
	"author": {
		"name": "Sindre Sorhus",
		"email": "sindresorhus@gmail.com",
		"url": "https://sindresorhus.com"
	},
	"type": "module",
	"exports": {
		"types": "./index.d.ts",
		"default": "./index.js"
	},
	"engines": {
		"node": ">=12"
	},
	"scripts": {
		"test": "xo && nyc ava && tsd"
	},
	"files": [
		"index.js",
		"index.d.ts"
	],
	"keywords": [
		"wrap",
		"break",
		"wordwrap",
		"wordbreak",
		"linewrap",
		"ansi",
		"styles",
		"color",
		"colour",
		"colors",
		"terminal",
		"console",
		"cli",
		"string",
		"tty",
		"escape",
		"formatting",
		"rgb",
		"256",
		"shell",
		"xterm",
		"log",
		"logging",
		"command-line",
		"text"
	],
	"dependencies": {
		"ansi-styles": "^6.1.0",
		"string-width": "^5.0.1",
		"strip-ansi": "^7.0.1"
	},
	"devDependencies": {
		"ava": "^3.15.0",
		"chalk": "^4.1.2",
		"coveralls": "^3.1.1",
		"has-ansi": "^5.0.1",
		"nyc": "^15.1.0",
		"tsd": "^0.25.0",
		"xo": "^0.44.0"
	}
}
# wrap-ansi

> Wordwrap a string with [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code#Colors_and_Styles)

## Install

```
$ npm install wrap-ansi
```

## Usage

```js
import chalk from 'chalk';
import wrapAnsi from 'wrap-ansi';

const input = 'The quick brown ' + chalk.red('fox jumped over ') +
	'the lazy ' + chalk.green('dog and then ran away with the unicorn.');

console.log(wrapAnsi(input, 20));
```

<img width="331" src="screenshot.png">

## API

### wrapAnsi(string, columns, options?)

Wrap words to the specified column width.

#### string

Type: `string`

String with ANSI escape codes. Like one styled by [`chalk`](https://github.com/chalk/chalk). Newline characters will be normalized to `\n`.

#### columns

Type: `number`

Number of columns to wrap the text to.

#### options

Type: `object`

##### hard

Type: `boolean`\
Default: `false`

By default the wrap is soft, meaning long words may extend past the column width. Setting this to `true` will make it hard wrap at the column width.

##### wordWrap

Type: `boolean`\
Default: `true`

By default, an attempt is made to split words at spaces, ensuring that they don't extend past the configured columns. If wordWrap is `false`, each column will instead be completely filled splitting words as necessary.

##### trim

Type: `boolean`\
Default: `true`

Whitespace on all lines is removed by default. Set this option to `false` if you don't want to trim.

## Related

- [slice-ansi](https://github.com/chalk/slice-ansi) - Slice a string with ANSI escape codes
- [cli-truncate](https://github.com/sindresorhus/cli-truncate) - Truncate a string to a specific width in the terminal
- [chalk](https://github.com/chalk/chalk) - Terminal string styling done right
- [jsesc](https://github.com/mathiasbynens/jsesc) - Generate ASCII-only output from Unicode strings. Useful for creating test fixtures.

## Maintainers

- [Sindre Sorhus](https://github.com/sindresorhus)
- [Josh Junon](https://github.com/qix-)
- [Benjamin Coe](https://github.com/bcoe)

---

<div align="center">
	<b>
		<a href="https://tidelift.com/subscription/pkg/npm-wrap_ansi?utm_source=npm-wrap-ansi&utm_medium=referral&utm_campaign=readme">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>
{
  "name": "@isaacs/cliui",
  "version": "8.0.2",
  "description": "easily create complex multi-column command-line-interfaces",
  "main": "build/index.cjs",
  "exports": {
    ".": [
      {
        "import": "./index.mjs",
        "require": "./build/index.cjs"
      },
      "./build/index.cjs"
    ]
  },
  "type": "module",
  "module": "./index.mjs",
  "scripts": {
    "check": "standardx '**/*.ts' && standardx '**/*.js' && standardx '**/*.cjs'",
    "fix": "standardx --fix '**/*.ts' && standardx --fix '**/*.js' && standardx --fix '**/*.cjs'",
    "pretest": "rimraf build && tsc -p tsconfig.test.json && cross-env NODE_ENV=test npm run build:cjs",
    "test": "c8 mocha ./test/*.cjs",
    "test:esm": "c8 mocha ./test/**/*.mjs",
    "postest": "check",
    "coverage": "c8 report --check-coverage",
    "precompile": "rimraf build",
    "compile": "tsc",
    "postcompile": "npm run build:cjs",
    "build:cjs": "rollup -c",
    "prepare": "npm run compile"
  },
  "repository": "yargs/cliui",
  "standard": {
    "ignore": [
      "**/example/**"
    ],
    "globals": [
      "it"
    ]
  },
  "keywords": [
    "cli",
    "command-line",
    "layout",
    "design",
    "console",
    "wrap",
    "table"
  ],
  "author": "Ben Coe <ben@npmjs.com>",
  "license": "ISC",
  "dependencies": {
    "string-width": "^5.1.2",
    "string-width-cjs": "npm:string-width@^4.2.0",
    "strip-ansi": "^7.0.1",
    "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
    "wrap-ansi": "^8.1.0",
    "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
  },
  "devDependencies": {
    "@types/node": "^14.0.27",
    "@typescript-eslint/eslint-plugin": "^4.0.0",
    "@typescript-eslint/parser": "^4.0.0",
    "c8": "^7.3.0",
    "chai": "^4.2.0",
    "chalk": "^4.1.0",
    "cross-env": "^7.0.2",
    "eslint": "^7.6.0",
    "eslint-plugin-import": "^2.22.0",
    "eslint-plugin-node": "^11.1.0",
    "gts": "^3.0.0",
    "mocha": "^10.0.0",
    "rimraf": "^3.0.2",
    "rollup": "^2.23.1",
    "rollup-plugin-ts": "^3.0.2",
    "standardx": "^7.0.0",
    "typescript": "^4.0.0"
  },
  "files": [
    "build",
    "index.mjs",
    "!*.d.ts"
  ],
  "engines": {
    "node": ">=12"
  }
}
# @isaacs/cliui

Temporary fork of [cliui](http://npm.im/cliui).

![ci](https://github.com/yargs/cliui/workflows/ci/badge.svg)
[![NPM version](https://img.shields.io/npm/v/cliui.svg)](https://www.npmjs.com/package/cliui)
[![Conventional Commits](https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg)](https://conventionalcommits.org)
![nycrc config on GitHub](https://img.shields.io/nycrc/yargs/cliui)

easily create complex multi-column command-line-interfaces.

## Example

```js
const ui = require('cliui')()

ui.div('Usage: $0 [command] [options]')

ui.div({
  text: 'Options:',
  padding: [2, 0, 1, 0]
})

ui.div(
  {
    text: "-f, --file",
    width: 20,
    padding: [0, 4, 0, 4]
  },
  {
    text: "the file to load." +
      chalk.green("(if this description is long it wraps).")
    ,
    width: 20
  },
  {
    text: chalk.red("[required]"),
    align: 'right'
  }
)

console.log(ui.toString())
```

## Deno/ESM Support

As of `v7` `cliui` supports [Deno](https://github.com/denoland/deno) and
[ESM](https://nodejs.org/api/esm.html#esm_ecmascript_modules):

```typescript
import cliui from "https://deno.land/x/cliui/deno.ts";

const ui = cliui({})

ui.div('Usage: $0 [command] [options]')

ui.div({
  text: 'Options:',
  padding: [2, 0, 1, 0]
})

ui.div({
  text: "-f, --file",
  width: 20,
  padding: [0, 4, 0, 4]
})

console.log(ui.toString())
```

<img width="500" src="screenshot.png">

## Layout DSL

cliui exposes a simple layout DSL:

If you create a single `ui.div`, passing a string rather than an
object:

* `\n`: characters will be interpreted as new rows.
* `\t`: characters will be interpreted as new columns.
* `\s`: characters will be interpreted as padding.

**as an example...**

```js
var ui = require('./')({
  width: 60
})

ui.div(
  'Usage: node ./bin/foo.js\n' +
  '  <regex>\t  provide a regex\n' +
  '  <glob>\t  provide a glob\t [required]'
)

console.log(ui.toString())
```

**will output:**

```shell
Usage: node ./bin/foo.js
  <regex>  provide a regex
  <glob>   provide a glob          [required]
```

## Methods

```js
cliui = require('cliui')
```

### cliui({width: integer})

Specify the maximum width of the UI being generated.
If no width is provided, cliui will try to get the current window's width and use it, and if that doesn't work, width will be set to `80`.

### cliui({wrap: boolean})

Enable or disable the wrapping of text in a column.

### cliui.div(column, column, column)

Create a row with any number of columns, a column
can either be a string, or an object with the following
options:

* **text:** some text to place in the column.
* **width:** the width of a column.
* **align:** alignment, `right` or `center`.
* **padding:** `[top, right, bottom, left]`.
* **border:** should a border be placed around the div?

### cliui.span(column, column, column)

Similar to `div`, except the next row will be appended without
a new line being created.

### cliui.resetOutput()

Resets the UI elements of the current cliui instance, maintaining the values
set for `width` and `wrap`.
# Change Log

All notable changes to this project will be documented in this file.

The format is based on Keep a Changelog and this project adheres to Semantic Versioning.

## [4.4.2] - 2023.07.21

### Fixed

- The pointer of Adapter container's iterator cannot as array to be deconstructed.

### Added

- Add `isAccessible` function to iterators for iterable containers.

## [4.4.1] - 2023.06.05

### Fixed

- Tree container with less than 3 items reverse iteration infinite loop

## [4.4.0] - 2023.03.17

### Changed

- Optimized inOrder travel function for tree container.
- Optimized `Symbol.iterator` function.
- Optimized `TreeContainer` `erase` function.
- Optimized some details of deque.
- Change `reverse` and `sort` returned value to `this`.

## [4.3.0] - 2023.01.20

### Added

- Add public member `container` to `Iterator` which means the container that the iterator pointed to.

### Changed

- Reimplement `Queue`, separate `Queue` from `Deque`.

## [4.2.0] - 2022.11.20

### Changed

- Optimized the structure of class `TreeNodeEnableIndex`.
- Change the `iterator access denied` error message to reduce the packing size.
- Change the internal storage of the hash container to the form of a linked list, traversing in insertion order.
- Standardize hash container. Make it extends from `Container` and add general functions.
- Refactor `LinkList` to do optimization.

### Added

- Add public `length` property to all the container.
- Add returned value to `pop` function including `popBack` and `popFront` to all the container which has such function.
- Add returned value to `eraseElementByKey` which means whether erase successfully.
- Add returned value to `push` or `insert` function which means the size of the container.

### Fixed

- Fixed wrong error type when `updateKeyByIterator`.
- Fixed wrong iterator was returned when erase tree reverse iterator.

## [4.2.0-beta.1] - 2022.11.06

### Changed

- Remove all the arrow function to optimize.
- Modify `HashContainer` implementation to optimize.

## [4.2.0-beta.0] - 2022.10.30

### Added

- Add `ts` sourcemap for debug mode.
- Add `this` param for `forEach` function.
- Support single package umd build.

### Changed

- Changed the packaging method of isolation packages release and the method of the member export.

## [4.1.5] - 2022.09.30

### Added

- Add `find`, `remove`, `updateItem` and `toArray` functions to `PriorityQueue`.
- Support single package release (use scope @js-sdsl).

## [4.1.5-beta.1] - 2022.09.23

### Fixed

- Get wrong tree index when size is 0.

## [4.1.5-beta.0] - 2022.09.23

### Added

- Add `index` property to tree iterator which represents the sequential index of the iterator in the tree.

### Changed

- Minimal optimization with private properties mangling, macro inlining and const enum.
- Private properties are now mangled.
- Remove `checkWithinAccessParams` function.
- Constants of `HashContainer` are moved to `HashContainerConst` const enum.
- The iteratorType parameter in the constructor now changed from `boolean` type to `IteratorType` const enum type.
- The type of `TreeNode.color` is now changed from `boolean` to `TreeNodeColor` const enum.
- Turn some member exports into export-only types.

### Fixed

- Fixed wrong iterator error message.

## [4.1.4] - 2022.09.07

### Added

- Add some notes.

### Changed

- Optimize hash container.
- Abstracting out the hash container.

### Fixed

- Fixed tree get height function return one larger than the real height.
- Tree-shaking not work in ES module.
- `Queue` and `Deque` should return `undefined` when container is empty.

## [4.1.4-beta.0] - 2022.08.31

### Added

- Add function update key by iterator.
- Add iterator copy function to get a copy of itself.
- Add insert by iterator hint function in tree container.

### Changed

- Changed OrderedMap's iterator pointer get from `Object.defineProperty'` to  `Proxy`.
- Improve iterator performance by remove some judgment.
- Change iterator type description from `normal` and `reverse` to boolean.

## [4.1.2-beta.0] - 2022.08.27

### Added

- Make `SequentialContainer` and `TreeBaseContainer` export in the index.

### Changed

- Change rbTree binary search from recursive to loop implementation (don't effect using).
- Reduce memory waste during deque initialization.

### Fixed

- Fixed priority queue not dereference on pop.

## [4.1.1] - 2022.08.23

### Fixed

- Forgot to reset root node on rotation in red-black tree delete operation.
- Fix iterator invalidation after tree container removes iterator.

## [4.1.0] - 2022.08.21

### Changed

- Change some functions from recursive to loop implementation (don't effect using).
- Change some iterator function parameter type.
- Change commonjs target to `es6`.
- Change `Deque` from sequential queue to circular queue.
- Optimize so many places (don't affect using).

### Fixed

- Fix `Vector` length bugs.

## [4.0.3] - 2022-08-13

### Changed

- Change `if (this.empty())` to `if (!this.length)`.
- Change some unit test.
- Change class type and optimized type design.

### Fixed

- Fix can push undefined to deque.

## [4.0.0] - 2022-07-30

### Changed

- Remove InternalError error as much as possible (don't affect using).
- Change `HashSet` api `eraseElementByValue`'s name to `eraseElementByKey`.
- Change some unit tests to improve coverage (don't affect using).

## [4.0.0-beta.0] - 2022-07-24

### Added

- Complete test examples (don't effect using).
- The error thrown is standardized, you can catch it according to the error type.

### Changed

- Refactor all container from function to class (don't affect using).
- Abstracting tree containers and hash containers, change `Set`'s and `Map`'s name to `OrderedSet` and `OrderedMap` to distinguish it from the official container.
- Change `OrderedSet` api `eraseElementByValue`'s name to `eraseElementByKey`.

### Fixed

- Fixed so many bugs.

## [3.0.0-beta.0] - 2022-04-29

### Added

- Bidirectional iterator is provided for all containers except Stack, Queue, HashSet and HashMap.
- Added begin, end, rBegin and rEnd functions to some containers for using iterator.
- Added `eraseElementByIterator` function.

### Changed

- Changed Pair type `T, K` to `K, V` (don't affect using).
- Changed `find`, `lowerBound`, `upperBound`, `reverseLowerBound` and `reverseUpperBound` function's returned value to `Iterator`.

### Fixed

- Fixed an error when the insert value was 0.
- Fixed the problem that the lower version browser does not recognize symbol Compilation error caused by iterator.
/**
 * @description The iterator type including `NORMAL` and `REVERSE`.
 */
declare const enum IteratorType {
    NORMAL = 0,
    REVERSE = 1
}
declare abstract class ContainerIterator<T> {
    /**
     * @description The container pointed to by the iterator.
     */
    abstract readonly container: Container<T>;
    /**
     * @description Iterator's type.
     * @example
     * console.log(container.end().iteratorType === IteratorType.NORMAL);  // true
     */
    readonly iteratorType: IteratorType;
    /**
     * @param iter - The other iterator you want to compare.
     * @returns Whether this equals to obj.
     * @example
     * container.find(1).equals(container.end());
     */
    equals(iter: ContainerIterator<T>): boolean;
    /**
     * @description Pointers to element.
     * @returns The value of the pointer's element.
     * @example
     * const val = container.begin().pointer;
     */
    abstract get pointer(): T;
    /**
     * @description Set pointer's value (some containers are unavailable).
     * @param newValue - The new value you want to set.
     * @example
     * (<LinkList<number>>container).begin().pointer = 1;
     */
    abstract set pointer(newValue: T);
    /**
     * @description Move `this` iterator to pre.
     * @returns The iterator's self.
     * @example
     * const iter = container.find(1);  // container = [0, 1]
     * const pre = iter.pre();
     * console.log(pre === iter);  // true
     * console.log(pre.equals(iter));  // true
     * console.log(pre.pointer, iter.pointer); // 0, 0
     */
    abstract pre(): this;
    /**
     * @description Move `this` iterator to next.
     * @returns The iterator's self.
     * @example
     * const iter = container.find(1);  // container = [1, 2]
     * const next = iter.next();
     * console.log(next === iter);  // true
     * console.log(next.equals(iter));  // true
     * console.log(next.pointer, iter.pointer); // 2, 2
     */
    abstract next(): this;
    /**
     * @description Get a copy of itself.
     * @returns The copy of self.
     * @example
     * const iter = container.find(1);  // container = [1, 2]
     * const next = iter.copy().next();
     * console.log(next === iter);  // false
     * console.log(next.equals(iter));  // false
     * console.log(next.pointer, iter.pointer); // 2, 1
     */
    abstract copy(): ContainerIterator<T>;
    abstract isAccessible(): boolean;
}
declare abstract class Base {
    /**
     * @returns The size of the container.
     * @example
     * const container = new Vector([1, 2]);
     * console.log(container.length); // 2
     */
    get length(): number;
    /**
     * @returns The size of the container.
     * @example
     * const container = new Vector([1, 2]);
     * console.log(container.size()); // 2
     */
    size(): number;
    /**
     * @returns Whether the container is empty.
     * @example
     * container.clear();
     * console.log(container.empty());  // true
     */
    empty(): boolean;
    /**
     * @description Clear the container.
     * @example
     * container.clear();
     * console.log(container.empty());  // true
     */
    abstract clear(): void;
}
declare abstract class Container<T> extends Base {
    /**
     * @returns Iterator pointing to the beginning element.
     * @example
     * const begin = container.begin();
     * const end = container.end();
     * for (const it = begin; !it.equals(end); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract begin(): ContainerIterator<T>;
    /**
     * @returns Iterator pointing to the super end like c++.
     * @example
     * const begin = container.begin();
     * const end = container.end();
     * for (const it = begin; !it.equals(end); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract end(): ContainerIterator<T>;
    /**
     * @returns Iterator pointing to the end element.
     * @example
     * const rBegin = container.rBegin();
     * const rEnd = container.rEnd();
     * for (const it = rBegin; !it.equals(rEnd); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract rBegin(): ContainerIterator<T>;
    /**
     * @returns Iterator pointing to the super begin like c++.
     * @example
     * const rBegin = container.rBegin();
     * const rEnd = container.rEnd();
     * for (const it = rBegin; !it.equals(rEnd); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract rEnd(): ContainerIterator<T>;
    /**
     * @returns The first element of the container.
     */
    abstract front(): T | undefined;
    /**
     * @returns The last element of the container.
     */
    abstract back(): T | undefined;
    /**
     * @param element - The element you want to find.
     * @returns An iterator pointing to the element if found, or super end if not found.
     * @example
     * container.find(1).equals(container.end());
     */
    abstract find(element: T): ContainerIterator<T>;
    /**
     * @description Iterate over all elements in the container.
     * @param callback - Callback function like Array.forEach.
     * @example
     * container.forEach((element, index) => console.log(element, index));
     */
    abstract forEach(callback: (element: T, index: number, container: Container<T>) => void): void;
    /**
     * @description Gets the value of the element at the specified position.
     * @example
     * const val = container.getElementByPos(-1); // throw a RangeError
     */
    abstract getElementByPos(pos: number): T;
    /**
     * @description Removes the element at the specified position.
     * @param pos - The element's position you want to remove.
     * @returns The container length after erasing.
     * @example
     * container.eraseElementByPos(-1); // throw a RangeError
     */
    abstract eraseElementByPos(pos: number): number;
    /**
     * @description Removes element by iterator and move `iter` to next.
     * @param iter - The iterator you want to erase.
     * @returns The next iterator.
     * @example
     * container.eraseElementByIterator(container.begin());
     * container.eraseElementByIterator(container.end()); // throw a RangeError
     */
    abstract eraseElementByIterator(iter: ContainerIterator<T>): ContainerIterator<T>;
    /**
     * @description Using for `for...of` syntax like Array.
     * @example
     * for (const element of container) {
     *   console.log(element);
     * }
     */
    abstract [Symbol.iterator](): Generator<T, void>;
}
/**
 * @description The initial data type passed in when initializing the container.
 */
type initContainer<T> = {
    size?: number | (() => number);
    length?: number;
    forEach: (callback: (el: T) => void) => void;
};
declare abstract class TreeIterator<K, V> extends ContainerIterator<K | [
    K,
    V
]> {
    abstract readonly container: TreeContainer<K, V>;
    /**
     * @description Get the sequential index of the iterator in the tree container.<br/>
     *              <strong>Note:</strong>
     *              This function only takes effect when the specified tree container `enableIndex = true`.
     * @returns The index subscript of the node in the tree.
     * @example
     * const st = new OrderedSet([1, 2, 3], true);
     * console.log(st.begin().next().index);  // 1
     */
    get index(): number;
    isAccessible(): boolean;
    // @ts-ignore
    pre(): this;
    // @ts-ignore
    next(): this;
}
declare const enum TreeNodeColor {
    RED = 1,
    BLACK = 0
}
declare class TreeNode<K, V> {
    _color: TreeNodeColor;
    _key: K | undefined;
    _value: V | undefined;
    _left: TreeNode<K, V> | undefined;
    _right: TreeNode<K, V> | undefined;
    _parent: TreeNode<K, V> | undefined;
    constructor(key?: K, value?: V, color?: TreeNodeColor);
    /**
     * @description Get the pre node.
     * @returns TreeNode about the pre node.
     */
    _pre(): TreeNode<K, V>;
    /**
     * @description Get the next node.
     * @returns TreeNode about the next node.
     */
    _next(): TreeNode<K, V>;
    /**
     * @description Rotate left.
     * @returns TreeNode about moved to original position after rotation.
     */
    _rotateLeft(): TreeNode<K, V>;
    /**
     * @description Rotate right.
     * @returns TreeNode about moved to original position after rotation.
     */
    _rotateRight(): TreeNode<K, V>;
}
declare abstract class TreeContainer<K, V> extends Container<K | [
    K,
    V
]> {
    enableIndex: boolean;
    protected _inOrderTraversal(): TreeNode<K, V>[];
    protected _inOrderTraversal(pos: number): TreeNode<K, V>;
    protected _inOrderTraversal(callback: (node: TreeNode<K, V>, index: number, map: this) => void): TreeNode<K, V>;
    clear(): void;
    /**
     * @description Update node's key by iterator.
     * @param iter - The iterator you want to change.
     * @param key - The key you want to update.
     * @returns Whether the modification is successful.
     * @example
     * const st = new orderedSet([1, 2, 5]);
     * const iter = st.find(2);
     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]
     */
    updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean;
    eraseElementByPos(pos: number): number;
    /**
     * @description Remove the element of the specified key.
     * @param key - The key you want to remove.
     * @returns Whether erase successfully.
     */
    eraseElementByKey(key: K): boolean;
    eraseElementByIterator(iter: TreeIterator<K, V>): TreeIterator<K, V>;
    /**
     * @description Get the height of the tree.
     * @returns Number about the height of the RB-tree.
     */
    getHeight(): number;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element less than the given key.
     */
    abstract reverseUpperBound(key: K): TreeIterator<K, V>;
    /**
     * @description Union the other tree to self.
     * @param other - The other tree container you want to merge.
     * @returns The size of the tree after union.
     */
    abstract union(other: TreeContainer<K, V>): number;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element not greater than the given key.
     */
    abstract reverseLowerBound(key: K): TreeIterator<K, V>;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element not less than the given key.
     */
    abstract lowerBound(key: K): TreeIterator<K, V>;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element greater than the given key.
     */
    abstract upperBound(key: K): TreeIterator<K, V>;
}
declare class OrderedMapIterator<K, V> extends TreeIterator<K, V> {
    container: OrderedMap<K, V>;
    constructor(node: TreeNode<K, V>, header: TreeNode<K, V>, container: OrderedMap<K, V>, iteratorType?: IteratorType);
    get pointer(): [
        K,
        V
    ];
    copy(): OrderedMapIterator<K, V>;
    // @ts-ignore
    equals(iter: OrderedMapIterator<K, V>): boolean;
}
declare class OrderedMap<K, V> extends TreeContainer<K, V> {
    /**
     * @param container - The initialization container.
     * @param cmp - The compare function.
     * @param enableIndex - Whether to enable iterator indexing function.
     * @example
     * new OrderedMap();
     * new OrderedMap([[0, 1], [2, 1]]);
     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);
     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);
     */
    constructor(container?: initContainer<[
        K,
        V
    ]>, cmp?: (x: K, y: K) => number, enableIndex?: boolean);
    begin(): OrderedMapIterator<K, V>;
    end(): OrderedMapIterator<K, V>;
    rBegin(): OrderedMapIterator<K, V>;
    rEnd(): OrderedMapIterator<K, V>;
    front(): [
        K,
        V
    ] | undefined;
    back(): [
        K,
        V
    ] | undefined;
    lowerBound(key: K): OrderedMapIterator<K, V>;
    upperBound(key: K): OrderedMapIterator<K, V>;
    reverseLowerBound(key: K): OrderedMapIterator<K, V>;
    reverseUpperBound(key: K): OrderedMapIterator<K, V>;
    forEach(callback: (element: [
        K,
        V
    ], index: number, map: OrderedMap<K, V>) => void): void;
    /**
     * @description Insert a key-value pair or set value by the given key.
     * @param key - The key want to insert.
     * @param value - The value want to set.
     * @param hint - You can give an iterator hint to improve insertion efficiency.
     * @return The size of container after setting.
     * @example
     * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);
     * const iter = mp.begin();
     * mp.setElement(1, 0);
     * mp.setElement(3, 0, iter);  // give a hint will be faster.
     */
    setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>): number;
    getElementByPos(pos: number): [
        K,
        V
    ];
    find(key: K): OrderedMapIterator<K, V>;
    /**
     * @description Get the value of the element of the specified key.
     * @param key - The specified key you want to get.
     * @example
     * const val = container.getElementByKey(1);
     */
    getElementByKey(key: K): V | undefined;
    union(other: OrderedMap<K, V>): number;
    [Symbol.iterator](): Generator<[
        K,
        V
    ], void, unknown>;
    // @ts-ignore
    eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;
}
export { OrderedMap };
export type { OrderedMapIterator, IteratorType, Container, ContainerIterator, TreeContainer };
"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

class TreeNode {
    constructor(t, e, s = 1) {
        this.i = undefined;
        this.h = undefined;
        this.o = undefined;
        this.u = t;
        this.l = e;
        this.p = s;
    }
    I() {
        let t = this;
        const e = t.o.o === t;
        if (e && t.p === 1) {
            t = t.h;
        } else if (t.i) {
            t = t.i;
            while (t.h) {
                t = t.h;
            }
        } else {
            if (e) {
                return t.o;
            }
            let s = t.o;
            while (s.i === t) {
                t = s;
                s = t.o;
            }
            t = s;
        }
        return t;
    }
    B() {
        let t = this;
        if (t.h) {
            t = t.h;
            while (t.i) {
                t = t.i;
            }
            return t;
        } else {
            let e = t.o;
            while (e.h === t) {
                t = e;
                e = t.o;
            }
            if (t.h !== e) {
                return e;
            } else return t;
        }
    }
    _() {
        const t = this.o;
        const e = this.h;
        const s = e.i;
        if (t.o === this) t.o = e; else if (t.i === this) t.i = e; else t.h = e;
        e.o = t;
        e.i = this;
        this.o = e;
        this.h = s;
        if (s) s.o = this;
        return e;
    }
    g() {
        const t = this.o;
        const e = this.i;
        const s = e.h;
        if (t.o === this) t.o = e; else if (t.i === this) t.i = e; else t.h = e;
        e.o = t;
        e.h = this;
        this.o = e;
        this.i = s;
        if (s) s.o = this;
        return e;
    }
}

class TreeNodeEnableIndex extends TreeNode {
    constructor() {
        super(...arguments);
        this.M = 1;
    }
    _() {
        const t = super._();
        this.O();
        t.O();
        return t;
    }
    g() {
        const t = super.g();
        this.O();
        t.O();
        return t;
    }
    O() {
        this.M = 1;
        if (this.i) {
            this.M += this.i.M;
        }
        if (this.h) {
            this.M += this.h.M;
        }
    }
}

class ContainerIterator {
    constructor(t = 0) {
        this.iteratorType = t;
    }
    equals(t) {
        return this.T === t.T;
    }
}

class Base {
    constructor() {
        this.m = 0;
    }
    get length() {
        return this.m;
    }
    size() {
        return this.m;
    }
    empty() {
        return this.m === 0;
    }
}

class Container extends Base {}

function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
}

class TreeContainer extends Container {
    constructor(t = function(t, e) {
        if (t < e) return -1;
        if (t > e) return 1;
        return 0;
    }, e = false) {
        super();
        this.v = undefined;
        this.A = t;
        this.enableIndex = e;
        this.N = e ? TreeNodeEnableIndex : TreeNode;
        this.C = new this.N;
    }
    R(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i < 0) {
                t = t.h;
            } else if (i > 0) {
                s = t;
                t = t.i;
            } else return t;
        }
        return s;
    }
    K(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i <= 0) {
                t = t.h;
            } else {
                s = t;
                t = t.i;
            }
        }
        return s;
    }
    L(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i < 0) {
                s = t;
                t = t.h;
            } else if (i > 0) {
                t = t.i;
            } else return t;
        }
        return s;
    }
    k(t, e) {
        let s = this.C;
        while (t) {
            const i = this.A(t.u, e);
            if (i < 0) {
                s = t;
                t = t.h;
            } else {
                t = t.i;
            }
        }
        return s;
    }
    P(t) {
        while (true) {
            const e = t.o;
            if (e === this.C) return;
            if (t.p === 1) {
                t.p = 0;
                return;
            }
            if (t === e.i) {
                const s = e.h;
                if (s.p === 1) {
                    s.p = 0;
                    e.p = 1;
                    if (e === this.v) {
                        this.v = e._();
                    } else e._();
                } else {
                    if (s.h && s.h.p === 1) {
                        s.p = e.p;
                        e.p = 0;
                        s.h.p = 0;
                        if (e === this.v) {
                            this.v = e._();
                        } else e._();
                        return;
                    } else if (s.i && s.i.p === 1) {
                        s.p = 1;
                        s.i.p = 0;
                        s.g();
                    } else {
                        s.p = 1;
                        t = e;
                    }
                }
            } else {
                const s = e.i;
                if (s.p === 1) {
                    s.p = 0;
                    e.p = 1;
                    if (e === this.v) {
                        this.v = e.g();
                    } else e.g();
                } else {
                    if (s.i && s.i.p === 1) {
                        s.p = e.p;
                        e.p = 0;
                        s.i.p = 0;
                        if (e === this.v) {
                            this.v = e.g();
                        } else e.g();
                        return;
                    } else if (s.h && s.h.p === 1) {
                        s.p = 1;
                        s.h.p = 0;
                        s._();
                    } else {
                        s.p = 1;
                        t = e;
                    }
                }
            }
        }
    }
    S(t) {
        if (this.m === 1) {
            this.clear();
            return;
        }
        let e = t;
        while (e.i || e.h) {
            if (e.h) {
                e = e.h;
                while (e.i) e = e.i;
            } else {
                e = e.i;
            }
            const s = t.u;
            t.u = e.u;
            e.u = s;
            const i = t.l;
            t.l = e.l;
            e.l = i;
            t = e;
        }
        if (this.C.i === e) {
            this.C.i = e.o;
        } else if (this.C.h === e) {
            this.C.h = e.o;
        }
        this.P(e);
        let s = e.o;
        if (e === s.i) {
            s.i = undefined;
        } else s.h = undefined;
        this.m -= 1;
        this.v.p = 0;
        if (this.enableIndex) {
            while (s !== this.C) {
                s.M -= 1;
                s = s.o;
            }
        }
    }
    U(t) {
        const e = typeof t === "number" ? t : undefined;
        const s = typeof t === "function" ? t : undefined;
        const i = typeof t === "undefined" ? [] : undefined;
        let r = 0;
        let n = this.v;
        const h = [];
        while (h.length || n) {
            if (n) {
                h.push(n);
                n = n.i;
            } else {
                n = h.pop();
                if (r === e) return n;
                i && i.push(n);
                s && s(n, r, this);
                r += 1;
                n = n.h;
            }
        }
        return i;
    }
    j(t) {
        while (true) {
            const e = t.o;
            if (e.p === 0) return;
            const s = e.o;
            if (e === s.i) {
                const i = s.h;
                if (i && i.p === 1) {
                    i.p = e.p = 0;
                    if (s === this.v) return;
                    s.p = 1;
                    t = s;
                    continue;
                } else if (t === e.h) {
                    t.p = 0;
                    if (t.i) {
                        t.i.o = e;
                    }
                    if (t.h) {
                        t.h.o = s;
                    }
                    e.h = t.i;
                    s.i = t.h;
                    t.i = e;
                    t.h = s;
                    if (s === this.v) {
                        this.v = t;
                        this.C.o = t;
                    } else {
                        const e = s.o;
                        if (e.i === s) {
                            e.i = t;
                        } else e.h = t;
                    }
                    t.o = s.o;
                    e.o = t;
                    s.o = t;
                    s.p = 1;
                } else {
                    e.p = 0;
                    if (s === this.v) {
                        this.v = s.g();
                    } else s.g();
                    s.p = 1;
                    return;
                }
            } else {
                const i = s.i;
                if (i && i.p === 1) {
                    i.p = e.p = 0;
                    if (s === this.v) return;
                    s.p = 1;
                    t = s;
                    continue;
                } else if (t === e.i) {
                    t.p = 0;
                    if (t.i) {
                        t.i.o = s;
                    }
                    if (t.h) {
                        t.h.o = e;
                    }
                    s.h = t.i;
                    e.i = t.h;
                    t.i = s;
                    t.h = e;
                    if (s === this.v) {
                        this.v = t;
                        this.C.o = t;
                    } else {
                        const e = s.o;
                        if (e.i === s) {
                            e.i = t;
                        } else e.h = t;
                    }
                    t.o = s.o;
                    e.o = t;
                    s.o = t;
                    s.p = 1;
                } else {
                    e.p = 0;
                    if (s === this.v) {
                        this.v = s._();
                    } else s._();
                    s.p = 1;
                    return;
                }
            }
            if (this.enableIndex) {
                e.O();
                s.O();
                t.O();
            }
            return;
        }
    }
    q(t, e, s) {
        if (this.v === undefined) {
            this.m += 1;
            this.v = new this.N(t, e, 0);
            this.v.o = this.C;
            this.C.o = this.C.i = this.C.h = this.v;
            return this.m;
        }
        let i;
        const r = this.C.i;
        const n = this.A(r.u, t);
        if (n === 0) {
            r.l = e;
            return this.m;
        } else if (n > 0) {
            r.i = new this.N(t, e);
            r.i.o = r;
            i = r.i;
            this.C.i = i;
        } else {
            const r = this.C.h;
            const n = this.A(r.u, t);
            if (n === 0) {
                r.l = e;
                return this.m;
            } else if (n < 0) {
                r.h = new this.N(t, e);
                r.h.o = r;
                i = r.h;
                this.C.h = i;
            } else {
                if (s !== undefined) {
                    const r = s.T;
                    if (r !== this.C) {
                        const s = this.A(r.u, t);
                        if (s === 0) {
                            r.l = e;
                            return this.m;
                        } else if (s > 0) {
                            const s = r.I();
                            const n = this.A(s.u, t);
                            if (n === 0) {
                                s.l = e;
                                return this.m;
                            } else if (n < 0) {
                                i = new this.N(t, e);
                                if (s.h === undefined) {
                                    s.h = i;
                                    i.o = s;
                                } else {
                                    r.i = i;
                                    i.o = r;
                                }
                            }
                        }
                    }
                }
                if (i === undefined) {
                    i = this.v;
                    while (true) {
                        const s = this.A(i.u, t);
                        if (s > 0) {
                            if (i.i === undefined) {
                                i.i = new this.N(t, e);
                                i.i.o = i;
                                i = i.i;
                                break;
                            }
                            i = i.i;
                        } else if (s < 0) {
                            if (i.h === undefined) {
                                i.h = new this.N(t, e);
                                i.h.o = i;
                                i = i.h;
                                break;
                            }
                            i = i.h;
                        } else {
                            i.l = e;
                            return this.m;
                        }
                    }
                }
            }
        }
        if (this.enableIndex) {
            let t = i.o;
            while (t !== this.C) {
                t.M += 1;
                t = t.o;
            }
        }
        this.j(i);
        this.m += 1;
        return this.m;
    }
    H(t, e) {
        while (t) {
            const s = this.A(t.u, e);
            if (s < 0) {
                t = t.h;
            } else if (s > 0) {
                t = t.i;
            } else return t;
        }
        return t || this.C;
    }
    clear() {
        this.m = 0;
        this.v = undefined;
        this.C.o = undefined;
        this.C.i = this.C.h = undefined;
    }
    updateKeyByIterator(t, e) {
        const s = t.T;
        if (s === this.C) {
            throwIteratorAccessError();
        }
        if (this.m === 1) {
            s.u = e;
            return true;
        }
        const i = s.B().u;
        if (s === this.C.i) {
            if (this.A(i, e) > 0) {
                s.u = e;
                return true;
            }
            return false;
        }
        const r = s.I().u;
        if (s === this.C.h) {
            if (this.A(r, e) < 0) {
                s.u = e;
                return true;
            }
            return false;
        }
        if (this.A(r, e) >= 0 || this.A(i, e) <= 0) return false;
        s.u = e;
        return true;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.m - 1) {
            throw new RangeError;
        }
        const e = this.U(t);
        this.S(e);
        return this.m;
    }
    eraseElementByKey(t) {
        if (this.m === 0) return false;
        const e = this.H(this.v, t);
        if (e === this.C) return false;
        this.S(e);
        return true;
    }
    eraseElementByIterator(t) {
        const e = t.T;
        if (e === this.C) {
            throwIteratorAccessError();
        }
        const s = e.h === undefined;
        const i = t.iteratorType === 0;
        if (i) {
            if (s) t.next();
        } else {
            if (!s || e.i === undefined) t.next();
        }
        this.S(e);
        return t;
    }
    getHeight() {
        if (this.m === 0) return 0;
        function traversal(t) {
            if (!t) return 0;
            return Math.max(traversal(t.i), traversal(t.h)) + 1;
        }
        return traversal(this.v);
    }
}

class TreeIterator extends ContainerIterator {
    constructor(t, e, s) {
        super(s);
        this.T = t;
        this.C = e;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.T === this.C.i) {
                    throwIteratorAccessError();
                }
                this.T = this.T.I();
                return this;
            };
            this.next = function() {
                if (this.T === this.C) {
                    throwIteratorAccessError();
                }
                this.T = this.T.B();
                return this;
            };
        } else {
            this.pre = function() {
                if (this.T === this.C.h) {
                    throwIteratorAccessError();
                }
                this.T = this.T.B();
                return this;
            };
            this.next = function() {
                if (this.T === this.C) {
                    throwIteratorAccessError();
                }
                this.T = this.T.I();
                return this;
            };
        }
    }
    get index() {
        let t = this.T;
        const e = this.C.o;
        if (t === this.C) {
            if (e) {
                return e.M - 1;
            }
            return 0;
        }
        let s = 0;
        if (t.i) {
            s += t.i.M;
        }
        while (t !== e) {
            const e = t.o;
            if (t === e.h) {
                s += 1;
                if (e.i) {
                    s += e.i.M;
                }
            }
            t = e;
        }
        return s;
    }
    isAccessible() {
        return this.T !== this.C;
    }
}

class OrderedMapIterator extends TreeIterator {
    constructor(t, e, s, i) {
        super(t, e, i);
        this.container = s;
    }
    get pointer() {
        if (this.T === this.C) {
            throwIteratorAccessError();
        }
        const t = this;
        return new Proxy([], {
            get(e, s) {
                if (s === "0") return t.T.u; else if (s === "1") return t.T.l;
                e[0] = t.T.u;
                e[1] = t.T.l;
                return e[s];
            },
            set(e, s, i) {
                if (s !== "1") {
                    throw new TypeError("prop must be 1");
                }
                t.T.l = i;
                return true;
            }
        });
    }
    copy() {
        return new OrderedMapIterator(this.T, this.C, this.container, this.iteratorType);
    }
}

class OrderedMap extends TreeContainer {
    constructor(t = [], e, s) {
        super(e, s);
        const i = this;
        t.forEach((function(t) {
            i.setElement(t[0], t[1]);
        }));
    }
    begin() {
        return new OrderedMapIterator(this.C.i || this.C, this.C, this);
    }
    end() {
        return new OrderedMapIterator(this.C, this.C, this);
    }
    rBegin() {
        return new OrderedMapIterator(this.C.h || this.C, this.C, this, 1);
    }
    rEnd() {
        return new OrderedMapIterator(this.C, this.C, this, 1);
    }
    front() {
        if (this.m === 0) return;
        const t = this.C.i;
        return [ t.u, t.l ];
    }
    back() {
        if (this.m === 0) return;
        const t = this.C.h;
        return [ t.u, t.l ];
    }
    lowerBound(t) {
        const e = this.R(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    upperBound(t) {
        const e = this.K(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    reverseLowerBound(t) {
        const e = this.L(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    reverseUpperBound(t) {
        const e = this.k(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    forEach(t) {
        this.U((function(e, s, i) {
            t([ e.u, e.l ], s, i);
        }));
    }
    setElement(t, e, s) {
        return this.q(t, e, s);
    }
    getElementByPos(t) {
        if (t < 0 || t > this.m - 1) {
            throw new RangeError;
        }
        const e = this.U(t);
        return [ e.u, e.l ];
    }
    find(t) {
        const e = this.H(this.v, t);
        return new OrderedMapIterator(e, this.C, this);
    }
    getElementByKey(t) {
        const e = this.H(this.v, t);
        return e.l;
    }
    union(t) {
        const e = this;
        t.forEach((function(t) {
            e.setElement(t[0], t[1]);
        }));
        return this.m;
    }
    * [Symbol.iterator]() {
        const t = this.m;
        const e = this.U();
        for (let s = 0; s < t; ++s) {
            const t = e[s];
            yield [ t.u, t.l ];
        }
    }
}

exports.OrderedMap = OrderedMap;
//# sourceMappingURL=index.js.map
{"version":3,"sources":["index.js","../../../.build-data/copied-source/src/container/TreeContainer/Base/TreeNode.ts","../../../.build-data/copied-source/src/container/ContainerBase/index.ts","../../../.build-data/copied-source/src/utils/throwError.ts","../../../.build-data/copied-source/src/container/TreeContainer/Base/index.ts","../../../.build-data/copied-source/src/container/TreeContainer/Base/TreeIterator.ts","../../../.build-data/copied-source/src/container/TreeContainer/OrderedMap.ts"],"names":["Object","defineProperty","exports","value","TreeNode","constructor","key","color","this","_left","undefined","_right","_parent","_key","_value","_color","_pre","preNode","isRootOrHeader","pre","_next","nextNode","_rotateLeft","PP","V","R","_rotateRight","F","K","TreeNodeEnableIndex","super","arguments","_subTreeSize","parent","_recount","ContainerIterator","iteratorType","equals","iter","_node","Base","_length","length","size","empty","Container","throwIteratorAccessError","RangeError","TreeContainer","cmp","x","y","enableIndex","_root","_cmp","_TreeNodeClass","_header","_lowerBound","curNode","resNode","cmpResult","_upperBound","_reverseLowerBound","_reverseUpperBound","_eraseNodeSelfBalance","parentNode","brother","_eraseNode","clear","swapNode","_inOrderTraversal","param","pos","callback","nodeList","index","stack","push","pop","_insertNodeSelfBalance","grandParent","uncle","GP","_set","hint","minNode","compareToMin","maxNode","compareToMax","iterNode","iterCmpRes","preCmpRes","_getTreeNodeByKey","updateKeyByIterator","node","nextKey","preKey","eraseElementByPos","eraseElementByKey","eraseElementByIterator","hasNoRight","isNormal","next","getHeight","traversal","Math","max","TreeIterator","header","root","isAccessible","OrderedMapIterator","container","pointer","self","Proxy","get","target","prop","set","_","newValue","TypeError","copy","OrderedMap","forEach","el","setElement","begin","end","rBegin","rEnd","front","back","lowerBound","upperBound","reverseLowerBound","reverseUpperBound","map","getElementByPos","find","getElementByKey","union","other","Symbol","iterator","i"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass TreeNode {\n  constructor(key, value, color = 1 /* TreeNodeColor.RED */) {\n    this._left = undefined;\n    this._right = undefined;\n    this._parent = undefined;\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  _pre() {\n    let preNode = this;\n    const isRootOrHeader = preNode._parent._parent === preNode;\n    if (isRootOrHeader && preNode._color === 1 /* TreeNodeColor.RED */) {\n      preNode = preNode._right;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent;\n      }\n      let pre = preNode._parent;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  }\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  _next() {\n    let nextNode = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      let pre = nextNode._parent;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  }\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const PP = this._parent;\n    const V = this._right;\n    const R = V._left;\n    if (PP._parent === this) PP._parent = V;else if (PP._left === this) PP._left = V;else PP._right = V;\n    V._parent = PP;\n    V._left = this;\n    this._parent = V;\n    this._right = R;\n    if (R) R._parent = this;\n    return V;\n  }\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const PP = this._parent;\n    const F = this._left;\n    const K = F._right;\n    if (PP._parent === this) PP._parent = F;else if (PP._left === this) PP._left = F;else PP._right = F;\n    F._parent = PP;\n    F._right = this;\n    this._parent = F;\n    this._left = K;\n    if (K) K._parent = this;\n    return F;\n  }\n}\nclass TreeNodeEnableIndex extends TreeNode {\n  constructor() {\n    super(...arguments);\n    this._subTreeSize = 1;\n  }\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const parent = super._rotateLeft();\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const parent = super._rotateRight();\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  _recount() {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += this._left._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += this._right._subTreeSize;\n    }\n  }\n}\n\nclass ContainerIterator {\n  /**\n   * @internal\n   */\n  constructor(iteratorType = 0 /* IteratorType.NORMAL */) {\n    this.iteratorType = iteratorType;\n  }\n  /**\n   * @param iter - The other iterator you want to compare.\n   * @returns Whether this equals to obj.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  equals(iter) {\n    return this._node === iter._node;\n  }\n}\nclass Base {\n  constructor() {\n    /**\n     * @description Container's size.\n     * @internal\n     */\n    this._length = 0;\n  }\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.length); // 2\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.size()); // 2\n   */\n  size() {\n    return this._length;\n  }\n  /**\n   * @returns Whether the container is empty.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  empty() {\n    return this._length === 0;\n  }\n}\nclass Container extends Base {}\n\n/**\n * @description Throw an iterator access error.\n * @internal\n */\nfunction throwIteratorAccessError() {\n  throw new RangeError('Iterator access denied!');\n}\n\nclass TreeContainer extends Container {\n  /**\n   * @internal\n   */\n  constructor(cmp = function (x, y) {\n    if (x < y) return -1;\n    if (x > y) return 1;\n    return 0;\n  }, enableIndex = false) {\n    super();\n    /**\n     * @internal\n     */\n    this._root = undefined;\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  _lowerBound(curNode, key) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  _upperBound(curNode, key) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  _reverseLowerBound(curNode, key) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  _reverseUpperBound(curNode, key) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  _eraseNodeSelfBalance(curNode) {\n    while (true) {\n      const parentNode = curNode._parent;\n      if (parentNode === this._header) return;\n      if (curNode._color === 1 /* TreeNodeColor.RED */) {\n        curNode._color = 0 /* TreeNodeColor.BLACK */;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right;\n        if (brother._color === 1 /* TreeNodeColor.RED */) {\n          brother._color = 0 /* TreeNodeColor.BLACK */;\n          parentNode._color = 1 /* TreeNodeColor.RED */;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = parentNode._color;\n            parentNode._color = 0 /* TreeNodeColor.BLACK */;\n            brother._right._color = 0 /* TreeNodeColor.BLACK */;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            brother._left._color = 0 /* TreeNodeColor.BLACK */;\n            brother._rotateRight();\n          } else {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left;\n        if (brother._color === 1 /* TreeNodeColor.RED */) {\n          brother._color = 0 /* TreeNodeColor.BLACK */;\n          parentNode._color = 1 /* TreeNodeColor.RED */;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = parentNode._color;\n            parentNode._color = 0 /* TreeNodeColor.BLACK */;\n            brother._left._color = 0 /* TreeNodeColor.BLACK */;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            brother._right._color = 0 /* TreeNodeColor.BLACK */;\n            brother._rotateLeft();\n          } else {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _eraseNode(curNode) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root._color = 0 /* TreeNodeColor.BLACK */;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent;\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _inOrderTraversal(param) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? [] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop();\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  _insertNodeSelfBalance(curNode) {\n    while (true) {\n      const parentNode = curNode._parent;\n      if (parentNode._color === 0 /* TreeNodeColor.BLACK */) return;\n      const grandParent = parentNode._parent;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n          uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) return;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n        } else {\n          parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n          uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) return;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n        } else {\n          parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        parentNode._recount();\n        grandParent._recount();\n        curNode._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  _set(key, value, hint) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left;\n    const compareToMin = this._cmp(minNode._key, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right;\n      const compareToMax = this._cmp(maxNode._key, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */if (iterCmpRes > 0) {\n                const preNode = iterNode._pre();\n                const preCmpRes = this._cmp(preNode._key, key);\n                if (preCmpRes === 0) {\n                  preNode._value = value;\n                  return this._length;\n                } else if (preCmpRes < 0) {\n                  curNode = new this._TreeNodeClass(key, value);\n                  if (preNode._right === undefined) {\n                    preNode._right = curNode;\n                    curNode._parent = preNode;\n                  } else {\n                    iterNode._left = curNode;\n                    curNode._parent = iterNode;\n                  }\n                }\n              }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  _getTreeNodeByKey(curNode, key) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter, key) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (this._cmp(preKey, key) >= 0 || this._cmp(nextKey, key) <= 0) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos) {\n    if (pos < 0 || pos > this._length - 1) {\n      throw new RangeError();\n    }\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode) {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n}\n\nclass TreeIterator extends ContainerIterator {\n  /**\n   * @internal\n   */\n  constructor(node, header, iteratorType) {\n    super(iteratorType);\n    this._node = node;\n    this._header = header;\n    if (this.iteratorType === 0 /* IteratorType.NORMAL */) {\n      this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n  }\n  /**\n   * @description Get the sequential index of the iterator in the tree container.<br/>\n   *              <strong>Note:</strong>\n   *              This function only takes effect when the specified tree container `enableIndex = true`.\n   * @returns The index subscript of the node in the tree.\n   * @example\n   * const st = new OrderedSet([1, 2, 3], true);\n   * console.log(st.begin().next().index);  // 1\n   */\n  get index() {\n    let _node = this._node;\n    const root = this._header._parent;\n    if (_node === this._header) {\n      if (root) {\n        return root._subTreeSize - 1;\n      }\n      return 0;\n    }\n    let index = 0;\n    if (_node._left) {\n      index += _node._left._subTreeSize;\n    }\n    while (_node !== root) {\n      const _parent = _node._parent;\n      if (_node === _parent._right) {\n        index += 1;\n        if (_parent._left) {\n          index += _parent._left._subTreeSize;\n        }\n      }\n      _node = _parent;\n    }\n    return index;\n  }\n  isAccessible() {\n    return this._node !== this._header;\n  }\n}\n\nclass OrderedMapIterator extends TreeIterator {\n  constructor(node, header, container, iteratorType) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy([], {\n      get(target, prop) {\n        if (prop === '0') return self._node._key;else if (prop === '1') return self._node._value;\n        target[0] = self._node._key;\n        target[1] = self._node._value;\n        return target[prop];\n      },\n      set(_, prop, newValue) {\n        if (prop !== '1') {\n          throw new TypeError('prop must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new OrderedMapIterator(this._node, this._header, this.container, this.iteratorType);\n  }\n}\nclass OrderedMap extends TreeContainer {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  constructor(container = [], cmp, enableIndex) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new OrderedMapIterator(this._header._left || this._header, this._header, this);\n  }\n  end() {\n    return new OrderedMapIterator(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedMapIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n  }\n\n  rEnd() {\n    return new OrderedMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n  }\n\n  front() {\n    if (this._length === 0) return;\n    const minNode = this._header._left;\n    return [minNode._key, minNode._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    const maxNode = this._header._right;\n    return [maxNode._key, maxNode._value];\n  }\n  lowerBound(key) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  }\n  upperBound(key) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  }\n  reverseLowerBound(key) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  }\n  reverseUpperBound(key) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  }\n  forEach(callback) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback([node._key, node._value], index, map);\n    });\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  setElement(key, value, hint) {\n    return this._set(key, value, hint);\n  }\n  getElementByPos(pos) {\n    if (pos < 0 || pos > this._length - 1) {\n      throw new RangeError();\n    }\n    const node = this._inOrderTraversal(pos);\n    return [node._key, node._value];\n  }\n  find(key) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator(curNode, this._header, this);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  }\n  union(other) {\n    const self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  }\n  *[Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      const node = nodeList[i];\n      yield [node._key, node._value];\n    }\n  }\n}\n\nexports.OrderedMap = OrderedMap;\n//# sourceMappingURL=index.js.map\n","export const enum TreeNodeColor {\n  RED = 1,\n  BLACK = 0\n}\n\nexport class TreeNode<K, V> {\n  _color: TreeNodeColor;\n  _key: K | undefined;\n  _value: V | undefined;\n  _left: TreeNode<K, V> | undefined = undefined;\n  _right: TreeNode<K, V> | undefined = undefined;\n  _parent: TreeNode<K, V> | undefined = undefined;\n  constructor(\n    key?: K,\n    value?: V,\n    color: TreeNodeColor = TreeNodeColor.RED\n  ) {\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  _pre() {\n    let preNode: TreeNode<K, V> = this;\n    const isRootOrHeader = preNode._parent!._parent === preNode;\n    if (isRootOrHeader && preNode._color === TreeNodeColor.RED) {\n      preNode = preNode._right!;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent!;\n      }\n      let pre = preNode._parent!;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent!;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  }\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  _next() {\n    let nextNode: TreeNode<K, V> = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      let pre = nextNode._parent!;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent!;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  }\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const PP = this._parent!;\n    const V = this._right!;\n    const R = V._left;\n\n    if (PP._parent === this) PP._parent = V;\n    else if (PP._left === this) PP._left = V;\n    else PP._right = V;\n\n    V._parent = PP;\n    V._left = this;\n\n    this._parent = V;\n    this._right = R;\n\n    if (R) R._parent = this;\n\n    return V;\n  }\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const PP = this._parent!;\n    const F = this._left!;\n    const K = F._right;\n\n    if (PP._parent === this) PP._parent = F;\n    else if (PP._left === this) PP._left = F;\n    else PP._right = F;\n\n    F._parent = PP;\n    F._right = this;\n\n    this._parent = F;\n    this._left = K;\n\n    if (K) K._parent = this;\n\n    return F;\n  }\n}\n\nexport class TreeNodeEnableIndex<K, V> extends TreeNode<K, V> {\n  _subTreeSize = 1;\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const parent = super._rotateLeft() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const parent = super._rotateRight() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  _recount() {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += (this._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += (this._right as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n  }\n}\n","/**\n * @description The iterator type including `NORMAL` and `REVERSE`.\n */\nexport const enum IteratorType {\n  NORMAL = 0,\n  REVERSE = 1\n}\n\nexport abstract class ContainerIterator<T> {\n  /**\n   * @description The container pointed to by the iterator.\n   */\n  abstract readonly container: Container<T>;\n  /**\n   * @internal\n   */\n  abstract _node: unknown;\n  /**\n   * @description Iterator's type.\n   * @example\n   * console.log(container.end().iteratorType === IteratorType.NORMAL);  // true\n   */\n  readonly iteratorType: IteratorType;\n  /**\n   * @internal\n   */\n  protected constructor(iteratorType = IteratorType.NORMAL) {\n    this.iteratorType = iteratorType;\n  }\n  /**\n   * @param iter - The other iterator you want to compare.\n   * @returns Whether this equals to obj.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  equals(iter: ContainerIterator<T>) {\n    return this._node === iter._node;\n  }\n  /**\n   * @description Pointers to element.\n   * @returns The value of the pointer's element.\n   * @example\n   * const val = container.begin().pointer;\n   */\n  abstract get pointer(): T;\n  /**\n   * @description Set pointer's value (some containers are unavailable).\n   * @param newValue - The new value you want to set.\n   * @example\n   * (<LinkList<number>>container).begin().pointer = 1;\n   */\n  abstract set pointer(newValue: T);\n  /**\n   * @description Move `this` iterator to pre.\n   * @returns The iterator's self.\n   * @example\n   * const iter = container.find(1);  // container = [0, 1]\n   * const pre = iter.pre();\n   * console.log(pre === iter);  // true\n   * console.log(pre.equals(iter));  // true\n   * console.log(pre.pointer, iter.pointer); // 0, 0\n   */\n  abstract pre(): this;\n  /**\n   * @description Move `this` iterator to next.\n   * @returns The iterator's self.\n   * @example\n   * const iter = container.find(1);  // container = [1, 2]\n   * const next = iter.next();\n   * console.log(next === iter);  // true\n   * console.log(next.equals(iter));  // true\n   * console.log(next.pointer, iter.pointer); // 2, 2\n   */\n  abstract next(): this;\n  /**\n   * @description Get a copy of itself.\n   * @returns The copy of self.\n   * @example\n   * const iter = container.find(1);  // container = [1, 2]\n   * const next = iter.copy().next();\n   * console.log(next === iter);  // false\n   * console.log(next.equals(iter));  // false\n   * console.log(next.pointer, iter.pointer); // 2, 1\n   */\n  abstract copy(): ContainerIterator<T>;\n  abstract isAccessible(): boolean;\n}\n\nexport abstract class Base {\n  /**\n   * @description Container's size.\n   * @internal\n   */\n  protected _length = 0;\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.length); // 2\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.size()); // 2\n   */\n  size() {\n    return this._length;\n  }\n  /**\n   * @returns Whether the container is empty.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  empty() {\n    return this._length === 0;\n  }\n  /**\n   * @description Clear the container.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  abstract clear(): void;\n}\n\nexport abstract class Container<T> extends Base {\n  /**\n   * @returns Iterator pointing to the beginning element.\n   * @example\n   * const begin = container.begin();\n   * const end = container.end();\n   * for (const it = begin; !it.equals(end); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract begin(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the super end like c++.\n   * @example\n   * const begin = container.begin();\n   * const end = container.end();\n   * for (const it = begin; !it.equals(end); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract end(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the end element.\n   * @example\n   * const rBegin = container.rBegin();\n   * const rEnd = container.rEnd();\n   * for (const it = rBegin; !it.equals(rEnd); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract rBegin(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the super begin like c++.\n   * @example\n   * const rBegin = container.rBegin();\n   * const rEnd = container.rEnd();\n   * for (const it = rBegin; !it.equals(rEnd); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract rEnd(): ContainerIterator<T>;\n  /**\n   * @returns The first element of the container.\n   */\n  abstract front(): T | undefined;\n  /**\n   * @returns The last element of the container.\n   */\n  abstract back(): T | undefined;\n  /**\n   * @param element - The element you want to find.\n   * @returns An iterator pointing to the element if found, or super end if not found.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  abstract find(element: T): ContainerIterator<T>;\n  /**\n   * @description Iterate over all elements in the container.\n   * @param callback - Callback function like Array.forEach.\n   * @example\n   * container.forEach((element, index) => console.log(element, index));\n   */\n  abstract forEach(callback: (element: T, index: number, container: Container<T>) => void): void;\n  /**\n   * @description Gets the value of the element at the specified position.\n   * @example\n   * const val = container.getElementByPos(-1); // throw a RangeError\n   */\n  abstract getElementByPos(pos: number): T;\n  /**\n   * @description Removes the element at the specified position.\n   * @param pos - The element's position you want to remove.\n   * @returns The container length after erasing.\n   * @example\n   * container.eraseElementByPos(-1); // throw a RangeError\n   */\n  abstract eraseElementByPos(pos: number): number;\n  /**\n   * @description Removes element by iterator and move `iter` to next.\n   * @param iter - The iterator you want to erase.\n   * @returns The next iterator.\n   * @example\n   * container.eraseElementByIterator(container.begin());\n   * container.eraseElementByIterator(container.end()); // throw a RangeError\n   */\n  abstract eraseElementByIterator(\n    iter: ContainerIterator<T>\n  ): ContainerIterator<T>;\n  /**\n   * @description Using for `for...of` syntax like Array.\n   * @example\n   * for (const element of container) {\n   *   console.log(element);\n   * }\n   */\n  abstract [Symbol.iterator](): Generator<T, void>;\n}\n\n/**\n * @description The initial data type passed in when initializing the container.\n */\nexport type initContainer<T> = {\n  size?: number | (() => number);\n  length?: number;\n  forEach: (callback: (el: T) => void) => void;\n}\n","/**\n * @description Throw an iterator access error.\n * @internal\n */\nexport function throwIteratorAccessError() {\n  throw new RangeError('Iterator access denied!');\n}\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  enableIndex: boolean;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent as TreeNodeEnableIndex<K, V>;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n  }\n  protected _inOrderTraversal(): TreeNode<K, V>[];\n  protected _inOrderTraversal(pos: number): TreeNode<K, V>;\n  protected _inOrderTraversal(\n    callback: (node: TreeNode<K, V>, index: number, map: this) => void\n  ): TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    param?: number | ((node: TreeNode<K, V>, index: number, map: this) => void)\n  ) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? <TreeNode<K, V>[]>[] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack: TreeNode<K, V>[] = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop()!;\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        (<TreeNodeEnableIndex<K, V>>parentNode)._recount();\n        (<TreeNodeEnableIndex<K, V>>grandParent)._recount();\n        (<TreeNodeEnableIndex<K, V>>curNode)._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _set(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, TreeNodeColor.BLACK);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return this._length;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent as TreeNodeEnableIndex<K, V>;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  protected _getTreeNodeByKey(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key!;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (\n      this._cmp(preKey, key) >= 0 ||\n      this._cmp(nextKey, key) <= 0\n    ) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode: TreeNode<K, V> | undefined): number {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n","import { TreeNode } from './TreeNode';\nimport type { TreeNodeEnableIndex } from './TreeNode';\nimport { ContainerIterator, IteratorType } from '@/container/ContainerBase';\nimport TreeContainer from '@/container/TreeContainer/Base/index';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeIterator<K, V> extends ContainerIterator<K | [K, V]> {\n  abstract readonly container: TreeContainer<K, V>;\n  /**\n   * @internal\n   */\n  _node: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(iteratorType);\n    this._node = node;\n    this._header = header;\n    if (this.iteratorType === IteratorType.NORMAL) {\n      this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n  }\n  /**\n   * @description Get the sequential index of the iterator in the tree container.<br/>\n   *              <strong>Note:</strong>\n   *              This function only takes effect when the specified tree container `enableIndex = true`.\n   * @returns The index subscript of the node in the tree.\n   * @example\n   * const st = new OrderedSet([1, 2, 3], true);\n   * console.log(st.begin().next().index);  // 1\n   */\n  get index() {\n    let _node = this._node as TreeNodeEnableIndex<K, V>;\n    const root = this._header._parent as TreeNodeEnableIndex<K, V>;\n    if (_node === this._header) {\n      if (root) {\n        return root._subTreeSize - 1;\n      }\n      return 0;\n    }\n    let index = 0;\n    if (_node._left) {\n      index += (_node._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    while (_node !== root) {\n      const _parent = _node._parent as TreeNodeEnableIndex<K, V>;\n      if (_node === _parent._right) {\n        index += 1;\n        if (_parent._left) {\n          index += (_parent._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n        }\n      }\n      _node = _parent;\n    }\n    return index;\n  }\n  isAccessible() {\n    return this._node !== this._header;\n  }\n  // @ts-ignore\n  pre(): this;\n  // @ts-ignore\n  next(): this;\n}\n\nexport default TreeIterator;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedMapIterator<K, V> extends TreeIterator<K, V> {\n  container: OrderedMap<K, V>;\n  constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    container: OrderedMap<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(target, prop: '0' | '1') {\n        if (prop === '0') return self._node._key!;\n        else if (prop === '1') return self._node._value!;\n        target[0] = self._node._key!;\n        target[1] = self._node._value!;\n        return target[prop];\n      },\n      set(_, prop: '1', newValue: V) {\n        if (prop !== '1') {\n          throw new TypeError('prop must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new OrderedMapIterator<K, V>(\n      this._node,\n      this._header,\n      this.container,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: OrderedMapIterator<K, V>): boolean;\n}\n\nexport type { OrderedMapIterator };\n\nclass OrderedMap<K, V> extends TreeContainer<K, V> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<[K, V]> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new OrderedMapIterator<K, V>(this._header._left || this._header, this._header, this);\n  }\n  end() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedMapIterator<K, V>(\n      this._header._right || this._header,\n      this._header,\n      this,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    const minNode = this._header._left!;\n    return <[K, V]>[minNode._key, minNode._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    const maxNode = this._header._right!;\n    return <[K, V]>[maxNode._key, maxNode._value];\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  forEach(callback: (element: [K, V], index: number, map: OrderedMap<K, V>) => void) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback(<[K, V]>[node._key, node._value], index, map);\n    });\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>) {\n    return this._set(key, value, hint);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    return <[K, V]>[node._key, node._value];\n  }\n  find(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator<K, V>(curNode, this._header, this);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  }\n  union(other: OrderedMap<K, V>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  }\n  * [Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      const node = nodeList[i];\n      yield <[K, V]>[node._key, node._value];\n    }\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;\n}\n\nexport default OrderedMap;\n"]}/**
 * @description The iterator type including `NORMAL` and `REVERSE`.
 */
declare const enum IteratorType {
    NORMAL = 0,
    REVERSE = 1
}
declare abstract class ContainerIterator<T> {
    /**
     * @description The container pointed to by the iterator.
     */
    abstract readonly container: Container<T>;
    /**
     * @description Iterator's type.
     * @example
     * console.log(container.end().iteratorType === IteratorType.NORMAL);  // true
     */
    readonly iteratorType: IteratorType;
    /**
     * @param iter - The other iterator you want to compare.
     * @returns Whether this equals to obj.
     * @example
     * container.find(1).equals(container.end());
     */
    equals(iter: ContainerIterator<T>): boolean;
    /**
     * @description Pointers to element.
     * @returns The value of the pointer's element.
     * @example
     * const val = container.begin().pointer;
     */
    abstract get pointer(): T;
    /**
     * @description Set pointer's value (some containers are unavailable).
     * @param newValue - The new value you want to set.
     * @example
     * (<LinkList<number>>container).begin().pointer = 1;
     */
    abstract set pointer(newValue: T);
    /**
     * @description Move `this` iterator to pre.
     * @returns The iterator's self.
     * @example
     * const iter = container.find(1);  // container = [0, 1]
     * const pre = iter.pre();
     * console.log(pre === iter);  // true
     * console.log(pre.equals(iter));  // true
     * console.log(pre.pointer, iter.pointer); // 0, 0
     */
    abstract pre(): this;
    /**
     * @description Move `this` iterator to next.
     * @returns The iterator's self.
     * @example
     * const iter = container.find(1);  // container = [1, 2]
     * const next = iter.next();
     * console.log(next === iter);  // true
     * console.log(next.equals(iter));  // true
     * console.log(next.pointer, iter.pointer); // 2, 2
     */
    abstract next(): this;
    /**
     * @description Get a copy of itself.
     * @returns The copy of self.
     * @example
     * const iter = container.find(1);  // container = [1, 2]
     * const next = iter.copy().next();
     * console.log(next === iter);  // false
     * console.log(next.equals(iter));  // false
     * console.log(next.pointer, iter.pointer); // 2, 1
     */
    abstract copy(): ContainerIterator<T>;
    abstract isAccessible(): boolean;
}
declare abstract class Base {
    /**
     * @returns The size of the container.
     * @example
     * const container = new Vector([1, 2]);
     * console.log(container.length); // 2
     */
    get length(): number;
    /**
     * @returns The size of the container.
     * @example
     * const container = new Vector([1, 2]);
     * console.log(container.size()); // 2
     */
    size(): number;
    /**
     * @returns Whether the container is empty.
     * @example
     * container.clear();
     * console.log(container.empty());  // true
     */
    empty(): boolean;
    /**
     * @description Clear the container.
     * @example
     * container.clear();
     * console.log(container.empty());  // true
     */
    abstract clear(): void;
}
declare abstract class Container<T> extends Base {
    /**
     * @returns Iterator pointing to the beginning element.
     * @example
     * const begin = container.begin();
     * const end = container.end();
     * for (const it = begin; !it.equals(end); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract begin(): ContainerIterator<T>;
    /**
     * @returns Iterator pointing to the super end like c++.
     * @example
     * const begin = container.begin();
     * const end = container.end();
     * for (const it = begin; !it.equals(end); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract end(): ContainerIterator<T>;
    /**
     * @returns Iterator pointing to the end element.
     * @example
     * const rBegin = container.rBegin();
     * const rEnd = container.rEnd();
     * for (const it = rBegin; !it.equals(rEnd); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract rBegin(): ContainerIterator<T>;
    /**
     * @returns Iterator pointing to the super begin like c++.
     * @example
     * const rBegin = container.rBegin();
     * const rEnd = container.rEnd();
     * for (const it = rBegin; !it.equals(rEnd); it.next()) {
     *   doSomething(it.pointer);
     * }
     */
    abstract rEnd(): ContainerIterator<T>;
    /**
     * @returns The first element of the container.
     */
    abstract front(): T | undefined;
    /**
     * @returns The last element of the container.
     */
    abstract back(): T | undefined;
    /**
     * @param element - The element you want to find.
     * @returns An iterator pointing to the element if found, or super end if not found.
     * @example
     * container.find(1).equals(container.end());
     */
    abstract find(element: T): ContainerIterator<T>;
    /**
     * @description Iterate over all elements in the container.
     * @param callback - Callback function like Array.forEach.
     * @example
     * container.forEach((element, index) => console.log(element, index));
     */
    abstract forEach(callback: (element: T, index: number, container: Container<T>) => void): void;
    /**
     * @description Gets the value of the element at the specified position.
     * @example
     * const val = container.getElementByPos(-1); // throw a RangeError
     */
    abstract getElementByPos(pos: number): T;
    /**
     * @description Removes the element at the specified position.
     * @param pos - The element's position you want to remove.
     * @returns The container length after erasing.
     * @example
     * container.eraseElementByPos(-1); // throw a RangeError
     */
    abstract eraseElementByPos(pos: number): number;
    /**
     * @description Removes element by iterator and move `iter` to next.
     * @param iter - The iterator you want to erase.
     * @returns The next iterator.
     * @example
     * container.eraseElementByIterator(container.begin());
     * container.eraseElementByIterator(container.end()); // throw a RangeError
     */
    abstract eraseElementByIterator(iter: ContainerIterator<T>): ContainerIterator<T>;
    /**
     * @description Using for `for...of` syntax like Array.
     * @example
     * for (const element of container) {
     *   console.log(element);
     * }
     */
    abstract [Symbol.iterator](): Generator<T, void>;
}
/**
 * @description The initial data type passed in when initializing the container.
 */
type initContainer<T> = {
    size?: number | (() => number);
    length?: number;
    forEach: (callback: (el: T) => void) => void;
};
declare abstract class TreeIterator<K, V> extends ContainerIterator<K | [
    K,
    V
]> {
    abstract readonly container: TreeContainer<K, V>;
    /**
     * @description Get the sequential index of the iterator in the tree container.<br/>
     *              <strong>Note:</strong>
     *              This function only takes effect when the specified tree container `enableIndex = true`.
     * @returns The index subscript of the node in the tree.
     * @example
     * const st = new OrderedSet([1, 2, 3], true);
     * console.log(st.begin().next().index);  // 1
     */
    get index(): number;
    isAccessible(): boolean;
    // @ts-ignore
    pre(): this;
    // @ts-ignore
    next(): this;
}
declare const enum TreeNodeColor {
    RED = 1,
    BLACK = 0
}
declare class TreeNode<K, V> {
    _color: TreeNodeColor;
    _key: K | undefined;
    _value: V | undefined;
    _left: TreeNode<K, V> | undefined;
    _right: TreeNode<K, V> | undefined;
    _parent: TreeNode<K, V> | undefined;
    constructor(key?: K, value?: V, color?: TreeNodeColor);
    /**
     * @description Get the pre node.
     * @returns TreeNode about the pre node.
     */
    _pre(): TreeNode<K, V>;
    /**
     * @description Get the next node.
     * @returns TreeNode about the next node.
     */
    _next(): TreeNode<K, V>;
    /**
     * @description Rotate left.
     * @returns TreeNode about moved to original position after rotation.
     */
    _rotateLeft(): TreeNode<K, V>;
    /**
     * @description Rotate right.
     * @returns TreeNode about moved to original position after rotation.
     */
    _rotateRight(): TreeNode<K, V>;
}
declare abstract class TreeContainer<K, V> extends Container<K | [
    K,
    V
]> {
    enableIndex: boolean;
    protected _inOrderTraversal(): TreeNode<K, V>[];
    protected _inOrderTraversal(pos: number): TreeNode<K, V>;
    protected _inOrderTraversal(callback: (node: TreeNode<K, V>, index: number, map: this) => void): TreeNode<K, V>;
    clear(): void;
    /**
     * @description Update node's key by iterator.
     * @param iter - The iterator you want to change.
     * @param key - The key you want to update.
     * @returns Whether the modification is successful.
     * @example
     * const st = new orderedSet([1, 2, 5]);
     * const iter = st.find(2);
     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]
     */
    updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean;
    eraseElementByPos(pos: number): number;
    /**
     * @description Remove the element of the specified key.
     * @param key - The key you want to remove.
     * @returns Whether erase successfully.
     */
    eraseElementByKey(key: K): boolean;
    eraseElementByIterator(iter: TreeIterator<K, V>): TreeIterator<K, V>;
    /**
     * @description Get the height of the tree.
     * @returns Number about the height of the RB-tree.
     */
    getHeight(): number;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element less than the given key.
     */
    abstract reverseUpperBound(key: K): TreeIterator<K, V>;
    /**
     * @description Union the other tree to self.
     * @param other - The other tree container you want to merge.
     * @returns The size of the tree after union.
     */
    abstract union(other: TreeContainer<K, V>): number;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element not greater than the given key.
     */
    abstract reverseLowerBound(key: K): TreeIterator<K, V>;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element not less than the given key.
     */
    abstract lowerBound(key: K): TreeIterator<K, V>;
    /**
     * @param key - The given key you want to compare.
     * @returns An iterator to the first element greater than the given key.
     */
    abstract upperBound(key: K): TreeIterator<K, V>;
}
declare class OrderedMapIterator<K, V> extends TreeIterator<K, V> {
    container: OrderedMap<K, V>;
    constructor(node: TreeNode<K, V>, header: TreeNode<K, V>, container: OrderedMap<K, V>, iteratorType?: IteratorType);
    get pointer(): [
        K,
        V
    ];
    copy(): OrderedMapIterator<K, V>;
    // @ts-ignore
    equals(iter: OrderedMapIterator<K, V>): boolean;
}
declare class OrderedMap<K, V> extends TreeContainer<K, V> {
    /**
     * @param container - The initialization container.
     * @param cmp - The compare function.
     * @param enableIndex - Whether to enable iterator indexing function.
     * @example
     * new OrderedMap();
     * new OrderedMap([[0, 1], [2, 1]]);
     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);
     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);
     */
    constructor(container?: initContainer<[
        K,
        V
    ]>, cmp?: (x: K, y: K) => number, enableIndex?: boolean);
    begin(): OrderedMapIterator<K, V>;
    end(): OrderedMapIterator<K, V>;
    rBegin(): OrderedMapIterator<K, V>;
    rEnd(): OrderedMapIterator<K, V>;
    front(): [
        K,
        V
    ] | undefined;
    back(): [
        K,
        V
    ] | undefined;
    lowerBound(key: K): OrderedMapIterator<K, V>;
    upperBound(key: K): OrderedMapIterator<K, V>;
    reverseLowerBound(key: K): OrderedMapIterator<K, V>;
    reverseUpperBound(key: K): OrderedMapIterator<K, V>;
    forEach(callback: (element: [
        K,
        V
    ], index: number, map: OrderedMap<K, V>) => void): void;
    /**
     * @description Insert a key-value pair or set value by the given key.
     * @param key - The key want to insert.
     * @param value - The value want to set.
     * @param hint - You can give an iterator hint to improve insertion efficiency.
     * @return The size of container after setting.
     * @example
     * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);
     * const iter = mp.begin();
     * mp.setElement(1, 0);
     * mp.setElement(3, 0, iter);  // give a hint will be faster.
     */
    setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>): number;
    getElementByPos(pos: number): [
        K,
        V
    ];
    find(key: K): OrderedMapIterator<K, V>;
    /**
     * @description Get the value of the element of the specified key.
     * @param key - The specified key you want to get.
     * @example
     * const val = container.getElementByKey(1);
     */
    getElementByKey(key: K): V | undefined;
    union(other: OrderedMap<K, V>): number;
    [Symbol.iterator](): Generator<[
        K,
        V
    ], void, unknown>;
    // @ts-ignore
    eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;
}
export { OrderedMap };
export type { OrderedMapIterator, IteratorType, Container, ContainerIterator, TreeContainer };
var extendStatics = function(e, r) {
    extendStatics = Object.setPrototypeOf || {
        __proto__: []
    } instanceof Array && function(e, r) {
        e.__proto__ = r;
    } || function(e, r) {
        for (var t in r) if (Object.prototype.hasOwnProperty.call(r, t)) e[t] = r[t];
    };
    return extendStatics(e, r);
};

function __extends(e, r) {
    if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    extendStatics(e, r);
    function __() {
        this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __);
}

function __generator(e, r) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1) throw s[1];
            return s[1];
        },
        trys: [],
        ops: []
    }, i, n, s, h;
    return h = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
    }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
        return this;
    }), h;
    function verb(e) {
        return function(r) {
            return step([ e, r ]);
        };
    }
    function step(a) {
        if (i) throw new TypeError("Generator is already executing.");
        while (h && (h = 0, a[0] && (t = 0)), t) try {
            if (i = 1, n && (s = a[0] & 2 ? n["return"] : a[0] ? n["throw"] || ((s = n["return"]) && s.call(n), 
            0) : n.next) && !(s = s.call(n, a[1])).done) return s;
            if (n = 0, s) a = [ a[0] & 2, s.value ];
            switch (a[0]) {
              case 0:
              case 1:
                s = a;
                break;

              case 4:
                t.label++;
                return {
                    value: a[1],
                    done: false
                };

              case 5:
                t.label++;
                n = a[1];
                a = [ 0 ];
                continue;

              case 7:
                a = t.ops.pop();
                t.trys.pop();
                continue;

              default:
                if (!(s = t.trys, s = s.length > 0 && s[s.length - 1]) && (a[0] === 6 || a[0] === 2)) {
                    t = 0;
                    continue;
                }
                if (a[0] === 3 && (!s || a[1] > s[0] && a[1] < s[3])) {
                    t.label = a[1];
                    break;
                }
                if (a[0] === 6 && t.label < s[1]) {
                    t.label = s[1];
                    s = a;
                    break;
                }
                if (s && t.label < s[2]) {
                    t.label = s[2];
                    t.ops.push(a);
                    break;
                }
                if (s[2]) t.ops.pop();
                t.trys.pop();
                continue;
            }
            a = r.call(e, t);
        } catch (e) {
            a = [ 6, e ];
            n = 0;
        } finally {
            i = s = 0;
        }
        if (a[0] & 5) throw a[1];
        return {
            value: a[0] ? a[1] : void 0,
            done: true
        };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function(e, r, t) {
    var i = new Error(t);
    return i.name = "SuppressedError", i.error = e, i.suppressed = r, i;
};

var TreeNode = function() {
    function TreeNode(e, r, t) {
        if (t === void 0) {
            t = 1;
        }
        this.t = undefined;
        this.i = undefined;
        this.h = undefined;
        this.u = e;
        this.o = r;
        this.l = t;
    }
    TreeNode.prototype.v = function() {
        var e = this;
        var r = e.h.h === e;
        if (r && e.l === 1) {
            e = e.i;
        } else if (e.t) {
            e = e.t;
            while (e.i) {
                e = e.i;
            }
        } else {
            if (r) {
                return e.h;
            }
            var t = e.h;
            while (t.t === e) {
                e = t;
                t = e.h;
            }
            e = t;
        }
        return e;
    };
    TreeNode.prototype.p = function() {
        var e = this;
        if (e.i) {
            e = e.i;
            while (e.t) {
                e = e.t;
            }
            return e;
        } else {
            var r = e.h;
            while (r.i === e) {
                e = r;
                r = e.h;
            }
            if (e.i !== r) {
                return r;
            } else return e;
        }
    };
    TreeNode.prototype.T = function() {
        var e = this.h;
        var r = this.i;
        var t = r.t;
        if (e.h === this) e.h = r; else if (e.t === this) e.t = r; else e.i = r;
        r.h = e;
        r.t = this;
        this.h = r;
        this.i = t;
        if (t) t.h = this;
        return r;
    };
    TreeNode.prototype.I = function() {
        var e = this.h;
        var r = this.t;
        var t = r.i;
        if (e.h === this) e.h = r; else if (e.t === this) e.t = r; else e.i = r;
        r.h = e;
        r.i = this;
        this.h = r;
        this.t = t;
        if (t) t.h = this;
        return r;
    };
    return TreeNode;
}();

var TreeNodeEnableIndex = function(e) {
    __extends(TreeNodeEnableIndex, e);
    function TreeNodeEnableIndex() {
        var r = e !== null && e.apply(this, arguments) || this;
        r.O = 1;
        return r;
    }
    TreeNodeEnableIndex.prototype.T = function() {
        var r = e.prototype.T.call(this);
        this.M();
        r.M();
        return r;
    };
    TreeNodeEnableIndex.prototype.I = function() {
        var r = e.prototype.I.call(this);
        this.M();
        r.M();
        return r;
    };
    TreeNodeEnableIndex.prototype.M = function() {
        this.O = 1;
        if (this.t) {
            this.O += this.t.O;
        }
        if (this.i) {
            this.O += this.i.O;
        }
    };
    return TreeNodeEnableIndex;
}(TreeNode);

var ContainerIterator = function() {
    function ContainerIterator(e) {
        if (e === void 0) {
            e = 0;
        }
        this.iteratorType = e;
    }
    ContainerIterator.prototype.equals = function(e) {
        return this.C === e.C;
    };
    return ContainerIterator;
}();

var Base = function() {
    function Base() {
        this._ = 0;
    }
    Object.defineProperty(Base.prototype, "length", {
        get: function() {
            return this._;
        },
        enumerable: false,
        configurable: true
    });
    Base.prototype.size = function() {
        return this._;
    };
    Base.prototype.empty = function() {
        return this._ === 0;
    };
    return Base;
}();

var Container = function(e) {
    __extends(Container, e);
    function Container() {
        return e !== null && e.apply(this, arguments) || this;
    }
    return Container;
}(Base);

function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
}

var TreeContainer = function(e) {
    __extends(TreeContainer, e);
    function TreeContainer(r, t) {
        if (r === void 0) {
            r = function(e, r) {
                if (e < r) return -1;
                if (e > r) return 1;
                return 0;
            };
        }
        if (t === void 0) {
            t = false;
        }
        var i = e.call(this) || this;
        i.N = undefined;
        i.g = r;
        i.enableIndex = t;
        i.S = t ? TreeNodeEnableIndex : TreeNode;
        i.A = new i.S;
        return i;
    }
    TreeContainer.prototype.m = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                e = e.i;
            } else if (i > 0) {
                t = e;
                e = e.t;
            } else return e;
        }
        return t;
    };
    TreeContainer.prototype.B = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i <= 0) {
                e = e.i;
            } else {
                t = e;
                e = e.t;
            }
        }
        return t;
    };
    TreeContainer.prototype.j = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                t = e;
                e = e.i;
            } else if (i > 0) {
                e = e.t;
            } else return e;
        }
        return t;
    };
    TreeContainer.prototype.k = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                t = e;
                e = e.i;
            } else {
                e = e.t;
            }
        }
        return t;
    };
    TreeContainer.prototype.R = function(e) {
        while (true) {
            var r = e.h;
            if (r === this.A) return;
            if (e.l === 1) {
                e.l = 0;
                return;
            }
            if (e === r.t) {
                var t = r.i;
                if (t.l === 1) {
                    t.l = 0;
                    r.l = 1;
                    if (r === this.N) {
                        this.N = r.T();
                    } else r.T();
                } else {
                    if (t.i && t.i.l === 1) {
                        t.l = r.l;
                        r.l = 0;
                        t.i.l = 0;
                        if (r === this.N) {
                            this.N = r.T();
                        } else r.T();
                        return;
                    } else if (t.t && t.t.l === 1) {
                        t.l = 1;
                        t.t.l = 0;
                        t.I();
                    } else {
                        t.l = 1;
                        e = r;
                    }
                }
            } else {
                var t = r.t;
                if (t.l === 1) {
                    t.l = 0;
                    r.l = 1;
                    if (r === this.N) {
                        this.N = r.I();
                    } else r.I();
                } else {
                    if (t.t && t.t.l === 1) {
                        t.l = r.l;
                        r.l = 0;
                        t.t.l = 0;
                        if (r === this.N) {
                            this.N = r.I();
                        } else r.I();
                        return;
                    } else if (t.i && t.i.l === 1) {
                        t.l = 1;
                        t.i.l = 0;
                        t.T();
                    } else {
                        t.l = 1;
                        e = r;
                    }
                }
            }
        }
    };
    TreeContainer.prototype.G = function(e) {
        if (this._ === 1) {
            this.clear();
            return;
        }
        var r = e;
        while (r.t || r.i) {
            if (r.i) {
                r = r.i;
                while (r.t) r = r.t;
            } else {
                r = r.t;
            }
            var t = e.u;
            e.u = r.u;
            r.u = t;
            var i = e.o;
            e.o = r.o;
            r.o = i;
            e = r;
        }
        if (this.A.t === r) {
            this.A.t = r.h;
        } else if (this.A.i === r) {
            this.A.i = r.h;
        }
        this.R(r);
        var n = r.h;
        if (r === n.t) {
            n.t = undefined;
        } else n.i = undefined;
        this._ -= 1;
        this.N.l = 0;
        if (this.enableIndex) {
            while (n !== this.A) {
                n.O -= 1;
                n = n.h;
            }
        }
    };
    TreeContainer.prototype.P = function(e) {
        var r = typeof e === "number" ? e : undefined;
        var t = typeof e === "function" ? e : undefined;
        var i = typeof e === "undefined" ? [] : undefined;
        var n = 0;
        var s = this.N;
        var h = [];
        while (h.length || s) {
            if (s) {
                h.push(s);
                s = s.t;
            } else {
                s = h.pop();
                if (n === r) return s;
                i && i.push(s);
                t && t(s, n, this);
                n += 1;
                s = s.i;
            }
        }
        return i;
    };
    TreeContainer.prototype.q = function(e) {
        while (true) {
            var r = e.h;
            if (r.l === 0) return;
            var t = r.h;
            if (r === t.t) {
                var i = t.i;
                if (i && i.l === 1) {
                    i.l = r.l = 0;
                    if (t === this.N) return;
                    t.l = 1;
                    e = t;
                    continue;
                } else if (e === r.i) {
                    e.l = 0;
                    if (e.t) {
                        e.t.h = r;
                    }
                    if (e.i) {
                        e.i.h = t;
                    }
                    r.i = e.t;
                    t.t = e.i;
                    e.t = r;
                    e.i = t;
                    if (t === this.N) {
                        this.N = e;
                        this.A.h = e;
                    } else {
                        var n = t.h;
                        if (n.t === t) {
                            n.t = e;
                        } else n.i = e;
                    }
                    e.h = t.h;
                    r.h = e;
                    t.h = e;
                    t.l = 1;
                } else {
                    r.l = 0;
                    if (t === this.N) {
                        this.N = t.I();
                    } else t.I();
                    t.l = 1;
                    return;
                }
            } else {
                var i = t.t;
                if (i && i.l === 1) {
                    i.l = r.l = 0;
                    if (t === this.N) return;
                    t.l = 1;
                    e = t;
                    continue;
                } else if (e === r.t) {
                    e.l = 0;
                    if (e.t) {
                        e.t.h = t;
                    }
                    if (e.i) {
                        e.i.h = r;
                    }
                    t.i = e.t;
                    r.t = e.i;
                    e.t = t;
                    e.i = r;
                    if (t === this.N) {
                        this.N = e;
                        this.A.h = e;
                    } else {
                        var n = t.h;
                        if (n.t === t) {
                            n.t = e;
                        } else n.i = e;
                    }
                    e.h = t.h;
                    r.h = e;
                    t.h = e;
                    t.l = 1;
                } else {
                    r.l = 0;
                    if (t === this.N) {
                        this.N = t.T();
                    } else t.T();
                    t.l = 1;
                    return;
                }
            }
            if (this.enableIndex) {
                r.M();
                t.M();
                e.M();
            }
            return;
        }
    };
    TreeContainer.prototype.D = function(e, r, t) {
        if (this.N === undefined) {
            this._ += 1;
            this.N = new this.S(e, r, 0);
            this.N.h = this.A;
            this.A.h = this.A.t = this.A.i = this.N;
            return this._;
        }
        var i;
        var n = this.A.t;
        var s = this.g(n.u, e);
        if (s === 0) {
            n.o = r;
            return this._;
        } else if (s > 0) {
            n.t = new this.S(e, r);
            n.t.h = n;
            i = n.t;
            this.A.t = i;
        } else {
            var h = this.A.i;
            var a = this.g(h.u, e);
            if (a === 0) {
                h.o = r;
                return this._;
            } else if (a < 0) {
                h.i = new this.S(e, r);
                h.i.h = h;
                i = h.i;
                this.A.i = i;
            } else {
                if (t !== undefined) {
                    var u = t.C;
                    if (u !== this.A) {
                        var f = this.g(u.u, e);
                        if (f === 0) {
                            u.o = r;
                            return this._;
                        } else if (f > 0) {
                            var o = u.v();
                            var d = this.g(o.u, e);
                            if (d === 0) {
                                o.o = r;
                                return this._;
                            } else if (d < 0) {
                                i = new this.S(e, r);
                                if (o.i === undefined) {
                                    o.i = i;
                                    i.h = o;
                                } else {
                                    u.t = i;
                                    i.h = u;
                                }
                            }
                        }
                    }
                }
                if (i === undefined) {
                    i = this.N;
                    while (true) {
                        var c = this.g(i.u, e);
                        if (c > 0) {
                            if (i.t === undefined) {
                                i.t = new this.S(e, r);
                                i.t.h = i;
                                i = i.t;
                                break;
                            }
                            i = i.t;
                        } else if (c < 0) {
                            if (i.i === undefined) {
                                i.i = new this.S(e, r);
                                i.i.h = i;
                                i = i.i;
                                break;
                            }
                            i = i.i;
                        } else {
                            i.o = r;
                            return this._;
                        }
                    }
                }
            }
        }
        if (this.enableIndex) {
            var l = i.h;
            while (l !== this.A) {
                l.O += 1;
                l = l.h;
            }
        }
        this.q(i);
        this._ += 1;
        return this._;
    };
    TreeContainer.prototype.F = function(e, r) {
        while (e) {
            var t = this.g(e.u, r);
            if (t < 0) {
                e = e.i;
            } else if (t > 0) {
                e = e.t;
            } else return e;
        }
        return e || this.A;
    };
    TreeContainer.prototype.clear = function() {
        this._ = 0;
        this.N = undefined;
        this.A.h = undefined;
        this.A.t = this.A.i = undefined;
    };
    TreeContainer.prototype.updateKeyByIterator = function(e, r) {
        var t = e.C;
        if (t === this.A) {
            throwIteratorAccessError();
        }
        if (this._ === 1) {
            t.u = r;
            return true;
        }
        var i = t.p().u;
        if (t === this.A.t) {
            if (this.g(i, r) > 0) {
                t.u = r;
                return true;
            }
            return false;
        }
        var n = t.v().u;
        if (t === this.A.i) {
            if (this.g(n, r) < 0) {
                t.u = r;
                return true;
            }
            return false;
        }
        if (this.g(n, r) >= 0 || this.g(i, r) <= 0) return false;
        t.u = r;
        return true;
    };
    TreeContainer.prototype.eraseElementByPos = function(e) {
        if (e < 0 || e > this._ - 1) {
            throw new RangeError;
        }
        var r = this.P(e);
        this.G(r);
        return this._;
    };
    TreeContainer.prototype.eraseElementByKey = function(e) {
        if (this._ === 0) return false;
        var r = this.F(this.N, e);
        if (r === this.A) return false;
        this.G(r);
        return true;
    };
    TreeContainer.prototype.eraseElementByIterator = function(e) {
        var r = e.C;
        if (r === this.A) {
            throwIteratorAccessError();
        }
        var t = r.i === undefined;
        var i = e.iteratorType === 0;
        if (i) {
            if (t) e.next();
        } else {
            if (!t || r.t === undefined) e.next();
        }
        this.G(r);
        return e;
    };
    TreeContainer.prototype.getHeight = function() {
        if (this._ === 0) return 0;
        function traversal(e) {
            if (!e) return 0;
            return Math.max(traversal(e.t), traversal(e.i)) + 1;
        }
        return traversal(this.N);
    };
    return TreeContainer;
}(Container);

var TreeIterator = function(e) {
    __extends(TreeIterator, e);
    function TreeIterator(r, t, i) {
        var n = e.call(this, i) || this;
        n.C = r;
        n.A = t;
        if (n.iteratorType === 0) {
            n.pre = function() {
                if (this.C === this.A.t) {
                    throwIteratorAccessError();
                }
                this.C = this.C.v();
                return this;
            };
            n.next = function() {
                if (this.C === this.A) {
                    throwIteratorAccessError();
                }
                this.C = this.C.p();
                return this;
            };
        } else {
            n.pre = function() {
                if (this.C === this.A.i) {
                    throwIteratorAccessError();
                }
                this.C = this.C.p();
                return this;
            };
            n.next = function() {
                if (this.C === this.A) {
                    throwIteratorAccessError();
                }
                this.C = this.C.v();
                return this;
            };
        }
        return n;
    }
    Object.defineProperty(TreeIterator.prototype, "index", {
        get: function() {
            var e = this.C;
            var r = this.A.h;
            if (e === this.A) {
                if (r) {
                    return r.O - 1;
                }
                return 0;
            }
            var t = 0;
            if (e.t) {
                t += e.t.O;
            }
            while (e !== r) {
                var i = e.h;
                if (e === i.i) {
                    t += 1;
                    if (i.t) {
                        t += i.t.O;
                    }
                }
                e = i;
            }
            return t;
        },
        enumerable: false,
        configurable: true
    });
    TreeIterator.prototype.isAccessible = function() {
        return this.C !== this.A;
    };
    return TreeIterator;
}(ContainerIterator);

var OrderedMapIterator = function(e) {
    __extends(OrderedMapIterator, e);
    function OrderedMapIterator(r, t, i, n) {
        var s = e.call(this, r, t, n) || this;
        s.container = i;
        return s;
    }
    Object.defineProperty(OrderedMapIterator.prototype, "pointer", {
        get: function() {
            if (this.C === this.A) {
                throwIteratorAccessError();
            }
            var e = this;
            return new Proxy([], {
                get: function(r, t) {
                    if (t === "0") return e.C.u; else if (t === "1") return e.C.o;
                    r[0] = e.C.u;
                    r[1] = e.C.o;
                    return r[t];
                },
                set: function(r, t, i) {
                    if (t !== "1") {
                        throw new TypeError("prop must be 1");
                    }
                    e.C.o = i;
                    return true;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    OrderedMapIterator.prototype.copy = function() {
        return new OrderedMapIterator(this.C, this.A, this.container, this.iteratorType);
    };
    return OrderedMapIterator;
}(TreeIterator);

var OrderedMap = function(e) {
    __extends(OrderedMap, e);
    function OrderedMap(r, t, i) {
        if (r === void 0) {
            r = [];
        }
        var n = e.call(this, t, i) || this;
        var s = n;
        r.forEach((function(e) {
            s.setElement(e[0], e[1]);
        }));
        return n;
    }
    OrderedMap.prototype.begin = function() {
        return new OrderedMapIterator(this.A.t || this.A, this.A, this);
    };
    OrderedMap.prototype.end = function() {
        return new OrderedMapIterator(this.A, this.A, this);
    };
    OrderedMap.prototype.rBegin = function() {
        return new OrderedMapIterator(this.A.i || this.A, this.A, this, 1);
    };
    OrderedMap.prototype.rEnd = function() {
        return new OrderedMapIterator(this.A, this.A, this, 1);
    };
    OrderedMap.prototype.front = function() {
        if (this._ === 0) return;
        var e = this.A.t;
        return [ e.u, e.o ];
    };
    OrderedMap.prototype.back = function() {
        if (this._ === 0) return;
        var e = this.A.i;
        return [ e.u, e.o ];
    };
    OrderedMap.prototype.lowerBound = function(e) {
        var r = this.m(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.upperBound = function(e) {
        var r = this.B(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.reverseLowerBound = function(e) {
        var r = this.j(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.reverseUpperBound = function(e) {
        var r = this.k(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.forEach = function(e) {
        this.P((function(r, t, i) {
            e([ r.u, r.o ], t, i);
        }));
    };
    OrderedMap.prototype.setElement = function(e, r, t) {
        return this.D(e, r, t);
    };
    OrderedMap.prototype.getElementByPos = function(e) {
        if (e < 0 || e > this._ - 1) {
            throw new RangeError;
        }
        var r = this.P(e);
        return [ r.u, r.o ];
    };
    OrderedMap.prototype.find = function(e) {
        var r = this.F(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.getElementByKey = function(e) {
        var r = this.F(this.N, e);
        return r.o;
    };
    OrderedMap.prototype.union = function(e) {
        var r = this;
        e.forEach((function(e) {
            r.setElement(e[0], e[1]);
        }));
        return this._;
    };
    OrderedMap.prototype[Symbol.iterator] = function() {
        var e, r, t, i;
        return __generator(this, (function(n) {
            switch (n.label) {
              case 0:
                e = this._;
                r = this.P();
                t = 0;
                n.label = 1;

              case 1:
                if (!(t < e)) return [ 3, 4 ];
                i = r[t];
                return [ 4, [ i.u, i.o ] ];

              case 2:
                n.sent();
                n.label = 3;

              case 3:
                ++t;
                return [ 3, 1 ];

              case 4:
                return [ 2 ];
            }
        }));
    };
    return OrderedMap;
}(TreeContainer);

export { OrderedMap };
//# sourceMappingURL=index.js.map
{"version":3,"sources":["../../../../../node_modules/tslib/tslib.es6.js","index.js","../../../.build-data/copied-source/src/container/TreeContainer/Base/TreeNode.ts","../../../.build-data/copied-source/src/container/ContainerBase/index.ts","../../../.build-data/copied-source/src/utils/throwError.ts","../../../.build-data/copied-source/src/container/TreeContainer/Base/index.ts","../../../.build-data/copied-source/src/container/TreeContainer/Base/TreeIterator.ts","../../../.build-data/copied-source/src/container/TreeContainer/OrderedMap.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__generator","thisArg","body","_","label","sent","t","trys","ops","f","y","g","next","verb","throw","return","Symbol","iterator","n","v","step","op","done","value","pop","length","push","e","SuppressedError","error","suppressed","message","Error","name","TreeNode","key","color","_left","undefined","_right","_parent","_key","_value","_color","_pre","preNode","isRootOrHeader","pre","_next","nextNode","_rotateLeft","PP","V","R","_rotateRight","F","K","TreeNodeEnableIndex","_super","_this","apply","arguments","_subTreeSize","parent","_recount","ContainerIterator","iteratorType","equals","iter","_node","Base","_length","defineProperty","get","enumerable","configurable","size","empty","Container","throwIteratorAccessError","RangeError","TreeContainer","cmp","enableIndex","x","_root","_cmp","_TreeNodeClass","_header","_lowerBound","curNode","resNode","cmpResult","_upperBound","_reverseLowerBound","_reverseUpperBound","_eraseNodeSelfBalance","parentNode","brother","_eraseNode","clear","swapNode","_inOrderTraversal","param","pos","callback","nodeList","index","stack","_insertNodeSelfBalance","grandParent","uncle","GP","_set","hint","minNode","compareToMin","maxNode","compareToMax","iterNode","iterCmpRes","preCmpRes","parent_1","_getTreeNodeByKey","updateKeyByIterator","node","nextKey","preKey","eraseElementByPos","eraseElementByKey","eraseElementByIterator","hasNoRight","isNormal","getHeight","traversal","Math","max","TreeIterator","header","root","isAccessible","OrderedMapIterator","container","self","Proxy","target","prop","set","newValue","copy","OrderedMap","forEach","el","setElement","begin","end","rBegin","rEnd","front","back","lowerBound","upperBound","reverseLowerBound","reverseUpperBound","map","getElementByPos","find","getElementByKey","union","other","i","_a"],"mappings":"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","file":"index.js","sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends,\r\n    __assign,\r\n    __rest,\r\n    __decorate,\r\n    __param,\r\n    __metadata,\r\n    __awaiter,\r\n    __generator,\r\n    __createBinding,\r\n    __exportStar,\r\n    __values,\r\n    __read,\r\n    __spread,\r\n    __spreadArrays,\r\n    __spreadArray,\r\n    __await,\r\n    __asyncGenerator,\r\n    __asyncDelegator,\r\n    __asyncValues,\r\n    __makeTemplateObject,\r\n    __importStar,\r\n    __importDefault,\r\n    __classPrivateFieldGet,\r\n    __classPrivateFieldSet,\r\n    __classPrivateFieldIn,\r\n    __addDisposableResource,\r\n    __disposeResources,\r\n};\r\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nvar TreeNode = /** @class */function () {\n  function TreeNode(key, value, color) {\n    if (color === void 0) {\n      color = 1 /* TreeNodeColor.RED */;\n    }\n    this._left = undefined;\n    this._right = undefined;\n    this._parent = undefined;\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  TreeNode.prototype._pre = function () {\n    var preNode = this;\n    var isRootOrHeader = preNode._parent._parent === preNode;\n    if (isRootOrHeader && preNode._color === 1 /* TreeNodeColor.RED */) {\n      preNode = preNode._right;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent;\n      }\n      var pre = preNode._parent;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  };\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  TreeNode.prototype._next = function () {\n    var nextNode = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      var pre = nextNode._parent;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  };\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNode.prototype._rotateLeft = function () {\n    var PP = this._parent;\n    var V = this._right;\n    var R = V._left;\n    if (PP._parent === this) PP._parent = V;else if (PP._left === this) PP._left = V;else PP._right = V;\n    V._parent = PP;\n    V._left = this;\n    this._parent = V;\n    this._right = R;\n    if (R) R._parent = this;\n    return V;\n  };\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNode.prototype._rotateRight = function () {\n    var PP = this._parent;\n    var F = this._left;\n    var K = F._right;\n    if (PP._parent === this) PP._parent = F;else if (PP._left === this) PP._left = F;else PP._right = F;\n    F._parent = PP;\n    F._right = this;\n    this._parent = F;\n    this._left = K;\n    if (K) K._parent = this;\n    return F;\n  };\n  return TreeNode;\n}();\nvar TreeNodeEnableIndex = /** @class */function (_super) {\n  __extends(TreeNodeEnableIndex, _super);\n  function TreeNodeEnableIndex() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._subTreeSize = 1;\n    return _this;\n  }\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNodeEnableIndex.prototype._rotateLeft = function () {\n    var parent = _super.prototype._rotateLeft.call(this);\n    this._recount();\n    parent._recount();\n    return parent;\n  };\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  TreeNodeEnableIndex.prototype._rotateRight = function () {\n    var parent = _super.prototype._rotateRight.call(this);\n    this._recount();\n    parent._recount();\n    return parent;\n  };\n  TreeNodeEnableIndex.prototype._recount = function () {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += this._left._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += this._right._subTreeSize;\n    }\n  };\n  return TreeNodeEnableIndex;\n}(TreeNode);\n\nvar ContainerIterator = /** @class */function () {\n  /**\n   * @internal\n   */\n  function ContainerIterator(iteratorType) {\n    if (iteratorType === void 0) {\n      iteratorType = 0 /* IteratorType.NORMAL */;\n    }\n    this.iteratorType = iteratorType;\n  }\n  /**\n   * @param iter - The other iterator you want to compare.\n   * @returns Whether this equals to obj.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  ContainerIterator.prototype.equals = function (iter) {\n    return this._node === iter._node;\n  };\n  return ContainerIterator;\n}();\nvar Base = /** @class */function () {\n  function Base() {\n    /**\n     * @description Container's size.\n     * @internal\n     */\n    this._length = 0;\n  }\n  Object.defineProperty(Base.prototype, \"length\", {\n    /**\n     * @returns The size of the container.\n     * @example\n     * const container = new Vector([1, 2]);\n     * console.log(container.length); // 2\n     */\n    get: function () {\n      return this._length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.size()); // 2\n   */\n  Base.prototype.size = function () {\n    return this._length;\n  };\n  /**\n   * @returns Whether the container is empty.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  Base.prototype.empty = function () {\n    return this._length === 0;\n  };\n  return Base;\n}();\nvar Container = /** @class */function (_super) {\n  __extends(Container, _super);\n  function Container() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return Container;\n}(Base);\n\n/**\n * @description Throw an iterator access error.\n * @internal\n */\nfunction throwIteratorAccessError() {\n  throw new RangeError('Iterator access denied!');\n}\n\nvar TreeContainer = /** @class */function (_super) {\n  __extends(TreeContainer, _super);\n  /**\n   * @internal\n   */\n  function TreeContainer(cmp, enableIndex) {\n    if (cmp === void 0) {\n      cmp = function (x, y) {\n        if (x < y) return -1;\n        if (x > y) return 1;\n        return 0;\n      };\n    }\n    if (enableIndex === void 0) {\n      enableIndex = false;\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * @internal\n     */\n    _this._root = undefined;\n    _this._cmp = cmp;\n    _this.enableIndex = enableIndex;\n    _this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    _this._header = new _this._TreeNodeClass();\n    return _this;\n  }\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._lowerBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._upperBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n    var resNode = this._header;\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n    while (true) {\n      var parentNode = curNode._parent;\n      if (parentNode === this._header) return;\n      if (curNode._color === 1 /* TreeNodeColor.RED */) {\n        curNode._color = 0 /* TreeNodeColor.BLACK */;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        var brother = parentNode._right;\n        if (brother._color === 1 /* TreeNodeColor.RED */) {\n          brother._color = 0 /* TreeNodeColor.BLACK */;\n          parentNode._color = 1 /* TreeNodeColor.RED */;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = parentNode._color;\n            parentNode._color = 0 /* TreeNodeColor.BLACK */;\n            brother._right._color = 0 /* TreeNodeColor.BLACK */;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            brother._left._color = 0 /* TreeNodeColor.BLACK */;\n            brother._rotateRight();\n          } else {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        var brother = parentNode._left;\n        if (brother._color === 1 /* TreeNodeColor.RED */) {\n          brother._color = 0 /* TreeNodeColor.BLACK */;\n          parentNode._color = 1 /* TreeNodeColor.RED */;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = parentNode._color;\n            parentNode._color = 0 /* TreeNodeColor.BLACK */;\n            brother._left._color = 0 /* TreeNodeColor.BLACK */;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            brother._right._color = 0 /* TreeNodeColor.BLACK */;\n            brother._rotateLeft();\n          } else {\n            brother._color = 1 /* TreeNodeColor.RED */;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._eraseNode = function (curNode) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    var swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left;\n      }\n      var key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      var value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    var _parent = swapNode._parent;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root._color = 0 /* TreeNodeColor.BLACK */;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent;\n      }\n    }\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._inOrderTraversal = function (param) {\n    var pos = typeof param === 'number' ? param : undefined;\n    var callback = typeof param === 'function' ? param : undefined;\n    var nodeList = typeof param === 'undefined' ? [] : undefined;\n    var index = 0;\n    var curNode = this._root;\n    var stack = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop();\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n    while (true) {\n      var parentNode = curNode._parent;\n      if (parentNode._color === 0 /* TreeNodeColor.BLACK */) return;\n      var grandParent = parentNode._parent;\n      if (parentNode === grandParent._left) {\n        var uncle = grandParent._right;\n        if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n          uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) return;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            var GP = grandParent._parent;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n        } else {\n          parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          return;\n        }\n      } else {\n        var uncle = grandParent._left;\n        if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n          uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) return;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            var GP = grandParent._parent;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n        } else {\n          parentNode._color = 0 /* TreeNodeColor.BLACK */;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = 1 /* TreeNodeColor.RED */;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        parentNode._recount();\n        grandParent._recount();\n        curNode._recount();\n      }\n      return;\n    }\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._set = function (key, value, hint) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    var curNode;\n    var minNode = this._header._left;\n    var compareToMin = this._cmp(minNode._key, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      var maxNode = this._header._right;\n      var compareToMax = this._cmp(maxNode._key, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          var iterNode = hint._node;\n          if (iterNode !== this._header) {\n            var iterCmpRes = this._cmp(iterNode._key, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */if (iterCmpRes > 0) {\n                var preNode = iterNode._pre();\n                var preCmpRes = this._cmp(preNode._key, key);\n                if (preCmpRes === 0) {\n                  preNode._value = value;\n                  return this._length;\n                } else if (preCmpRes < 0) {\n                  curNode = new this._TreeNodeClass(key, value);\n                  if (preNode._right === undefined) {\n                    preNode._right = curNode;\n                    curNode._parent = preNode;\n                  } else {\n                    iterNode._left = curNode;\n                    curNode._parent = iterNode;\n                  }\n                }\n              }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      var parent_1 = curNode._parent;\n      while (parent_1 !== this._header) {\n        parent_1._subTreeSize += 1;\n        parent_1 = parent_1._parent;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  };\n  /**\n   * @internal\n   */\n  TreeContainer.prototype._getTreeNodeByKey = function (curNode, key) {\n    while (curNode) {\n      var cmpResult = this._cmp(curNode._key, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  };\n  TreeContainer.prototype.clear = function () {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  };\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n    var node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    var nextKey = node._next()._key;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    var preKey = node._pre()._key;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (this._cmp(preKey, key) >= 0 || this._cmp(nextKey, key) <= 0) return false;\n    node._key = key;\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByPos = function (pos) {\n    if (pos < 0 || pos > this._length - 1) {\n      throw new RangeError();\n    }\n    var node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  };\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  TreeContainer.prototype.eraseElementByKey = function (key) {\n    if (this._length === 0) return false;\n    var curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByIterator = function (iter) {\n    var node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    var hasNoRight = node._right === undefined;\n    var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  };\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  TreeContainer.prototype.getHeight = function () {\n    if (this._length === 0) return 0;\n    function traversal(curNode) {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  };\n  return TreeContainer;\n}(Container);\n\nvar TreeIterator = /** @class */function (_super) {\n  __extends(TreeIterator, _super);\n  /**\n   * @internal\n   */\n  function TreeIterator(node, header, iteratorType) {\n    var _this = _super.call(this, iteratorType) || this;\n    _this._node = node;\n    _this._header = header;\n    if (_this.iteratorType === 0 /* IteratorType.NORMAL */) {\n      _this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n      _this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      _this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n      _this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n    return _this;\n  }\n  Object.defineProperty(TreeIterator.prototype, \"index\", {\n    /**\n     * @description Get the sequential index of the iterator in the tree container.<br/>\n     *              <strong>Note:</strong>\n     *              This function only takes effect when the specified tree container `enableIndex = true`.\n     * @returns The index subscript of the node in the tree.\n     * @example\n     * const st = new OrderedSet([1, 2, 3], true);\n     * console.log(st.begin().next().index);  // 1\n     */\n    get: function () {\n      var _node = this._node;\n      var root = this._header._parent;\n      if (_node === this._header) {\n        if (root) {\n          return root._subTreeSize - 1;\n        }\n        return 0;\n      }\n      var index = 0;\n      if (_node._left) {\n        index += _node._left._subTreeSize;\n      }\n      while (_node !== root) {\n        var _parent = _node._parent;\n        if (_node === _parent._right) {\n          index += 1;\n          if (_parent._left) {\n            index += _parent._left._subTreeSize;\n          }\n        }\n        _node = _parent;\n      }\n      return index;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TreeIterator.prototype.isAccessible = function () {\n    return this._node !== this._header;\n  };\n  return TreeIterator;\n}(ContainerIterator);\n\nvar OrderedMapIterator = /** @class */function (_super) {\n  __extends(OrderedMapIterator, _super);\n  function OrderedMapIterator(node, header, container, iteratorType) {\n    var _this = _super.call(this, node, header, iteratorType) || this;\n    _this.container = container;\n    return _this;\n  }\n  Object.defineProperty(OrderedMapIterator.prototype, \"pointer\", {\n    get: function () {\n      if (this._node === this._header) {\n        throwIteratorAccessError();\n      }\n      var self = this;\n      return new Proxy([], {\n        get: function (target, prop) {\n          if (prop === '0') return self._node._key;else if (prop === '1') return self._node._value;\n          target[0] = self._node._key;\n          target[1] = self._node._value;\n          return target[prop];\n        },\n        set: function (_, prop, newValue) {\n          if (prop !== '1') {\n            throw new TypeError('prop must be 1');\n          }\n          self._node._value = newValue;\n          return true;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  OrderedMapIterator.prototype.copy = function () {\n    return new OrderedMapIterator(this._node, this._header, this.container, this.iteratorType);\n  };\n  return OrderedMapIterator;\n}(TreeIterator);\nvar OrderedMap = /** @class */function (_super) {\n  __extends(OrderedMap, _super);\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  function OrderedMap(container, cmp, enableIndex) {\n    if (container === void 0) {\n      container = [];\n    }\n    var _this = _super.call(this, cmp, enableIndex) || this;\n    var self = _this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return _this;\n  }\n  OrderedMap.prototype.begin = function () {\n    return new OrderedMapIterator(this._header._left || this._header, this._header, this);\n  };\n  OrderedMap.prototype.end = function () {\n    return new OrderedMapIterator(this._header, this._header, this);\n  };\n  OrderedMap.prototype.rBegin = function () {\n    return new OrderedMapIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n  };\n\n  OrderedMap.prototype.rEnd = function () {\n    return new OrderedMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n  };\n\n  OrderedMap.prototype.front = function () {\n    if (this._length === 0) return;\n    var minNode = this._header._left;\n    return [minNode._key, minNode._value];\n  };\n  OrderedMap.prototype.back = function () {\n    if (this._length === 0) return;\n    var maxNode = this._header._right;\n    return [maxNode._key, maxNode._value];\n  };\n  OrderedMap.prototype.lowerBound = function (key) {\n    var resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.upperBound = function (key) {\n    var resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.reverseLowerBound = function (key) {\n    var resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.reverseUpperBound = function (key) {\n    var resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator(resNode, this._header, this);\n  };\n  OrderedMap.prototype.forEach = function (callback) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback([node._key, node._value], index, map);\n    });\n  };\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  OrderedMap.prototype.setElement = function (key, value, hint) {\n    return this._set(key, value, hint);\n  };\n  OrderedMap.prototype.getElementByPos = function (pos) {\n    if (pos < 0 || pos > this._length - 1) {\n      throw new RangeError();\n    }\n    var node = this._inOrderTraversal(pos);\n    return [node._key, node._value];\n  };\n  OrderedMap.prototype.find = function (key) {\n    var curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator(curNode, this._header, this);\n  };\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  OrderedMap.prototype.getElementByKey = function (key) {\n    var curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  };\n  OrderedMap.prototype.union = function (other) {\n    var self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  };\n  OrderedMap.prototype[Symbol.iterator] = function () {\n    var length, nodeList, i, node;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          length = this._length;\n          nodeList = this._inOrderTraversal();\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!(i < length)) return [3 /*break*/, 4];\n          node = nodeList[i];\n          return [4 /*yield*/, [node._key, node._value]];\n        case 2:\n          _a.sent();\n          _a.label = 3;\n        case 3:\n          ++i;\n          return [3 /*break*/, 1];\n        case 4:\n          return [2 /*return*/];\n      }\n    });\n  };\n\n  return OrderedMap;\n}(TreeContainer);\n\nexport { OrderedMap };\n//# sourceMappingURL=index.js.map\n","export const enum TreeNodeColor {\n  RED = 1,\n  BLACK = 0\n}\n\nexport class TreeNode<K, V> {\n  _color: TreeNodeColor;\n  _key: K | undefined;\n  _value: V | undefined;\n  _left: TreeNode<K, V> | undefined = undefined;\n  _right: TreeNode<K, V> | undefined = undefined;\n  _parent: TreeNode<K, V> | undefined = undefined;\n  constructor(\n    key?: K,\n    value?: V,\n    color: TreeNodeColor = TreeNodeColor.RED\n  ) {\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  _pre() {\n    let preNode: TreeNode<K, V> = this;\n    const isRootOrHeader = preNode._parent!._parent === preNode;\n    if (isRootOrHeader && preNode._color === TreeNodeColor.RED) {\n      preNode = preNode._right!;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent!;\n      }\n      let pre = preNode._parent!;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent!;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  }\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  _next() {\n    let nextNode: TreeNode<K, V> = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      let pre = nextNode._parent!;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent!;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  }\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const PP = this._parent!;\n    const V = this._right!;\n    const R = V._left;\n\n    if (PP._parent === this) PP._parent = V;\n    else if (PP._left === this) PP._left = V;\n    else PP._right = V;\n\n    V._parent = PP;\n    V._left = this;\n\n    this._parent = V;\n    this._right = R;\n\n    if (R) R._parent = this;\n\n    return V;\n  }\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const PP = this._parent!;\n    const F = this._left!;\n    const K = F._right;\n\n    if (PP._parent === this) PP._parent = F;\n    else if (PP._left === this) PP._left = F;\n    else PP._right = F;\n\n    F._parent = PP;\n    F._right = this;\n\n    this._parent = F;\n    this._left = K;\n\n    if (K) K._parent = this;\n\n    return F;\n  }\n}\n\nexport class TreeNodeEnableIndex<K, V> extends TreeNode<K, V> {\n  _subTreeSize = 1;\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const parent = super._rotateLeft() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const parent = super._rotateRight() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  _recount() {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += (this._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += (this._right as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n  }\n}\n","/**\n * @description The iterator type including `NORMAL` and `REVERSE`.\n */\nexport const enum IteratorType {\n  NORMAL = 0,\n  REVERSE = 1\n}\n\nexport abstract class ContainerIterator<T> {\n  /**\n   * @description The container pointed to by the iterator.\n   */\n  abstract readonly container: Container<T>;\n  /**\n   * @internal\n   */\n  abstract _node: unknown;\n  /**\n   * @description Iterator's type.\n   * @example\n   * console.log(container.end().iteratorType === IteratorType.NORMAL);  // true\n   */\n  readonly iteratorType: IteratorType;\n  /**\n   * @internal\n   */\n  protected constructor(iteratorType = IteratorType.NORMAL) {\n    this.iteratorType = iteratorType;\n  }\n  /**\n   * @param iter - The other iterator you want to compare.\n   * @returns Whether this equals to obj.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  equals(iter: ContainerIterator<T>) {\n    return this._node === iter._node;\n  }\n  /**\n   * @description Pointers to element.\n   * @returns The value of the pointer's element.\n   * @example\n   * const val = container.begin().pointer;\n   */\n  abstract get pointer(): T;\n  /**\n   * @description Set pointer's value (some containers are unavailable).\n   * @param newValue - The new value you want to set.\n   * @example\n   * (<LinkList<number>>container).begin().pointer = 1;\n   */\n  abstract set pointer(newValue: T);\n  /**\n   * @description Move `this` iterator to pre.\n   * @returns The iterator's self.\n   * @example\n   * const iter = container.find(1);  // container = [0, 1]\n   * const pre = iter.pre();\n   * console.log(pre === iter);  // true\n   * console.log(pre.equals(iter));  // true\n   * console.log(pre.pointer, iter.pointer); // 0, 0\n   */\n  abstract pre(): this;\n  /**\n   * @description Move `this` iterator to next.\n   * @returns The iterator's self.\n   * @example\n   * const iter = container.find(1);  // container = [1, 2]\n   * const next = iter.next();\n   * console.log(next === iter);  // true\n   * console.log(next.equals(iter));  // true\n   * console.log(next.pointer, iter.pointer); // 2, 2\n   */\n  abstract next(): this;\n  /**\n   * @description Get a copy of itself.\n   * @returns The copy of self.\n   * @example\n   * const iter = container.find(1);  // container = [1, 2]\n   * const next = iter.copy().next();\n   * console.log(next === iter);  // false\n   * console.log(next.equals(iter));  // false\n   * console.log(next.pointer, iter.pointer); // 2, 1\n   */\n  abstract copy(): ContainerIterator<T>;\n  abstract isAccessible(): boolean;\n}\n\nexport abstract class Base {\n  /**\n   * @description Container's size.\n   * @internal\n   */\n  protected _length = 0;\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.length); // 2\n   */\n  get length() {\n    return this._length;\n  }\n  /**\n   * @returns The size of the container.\n   * @example\n   * const container = new Vector([1, 2]);\n   * console.log(container.size()); // 2\n   */\n  size() {\n    return this._length;\n  }\n  /**\n   * @returns Whether the container is empty.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  empty() {\n    return this._length === 0;\n  }\n  /**\n   * @description Clear the container.\n   * @example\n   * container.clear();\n   * console.log(container.empty());  // true\n   */\n  abstract clear(): void;\n}\n\nexport abstract class Container<T> extends Base {\n  /**\n   * @returns Iterator pointing to the beginning element.\n   * @example\n   * const begin = container.begin();\n   * const end = container.end();\n   * for (const it = begin; !it.equals(end); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract begin(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the super end like c++.\n   * @example\n   * const begin = container.begin();\n   * const end = container.end();\n   * for (const it = begin; !it.equals(end); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract end(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the end element.\n   * @example\n   * const rBegin = container.rBegin();\n   * const rEnd = container.rEnd();\n   * for (const it = rBegin; !it.equals(rEnd); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract rBegin(): ContainerIterator<T>;\n  /**\n   * @returns Iterator pointing to the super begin like c++.\n   * @example\n   * const rBegin = container.rBegin();\n   * const rEnd = container.rEnd();\n   * for (const it = rBegin; !it.equals(rEnd); it.next()) {\n   *   doSomething(it.pointer);\n   * }\n   */\n  abstract rEnd(): ContainerIterator<T>;\n  /**\n   * @returns The first element of the container.\n   */\n  abstract front(): T | undefined;\n  /**\n   * @returns The last element of the container.\n   */\n  abstract back(): T | undefined;\n  /**\n   * @param element - The element you want to find.\n   * @returns An iterator pointing to the element if found, or super end if not found.\n   * @example\n   * container.find(1).equals(container.end());\n   */\n  abstract find(element: T): ContainerIterator<T>;\n  /**\n   * @description Iterate over all elements in the container.\n   * @param callback - Callback function like Array.forEach.\n   * @example\n   * container.forEach((element, index) => console.log(element, index));\n   */\n  abstract forEach(callback: (element: T, index: number, container: Container<T>) => void): void;\n  /**\n   * @description Gets the value of the element at the specified position.\n   * @example\n   * const val = container.getElementByPos(-1); // throw a RangeError\n   */\n  abstract getElementByPos(pos: number): T;\n  /**\n   * @description Removes the element at the specified position.\n   * @param pos - The element's position you want to remove.\n   * @returns The container length after erasing.\n   * @example\n   * container.eraseElementByPos(-1); // throw a RangeError\n   */\n  abstract eraseElementByPos(pos: number): number;\n  /**\n   * @description Removes element by iterator and move `iter` to next.\n   * @param iter - The iterator you want to erase.\n   * @returns The next iterator.\n   * @example\n   * container.eraseElementByIterator(container.begin());\n   * container.eraseElementByIterator(container.end()); // throw a RangeError\n   */\n  abstract eraseElementByIterator(\n    iter: ContainerIterator<T>\n  ): ContainerIterator<T>;\n  /**\n   * @description Using for `for...of` syntax like Array.\n   * @example\n   * for (const element of container) {\n   *   console.log(element);\n   * }\n   */\n  abstract [Symbol.iterator](): Generator<T, void>;\n}\n\n/**\n * @description The initial data type passed in when initializing the container.\n */\nexport type initContainer<T> = {\n  size?: number | (() => number);\n  length?: number;\n  forEach: (callback: (el: T) => void) => void;\n}\n","/**\n * @description Throw an iterator access error.\n * @internal\n */\nexport function throwIteratorAccessError() {\n  throw new RangeError('Iterator access denied!');\n}\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  enableIndex: boolean;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent as TreeNodeEnableIndex<K, V>;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n  }\n  protected _inOrderTraversal(): TreeNode<K, V>[];\n  protected _inOrderTraversal(pos: number): TreeNode<K, V>;\n  protected _inOrderTraversal(\n    callback: (node: TreeNode<K, V>, index: number, map: this) => void\n  ): TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    param?: number | ((node: TreeNode<K, V>, index: number, map: this) => void)\n  ) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? <TreeNode<K, V>[]>[] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack: TreeNode<K, V>[] = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop()!;\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        (<TreeNodeEnableIndex<K, V>>parentNode)._recount();\n        (<TreeNodeEnableIndex<K, V>>grandParent)._recount();\n        (<TreeNodeEnableIndex<K, V>>curNode)._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _set(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, TreeNodeColor.BLACK);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return this._length;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent as TreeNodeEnableIndex<K, V>;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  protected _getTreeNodeByKey(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key!;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (\n      this._cmp(preKey, key) >= 0 ||\n      this._cmp(nextKey, key) <= 0\n    ) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode: TreeNode<K, V> | undefined): number {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n","import { TreeNode } from './TreeNode';\nimport type { TreeNodeEnableIndex } from './TreeNode';\nimport { ContainerIterator, IteratorType } from '@/container/ContainerBase';\nimport TreeContainer from '@/container/TreeContainer/Base/index';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeIterator<K, V> extends ContainerIterator<K | [K, V]> {\n  abstract readonly container: TreeContainer<K, V>;\n  /**\n   * @internal\n   */\n  _node: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(iteratorType);\n    this._node = node;\n    this._header = header;\n    if (this.iteratorType === IteratorType.NORMAL) {\n      this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n  }\n  /**\n   * @description Get the sequential index of the iterator in the tree container.<br/>\n   *              <strong>Note:</strong>\n   *              This function only takes effect when the specified tree container `enableIndex = true`.\n   * @returns The index subscript of the node in the tree.\n   * @example\n   * const st = new OrderedSet([1, 2, 3], true);\n   * console.log(st.begin().next().index);  // 1\n   */\n  get index() {\n    let _node = this._node as TreeNodeEnableIndex<K, V>;\n    const root = this._header._parent as TreeNodeEnableIndex<K, V>;\n    if (_node === this._header) {\n      if (root) {\n        return root._subTreeSize - 1;\n      }\n      return 0;\n    }\n    let index = 0;\n    if (_node._left) {\n      index += (_node._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    while (_node !== root) {\n      const _parent = _node._parent as TreeNodeEnableIndex<K, V>;\n      if (_node === _parent._right) {\n        index += 1;\n        if (_parent._left) {\n          index += (_parent._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n        }\n      }\n      _node = _parent;\n    }\n    return index;\n  }\n  isAccessible() {\n    return this._node !== this._header;\n  }\n  // @ts-ignore\n  pre(): this;\n  // @ts-ignore\n  next(): this;\n}\n\nexport default TreeIterator;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedMapIterator<K, V> extends TreeIterator<K, V> {\n  container: OrderedMap<K, V>;\n  constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    container: OrderedMap<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(target, prop: '0' | '1') {\n        if (prop === '0') return self._node._key!;\n        else if (prop === '1') return self._node._value!;\n        target[0] = self._node._key!;\n        target[1] = self._node._value!;\n        return target[prop];\n      },\n      set(_, prop: '1', newValue: V) {\n        if (prop !== '1') {\n          throw new TypeError('prop must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new OrderedMapIterator<K, V>(\n      this._node,\n      this._header,\n      this.container,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: OrderedMapIterator<K, V>): boolean;\n}\n\nexport type { OrderedMapIterator };\n\nclass OrderedMap<K, V> extends TreeContainer<K, V> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<[K, V]> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new OrderedMapIterator<K, V>(this._header._left || this._header, this._header, this);\n  }\n  end() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedMapIterator<K, V>(\n      this._header._right || this._header,\n      this._header,\n      this,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    const minNode = this._header._left!;\n    return <[K, V]>[minNode._key, minNode._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    const maxNode = this._header._right!;\n    return <[K, V]>[maxNode._key, maxNode._value];\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  forEach(callback: (element: [K, V], index: number, map: OrderedMap<K, V>) => void) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback(<[K, V]>[node._key, node._value], index, map);\n    });\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>) {\n    return this._set(key, value, hint);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    return <[K, V]>[node._key, node._value];\n  }\n  find(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator<K, V>(curNode, this._header, this);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  }\n  union(other: OrderedMap<K, V>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  }\n  * [Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      const node = nodeList[i];\n      yield <[K, V]>[node._key, node._value];\n    }\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;\n}\n\nexport default OrderedMap;\n"]}/*!
 * @js-sdsl/ordered-map v4.4.2
 * https://github.com/js-sdsl/js-sdsl
 * (c) 2021-present ZLY201 <zilongyao1366@gmail.com>
 * MIT license
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sdsl = {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __generator(thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        },
        f,
        y,
        t,
        g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }
    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var TreeNode = /** @class */function () {
      function TreeNode(key, value, color) {
        if (color === void 0) {
          color = 1 /* TreeNodeColor.RED */;
        }
        this._left = undefined;
        this._right = undefined;
        this._parent = undefined;
        this._key = key;
        this._value = value;
        this._color = color;
      }
      /**
       * @description Get the pre node.
       * @returns TreeNode about the pre node.
       */
      TreeNode.prototype._pre = function () {
        var preNode = this;
        var isRootOrHeader = preNode._parent._parent === preNode;
        if (isRootOrHeader && preNode._color === 1 /* TreeNodeColor.RED */) {
          preNode = preNode._right;
        } else if (preNode._left) {
          preNode = preNode._left;
          while (preNode._right) {
            preNode = preNode._right;
          }
        } else {
          // Must be root and left is null
          if (isRootOrHeader) {
            return preNode._parent;
          }
          var pre = preNode._parent;
          while (pre._left === preNode) {
            preNode = pre;
            pre = preNode._parent;
          }
          preNode = pre;
        }
        return preNode;
      };
      /**
       * @description Get the next node.
       * @returns TreeNode about the next node.
       */
      TreeNode.prototype._next = function () {
        var nextNode = this;
        if (nextNode._right) {
          nextNode = nextNode._right;
          while (nextNode._left) {
            nextNode = nextNode._left;
          }
          return nextNode;
        } else {
          var pre = nextNode._parent;
          while (pre._right === nextNode) {
            nextNode = pre;
            pre = nextNode._parent;
          }
          if (nextNode._right !== pre) {
            return pre;
          } else return nextNode;
        }
      };
      /**
       * @description Rotate left.
       * @returns TreeNode about moved to original position after rotation.
       */
      TreeNode.prototype._rotateLeft = function () {
        var PP = this._parent;
        var V = this._right;
        var R = V._left;
        if (PP._parent === this) PP._parent = V;else if (PP._left === this) PP._left = V;else PP._right = V;
        V._parent = PP;
        V._left = this;
        this._parent = V;
        this._right = R;
        if (R) R._parent = this;
        return V;
      };
      /**
       * @description Rotate right.
       * @returns TreeNode about moved to original position after rotation.
       */
      TreeNode.prototype._rotateRight = function () {
        var PP = this._parent;
        var F = this._left;
        var K = F._right;
        if (PP._parent === this) PP._parent = F;else if (PP._left === this) PP._left = F;else PP._right = F;
        F._parent = PP;
        F._right = this;
        this._parent = F;
        this._left = K;
        if (K) K._parent = this;
        return F;
      };
      return TreeNode;
    }();
    var TreeNodeEnableIndex = /** @class */function (_super) {
      __extends(TreeNodeEnableIndex, _super);
      function TreeNodeEnableIndex() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._subTreeSize = 1;
        return _this;
      }
      /**
       * @description Rotate left and do recount.
       * @returns TreeNode about moved to original position after rotation.
       */
      TreeNodeEnableIndex.prototype._rotateLeft = function () {
        var parent = _super.prototype._rotateLeft.call(this);
        this._recount();
        parent._recount();
        return parent;
      };
      /**
       * @description Rotate right and do recount.
       * @returns TreeNode about moved to original position after rotation.
       */
      TreeNodeEnableIndex.prototype._rotateRight = function () {
        var parent = _super.prototype._rotateRight.call(this);
        this._recount();
        parent._recount();
        return parent;
      };
      TreeNodeEnableIndex.prototype._recount = function () {
        this._subTreeSize = 1;
        if (this._left) {
          this._subTreeSize += this._left._subTreeSize;
        }
        if (this._right) {
          this._subTreeSize += this._right._subTreeSize;
        }
      };
      return TreeNodeEnableIndex;
    }(TreeNode);

    var ContainerIterator = /** @class */function () {
      /**
       * @internal
       */
      function ContainerIterator(iteratorType) {
        if (iteratorType === void 0) {
          iteratorType = 0 /* IteratorType.NORMAL */;
        }
        this.iteratorType = iteratorType;
      }
      /**
       * @param iter - The other iterator you want to compare.
       * @returns Whether this equals to obj.
       * @example
       * container.find(1).equals(container.end());
       */
      ContainerIterator.prototype.equals = function (iter) {
        return this._node === iter._node;
      };
      return ContainerIterator;
    }();
    var Base = /** @class */function () {
      function Base() {
        /**
         * @description Container's size.
         * @internal
         */
        this._length = 0;
      }
      Object.defineProperty(Base.prototype, "length", {
        /**
         * @returns The size of the container.
         * @example
         * const container = new Vector([1, 2]);
         * console.log(container.length); // 2
         */
        get: function () {
          return this._length;
        },
        enumerable: false,
        configurable: true
      });
      /**
       * @returns The size of the container.
       * @example
       * const container = new Vector([1, 2]);
       * console.log(container.size()); // 2
       */
      Base.prototype.size = function () {
        return this._length;
      };
      /**
       * @returns Whether the container is empty.
       * @example
       * container.clear();
       * console.log(container.empty());  // true
       */
      Base.prototype.empty = function () {
        return this._length === 0;
      };
      return Base;
    }();
    var Container = /** @class */function (_super) {
      __extends(Container, _super);
      function Container() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return Container;
    }(Base);

    /**
     * @description Throw an iterator access error.
     * @internal
     */
    function throwIteratorAccessError() {
      throw new RangeError('Iterator access denied!');
    }

    var TreeContainer = /** @class */function (_super) {
      __extends(TreeContainer, _super);
      /**
       * @internal
       */
      function TreeContainer(cmp, enableIndex) {
        if (cmp === void 0) {
          cmp = function (x, y) {
            if (x < y) return -1;
            if (x > y) return 1;
            return 0;
          };
        }
        if (enableIndex === void 0) {
          enableIndex = false;
        }
        var _this = _super.call(this) || this;
        /**
         * @internal
         */
        _this._root = undefined;
        _this._cmp = cmp;
        _this.enableIndex = enableIndex;
        _this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;
        _this._header = new _this._TreeNodeClass();
        return _this;
      }
      /**
       * @internal
       */
      TreeContainer.prototype._lowerBound = function (curNode, key) {
        var resNode = this._header;
        while (curNode) {
          var cmpResult = this._cmp(curNode._key, key);
          if (cmpResult < 0) {
            curNode = curNode._right;
          } else if (cmpResult > 0) {
            resNode = curNode;
            curNode = curNode._left;
          } else return curNode;
        }
        return resNode;
      };
      /**
       * @internal
       */
      TreeContainer.prototype._upperBound = function (curNode, key) {
        var resNode = this._header;
        while (curNode) {
          var cmpResult = this._cmp(curNode._key, key);
          if (cmpResult <= 0) {
            curNode = curNode._right;
          } else {
            resNode = curNode;
            curNode = curNode._left;
          }
        }
        return resNode;
      };
      /**
       * @internal
       */
      TreeContainer.prototype._reverseLowerBound = function (curNode, key) {
        var resNode = this._header;
        while (curNode) {
          var cmpResult = this._cmp(curNode._key, key);
          if (cmpResult < 0) {
            resNode = curNode;
            curNode = curNode._right;
          } else if (cmpResult > 0) {
            curNode = curNode._left;
          } else return curNode;
        }
        return resNode;
      };
      /**
       * @internal
       */
      TreeContainer.prototype._reverseUpperBound = function (curNode, key) {
        var resNode = this._header;
        while (curNode) {
          var cmpResult = this._cmp(curNode._key, key);
          if (cmpResult < 0) {
            resNode = curNode;
            curNode = curNode._right;
          } else {
            curNode = curNode._left;
          }
        }
        return resNode;
      };
      /**
       * @internal
       */
      TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {
        while (true) {
          var parentNode = curNode._parent;
          if (parentNode === this._header) return;
          if (curNode._color === 1 /* TreeNodeColor.RED */) {
            curNode._color = 0 /* TreeNodeColor.BLACK */;
            return;
          }
          if (curNode === parentNode._left) {
            var brother = parentNode._right;
            if (brother._color === 1 /* TreeNodeColor.RED */) {
              brother._color = 0 /* TreeNodeColor.BLACK */;
              parentNode._color = 1 /* TreeNodeColor.RED */;
              if (parentNode === this._root) {
                this._root = parentNode._rotateLeft();
              } else parentNode._rotateLeft();
            } else {
              if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {
                brother._color = parentNode._color;
                parentNode._color = 0 /* TreeNodeColor.BLACK */;
                brother._right._color = 0 /* TreeNodeColor.BLACK */;
                if (parentNode === this._root) {
                  this._root = parentNode._rotateLeft();
                } else parentNode._rotateLeft();
                return;
              } else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {
                brother._color = 1 /* TreeNodeColor.RED */;
                brother._left._color = 0 /* TreeNodeColor.BLACK */;
                brother._rotateRight();
              } else {
                brother._color = 1 /* TreeNodeColor.RED */;
                curNode = parentNode;
              }
            }
          } else {
            var brother = parentNode._left;
            if (brother._color === 1 /* TreeNodeColor.RED */) {
              brother._color = 0 /* TreeNodeColor.BLACK */;
              parentNode._color = 1 /* TreeNodeColor.RED */;
              if (parentNode === this._root) {
                this._root = parentNode._rotateRight();
              } else parentNode._rotateRight();
            } else {
              if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {
                brother._color = parentNode._color;
                parentNode._color = 0 /* TreeNodeColor.BLACK */;
                brother._left._color = 0 /* TreeNodeColor.BLACK */;
                if (parentNode === this._root) {
                  this._root = parentNode._rotateRight();
                } else parentNode._rotateRight();
                return;
              } else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {
                brother._color = 1 /* TreeNodeColor.RED */;
                brother._right._color = 0 /* TreeNodeColor.BLACK */;
                brother._rotateLeft();
              } else {
                brother._color = 1 /* TreeNodeColor.RED */;
                curNode = parentNode;
              }
            }
          }
        }
      };
      /**
       * @internal
       */
      TreeContainer.prototype._eraseNode = function (curNode) {
        if (this._length === 1) {
          this.clear();
          return;
        }
        var swapNode = curNode;
        while (swapNode._left || swapNode._right) {
          if (swapNode._right) {
            swapNode = swapNode._right;
            while (swapNode._left) swapNode = swapNode._left;
          } else {
            swapNode = swapNode._left;
          }
          var key = curNode._key;
          curNode._key = swapNode._key;
          swapNode._key = key;
          var value = curNode._value;
          curNode._value = swapNode._value;
          swapNode._value = value;
          curNode = swapNode;
        }
        if (this._header._left === swapNode) {
          this._header._left = swapNode._parent;
        } else if (this._header._right === swapNode) {
          this._header._right = swapNode._parent;
        }
        this._eraseNodeSelfBalance(swapNode);
        var _parent = swapNode._parent;
        if (swapNode === _parent._left) {
          _parent._left = undefined;
        } else _parent._right = undefined;
        this._length -= 1;
        this._root._color = 0 /* TreeNodeColor.BLACK */;
        if (this.enableIndex) {
          while (_parent !== this._header) {
            _parent._subTreeSize -= 1;
            _parent = _parent._parent;
          }
        }
      };
      /**
       * @internal
       */
      TreeContainer.prototype._inOrderTraversal = function (param) {
        var pos = typeof param === 'number' ? param : undefined;
        var callback = typeof param === 'function' ? param : undefined;
        var nodeList = typeof param === 'undefined' ? [] : undefined;
        var index = 0;
        var curNode = this._root;
        var stack = [];
        while (stack.length || curNode) {
          if (curNode) {
            stack.push(curNode);
            curNode = curNode._left;
          } else {
            curNode = stack.pop();
            if (index === pos) return curNode;
            nodeList && nodeList.push(curNode);
            callback && callback(curNode, index, this);
            index += 1;
            curNode = curNode._right;
          }
        }
        return nodeList;
      };
      /**
       * @internal
       */
      TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {
        while (true) {
          var parentNode = curNode._parent;
          if (parentNode._color === 0 /* TreeNodeColor.BLACK */) return;
          var grandParent = parentNode._parent;
          if (parentNode === grandParent._left) {
            var uncle = grandParent._right;
            if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {
              uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;
              if (grandParent === this._root) return;
              grandParent._color = 1 /* TreeNodeColor.RED */;
              curNode = grandParent;
              continue;
            } else if (curNode === parentNode._right) {
              curNode._color = 0 /* TreeNodeColor.BLACK */;
              if (curNode._left) {
                curNode._left._parent = parentNode;
              }
              if (curNode._right) {
                curNode._right._parent = grandParent;
              }
              parentNode._right = curNode._left;
              grandParent._left = curNode._right;
              curNode._left = parentNode;
              curNode._right = grandParent;
              if (grandParent === this._root) {
                this._root = curNode;
                this._header._parent = curNode;
              } else {
                var GP = grandParent._parent;
                if (GP._left === grandParent) {
                  GP._left = curNode;
                } else GP._right = curNode;
              }
              curNode._parent = grandParent._parent;
              parentNode._parent = curNode;
              grandParent._parent = curNode;
              grandParent._color = 1 /* TreeNodeColor.RED */;
            } else {
              parentNode._color = 0 /* TreeNodeColor.BLACK */;
              if (grandParent === this._root) {
                this._root = grandParent._rotateRight();
              } else grandParent._rotateRight();
              grandParent._color = 1 /* TreeNodeColor.RED */;
              return;
            }
          } else {
            var uncle = grandParent._left;
            if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {
              uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;
              if (grandParent === this._root) return;
              grandParent._color = 1 /* TreeNodeColor.RED */;
              curNode = grandParent;
              continue;
            } else if (curNode === parentNode._left) {
              curNode._color = 0 /* TreeNodeColor.BLACK */;
              if (curNode._left) {
                curNode._left._parent = grandParent;
              }
              if (curNode._right) {
                curNode._right._parent = parentNode;
              }
              grandParent._right = curNode._left;
              parentNode._left = curNode._right;
              curNode._left = grandParent;
              curNode._right = parentNode;
              if (grandParent === this._root) {
                this._root = curNode;
                this._header._parent = curNode;
              } else {
                var GP = grandParent._parent;
                if (GP._left === grandParent) {
                  GP._left = curNode;
                } else GP._right = curNode;
              }
              curNode._parent = grandParent._parent;
              parentNode._parent = curNode;
              grandParent._parent = curNode;
              grandParent._color = 1 /* TreeNodeColor.RED */;
            } else {
              parentNode._color = 0 /* TreeNodeColor.BLACK */;
              if (grandParent === this._root) {
                this._root = grandParent._rotateLeft();
              } else grandParent._rotateLeft();
              grandParent._color = 1 /* TreeNodeColor.RED */;
              return;
            }
          }
          if (this.enableIndex) {
            parentNode._recount();
            grandParent._recount();
            curNode._recount();
          }
          return;
        }
      };
      /**
       * @internal
       */
      TreeContainer.prototype._set = function (key, value, hint) {
        if (this._root === undefined) {
          this._length += 1;
          this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);
          this._root._parent = this._header;
          this._header._parent = this._header._left = this._header._right = this._root;
          return this._length;
        }
        var curNode;
        var minNode = this._header._left;
        var compareToMin = this._cmp(minNode._key, key);
        if (compareToMin === 0) {
          minNode._value = value;
          return this._length;
        } else if (compareToMin > 0) {
          minNode._left = new this._TreeNodeClass(key, value);
          minNode._left._parent = minNode;
          curNode = minNode._left;
          this._header._left = curNode;
        } else {
          var maxNode = this._header._right;
          var compareToMax = this._cmp(maxNode._key, key);
          if (compareToMax === 0) {
            maxNode._value = value;
            return this._length;
          } else if (compareToMax < 0) {
            maxNode._right = new this._TreeNodeClass(key, value);
            maxNode._right._parent = maxNode;
            curNode = maxNode._right;
            this._header._right = curNode;
          } else {
            if (hint !== undefined) {
              var iterNode = hint._node;
              if (iterNode !== this._header) {
                var iterCmpRes = this._cmp(iterNode._key, key);
                if (iterCmpRes === 0) {
                  iterNode._value = value;
                  return this._length;
                } else /* istanbul ignore else */if (iterCmpRes > 0) {
                    var preNode = iterNode._pre();
                    var preCmpRes = this._cmp(preNode._key, key);
                    if (preCmpRes === 0) {
                      preNode._value = value;
                      return this._length;
                    } else if (preCmpRes < 0) {
                      curNode = new this._TreeNodeClass(key, value);
                      if (preNode._right === undefined) {
                        preNode._right = curNode;
                        curNode._parent = preNode;
                      } else {
                        iterNode._left = curNode;
                        curNode._parent = iterNode;
                      }
                    }
                  }
              }
            }
            if (curNode === undefined) {
              curNode = this._root;
              while (true) {
                var cmpResult = this._cmp(curNode._key, key);
                if (cmpResult > 0) {
                  if (curNode._left === undefined) {
                    curNode._left = new this._TreeNodeClass(key, value);
                    curNode._left._parent = curNode;
                    curNode = curNode._left;
                    break;
                  }
                  curNode = curNode._left;
                } else if (cmpResult < 0) {
                  if (curNode._right === undefined) {
                    curNode._right = new this._TreeNodeClass(key, value);
                    curNode._right._parent = curNode;
                    curNode = curNode._right;
                    break;
                  }
                  curNode = curNode._right;
                } else {
                  curNode._value = value;
                  return this._length;
                }
              }
            }
          }
        }
        if (this.enableIndex) {
          var parent_1 = curNode._parent;
          while (parent_1 !== this._header) {
            parent_1._subTreeSize += 1;
            parent_1 = parent_1._parent;
          }
        }
        this._insertNodeSelfBalance(curNode);
        this._length += 1;
        return this._length;
      };
      /**
       * @internal
       */
      TreeContainer.prototype._getTreeNodeByKey = function (curNode, key) {
        while (curNode) {
          var cmpResult = this._cmp(curNode._key, key);
          if (cmpResult < 0) {
            curNode = curNode._right;
          } else if (cmpResult > 0) {
            curNode = curNode._left;
          } else return curNode;
        }
        return curNode || this._header;
      };
      TreeContainer.prototype.clear = function () {
        this._length = 0;
        this._root = undefined;
        this._header._parent = undefined;
        this._header._left = this._header._right = undefined;
      };
      /**
       * @description Update node's key by iterator.
       * @param iter - The iterator you want to change.
       * @param key - The key you want to update.
       * @returns Whether the modification is successful.
       * @example
       * const st = new orderedSet([1, 2, 5]);
       * const iter = st.find(2);
       * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]
       */
      TreeContainer.prototype.updateKeyByIterator = function (iter, key) {
        var node = iter._node;
        if (node === this._header) {
          throwIteratorAccessError();
        }
        if (this._length === 1) {
          node._key = key;
          return true;
        }
        var nextKey = node._next()._key;
        if (node === this._header._left) {
          if (this._cmp(nextKey, key) > 0) {
            node._key = key;
            return true;
          }
          return false;
        }
        var preKey = node._pre()._key;
        if (node === this._header._right) {
          if (this._cmp(preKey, key) < 0) {
            node._key = key;
            return true;
          }
          return false;
        }
        if (this._cmp(preKey, key) >= 0 || this._cmp(nextKey, key) <= 0) return false;
        node._key = key;
        return true;
      };
      TreeContainer.prototype.eraseElementByPos = function (pos) {
        if (pos < 0 || pos > this._length - 1) {
          throw new RangeError();
        }
        var node = this._inOrderTraversal(pos);
        this._eraseNode(node);
        return this._length;
      };
      /**
       * @description Remove the element of the specified key.
       * @param key - The key you want to remove.
       * @returns Whether erase successfully.
       */
      TreeContainer.prototype.eraseElementByKey = function (key) {
        if (this._length === 0) return false;
        var curNode = this._getTreeNodeByKey(this._root, key);
        if (curNode === this._header) return false;
        this._eraseNode(curNode);
        return true;
      };
      TreeContainer.prototype.eraseElementByIterator = function (iter) {
        var node = iter._node;
        if (node === this._header) {
          throwIteratorAccessError();
        }
        var hasNoRight = node._right === undefined;
        var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;
        // For the normal iterator, the `next` node will be swapped to `this` node when has right.
        if (isNormal) {
          // So we should move it to next when it's right is null.
          if (hasNoRight) iter.next();
        } else {
          // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.
          // So when it has right, or it is a leaf node we should move it to `next`.
          if (!hasNoRight || node._left === undefined) iter.next();
        }
        this._eraseNode(node);
        return iter;
      };
      /**
       * @description Get the height of the tree.
       * @returns Number about the height of the RB-tree.
       */
      TreeContainer.prototype.getHeight = function () {
        if (this._length === 0) return 0;
        function traversal(curNode) {
          if (!curNode) return 0;
          return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;
        }
        return traversal(this._root);
      };
      return TreeContainer;
    }(Container);

    var TreeIterator = /** @class */function (_super) {
      __extends(TreeIterator, _super);
      /**
       * @internal
       */
      function TreeIterator(node, header, iteratorType) {
        var _this = _super.call(this, iteratorType) || this;
        _this._node = node;
        _this._header = header;
        if (_this.iteratorType === 0 /* IteratorType.NORMAL */) {
          _this.pre = function () {
            if (this._node === this._header._left) {
              throwIteratorAccessError();
            }
            this._node = this._node._pre();
            return this;
          };
          _this.next = function () {
            if (this._node === this._header) {
              throwIteratorAccessError();
            }
            this._node = this._node._next();
            return this;
          };
        } else {
          _this.pre = function () {
            if (this._node === this._header._right) {
              throwIteratorAccessError();
            }
            this._node = this._node._next();
            return this;
          };
          _this.next = function () {
            if (this._node === this._header) {
              throwIteratorAccessError();
            }
            this._node = this._node._pre();
            return this;
          };
        }
        return _this;
      }
      Object.defineProperty(TreeIterator.prototype, "index", {
        /**
         * @description Get the sequential index of the iterator in the tree container.<br/>
         *              <strong>Note:</strong>
         *              This function only takes effect when the specified tree container `enableIndex = true`.
         * @returns The index subscript of the node in the tree.
         * @example
         * const st = new OrderedSet([1, 2, 3], true);
         * console.log(st.begin().next().index);  // 1
         */
        get: function () {
          var _node = this._node;
          var root = this._header._parent;
          if (_node === this._header) {
            if (root) {
              return root._subTreeSize - 1;
            }
            return 0;
          }
          var index = 0;
          if (_node._left) {
            index += _node._left._subTreeSize;
          }
          while (_node !== root) {
            var _parent = _node._parent;
            if (_node === _parent._right) {
              index += 1;
              if (_parent._left) {
                index += _parent._left._subTreeSize;
              }
            }
            _node = _parent;
          }
          return index;
        },
        enumerable: false,
        configurable: true
      });
      TreeIterator.prototype.isAccessible = function () {
        return this._node !== this._header;
      };
      return TreeIterator;
    }(ContainerIterator);

    var OrderedMapIterator = /** @class */function (_super) {
      __extends(OrderedMapIterator, _super);
      function OrderedMapIterator(node, header, container, iteratorType) {
        var _this = _super.call(this, node, header, iteratorType) || this;
        _this.container = container;
        return _this;
      }
      Object.defineProperty(OrderedMapIterator.prototype, "pointer", {
        get: function () {
          if (this._node === this._header) {
            throwIteratorAccessError();
          }
          var self = this;
          return new Proxy([], {
            get: function (target, prop) {
              if (prop === '0') return self._node._key;else if (prop === '1') return self._node._value;
              target[0] = self._node._key;
              target[1] = self._node._value;
              return target[prop];
            },
            set: function (_, prop, newValue) {
              if (prop !== '1') {
                throw new TypeError('prop must be 1');
              }
              self._node._value = newValue;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      OrderedMapIterator.prototype.copy = function () {
        return new OrderedMapIterator(this._node, this._header, this.container, this.iteratorType);
      };
      return OrderedMapIterator;
    }(TreeIterator);
    var OrderedMap = /** @class */function (_super) {
      __extends(OrderedMap, _super);
      /**
       * @param container - The initialization container.
       * @param cmp - The compare function.
       * @param enableIndex - Whether to enable iterator indexing function.
       * @example
       * new OrderedMap();
       * new OrderedMap([[0, 1], [2, 1]]);
       * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);
       * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);
       */
      function OrderedMap(container, cmp, enableIndex) {
        if (container === void 0) {
          container = [];
        }
        var _this = _super.call(this, cmp, enableIndex) || this;
        var self = _this;
        container.forEach(function (el) {
          self.setElement(el[0], el[1]);
        });
        return _this;
      }
      OrderedMap.prototype.begin = function () {
        return new OrderedMapIterator(this._header._left || this._header, this._header, this);
      };
      OrderedMap.prototype.end = function () {
        return new OrderedMapIterator(this._header, this._header, this);
      };
      OrderedMap.prototype.rBegin = function () {
        return new OrderedMapIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);
      };

      OrderedMap.prototype.rEnd = function () {
        return new OrderedMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);
      };

      OrderedMap.prototype.front = function () {
        if (this._length === 0) return;
        var minNode = this._header._left;
        return [minNode._key, minNode._value];
      };
      OrderedMap.prototype.back = function () {
        if (this._length === 0) return;
        var maxNode = this._header._right;
        return [maxNode._key, maxNode._value];
      };
      OrderedMap.prototype.lowerBound = function (key) {
        var resNode = this._lowerBound(this._root, key);
        return new OrderedMapIterator(resNode, this._header, this);
      };
      OrderedMap.prototype.upperBound = function (key) {
        var resNode = this._upperBound(this._root, key);
        return new OrderedMapIterator(resNode, this._header, this);
      };
      OrderedMap.prototype.reverseLowerBound = function (key) {
        var resNode = this._reverseLowerBound(this._root, key);
        return new OrderedMapIterator(resNode, this._header, this);
      };
      OrderedMap.prototype.reverseUpperBound = function (key) {
        var resNode = this._reverseUpperBound(this._root, key);
        return new OrderedMapIterator(resNode, this._header, this);
      };
      OrderedMap.prototype.forEach = function (callback) {
        this._inOrderTraversal(function (node, index, map) {
          callback([node._key, node._value], index, map);
        });
      };
      /**
       * @description Insert a key-value pair or set value by the given key.
       * @param key - The key want to insert.
       * @param value - The value want to set.
       * @param hint - You can give an iterator hint to improve insertion efficiency.
       * @return The size of container after setting.
       * @example
       * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);
       * const iter = mp.begin();
       * mp.setElement(1, 0);
       * mp.setElement(3, 0, iter);  // give a hint will be faster.
       */
      OrderedMap.prototype.setElement = function (key, value, hint) {
        return this._set(key, value, hint);
      };
      OrderedMap.prototype.getElementByPos = function (pos) {
        if (pos < 0 || pos > this._length - 1) {
          throw new RangeError();
        }
        var node = this._inOrderTraversal(pos);
        return [node._key, node._value];
      };
      OrderedMap.prototype.find = function (key) {
        var curNode = this._getTreeNodeByKey(this._root, key);
        return new OrderedMapIterator(curNode, this._header, this);
      };
      /**
       * @description Get the value of the element of the specified key.
       * @param key - The specified key you want to get.
       * @example
       * const val = container.getElementByKey(1);
       */
      OrderedMap.prototype.getElementByKey = function (key) {
        var curNode = this._getTreeNodeByKey(this._root, key);
        return curNode._value;
      };
      OrderedMap.prototype.union = function (other) {
        var self = this;
        other.forEach(function (el) {
          self.setElement(el[0], el[1]);
        });
        return this._length;
      };
      OrderedMap.prototype[Symbol.iterator] = function () {
        var length, nodeList, i, node;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              length = this._length;
              nodeList = this._inOrderTraversal();
              i = 0;
              _a.label = 1;
            case 1:
              if (!(i < length)) return [3 /*break*/, 4];
              node = nodeList[i];
              return [4 /*yield*/, [node._key, node._value]];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              ++i;
              return [3 /*break*/, 1];
            case 4:
              return [2 /*return*/];
          }
        });
      };

      return OrderedMap;
    }(TreeContainer);

    exports.OrderedMap = OrderedMap;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
/*!
 * @js-sdsl/ordered-map v4.4.2
 * https://github.com/js-sdsl/js-sdsl
 * (c) 2021-present ZLY201 <zilongyao1366@gmail.com>
 * MIT license
 */
!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports):"function"==typeof define&&define.amd?define(["exports"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).sdsl={})}(this,function(t){"use strict";var r=function(t,i){return(r=Object.setPrototypeOf||({__proto__:[]}instanceof Array?function(t,i){t.__proto__=i}:function(t,i){for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}))(t,i)};function i(t,i){if("function"!=typeof i&&null!==i)throw new TypeError("Class extends value "+String(i)+" is not a constructor or null");function e(){this.constructor=t}r(t,i),t.prototype=null===i?Object.create(i):(e.prototype=i.prototype,new e)}function o(r,n){var o,s,h,u={label:0,sent:function(){if(1&h[0])throw h[1];return h[1]},trys:[],ops:[]},f={next:t(0),throw:t(1),return:t(2)};return"function"==typeof Symbol&&(f[Symbol.iterator]=function(){return this}),f;function t(e){return function(t){var i=[e,t];if(o)throw new TypeError("Generator is already executing.");for(;u=f&&i[f=0]?0:u;)try{if(o=1,s&&(h=2&i[0]?s.return:i[0]?s.throw||((h=s.return)&&h.call(s),0):s.next)&&!(h=h.call(s,i[1])).done)return h;switch(s=0,(i=h?[2&i[0],h.value]:i)[0]){case 0:case 1:h=i;break;case 4:return u.label++,{value:i[1],done:!1};case 5:u.label++,s=i[1],i=[0];continue;case 7:i=u.ops.pop(),u.trys.pop();continue;default:if(!(h=0<(h=u.trys).length&&h[h.length-1])&&(6===i[0]||2===i[0])){u=0;continue}if(3===i[0]&&(!h||i[1]>h[0]&&i[1]<h[3]))u.label=i[1];else if(6===i[0]&&u.label<h[1])u.label=h[1],h=i;else{if(!(h&&u.label<h[2])){h[2]&&u.ops.pop(),u.trys.pop();continue}u.label=h[2],u.ops.push(i)}}i=n.call(r,u)}catch(t){i=[6,t],s=0}finally{o=h=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}}}e.prototype.v=function(){var t=this,i=t.u.u===t;if(i&&1===t.l)t=t.i;else if(t.t)for(t=t.t;t.i;)t=t.i;else{if(i)return t.u;for(var e=t.u;e.t===t;)e=(t=e).u;t=e}return t},e.prototype.p=function(){var t=this;if(t.i){for(t=t.i;t.t;)t=t.t;return t}for(var i=t.u;i.i===t;)i=(t=i).u;return t.i!==i?i:t},e.prototype.T=function(){var t=this.u,i=this.i,e=i.t;return t.u===this?t.u=i:t.t===this?t.t=i:t.i=i,i.u=t,(i.t=this).u=i,(this.i=e)&&(e.u=this),i},e.prototype.O=function(){var t=this.u,i=this.t,e=i.i;return t.u===this?t.u=i:t.t===this?t.t=i:t.i=i,i.u=t,(i.i=this).u=i,(this.t=e)&&(e.u=this),i};var n=e;function e(t,i,e){void 0===e&&(e=1),this.t=void 0,this.i=void 0,this.u=void 0,this.h=t,this.o=i,this.l=e}i(u,s=n),u.prototype.T=function(){var t=s.prototype.T.call(this);return this.I(),t.I(),t},u.prototype.O=function(){var t=s.prototype.O.call(this);return this.I(),t.I(),t},u.prototype.I=function(){this._=1,this.t&&(this._+=this.t._),this.i&&(this._+=this.i._)};var s,h=u;function u(){var t=null!==s&&s.apply(this,arguments)||this;return t._=1,t}p.prototype.equals=function(t){return this.M===t.M};var f=p;function p(t){this.iteratorType=t=void 0===t?0:t}function l(){this.C=0}Object.defineProperty(l.prototype,"length",{get:function(){return this.C},enumerable:!1,configurable:!0}),l.prototype.size=function(){return this.C},l.prototype.empty=function(){return 0===this.C};i(y,c=l);var c,a=y;function y(){return null!==c&&c.apply(this,arguments)||this}function v(){throw new RangeError("Iterator access denied!")}i(A,d=a),A.prototype.j=function(t,i){for(var e=this.A;t;){var r=this.N(t.h,i);if(r<0)t=t.i;else{if(!(0<r))return t;t=(e=t).t}}return e},A.prototype.S=function(t,i){for(var e=this.A;t;)t=this.N(t.h,i)<=0?t.i:(e=t).t;return e},A.prototype.k=function(t,i){for(var e=this.A;t;){var r=this.N(t.h,i);if(r<0)t=(e=t).i;else{if(!(0<r))return t;t=t.t}}return e},A.prototype.B=function(t,i){for(var e=this.A;t;)t=this.N(t.h,i)<0?(e=t).i:t.t;return e},A.prototype.R=function(t){for(;;){var i,e=t.u;if(e===this.A)return;if(1===t.l)return void(t.l=0);if(t===e.t)if(1===(i=e.i).l)i.l=0,e.l=1,e===this.g?this.g=e.T():e.T();else{if(i.i&&1===i.i.l)return i.l=e.l,e.l=0,i.i.l=0,void(e===this.g?this.g=e.T():e.T());i.t&&1===i.t.l?(i.l=1,i.t.l=0,i.O()):(i.l=1,t=e)}else if(1===(i=e.t).l)i.l=0,e.l=1,e===this.g?this.g=e.O():e.O();else{if(i.t&&1===i.t.l)return i.l=e.l,e.l=0,i.t.l=0,void(e===this.g?this.g=e.O():e.O());i.i&&1===i.i.l?(i.l=1,i.i.l=0,i.T()):(i.l=1,t=e)}}},A.prototype.G=function(t){if(1===this.C)this.clear();else{for(var i=t;i.t||i.i;){if(i.i)for(i=i.i;i.t;)i=i.t;else i=i.t;var e=t.h,e=(t.h=i.h,i.h=e,t.o);t.o=i.o,i.o=e,t=i}this.A.t===i?this.A.t=i.u:this.A.i===i&&(this.A.i=i.u),this.R(i);var r=i.u;if(i===r.t?r.t=void 0:r.i=void 0,--this.C,this.g.l=0,this.enableIndex)for(;r!==this.A;)--r._,r=r.u}},A.prototype.P=function(t){for(var i="number"==typeof t?t:void 0,e="function"==typeof t?t:void 0,r=void 0===t?[]:void 0,n=0,o=this.g,s=[];s.length||o;)if(o)s.push(o),o=o.t;else{if(o=s.pop(),n===i)return o;r&&r.push(o),e&&e(o,n,this),n+=1,o=o.i}return r},A.prototype.q=function(t){for(;;){var i=t.u;if(0===i.l)return;var e,r,n=i.u;if(i===n.t){if((e=n.i)&&1===e.l){if(e.l=i.l=0,n===this.g)return;n.l=1,t=n;continue}if(t!==i.i)return i.l=0,n===this.g?this.g=n.O():n.O(),void(n.l=1);t.l=0,t.t&&(t.t.u=i),t.i&&(t.i.u=n),i.i=t.t,n.t=t.i,t.t=i,(t.i=n)===this.g?(this.g=t,this.A.u=t):(r=n.u).t===n?r.t=t:r.i=t}else{if((e=n.t)&&1===e.l){if(e.l=i.l=0,n===this.g)return;n.l=1,t=n;continue}if(t!==i.t)return i.l=0,n===this.g?this.g=n.T():n.T(),void(n.l=1);t.l=0,t.t&&(t.t.u=n),t.i&&(t.i.u=i),n.i=t.t,i.t=t.i,t.t=n,t.i=i,n===this.g?(this.g=t,this.A.u=t):(r=n.u).t===n?r.t=t:r.i=t}return t.u=n.u,i.u=t,n.u=t,n.l=1,void(this.enableIndex&&(i.I(),n.I(),t.I()))}},A.prototype.D=function(t,i,e){if(void 0===this.g)this.C+=1,this.g=new this.m(t,i,0),this.g.u=this.A,this.A.u=this.A.t=this.A.i=this.g;else{var r,n=this.A.t,o=this.N(n.h,t);if(0===o)n.o=i;else{if(0<o)n.t=new this.m(t,i),r=(n.t.u=n).t,this.A.t=r;else{o=this.A.i,n=this.N(o.h,t);if(0===n)return o.o=i,this.C;if(n<0)o.i=new this.m(t,i),r=(o.i.u=o).i,this.A.i=r;else{if(void 0!==e){n=e.M;if(n!==this.A){o=this.N(n.h,t);if(0===o)return n.o=i,this.C;if(0<o){e=n.v(),o=this.N(e.h,t);if(0===o)return e.o=i,this.C;o<0&&(r=new this.m(t,i),void 0===e.i?(e.i=r).u=e:(n.t=r).u=n)}}}if(void 0===r)for(r=this.g;;){var s=this.N(r.h,t);if(0<s){if(void 0===r.t){r.t=new this.m(t,i),r=(r.t.u=r).t;break}r=r.t}else{if(!(s<0))return r.o=i,this.C;if(void 0===r.i){r.i=new this.m(t,i),r=(r.i.u=r).i;break}r=r.i}}}}if(this.enableIndex)for(var h=r.u;h!==this.A;)h._+=1,h=h.u;this.q(r),this.C+=1}}return this.C},A.prototype.F=function(t,i){for(;t;){var e=this.N(t.h,i);if(e<0)t=t.i;else{if(!(0<e))return t;t=t.t}}return t||this.A},A.prototype.clear=function(){this.C=0,this.g=void 0,this.A.u=void 0,this.A.t=this.A.i=void 0},A.prototype.updateKeyByIterator=function(t,i){t=t.M;if(t===this.A&&v(),1!==this.C){var e=t.p().h;if(t===this.A.t)return 0<this.N(e,i)&&(t.h=i,!0);var r=t.v().h;if(t===this.A.i)return this.N(r,i)<0&&(t.h=i,!0);if(0<=this.N(r,i)||this.N(e,i)<=0)return!1}return t.h=i,!0},A.prototype.eraseElementByPos=function(t){if(t<0||t>this.C-1)throw new RangeError;t=this.P(t);return this.G(t),this.C},A.prototype.eraseElementByKey=function(t){return 0!==this.C&&(t=this.F(this.g,t))!==this.A&&(this.G(t),!0)},A.prototype.eraseElementByIterator=function(t){var i=t.M,e=(i===this.A&&v(),void 0===i.i);return 0===t.iteratorType?e&&t.next():e&&void 0!==i.t||t.next(),this.G(i),t},A.prototype.getHeight=function(){return 0===this.C?0:function t(i){return i?Math.max(t(i.t),t(i.i))+1:0}(this.g)};var d,a=A;function A(t,i){void 0===t&&(t=function(t,i){return t<i?-1:i<t?1:0}),void 0===i&&(i=!1);var e=d.call(this)||this;return e.g=void 0,e.N=t,e.enableIndex=i,e.m=i?h:n,e.A=new e.m,e}i(b,g=f),Object.defineProperty(b.prototype,"index",{get:function(){var t=this.M,i=this.A.u;if(t===this.A)return i?i._-1:0;var e=0;for(t.t&&(e+=t.t._);t!==i;){var r=t.u;t===r.i&&(e+=1,r.t)&&(e+=r.t._),t=r}return e},enumerable:!1,configurable:!0}),b.prototype.isAccessible=function(){return this.M!==this.A};var g,f=b;function b(t,i,e){e=g.call(this,e)||this;return e.M=t,e.A=i,0===e.iteratorType?(e.pre=function(){return this.M===this.A.t&&v(),this.M=this.M.v(),this},e.next=function(){return this.M===this.A&&v(),this.M=this.M.p(),this}):(e.pre=function(){return this.M===this.A.i&&v(),this.M=this.M.p(),this},e.next=function(){return this.M===this.A&&v(),this.M=this.M.v(),this}),e}i(m,w=f),Object.defineProperty(m.prototype,"pointer",{get:function(){this.M===this.A&&v();var r=this;return new Proxy([],{get:function(t,i){return"0"===i?r.M.h:"1"===i?r.M.o:(t[0]=r.M.h,t[1]=r.M.o,t[i])},set:function(t,i,e){if("1"!==i)throw new TypeError("prop must be 1");return r.M.o=e,!0}})},enumerable:!1,configurable:!0}),m.prototype.copy=function(){return new m(this.M,this.A,this.container,this.iteratorType)};var w,M=m;function m(t,i,e,r){t=w.call(this,t,i,r)||this;return t.container=e,t}i(O,C=a),O.prototype.begin=function(){return new M(this.A.t||this.A,this.A,this)},O.prototype.end=function(){return new M(this.A,this.A,this)},O.prototype.rBegin=function(){return new M(this.A.i||this.A,this.A,this,1)},O.prototype.rEnd=function(){return new M(this.A,this.A,this,1)},O.prototype.front=function(){var t;if(0!==this.C)return[(t=this.A.t).h,t.o]},O.prototype.back=function(){var t;if(0!==this.C)return[(t=this.A.i).h,t.o]},O.prototype.lowerBound=function(t){t=this.j(this.g,t);return new M(t,this.A,this)},O.prototype.upperBound=function(t){t=this.S(this.g,t);return new M(t,this.A,this)},O.prototype.reverseLowerBound=function(t){t=this.k(this.g,t);return new M(t,this.A,this)},O.prototype.reverseUpperBound=function(t){t=this.B(this.g,t);return new M(t,this.A,this)},O.prototype.forEach=function(r){this.P(function(t,i,e){r([t.h,t.o],i,e)})},O.prototype.setElement=function(t,i,e){return this.D(t,i,e)},O.prototype.getElementByPos=function(t){if(t<0||t>this.C-1)throw new RangeError;t=this.P(t);return[t.h,t.o]},O.prototype.find=function(t){t=this.F(this.g,t);return new M(t,this.A,this)},O.prototype.getElementByKey=function(t){return this.F(this.g,t).o},O.prototype.union=function(t){var i=this;return t.forEach(function(t){i.setElement(t[0],t[1])}),this.C},O.prototype[Symbol.iterator]=function(){var i,e,r,n;return o(this,function(t){switch(t.label){case 0:i=this.C,e=this.P(),r=0,t.label=1;case 1:return r<i?[4,[(n=e[r]).h,n.o]]:[3,4];case 2:t.sent(),t.label=3;case 3:return++r,[3,1];case 4:return[2]}})};var C,f=O;function O(t,i,e){void 0===t&&(t=[]);var i=C.call(this,i,e)||this,r=i;return t.forEach(function(t){r.setElement(t[0],t[1])}),i}t.OrderedMap=f,Object.defineProperty(t,"H",{value:!0})});
//# sourceMappingURL=ordered-map.min.js.map
{"version":3,"sources":["ordered-map.js"],"names":["exports","sdsl","module","factory","define","global","globalThis","self","this","extendStatics","__generator","body","Object","setPrototypeOf","__proto__","Array","d","b","t","p","prototype","hasOwnProperty","call","__extends","next","TypeError","String","return","constructor","Symbol","verb","g","thisArg","v","f","y","_","label","sent","op","step","trys","ops","throw","iterator","n","done","pop","value","length","SuppressedError","e","push","TreeNode","_right","undefined","_key","key","_pre","isRootOrHeader","preNode","_color","nextNode","_left","_parent","pre","R","V","K","PP","F","_this","TreeNodeEnableIndex","parent","_recount","_rotateRight","_subTreeSize","color","_value","iteratorType","_super","defineProperty","get","_rotateLeft","enumerable","empty","_length","Base","Container","throwIteratorAccessError","ContainerIterator","iter","_node","resNode","curNode","configurable","cmpResult","TreeContainer","_header","RangeError","_lowerBound","parentNode","swapNode","_reverseLowerBound","_cmp","_eraseNodeSelfBalance","brother","param","nodeList","_root","index","_insertNodeSelfBalance","uncle","grandParent","GP","_eraseNode","clear","enableIndex","_inOrderTraversal","pos","callback","stack","compareToMax","maxNode","hint","preCmpRes","_getTreeNodeByKey","parent_1","node","_TreeNodeClass","minNode","compareToMin","nextKey","preKey","iterCmpRes","eraseElementByKey","iterNode","eraseElementByIterator","traversal","max","TreeIterator","header","root","_next","isAccessible","OrderedMapIterator","container","eraseElementByPos","prop","set","hasNoRight","OrderedMap","Math","cmp","x","i","map","Proxy","target","newValue","copy","begin","end","rBegin","rEnd","front","back","lowerBound","upperBound","_upperBound","reverseLowerBound","reverseUpperBound","_reverseUpperBound","forEach","setElement","_set","getElementByPos","find","getElementByKey","union","other","el","_a"],"mappings":";;;;;;UAQWA,EAAAA,GAE2F,U,OAARC,SAAQ,aAAA,OAAAC,OAAAC,EAAAH,OAAAA,EAClFA,YADkFA,OAC7FI,QAAWJ,OAAAA,IAAAA,OAAAA,CAAAA,WAAAA,CAAAA,EAAWG,GAAAE,EAAA,aAAAA,OAAAC,WAAAA,WAAAD,GAAAE,MAAAN,KAAA,EAAA,CAA9B,EAAEO,KAAAA,SAkBKC,GAAgB,aAkBpB,IAAAA,EAASC,SAAqBC,EAAAA,GAV5B,OAPAF,EAkBQG,OAAAC,iBAAA,CAjBNC,UAkBS,E,YACDC,MAAA,SAAAC,EAAAC,GAjBRD,EAAEF,UAkBQG,CAjBZ,EAAK,SAkBCD,EAAOE,GACT,IAAA,IAAAC,KAAAF,EAAAL,OAAAQ,UAAAC,eAAAC,KAAAL,EAAAE,CAAAA,IAAAH,EAAAG,GAAAF,EAAAE,GAjBJ,IAmBSH,EAAAC,CAAAA,CAjBX,EACA,SAsBEM,EAAWP,EAAAC,GArBX,GAsBa,YAtBb,OAsBEO,GAAW,OAAAP,EAAA,MAAA,IAAAQ,UAAA,uBAAAC,OAAAT,CAAAA,EAAA,+BAAA,EApBb,SAsBEU,IArBAnB,KAAKoB,YAsBGC,CArBV,CAHApB,EAsBWqB,EAAAA,CAAAA,EAIXd,EAAAI,UAAIW,OAAAA,EAAAA,OAAAA,OAAAA,CAAAA,GAAAA,EAAAA,UAAAA,EAAAA,UAAAA,IAAAA,EArBN,CACA,SAsBIrB,EAAOsB,EAAUC,GArBnB,IASEC,EACAC,EACAjB,EAXEkB,EAAI,CAuBNC,MAAA,EACFC,KAAA,WACA,GAAcC,EAAdrB,EAASsB,GAAKD,MAAAA,EAAAA,GACZ,OAAOrB,EAAA,EArBL,EACAuB,KAsBA,GArBAC,IAAK,E,EAMFX,EAAI,CACTP,KAAMM,EAAK,CAAA,EACXa,MAASb,EAoBL,CAAA,EAnBJH,OAAUG,EAoBFO,CAAAA,C,EAvBV,MAwBe,Y,OApBLR,SAoBKE,EAAAF,OAAAe,UAAA,WAnBb,OAAOpC,IACT,GAAIuB,EACJ,SAASD,EAAKe,GACZ,OAAO,SAAUZ,GACRO,IAsBHD,EAHF,CAAKM,EAAAZ,GAfT,GAAIC,EAAG,MAmBD,IAAAT,UAAA,iCAAA,EAlBN,KAA8BW,EAAvBL,GAAaQ,EAAPR,EAAI,GAAiB,EAAKK,GAAAA,IACrC,GAAIF,EAkBF,EAAAC,IAAKjB,EAAA,EAAAqB,EAAA,GAAAJ,EAAA,OAAAI,EAAA,GAAAJ,EAAA,SAAAjB,EAAAiB,EAAA,SAAAjB,EAAAI,KAAAa,CAAAA,EAAA,GAAAA,EAAAX,OAAAA,EAAAN,EAAAA,EAAAI,KAAAa,EAAAI,EAAA,EAAA,GAAAO,KAAA,OAAA5B,EAhBP,OADIiB,EAAI,GAkBCC,EAALG,EAAOG,CAAIK,EAAAA,EAAAA,GAAAA,EAAAA,OAjBPR,GAkBJH,IAjBF,KAAK,EACL,KAAK,EACHlB,EAiBFqB,EAhBE,MACF,KAAK,EAmBH,OAlBAH,EAAEC,KAAAA,GAkBF,CAhBEW,MAiBFT,EAAO,GAhBLO,KAAM,CAAA,C,EAmBR,KAAA,EAhBAV,EAAEC,KAAAA,GACFF,EAAII,EAAG,GACPA,EAAK,CAAC,GACN,SAkBA,KAAA,EAhBAA,EAAKH,EAiBLM,IAAIxB,IAAAA,EAhBJkB,EAAEK,KAAKM,IAAAA,EACP,SACF,QAkBE,GAAA,EAAA7B,EAAA,GAAAA,EAAAkB,EAAAK,MAAAQ,QAAA/B,EAAAA,EAAA+B,OAAA,MAAA,IAAAV,EAAA,IAAA,IAAAA,EAAA,IAAA,CAhBEH,EAiBF,EAhBE,QACF,CACA,GAAc,IAAVG,EAAG,KAAO,CAAOrB,GAAKqB,EAAG,GAAKrB,EAAE,IAAMqB,EAAG,GAAKrB,EAAE,IAkBxDqB,EAAAA,MAAUjB,EAAKU,QAdX,GAiBA,IAAJG,EAAI,IAAAC,EAAAC,MAAAnB,EAAA,GACJkB,EAAAC,MAAAnB,EAAA,GACAgB,EAAIhB,MAnBA,CAsBN,GAAAA,EAAAA,GAAOkB,EAAAC,MAAAnB,EAAA,IAAP,CAKJA,EAAA,IAAAkB,EAAAM,IAAAK,IAAAA,EACOG,EAAAA,KAAAA,IAAAA,EACDC,QAHJ,CAHIH,EAAAA,MAAU9B,EAAA,GACV4B,EAAAA,IAAMM,KAAAb,CAAAA,CAHR,C,CAUJA,EAAA5B,EAAAW,KAAAU,EAAAI,CAAAA,CAXI,CAaAiB,MAAwBF,GAC1BZ,EAAA,CAAA,EAASc,GAjBLlB,EAkBF,CAjBA,CAAE,QAmBFD,EAAAhB,EAAA,CAjBA,CACA,GAkBKoC,EAAL9C,EAAAA,GAAc+C,MAAAA,EAAAA,GAjBd,MAkBA/C,CAjBEwC,MAkBGQ,EAAAA,GAAOC,EAAAA,GAAAA,KAAAA,EAjBVX,KAkBFtC,CAAAA,C,CA9EA,CACF,CA8DF,CA6CE6C,EAAAjC,UAAAsC,EAAA,WAKAL,IAAAA,EAASjC,KACPuC,EAAenD,EAAAA,EAAAA,IAAAA,EA1Bf,GA2BAmD,GAAqB,IAAAC,EAAAC,EA1BnBD,EA2BWE,EAASR,OA1Bf,GA2BLM,EAAgBG,EAEhB,IA5BAH,EA2BEE,EAAoBC,EACtBH,EAAAN,GA1BEM,EA2BFA,EAAOE,MAzBF,CAEL,GAAIH,EACF,OAAOC,EA2BQI,EAxBjB,IADA,IAAIC,EA2BAH,EAAoBG,EA1BjBA,EA2BLF,IAAOE,GAEXA,GADEL,EAAAK,GACFD,EAMFX,EAASjC,CA9BP,CACA,OA+BAwC,CA9BF,EAKAP,EA+BE7C,UAAc0D,EAAAA,WA9Bd,IA+BAJ,EAASE,KA9BT,GA+BAF,EAAOK,EAAAA,CAMTd,IALAS,EAAAA,EAAAR,EAKSlC,EAAAA,GACP0C,EAAStD,EAAKwD,EAjCZ,OAmCEI,CAlCJ,CAEE,IADA,IAmCAJ,EAAUK,EAAAA,EACVf,EAAS9C,IAAAA,GAEXA,GADAA,EAAe8D,GACFF,EAjCX,OAmCFN,EAAOQ,IAAAA,EACTL,EACOZ,CAET,EA9BEA,EAmCEjC,UAAOmD,EAAAA,WACT,IAAAF,EAAA7D,KAAAwD,EAKAQ,EAAAA,KAAAA,EACEN,EAAIO,EAAAA,EAhCJ,OAiCAjE,EAAAA,IAAKkE,KAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,KAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAtCLP,EAAEH,EAuCKU,GAtCPP,EAAEJ,EAuCFvD,MACFwD,EAAAG,GAKAK,KAAAA,EAAAA,KACEN,EAAIO,EAAgBrD,MACpBZ,CA1CF,EAKA6C,EA2CEjC,UAAgBuD,EAAA,WA1ChB,IAAIN,EA2CF7D,KAAKoE,EACPN,EAAA9D,KAAAuD,EACAK,EAAI5D,EAAAA,EAWN,OArDM6D,EAAGL,IA2CgBxD,KAAYoE,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,KAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EACnCN,EAAAN,EAAAK,GACFC,EAAAhB,EAAA9C,MACAwD,EAAOQ,GACPnB,KAAAA,EAAAA,KAEmCe,EAAAJ,EAAAxD,MAInC8D,CA9CA,EA9FF,IAAIjB,EA+FKA,EA9FP,SAASA,EAsBEO,EAAgBZ,EAAA6B,GArBrBA,KAAAA,IAAAA,IAuBFA,EAAA,GApBFrE,KAAKuD,EAuBCJ,KAAAA,EAtBNnD,KAAK8C,EAuBDC,KAAAA,EACF/C,KAAAwD,EAAAT,KAAAA,EAtBF/C,KAAKgD,EAuBCS,EAtBNzD,KAAKsE,EAuBH9B,EAtBFxC,KAAKqD,EAuBDD,CAtBN,CAsIArC,EAAAiD,EADsBO,EAVtB1B,CAWA2B,EArCAR,EAyDOS,UAAoB7D,EAAW,WAxDpC,IA+DA8D,EAAKF,EAAA5D,UAAA+D,EAAA7D,KAAAd,IAAAA,EA5DL,OAFAA,KAAKkE,EAAAA,EAgELD,EAAAC,EAAAA,EACAU,CA9DF,EAKAZ,EA2Eea,UAAQV,EAAA,WA1ErB,IA2EAF,EAAOjE,EAAK8E,UAAYX,EAAArD,KAAAd,IAAAA,EArCJ,OAsCtBA,KAAAkE,EAAAA,EACAD,EAAOc,EAAAA,EAvCed,CAyCxB,EA1EED,EA2EUgB,UAAWR,EAAAA,WACrBxE,KAAAoE,EAASY,EACPhF,KAAAuD,IACFvD,KAAAoE,GAAApE,KAAAuD,EAAAa,GAEAW,KAAAA,IAMF/E,KAASiF,GAAAA,KAAAA,EAAAA,EAET,EAnHA,IA+CwBV,EA/CpBP,EAqH6BA,EAnH/B,SAqDAkB,IApDE,IAqDAnB,EAAsBoB,OAAfnF,GAAoBoF,EAAAA,MAAAA,KAAAA,SAAAA,GAAAA,KAE7B,OADArB,EAAAK,EAAA,EACOc,CAnB4B,CAgBnCA,EAuFSnB,UAAAA,OAAAA,SAAAA,GACT,OAAA/D,KAAAoF,IAAAD,EAAAC,CAtFA,EAlBF,IAAIF,EA6GAA,EAzGF,SAASA,EAoFIX,GAhFXvE,KAAKuE,aAkFLA,EADEA,KAAAA,IAAAA,EACF,EAEgBA,CAChB,CAvEF,SAASQ,IA+FL/E,KAAA8E,EAAO,CACT,CAzFF1E,OA0FEqE,eAAOY,EAAAA,UAAAA,SAAAA,CAnFPX,IAAK,WA8FH,OAAA1E,KAAA8E,CA5FF,EACAF,WA6FIU,CAAAA,EACFC,aAAA,CAAA,C,GArFJR,EAAKnE,UAgGG4E,KAAe,WA/FrB,OAAOxF,KAgGHqF,CA/FN,EAOAN,EAmGAU,UAAAA,MAAc7E,WAlGZ,OAmGmB8E,IAAnB1F,KAAcA,CAlGhB,EAIAe,EAAUiE,EAkGMM,EArGTP,CAsGiBjC,EApG1B,IAmGkBwC,EAnGdN,EAwGAA,EAHE,SAAAA,IAlGF,OAmGsBzB,OAnGfiB,GAmGejB,EAAAA,MAAAA,KAAAA,SAAAA,GAAAA,IACpB,CA3FN,SAAS0B,IACP,MAAM,IAAIU,WAsGa,yBAAA,CArGzB,CAGE5E,EAAU0E,EAqG4BjB,EAslBtCQ,CArlB+BlC,EAzE/B2C,EAAc7E,UAsGcgF,EAAA,SAAAN,EAAArC,GApG1B,IADA,IAAIoC,EAAUrF,KAsGR0F,EArGCJ,GAAS,CAuGV,IAAAE,EAAAxF,KAAO6F,EAAW1B,EAAAA,EAAAA,CAAAA,EACpB,GAAAqB,EAAA,EArGAF,EAAUA,EAsGI/B,MArGT,CAAA,GAAIiC,EAsGGnC,EAtGHmC,GAGJ,OAAOF,EADZA,GADAD,EAAUC,GAuGE/B,CArGA+B,CAChB,CAuGQ,OAAAD,CArGV,EAIAI,EAAc7E,UAsGI+D,EAAAA,SAAAA,EAAAA,GApGhB,IAqGM,IAAAU,EAAArF,KAAA0F,EArGCJ,GAyGHA,EAxGctF,KAsGVsF,EAAUO,EAAAA,EAAAA,CAAAA,GACZ,EACFP,EAAAxC,GAEJuC,EAAAC,GACF/B,EAnGE,OAAO8B,CACT,EAIAI,EAyGQK,UAAiBC,EAAA,SAAAT,EAAArC,GAvGvB,IADA,IAAIoC,EAyGAS,KAAoBhD,EAxGjBwC,GAyGH,CACF,IAAAE,EAAOxF,KAAAgG,EAAAV,EAAAtC,EAAAC,CAAAA,EAxGP,GAAIuC,EAyGkBjC,EAvGpB+B,GAwGFD,EAAAC,GACkBtC,MAClBsC,CAAAA,GAAQtC,EAAgBA,EAAhBA,GAER,OAAYsC,EA1GVA,EAyGcrC,EAAAA,CACJqC,CAxGd,CACA,OAAOD,CACT,EA6GEI,EAAO7E,UAAiBkC,EAAqB,SAAAwC,EAAArC,GAE7C,IA1GA,IAAIoC,EAyGGK,KAAiBI,EACxBR,GArGIA,EAsGuBQ,KAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EACJtC,GACvB6B,EAAiB7B,GACCT,EAEFuC,EAAA/B,EAtGhB,OAAO8B,CACT,EA6GAI,EAAA7E,UAAAqF,EAAA,SAAAX,GAIAG,OAAAA,CA3GI,IAiCMS,EA2ERL,EAAiBM,EAAU3C,EA3GzB,GA4GFqC,IAAsBM,KAAUT,EAAA,OA3G9B,GA4G8B,IAAhCJ,EAAIc,EAEJ,OADAd,KAAAA,EAAYjC,EAAA,GAzGV,GA4GFiC,IAAa7C,EAAmBc,EA1G5B,GA4GW+B,KA5GPY,EA2GOL,EAAA/C,GACLF,EA3GJsD,EA4GFZ,EAAkB/B,EACpBsC,EAAOxC,EAAA,EA3GCwC,IA4GUtD,KAAAA,EA3GZvC,KA4GJqG,EAAIC,EAAsBhB,EAAAA,EAC1Bc,EAA0Bd,EAAAA,MA3GnB,CACL,GAAIY,EA4GGpD,GAAA,IAAAoD,EAAApD,EAAAO,EAUb,OArHQ6C,EA4GMZ,EAAQxC,EAAAA,EACpB+C,EAAAxC,EAAA,EACF6C,EAAApD,EAAAO,EAAA,EA9GQ6C,KA+GDE,IAAAA,KAAAA,EACTpG,KAAAqG,EAAAR,EAAAlB,EAAAA,EAIc/D,EAAU2F,EAAAA,GAEHjB,EAAQ9B,GAAAA,IAAAA,EAAAA,EAAAA,GACzB0C,EAAe7C,EAAwC,EACvD6C,EAAkBL,EAAWrC,EAAAA,EAC7B0C,EAAIL,EAAAA,IA7GEK,EA+GAM,EAAenD,EA9GfiC,EA+GIjC,EA7GR,MAkHA,GAAWiC,KAAXY,EADEL,EAAAtC,GACFF,EA9GE6C,EAAQ7C,EA+GS,EA9GjBwC,EA+GAxC,EAAmB,EA9GfwC,IA+GYrC,KAAUqC,EAC1B7F,KAAAqG,EAAAR,EAAA1B,EAAAA,EA9GO0B,EA+GK/C,EAAAA,MA9GP,CAgHL,GAAAoD,EAAA3C,GAAA,IAAA2C,EAAA3C,EAAAF,EAxGE,OANA6C,EA+GFL,EAA4BtC,EAAAA,EA9G1BsC,EA+GUtC,EAAgBT,EA9G1BoD,EA+GFZ,EAAgBO,EAAAA,EAjHdK,KAGIL,IA+GWY,KAAAA,EA9GbzG,KAAKqG,EA+GLI,EAA4BtC,EAAAA,EA9GvB0B,EA+GFQ,EAAAA,GAEPH,EAAOpD,GAAA,IAAAoD,EAAApD,EAAAO,GA9GL6C,EAAQ7C,EA+GJqD,EA9GJR,EAAQpD,EA+GRO,EAAiBoD,EA9GjBP,EAAQvB,EAAAA,IAiHVuB,EAAA7C,EAAA,EA9GEiC,EA+GM9B,EA7GV,CAiHA,CA9GN,EAIAiC,EAAc7E,UA+Ge+F,EAAA,SAAArB,GA9G3B,GA+GM,IA/GFtF,KAAK8E,EAgHL9E,KAAA4G,MAAAA,MAhHJ,CAKA,IADA,IAAId,EA+GAR,EA9GGQ,EA+GDU,GAA0BnD,EAASP,GAAA,CA9GvC,GAAIgD,EAAShD,EAEX,IADAgD,EAAWA,EA+GYhD,EA9GhBgD,EA+GKW,GAAAA,EAAAA,EAAAA,OAEZX,EAAAA,EAAWR,EA7Gb,IAAIrC,EAAMqC,EA+GFA,EA5GJ9C,GAFJ8C,EAAQtC,EAAO8C,EA+GKtC,EAChBsC,EAAA9C,EAAAC,EA9GQqC,EA+GIxC,GA9GhBwC,EAAQhB,EAASwB,EA+GcD,EAC3BC,EAAAxB,EAAA9B,EA9GJ8C,EAAUQ,CACZ,CACI9F,KAAK0F,EA+GHJ,IAAgBmB,EA9GpBzG,KAAK0F,EAAQnC,EA+GQsC,EAAAA,EA9GZ7F,KA+GL0F,EAAIe,IAA4BX,IA9GpC9F,KAAK0F,EAAQ5C,EA+GP9C,EAAasF,GAEftF,KAAAiG,EAAOH,CAAAA,EA9Gb,IAAItC,EAAUsC,EA+GNtC,EAzGR,GALIsC,IAAatC,EA+GLkD,EA9GVlD,EAAQD,EAAQR,KAAAA,EAgHVS,EAAAV,EAAAC,KAAAA,EACF/C,EAAAA,KAAA8E,EA9GN9E,KAAKqG,EAAMhD,EA+GGG,EA9GVxD,KAAK6G,YACP,KAAOrD,IA+GSA,KAAU8B,GA9GxB9B,EAAAA,EAAQY,EAgHRZ,EAAAA,EAAOA,CA/IX,CAmCF,EAmHMiC,EAAA7E,UAAAkG,EAAA,SAAAX,GAxGJ,IAyGE,IAAAY,EAAA,UAAAA,OAAAZ,EAAAA,EAAApD,KAAAA,EA9GEiE,EA+GoB,YA/GpBA,OA+GOH,EAAaV,EAAApD,KAAAA,EA9GpBqD,EA+GWlC,KAAAA,IAAAA,EAAAA,GAAAA,KAAAA,EA9GXoC,EA+GAG,EA9GAnB,EA+GQpB,KAAAA,EACV+C,EAAA,GA9GKA,EA+GLxE,QAAA6C,GACF,GAAAA,EACF2B,EAAArE,KAAA0C,CAAAA,EAIAG,EAAc7E,EAAAA,MACRZ,CAhHA,GADAsF,EAkHGR,EAAWvC,IAAAA,EAChBvC,IAAa+G,EAAI/G,OAAoBiD,EAjHnCmD,GAkHS5C,EAAekC,KAAAA,CAAAA,EAjHxBsB,GAkHWxD,EAAekC,EAAgB1F,EAAsBA,IAAAA,EAjHhEsG,GAkHF,EACFhB,EAAAA,EAAAxC,CAjHE,CAEF,OAkHAsD,CAjHF,EAIAX,EAkHYlC,UAAYvD,EAAyBwC,SAAAA,GAjH/C,OAkHgBgB,CAjHd,IAAIqC,EAkHctC,EAAAA,EAjHlB,GAkHqB+B,IAlHjBO,EAkHStC,EAAQ+B,OACvB,IAvEQkB,EAyIJxG,EAlEJyG,EAAOZ,EAAArC,EAjHL,GAAIqC,IAkHeH,EAAQ5C,EAlH3B,CAEE,IAkHF0D,EADmBxG,EAAwBiD,IACnB,IAApBiE,EAAoB7D,EAAA,CAhHpB,GADAmD,EAkHFW,EAAiB3E,EAAAA,EAAAA,EAjHXiE,IAkHM3B,KAAAA,EAAAA,OACd2B,EAAOpD,EAAsB,EAjHzBiC,EAkHMxC,EAjHN,QACF,CAAO,GAkHPwC,IAAkBxC,EAAAA,EAnFhB,OA6GI+C,EAAAxC,EAAA,EACJoD,IAAAzG,KAAAqG,EACFrG,KAAAqG,EAAAI,EAAAtC,EAAAA,EACAsC,EAAgB1D,EAAAA,EAHV8C,KA9GJY,EAkHAnB,EAAee,GA/Iff,EAkHFtF,EAAsBsF,EACxBA,EAAO/B,IAjHD+B,EAkHA8B,EAASrE,EAAAA,GAhHPuC,EAkHJxC,IAjHEwC,EAAQxC,EAkHRU,EAAsBwC,GAhHxBH,EAAW/C,EAkHEwB,EAAS9B,EAjHtBiE,EAAYlD,EAkHR+B,EAAOtF,EACTsF,EAAA/B,EAAAsC,GAjHFP,EAAQxC,EAAS2D,KAmHXzG,KAAIqH,GAjHRrH,KAAKqG,EAAQf,EACbtF,KAAK0F,EAAQlC,EAkHCc,IA/GVoC,EAiHAD,EAAAjD,GAjHGD,IAAUkD,EACfC,EAAGnD,EAAQ+B,EACNoB,EAAG5D,EAASwC,CAuDzB,KAlFA,CA2CE,IAAIkB,EADQC,EAkHFnB,IACc,IAlHXkB,EAAMnD,EAkHkCb,CAhHnD,GADAgE,EAAMnD,EAASwC,EAkHKrC,EAAU8B,EAjH1BmB,IAAgBzG,KAkHdsF,EAAkB/B,OAjHxBkD,EAAYpD,EAAS,EAmHjBiC,EAAAmB,EAjHJ,QAmHE,CAAA,GAAAnB,IAAOO,EAAmBtC,EAnF5B,OA6GRsC,EAAAxC,EAAA,EAIAoC,IAAwB6B,KAAoBjB,EAC1CrG,KAAOsF,EAASmB,EAAA9B,EAAAA,EACVa,EAA8BxC,EAAAA,EANtC6C,KA9GQY,EAqHYpD,EAAG,GAlJfiC,EAAQjC,EAAS,EACbiC,EAAQ/B,IACV+B,EAAQ/B,EAAMC,EAkHKA,GAhHjB8B,EAAQxC,IAmHRwC,EAAAxC,EAAAU,EAAAqC,GAEFY,EAAA3D,EAAOwC,EAAA/B,EAjHTsC,EAAWtC,EAkHP+B,EAAiB9C,EAjHrB8C,EAAQ/B,EAAQkD,EAmHdnB,EAAAxC,EAAA+C,EACFY,IAAAzG,KAAAqG,GACFrG,KAAAqG,EAAAf,EACFtF,KAAA0F,EAAAlC,EAAA8B,IAGIiC,EADGV,EAAarD,GAChB+D,IAAmB/D,EACvBkD,EAAAnD,EAAoBvD,EACToE,EAAAA,EAAgBkB,CApG3B,CAMA,OAgGAA,EAAA9B,EAAAiD,EAAAjD,EACFqC,EAAArC,EAAA8B,EACAtF,EAA4BsF,EAAAA,EAC5BtF,EAAgBqD,EAAA,EAHdiC,KAgBAtF,KAAA6G,cACFhB,EAAA3B,EAAAA,EACAuC,EAAkBzG,EAAAA,EACpBsF,EAAApB,EAAAA,GAlHE,CACF,EAIAuB,EA+HaN,UAAKC,EAAAA,SAAAA,EAAAA,EAAAA,GA9HhB,GA+HkBM,KAAAA,IAAlB1F,KAAIwH,EA9HFxH,KAAK8E,GA+HLG,EACFjF,KAAAqG,EAAA,IAAArG,KAAAyH,EAAAxE,EAAAT,EAAA,CAAA,EA9HExC,KA+HFqG,EAASvB,EAAe9E,KAAA0F,EA9HtB1F,KAAK0F,EA+HOzC,EAAAA,KAAAA,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,KAAAA,MAnId,CAOA,IA+HAqC,EACAoC,EAAa1H,KAAK0F,EAAenC,EA9H7BoE,EA+HYC,KAAS3E,EAAOyE,EAAG1E,EAAAC,CAAAA,EA9HnC,GA+HgBA,IA/HZ0E,EACFD,EAAQpD,EA+HC9B,MAhIX,CAGO,GA+HE,EAAPmF,EACFD,EAAAnE,EAAA,IAAAvD,KAAAyH,EAAAxE,EAAAT,CAAAA,EA7HE8C,GADAoC,EA+HEG,EAAc3E,EAAOF,GACP0C,EA9HhB1F,KAAK0F,EA+HD1F,EAAkBiD,MA9HjB,CACDkE,EA+HFnH,KAAO0F,EAAA5C,EACToE,EAAAlH,KAAAgG,EAAAmB,EAAAnE,EAAAC,CAAAA,EA9HA,GA+HO,IA/HHiE,EAiIN,OADAC,EAAA7C,EAAA9B,EACIxC,KAAU6H,EACT7E,GAAOC,EAAAA,EACZkE,EAAOrE,EAAA,IAAA9C,KAAAyH,EAAAxE,EAAAT,CAAAA,EAETiD,GADA0B,EAAArE,EAAAU,EAAA2D,GACcvG,EACZZ,KAAI+G,EAAWA,EAAWjC,MACxB,CACF,GAAA/B,KAAAA,IAAAqE,EAAA,CACII,EAA8BT,EAAAA,EAClC/G,GAAK2G,IAAWa,KAAAA,EAAAA,CACTxH,EAAK8E,KAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EACd,GAAA,IAAAgD,EAOM9H,OADNyF,EAAc7E,EAAUmH,EACbjD,KAAeA,EACyB7B,GAAAA,EAAAA,EAAAA,CACjCjD,EAAcgI,EAAO9E,EAAAA,EACrBoC,EAAAA,KAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EACT,GAAA,IAAA+B,EAEKzG,OADdwC,EAAAkB,EAAA9B,EACc5B,KAAUqH,EACN7C,EAAAA,IACHpF,EAAc,IAAAA,KAAAyH,EAAAxE,EAAAT,CAAAA,EACzByC,KAAAA,IAAAA,EAAAA,GACF7B,EAAAN,EAAAwC,GACiCvC,EAAAA,GAGnBiF,EAAAzE,EAAA+B,GAEStE,EAAAA,EAKvB,CACAhB,CACA,CACF,GAAA+C,KAAAA,IAAAuC,EAME,IADFG,EAAc7E,KAAAA,IACS,CACrB,IAAA4E,EAAmBF,KAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EACjB,GAAqB,EAArBE,EAAqB,CACrB,GAAgB0C,KAAAA,IAAhB5C,EAAY6C,EAA8BD,CAC5C5C,EAAA/B,EAAA,IAAAvD,KAAAyH,EAAAxE,EAAAT,CAAAA,EAEF8C,GADS4C,EAAAA,EAAe7B,EAAAA,GACxB9C,EACOkC,KACPT,CAE8BM,EAAUd,EAAAA,CACxCzD,KAAUqH,CAAAA,GAAAA,EAAAA,EAAc5D,GAnIZ,OA+INc,EAAAhB,EAAA9B,EACK4C,KAAQpF,EATVoI,GAA2B7D,KAAAA,IAA3B6D,EAAaZ,EAAcjD,CACtBC,EAAYxE,EAAMuE,IAAiBvE,KAAAA,EAAAA,EAAAA,CAAAA,EAE/BqI,GADFb,EAAAA,EAAAA,EAAAA,GACEa,EACN9D,KACFd,CA/IE6B,EAgJFtF,EAAeA,CA5If,CAiJN,CA9IA,CACF,CAiJI,GAAAA,KAAA6G,YA9IF,IADA,IAAIU,EAgJGnC,EAAQpF,EA/IRuH,IAgJEvH,KAAAA,GACTuH,EAAAnD,GAAA,EACFmD,EAAOA,EAAA/D,EA7IPxD,KAAKuG,EAgJCtB,CAAAA,EACFjF,KAAA8E,GAAA,CAzJJ,CAkDA,CAxCA,OAAO9E,KAgJHA,CA/IN,EAIAyF,EAAc7E,UAgJNqE,EAAAA,SAAAA,EAAAA,GACF,KAAAK,GAAA,CA/IF,IAAIE,EAgJGJ,KAAQpF,EAAWkD,EAAAA,EAAAA,CAAAA,EA/I1B,GAAIsC,EAgJF,EACFF,EAAAA,EAAAxC,MACF,CAAA,GAAA0C,EAAA,EAAAA,GAEF,OAAAF,EADEA,EAAOvB,EAAAA,CACTuB,CACAlF,CA/IE,OAyJAsE,GAAK1E,KAAA0F,CAxJP,EACAD,EAyJQ6C,UAAY5C,MAAQlC,WAxJ1BxD,KAAK8E,EAyJCM,EAxJNpF,KAAKqG,EAyJDtD,KAAAA,EAxJJ/C,KAAK0F,EAAQlC,EAyJA8E,KAAAA,EACTtI,KAAA0F,EAAAnC,EAAAvD,KAAA0F,EAAA5C,EAAAC,KAAAA,CAxJN,EAWA0C,EAAc7E,UAyJJ0F,oBAAuBlC,SAAAA,EAAAA,GACzBoD,EAAArC,EAAAC,EArJN,GAsJIoC,IAAAxH,KAAA0F,GAxJFT,EAAAA,EA2JOqB,IAzJLtG,KAyJF8E,EAzJF,CAIA,IAAI8C,EAAUJ,EAAKe,EAAAA,EAAQvF,EA0J7BoF,GAAAA,IAAaxH,KAAAA,EAAU4H,EAxJnB,OAyJyB9C,EAA3B1F,KAAOA,EAAKoF,EAAUpF,CAAAA,IACxBwH,EAAAxE,EAAAC,EACOmF,CAAAA,GAKP,IAAAP,EAASY,EAAAA,EAAAA,EAAAA,EAzJP,GA0JAjB,IAAYhD,KAAO1D,EAAW0G,EAzJ5B,OA0JIkB,KAAAA,EAAAA,EAAYA,CAAAA,EAAAA,IAClBlB,EAAAxE,EAAOe,EACT,CAAA,GAtJE,GA0JIkB,GA1JAjF,KAAKgG,EA0JLf,EAAAA,CAAAA,GAAAA,KAAAA,EAAAA,EAAAA,CAAAA,GAAAA,EAAAA,MAAAA,CAAAA,CA3KJ,CAmBA,OAyJEuC,EAAAxE,EAAAC,EAzJK,CAAA,CACT,EACAwC,EA0JMf,UAAKiE,kBAAkBC,SAAAA,GAzJ3B,GAAI7B,EAAM,GAAKA,EA0JL6B,KAAS9D,EAAK,EAzJtB,MAAM,IAAIa,WAER6B,EAAOxH,KA0JL8G,EAAc8B,CAAAA,EAxJpB,OAyJI5I,KAAA2G,EAAAa,CAAAA,EAzJGxH,KA0JH6I,CAzJN,EAMApD,EAAc7E,UAAUmH,kBAAoB,SAAU9E,GA2JpD,OAAA,IAAAjD,KAAA8E,IACAF,EAAAA,KAAY0C,EAAAtH,KAAAqG,EAAApD,CAAAA,KACZsC,KAAcG,IAzJd1F,KAAK2G,EAAWrB,CAAAA,EA2JlBmD,CAAAA,EAzJA,EA2JAhD,EAAA7E,UAAAqH,uBAAA,SAAA9C,GACA,IAAAqC,EAAOiB,EAAAA,EAcPK,GAbAV,IAAAA,KAAAA,GACEW,EAAAA,EAYkClC,KAAAA,IAA3BkC,EAAWL,GAxJlB,OAyJ0B,IAAtBA,EAAmBnE,aAIvBuE,GAAW/E,EAAAA,KAAAA,EAIX+E,GAAO/E,KAAAA,IAAAA,EAAAA,GAAAA,EAAAA,KAAAA,EAETgF,KAAAA,EAAWnI,CAAAA,EACTuE,CACF,EA/JAM,EAoKS7E,UAA4B8E,UAAuBA,WAC5D,OAAA,IAAA1F,KAAA8E,EAAA,EAEAiE,SAAAA,EAAWnI,GApKP,OAqKF0E,EACF0D,KAAAb,IAAAD,EAAA5C,EAAA/B,CAAAA,EAAA2E,EAAA5C,EAAAxC,CAAAA,CAAAA,EAAA,EADqC4C,CAGrCqD,EACWjE,KAAeuB,CAAAA,CArK1B,EAphBF,IAsGwC7B,EAtGpCiB,EA2rBAA,EAtrBF,SAASA,EAsGGI,EAAe7F,GArGrBiJ,KAAAA,IAAAA,IAuGEA,EAAA,SAAAC,EAAAvH,GACF,OAAAuH,EAAAvH,EAAA,CAAO,EArGCA,EAAJuH,EAsGUpG,EArGP,CACT,GAEE+D,KAAAA,IAAAA,IACFA,EAAc,CAAA,GAEhB,IAAI9C,EAAQS,EAAO1D,KAsGXd,IAAAA,GAAAA,KASJ,OA3GJ+D,EAAMsC,EAAQtD,KAAAA,EAuGRgB,EAAAiC,EAAAiD,EArGNlF,EAAM8C,YAsGEX,EArGRnC,EAAM0D,EAsGEnC,EAAUO,EAAAA,EACZ9B,EAAA2B,EAAA,IAAA3B,EAAA0D,EACF1D,CACF,CAyZJhD,EAsKMoG,EADoB3C,EAoG/BU,CAnGkCpC,EA2D7B1C,OAAAqE,eAAA2D,EAAAxH,UAAA,QAAA,CA9KE8D,IAwLA,WAvLE,IAAIU,EAwLJpF,KAAW6B,EAvLPyG,EAwLFtI,KAAK0F,EAAAlC,EAvLP,GAAI4B,IAwLSpF,KAAK8E,EAvLhB,OAAIwD,EAyLFa,EAAI/E,EAAA,EAtLC,EAET,IAAIkC,EAuLA,EAnLJ,IAHIlB,EAuLAoC,IAtLFlB,GAuLElB,EAAO7B,EAAca,GArLlBgB,IAsLAkD,GAAA,CArLL,IAAI9E,EAsLC1B,EAAAA,EArLDsD,IAsLCvD,EAAQiB,IArLXwD,GAAS,EAsLX9C,EAAKD,KApLD+C,GAqLA6C,EAAAA,EAAAA,GAlLJ/D,EAoLA5B,CAnLF,CACA,OAAO8C,CAqLT,EACF1B,WAAA,CAAA,EAEAW,aAAOwD,CAAAA,C,GAGDA,EAAaA,UAAAA,aAAAA,WAErB3I,OAAOqE,KAAAA,IAAwBzE,KAAc0F,CAtL3C,EAlFF,IAsK4BlB,EAtKxB4D,EAmFKA,EA9EP,SAsKEA,EAA+BpI,EAAKqG,EAAOpD,GAC3Cc,EAAOS,EAAuBa,KAASrF,KAAcA,CAAAA,GAAAA,KApIrD,OAqIF+D,EAAAqB,EAAAoC,EACAuB,EAAAA,EAAWnI,EACkCqC,IAA3Cc,EAAIsB,cArKFtB,EAsKFN,IAAO,WAKT,OAJAzD,KAAAoF,IAAApF,KAAA0F,EAAAnC,GACAwF,EAAAA,EAEE/I,KAAAoF,EAA8BC,KAASrF,EAAcA,EAAAA,EACvDA,IACA+I,EArKIhF,EAsKEsB,KAAUrF,WAjKV,OAkKJA,KAAOoF,IAAgCpF,KAAcA,GACvDiF,EAAAA,EAEEjF,KAAK8G,EAAkB9G,KAAUwH,EAAa4B,EAAAA,EACnCpJ,IACX,IAcF+I,EAAAA,IAAWnI,WA7KL,OA8KJZ,KAAOA,IAAewC,KAAO4E,EAAAA,GAC/BnC,EAAAA,EAEEjF,KAAI+G,EAAWA,KAAM/G,EAAK8E,EAAAA,EACxB9E,IACF,EAjLE+D,EAkLEyD,KAAOxH,WAKX,OAJAA,KAAQwH,IAAgBlD,KAAAA,GAC1BW,EAAAA,EAEEjF,KAAIsF,EAAegC,KAAkBtH,EAAYiD,EAAAA,EAC1CjD,IACT,GAQE+D,CAvLF,CA8CAhD,EAAU0H,EADoCjE,EAoC9C4D,CAnC8B5D,EAM9BpE,OAAOqE,eAAegE,EAAmB7H,UAAW,UAAW,CAC7D8D,IAAK,WACC1E,KAAKoF,IAAUpF,KAAK0F,GACtBT,EAAAA,EAEF,IAAIlF,EAAOC,KACX,OAAO,IAAIqJ,MAAM,GAAI,CACnB3E,IAAK,SAAU4E,EAAQV,GACrB,MAAa,MAATA,EAAqB7I,EAAKqF,EAAMpC,EAAuB,MAAT4F,EAAqB7I,EAAKqF,EAAMd,GAClFgF,EAAO,GAAKvJ,EAAKqF,EAAMpC,EACvBsG,EAAO,GAAKvJ,EAAKqF,EAAMd,EAChBgF,EAAOV,GAChB,EACAC,IAAK,SAAUjH,EAAGgH,EAAMW,GACtB,GAAa,MAATX,EACF,MAAM,IAAI3H,UAAU,gBAAA,EAGtB,OADAlB,EAAKqF,EAAMd,EAASiF,EACb,CAAA,CACT,C,EAEJ,EACA3E,WAAY,CAAA,EACZW,aAAc,CAAA,C,GAEhBkD,EAAmB7H,UAAU4I,KAAO,WAClC,OAAO,IAAIf,EAAmBzI,KAAKoF,EAAOpF,KAAK0F,EAAS1F,KAAK0I,UAAW1I,KAAKuE,YAAAA,CAC/E,EAlCF,IAAgDC,EAA5CiE,EAmCKA,EAjCP,SAASA,EAAmBjB,EAAMa,EAAQK,EAAWnE,GAC/CR,EAAQS,EAAO1D,KAAKd,KAAMwH,EAAMa,EAAQ9D,CAAAA,GAAiBvE,KAE7D,OADA+D,EAAM2E,UAAYA,EACX3E,CACT,CAgCAhD,EAAUgI,EAD4BvE,EAyItCiB,CAxIsBjB,EAsBtBuE,EAAWnI,UAAU6I,MAAQ,WAC3B,OAAO,IAAIhB,EAAmBzI,KAAK0F,EAAQnC,GAASvD,KAAK0F,EAAS1F,KAAK0F,EAAS1F,IAAAA,CAClF,EACA+I,EAAWnI,UAAU8I,IAAM,WACzB,OAAO,IAAIjB,EAAmBzI,KAAK0F,EAAS1F,KAAK0F,EAAS1F,IAAAA,CAC5D,EACA+I,EAAWnI,UAAU+I,OAAS,WAC5B,OAAO,IAAIlB,EAAmBzI,KAAK0F,EAAQ5C,GAAU9C,KAAK0F,EAAS1F,KAAK0F,EAAS1F,KAAM,CAAA,CACzF,EAEA+I,EAAWnI,UAAUgJ,KAAO,WAC1B,OAAO,IAAInB,EAAmBzI,KAAK0F,EAAS1F,KAAK0F,EAAS1F,KAAM,CAAA,CAClE,EAEA+I,EAAWnI,UAAUiJ,MAAQ,WAC3B,IACInC,EADJ,GAAqB,IAAjB1H,KAAK8E,EAET,MAAO,EADH4C,EAAU1H,KAAK0F,EAAQnC,GACXP,EAAM0E,EAAQpD,EAChC,EACAyE,EAAWnI,UAAUkJ,KAAO,WAC1B,IACI3C,EADJ,GAAqB,IAAjBnH,KAAK8E,EAET,MAAO,EADHqC,EAAUnH,KAAK0F,EAAQ5C,GACXE,EAAMmE,EAAQ7C,EAChC,EACAyE,EAAWnI,UAAUmJ,WAAa,SAAU9G,GACtCoC,EAAUrF,KAAK4F,EAAY5F,KAAKqG,EAAOpD,CAAAA,EAC3C,OAAO,IAAIwF,EAAmBpD,EAASrF,KAAK0F,EAAS1F,IAAAA,CACvD,EACA+I,EAAWnI,UAAUoJ,WAAa,SAAU/G,GACtCoC,EAAUrF,KAAKiK,EAAYjK,KAAKqG,EAAOpD,CAAAA,EAC3C,OAAO,IAAIwF,EAAmBpD,EAASrF,KAAK0F,EAAS1F,IAAAA,CACvD,EACA+I,EAAWnI,UAAUsJ,kBAAoB,SAAUjH,GAC7CoC,EAAUrF,KAAK+F,EAAmB/F,KAAKqG,EAAOpD,CAAAA,EAClD,OAAO,IAAIwF,EAAmBpD,EAASrF,KAAK0F,EAAS1F,IAAAA,CACvD,EACA+I,EAAWnI,UAAUuJ,kBAAoB,SAAUlH,GAC7CoC,EAAUrF,KAAKoK,EAAmBpK,KAAKqG,EAAOpD,CAAAA,EAClD,OAAO,IAAIwF,EAAmBpD,EAASrF,KAAK0F,EAAS1F,IAAAA,CACvD,EACA+I,EAAWnI,UAAUyJ,QAAU,SAAUrD,GACvChH,KAAK8G,EAAAA,SAA4BU,EAAMlB,EAAO8C,GAC5CpC,EAAS,CAACQ,EAAKxE,EAAMwE,EAAKlD,GAASgC,EAAO8C,CAAAA,CAC5C,CAAA,CACF,EAaAL,EAAWnI,UAAU0J,WAAa,SAAUrH,EAAKT,EAAO4E,GACtD,OAAOpH,KAAKuK,EAAKtH,EAAKT,EAAO4E,CAAAA,CAC/B,EACA2B,EAAWnI,UAAU4J,gBAAkB,SAAUzD,GAC/C,GAAIA,EAAM,GAAKA,EAAM/G,KAAK8E,EAAU,EAClC,MAAM,IAAIa,WAER6B,EAAOxH,KAAK8G,EAAkBC,CAAAA,EAClC,MAAO,CAACS,EAAKxE,EAAMwE,EAAKlD,EAC1B,EACAyE,EAAWnI,UAAU6J,KAAO,SAAUxH,GAChCqC,EAAUtF,KAAKsH,EAAkBtH,KAAKqG,EAAOpD,CAAAA,EACjD,OAAO,IAAIwF,EAAmBnD,EAAStF,KAAK0F,EAAS1F,IAAAA,CACvD,EAOA+I,EAAWnI,UAAU8J,gBAAkB,SAAUzH,GAE/C,OADcjD,KAAKsH,EAAkBtH,KAAKqG,EAAOpD,CAAAA,EAClCqB,CACjB,EACAyE,EAAWnI,UAAU+J,MAAQ,SAAUC,GACrC,IAAI7K,EAAOC,KAIX,OAHA4K,EAAMP,QAAAA,SAAkBQ,GACtB9K,EAAKuK,WAAWO,EAAG,GAAIA,EAAG,EAAA,CAC5B,CAAA,EACO7K,KAAK8E,CACd,EACAiE,EAAWnI,UAAUS,OAAOe,UAAY,WACtC,IAAIK,EAAQ2D,EAAU+C,EAAG3B,EACzB,OAAOtH,EAAYF,KAAAA,SAAgB8K,GACjC,OAAQA,EAAGjJ,OACT,KAAK,EACHY,EAASzC,KAAK8E,EACdsB,EAAWpG,KAAK8G,EAAAA,EAChBqC,EAAI,EACJ2B,EAAGjJ,MAAQ,EACb,KAAK,EACH,OAAMsH,EAAI1G,EAEH,CAAC,EAAa,EADrB+E,EAAOpB,EAAS+C,IACWnG,EAAMwE,EAAKlD,IAFZ,CAAC,EAAa,GAG1C,KAAK,EACHwG,EAAGhJ,KAAAA,EACHgJ,EAAGjJ,MAAQ,EACb,KAAK,EAEH,M,EADEsH,EACK,CAAC,EAAa,GACvB,KAAK,EACH,MAAO,CAAC,E,CAEd,CAAA,CACF,EAtIF,IAAwC3E,EAApCuE,EAwIKA,EA5HP,SAASA,EAAWL,EAAWO,EAAKpC,GAC9B6B,KAAAA,IAAAA,IACFA,EAAY,IAEd,IAAI3E,EAAQS,EAAO1D,KAAKd,KAAMiJ,EAAKpC,CAAAA,GAAgB7G,KAC/CD,EAAOgE,EAIX,OAHA2E,EAAU2B,QAAAA,SAAkBQ,GAC1B9K,EAAKuK,WAAWO,EAAG,GAAIA,EAAG,EAAA,CAC5B,CAAA,EACO9G,CACT,CAqHFvE,EAAQuJ,WAAaA,EAErB3I,OAAOqE,eAAejF,EAAS,IAAc,CAAEgD,MAAO,CAAA,C,EAEzD,CAAA","file":"ordered-map.min.js"}MIT License

Copyright (c) 2021 Zilong Yao

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
{
  "name": "@js-sdsl/ordered-map",
  "version": "4.4.2",
  "description": "javascript standard data structure library which benchmark against C++ STL",
  "main": "./dist/cjs/index.js",
  "module": "./dist/esm/index.js",
  "types": "./dist/esm/index.d.ts",
  "author": {
    "name": "ZLY201",
    "email": "951711127@qq.com",
    "url": "https://github.com/js-sdsl/js-sdsl"
  },
  "sideEffects": false,
  "homepage": "https://js-sdsl.org",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/js-sdsl"
  },
  "lint-staged": {
    "*.{js,ts}": [
      "yarn lint"
    ]
  },
  "devDependencies": {
    "@babel/core": "^7.19.3",
    "@babel/plugin-transform-modules-commonjs": "^7.18.6",
    "@rollup/plugin-babel": "^5.3.1",
    "@rollup/plugin-typescript": "^9.0.2",
    "@types/babel__core": "^7.1.19",
    "@types/chai": "^3.5.2",
    "@types/delete-empty": "^3.0.2",
    "@types/glob": "^8.1.0",
    "@types/gulp": "^4.0.9",
    "@types/gulp-babel": "^6.1.30",
    "@types/gulp-filter": "^3.0.34",
    "@types/gulp-rename": "^2.0.1",
    "@types/gulp-sourcemaps": "^0.0.35",
    "@types/gulp-tap": "^1.0.1",
    "@types/gulp-terser": "^1.2.1",
    "@types/gulp-uglify": "^3.0.7",
    "@types/karma": "^6.3.3",
    "@types/merge-stream": "^1.1.2",
    "@types/mocha": "^9.1.1",
    "@types/node": "^17.0.0",
    "@typescript-eslint/eslint-plugin": "^5.33.1",
    "@typescript-eslint/parser": "^5.33.1",
    "all-contributors-cli": "^6.20.0",
    "babel-plugin-remove-unused-import": "^2.1.1",
    "browserslist": "^4.21.3",
    "chai": "^3.5.0",
    "commitlint": "^17.0.3",
    "compare-versions": "^5.0.1",
    "conventional-changelog-conventionalcommits": "^5.0.0",
    "delete-empty": "^3.0.0",
    "eslint": "^8.23.1",
    "eslint-import-resolver-typescript": "^3.5.2",
    "eslint-plugin-compat": "^4.0.2",
    "eslint-plugin-import": "^2.26.0",
    "get-npm-package-version": "^1.1.1",
    "gh-pages": "^3.2.3",
    "gulp": "^4.0.2",
    "gulp-babel": "^8.0.0",
    "gulp-clean": "^0.4.0",
    "gulp-filter": "^7.0.0",
    "gulp-rename": "^2.0.0",
    "gulp-sourcemaps": "^3.0.0",
    "gulp-tap": "^2.0.0",
    "gulp-terser": "^2.1.0",
    "gulp-typescript": "^5.0.0",
    "gulp-uglify": "^3.0.2",
    "husky": "^8.0.1",
    "karma": "^6.4.1",
    "karma-chrome-launcher": "^3.1.1",
    "karma-edge-launcher": "^0.4.2",
    "karma-firefox-launcher": "^2.1.2",
    "karma-mocha": "^2.0.1",
    "karma-mocha-reporter": "^2.2.5",
    "karma-requirejs": "^1.1.0",
    "karma-safarinative-launcher": "^1.1.0",
    "karma-typescript": "^5.5.3",
    "lint-staged": "^13.0.3",
    "merge-stream": "^2.0.0",
    "mocha": "^9.2.2",
    "nyc": "^15.1.0",
    "requirejs": "^2.3.6",
    "rollup": "^2.79.1",
    "rollup-plugin-license": "^3.0.0",
    "rollup-plugin-ts": "^3.0.2",
    "ts-macros": "^1.3.3",
    "ts-mocha": "^10.0.0",
    "ts-node": "^10.9.1",
    "ts-transform-paths": "^2.0.3",
    "tsconfig-paths": "^4.0.0",
    "tslib": "^2.4.0",
    "ttypescript": "^1.5.13",
    "typedoc": "^0.23.10",
    "typedoc-plugin-missing-exports": "^1.0.0",
    "typescript": "~4.7.4"
  },
  "repository": {
    "type": "github",
    "url": "https://github.com/js-sdsl/js-sdsl.git"
  },
  "license": "MIT",
  "keywords": [
    "data",
    "structure",
    "data structure",
    "rbTree",
    "rbtree",
    "RBTree",
    "red black tree",
    "ordered",
    "set",
    "map",
    "ordered map",
    "ordered set",
    "deque",
    "heap",
    "priority queue",
    "link list",
    "LinkList",
    "linkedList",
    "vector",
    "stack",
    "queue",
    "hash",
    "hash set",
    "hash map",
    "c++",
    "stl"
  ],
  "bugs": {
    "email": "951711127@qq.com",
    "url": "https://github.com/js-sdsl/js-sdsl/issues"
  },
  "dependencies": {}
}<p align="center">
  <a href="https://js-sdsl.org/" target="_blank" rel="noopener noreferrer">
    <img src="https://js-sdsl.org/assets/image/logo/logo-removebg.png" alt="js-sdsl logo" width="120" />
  </a>
</p>

<h3><p align="center">A javascript standard data structure library which benchmark against C++ STL</p></h3>

<p align="center">
  <a href="https://www.npmjs.com/package/js-sdsl"><img src="https://img.shields.io/npm/v/js-sdsl.svg" alt="NPM Version" /></a>
  <a href="https://github.com/js-sdsl/js-sdsl/actions/workflows/build.yml"><img src="https://img.shields.io/github/actions/workflow/status/js-sdsl/js-sdsl/build.yml" alt="Build Status" /></a>
  <a href='https://coveralls.io/github/js-sdsl/js-sdsl?branch=main'><img src='https://coveralls.io/repos/github/js-sdsl/js-sdsl/badge.svg?branch=main' alt='Coverage Status' /></a>
  <a href="https://github.com/js-sdsl/js-sdsl"><img src="https://img.shields.io/github/stars/js-sdsl/js-sdsl.svg" alt="GITHUB Star" /></a>
  <a href="https://npmcharts.com/compare/js-sdsl?minimal=true"><img src="https://img.shields.io/npm/dm/js-sdsl.svg" alt="NPM Downloads" /></a>
  <a href="https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js"><img src="https://img.badgesize.io/https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js?compression=gzip&style=flat-square/" alt="Gzip Size"></a>
  <a href="https://openbase.com/js/js-sdsl?utm_source=embedded&amp;utm_medium=badge&amp;utm_campaign=rate-badge"><img src="https://badges.openbase.com/js/rating/js-sdsl.svg?token=fh3LMNOV+JSWykSjtg1rA8kouSYkJoIDzGbvaByq5X0=" alt="Rate this package"/></a>
  <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/npm/l/js-sdsl.svg" alt="MIT-license" /></a>
  <a href="https://github.com/js-sdsl/js-sdsl/"><img src="https://img.shields.io/github/languages/top/js-sdsl/js-sdsl.svg" alt="GITHUB-language" /></a>
</p>

<p align="center">English | <a href="https://github.com/js-sdsl/js-sdsl/blob/main/README.zh-CN.md">简体中文</a></p>

## ✨ Included data structures

- **Stack** - first in last out stack.
- **Queue** - first in first out queue.
- **PriorityQueue** - heap-implemented priority queue.
- **Vector** - protected array, cannot to operate properties like `length` directly.
- **LinkList** - linked list of non-contiguous memory addresses.
- **Deque** - double-ended-queue, O(1) time complexity to `unshift` or getting elements by index.
- **OrderedSet** - sorted set which implemented by red black tree.
- **OrderedMap** - sorted map which implemented by red black tree.
- **HashSet** - refer to the [polyfill of ES6 Set](https://github.com/rousan/collections-es6).
- **HashMap** - refer to the [polyfill of ES6 Map](https://github.com/rousan/collections-es6).

## ⚔️ Benchmark

We are benchmarking against other popular data structure libraries. In some ways we're better than the best library. See [benchmark](https://js-sdsl.org/#/test/benchmark-analyze).

## 🖥 Supported platforms

| ![][Edge-Icon]<br/>IE / Edge | ![][Firefox-Icon]<br/>Firefox | ![][Chrome-Icon]<br/>Chrome | ![][Safari-Icon]<br/>Safari | ![][Opera-Icon]<br/>Opera | ![][NodeJs-Icon]<br/>NodeJs |
|:----------------------------:|:-----------------------------:|:---------------------------:|:---------------------------:|:-------------------------:|:---------------------------:|
|           Edge 12            |              36               |             49              |             10              |            36             |             10              |

## 📦 Download

Download directly by cdn:

- [js-sdsl.js](https://unpkg.com/js-sdsl/dist/umd/js-sdsl.js) (for development)
- [js-sdsl.min.js](https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js) (for production)

Or install js-sdsl using npm:

```bash
npm install js-sdsl
```

Or you can download the isolation packages containing only the containers you want:

| package                                           | npm                                                                   | size                                                             | docs                        |
|---------------------------------------------------|-----------------------------------------------------------------------|------------------------------------------------------------------|-----------------------------|
| [@js-sdsl/stack][stack-package]                   | [![NPM Package][stack-npm-version]][stack-npm-link]                   | [![GZIP Size][stack-umd-size]][stack-umd-link]                   | [link][stack-docs]          |
| [@js-sdsl/queue][queue-package]                   | [![NPM Package][queue-npm-version]][queue-npm-link]                   | [![GZIP Size][queue-umd-size]][queue-umd-link]                   | [link][queue-docs]          |
| [@js-sdsl/priority-queue][priority-queue-package] | [![NPM Package][priority-queue-npm-version]][priority-queue-npm-link] | [![GZIP Size][priority-queue-umd-size]][priority-queue-umd-link] | [link][priority-queue-docs] |
| [@js-sdsl/vector][vector-package]                 | [![NPM Package][vector-npm-version]][vector-npm-link]                 | [![GZIP Size][vector-umd-size]][vector-umd-link]                 | [link][vector-docs]         |
| [@js-sdsl/link-list][link-list-package]           | [![NPM Package][link-list-npm-version]][link-list-npm-link]           | [![GZIP Size][link-list-umd-size]][link-list-umd-link]           | [link][link-list-docs]      |
| [@js-sdsl/deque][deque-package]                   | [![NPM Package][deque-npm-version]][deque-npm-link]                   | [![GZIP Size][deque-umd-size]][deque-umd-link]                   | [link][deque-docs]          |
| [@js-sdsl/ordered-set][ordered-set-package]       | [![NPM Package][ordered-set-npm-version]][ordered-set-npm-link]       | [![GZIP Size][ordered-set-umd-size]][ordered-set-umd-link]       | [link][ordered-set-docs]    |
| [@js-sdsl/ordered-map][ordered-map-package]       | [![NPM Package][ordered-map-npm-version]][ordered-map-npm-link]       | [![GZIP Size][ordered-map-umd-size]][ordered-map-umd-link]       | [link][ordered-map-docs]    |
| [@js-sdsl/hash-set][hash-set-package]             | [![NPM Package][hash-set-npm-version]][hash-set-npm-link]             | [![GZIP Size][hash-set-umd-size]][hash-set-umd-link]             | [link][hash-set-docs]       |
| [@js-sdsl/hash-map][hash-map-package]             | [![NPM Package][hash-map-npm-version]][hash-map-npm-link]             | [![GZIP Size][hash-map-umd-size]][hash-map-umd-link]             | [link][hash-map-docs]       |

## 🪒 Usage

You can visit our [official website](https://js-sdsl.org/) to get more information.

To help you have a better use, we also provide this [API document](https://js-sdsl.org/js-sdsl/index.html).

For previous versions of the documentation, please visit:

`https://js-sdsl.org/js-sdsl/previous/v${version}/index.html`

E.g.

[https://js-sdsl.org/js-sdsl/previous/v4.1.5/index.html](https://js-sdsl.org/js-sdsl/previous/v4.1.5/index.html)

### For browser

```html
<script src="https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js"></script>
<script>
    const {
      Vector,
      Stack,
      Queue,
      LinkList,
      Deque,
      PriorityQueue,
      OrderedSet,
      OrderedMap,
      HashSet,
      HashMap
    } = sdsl;
    const myOrderedMap = new OrderedMap();
    myOrderedMap.setElement(1, 2);
    console.log(myOrderedMap.getElementByKey(1)); // 2
</script>
```

### For npm

```javascript
// esModule
import { OrderedMap } from 'js-sdsl';
// commonJs
const { OrderedMap } = require('js-sdsl');
const myOrderedMap = new OrderedMap();
myOrderedMap.setElement(1, 2);
console.log(myOrderedMap.getElementByKey(1)); // 2
```

## 🛠 Test

### Unit test

We use [karma](https://karma-runner.github.io/) and [mocha](https://mochajs.org/) frame to do unit tests and synchronize to [coveralls](https://coveralls.io/github/js-sdsl/js-sdsl). You can run `yarn test:unit` command to reproduce it.

### For performance

We tested most of the functions for efficiency. You can go to [`gh-pages/performance.md`](https://github.com/js-sdsl/js-sdsl/blob/gh-pages/performance.md) to see our running results or reproduce it with `yarn test:performance` command.

You can also visit [here](https://js-sdsl.org/#/test/performance-test) to get the result.

## ⌨️ Development

Use Gitpod, a free online dev environment for GitHub.

[![Open in Gippod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/js-sdsl/js-sdsl)

Or clone locally:

```bash
$ git clone https://github.com/js-sdsl/js-sdsl.git
$ cd js-sdsl
$ npm install
$ npm run dev   # development mode
```

Then you can see the output in `dist/cjs` folder.

## 🤝 Contributing

Feel free to dive in! Open an issue or submit PRs. It may be helpful to read the [Contributor Guide](https://github.com/js-sdsl/js-sdsl/blob/main/.github/CONTRIBUTING.md).

### Contributors

Thanks goes to these wonderful people:

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center"><a href="https://www.linkedin.com/in/takatoshi-kondo-02a91410/"><img src="https://avatars.githubusercontent.com/u/275959?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Takatoshi Kondo</b></sub></a><br /><a href="https://github.com/js-sdsl/js-sdsl/commits?author=redboltz" title="Code">💻</a> <a href="https://github.com/js-sdsl/js-sdsl/commits?author=redboltz" title="Tests">⚠️</a></td>
      <td align="center"><a href="https://www.youtube.com/c/noname0310"><img src="https://avatars.githubusercontent.com/u/48761044?v=4?s=100" width="100px;" alt=""/><br /><sub><b>noname</b></sub></a><br /><a href="https://github.com/js-sdsl/js-sdsl/commits?author=noname0310" title="Code">💻</a></td>
    </tr>
  </tbody>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

This project follows the [all-contributors](https://github.com/all-contributors/all-contributors) specification. Contributions of any kind welcome!

## ❤️ Sponsors and Backers

The special thanks to these sponsors or backers because they provided support at a very early stage:

<a href="https://eslint.org/"><img src="https://js-sdsl.org/assets/image/sponsors/eslint-logo-color.png" alt="eslint logo" width="150"></a>

Thanks also give to these sponsors or backers:

[![sponsors](https://opencollective.com/js-sdsl/tiers/sponsors.svg?avatarHeight=36)](https://opencollective.com/js-sdsl#support)

[![backers](https://opencollective.com/js-sdsl/tiers/backers.svg?avatarHeight=36)](https://opencollective.com/js-sdsl#support)

## 🪪 License

[MIT](https://github.com/js-sdsl/js-sdsl/blob/main/LICENSE) © [ZLY201](https://github.com/zly201)

[Edge-Icon]: https://js-sdsl.org/assets/image/platform/edge.png
[Firefox-Icon]: https://js-sdsl.org/assets/image/platform/firefox.png
[Chrome-Icon]: https://js-sdsl.org/assets/image/platform/chrome.png
[Safari-Icon]: https://js-sdsl.org/assets/image/platform/safari.png
[Opera-Icon]: https://js-sdsl.org/assets/image/platform/opera.png
[NodeJs-Icon]: https://js-sdsl.org/assets/image/platform/nodejs.png

[stack-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/OtherContainer/Stack.ts
[stack-npm-version]: https://img.shields.io/npm/v/@js-sdsl/stack
[stack-npm-link]: https://www.npmjs.com/package/@js-sdsl/stack
[stack-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/stack/dist/umd/stack.min.js?compression=gzip&style=flat-square/
[stack-umd-link]: https://unpkg.com/@js-sdsl/stack/dist/umd/stack.min.js
[stack-docs]: https://js-sdsl.org/js-sdsl/classes/Stack.html

[queue-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/OtherContainer/Queue.ts
[queue-npm-version]: https://img.shields.io/npm/v/@js-sdsl/queue
[queue-npm-link]: https://www.npmjs.com/package/@js-sdsl/queue
[queue-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/queue/dist/umd/queue.min.js?compression=gzip&style=flat-square/
[queue-umd-link]: https://unpkg.com/@js-sdsl/queue/dist/umd/queue.min.js
[queue-docs]: https://js-sdsl.org/js-sdsl/classes/Queue.html

[priority-queue-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/OtherContainer/PriorityQueue.ts
[priority-queue-npm-version]: https://img.shields.io/npm/v/@js-sdsl/priority-queue
[priority-queue-npm-link]: https://www.npmjs.com/package/@js-sdsl/priority-queue
[priority-queue-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/priority-queue/dist/umd/priority-queue.min.js?compression=gzip&style=flat-square/
[priority-queue-umd-link]: https://unpkg.com/@js-sdsl/priority-queue/dist/umd/priority-queue.min.js
[priority-queue-docs]: https://js-sdsl.org/js-sdsl/classes/PriorityQueue.html

[vector-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/SequentialContainer/Vector.ts
[vector-npm-version]: https://img.shields.io/npm/v/@js-sdsl/vector
[vector-npm-link]: https://www.npmjs.com/package/@js-sdsl/vector
[vector-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/vector/dist/umd/vector.min.js?compression=gzip&style=flat-square/
[vector-umd-link]: https://unpkg.com/@js-sdsl/vector/dist/umd/vector.min.js
[vector-docs]: https://js-sdsl.org/js-sdsl/classes/Vector.html

[link-list-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/SequentialContainer/LinkList.ts
[link-list-npm-version]: https://img.shields.io/npm/v/@js-sdsl/link-list
[link-list-npm-link]: https://www.npmjs.com/package/@js-sdsl/link-list
[link-list-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/link-list/dist/umd/link-list.min.js?compression=gzip&style=flat-square/
[link-list-umd-link]: https://unpkg.com/@js-sdsl/link-list/dist/umd/link-list.min.js
[link-list-docs]: https://js-sdsl.org/js-sdsl/classes/LinkList.html

[deque-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/SequentialContainer/Deque.ts
[deque-npm-version]: https://img.shields.io/npm/v/@js-sdsl/deque
[deque-npm-link]: https://www.npmjs.com/package/@js-sdsl/deque
[deque-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/deque/dist/umd/deque.min.js?compression=gzip&style=flat-square/
[deque-umd-link]: https://unpkg.com/@js-sdsl/deque/dist/umd/deque.min.js
[deque-docs]: https://js-sdsl.org/js-sdsl/classes/Deque.html

[ordered-set-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/TreeContainer/OrderedSet.ts
[ordered-set-npm-version]: https://img.shields.io/npm/v/@js-sdsl/ordered-set
[ordered-set-npm-link]: https://www.npmjs.com/package/@js-sdsl/ordered-set
[ordered-set-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/ordered-set/dist/umd/ordered-set.min.js?compression=gzip&style=flat-square/
[ordered-set-umd-link]: https://unpkg.com/@js-sdsl/ordered-set/dist/umd/ordered-set.min.js
[ordered-set-docs]: https://js-sdsl.org/js-sdsl/classes/OrderedSet.html

[ordered-map-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/TreeContainer/OrderedMap.ts
[ordered-map-npm-version]: https://img.shields.io/npm/v/@js-sdsl/ordered-map
[ordered-map-npm-link]: https://www.npmjs.com/package/@js-sdsl/ordered-map
[ordered-map-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/ordered-map/dist/umd/ordered-map.min.js?compression=gzip&style=flat-square/
[ordered-map-umd-link]: https://unpkg.com/@js-sdsl/ordered-map/dist/umd/ordered-map.min.js
[ordered-map-docs]: https://js-sdsl.org/js-sdsl/classes/OrderedMap.html

[hash-set-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/HashContainer/HashSet.ts
[hash-set-npm-version]: https://img.shields.io/npm/v/@js-sdsl/hash-set
[hash-set-npm-link]: https://www.npmjs.com/package/@js-sdsl/hash-set
[hash-set-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/hash-set/dist/umd/hash-set.min.js?compression=gzip&style=flat-square/
[hash-set-umd-link]: https://unpkg.com/@js-sdsl/hash-set/dist/umd/hash-set.min.js
[hash-set-docs]: https://js-sdsl.org/js-sdsl/classes/HashSet.html

[hash-map-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/HashContainer/HashMap.ts
[hash-map-npm-version]: https://img.shields.io/npm/v/@js-sdsl/hash-map
[hash-map-npm-link]: https://www.npmjs.com/package/@js-sdsl/hash-map
[hash-map-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/hash-map/dist/umd/hash-map.min.js?compression=gzip&style=flat-square/
[hash-map-umd-link]: https://unpkg.com/@js-sdsl/hash-map/dist/umd/hash-map.min.js
[hash-map-docs]: https://js-sdsl.org/js-sdsl/classes/HashMap.html
<p align="center">
  <a href="https://js-sdsl.org/" target="_blank" rel="noopener noreferrer">
    <img src="https://js-sdsl.org/assets/image/logo/logo-removebg.png" alt="js-sdsl logo" width="120" />
  </a>
</p>

<h3><p align="center">一款参考 C++ STL 实现的 JavaScript 标准数据结构库</p></h3>

<p align="center">
  <a href="https://www.npmjs.com/package/js-sdsl"><img src="https://img.shields.io/npm/v/js-sdsl.svg" alt="NPM Version" /></a>
  <a href="https://github.com/js-sdsl/js-sdsl/actions/workflows/build.yml"><img src="https://img.shields.io/github/actions/workflow/status/js-sdsl/js-sdsl/build.yml" alt="Build Status" /></a>
  <a href='https://coveralls.io/github/js-sdsl/js-sdsl?branch=main'><img src='https://coveralls.io/repos/github/js-sdsl/js-sdsl/badge.svg?branch=main' alt='Coverage Status' /></a>
  <a href="https://github.com/js-sdsl/js-sdsl"><img src="https://img.shields.io/github/stars/js-sdsl/js-sdsl.svg" alt="GITHUB Star" /></a>
  <a href="https://npmcharts.com/compare/js-sdsl?minimal=true"><img src="https://img.shields.io/npm/dm/js-sdsl.svg" alt="NPM Downloads" /></a>
  <a href="https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js"><img src="https://img.badgesize.io/https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js?compression=gzip&style=flat-square/" alt="Gzip Size"></a>
  <a href="https://openbase.com/js/js-sdsl?utm_source=embedded&amp;utm_medium=badge&amp;utm_campaign=rate-badge"><img src="https://badges.openbase.com/js/rating/js-sdsl.svg?token=fh3LMNOV+JSWykSjtg1rA8kouSYkJoIDzGbvaByq5X0=" alt="Rate this package"/></a>
  <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/npm/l/js-sdsl.svg" alt="MIT-license" /></a>
  <a href="https://github.com/js-sdsl/js-sdsl/"><img src="https://img.shields.io/github/languages/top/js-sdsl/js-sdsl.svg" alt="GITHUB-language" /></a>
</p>

<p align="center"><a href="https://github.com/js-sdsl/js-sdsl/blob/main/README.md">English</a> | 简体中文</p>

## ✨ 包含的数据结构

- **Stack** - 先进后出的堆栈
- **Queue** - 先进先出的队列
- **PriorityQueue** - 堆实现的优先级队列
- **Vector** - 受保护的数组，不能直接操作像 `length` 这样的属性
- **LinkList** - 非连续内存地址的链表
- **Deque** - 双端队列，向前和向后插入元素或按索引获取元素的时间复杂度为 O(1)
- **OrderedSet** - 由红黑树实现的排序集合
- **OrderedMap** - 由红黑树实现的排序字典
- **HashSet** - 参考 [ES6 Set polyfill](https://github.com/rousan/collections-es6) 实现的哈希集合
- **HashMap** - 参考 [ES6 Set polyfill](https://github.com/rousan/collections-es6) 实现的哈希字典

## ⚔️ 基准测试

我们和其他数据结构库进行了基准测试，在某些场景我们甚至超过了当前最流行的库

查看 [benchmark](https://js-sdsl.org/#/zh-cn/test/benchmark-analyze) 以获取更多信息

## 🖥 支持的平台

| ![][Edge-Icon]<br/>IE / Edge | ![][Firefox-Icon]<br/>Firefox | ![][Chrome-Icon]<br/>Chrome | ![][Safari-Icon]<br/>Safari | ![][Opera-Icon]<br/>Opera | ![][NodeJs-Icon]<br/>NodeJs |
|:----------------------------:|:-----------------------------:|:---------------------------:|:---------------------------:|:-------------------------:|:---------------------------:|
|           Edge 12            |              36               |             49              |             10              |            36             |             10              |

## 📦 下载

使用 cdn 直接引入

- [js-sdsl.js](https://unpkg.com/js-sdsl/dist/umd/js-sdsl.js) (for development)
- [js-sdsl.min.js](https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js) (for production)

使用 npm 下载

```bash
npm install js-sdsl
```

或者根据需要安装以下任意单个包

| package                                           | npm                                                                   | size                                                             | docs                        |
|---------------------------------------------------|-----------------------------------------------------------------------|------------------------------------------------------------------|-----------------------------|
| [@js-sdsl/stack][stack-package]                   | [![NPM Package][stack-npm-version]][stack-npm-link]                   | [![GZIP Size][stack-umd-size]][stack-umd-link]                   | [link][stack-docs]          |
| [@js-sdsl/queue][queue-package]                   | [![NPM Package][queue-npm-version]][queue-npm-link]                   | [![GZIP Size][queue-umd-size]][queue-umd-link]                   | [link][queue-docs]          |
| [@js-sdsl/priority-queue][priority-queue-package] | [![NPM Package][priority-queue-npm-version]][priority-queue-npm-link] | [![GZIP Size][priority-queue-umd-size]][priority-queue-umd-link] | [link][priority-queue-docs] |
| [@js-sdsl/vector][vector-package]                 | [![NPM Package][vector-npm-version]][vector-npm-link]                 | [![GZIP Size][vector-umd-size]][vector-umd-link]                 | [link][vector-docs]         |
| [@js-sdsl/link-list][link-list-package]           | [![NPM Package][link-list-npm-version]][link-list-npm-link]           | [![GZIP Size][link-list-umd-size]][link-list-umd-link]           | [link][link-list-docs]      |
| [@js-sdsl/deque][deque-package]                   | [![NPM Package][deque-npm-version]][deque-npm-link]                   | [![GZIP Size][deque-umd-size]][deque-umd-link]                   | [link][deque-docs]          |
| [@js-sdsl/ordered-set][ordered-set-package]       | [![NPM Package][ordered-set-npm-version]][ordered-set-npm-link]       | [![GZIP Size][ordered-set-umd-size]][ordered-set-umd-link]       | [link][ordered-set-docs]    |
| [@js-sdsl/ordered-map][ordered-map-package]       | [![NPM Package][ordered-map-npm-version]][ordered-map-npm-link]       | [![GZIP Size][ordered-map-umd-size]][ordered-map-umd-link]       | [link][ordered-map-docs]    |
| [@js-sdsl/hash-set][hash-set-package]             | [![NPM Package][hash-set-npm-version]][hash-set-npm-link]             | [![GZIP Size][hash-set-umd-size]][hash-set-umd-link]             | [link][hash-set-docs]       |
| [@js-sdsl/hash-map][hash-map-package]             | [![NPM Package][hash-map-npm-version]][hash-map-npm-link]             | [![GZIP Size][hash-map-umd-size]][hash-map-umd-link]             | [link][hash-map-docs]       |

## 🪒 使用说明

您可以[访问我们的主页](https://js-sdsl.org/)获取更多信息

并且我们提供了完整的 [API 文档](https://js-sdsl.org/js-sdsl/index.html)供您参考

想要查看从前版本的文档，请访问：

`https://js-sdsl.org/js-sdsl/previous/v${version}/index.html`

例如：

[https://js-sdsl.org/js-sdsl/previous/v4.1.5/index.html](https://js-sdsl.org/js-sdsl/previous/v4.1.5/index.html)

### 在浏览器中使用

```html
<script src="https://unpkg.com/js-sdsl/dist/umd/js-sdsl.min.js"></script>
<script>
    const { 
      Vector,
      Stack,
      Queue,
      LinkList,
      Deque,
      PriorityQueue,
      OrderedSet,
      OrderedMap,
      HashSet,
      HashMap
    } = sdsl;
    const myOrderedMap = new OrderedMap();
    myOrderedMap.setElement(1, 2);
    console.log(myOrderedMap.getElementByKey(1)); // 2
</script>
```

### npm 引入

```javascript
// esModule
import { OrderedMap } from 'js-sdsl';
// commonJs
const { OrderedMap } = require('js-sdsl');
const myOrderedMap = new OrderedMap();
myOrderedMap.setElement(1, 2);
console.log(myOrderedMap.getElementByKey(1)); // 2
```

## 🛠 测试

### 单元测试

我们使用 [karma](https://karma-runner.github.io/) 和 [mocha](https://mochajs.org/) 框架进行单元测试，并同步到 [coveralls](https://coveralls.io/github/js-sdsl/js-sdsl) 上，你可以使用 `yarn test:unit` 命令来重建它

### 对于性能的校验

我们对于编写的所有 API 进行了性能测试，并将结果同步到了 [`gh-pages/performance.md`](https://github.com/js-sdsl/js-sdsl/blob/gh-pages/performance.md) 中，你可以通过 `yarn test:performance` 命令来重现它

您也可以访问[我们的网站](https://js-sdsl.org/#/zh-cn/test/performance-test)来获取结果

## ⌨️ 开发

可以使用 Gitpod 进行在线编辑：

[![Open in Gippod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/js-sdsl/js-sdsl)

或者在本地使用以下命令获取源码进行开发：

```bash
$ git clone https://github.com/js-sdsl/js-sdsl.git
$ cd js-sdsl
$ npm install
$ npm run dev   # development mode
```

之后您在 `dist/cjs` 文件夹中可以看到在 `dev` 模式下打包生成的产物

## 🤝 贡献

我们欢迎所有的开发人员提交 issue 或 pull request，阅读[贡献者指南](https://github.com/js-sdsl/js-sdsl/blob/main/.github/CONTRIBUTING.md)可能会有所帮助

### 贡献者

感谢对本项目做出贡献的开发者们：

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center"><a href="https://www.linkedin.com/in/takatoshi-kondo-02a91410/"><img src="https://avatars.githubusercontent.com/u/275959?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Takatoshi Kondo</b></sub></a><br /><a href="https://github.com/js-sdsl/js-sdsl/commits?author=redboltz" title="Code">💻</a> <a href="https://github.com/js-sdsl/js-sdsl/commits?author=redboltz" title="Tests">⚠️</a></td>
      <td align="center"><a href="https://www.youtube.com/c/noname0310"><img src="https://avatars.githubusercontent.com/u/48761044?v=4?s=100" width="100px;" alt=""/><br /><sub><b>noname</b></sub></a><br /><a href="https://github.com/js-sdsl/js-sdsl/commits?author=noname0310" title="Code">💻</a></td>
    </tr>
  </tbody>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->

本项目遵循 [all-contributors](https://github.com/all-contributors/all-contributors) 规范。 欢迎任何形式的贡献！

## ❤️ 赞助者

特别鸣谢下列赞助商和支持者们，他们在非常早期的时候为我们提供了支持：

<a href="https://eslint.org/"><img src="https://js-sdsl.org/assets/image/sponsors/eslint-logo-color.png" alt="eslint logo" width="150"></a>

同样感谢这些赞助商和支持者们：

[![sponsors](https://opencollective.com/js-sdsl/tiers/sponsors.svg?avatarHeight=36)](https://opencollective.com/js-sdsl#support)

[![backers](https://opencollective.com/js-sdsl/tiers/backers.svg?avatarHeight=36)](https://opencollective.com/js-sdsl#support)

## 🪪 许可证

[MIT](https://github.com/js-sdsl/js-sdsl/blob/main/LICENSE) © [ZLY201](https://github.com/zly201)

[Edge-Icon]: https://js-sdsl.org/assets/image/platform/edge.png
[Firefox-Icon]: https://js-sdsl.org/assets/image/platform/firefox.png
[Chrome-Icon]: https://js-sdsl.org/assets/image/platform/chrome.png
[Safari-Icon]: https://js-sdsl.org/assets/image/platform/safari.png
[Opera-Icon]: https://js-sdsl.org/assets/image/platform/opera.png
[NodeJs-Icon]: https://js-sdsl.org/assets/image/platform/nodejs.png

[stack-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/OtherContainer/Stack.ts
[stack-npm-version]: https://img.shields.io/npm/v/@js-sdsl/stack
[stack-npm-link]: https://www.npmjs.com/package/@js-sdsl/stack
[stack-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/stack/dist/umd/stack.min.js?compression=gzip&style=flat-square/
[stack-umd-link]: https://unpkg.com/@js-sdsl/stack/dist/umd/stack.min.js
[stack-docs]: https://js-sdsl.org/js-sdsl/classes/Stack.html

[queue-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/OtherContainer/Queue.ts
[queue-npm-version]: https://img.shields.io/npm/v/@js-sdsl/queue
[queue-npm-link]: https://www.npmjs.com/package/@js-sdsl/queue
[queue-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/queue/dist/umd/queue.min.js?compression=gzip&style=flat-square/
[queue-umd-link]: https://unpkg.com/@js-sdsl/queue/dist/umd/queue.min.js
[queue-docs]: https://js-sdsl.org/js-sdsl/classes/Queue.html

[priority-queue-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/OtherContainer/PriorityQueue.ts
[priority-queue-npm-version]: https://img.shields.io/npm/v/@js-sdsl/priority-queue
[priority-queue-npm-link]: https://www.npmjs.com/package/@js-sdsl/priority-queue
[priority-queue-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/priority-queue/dist/umd/priority-queue.min.js?compression=gzip&style=flat-square/
[priority-queue-umd-link]: https://unpkg.com/@js-sdsl/priority-queue/dist/umd/priority-queue.min.js
[priority-queue-docs]: https://js-sdsl.org/js-sdsl/classes/PriorityQueue.html

[vector-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/SequentialContainer/Vector.ts
[vector-npm-version]: https://img.shields.io/npm/v/@js-sdsl/vector
[vector-npm-link]: https://www.npmjs.com/package/@js-sdsl/vector
[vector-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/vector/dist/umd/vector.min.js?compression=gzip&style=flat-square/
[vector-umd-link]: https://unpkg.com/@js-sdsl/vector/dist/umd/vector.min.js
[vector-docs]: https://js-sdsl.org/js-sdsl/classes/Vector.html

[link-list-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/SequentialContainer/LinkList.ts
[link-list-npm-version]: https://img.shields.io/npm/v/@js-sdsl/link-list
[link-list-npm-link]: https://www.npmjs.com/package/@js-sdsl/link-list
[link-list-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/link-list/dist/umd/link-list.min.js?compression=gzip&style=flat-square/
[link-list-umd-link]: https://unpkg.com/@js-sdsl/link-list/dist/umd/link-list.min.js
[link-list-docs]: https://js-sdsl.org/js-sdsl/classes/LinkList.html

[deque-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/SequentialContainer/Deque.ts
[deque-npm-version]: https://img.shields.io/npm/v/@js-sdsl/deque
[deque-npm-link]: https://www.npmjs.com/package/@js-sdsl/deque
[deque-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/deque/dist/umd/deque.min.js?compression=gzip&style=flat-square/
[deque-umd-link]: https://unpkg.com/@js-sdsl/deque/dist/umd/deque.min.js
[deque-docs]: https://js-sdsl.org/js-sdsl/classes/Deque.html

[ordered-set-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/TreeContainer/OrderedSet.ts
[ordered-set-npm-version]: https://img.shields.io/npm/v/@js-sdsl/ordered-set
[ordered-set-npm-link]: https://www.npmjs.com/package/@js-sdsl/ordered-set
[ordered-set-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/ordered-set/dist/umd/ordered-set.min.js?compression=gzip&style=flat-square/
[ordered-set-umd-link]: https://unpkg.com/@js-sdsl/ordered-set/dist/umd/ordered-set.min.js
[ordered-set-docs]: https://js-sdsl.org/js-sdsl/classes/OrderedSet.html

[ordered-map-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/TreeContainer/OrderedMap.ts
[ordered-map-npm-version]: https://img.shields.io/npm/v/@js-sdsl/ordered-map
[ordered-map-npm-link]: https://www.npmjs.com/package/@js-sdsl/ordered-map
[ordered-map-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/ordered-map/dist/umd/ordered-map.min.js?compression=gzip&style=flat-square/
[ordered-map-umd-link]: https://unpkg.com/@js-sdsl/ordered-map/dist/umd/ordered-map.min.js
[ordered-map-docs]: https://js-sdsl.org/js-sdsl/classes/OrderedMap.html

[hash-set-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/HashContainer/HashSet.ts
[hash-set-npm-version]: https://img.shields.io/npm/v/@js-sdsl/hash-set
[hash-set-npm-link]: https://www.npmjs.com/package/@js-sdsl/hash-set
[hash-set-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/hash-set/dist/umd/hash-set.min.js?compression=gzip&style=flat-square/
[hash-set-umd-link]: https://unpkg.com/@js-sdsl/hash-set/dist/umd/hash-set.min.js
[hash-set-docs]: https://js-sdsl.org/js-sdsl/classes/HashSet.html

[hash-map-package]: https://github.com/js-sdsl/js-sdsl/blob/main/src/container/HashContainer/HashMap.ts
[hash-map-npm-version]: https://img.shields.io/npm/v/@js-sdsl/hash-map
[hash-map-npm-link]: https://www.npmjs.com/package/@js-sdsl/hash-map
[hash-map-umd-size]: https://img.badgesize.io/https://unpkg.com/@js-sdsl/hash-map/dist/umd/hash-map.min.js?compression=gzip&style=flat-square/
[hash-map-umd-link]: https://unpkg.com/@js-sdsl/hash-map/dist/umd/hash-map.min.js
[hash-map-docs]: https://js-sdsl.org/js-sdsl/classes/HashMap.html
import { Sink } from "./Sink";
export declare function applyAsyncIterableIteratorToSink<TValue = unknown, TError = unknown>(asyncIterableIterator: AsyncIterableIterator<TValue>, sink: Sink<TValue, TError>): () => void;
export function applyAsyncIterableIteratorToSink(asyncIterableIterator, sink) {
    const run = async () => {
        try {
            for await (const value of asyncIterableIterator) {
                sink.next(value);
            }
            sink.complete();
        }
        catch (err) {
            sink.error(err);
        }
    };
    run();
    return () => {
        var _a;
        (_a = asyncIterableIterator.return) === null || _a === void 0 ? void 0 : _a.call(asyncIterableIterator);
    };
}
//# sourceMappingURL=applyAsyncIterableIteratorToSink.js.map{"version":3,"file":"applyAsyncIterableIteratorToSink.js","sourceRoot":"","sources":["../src/applyAsyncIterableIteratorToSink.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,gCAAgC,CAI9C,qBAAoD,EACpD,IAA0B;IAE1B,MAAM,GAAG,GAAG,KAAK,IAAI,EAAE;QACrB,IAAI;YACF,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,qBAAqB,EAAE;gBAC/C,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAClB;YACD,IAAI,CAAC,QAAQ,EAAE,CAAC;SACjB;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,CAAC,KAAK,CAAC,GAAa,CAAC,CAAC;SAC3B;IACH,CAAC,CAAC;IACF,GAAG,EAAE,CAAC;IAEN,OAAO,GAAG,EAAE;;QACV,MAAA,qBAAqB,CAAC,MAAM,+CAA5B,qBAAqB,CAAW,CAAC;IACnC,CAAC,CAAC;AACJ,CAAC"}export * from "./makePushPullAsyncIterableIterator";
export * from "./Sink";
export * from "./makeAsyncIterableIteratorFromSink";
export * from "./applyAsyncIterableIteratorToSink";
export * from "./isAsyncIterable";
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function createDeferred() {
    const d = {};
    d.promise = new Promise((resolve, reject) => {
        d.resolve = resolve;
        d.reject = reject;
    });
    return d;
}
const SYMBOL_FINISHED = Symbol();
const SYMBOL_NEW_VALUE = Symbol();
/**
 * makePushPullAsyncIterableIterator
 *
 * The iterable will publish values until return or throw is called.
 * Afterwards it is in the completed state and cannot be used for publishing any further values.
 * It will handle back-pressure and keep pushed values until they are consumed by a source.
 */
function makePushPullAsyncIterableIterator() {
    let isRunning = true;
    const values = [];
    let newValueD = createDeferred();
    const finishedD = createDeferred();
    const asyncIterableIterator = (async function* PushPullAsyncIterableIterator() {
        while (true) {
            if (values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                yield values.shift();
            }
            else {
                const result = await Promise.race([
                    newValueD.promise,
                    finishedD.promise
                ]);
                if (result === SYMBOL_FINISHED) {
                    break;
                }
                if (result !== SYMBOL_NEW_VALUE) {
                    throw result;
                }
            }
        }
    })();
    function pushValue(value) {
        if (isRunning === false) {
            // TODO: Should this throw?
            return;
        }
        values.push(value);
        newValueD.resolve(SYMBOL_NEW_VALUE);
        newValueD = createDeferred();
    }
    // We monkey patch the original generator for clean-up
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalReturn = asyncIterableIterator.return.bind(asyncIterableIterator);
    asyncIterableIterator.return = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ...args) => {
        isRunning = false;
        finishedD.resolve(SYMBOL_FINISHED);
        return originalReturn(...args);
    };
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalThrow = asyncIterableIterator.throw.bind(asyncIterableIterator);
    asyncIterableIterator.throw = (err) => {
        isRunning = false;
        finishedD.resolve(err);
        return originalThrow(err);
    };
    return {
        pushValue,
        asyncIterableIterator
    };
}

const makeAsyncIterableIteratorFromSink = (make) => {
    const { pushValue, asyncIterableIterator } = makePushPullAsyncIterableIterator();
    const dispose = make({
        next: (value) => {
            pushValue(value);
        },
        complete: () => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            asyncIterableIterator.return();
        },
        error: (err) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            asyncIterableIterator.throw(err);
        }
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalReturn = asyncIterableIterator.return;
    let returnValue = undefined;
    asyncIterableIterator.return = () => {
        if (returnValue === undefined) {
            dispose();
            returnValue = originalReturn();
        }
        return returnValue;
    };
    return asyncIterableIterator;
};

function applyAsyncIterableIteratorToSink(asyncIterableIterator, sink) {
    const run = async () => {
        try {
            for await (const value of asyncIterableIterator) {
                sink.next(value);
            }
            sink.complete();
        }
        catch (err) {
            sink.error(err);
        }
    };
    run();
    return () => {
        var _a;
        (_a = asyncIterableIterator.return) === null || _a === void 0 ? void 0 : _a.call(asyncIterableIterator);
    };
}

function isAsyncIterable(input) {
    return (typeof input === "object" &&
        input !== null &&
        // The AsyncGenerator check is for Safari on iOS which currently does not have
        // Symbol.asyncIterator implemented
        // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (input[Symbol.toStringTag] === "AsyncGenerator" ||
            (Symbol.asyncIterator && Symbol.asyncIterator in input)));
}

exports.applyAsyncIterableIteratorToSink = applyAsyncIterableIteratorToSink;
exports.isAsyncIterable = isAsyncIterable;
exports.makeAsyncIterableIteratorFromSink = makeAsyncIterableIteratorFromSink;
exports.makePushPullAsyncIterableIterator = makePushPullAsyncIterableIterator;
{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,qCAAqC,CAAC;AACpD,cAAc,QAAQ,CAAC;AACvB,cAAc,qCAAqC,CAAC;AACpD,cAAc,oCAAoC,CAAC;AACnD,cAAc,mBAAmB,CAAC"}function createDeferred() {
    const d = {};
    d.promise = new Promise((resolve, reject) => {
        d.resolve = resolve;
        d.reject = reject;
    });
    return d;
}
const SYMBOL_FINISHED = Symbol();
const SYMBOL_NEW_VALUE = Symbol();
/**
 * makePushPullAsyncIterableIterator
 *
 * The iterable will publish values until return or throw is called.
 * Afterwards it is in the completed state and cannot be used for publishing any further values.
 * It will handle back-pressure and keep pushed values until they are consumed by a source.
 */
function makePushPullAsyncIterableIterator() {
    let isRunning = true;
    const values = [];
    let newValueD = createDeferred();
    const finishedD = createDeferred();
    const asyncIterableIterator = (async function* PushPullAsyncIterableIterator() {
        while (true) {
            if (values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                yield values.shift();
            }
            else {
                const result = await Promise.race([
                    newValueD.promise,
                    finishedD.promise
                ]);
                if (result === SYMBOL_FINISHED) {
                    break;
                }
                if (result !== SYMBOL_NEW_VALUE) {
                    throw result;
                }
            }
        }
    })();
    function pushValue(value) {
        if (isRunning === false) {
            // TODO: Should this throw?
            return;
        }
        values.push(value);
        newValueD.resolve(SYMBOL_NEW_VALUE);
        newValueD = createDeferred();
    }
    // We monkey patch the original generator for clean-up
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalReturn = asyncIterableIterator.return.bind(asyncIterableIterator);
    asyncIterableIterator.return = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ...args) => {
        isRunning = false;
        finishedD.resolve(SYMBOL_FINISHED);
        return originalReturn(...args);
    };
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalThrow = asyncIterableIterator.throw.bind(asyncIterableIterator);
    asyncIterableIterator.throw = (err) => {
        isRunning = false;
        finishedD.resolve(err);
        return originalThrow(err);
    };
    return {
        pushValue,
        asyncIterableIterator
    };
}

const makeAsyncIterableIteratorFromSink = (make) => {
    const { pushValue, asyncIterableIterator } = makePushPullAsyncIterableIterator();
    const dispose = make({
        next: (value) => {
            pushValue(value);
        },
        complete: () => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            asyncIterableIterator.return();
        },
        error: (err) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            asyncIterableIterator.throw(err);
        }
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalReturn = asyncIterableIterator.return;
    let returnValue = undefined;
    asyncIterableIterator.return = () => {
        if (returnValue === undefined) {
            dispose();
            returnValue = originalReturn();
        }
        return returnValue;
    };
    return asyncIterableIterator;
};

function applyAsyncIterableIteratorToSink(asyncIterableIterator, sink) {
    const run = async () => {
        try {
            for await (const value of asyncIterableIterator) {
                sink.next(value);
            }
            sink.complete();
        }
        catch (err) {
            sink.error(err);
        }
    };
    run();
    return () => {
        var _a;
        (_a = asyncIterableIterator.return) === null || _a === void 0 ? void 0 : _a.call(asyncIterableIterator);
    };
}

function isAsyncIterable(input) {
    return (typeof input === "object" &&
        input !== null &&
        // The AsyncGenerator check is for Safari on iOS which currently does not have
        // Symbol.asyncIterator implemented
        // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (input[Symbol.toStringTag] === "AsyncGenerator" ||
            (Symbol.asyncIterator && Symbol.asyncIterator in input)));
}

export { applyAsyncIterableIteratorToSink, isAsyncIterable, makeAsyncIterableIteratorFromSink, makePushPullAsyncIterableIterator };
export declare function isAsyncIterable(input: unknown): input is AsyncIterator<unknown> | AsyncIterableIterator<unknown>;
export function isAsyncIterable(input) {
    return (typeof input === "object" &&
        input !== null &&
        // The AsyncGenerator check is for Safari on iOS which currently does not have
        // Symbol.asyncIterator implemented
        // That means every custom AsyncIterable must be built using a AsyncGeneratorFunction (async function * () {})
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (input[Symbol.toStringTag] === "AsyncGenerator" ||
            (Symbol.asyncIterator && Symbol.asyncIterator in input)));
}
//# sourceMappingURL=isAsyncIterable.js.map{"version":3,"file":"isAsyncIterable.js","sourceRoot":"","sources":["../src/isAsyncIterable.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,eAAe,CAC7B,KAAc;IAEd,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,KAAK,IAAI;QACd,8EAA8E;QAC9E,mCAAmC;QACnC,8GAA8G;QAC9G,8DAA8D;QAC9D,CAAE,KAAa,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,gBAAgB;YACtD,CAAC,MAAM,CAAC,aAAa,IAAI,MAAM,CAAC,aAAa,IAAI,KAAK,CAAC,CAAC,CAC3D,CAAC;AACJ,CAAC"}MIT License

Copyright (c) 2020-present Laurin Quast (laurinquast@googlemail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.import { Sink } from "./Sink";
export declare const makeAsyncIterableIteratorFromSink: <TValue = unknown, TError = unknown>(make: (sink: Sink<TValue, TError>) => () => void) => AsyncIterableIterator<TValue>;
import { makePushPullAsyncIterableIterator } from "./makePushPullAsyncIterableIterator";
export const makeAsyncIterableIteratorFromSink = (make) => {
    const { pushValue, asyncIterableIterator } = makePushPullAsyncIterableIterator();
    const dispose = make({
        next: (value) => {
            pushValue(value);
        },
        complete: () => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            asyncIterableIterator.return();
        },
        error: (err) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            asyncIterableIterator.throw(err);
        }
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalReturn = asyncIterableIterator.return;
    let returnValue = undefined;
    asyncIterableIterator.return = () => {
        if (returnValue === undefined) {
            dispose();
            returnValue = originalReturn();
        }
        return returnValue;
    };
    return asyncIterableIterator;
};
//# sourceMappingURL=makeAsyncIterableIteratorFromSink.js.map{"version":3,"file":"makeAsyncIterableIteratorFromSink.js","sourceRoot":"","sources":["../src/makeAsyncIterableIteratorFromSink.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iCAAiC,EAAE,MAAM,qCAAqC,CAAC;AAGxF,MAAM,CAAC,MAAM,iCAAiC,GAAG,CAI/C,IAAgD,EACjB,EAAE;IACjC,MAAM,EACJ,SAAS,EACT,qBAAqB,EACtB,GAAG,iCAAiC,EAAU,CAAC;IAChD,MAAM,OAAO,GAAG,IAAI,CAAC;QACnB,IAAI,EAAE,CAAC,KAAa,EAAE,EAAE;YACtB,SAAS,CAAC,KAAK,CAAC,CAAC;QACnB,CAAC;QACD,QAAQ,EAAE,GAAG,EAAE;YACb,oEAAoE;YACpE,qBAAqB,CAAC,MAAO,EAAE,CAAC;QAClC,CAAC;QACD,KAAK,EAAE,CAAC,GAAW,EAAE,EAAE;YACrB,oEAAoE;YACpE,qBAAqB,CAAC,KAAM,CAAC,GAAG,CAAC,CAAC;QACpC,CAAC;KACF,CAAC,CAAC;IACH,oEAAoE;IACpE,MAAM,cAAc,GAAG,qBAAqB,CAAC,MAAO,CAAC;IACrD,IAAI,WAAW,GAAkD,SAAS,CAAC;IAC3E,qBAAqB,CAAC,MAAM,GAAG,GAAG,EAAE;QAClC,IAAI,WAAW,KAAK,SAAS,EAAE;YAC7B,OAAO,EAAE,CAAC;YACV,WAAW,GAAG,cAAc,EAAE,CAAC;SAChC;QACD,OAAO,WAAW,CAAC;IACrB,CAAC,CAAC;IACF,OAAO,qBAAqB,CAAC;AAC/B,CAAC,CAAC"}export declare type PushPullAsyncIterableIterator<T> = {
    pushValue: (value: T) => void;
    asyncIterableIterator: AsyncGenerator<T, void>;
};
/**
 * makePushPullAsyncIterableIterator
 *
 * The iterable will publish values until return or throw is called.
 * Afterwards it is in the completed state and cannot be used for publishing any further values.
 * It will handle back-pressure and keep pushed values until they are consumed by a source.
 */
export declare function makePushPullAsyncIterableIterator<T>(): PushPullAsyncIterableIterator<T>;
function createDeferred() {
    const d = {};
    d.promise = new Promise((resolve, reject) => {
        d.resolve = resolve;
        d.reject = reject;
    });
    return d;
}
const SYMBOL_FINISHED = Symbol();
const SYMBOL_NEW_VALUE = Symbol();
/**
 * makePushPullAsyncIterableIterator
 *
 * The iterable will publish values until return or throw is called.
 * Afterwards it is in the completed state and cannot be used for publishing any further values.
 * It will handle back-pressure and keep pushed values until they are consumed by a source.
 */
export function makePushPullAsyncIterableIterator() {
    let isRunning = true;
    const values = [];
    let newValueD = createDeferred();
    const finishedD = createDeferred();
    const asyncIterableIterator = (async function* PushPullAsyncIterableIterator() {
        while (true) {
            if (values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                yield values.shift();
            }
            else {
                const result = await Promise.race([
                    newValueD.promise,
                    finishedD.promise
                ]);
                if (result === SYMBOL_FINISHED) {
                    break;
                }
                if (result !== SYMBOL_NEW_VALUE) {
                    throw result;
                }
            }
        }
    })();
    function pushValue(value) {
        if (isRunning === false) {
            // TODO: Should this throw?
            return;
        }
        values.push(value);
        newValueD.resolve(SYMBOL_NEW_VALUE);
        newValueD = createDeferred();
    }
    // We monkey patch the original generator for clean-up
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalReturn = asyncIterableIterator.return.bind(asyncIterableIterator);
    asyncIterableIterator.return = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ...args) => {
        isRunning = false;
        finishedD.resolve(SYMBOL_FINISHED);
        return originalReturn(...args);
    };
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const originalThrow = asyncIterableIterator.throw.bind(asyncIterableIterator);
    asyncIterableIterator.throw = (err) => {
        isRunning = false;
        finishedD.resolve(err);
        return originalThrow(err);
    };
    return {
        pushValue,
        asyncIterableIterator
    };
}
//# sourceMappingURL=makePushPullAsyncIterableIterator.js.map{"version":3,"file":"makePushPullAsyncIterableIterator.js","sourceRoot":"","sources":["../src/makePushPullAsyncIterableIterator.ts"],"names":[],"mappings":"AAMA,SAAS,cAAc;IACrB,MAAM,CAAC,GAAG,EAAiB,CAAC;IAC5B,CAAC,CAAC,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAC7C,CAAC,CAAC,OAAO,GAAG,OAAO,CAAC;QACpB,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC;IACpB,CAAC,CAAC,CAAC;IACH,OAAO,CAAC,CAAC;AACX,CAAC;AASD,MAAM,eAAe,GAAG,MAAM,EAAE,CAAC;AACjC,MAAM,gBAAgB,GAAG,MAAM,EAAE,CAAC;AAElC;;;;;;GAMG;AACH,MAAM,UAAU,iCAAiC;IAG/C,IAAI,SAAS,GAAG,IAAI,CAAC;IACrB,MAAM,MAAM,GAAa,EAAE,CAAC;IAE5B,IAAI,SAAS,GAAG,cAAc,EAA2B,CAAC;IAC1D,MAAM,SAAS,GAAG,cAAc,EAAoC,CAAC;IAErE,MAAM,qBAAqB,GAAG,CAAC,KAAK,SAAS,CAAC,CAAC,6BAA6B;QAI1E,OAAO,IAAI,EAAE;YACX,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACrB,oEAAoE;gBACpE,MAAM,MAAM,CAAC,KAAK,EAAG,CAAC;aACvB;iBAAM;gBACL,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC;oBAChC,SAAS,CAAC,OAAO;oBACjB,SAAS,CAAC,OAAO;iBAClB,CAAC,CAAC;gBAEH,IAAI,MAAM,KAAK,eAAe,EAAE;oBAC9B,MAAM;iBACP;gBACD,IAAI,MAAM,KAAK,gBAAgB,EAAE;oBAC/B,MAAM,MAAM,CAAC;iBACd;aACF;SACF;IACH,CAAC,CAAC,EAAE,CAAC;IAEL,SAAS,SAAS,CAAC,KAAQ;QACzB,IAAI,SAAS,KAAK,KAAK,EAAE;YACvB,2BAA2B;YAC3B,OAAO;SACR;QAED,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnB,SAAS,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;QACpC,SAAS,GAAG,cAAc,EAAE,CAAC;IAC/B,CAAC;IAED,sDAAsD;IACtD,oEAAoE;IACpE,MAAM,cAAc,GAAG,qBAAqB,CAAC,MAAM,CAAC,IAAI,CACtD,qBAAqB,CACtB,CAAC;IAEF,qBAAqB,CAAC,MAAM,GAAG;IAC7B,8DAA8D;IAC9D,GAAG,IAAW,EACoB,EAAE;QACpC,SAAS,GAAG,KAAK,CAAC;QAClB,SAAS,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;QACnC,OAAO,cAAc,CAAC,GAAG,IAAI,CAAC,CAAC;IACjC,CAAC,CAAC;IAEF,oEAAoE;IACpE,MAAM,aAAa,GAAG,qBAAqB,CAAC,KAAK,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;IAC9E,qBAAqB,CAAC,KAAK,GAAG,CAC5B,GAAY,EACsB,EAAE;QACpC,SAAS,GAAG,KAAK,CAAC;QAClB,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACvB,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC;IAC5B,CAAC,CAAC;IAEF,OAAO;QACL,SAAS;QACT,qBAAqB;KACtB,CAAC;AACJ,CAAC"}{
  "name": "@n1ru4l/push-pull-async-iterable-iterator",
  "version": "3.1.0",
  "repository": "https://github.com/n1ru4l/push-pull-async-iterable-iterator",
  "author": {
    "name": "Laurin Quast",
    "email": "laurinquast@googlemail.com",
    "url": "https://github.com/n1ru4l"
  },
  "license": "MIT",
  "engines": {
    "node": ">=12"
  },
  "main": "index.js",
  "module": "index.mjs",
  "typings": "index.d.ts",
  "typescript": {
    "definition": "index.d.ts"
  },
  "exports": {
    ".": {
      "require": "./index.js",
      "import": "./index.mjs"
    },
    "./*": {
      "require": "./*.js",
      "import": "./*.mjs"
    }
  }
}
# `@n1ru4l/push-pull-async-iterable-iterator`

[![TypeScript](https://img.shields.io/badge/%3C%2F%3E-TypeScript-%230074c1.svg)](http://www.typescriptlang.org/)
[![npm version](https://img.shields.io/npm/v/@n1ru4l/push-pull-async-iterable-iterator)](https://www.npmjs.com/package/@n1ru4l/push-pull-async-iterable-iterator)
[![npm downloads](https://img.shields.io/npm/dm/@n1ru4l/push-pull-async-iterable-iterator)](https://www.npmjs.com/package/@n1ru4l/push-pull-async-iterable-iterator)
[![Dependents](https://img.shields.io/librariesio/dependents/npm/@n1ru4l/push-pull-async-iterable-iterator)](https://www.npmjs.com/browse/depended/@n1ru4l/push-pull-async-iterable-iterator)
[![Build Status](https://img.shields.io/github/workflow/status/n1ru4l/push-pull-async-iterable-iterator/CI)](https://github.com/n1ru4l/push-pull-async-iterable-iterator/actions)

Create an AsyncIterableIterator from anything (on any modern platform) while handling back-pressure!

```bash
yarn install -E @n1ru4l/push-pull-async-iterable-iterator
```

**Standalone Usage**

```ts
import { makePushPullAsyncIterableIterator } from "@n1ru4l/push-pull-async-iterable-iterator";

const {
  pushValue,
  asyncIterableIterator
} = makePushPullAsyncIterableIterator();
pushValue(1);
pushValue(2);
pushValue(3);

// prints 1, 2, 3
for await (const value of asyncIterableIterator) {
  console.log(value);
}
```

**Check if something is an AsyncIterable**

```ts
import { isAsyncIterable } from "@n1ru4l/push-pull-async-iterable-iterator";

if (isAsyncIterable(something)) {
  for await (const value of something) {
    console.log(value);
  }
}
```

_Note:_ On Safari iOS [`Symbol.asyncIterator` is not available](https://caniuse.com/mdn-javascript_builtins_symbol_asynciterator), therefore all async iterators used must be build using [AsyncGenerators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of#Iterating_over_async_generators).
If a AsyncIterable that is NO AsyncGenerator is passed to `isAsyncIterable` on the Safari iOS environment, it will return the value `false`.

**Wrap a Sink**

```ts
import { makeAsyncIterableIteratorFromSink } from "@n1ru4l/push-pull-async-iterable-iterator";
// let's use some GraphQL client :)
import { createClient } from "graphql-ws/lib/use/ws";

const client = createClient({
  url: "ws://localhost:3000/graphql"
});

const asyncIterableIterator = makeAsyncIterableIteratorFromSink(sink => {
  const dispose = client.subscribe(
    {
      query: "{ hello }"
    },
    {
      next: sink.next,
      error: sink.error,
      complete: sink.complete
    }
  );
  return () => dispose();
});

for await (const value of asyncIterableIterator) {
  console.log(value);
}
```

**Apply an AsyncIterableIterator to a sink**

```tsx
import Observable from "zen-observable";
import {
  makePushPullAsyncIterableIterator,
  applyAsyncIterableIteratorToSink
} from "@n1ru4l/push-pull-async-iterable-iterator";

const { asyncIterableIterator } = makePushPullAsyncIterableIterator();

const observable = new Observable(sink => {
  const dispose = applyAsyncIterableIteratorToSink(asyncIterableIterator, sink);
  // dispose will be called when the observable subscription got destroyed
  // the dispose call will ensure that the async iterator is completed.
  return () => dispose();
});

const subscription = observable.subscribe({
  next: console.log,
  complete: () => console.log("done."),
  error: () => console.log("error.")
});

const interval = setInterval(() => {
  iterator.push("hi");
}, 1000);

setTimeout(() => {
  subscription.unsubscribe();
  clearInterval(interval);
}, 5000);
```

**Put it all together**

```tsx
import { Observable, RequestParameters, Variables } from "relay-runtime";
import { createClient } from "graphql-ws/lib/use/ws";
import {
  makeAsyncIterableFromSink,
  applyAsyncIterableIteratorToSink
} from "@n1ru4l/push-pull-async-iterable-iterator";
import { createApplyLiveQueryPatch } from "@n1ru4l/graphql-live-query-patch";

const client = createClient({
  url: "ws://localhost:3000/graphql"
});

export const execute = (request: RequestParameters, variables: Variables) => {
  if (!request.text) {
    throw new Error("Missing document.");
  }
  const query = request.text;

  return Observable.create<GraphQLResponse>(sink => {
    // Create our asyncIterator from a Sink
    const executionResultIterator = makeAsyncIterableFromSink(wsSink => {
      const dispose = client.subscribe({ query }, wsSink);
      return () => dispose();
    });

    const applyLiveQueryPatch = createApplyLiveQueryPatch();

    // apply some middleware to our asyncIterator
    const compositeIterator = applyLiveQueryPatch(executionResultIterator);

    // Apply our async iterable to the relay sink
    // unfortunately relay cannot consume an async iterable right now.
    const dispose = applyAsyncIterableIteratorToSink(compositeIterator, sink);
    // dispose will be called by relay when the observable is disposed
    // the dispose call will ensure that the async iterator is completed.
    return () => dispose();
  });
};
```
export declare type Sink<TValue = unknown, TError = unknown> = {
    next: (value: TValue) => void;
    error: (error: TError) => void;
    complete: () => void;
};
export {};
//# sourceMappingURL=Sink.js.map{"version":3,"file":"Sink.js","sourceRoot":"","sources":["../src/Sink.ts"],"names":[],"mappings":""}'use strict'

const net = require('net')
const tls = require('tls')
const { once } = require('events')
const timers = require('timers/promises')
const { normalizeOptions, cacheOptions } = require('./options')
const { getProxy, getProxyAgent, proxyCache } = require('./proxy.js')
const Errors = require('./errors.js')
const { Agent: AgentBase } = require('agent-base')

module.exports = class Agent extends AgentBase {
  #options
  #timeouts
  #proxy
  #noProxy
  #ProxyAgent

  constructor (options = {}) {
    const { timeouts, proxy, noProxy, ...normalizedOptions } = normalizeOptions(options)

    super(normalizedOptions)

    this.#options = normalizedOptions
    this.#timeouts = timeouts

    if (proxy) {
      this.#proxy = new URL(proxy)
      this.#noProxy = noProxy
      this.#ProxyAgent = getProxyAgent(proxy)
    }
  }

  get proxy () {
    return this.#proxy ? { url: this.#proxy } : {}
  }

  #getProxy (options) {
    if (!this.#proxy) {
      return
    }

    const proxy = getProxy(`${options.protocol}//${options.host}:${options.port}`, {
      proxy: this.#proxy,
      noProxy: this.#noProxy,
    })

    if (!proxy) {
      return
    }

    const cacheKey = cacheOptions({
      ...options,
      ...this.#options,
      timeouts: this.#timeouts,
      proxy,
    })

    if (proxyCache.has(cacheKey)) {
      return proxyCache.get(cacheKey)
    }

    let ProxyAgent = this.#ProxyAgent
    if (Array.isArray(ProxyAgent)) {
      ProxyAgent = this.isSecureEndpoint(options) ? ProxyAgent[1] : ProxyAgent[0]
    }

    const proxyAgent = new ProxyAgent(proxy, {
      ...this.#options,
      socketOptions: { family: this.#options.family },
    })
    proxyCache.set(cacheKey, proxyAgent)

    return proxyAgent
  }

  // takes an array of promises and races them against the connection timeout
  // which will throw the necessary error if it is hit. This will return the
  // result of the promise race.
  async #timeoutConnection ({ promises, options, timeout }, ac = new AbortController()) {
    if (timeout) {
      const connectionTimeout = timers.setTimeout(timeout, null, { signal: ac.signal })
        .then(() => {
          throw new Errors.ConnectionTimeoutError(`${options.host}:${options.port}`)
        }).catch((err) => {
          if (err.name === 'AbortError') {
            return
          }
          throw err
        })
      promises.push(connectionTimeout)
    }

    let result
    try {
      result = await Promise.race(promises)
      ac.abort()
    } catch (err) {
      ac.abort()
      throw err
    }
    return result
  }

  async connect (request, options) {
    // if the connection does not have its own lookup function
    // set, then use the one from our options
    options.lookup ??= this.#options.lookup

    let socket
    let timeout = this.#timeouts.connection
    const isSecureEndpoint = this.isSecureEndpoint(options)

    const proxy = this.#getProxy(options)
    if (proxy) {
      // some of the proxies will wait for the socket to fully connect before
      // returning so we have to await this while also racing it against the
      // connection timeout.
      const start = Date.now()
      socket = await this.#timeoutConnection({
        options,
        timeout,
        promises: [proxy.connect(request, options)],
      })
      // see how much time proxy.connect took and subtract it from
      // the timeout
      if (timeout) {
        timeout = timeout - (Date.now() - start)
      }
    } else {
      socket = (isSecureEndpoint ? tls : net).connect(options)
    }

    socket.setKeepAlive(this.keepAlive, this.keepAliveMsecs)
    socket.setNoDelay(this.keepAlive)

    const abortController = new AbortController()
    const { signal } = abortController

    const connectPromise = socket[isSecureEndpoint ? 'secureConnecting' : 'connecting']
      ? once(socket, isSecureEndpoint ? 'secureConnect' : 'connect', { signal })
      : Promise.resolve()

    await this.#timeoutConnection({
      options,
      timeout,
      promises: [
        connectPromise,
        once(socket, 'error', { signal }).then((err) => {
          throw err[0]
        }),
      ],
    }, abortController)

    if (this.#timeouts.idle) {
      socket.setTimeout(this.#timeouts.idle, () => {
        socket.destroy(new Errors.IdleTimeoutError(`${options.host}:${options.port}`))
      })
    }

    return socket
  }

  addRequest (request, options) {
    const proxy = this.#getProxy(options)
    // it would be better to call proxy.addRequest here but this causes the
    // http-proxy-agent to call its super.addRequest which causes the request
    // to be added to the agent twice. since we only support 3 agents
    // currently (see the required agents in proxy.js) we have manually
    // checked that the only public methods we need to call are called in the
    // next block. this could change in the future and presumably we would get
    // failing tests until we have properly called the necessary methods on
    // each of our proxy agents
    if (proxy?.setRequestProps) {
      proxy.setRequestProps(request, options)
    }

    request.setHeader('connection', this.keepAlive ? 'keep-alive' : 'close')

    if (this.#timeouts.response) {
      let responseTimeout
      request.once('finish', () => {
        setTimeout(() => {
          request.destroy(new Errors.ResponseTimeoutError(request, this.#proxy))
        }, this.#timeouts.response)
      })
      request.once('response', () => {
        clearTimeout(responseTimeout)
      })
    }

    if (this.#timeouts.transfer) {
      let transferTimeout
      request.once('response', (res) => {
        setTimeout(() => {
          res.destroy(new Errors.TransferTimeoutError(request, this.#proxy))
        }, this.#timeouts.transfer)
        res.once('close', () => {
          clearTimeout(transferTimeout)
        })
      })
    }

    return super.addRequest(request, options)
  }
}
'use strict'

const { LRUCache } = require('lru-cache')
const dns = require('dns')

// this is a factory so that each request can have its own opts (i.e. ttl)
// while still sharing the cache across all requests
const cache = new LRUCache({ max: 50 })

const getOptions = ({
  family = 0,
  hints = dns.ADDRCONFIG,
  all = false,
  verbatim = undefined,
  ttl = 5 * 60 * 1000,
  lookup = dns.lookup,
}) => ({
  // hints and lookup are returned since both are top level properties to (net|tls).connect
  hints,
  lookup: (hostname, ...args) => {
    const callback = args.pop() // callback is always last arg
    const lookupOptions = args[0] ?? {}

    const options = {
      family,
      hints,
      all,
      verbatim,
      ...(typeof lookupOptions === 'number' ? { family: lookupOptions } : lookupOptions),
    }

    const key = JSON.stringify({ hostname, ...options })

    if (cache.has(key)) {
      const cached = cache.get(key)
      return process.nextTick(callback, null, ...cached)
    }

    lookup(hostname, options, (err, ...result) => {
      if (err) {
        return callback(err)
      }

      cache.set(key, result, { ttl })
      return callback(null, ...result)
    })
  },
})

module.exports = {
  cache,
  getOptions,
}
'use strict'

class InvalidProxyProtocolError extends Error {
  constructor (url) {
    super(`Invalid protocol \`${url.protocol}\` connecting to proxy \`${url.host}\``)
    this.code = 'EINVALIDPROXY'
    this.proxy = url
  }
}

class ConnectionTimeoutError extends Error {
  constructor (host) {
    super(`Timeout connecting to host \`${host}\``)
    this.code = 'ECONNECTIONTIMEOUT'
    this.host = host
  }
}

class IdleTimeoutError extends Error {
  constructor (host) {
    super(`Idle timeout reached for host \`${host}\``)
    this.code = 'EIDLETIMEOUT'
    this.host = host
  }
}

class ResponseTimeoutError extends Error {
  constructor (request, proxy) {
    let msg = 'Response timeout '
    if (proxy) {
      msg += `from proxy \`${proxy.host}\` `
    }
    msg += `connecting to host \`${request.host}\``
    super(msg)
    this.code = 'ERESPONSETIMEOUT'
    this.proxy = proxy
    this.request = request
  }
}

class TransferTimeoutError extends Error {
  constructor (request, proxy) {
    let msg = 'Transfer timeout '
    if (proxy) {
      msg += `from proxy \`${proxy.host}\` `
    }
    msg += `for \`${request.host}\``
    super(msg)
    this.code = 'ETRANSFERTIMEOUT'
    this.proxy = proxy
    this.request = request
  }
}

module.exports = {
  InvalidProxyProtocolError,
  ConnectionTimeoutError,
  IdleTimeoutError,
  ResponseTimeoutError,
  TransferTimeoutError,
}
'use strict'

const { LRUCache } = require('lru-cache')
const { normalizeOptions, cacheOptions } = require('./options')
const { getProxy, proxyCache } = require('./proxy.js')
const dns = require('./dns.js')
const Agent = require('./agents.js')

const agentCache = new LRUCache({ max: 20 })

const getAgent = (url, { agent, proxy, noProxy, ...options } = {}) => {
  // false has meaning so this can't be a simple truthiness check
  if (agent != null) {
    return agent
  }

  url = new URL(url)

  const proxyForUrl = getProxy(url, { proxy, noProxy })
  const normalizedOptions = {
    ...normalizeOptions(options),
    proxy: proxyForUrl,
  }

  const cacheKey = cacheOptions({
    ...normalizedOptions,
    secureEndpoint: url.protocol === 'https:',
  })

  if (agentCache.has(cacheKey)) {
    return agentCache.get(cacheKey)
  }

  const newAgent = new Agent(normalizedOptions)
  agentCache.set(cacheKey, newAgent)

  return newAgent
}

module.exports = {
  getAgent,
  Agent,
  // these are exported for backwards compatability
  HttpAgent: Agent,
  HttpsAgent: Agent,
  cache: {
    proxy: proxyCache,
    agent: agentCache,
    dns: dns.cache,
    clear: () => {
      proxyCache.clear()
      agentCache.clear()
      dns.cache.clear()
    },
  },
}
'use strict'

const dns = require('./dns')

const normalizeOptions = (opts) => {
  const family = parseInt(opts.family ?? '0', 10)
  const keepAlive = opts.keepAlive ?? true

  const normalized = {
    // nodejs http agent options. these are all the defaults
    // but kept here to increase the likelihood of cache hits
    // https://nodejs.org/api/http.html#new-agentoptions
    keepAliveMsecs: keepAlive ? 1000 : undefined,
    maxSockets: opts.maxSockets ?? 15,
    maxTotalSockets: Infinity,
    maxFreeSockets: keepAlive ? 256 : undefined,
    scheduling: 'fifo',
    // then spread the rest of the options
    ...opts,
    // we already set these to their defaults that we want
    family,
    keepAlive,
    // our custom timeout options
    timeouts: {
      // the standard timeout option is mapped to our idle timeout
      // and then deleted below
      idle: opts.timeout ?? 0,
      connection: 0,
      response: 0,
      transfer: 0,
      ...opts.timeouts,
    },
    // get the dns options that go at the top level of socket connection
    ...dns.getOptions({ family, ...opts.dns }),
  }

  // remove timeout since we already used it to set our own idle timeout
  delete normalized.timeout

  return normalized
}

const createKey = (obj) => {
  let key = ''
  const sorted = Object.entries(obj).sort((a, b) => a[0] - b[0])
  for (let [k, v] of sorted) {
    if (v == null) {
      v = 'null'
    } else if (v instanceof URL) {
      v = v.toString()
    } else if (typeof v === 'object') {
      v = createKey(v)
    }
    key += `${k}:${v}:`
  }
  return key
}

const cacheOptions = ({ secureEndpoint, ...options }) => createKey({
  secureEndpoint: !!secureEndpoint,
  // socket connect options
  family: options.family,
  hints: options.hints,
  localAddress: options.localAddress,
  // tls specific connect options
  strictSsl: secureEndpoint ? !!options.rejectUnauthorized : false,
  ca: secureEndpoint ? options.ca : null,
  cert: secureEndpoint ? options.cert : null,
  key: secureEndpoint ? options.key : null,
  // http agent options
  keepAlive: options.keepAlive,
  keepAliveMsecs: options.keepAliveMsecs,
  maxSockets: options.maxSockets,
  maxTotalSockets: options.maxTotalSockets,
  maxFreeSockets: options.maxFreeSockets,
  scheduling: options.scheduling,
  // timeout options
  timeouts: options.timeouts,
  // proxy
  proxy: options.proxy,
})

module.exports = {
  normalizeOptions,
  cacheOptions,
}
'use strict'

const { HttpProxyAgent } = require('http-proxy-agent')
const { HttpsProxyAgent } = require('https-proxy-agent')
const { SocksProxyAgent } = require('socks-proxy-agent')
const { LRUCache } = require('lru-cache')
const { InvalidProxyProtocolError } = require('./errors.js')

const PROXY_CACHE = new LRUCache({ max: 20 })

const SOCKS_PROTOCOLS = new Set(SocksProxyAgent.protocols)

const PROXY_ENV_KEYS = new Set(['https_proxy', 'http_proxy', 'proxy', 'no_proxy'])

const PROXY_ENV = Object.entries(process.env).reduce((acc, [key, value]) => {
  key = key.toLowerCase()
  if (PROXY_ENV_KEYS.has(key)) {
    acc[key] = value
  }
  return acc
}, {})

const getProxyAgent = (url) => {
  url = new URL(url)

  const protocol = url.protocol.slice(0, -1)
  if (SOCKS_PROTOCOLS.has(protocol)) {
    return SocksProxyAgent
  }
  if (protocol === 'https' || protocol === 'http') {
    return [HttpProxyAgent, HttpsProxyAgent]
  }

  throw new InvalidProxyProtocolError(url)
}

const isNoProxy = (url, noProxy) => {
  if (typeof noProxy === 'string') {
    noProxy = noProxy.split(',').map((p) => p.trim()).filter(Boolean)
  }

  if (!noProxy || !noProxy.length) {
    return false
  }

  const hostSegments = url.hostname.split('.').reverse()

  return noProxy.some((no) => {
    const noSegments = no.split('.').filter(Boolean).reverse()
    if (!noSegments.length) {
      return false
    }

    for (let i = 0; i < noSegments.length; i++) {
      if (hostSegments[i] !== noSegments[i]) {
        return false
      }
    }

    return true
  })
}

const getProxy = (url, { proxy, noProxy }) => {
  url = new URL(url)

  if (!proxy) {
    proxy = url.protocol === 'https:'
      ? PROXY_ENV.https_proxy
      : PROXY_ENV.https_proxy || PROXY_ENV.http_proxy || PROXY_ENV.proxy
  }

  if (!noProxy) {
    noProxy = PROXY_ENV.no_proxy
  }

  if (!proxy || isNoProxy(url, noProxy)) {
    return null
  }

  return new URL(proxy)
}

module.exports = {
  getProxyAgent,
  getProxy,
  proxyCache: PROXY_CACHE,
}
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import * as net from 'net';
import * as tls from 'tls';
import * as http from 'http';
import { Agent, AgentConnectOpts } from 'agent-base';
import { URL } from 'url';
import type { OutgoingHttpHeaders } from 'http';
type Protocol<T> = T extends `${infer Protocol}:${infer _}` ? Protocol : never;
type ConnectOptsMap = {
    http: Omit<net.TcpNetConnectOpts, 'host' | 'port'>;
    https: Omit<tls.ConnectionOptions, 'host' | 'port'>;
};
type ConnectOpts<T> = {
    [P in keyof ConnectOptsMap]: Protocol<T> extends P ? ConnectOptsMap[P] : never;
}[keyof ConnectOptsMap];
export type HttpsProxyAgentOptions<T> = ConnectOpts<T> & http.AgentOptions & {
    headers?: OutgoingHttpHeaders | (() => OutgoingHttpHeaders);
};
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 */
export declare class HttpsProxyAgent<Uri extends string> extends Agent {
    static protocols: readonly ["http", "https"];
    readonly proxy: URL;
    proxyHeaders: OutgoingHttpHeaders | (() => OutgoingHttpHeaders);
    connectOpts: net.TcpNetConnectOpts & tls.ConnectionOptions;
    constructor(proxy: Uri | URL, opts?: HttpsProxyAgentOptions<Uri>);
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    connect(req: http.ClientRequest, opts: AgentConnectOpts): Promise<net.Socket>;
}
export {};
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;AAAA,OAAO,KAAK,GAAG,MAAM,KAAK,CAAC;AAC3B,OAAO,KAAK,GAAG,MAAM,KAAK,CAAC;AAC3B,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAG7B,OAAO,EAAE,KAAK,EAAE,gBAAgB,EAAE,MAAM,YAAY,CAAC;AACrD,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAE1B,OAAO,KAAK,EAAE,mBAAmB,EAAE,MAAM,MAAM,CAAC;AAKhD,KAAK,QAAQ,CAAC,CAAC,IAAI,CAAC,SAAS,GAAG,MAAM,QAAQ,IAAI,MAAM,CAAC,EAAE,GAAG,QAAQ,GAAG,KAAK,CAAC;AAE/E,KAAK,cAAc,GAAG;IACrB,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;IACnD,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;CACpD,CAAC;AAEF,KAAK,WAAW,CAAC,CAAC,IAAI;KACpB,CAAC,IAAI,MAAM,cAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,GAC/C,cAAc,CAAC,CAAC,CAAC,GACjB,KAAK;CACR,CAAC,MAAM,cAAc,CAAC,CAAC;AAExB,MAAM,MAAM,sBAAsB,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,GACrD,IAAI,CAAC,YAAY,GAAG;IACnB,OAAO,CAAC,EAAE,mBAAmB,GAAG,CAAC,MAAM,mBAAmB,CAAC,CAAC;CAC5D,CAAC;AAEH;;;;;;;;;;;GAWG;AACH,qBAAa,eAAe,CAAC,GAAG,SAAS,MAAM,CAAE,SAAQ,KAAK;IAC7D,MAAM,CAAC,SAAS,6BAA8B;IAE9C,QAAQ,CAAC,KAAK,EAAE,GAAG,CAAC;IACpB,YAAY,EAAE,mBAAmB,GAAG,CAAC,MAAM,mBAAmB,CAAC,CAAC;IAChE,WAAW,EAAE,GAAG,CAAC,iBAAiB,GAAG,GAAG,CAAC,iBAAiB,CAAC;gBAE/C,KAAK,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,EAAE,sBAAsB,CAAC,GAAG,CAAC;IA0BhE;;;OAGG;IACG,OAAO,CACZ,GAAG,EAAE,IAAI,CAAC,aAAa,EACvB,IAAI,EAAE,gBAAgB,GACpB,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;CA0GtB"}"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpsProxyAgent = void 0;
const net = __importStar(require("net"));
const tls = __importStar(require("tls"));
const assert_1 = __importDefault(require("assert"));
const debug_1 = __importDefault(require("debug"));
const agent_base_1 = require("agent-base");
const url_1 = require("url");
const parse_proxy_response_1 = require("./parse-proxy-response");
const debug = (0, debug_1.default)('https-proxy-agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 */
class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
        super(opts);
        this.options = { path: undefined };
        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);
        // Trim off the brackets from IPv6 addresses
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
        const port = this.proxy.port
            ? parseInt(this.proxy.port, 10)
            : this.proxy.protocol === 'https:'
                ? 443
                : 80;
        this.connectOpts = {
            // Attempt to negotiate http/1.1 for proxy servers that support http/2
            ALPNProtocols: ['http/1.1'],
            ...(opts ? omit(opts, 'headers') : null),
            host,
            port,
        };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */
    async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
            throw new TypeError('No "host" provided');
        }
        // Create a socket connection to the proxy server.
        let socket;
        if (proxy.protocol === 'https:') {
            debug('Creating `tls.Socket`: %o', this.connectOpts);
            const servername = this.connectOpts.servername || this.connectOpts.host;
            socket = tls.connect({
                ...this.connectOpts,
                servername,
            });
        }
        else {
            debug('Creating `net.Socket`: %o', this.connectOpts);
            socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === 'function'
            ? this.proxyHeaders()
            : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
        // Inject the `Proxy-Authorization` header if necessary.
        if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers['Proxy-Connection']) {
            headers['Proxy-Connection'] = this.keepAlive
                ? 'Keep-Alive'
                : 'close';
        }
        for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r\n`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r\n`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit('proxyConnect', connect);
        this.emit('proxyConnect', connect, req);
        if (connect.statusCode === 200) {
            req.once('socket', resume);
            if (opts.secureEndpoint) {
                // The proxy is connecting to a TLS server, so upgrade
                // this socket connection to a TLS connection.
                debug('Upgrading socket connection to TLS');
                const servername = opts.servername || opts.host;
                return tls.connect({
                    ...omit(opts, 'host', 'path', 'port'),
                    socket,
                    servername,
                });
            }
            return socket;
        }
        // Some other status code that's not 200... need to re-play the HTTP
        // header "data" events onto the socket once the HTTP machinery is
        // attached so that the node core `http` can parse and handle the
        // error status code.
        // Close the original socket, and a new "fake" socket is returned
        // instead, so that the proxy doesn't get the HTTP request
        // written to it (which may contain `Authorization` headers or other
        // sensitive data).
        //
        // See: https://hackerone.com/reports/541502
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        // Need to wait for the "socket" event to re-play the "data" events.
        req.once('socket', (s) => {
            debug('Replaying proxy buffer for failed request');
            (0, assert_1.default)(s.listenerCount('data') > 0);
            // Replay the "buffered" Buffer onto the fake `socket`, since at
            // this point the HTTP module machinery has been hooked up for
            // the user.
            s.push(buffered);
            s.push(null);
        });
        return fakeSocket;
    }
}
HttpsProxyAgent.protocols = ['http', 'https'];
exports.HttpsProxyAgent = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
}
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { IncomingHttpHeaders } from 'http';
import { Readable } from 'stream';
export interface ConnectResponse {
    statusCode: number;
    statusText: string;
    headers: IncomingHttpHeaders;
}
export declare function parseProxyResponse(socket: Readable): Promise<{
    connect: ConnectResponse;
    buffered: Buffer;
}>;
//# sourceMappingURL=parse-proxy-response.d.ts.map{"version":3,"file":"parse-proxy-response.d.ts","sourceRoot":"","sources":["../src/parse-proxy-response.ts"],"names":[],"mappings":";;;AACA,OAAO,EAAE,mBAAmB,EAAE,MAAM,MAAM,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAIlC,MAAM,WAAW,eAAe;IAC/B,UAAU,EAAE,MAAM,CAAC;IACnB,UAAU,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,mBAAmB,CAAC;CAC7B;AAED,wBAAgB,kBAAkB,CACjC,MAAM,EAAE,QAAQ,GACd,OAAO,CAAC;IAAE,OAAO,EAAE,eAAe,CAAC;IAAC,QAAQ,EAAE,MAAM,CAAA;CAAE,CAAC,CAyGzD"}"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseProxyResponse = void 0;
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b)
                ondata(b);
            else
                socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('readable', read);
        }
        function onend() {
            cleanup();
            debug('onend');
            reject(new Error('Proxy connection ended before receiving CONNECT response'));
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const headerParts = buffered
                .slice(0, endOfHeaders)
                .toString('ascii')
                .split('\r\n');
            const firstLine = headerParts.shift();
            if (!firstLine) {
                socket.destroy();
                return reject(new Error('No header received from proxy CONNECT response'));
            }
            const firstLineParts = firstLine.split(' ');
            const statusCode = +firstLineParts[1];
            const statusText = firstLineParts.slice(2).join(' ');
            const headers = {};
            for (const header of headerParts) {
                if (!header)
                    continue;
                const firstColon = header.indexOf(':');
                if (firstColon === -1) {
                    socket.destroy();
                    return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
                }
                const key = header.slice(0, firstColon).toLowerCase();
                const value = header.slice(firstColon + 1).trimStart();
                const current = headers[key];
                if (typeof current === 'string') {
                    headers[key] = [current, value];
                }
                else if (Array.isArray(current)) {
                    current.push(value);
                }
                else {
                    headers[key] = value;
                }
            }
            debug('got proxy server response: %o %o', firstLine, headers);
            cleanup();
            resolve({
                connect: {
                    statusCode,
                    statusText,
                    headers,
                },
                buffered,
            });
        }
        socket.on('error', onerror);
        socket.on('end', onend);
        read();
    });
}
exports.parseProxyResponse = parseProxyResponse;
//# sourceMappingURL=parse-proxy-response.js.map{"version":3,"file":"parse-proxy-response.js","sourceRoot":"","sources":["../src/parse-proxy-response.ts"],"names":[],"mappings":"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"}(The MIT License)

Copyright (c) 2013 Nathan Rajlich <nathan@tootallnate.net>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.{
  "name": "https-proxy-agent",
  "version": "7.0.5",
  "description": "An HTTP(s) proxy `http.Agent` implementation for HTTPS",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/TooTallNate/proxy-agents.git",
    "directory": "packages/https-proxy-agent"
  },
  "keywords": [
    "https",
    "proxy",
    "endpoint",
    "agent"
  ],
  "author": "Nathan Rajlich <nathan@tootallnate.net> (http://n8.io/)",
  "license": "MIT",
  "dependencies": {
    "agent-base": "^7.0.2",
    "debug": "4"
  },
  "devDependencies": {
    "@types/async-retry": "^1.4.5",
    "@types/debug": "4",
    "@types/jest": "^29.5.1",
    "@types/node": "^14.18.45",
    "async-listen": "^3.0.0",
    "async-retry": "^1.3.3",
    "jest": "^29.5.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.4",
    "proxy": "2.2.0",
    "tsconfig": "0.0.0"
  },
  "engines": {
    "node": ">= 14"
  },
  "scripts": {
    "build": "tsc",
    "test": "jest --env node --verbose --bail test/test.ts",
    "test-e2e": "jest --env node --verbose --bail test/e2e.test.ts",
    "lint": "eslint --ext .ts",
    "pack": "node ../../scripts/pack.mjs"
  }
}https-proxy-agent
================
### An HTTP(s) proxy `http.Agent` implementation for HTTPS

This module provides an `http.Agent` implementation that connects to a specified
HTTP or HTTPS proxy server, and can be used with the built-in `https` module.

Specifically, this `Agent` implementation connects to an intermediary "proxy"
server and issues the [CONNECT HTTP method][CONNECT], which tells the proxy to
open a direct TCP connection to the destination server.

Since this agent implements the CONNECT HTTP method, it also works with other
protocols that use this method when connecting over proxies (i.e. WebSockets).
See the "Examples" section below for more.

Examples
--------

#### `https` module example

```ts
import * as https from 'https';
import { HttpsProxyAgent } from 'https-proxy-agent';

const agent = new HttpsProxyAgent('http://168.63.76.32:3128');

https.get('https://example.com', { agent }, (res) => {
  console.log('"response" event!', res.headers);
  res.pipe(process.stdout);
});
```

#### `ws` WebSocket connection example

```ts
import WebSocket from 'ws';
import { HttpsProxyAgent } from 'https-proxy-agent';

const agent = new HttpsProxyAgent('http://168.63.76.32:3128');
const socket = new WebSocket('ws://echo.websocket.org', { agent });

socket.on('open', function () {
  console.log('"open" event!');
  socket.send('hello world');
});

socket.on('message', function (data, flags) {
  console.log('"message" event! %j %j', data, flags);
  socket.close();
});
```

API
---

### new HttpsProxyAgent(proxy: string | URL, options?: HttpsProxyAgentOptions)

The `HttpsProxyAgent` class implements an `http.Agent` subclass that connects
to the specified "HTTP(s) proxy server" in order to proxy HTTPS and/or WebSocket
requests. This is achieved by using the [HTTP `CONNECT` method][CONNECT].

The `proxy` argument is the URL for the proxy server.

The `options` argument accepts the usual `http.Agent` constructor options, and
some additional properties:

 * `headers` - Object containing additional headers to send to the proxy server
   in the `CONNECT` request.

[CONNECT]: http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_Tunneling
/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     *
     * - `evict`: The item was evicted because it is the least recently used,
     *   and the cache is full.
     * - `set`: A new value was set, overwriting the old value being disposed.
     * - `delete`: The item was explicitly deleted, either by calling
     *   {@link LRUCache#delete}, {@link LRUCache#clear}, or
     *   {@link LRUCache#set} with an undefined value.
     * - `expire`: The item was removed due to exceeding its TTL.
     * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned
     *   `undefined` or was aborted, causing the item to be deleted.
     */
    type DisposeReason = 'evict' | 'set' | 'delete' | 'expire' | 'fetch';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Occasionally, it may be useful to track the internal behavior of the
     * cache, particularly for logging, debugging, or for behavior within the
     * `fetchMethod`. To do this, you can pass a `status` object to the
     * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},
     * {@link LRUCache#memo}, and {@link LRUCache#has} methods.
     *
     * The `status` option should be a plain JavaScript object. The following
     * fields will be set on it appropriately, depending on the situation.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no {@link OptionsBase.fetchMethod}, so
         *   {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    interface MemoOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.memoMethod} as
         * the {@link MemoizerOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#memo} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface MemoOptionsWithContext<K, V, FC> extends MemoOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#memo} when the FC type is
     * `undefined` or `void`
     */
    interface MemoOptionsNoContext<K, V> extends MemoOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options provided to the
     * {@link OptionsBase.memoMethod} function.
     */
    interface MemoizerOptions<K, V, FC = unknown> {
        options: MemoizerMemoOptions<K, V, FC>;
        /**
         * Object provided in the {@link MemoOptions.context} option to
         * {@link LRUCache#memo}
         */
        context: FC;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#memo}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link MemoOptions.forceRefresh}, and
     * {@link MemoerOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.memoMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the memoMethod is called.
     */
    interface MemoizerMemoOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        status?: Status<V>;
        size?: Size;
        start?: Milliseconds;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * the type signature for the {@link OptionsBase.memoMethod} option.
     */
    type Memoizer<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: MemoizerOptions<K, V, FC>) => V;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     *
     * All options are also available on the {@link LRUCache} instance, making
     * it safe to pass an LRUCache instance as the options argumemnt to
     * make another empty cache of the same type.
     *
     * Some options are marked as read-only, because changing them after
     * instantiation is not safe. Changing any of the other options will of
     * course only have an effect on subsequent method calls.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         *
         * **It is strongly recommended to set a `max` to prevent unbounded growth
         * of the cache.**
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed by
         * default, and MAY live in the cache, contributing to its LRU max, long
         * after they have expired, unless {@link OptionsBase.ttlAutopurge} is
         * set.
         *
         * If set to `0` (the default value), then that means "do not track
         * TTL", not "expire immediately".
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * This is not primarily a TTL cache, and does not make strong TTL
         * guarantees. There is no pre-emptive pruning of expired items, but you
         * _may_ set a TTL on the cache, and it will treat expired items as missing
         * when they are fetched, and delete them.
         *
         * Optional, but must be a non-negative integer in ms if specified.
         *
         * This may be overridden by passing an options object to `cache.set()`.
         *
         * At least one of `max`, `maxSize`, or `TTL` is required. This must be a
         * positive integer if set.
         *
         * Even if ttl tracking is enabled, **it is strongly recommended to set a
         * `max` to prevent unbounded growth of the cache.**
         *
         * If ttl tracking is enabled, and `max` and `maxSize` are not set,
         * and `ttlAutopurge` is not set, then a warning will be emitted
         * cautioning about the potential for unbounded memory consumption.
         * (The TypeScript definitions will also discourage this.)
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         *
         * Note that this may *significantly* degrade performance, especially if
         * the cache is storing a large number of items. It is almost always best
         * to just leave the stale items in the cache, and let them fall out as new
         * items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * Use with caution!
         */
        ttlAutopurge?: boolean;
        /**
         * When using time-expiring entries with `ttl`, setting this to `true` will
         * make each item's age reset to 0 whenever it is retrieved from cache with
         * {@link LRUCache#get}, causing it to not expire. (It can still fall out
         * of cache based on recency of use, of course.)
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         */
        updateAgeOnGet?: boolean;
        /**
         * When using time-expiring entries with `ttl`, setting this to `true` will
         * make each item's age reset to 0 whenever its presence in the cache is
         * checked with {@link LRUCache#has}, causing it to not expire. (It can
         * still fall out of cache based on recency of use, of course.)
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         *
         * By default, if you set `ttl`, stale items will only be deleted from the
         * cache when you `get(key)`. That is, it's not preemptively pruning items,
         * unless {@link OptionsBase.ttlAutopurge} is set.
         *
         * If you set `allowStale:true`, it'll return the stale value *as well as*
         * deleting it. If you don't set this, then it'll return `undefined` when
         * you try to get a stale entry.
         *
         * Note that when a stale entry is fetched, _even if it is returned due to
         * `allowStale` being set_, it is removed from the cache immediately. You
         * can suppress this behavior by setting
         * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in
         * the options provided to {@link LRUCache#get}.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         * The `cache.has()` method will always return `false` for stale items.
         *
         * Only relevant if a ttl is set.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the
         * cache, as `dispose(value, key, reason)`.
         *
         * This can be handy if you want to close file descriptors or do
         * other cleanup tasks when items are no longer stored in the cache.
         *
         * **NOTE**: It is called _before_ the item has been fully removed
         * from the cache, so if you want to put it right back in, you need
         * to wait until the next tick. If you try to add it back in during
         * the `dispose()` function call, it will break things in subtle and
         * weird ways.
         *
         * Unlike several other options, this may _not_ be overridden by
         * passing an option to `set()`, for performance reasons.
         *
         * The `reason` will be one of the following strings, corresponding
         * to the reason for the item's deletion:
         *
         * - `evict` Item was evicted to make space for a new addition
         * - `set` Item was overwritten by a new value
         * - `expire` Item expired its TTL
         * - `fetch` Item was deleted due to a failed or aborted fetch, or a
         *   fetchMethod returning `undefined.
         * - `delete` Item was removed by explicit `cache.delete(key)`,
         *   `cache.clear()`, or `cache.set(key, undefined)`.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         *
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         *
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         *
         * Only relevant if `dispose` or `disposeAfter` are set.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when setting a new
         * value for an existing key (ie, when updating a value rather than
         * inserting a new value).  Note that the TTL value is _always_ set (if
         * provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         *
         * May be passed as an option to {@link LRUCache#set}.
         */
        noUpdateTTL?: boolean;
        /**
         * Set to a positive integer to track the sizes of items added to the
         * cache, and automatically evict items in order to stay below this size.
         * Note that this may result in fewer than `max` items being stored.
         *
         * Attempting to add an item to the cache whose calculated size is greater
         * that this amount will be a no-op. The item will not be cached, and no
         * other items will be evicted.
         *
         * Optional, must be a positive integer if provided.
         *
         * Sets `maxEntrySize` to the same value, unless a different value is
         * provided for `maxEntrySize`.
         *
         * At least one of `max`, `maxSize`, or `TTL` is required. This must be a
         * positive integer if set.
         *
         * Even if size tracking is enabled, **it is strongly recommended to set a
         * `max` to prevent unbounded growth of the cache.**
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then
         * it will not be stored in the cache.
         *
         * Attempting to add an item whose calculated size is greater than
         * this amount will not cache the item or evict any old items, but
         * WILL delete an existing value if one is already present.
         *
         * Optional, must be a positive integer if provided. Defaults to
         * the value of `maxSize` if provided.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * Requires {@link OptionsBase.maxSize} to be set.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         *
         * ```ts
         * fetchMethod(key, staleValue, { signal, options, context })
         * ```
         *
         * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent
         * to `Promise.resolve(cache.get(key))`.
         *
         * If at any time, `signal.aborted` is set to `true`, or if the
         * `signal.onabort` method is called, or if it emits an `'abort'` event
         * which you can listen to with `addEventListener`, then that means that
         * the fetch should be abandoned. This may be passed along to async
         * functions aware of AbortController/AbortSignal behavior.
         *
         * The `fetchMethod` should **only** return `undefined` or a Promise
         * resolving to `undefined` if the AbortController signaled an `abort`
         * event. In all other cases, it should return or resolve to a value
         * suitable for adding to the cache.
         *
         * The `options` object is a union of the options that may be provided to
         * `set()` and `get()`. If they are modified, then that will result in
         * modifying the settings to `cache.set()` when the value is resolved, and
         * in the case of
         * {@link OptionsBase.noDeleteOnFetchRejection} and
         * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of
         * `fetchMethod` failures.
         *
         * For example, a DNS cache may update the TTL based on the value returned
         * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Method that provides the implementation for {@link LRUCache#memo}
         */
        memoMethod?: Memoizer<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         *
         * When using time-expiring entries with `ttl`, by default stale
         * items will be removed from the cache when the key is accessed
         * with `cache.get()`.
         *
         * Setting this option will cause stale items to remain in the cache, until
         * they are explicitly deleted with `cache.delete(key)`, or retrieved with
         * `noDeleteOnStaleGet` set to `false`.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         *
         * Only relevant if a ttl is used.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the {@link LRUCache#fetch}
         * fails, not any other times.
         *
         * If a `fetchMethod` fails, and there is no stale value available, the
         * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are
         * suppressed.
         *
         * Implies `noDeleteOnFetchRejection`.
         *
         * This may be set in calls to `fetch()`, or defaulted on the constructor,
         * or overridden by modifying the options object in the `fetchMethod`.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches
         * an `'abort'` event, whether user-triggered, or due to internal cache
         * behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls
         * are not immediately resolved or rejected when they are aborted, and
         * instead take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * For example:
         *
         * ```ts
         * const c = new LRUCache({
         *   ttl: 100,
         *   ignoreFetchAbort: true,
         *   allowStaleOnFetchAbort: true,
         *   fetchMethod: async (key, oldValue, { signal }) => {
         *     // note: do NOT pass the signal to fetch()!
         *     // let's say this fetch can take a long time.
         *     const res = await fetch(`https://slow-backend-server/${key}`)
         *     return await res.json()
         *   },
         * })
         *
         * // this will return the stale value after 100ms, while still
         * // updating in the background for next time.
         * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })
         * ```
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If the value is in the cache and not stale, then the returned
     * Promise resolves to the value.
     *
     * If not in the cache, or beyond its TTL staleness, then
     * `fetchMethod(key, staleValue, { options, signal, context })` is
     * called, and the value returned will be added to the cache once
     * resolved.
     *
     * If called with `allowStale`, and an asynchronous fetch is
     * currently in progress to reload a stale value, then the former
     * stale value will be returned.
     *
     * If called with `forceRefresh`, then the cached item will be
     * re-fetched, even if it is not stale. However, if `allowStale` is also
     * set, then the old value will still be returned. This is useful
     * in cases where you want to force a reload of a cached value. If
     * a background fetch is already in progress, then `forceRefresh`
     * has no effect.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     *
     * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is
     * effectively an alias for `Promise.resolve(cache.get(key))`.
     *
     * When the fetch method resolves to a value, if the fetch has not
     * been aborted due to deletion, eviction, or being overwritten,
     * then it is added to the cache using the options provided.
     *
     * If the key is evicted or deleted before the `fetchMethod`
     * resolves, then the AbortSignal passed to the `fetchMethod` will
     * receive an `abort` event, and the promise returned by `fetch()`
     * will reject with the reason for the abort.
     *
     * If a `signal` is passed to the `fetch()` call, then aborting the
     * signal will abort the fetch and cause the `fetch()` promise to
     * reject with the reason provided.
     *
     * **Setting `context`**
     *
     * If an `FC` type is set to a type other than `unknown`, `void`, or
     * `undefined` in the {@link LRUCache} constructor, then all
     * calls to `cache.fetch()` _must_ provide a `context` option. If
     * set to `undefined` or `void`, then calls to fetch _must not_
     * provide a `context` option.
     *
     * The `context` param allows you to provide arbitrary data that
     * might be relevant in the course of fetching the data. It is only
     * relevant for the course of a single `fetch()` operation, and
     * discarded afterwards.
     *
     * **Note: `fetch()` calls are inflight-unique**
     *
     * If you call `fetch()` multiple times with the same key value,
     * then every call after the first will resolve on the same
     * promise<sup>1</sup>,
     * _even if they have different settings that would otherwise change
     * the behavior of the fetch_, such as `noDeleteOnFetchRejection`
     * or `ignoreFetchAbort`.
     *
     * In most cases, this is not a problem (in fact, only fetching
     * something once is what you probably want, if you're caching in
     * the first place). If you are changing the fetch() options
     * dramatically between runs, there's a good chance that you might
     * be trying to fit divergent semantics into a single object, and
     * would be better off with multiple cache instances.
     *
     * **1**: Ie, they're not the "same Promise", but they resolve at
     * the same time, because they're both waiting on the same
     * underlying fetchMethod response.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * In some cases, `cache.fetch()` may resolve to `undefined`, either because
     * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning
     * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or
     * because `ignoreFetchAbort` was specified (either to the constructor or
     * in the {@link LRUCache.FetchOptions}). Also, the
     * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making
     * the test even more complicated.
     *
     * Because inferring the cases where `undefined` might be returned are so
     * cumbersome, but testing for `undefined` can also be annoying, this method
     * can be used, which will reject if `this.fetch()` resolves to undefined.
     */
    forceFetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<V>;
    forceFetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<V>;
    /**
     * If the key is found in the cache, then this is equivalent to
     * {@link LRUCache#get}. If not, in the cache, then calculate the value using
     * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.
     *
     * If an `FC` type is set to a type other than `unknown`, `void`, or
     * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`
     * _must_ provide a `context` option. If set to `undefined` or `void`, then
     * calls to memo _must not_ provide a `context` option.
     *
     * The `context` param allows you to provide arbitrary data that might be
     * relevant in the course of fetching the data. It is only relevant for the
     * course of a single `memo()` operation, and discarded afterwards.
     */
    memo(k: K, memoOptions: unknown extends FC ? LRUCache.MemoOptions<K, V, FC> : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V> : LRUCache.MemoOptionsWithContext<K, V, FC>): V;
    memo(k: unknown extends FC ? K : FC extends undefined | void ? K : never, memoOptions?: unknown extends FC ? LRUCache.MemoOptions<K, V, FC> : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V> : never): V;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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"}"use strict";
/**
 * @module LRUCache
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LRUCache = void 0;
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n"]}"use strict";var G=(l,t,e)=>{if(!t.has(l))throw TypeError("Cannot "+e)};var j=(l,t,e)=>(G(l,t,"read from private field"),e?e.call(l):t.get(l)),I=(l,t,e)=>{if(t.has(l))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(l):t.set(l,e)},x=(l,t,e,i)=>(G(l,t,"write to private field"),i?i.call(l,e):t.set(l,e),e);Object.defineProperty(exports,"__esModule",{value:!0});exports.LRUCache=void 0;var T=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,P=new Set,U=typeof process=="object"&&process?process:{},H=(l,t,e,i)=>{typeof U.emitWarning=="function"?U.emitWarning(l,t,e,i):console.error(`[${e}] ${t}: ${l}`)},D=globalThis.AbortController,N=globalThis.AbortSignal;if(typeof D>"u"){N=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,s){this._onabort.push(s)}},D=class{constructor(){t()}signal=new N;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(let s of this.signal._onabort)s(i);this.signal.onabort?.(i)}}};let l=U.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",t=()=>{l&&(l=!1,H("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}var V=l=>!P.has(l),Y=Symbol("type"),A=l=>l&&l===Math.floor(l)&&l>0&&isFinite(l),k=l=>A(l)?l<=Math.pow(2,8)?Uint8Array:l<=Math.pow(2,16)?Uint16Array:l<=Math.pow(2,32)?Uint32Array:l<=Number.MAX_SAFE_INTEGER?E:null:null,E=class extends Array{constructor(t){super(t),this.fill(0)}},v,O=class{heap;length;static create(t){let e=k(t);if(!e)return[];x(O,v,!0);let i=new O(t,e);return x(O,v,!1),i}constructor(t,e){if(!j(O,v))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}},W=O;v=new WeakMap,I(W,v,!1);var C=class{#g;#f;#p;#w;#R;#W;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#n;#S;#s;#i;#t;#l;#c;#o;#h;#_;#r;#b;#m;#u;#y;#E;#a;static unsafeExposeInternals(t){return{starts:t.#m,ttls:t.#u,sizes:t.#b,keyMap:t.#s,keyList:t.#i,valList:t.#t,next:t.#l,prev:t.#c,get head(){return t.#o},get tail(){return t.#h},free:t.#_,isBackgroundFetch:e=>t.#e(e),backgroundFetch:(e,i,s,n)=>t.#x(e,i,s,n),moveToTail:e=>t.#C(e),indexes:e=>t.#A(e),rindexes:e=>t.#F(e),isStale:e=>t.#d(e)}}get max(){return this.#g}get maxSize(){return this.#f}get calculatedSize(){return this.#S}get size(){return this.#n}get fetchMethod(){return this.#R}get memoMethod(){return this.#W}get dispose(){return this.#p}get disposeAfter(){return this.#w}constructor(t){let{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:n,updateAgeOnGet:h,updateAgeOnHas:o,allowStale:r,dispose:g,disposeAfter:b,noDisposeOnSet:f,noUpdateTTL:u,maxSize:c=0,maxEntrySize:F=0,sizeCalculation:d,fetchMethod:S,memoMethod:a,noDeleteOnFetchRejection:w,noDeleteOnStaleGet:m,allowStaleOnFetchRejection:p,allowStaleOnFetchAbort:_,ignoreFetchAbort:z}=t;if(e!==0&&!A(e))throw new TypeError("max option must be a nonnegative integer");let y=e?k(e):Array;if(!y)throw new Error("invalid max value: "+e);if(this.#g=e,this.#f=c,this.maxEntrySize=F||this.#f,this.sizeCalculation=d,this.sizeCalculation){if(!this.#f&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(a!==void 0&&typeof a!="function")throw new TypeError("memoMethod must be a function if defined");if(this.#W=a,S!==void 0&&typeof S!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.#R=S,this.#E=!!S,this.#s=new Map,this.#i=new Array(e).fill(void 0),this.#t=new Array(e).fill(void 0),this.#l=new y(e),this.#c=new y(e),this.#o=0,this.#h=0,this.#_=W.create(e),this.#n=0,this.#S=0,typeof g=="function"&&(this.#p=g),typeof b=="function"?(this.#w=b,this.#r=[]):(this.#w=void 0,this.#r=void 0),this.#y=!!this.#p,this.#a=!!this.#w,this.noDisposeOnSet=!!f,this.noUpdateTTL=!!u,this.noDeleteOnFetchRejection=!!w,this.allowStaleOnFetchRejection=!!p,this.allowStaleOnFetchAbort=!!_,this.ignoreFetchAbort=!!z,this.maxEntrySize!==0){if(this.#f!==0&&!A(this.#f))throw new TypeError("maxSize must be a positive integer if specified");if(!A(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#P()}if(this.allowStale=!!r,this.noDeleteOnStaleGet=!!m,this.updateAgeOnGet=!!h,this.updateAgeOnHas=!!o,this.ttlResolution=A(s)||s===0?s:1,this.ttlAutopurge=!!n,this.ttl=i||0,this.ttl){if(!A(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#U()}if(this.#g===0&&this.ttl===0&&this.#f===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#g&&!this.#f){let R="LRU_CACHE_UNBOUNDED";V(R)&&(P.add(R),H("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",R,C))}}getRemainingTTL(t){return this.#s.has(t)?1/0:0}#U(){let t=new E(this.#g),e=new E(this.#g);this.#u=t,this.#m=e,this.#M=(n,h,o=T.now())=>{if(e[n]=h!==0?o:0,t[n]=h,h!==0&&this.ttlAutopurge){let r=setTimeout(()=>{this.#d(n)&&this.#T(this.#i[n],"expire")},h+1);r.unref&&r.unref()}},this.#v=n=>{e[n]=t[n]!==0?T.now():0},this.#O=(n,h)=>{if(t[h]){let o=t[h],r=e[h];if(!o||!r)return;n.ttl=o,n.start=r,n.now=i||s();let g=n.now-r;n.remainingTTL=o-g}};let i=0,s=()=>{let n=T.now();if(this.ttlResolution>0){i=n;let h=setTimeout(()=>i=0,this.ttlResolution);h.unref&&h.unref()}return n};this.getRemainingTTL=n=>{let h=this.#s.get(n);if(h===void 0)return 0;let o=t[h],r=e[h];if(!o||!r)return 1/0;let g=(i||s())-r;return o-g},this.#d=n=>{let h=e[n],o=t[n];return!!o&&!!h&&(i||s())-h>o}}#v=()=>{};#O=()=>{};#M=()=>{};#d=()=>!1;#P(){let t=new E(this.#g);this.#S=0,this.#b=t,this.#z=e=>{this.#S-=t[e],t[e]=0},this.#G=(e,i,s,n)=>{if(this.#e(i))return 0;if(!A(s))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(s=n(i,e),!A(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return s},this.#D=(e,i,s)=>{if(t[e]=i,this.#f){let n=this.#f-t[e];for(;this.#S>n;)this.#L(!0)}this.#S+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#S)}}#z=t=>{};#D=(t,e,i)=>{};#G=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#A({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#h;!(!this.#j(e)||((t||!this.#d(e))&&(yield e),e===this.#o));)e=this.#c[e]}*#F({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#o;!(!this.#j(e)||((t||!this.#d(e))&&(yield e),e===this.#h));)e=this.#l[e]}#j(t){return t!==void 0&&this.#s.get(this.#i[t])===t}*entries(){for(let t of this.#A())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*rentries(){for(let t of this.#F())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*keys(){for(let t of this.#A()){let e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*rkeys(){for(let t of this.#F()){let e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*values(){for(let t of this.#A())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}*rvalues(){for(let t of this.#F())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#A()){let s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;if(n!==void 0&&t(n,this.#i[i],this))return this.get(this.#i[i],e)}}forEach(t,e=this){for(let i of this.#A()){let s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}rforEach(t,e=this){for(let i of this.#F()){let s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}purgeStale(){let t=!1;for(let e of this.#F({allowStale:!0}))this.#d(e)&&(this.#T(this.#i[e],"expire"),t=!0);return t}info(t){let e=this.#s.get(t);if(e===void 0)return;let i=this.#t[e],s=this.#e(i)?i.__staleWhileFetching:i;if(s===void 0)return;let n={value:s};if(this.#u&&this.#m){let h=this.#u[e],o=this.#m[e];if(h&&o){let r=h-(T.now()-o);n.ttl=r,n.start=Date.now()}}return this.#b&&(n.size=this.#b[e]),n}dump(){let t=[];for(let e of this.#A({allowStale:!0})){let i=this.#i[e],s=this.#t[e],n=this.#e(s)?s.__staleWhileFetching:s;if(n===void 0||i===void 0)continue;let h={value:n};if(this.#u&&this.#m){h.ttl=this.#u[e];let o=T.now()-this.#m[e];h.start=Math.floor(Date.now()-o)}this.#b&&(h.size=this.#b[e]),t.unshift([i,h])}return t}load(t){this.clear();for(let[e,i]of t){if(i.start){let s=Date.now()-i.start;i.start=T.now()-s}this.set(e,i.value,i)}}set(t,e,i={}){if(e===void 0)return this.delete(t),this;let{ttl:s=this.ttl,start:n,noDisposeOnSet:h=this.noDisposeOnSet,sizeCalculation:o=this.sizeCalculation,status:r}=i,{noUpdateTTL:g=this.noUpdateTTL}=i,b=this.#G(t,e,i.size||0,o);if(this.maxEntrySize&&b>this.maxEntrySize)return r&&(r.set="miss",r.maxEntrySizeExceeded=!0),this.#T(t,"set"),this;let f=this.#n===0?void 0:this.#s.get(t);if(f===void 0)f=this.#n===0?this.#h:this.#_.length!==0?this.#_.pop():this.#n===this.#g?this.#L(!1):this.#n,this.#i[f]=t,this.#t[f]=e,this.#s.set(t,f),this.#l[this.#h]=f,this.#c[f]=this.#h,this.#h=f,this.#n++,this.#D(f,b,r),r&&(r.set="add"),g=!1;else{this.#C(f);let u=this.#t[f];if(e!==u){if(this.#E&&this.#e(u)){u.__abortController.abort(new Error("replaced"));let{__staleWhileFetching:c}=u;c!==void 0&&!h&&(this.#y&&this.#p?.(c,t,"set"),this.#a&&this.#r?.push([c,t,"set"]))}else h||(this.#y&&this.#p?.(u,t,"set"),this.#a&&this.#r?.push([u,t,"set"]));if(this.#z(f),this.#D(f,b,r),this.#t[f]=e,r){r.set="replace";let c=u&&this.#e(u)?u.__staleWhileFetching:u;c!==void 0&&(r.oldValue=c)}}else r&&(r.set="update")}if(s!==0&&!this.#u&&this.#U(),this.#u&&(g||this.#M(f,s,n),r&&this.#O(r,f)),!h&&this.#a&&this.#r){let u=this.#r,c;for(;c=u?.shift();)this.#w?.(...c)}return this}pop(){try{for(;this.#n;){let t=this.#t[this.#o];if(this.#L(!0),this.#e(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(t!==void 0)return t}}finally{if(this.#a&&this.#r){let t=this.#r,e;for(;e=t?.shift();)this.#w?.(...e)}}}#L(t){let e=this.#o,i=this.#i[e],s=this.#t[e];return this.#E&&this.#e(s)?s.__abortController.abort(new Error("evicted")):(this.#y||this.#a)&&(this.#y&&this.#p?.(s,i,"evict"),this.#a&&this.#r?.push([s,i,"evict"])),this.#z(e),t&&(this.#i[e]=void 0,this.#t[e]=void 0,this.#_.push(e)),this.#n===1?(this.#o=this.#h=0,this.#_.length=0):this.#o=this.#l[e],this.#s.delete(i),this.#n--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,n=this.#s.get(t);if(n!==void 0){let h=this.#t[n];if(this.#e(h)&&h.__staleWhileFetching===void 0)return!1;if(this.#d(n))s&&(s.has="stale",this.#O(s,n));else return i&&this.#v(n),s&&(s.has="hit",this.#O(s,n)),!0}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#s.get(t);if(s===void 0||!i&&this.#d(s))return;let n=this.#t[s];return this.#e(n)?n.__staleWhileFetching:n}#x(t,e,i,s){let n=e===void 0?void 0:this.#t[e];if(this.#e(n))return n;let h=new D,{signal:o}=i;o?.addEventListener("abort",()=>h.abort(o.reason),{signal:h.signal});let r={signal:h.signal,options:i,context:s},g=(d,S=!1)=>{let{aborted:a}=h.signal,w=i.ignoreFetchAbort&&d!==void 0;if(i.status&&(a&&!S?(i.status.fetchAborted=!0,i.status.fetchError=h.signal.reason,w&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),a&&!w&&!S)return f(h.signal.reason);let m=c;return this.#t[e]===c&&(d===void 0?m.__staleWhileFetching?this.#t[e]=m.__staleWhileFetching:this.#T(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,d,r.options))),d},b=d=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=d),f(d)),f=d=>{let{aborted:S}=h.signal,a=S&&i.allowStaleOnFetchAbort,w=a||i.allowStaleOnFetchRejection,m=w||i.noDeleteOnFetchRejection,p=c;if(this.#t[e]===c&&(!m||p.__staleWhileFetching===void 0?this.#T(t,"fetch"):a||(this.#t[e]=p.__staleWhileFetching)),w)return i.status&&p.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),p.__staleWhileFetching;if(p.__returned===p)throw d},u=(d,S)=>{let a=this.#R?.(t,n,r);a&&a instanceof Promise&&a.then(w=>d(w===void 0?void 0:w),S),h.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(d(void 0),i.allowStaleOnFetchAbort&&(d=w=>g(w,!0)))})};i.status&&(i.status.fetchDispatched=!0);let c=new Promise(u).then(g,b),F=Object.assign(c,{__abortController:h,__staleWhileFetching:n,__returned:void 0});return e===void 0?(this.set(t,F,{...r.options,status:void 0}),e=this.#s.get(t)):this.#t[e]=F,F}#e(t){if(!this.#E)return!1;let e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof D}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:r=0,sizeCalculation:g=this.sizeCalculation,noUpdateTTL:b=this.noUpdateTTL,noDeleteOnFetchRejection:f=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:c=this.ignoreFetchAbort,allowStaleOnFetchAbort:F=this.allowStaleOnFetchAbort,context:d,forceRefresh:S=!1,status:a,signal:w}=e;if(!this.#E)return a&&(a.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:a});let m={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:h,noDisposeOnSet:o,size:r,sizeCalculation:g,noUpdateTTL:b,noDeleteOnFetchRejection:f,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:F,ignoreFetchAbort:c,status:a,signal:w},p=this.#s.get(t);if(p===void 0){a&&(a.fetch="miss");let _=this.#x(t,p,m,d);return _.__returned=_}else{let _=this.#t[p];if(this.#e(_)){let M=i&&_.__staleWhileFetching!==void 0;return a&&(a.fetch="inflight",M&&(a.returnedStale=!0)),M?_.__staleWhileFetching:_.__returned=_}let z=this.#d(p);if(!S&&!z)return a&&(a.fetch="hit"),this.#C(p),s&&this.#v(p),a&&this.#O(a,p),_;let y=this.#x(t,p,m,d),L=y.__staleWhileFetching!==void 0&&i;return a&&(a.fetch=z?"stale":"refresh",L&&z&&(a.returnedStale=!0)),L?y.__staleWhileFetching:y.__returned=y}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(i===void 0)throw new Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#W;if(!i)throw new Error("no memoMethod provided to constructor");let{context:s,forceRefresh:n,...h}=e,o=this.get(t,h);if(!n&&o!==void 0)return o;let r=i(t,o,{options:h,context:s});return this.set(t,r,h),r}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:h}=e,o=this.#s.get(t);if(o!==void 0){let r=this.#t[o],g=this.#e(r);return h&&this.#O(h,o),this.#d(o)?(h&&(h.get="stale"),g?(h&&i&&r.__staleWhileFetching!==void 0&&(h.returnedStale=!0),i?r.__staleWhileFetching:void 0):(n||this.#T(t,"expire"),h&&i&&(h.returnedStale=!0),i?r:void 0)):(h&&(h.get="hit"),g?r.__staleWhileFetching:(this.#C(o),s&&this.#v(o),r))}else h&&(h.get="miss")}#I(t,e){this.#c[e]=t,this.#l[t]=e}#C(t){t!==this.#h&&(t===this.#o?this.#o=this.#l[t]:this.#I(this.#c[t],this.#l[t]),this.#I(this.#h,t),this.#h=t)}delete(t){return this.#T(t,"delete")}#T(t,e){let i=!1;if(this.#n!==0){let s=this.#s.get(t);if(s!==void 0)if(i=!0,this.#n===1)this.#N(e);else{this.#z(s);let n=this.#t[s];if(this.#e(n)?n.__abortController.abort(new Error("deleted")):(this.#y||this.#a)&&(this.#y&&this.#p?.(n,t,e),this.#a&&this.#r?.push([n,t,e])),this.#s.delete(t),this.#i[s]=void 0,this.#t[s]=void 0,s===this.#h)this.#h=this.#c[s];else if(s===this.#o)this.#o=this.#l[s];else{let h=this.#c[s];this.#l[h]=this.#l[s];let o=this.#l[s];this.#c[o]=this.#c[s]}this.#n--,this.#_.push(s)}}if(this.#a&&this.#r?.length){let s=this.#r,n;for(;n=s?.shift();)this.#w?.(...n)}return i}clear(){return this.#N("delete")}#N(t){for(let e of this.#F({allowStale:!0})){let i=this.#t[e];if(this.#e(i))i.__abortController.abort(new Error("deleted"));else{let s=this.#i[e];this.#y&&this.#p?.(i,s,t),this.#a&&this.#r?.push([i,s,t])}}if(this.#s.clear(),this.#t.fill(void 0),this.#i.fill(void 0),this.#u&&this.#m&&(this.#u.fill(0),this.#m.fill(0)),this.#b&&this.#b.fill(0),this.#o=0,this.#h=0,this.#_.length=0,this.#S=0,this.#n=0,this.#a&&this.#r){let e=this.#r,i;for(;i=e?.shift();)this.#w?.(...i)}}};exports.LRUCache=C;
//# sourceMappingURL=index.min.js.map
{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["perf", "warned", "PROCESS", "emitWarning", "msg", "type", "code", "fn", "AC", "AS", "_", "warnACPolyfill", "reason", "printACPolyfillWarning", "shouldWarn", "TYPE", "isPosInt", "n", "getUintArray", "max", "ZeroArray", "size", "_Stack", "HeapCls", "__privateSet", "_constructing", "s", "__privateGet", "Stack", "__privateAdd", "LRUCache", "#max", "#maxSize", "#dispose", "#disposeAfter", "#fetchMethod", "#memoMethod", "#size", "#calculatedSize", "#keyMap", "#keyList", "#valList", "#next", "#prev", "#head", "#tail", "#free", "#disposed", "#sizes", "#starts", "#ttls", "#hasDispose", "#hasFetchMethod", "#hasDisposeAfter", "c", "p", "#isBackgroundFetch", "k", "index", "options", "context", "#backgroundFetch", "#moveToTail", "#indexes", "#rindexes", "#isStale", "ttl", "ttlResolution", "ttlAutopurge", "updateAgeOnGet", "updateAgeOnHas", "allowStale", "dispose", "disposeAfter", "noDisposeOnSet", "noUpdateTTL", "maxSize", "maxEntrySize", "sizeCalculation", "fetchMethod", "memoMethod", "noDeleteOnFetchRejection", "noDeleteOnStaleGet", "allowStaleOnFetchRejection", "allowStaleOnFetchAbort", "ignoreFetchAbort", "UintArray", "#initializeSizeTracking", "#initializeTTLTracking", "key", "ttls", "starts", "#setItemTTL", "start", "t", "#delete", "#updateItemAge", "#statusTTL", "status", "cachedNow", "getNow", "age", "sizes", "#removeItemSize", "#requireSize", "v", "#addItemSize", "#evict", "_i", "_s", "_st", "_k", "_v", "i", "#isValidIndex", "getOptions", "value", "thisp", "deleted", "entry", "remain", "arr", "setOptions", "oldVal", "oldValue", "dt", "task", "val", "free", "head", "hasOptions", "peekOptions", "ac", "signal", "fetchOpts", "cb", "updateCache", "aborted", "ignoreAbort", "fetchFail", "bf", "eb", "er", "allowStaleAborted", "noDelete", "pcall", "res", "rej", "fmp", "b", "fetchOptions", "forceRefresh", "stale", "isStale", "staleVal", "memoOptions", "vv", "fetching", "#connect", "#clear", "pi", "ni"]
}
{
  "type": "commonjs"
}
/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     *
     * - `evict`: The item was evicted because it is the least recently used,
     *   and the cache is full.
     * - `set`: A new value was set, overwriting the old value being disposed.
     * - `delete`: The item was explicitly deleted, either by calling
     *   {@link LRUCache#delete}, {@link LRUCache#clear}, or
     *   {@link LRUCache#set} with an undefined value.
     * - `expire`: The item was removed due to exceeding its TTL.
     * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned
     *   `undefined` or was aborted, causing the item to be deleted.
     */
    type DisposeReason = 'evict' | 'set' | 'delete' | 'expire' | 'fetch';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Occasionally, it may be useful to track the internal behavior of the
     * cache, particularly for logging, debugging, or for behavior within the
     * `fetchMethod`. To do this, you can pass a `status` object to the
     * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},
     * {@link LRUCache#memo}, and {@link LRUCache#has} methods.
     *
     * The `status` option should be a plain JavaScript object. The following
     * fields will be set on it appropriately, depending on the situation.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no {@link OptionsBase.fetchMethod}, so
         *   {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    interface MemoOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.memoMethod} as
         * the {@link MemoizerOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#memo} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface MemoOptionsWithContext<K, V, FC> extends MemoOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#memo} when the FC type is
     * `undefined` or `void`
     */
    interface MemoOptionsNoContext<K, V> extends MemoOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options provided to the
     * {@link OptionsBase.memoMethod} function.
     */
    interface MemoizerOptions<K, V, FC = unknown> {
        options: MemoizerMemoOptions<K, V, FC>;
        /**
         * Object provided in the {@link MemoOptions.context} option to
         * {@link LRUCache#memo}
         */
        context: FC;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#memo}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link MemoOptions.forceRefresh}, and
     * {@link MemoerOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.memoMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the memoMethod is called.
     */
    interface MemoizerMemoOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        status?: Status<V>;
        size?: Size;
        start?: Milliseconds;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * the type signature for the {@link OptionsBase.memoMethod} option.
     */
    type Memoizer<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: MemoizerOptions<K, V, FC>) => V;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     *
     * All options are also available on the {@link LRUCache} instance, making
     * it safe to pass an LRUCache instance as the options argumemnt to
     * make another empty cache of the same type.
     *
     * Some options are marked as read-only, because changing them after
     * instantiation is not safe. Changing any of the other options will of
     * course only have an effect on subsequent method calls.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         *
         * **It is strongly recommended to set a `max` to prevent unbounded growth
         * of the cache.**
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed by
         * default, and MAY live in the cache, contributing to its LRU max, long
         * after they have expired, unless {@link OptionsBase.ttlAutopurge} is
         * set.
         *
         * If set to `0` (the default value), then that means "do not track
         * TTL", not "expire immediately".
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * This is not primarily a TTL cache, and does not make strong TTL
         * guarantees. There is no pre-emptive pruning of expired items, but you
         * _may_ set a TTL on the cache, and it will treat expired items as missing
         * when they are fetched, and delete them.
         *
         * Optional, but must be a non-negative integer in ms if specified.
         *
         * This may be overridden by passing an options object to `cache.set()`.
         *
         * At least one of `max`, `maxSize`, or `TTL` is required. This must be a
         * positive integer if set.
         *
         * Even if ttl tracking is enabled, **it is strongly recommended to set a
         * `max` to prevent unbounded growth of the cache.**
         *
         * If ttl tracking is enabled, and `max` and `maxSize` are not set,
         * and `ttlAutopurge` is not set, then a warning will be emitted
         * cautioning about the potential for unbounded memory consumption.
         * (The TypeScript definitions will also discourage this.)
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         *
         * Note that this may *significantly* degrade performance, especially if
         * the cache is storing a large number of items. It is almost always best
         * to just leave the stale items in the cache, and let them fall out as new
         * items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * Use with caution!
         */
        ttlAutopurge?: boolean;
        /**
         * When using time-expiring entries with `ttl`, setting this to `true` will
         * make each item's age reset to 0 whenever it is retrieved from cache with
         * {@link LRUCache#get}, causing it to not expire. (It can still fall out
         * of cache based on recency of use, of course.)
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         */
        updateAgeOnGet?: boolean;
        /**
         * When using time-expiring entries with `ttl`, setting this to `true` will
         * make each item's age reset to 0 whenever its presence in the cache is
         * checked with {@link LRUCache#has}, causing it to not expire. (It can
         * still fall out of cache based on recency of use, of course.)
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         *
         * By default, if you set `ttl`, stale items will only be deleted from the
         * cache when you `get(key)`. That is, it's not preemptively pruning items,
         * unless {@link OptionsBase.ttlAutopurge} is set.
         *
         * If you set `allowStale:true`, it'll return the stale value *as well as*
         * deleting it. If you don't set this, then it'll return `undefined` when
         * you try to get a stale entry.
         *
         * Note that when a stale entry is fetched, _even if it is returned due to
         * `allowStale` being set_, it is removed from the cache immediately. You
         * can suppress this behavior by setting
         * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in
         * the options provided to {@link LRUCache#get}.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         * The `cache.has()` method will always return `false` for stale items.
         *
         * Only relevant if a ttl is set.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the
         * cache, as `dispose(value, key, reason)`.
         *
         * This can be handy if you want to close file descriptors or do
         * other cleanup tasks when items are no longer stored in the cache.
         *
         * **NOTE**: It is called _before_ the item has been fully removed
         * from the cache, so if you want to put it right back in, you need
         * to wait until the next tick. If you try to add it back in during
         * the `dispose()` function call, it will break things in subtle and
         * weird ways.
         *
         * Unlike several other options, this may _not_ be overridden by
         * passing an option to `set()`, for performance reasons.
         *
         * The `reason` will be one of the following strings, corresponding
         * to the reason for the item's deletion:
         *
         * - `evict` Item was evicted to make space for a new addition
         * - `set` Item was overwritten by a new value
         * - `expire` Item expired its TTL
         * - `fetch` Item was deleted due to a failed or aborted fetch, or a
         *   fetchMethod returning `undefined.
         * - `delete` Item was removed by explicit `cache.delete(key)`,
         *   `cache.clear()`, or `cache.set(key, undefined)`.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         *
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         *
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         *
         * Only relevant if `dispose` or `disposeAfter` are set.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when setting a new
         * value for an existing key (ie, when updating a value rather than
         * inserting a new value).  Note that the TTL value is _always_ set (if
         * provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         *
         * May be passed as an option to {@link LRUCache#set}.
         */
        noUpdateTTL?: boolean;
        /**
         * Set to a positive integer to track the sizes of items added to the
         * cache, and automatically evict items in order to stay below this size.
         * Note that this may result in fewer than `max` items being stored.
         *
         * Attempting to add an item to the cache whose calculated size is greater
         * that this amount will be a no-op. The item will not be cached, and no
         * other items will be evicted.
         *
         * Optional, must be a positive integer if provided.
         *
         * Sets `maxEntrySize` to the same value, unless a different value is
         * provided for `maxEntrySize`.
         *
         * At least one of `max`, `maxSize`, or `TTL` is required. This must be a
         * positive integer if set.
         *
         * Even if size tracking is enabled, **it is strongly recommended to set a
         * `max` to prevent unbounded growth of the cache.**
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then
         * it will not be stored in the cache.
         *
         * Attempting to add an item whose calculated size is greater than
         * this amount will not cache the item or evict any old items, but
         * WILL delete an existing value if one is already present.
         *
         * Optional, must be a positive integer if provided. Defaults to
         * the value of `maxSize` if provided.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * Requires {@link OptionsBase.maxSize} to be set.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         *
         * ```ts
         * fetchMethod(key, staleValue, { signal, options, context })
         * ```
         *
         * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent
         * to `Promise.resolve(cache.get(key))`.
         *
         * If at any time, `signal.aborted` is set to `true`, or if the
         * `signal.onabort` method is called, or if it emits an `'abort'` event
         * which you can listen to with `addEventListener`, then that means that
         * the fetch should be abandoned. This may be passed along to async
         * functions aware of AbortController/AbortSignal behavior.
         *
         * The `fetchMethod` should **only** return `undefined` or a Promise
         * resolving to `undefined` if the AbortController signaled an `abort`
         * event. In all other cases, it should return or resolve to a value
         * suitable for adding to the cache.
         *
         * The `options` object is a union of the options that may be provided to
         * `set()` and `get()`. If they are modified, then that will result in
         * modifying the settings to `cache.set()` when the value is resolved, and
         * in the case of
         * {@link OptionsBase.noDeleteOnFetchRejection} and
         * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of
         * `fetchMethod` failures.
         *
         * For example, a DNS cache may update the TTL based on the value returned
         * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Method that provides the implementation for {@link LRUCache#memo}
         */
        memoMethod?: Memoizer<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         *
         * When using time-expiring entries with `ttl`, by default stale
         * items will be removed from the cache when the key is accessed
         * with `cache.get()`.
         *
         * Setting this option will cause stale items to remain in the cache, until
         * they are explicitly deleted with `cache.delete(key)`, or retrieved with
         * `noDeleteOnStaleGet` set to `false`.
         *
         * This may be overridden by passing an options object to `cache.get()`.
         *
         * Only relevant if a ttl is used.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the {@link LRUCache#fetch}
         * fails, not any other times.
         *
         * If a `fetchMethod` fails, and there is no stale value available, the
         * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are
         * suppressed.
         *
         * Implies `noDeleteOnFetchRejection`.
         *
         * This may be set in calls to `fetch()`, or defaulted on the constructor,
         * or overridden by modifying the options object in the `fetchMethod`.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches
         * an `'abort'` event, whether user-triggered, or due to internal cache
         * behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls
         * are not immediately resolved or rejected when they are aborted, and
         * instead take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * For example:
         *
         * ```ts
         * const c = new LRUCache({
         *   ttl: 100,
         *   ignoreFetchAbort: true,
         *   allowStaleOnFetchAbort: true,
         *   fetchMethod: async (key, oldValue, { signal }) => {
         *     // note: do NOT pass the signal to fetch()!
         *     // let's say this fetch can take a long time.
         *     const res = await fetch(`https://slow-backend-server/${key}`)
         *     return await res.json()
         *   },
         * })
         *
         * // this will return the stale value after 100ms, while still
         * // updating in the background for next time.
         * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })
         * ```
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort: boolean;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals<K extends {}, V extends {}, FC extends unknown = unknown>(c: LRUCache<K, V, FC>): {
        starts: ZeroArray | undefined;
        ttls: ZeroArray | undefined;
        sizes: ZeroArray | undefined;
        keyMap: Map<K, number>;
        keyList: (K | undefined)[];
        valList: (V | BackgroundFetch<V> | undefined)[];
        next: NumberArray;
        prev: NumberArray;
        readonly head: Index;
        readonly tail: Index;
        free: StackLike;
        isBackgroundFetch: (p: any) => boolean;
        backgroundFetch: (k: K, index: number | undefined, options: LRUCache.FetchOptions<K, V, FC>, context: any) => BackgroundFetch<V>;
        moveToTail: (index: number) => void;
        indexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        rindexes: (options?: {
            allowStale: boolean;
        }) => Generator<Index, void, unknown>;
        isStale: (index: number | undefined) => boolean;
    };
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize(): LRUCache.Count;
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize(): LRUCache.Size;
    /**
     * The number of items stored in the cache (read-only)
     */
    get size(): LRUCache.Count;
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined;
    get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined;
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose(): LRUCache.Disposer<K, V> | undefined;
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter(): LRUCache.Disposer<K, V> | undefined;
    constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>);
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key: K): number;
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    entries(): Generator<[K, V], void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    rentries(): Generator<(K | V | BackgroundFetch<V> | undefined)[], void, unknown>;
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    keys(): Generator<K, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    rkeys(): Generator<K, void, unknown>;
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    values(): Generator<V, void, unknown>;
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    rvalues(): Generator<V | BackgroundFetch<V> | undefined, void, unknown>;
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator](): Generator<[K, V], void, unknown>;
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag]: string;
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any, thisp?: any): void;
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale(): boolean;
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key: K): LRUCache.Entry<V> | undefined;
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump(): [K, LRUCache.Entry<V>][];
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr: [K, LRUCache.Entry<V>][]): void;
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k: K, v: V | BackgroundFetch<V> | undefined, setOptions?: LRUCache.SetOptions<K, V, FC>): this;
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop(): V | undefined;
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k: K, hasOptions?: LRUCache.HasOptions<K, V, FC>): boolean;
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k: K, peekOptions?: LRUCache.PeekOptions<K, V, FC>): V | undefined;
    /**
     * Make an asynchronous cached fetch using the
     * {@link LRUCache.OptionsBase.fetchMethod} function.
     *
     * If the value is in the cache and not stale, then the returned
     * Promise resolves to the value.
     *
     * If not in the cache, or beyond its TTL staleness, then
     * `fetchMethod(key, staleValue, { options, signal, context })` is
     * called, and the value returned will be added to the cache once
     * resolved.
     *
     * If called with `allowStale`, and an asynchronous fetch is
     * currently in progress to reload a stale value, then the former
     * stale value will be returned.
     *
     * If called with `forceRefresh`, then the cached item will be
     * re-fetched, even if it is not stale. However, if `allowStale` is also
     * set, then the old value will still be returned. This is useful
     * in cases where you want to force a reload of a cached value. If
     * a background fetch is already in progress, then `forceRefresh`
     * has no effect.
     *
     * If multiple fetches for the same key are issued, then they will all be
     * coalesced into a single call to fetchMethod.
     *
     * Note that this means that handling options such as
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},
     * {@link LRUCache.FetchOptions.signal},
     * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be
     * determined by the FIRST fetch() call for a given key.
     *
     * This is a known (fixable) shortcoming which will be addresed on when
     * someone complains about it, as the fix would involve added complexity and
     * may not be worth the costs for this edge case.
     *
     * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is
     * effectively an alias for `Promise.resolve(cache.get(key))`.
     *
     * When the fetch method resolves to a value, if the fetch has not
     * been aborted due to deletion, eviction, or being overwritten,
     * then it is added to the cache using the options provided.
     *
     * If the key is evicted or deleted before the `fetchMethod`
     * resolves, then the AbortSignal passed to the `fetchMethod` will
     * receive an `abort` event, and the promise returned by `fetch()`
     * will reject with the reason for the abort.
     *
     * If a `signal` is passed to the `fetch()` call, then aborting the
     * signal will abort the fetch and cause the `fetch()` promise to
     * reject with the reason provided.
     *
     * **Setting `context`**
     *
     * If an `FC` type is set to a type other than `unknown`, `void`, or
     * `undefined` in the {@link LRUCache} constructor, then all
     * calls to `cache.fetch()` _must_ provide a `context` option. If
     * set to `undefined` or `void`, then calls to fetch _must not_
     * provide a `context` option.
     *
     * The `context` param allows you to provide arbitrary data that
     * might be relevant in the course of fetching the data. It is only
     * relevant for the course of a single `fetch()` operation, and
     * discarded afterwards.
     *
     * **Note: `fetch()` calls are inflight-unique**
     *
     * If you call `fetch()` multiple times with the same key value,
     * then every call after the first will resolve on the same
     * promise<sup>1</sup>,
     * _even if they have different settings that would otherwise change
     * the behavior of the fetch_, such as `noDeleteOnFetchRejection`
     * or `ignoreFetchAbort`.
     *
     * In most cases, this is not a problem (in fact, only fetching
     * something once is what you probably want, if you're caching in
     * the first place). If you are changing the fetch() options
     * dramatically between runs, there's a good chance that you might
     * be trying to fit divergent semantics into a single object, and
     * would be better off with multiple cache instances.
     *
     * **1**: Ie, they're not the "same Promise", but they resolve at
     * the same time, because they're both waiting on the same
     * underlying fetchMethod response.
     */
    fetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<undefined | V>;
    fetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<undefined | V>;
    /**
     * In some cases, `cache.fetch()` may resolve to `undefined`, either because
     * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning
     * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or
     * because `ignoreFetchAbort` was specified (either to the constructor or
     * in the {@link LRUCache.FetchOptions}). Also, the
     * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making
     * the test even more complicated.
     *
     * Because inferring the cases where `undefined` might be returned are so
     * cumbersome, but testing for `undefined` can also be annoying, this method
     * can be used, which will reject if `this.fetch()` resolves to undefined.
     */
    forceFetch(k: K, fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : LRUCache.FetchOptionsWithContext<K, V, FC>): Promise<V>;
    forceFetch(k: unknown extends FC ? K : FC extends undefined | void ? K : never, fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC> : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V> : never): Promise<V>;
    /**
     * If the key is found in the cache, then this is equivalent to
     * {@link LRUCache#get}. If not, in the cache, then calculate the value using
     * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.
     *
     * If an `FC` type is set to a type other than `unknown`, `void`, or
     * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`
     * _must_ provide a `context` option. If set to `undefined` or `void`, then
     * calls to memo _must not_ provide a `context` option.
     *
     * The `context` param allows you to provide arbitrary data that might be
     * relevant in the course of fetching the data. It is only relevant for the
     * course of a single `memo()` operation, and discarded afterwards.
     */
    memo(k: K, memoOptions: unknown extends FC ? LRUCache.MemoOptions<K, V, FC> : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V> : LRUCache.MemoOptionsWithContext<K, V, FC>): V;
    memo(k: unknown extends FC ? K : FC extends undefined | void ? K : never, memoOptions?: unknown extends FC ? LRUCache.MemoOptions<K, V, FC> : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V> : never): V;
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k: K, getOptions?: LRUCache.GetOptions<K, V, FC>): V | undefined;
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k: K): boolean;
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear(): void;
}
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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"}/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
export class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n"]}var G=(l,t,e)=>{if(!t.has(l))throw TypeError("Cannot "+e)};var I=(l,t,e)=>(G(l,t,"read from private field"),e?e.call(l):t.get(l)),j=(l,t,e)=>{if(t.has(l))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(l):t.set(l,e)},x=(l,t,e,i)=>(G(l,t,"write to private field"),i?i.call(l,e):t.set(l,e),e);var T=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,P=new Set,M=typeof process=="object"&&process?process:{},H=(l,t,e,i)=>{typeof M.emitWarning=="function"?M.emitWarning(l,t,e,i):console.error(`[${e}] ${t}: ${l}`)},W=globalThis.AbortController,N=globalThis.AbortSignal;if(typeof W>"u"){N=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,s){this._onabort.push(s)}},W=class{constructor(){t()}signal=new N;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(let s of this.signal._onabort)s(i);this.signal.onabort?.(i)}}};let l=M.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",t=()=>{l&&(l=!1,H("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}var V=l=>!P.has(l),Y=Symbol("type"),A=l=>l&&l===Math.floor(l)&&l>0&&isFinite(l),k=l=>A(l)?l<=Math.pow(2,8)?Uint8Array:l<=Math.pow(2,16)?Uint16Array:l<=Math.pow(2,32)?Uint32Array:l<=Number.MAX_SAFE_INTEGER?O:null:null,O=class extends Array{constructor(t){super(t),this.fill(0)}},z,E=class{heap;length;static create(t){let e=k(t);if(!e)return[];x(E,z,!0);let i=new E(t,e);return x(E,z,!1),i}constructor(t,e){if(!I(E,z))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}},R=E;z=new WeakMap,j(R,z,!1);var D=class{#g;#f;#p;#w;#R;#W;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#n;#S;#s;#i;#t;#l;#c;#o;#h;#_;#r;#m;#b;#u;#y;#O;#a;static unsafeExposeInternals(t){return{starts:t.#b,ttls:t.#u,sizes:t.#m,keyMap:t.#s,keyList:t.#i,valList:t.#t,next:t.#l,prev:t.#c,get head(){return t.#o},get tail(){return t.#h},free:t.#_,isBackgroundFetch:e=>t.#e(e),backgroundFetch:(e,i,s,n)=>t.#x(e,i,s,n),moveToTail:e=>t.#C(e),indexes:e=>t.#A(e),rindexes:e=>t.#F(e),isStale:e=>t.#d(e)}}get max(){return this.#g}get maxSize(){return this.#f}get calculatedSize(){return this.#S}get size(){return this.#n}get fetchMethod(){return this.#R}get memoMethod(){return this.#W}get dispose(){return this.#p}get disposeAfter(){return this.#w}constructor(t){let{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:n,updateAgeOnGet:h,updateAgeOnHas:o,allowStale:r,dispose:g,disposeAfter:m,noDisposeOnSet:f,noUpdateTTL:u,maxSize:c=0,maxEntrySize:F=0,sizeCalculation:d,fetchMethod:S,memoMethod:a,noDeleteOnFetchRejection:w,noDeleteOnStaleGet:b,allowStaleOnFetchRejection:p,allowStaleOnFetchAbort:_,ignoreFetchAbort:v}=t;if(e!==0&&!A(e))throw new TypeError("max option must be a nonnegative integer");let y=e?k(e):Array;if(!y)throw new Error("invalid max value: "+e);if(this.#g=e,this.#f=c,this.maxEntrySize=F||this.#f,this.sizeCalculation=d,this.sizeCalculation){if(!this.#f&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(a!==void 0&&typeof a!="function")throw new TypeError("memoMethod must be a function if defined");if(this.#W=a,S!==void 0&&typeof S!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.#R=S,this.#O=!!S,this.#s=new Map,this.#i=new Array(e).fill(void 0),this.#t=new Array(e).fill(void 0),this.#l=new y(e),this.#c=new y(e),this.#o=0,this.#h=0,this.#_=R.create(e),this.#n=0,this.#S=0,typeof g=="function"&&(this.#p=g),typeof m=="function"?(this.#w=m,this.#r=[]):(this.#w=void 0,this.#r=void 0),this.#y=!!this.#p,this.#a=!!this.#w,this.noDisposeOnSet=!!f,this.noUpdateTTL=!!u,this.noDeleteOnFetchRejection=!!w,this.allowStaleOnFetchRejection=!!p,this.allowStaleOnFetchAbort=!!_,this.ignoreFetchAbort=!!v,this.maxEntrySize!==0){if(this.#f!==0&&!A(this.#f))throw new TypeError("maxSize must be a positive integer if specified");if(!A(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#P()}if(this.allowStale=!!r,this.noDeleteOnStaleGet=!!b,this.updateAgeOnGet=!!h,this.updateAgeOnHas=!!o,this.ttlResolution=A(s)||s===0?s:1,this.ttlAutopurge=!!n,this.ttl=i||0,this.ttl){if(!A(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#M()}if(this.#g===0&&this.ttl===0&&this.#f===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#g&&!this.#f){let C="LRU_CACHE_UNBOUNDED";V(C)&&(P.add(C),H("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",C,D))}}getRemainingTTL(t){return this.#s.has(t)?1/0:0}#M(){let t=new O(this.#g),e=new O(this.#g);this.#u=t,this.#b=e,this.#U=(n,h,o=T.now())=>{if(e[n]=h!==0?o:0,t[n]=h,h!==0&&this.ttlAutopurge){let r=setTimeout(()=>{this.#d(n)&&this.#T(this.#i[n],"expire")},h+1);r.unref&&r.unref()}},this.#z=n=>{e[n]=t[n]!==0?T.now():0},this.#E=(n,h)=>{if(t[h]){let o=t[h],r=e[h];if(!o||!r)return;n.ttl=o,n.start=r,n.now=i||s();let g=n.now-r;n.remainingTTL=o-g}};let i=0,s=()=>{let n=T.now();if(this.ttlResolution>0){i=n;let h=setTimeout(()=>i=0,this.ttlResolution);h.unref&&h.unref()}return n};this.getRemainingTTL=n=>{let h=this.#s.get(n);if(h===void 0)return 0;let o=t[h],r=e[h];if(!o||!r)return 1/0;let g=(i||s())-r;return o-g},this.#d=n=>{let h=e[n],o=t[n];return!!o&&!!h&&(i||s())-h>o}}#z=()=>{};#E=()=>{};#U=()=>{};#d=()=>!1;#P(){let t=new O(this.#g);this.#S=0,this.#m=t,this.#v=e=>{this.#S-=t[e],t[e]=0},this.#G=(e,i,s,n)=>{if(this.#e(i))return 0;if(!A(s))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(s=n(i,e),!A(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return s},this.#D=(e,i,s)=>{if(t[e]=i,this.#f){let n=this.#f-t[e];for(;this.#S>n;)this.#L(!0)}this.#S+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#S)}}#v=t=>{};#D=(t,e,i)=>{};#G=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#A({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#h;!(!this.#I(e)||((t||!this.#d(e))&&(yield e),e===this.#o));)e=this.#c[e]}*#F({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#o;!(!this.#I(e)||((t||!this.#d(e))&&(yield e),e===this.#h));)e=this.#l[e]}#I(t){return t!==void 0&&this.#s.get(this.#i[t])===t}*entries(){for(let t of this.#A())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*rentries(){for(let t of this.#F())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*keys(){for(let t of this.#A()){let e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*rkeys(){for(let t of this.#F()){let e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*values(){for(let t of this.#A())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}*rvalues(){for(let t of this.#F())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#A()){let s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;if(n!==void 0&&t(n,this.#i[i],this))return this.get(this.#i[i],e)}}forEach(t,e=this){for(let i of this.#A()){let s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}rforEach(t,e=this){for(let i of this.#F()){let s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}purgeStale(){let t=!1;for(let e of this.#F({allowStale:!0}))this.#d(e)&&(this.#T(this.#i[e],"expire"),t=!0);return t}info(t){let e=this.#s.get(t);if(e===void 0)return;let i=this.#t[e],s=this.#e(i)?i.__staleWhileFetching:i;if(s===void 0)return;let n={value:s};if(this.#u&&this.#b){let h=this.#u[e],o=this.#b[e];if(h&&o){let r=h-(T.now()-o);n.ttl=r,n.start=Date.now()}}return this.#m&&(n.size=this.#m[e]),n}dump(){let t=[];for(let e of this.#A({allowStale:!0})){let i=this.#i[e],s=this.#t[e],n=this.#e(s)?s.__staleWhileFetching:s;if(n===void 0||i===void 0)continue;let h={value:n};if(this.#u&&this.#b){h.ttl=this.#u[e];let o=T.now()-this.#b[e];h.start=Math.floor(Date.now()-o)}this.#m&&(h.size=this.#m[e]),t.unshift([i,h])}return t}load(t){this.clear();for(let[e,i]of t){if(i.start){let s=Date.now()-i.start;i.start=T.now()-s}this.set(e,i.value,i)}}set(t,e,i={}){if(e===void 0)return this.delete(t),this;let{ttl:s=this.ttl,start:n,noDisposeOnSet:h=this.noDisposeOnSet,sizeCalculation:o=this.sizeCalculation,status:r}=i,{noUpdateTTL:g=this.noUpdateTTL}=i,m=this.#G(t,e,i.size||0,o);if(this.maxEntrySize&&m>this.maxEntrySize)return r&&(r.set="miss",r.maxEntrySizeExceeded=!0),this.#T(t,"set"),this;let f=this.#n===0?void 0:this.#s.get(t);if(f===void 0)f=this.#n===0?this.#h:this.#_.length!==0?this.#_.pop():this.#n===this.#g?this.#L(!1):this.#n,this.#i[f]=t,this.#t[f]=e,this.#s.set(t,f),this.#l[this.#h]=f,this.#c[f]=this.#h,this.#h=f,this.#n++,this.#D(f,m,r),r&&(r.set="add"),g=!1;else{this.#C(f);let u=this.#t[f];if(e!==u){if(this.#O&&this.#e(u)){u.__abortController.abort(new Error("replaced"));let{__staleWhileFetching:c}=u;c!==void 0&&!h&&(this.#y&&this.#p?.(c,t,"set"),this.#a&&this.#r?.push([c,t,"set"]))}else h||(this.#y&&this.#p?.(u,t,"set"),this.#a&&this.#r?.push([u,t,"set"]));if(this.#v(f),this.#D(f,m,r),this.#t[f]=e,r){r.set="replace";let c=u&&this.#e(u)?u.__staleWhileFetching:u;c!==void 0&&(r.oldValue=c)}}else r&&(r.set="update")}if(s!==0&&!this.#u&&this.#M(),this.#u&&(g||this.#U(f,s,n),r&&this.#E(r,f)),!h&&this.#a&&this.#r){let u=this.#r,c;for(;c=u?.shift();)this.#w?.(...c)}return this}pop(){try{for(;this.#n;){let t=this.#t[this.#o];if(this.#L(!0),this.#e(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(t!==void 0)return t}}finally{if(this.#a&&this.#r){let t=this.#r,e;for(;e=t?.shift();)this.#w?.(...e)}}}#L(t){let e=this.#o,i=this.#i[e],s=this.#t[e];return this.#O&&this.#e(s)?s.__abortController.abort(new Error("evicted")):(this.#y||this.#a)&&(this.#y&&this.#p?.(s,i,"evict"),this.#a&&this.#r?.push([s,i,"evict"])),this.#v(e),t&&(this.#i[e]=void 0,this.#t[e]=void 0,this.#_.push(e)),this.#n===1?(this.#o=this.#h=0,this.#_.length=0):this.#o=this.#l[e],this.#s.delete(i),this.#n--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,n=this.#s.get(t);if(n!==void 0){let h=this.#t[n];if(this.#e(h)&&h.__staleWhileFetching===void 0)return!1;if(this.#d(n))s&&(s.has="stale",this.#E(s,n));else return i&&this.#z(n),s&&(s.has="hit",this.#E(s,n)),!0}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#s.get(t);if(s===void 0||!i&&this.#d(s))return;let n=this.#t[s];return this.#e(n)?n.__staleWhileFetching:n}#x(t,e,i,s){let n=e===void 0?void 0:this.#t[e];if(this.#e(n))return n;let h=new W,{signal:o}=i;o?.addEventListener("abort",()=>h.abort(o.reason),{signal:h.signal});let r={signal:h.signal,options:i,context:s},g=(d,S=!1)=>{let{aborted:a}=h.signal,w=i.ignoreFetchAbort&&d!==void 0;if(i.status&&(a&&!S?(i.status.fetchAborted=!0,i.status.fetchError=h.signal.reason,w&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),a&&!w&&!S)return f(h.signal.reason);let b=c;return this.#t[e]===c&&(d===void 0?b.__staleWhileFetching?this.#t[e]=b.__staleWhileFetching:this.#T(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,d,r.options))),d},m=d=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=d),f(d)),f=d=>{let{aborted:S}=h.signal,a=S&&i.allowStaleOnFetchAbort,w=a||i.allowStaleOnFetchRejection,b=w||i.noDeleteOnFetchRejection,p=c;if(this.#t[e]===c&&(!b||p.__staleWhileFetching===void 0?this.#T(t,"fetch"):a||(this.#t[e]=p.__staleWhileFetching)),w)return i.status&&p.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),p.__staleWhileFetching;if(p.__returned===p)throw d},u=(d,S)=>{let a=this.#R?.(t,n,r);a&&a instanceof Promise&&a.then(w=>d(w===void 0?void 0:w),S),h.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(d(void 0),i.allowStaleOnFetchAbort&&(d=w=>g(w,!0)))})};i.status&&(i.status.fetchDispatched=!0);let c=new Promise(u).then(g,m),F=Object.assign(c,{__abortController:h,__staleWhileFetching:n,__returned:void 0});return e===void 0?(this.set(t,F,{...r.options,status:void 0}),e=this.#s.get(t)):this.#t[e]=F,F}#e(t){if(!this.#O)return!1;let e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof W}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:r=0,sizeCalculation:g=this.sizeCalculation,noUpdateTTL:m=this.noUpdateTTL,noDeleteOnFetchRejection:f=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:c=this.ignoreFetchAbort,allowStaleOnFetchAbort:F=this.allowStaleOnFetchAbort,context:d,forceRefresh:S=!1,status:a,signal:w}=e;if(!this.#O)return a&&(a.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:a});let b={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:h,noDisposeOnSet:o,size:r,sizeCalculation:g,noUpdateTTL:m,noDeleteOnFetchRejection:f,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:F,ignoreFetchAbort:c,status:a,signal:w},p=this.#s.get(t);if(p===void 0){a&&(a.fetch="miss");let _=this.#x(t,p,b,d);return _.__returned=_}else{let _=this.#t[p];if(this.#e(_)){let U=i&&_.__staleWhileFetching!==void 0;return a&&(a.fetch="inflight",U&&(a.returnedStale=!0)),U?_.__staleWhileFetching:_.__returned=_}let v=this.#d(p);if(!S&&!v)return a&&(a.fetch="hit"),this.#C(p),s&&this.#z(p),a&&this.#E(a,p),_;let y=this.#x(t,p,b,d),L=y.__staleWhileFetching!==void 0&&i;return a&&(a.fetch=v?"stale":"refresh",L&&v&&(a.returnedStale=!0)),L?y.__staleWhileFetching:y.__returned=y}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(i===void 0)throw new Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#W;if(!i)throw new Error("no memoMethod provided to constructor");let{context:s,forceRefresh:n,...h}=e,o=this.get(t,h);if(!n&&o!==void 0)return o;let r=i(t,o,{options:h,context:s});return this.set(t,r,h),r}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:h}=e,o=this.#s.get(t);if(o!==void 0){let r=this.#t[o],g=this.#e(r);return h&&this.#E(h,o),this.#d(o)?(h&&(h.get="stale"),g?(h&&i&&r.__staleWhileFetching!==void 0&&(h.returnedStale=!0),i?r.__staleWhileFetching:void 0):(n||this.#T(t,"expire"),h&&i&&(h.returnedStale=!0),i?r:void 0)):(h&&(h.get="hit"),g?r.__staleWhileFetching:(this.#C(o),s&&this.#z(o),r))}else h&&(h.get="miss")}#j(t,e){this.#c[e]=t,this.#l[t]=e}#C(t){t!==this.#h&&(t===this.#o?this.#o=this.#l[t]:this.#j(this.#c[t],this.#l[t]),this.#j(this.#h,t),this.#h=t)}delete(t){return this.#T(t,"delete")}#T(t,e){let i=!1;if(this.#n!==0){let s=this.#s.get(t);if(s!==void 0)if(i=!0,this.#n===1)this.#N(e);else{this.#v(s);let n=this.#t[s];if(this.#e(n)?n.__abortController.abort(new Error("deleted")):(this.#y||this.#a)&&(this.#y&&this.#p?.(n,t,e),this.#a&&this.#r?.push([n,t,e])),this.#s.delete(t),this.#i[s]=void 0,this.#t[s]=void 0,s===this.#h)this.#h=this.#c[s];else if(s===this.#o)this.#o=this.#l[s];else{let h=this.#c[s];this.#l[h]=this.#l[s];let o=this.#l[s];this.#c[o]=this.#c[s]}this.#n--,this.#_.push(s)}}if(this.#a&&this.#r?.length){let s=this.#r,n;for(;n=s?.shift();)this.#w?.(...n)}return i}clear(){return this.#N("delete")}#N(t){for(let e of this.#F({allowStale:!0})){let i=this.#t[e];if(this.#e(i))i.__abortController.abort(new Error("deleted"));else{let s=this.#i[e];this.#y&&this.#p?.(i,s,t),this.#a&&this.#r?.push([i,s,t])}}if(this.#s.clear(),this.#t.fill(void 0),this.#i.fill(void 0),this.#u&&this.#b&&(this.#u.fill(0),this.#b.fill(0)),this.#m&&this.#m.fill(0),this.#o=0,this.#h=0,this.#_.length=0,this.#S=0,this.#n=0,this.#a&&this.#r){let e=this.#r,i;for(;i=e?.shift();)this.#w?.(...i)}}};export{D as LRUCache};
//# sourceMappingURL=index.min.js.map
{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["perf", "warned", "PROCESS", "emitWarning", "msg", "type", "code", "fn", "AC", "AS", "_", "warnACPolyfill", "reason", "printACPolyfillWarning", "shouldWarn", "TYPE", "isPosInt", "n", "getUintArray", "max", "ZeroArray", "size", "_constructing", "_Stack", "HeapCls", "__privateSet", "s", "__privateGet", "Stack", "__privateAdd", "LRUCache", "#max", "#maxSize", "#dispose", "#disposeAfter", "#fetchMethod", "#memoMethod", "#size", "#calculatedSize", "#keyMap", "#keyList", "#valList", "#next", "#prev", "#head", "#tail", "#free", "#disposed", "#sizes", "#starts", "#ttls", "#hasDispose", "#hasFetchMethod", "#hasDisposeAfter", "c", "p", "#isBackgroundFetch", "k", "index", "options", "context", "#backgroundFetch", "#moveToTail", "#indexes", "#rindexes", "#isStale", "ttl", "ttlResolution", "ttlAutopurge", "updateAgeOnGet", "updateAgeOnHas", "allowStale", "dispose", "disposeAfter", "noDisposeOnSet", "noUpdateTTL", "maxSize", "maxEntrySize", "sizeCalculation", "fetchMethod", "memoMethod", "noDeleteOnFetchRejection", "noDeleteOnStaleGet", "allowStaleOnFetchRejection", "allowStaleOnFetchAbort", "ignoreFetchAbort", "UintArray", "#initializeSizeTracking", "#initializeTTLTracking", "key", "ttls", "starts", "#setItemTTL", "start", "t", "#delete", "#updateItemAge", "#statusTTL", "status", "cachedNow", "getNow", "age", "sizes", "#removeItemSize", "#requireSize", "v", "#addItemSize", "#evict", "_i", "_s", "_st", "_k", "_v", "i", "#isValidIndex", "getOptions", "value", "thisp", "deleted", "entry", "remain", "arr", "setOptions", "oldVal", "oldValue", "dt", "task", "val", "free", "head", "hasOptions", "peekOptions", "ac", "signal", "fetchOpts", "cb", "updateCache", "aborted", "ignoreAbort", "fetchFail", "bf", "eb", "er", "allowStaleAborted", "noDelete", "pcall", "res", "rej", "fmp", "b", "fetchOptions", "forceRefresh", "stale", "isStale", "staleVal", "memoOptions", "vv", "fetching", "#connect", "#clear", "pi", "ni"]
}
{
  "type": "module"
}
The ISC License

Copyright (c) 2010-2023 Isaac Z. Schlueter and Contributors

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
{
  "name": "lru-cache",
  "publishConfig": {
    "tag": "legacy-v10"
  },
  "description": "A cache object that deletes the least-recently-used items.",
  "version": "10.4.3",
  "author": "Isaac Z. Schlueter <i@izs.me>",
  "keywords": [
    "mru",
    "lru",
    "cache"
  ],
  "sideEffects": false,
  "scripts": {
    "build": "npm run prepare",
    "prepare": "tshy && bash fixup.sh",
    "pretest": "npm run prepare",
    "presnap": "npm run prepare",
    "test": "tap",
    "snap": "tap",
    "preversion": "npm test",
    "postversion": "npm publish",
    "prepublishOnly": "git push origin --follow-tags",
    "format": "prettier --write .",
    "typedoc": "typedoc --tsconfig ./.tshy/esm.json ./src/*.ts",
    "benchmark-results-typedoc": "bash scripts/benchmark-results-typedoc.sh",
    "prebenchmark": "npm run prepare",
    "benchmark": "make -C benchmark",
    "preprofile": "npm run prepare",
    "profile": "make -C benchmark profile"
  },
  "main": "./dist/commonjs/index.js",
  "types": "./dist/commonjs/index.d.ts",
  "tshy": {
    "exports": {
      ".": "./src/index.ts",
      "./min": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.min.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.min.js"
        }
      }
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/node-lru-cache.git"
  },
  "devDependencies": {
    "@types/node": "^20.2.5",
    "@types/tap": "^15.0.6",
    "benchmark": "^2.1.4",
    "esbuild": "^0.17.11",
    "eslint-config-prettier": "^8.5.0",
    "marked": "^4.2.12",
    "mkdirp": "^2.1.5",
    "prettier": "^2.6.2",
    "tap": "^20.0.3",
    "tshy": "^2.0.0",
    "tslib": "^2.4.0",
    "typedoc": "^0.25.3",
    "typescript": "^5.2.2"
  },
  "license": "ISC",
  "files": [
    "dist"
  ],
  "prettier": {
    "semi": false,
    "printWidth": 70,
    "tabWidth": 2,
    "useTabs": false,
    "singleQuote": true,
    "jsxSingleQuote": false,
    "bracketSameLine": true,
    "arrowParens": "avoid",
    "endOfLine": "lf"
  },
  "tap": {
    "node-arg": [
      "--expose-gc"
    ],
    "plugin": [
      "@tapjs/clock"
    ]
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.js"
      }
    },
    "./min": {
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.min.js"
      },
      "require": {
        "types": "./dist/commonjs/index.d.ts",
        "default": "./dist/commonjs/index.min.js"
      }
    }
  },
  "type": "module",
  "module": "./dist/esm/index.js"
}
# lru-cache

A cache object that deletes the least-recently-used items.

Specify a max number of the most recently used items that you
want to keep, and this cache will keep that many of the most
recently accessed items.

This is not primarily a TTL cache, and does not make strong TTL
guarantees. There is no preemptive pruning of expired items by
default, but you _may_ set a TTL on the cache or on a single
`set`. If you do so, it will treat expired items as missing, and
delete them when fetched. If you are more interested in TTL
caching than LRU caching, check out
[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).

As of version 7, this is one of the most performant LRU
implementations available in JavaScript, and supports a wide
diversity of use cases. However, note that using some of the
features will necessarily impact performance, by causing the
cache to have to do more work. See the "Performance" section
below.

## Installation

```bash
npm install lru-cache --save
```

## Usage

```js
// hybrid module, either works
import { LRUCache } from 'lru-cache'
// or:
const { LRUCache } = require('lru-cache')
// or in minified form for web browsers:
import { LRUCache } from 'http://unpkg.com/lru-cache@9/dist/mjs/index.min.mjs'

// At least one of 'max', 'ttl', or 'maxSize' is required, to prevent
// unsafe unbounded storage.
//
// In most cases, it's best to specify a max for performance, so all
// the required memory allocation is done up-front.
//
// All the other options are optional, see the sections below for
// documentation on what each one does.  Most of them can be
// overridden for specific items in get()/set()
const options = {
  max: 500,

  // for use with tracking overall storage size
  maxSize: 5000,
  sizeCalculation: (value, key) => {
    return 1
  },

  // for use when you need to clean up something when objects
  // are evicted from the cache
  dispose: (value, key) => {
    freeFromMemoryOrWhatever(value)
  },

  // how long to live in ms
  ttl: 1000 * 60 * 5,

  // return stale items before removing from cache?
  allowStale: false,

  updateAgeOnGet: false,
  updateAgeOnHas: false,

  // async method to use for cache.fetch(), for
  // stale-while-revalidate type of behavior
  fetchMethod: async (
    key,
    staleValue,
    { options, signal, context }
  ) => {},
}

const cache = new LRUCache(options)

cache.set('key', 'value')
cache.get('key') // "value"

// non-string keys ARE fully supported
// but note that it must be THE SAME object, not
// just a JSON-equivalent object.
var someObject = { a: 1 }
cache.set(someObject, 'a value')
// Object keys are not toString()-ed
cache.set('[object Object]', 'a different value')
assert.equal(cache.get(someObject), 'a value')
// A similar object with same keys/values won't work,
// because it's a different object identity
assert.equal(cache.get({ a: 1 }), undefined)

cache.clear() // empty the cache
```

If you put more stuff in the cache, then less recently used items
will fall out. That's what an LRU cache is.

For full description of the API and all options, please see [the
LRUCache typedocs](https://isaacs.github.io/node-lru-cache/)

## Storage Bounds Safety

This implementation aims to be as flexible as possible, within
the limits of safe memory consumption and optimal performance.

At initial object creation, storage is allocated for `max` items.
If `max` is set to zero, then some performance is lost, and item
count is unbounded. Either `maxSize` or `ttl` _must_ be set if
`max` is not specified.

If `maxSize` is set, then this creates a safe limit on the
maximum storage consumed, but without the performance benefits of
pre-allocation. When `maxSize` is set, every item _must_ provide
a size, either via the `sizeCalculation` method provided to the
constructor, or via a `size` or `sizeCalculation` option provided
to `cache.set()`. The size of every item _must_ be a positive
integer.

If neither `max` nor `maxSize` are set, then `ttl` tracking must
be enabled. Note that, even when tracking item `ttl`, items are
_not_ preemptively deleted when they become stale, unless
`ttlAutopurge` is enabled. Instead, they are only purged the
next time the key is requested. Thus, if `ttlAutopurge`, `max`,
and `maxSize` are all not set, then the cache will potentially
grow unbounded.

In this case, a warning is printed to standard error. Future
versions may require the use of `ttlAutopurge` if `max` and
`maxSize` are not specified.

If you truly wish to use a cache that is bound _only_ by TTL
expiration, consider using a `Map` object, and calling
`setTimeout` to delete entries when they expire. It will perform
much better than an LRU cache.

Here is an implementation you may use, under the same
[license](./LICENSE) as this package:

```js
// a storage-unbounded ttl cache that is not an lru-cache
const cache = {
  data: new Map(),
  timers: new Map(),
  set: (k, v, ttl) => {
    if (cache.timers.has(k)) {
      clearTimeout(cache.timers.get(k))
    }
    cache.timers.set(
      k,
      setTimeout(() => cache.delete(k), ttl)
    )
    cache.data.set(k, v)
  },
  get: k => cache.data.get(k),
  has: k => cache.data.has(k),
  delete: k => {
    if (cache.timers.has(k)) {
      clearTimeout(cache.timers.get(k))
    }
    cache.timers.delete(k)
    return cache.data.delete(k)
  },
  clear: () => {
    cache.data.clear()
    for (const v of cache.timers.values()) {
      clearTimeout(v)
    }
    cache.timers.clear()
  },
}
```

If that isn't to your liking, check out
[@isaacs/ttlcache](http://npm.im/@isaacs/ttlcache).

## Storing Undefined Values

This cache never stores undefined values, as `undefined` is used
internally in a few places to indicate that a key is not in the
cache.

You may call `cache.set(key, undefined)`, but this is just
an alias for `cache.delete(key)`. Note that this has the effect
that `cache.has(key)` will return _false_ after setting it to
undefined.

```js
cache.set(myKey, undefined)
cache.has(myKey) // false!
```

If you need to track `undefined` values, and still note that the
key is in the cache, an easy workaround is to use a sigil object
of your own.

```js
import { LRUCache } from 'lru-cache'
const undefinedValue = Symbol('undefined')
const cache = new LRUCache(...)
const mySet = (key, value) =>
  cache.set(key, value === undefined ? undefinedValue : value)
const myGet = (key, value) => {
  const v = cache.get(key)
  return v === undefinedValue ? undefined : v
}
```

## Performance

As of January 2022, version 7 of this library is one of the most
performant LRU cache implementations in JavaScript.

Benchmarks can be extremely difficult to get right. In
particular, the performance of set/get/delete operations on
objects will vary _wildly_ depending on the type of key used. V8
is highly optimized for objects with keys that are short strings,
especially integer numeric strings. Thus any benchmark which
tests _solely_ using numbers as keys will tend to find that an
object-based approach performs the best.

Note that coercing _anything_ to strings to use as object keys is
unsafe, unless you can be 100% certain that no other type of
value will be used. For example:

```js
const myCache = {}
const set = (k, v) => (myCache[k] = v)
const get = k => myCache[k]

set({}, 'please hang onto this for me')
set('[object Object]', 'oopsie')
```

Also beware of "Just So" stories regarding performance. Garbage
collection of large (especially: deep) object graphs can be
incredibly costly, with several "tipping points" where it
increases exponentially. As a result, putting that off until
later can make it much worse, and less predictable. If a library
performs well, but only in a scenario where the object graph is
kept shallow, then that won't help you if you are using large
objects as keys.

In general, when attempting to use a library to improve
performance (such as a cache like this one), it's best to choose
an option that will perform well in the sorts of scenarios where
you'll actually use it.

This library is optimized for repeated gets and minimizing
eviction time, since that is the expected need of a LRU. Set
operations are somewhat slower on average than a few other
options, in part because of that optimization. It is assumed
that you'll be caching some costly operation, ideally as rarely
as possible, so optimizing set over get would be unwise.

If performance matters to you:

1. If it's at all possible to use small integer values as keys,
   and you can guarantee that no other types of values will be
   used as keys, then do that, and use a cache such as
   [lru-fast](https://npmjs.com/package/lru-fast), or
   [mnemonist's
   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache)
   which uses an Object as its data store.

2. Failing that, if at all possible, use short non-numeric
   strings (ie, less than 256 characters) as your keys, and use
   [mnemonist's
   LRUCache](https://yomguithereal.github.io/mnemonist/lru-cache).

3. If the types of your keys will be anything else, especially
   long strings, strings that look like floats, objects, or some
   mix of types, or if you aren't sure, then this library will
   work well for you.

   If you do not need the features that this library provides
   (like asynchronous fetching, a variety of TTL staleness
   options, and so on), then [mnemonist's
   LRUMap](https://yomguithereal.github.io/mnemonist/lru-map) is
   a very good option, and just slightly faster than this module
   (since it does considerably less).

4. Do not use a `dispose` function, size tracking, or especially
   ttl behavior, unless absolutely needed. These features are
   convenient, and necessary in some use cases, and every attempt
   has been made to make the performance impact minimal, but it
   isn't nothing.

## Breaking Changes in Version 7

This library changed to a different algorithm and internal data
structure in version 7, yielding significantly better
performance, albeit with some subtle changes as a result.

If you were relying on the internals of LRUCache in version 6 or
before, it probably will not work in version 7 and above.

## Breaking Changes in Version 8

- The `fetchContext` option was renamed to `context`, and may no
  longer be set on the cache instance itself.
- Rewritten in TypeScript, so pretty much all the types moved
  around a lot.
- The AbortController/AbortSignal polyfill was removed. For this
  reason, **Node version 16.14.0 or higher is now required**.
- Internal properties were moved to actual private class
  properties.
- Keys and values must not be `null` or `undefined`.
- Minified export available at `'lru-cache/min'`, for both CJS
  and MJS builds.

## Breaking Changes in Version 9

- Named export only, no default export.
- AbortController polyfill returned, albeit with a warning when
  used.

## Breaking Changes in Version 10

- `cache.fetch()` return type is now `Promise<V | undefined>`
  instead of `Promise<V | void>`. This is an irrelevant change
  practically speaking, but can require changes for TypeScript
  users.

For more info, see the [change log](CHANGELOG.md).
{
  "name": "@npmcli/agent",
  "version": "2.2.2",
  "description": "the http/https agent used by the npm cli",
  "main": "lib/index.js",
  "scripts": {
    "gencerts": "bash scripts/create-cert.sh",
    "test": "tap",
    "lint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\"",
    "postlint": "template-oss-check",
    "template-oss-apply": "template-oss-apply --force",
    "lintfix": "npm run lint -- --fix",
    "snap": "tap",
    "posttest": "npm run lint"
  },
  "author": "GitHub Inc.",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/npm/agent/issues"
  },
  "homepage": "https://github.com/npm/agent#readme",
  "files": [
    "bin/",
    "lib/"
  ],
  "engines": {
    "node": "^16.14.0 || >=18.0.0"
  },
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "version": "4.21.3",
    "publish": "true"
  },
  "dependencies": {
    "agent-base": "^7.1.0",
    "http-proxy-agent": "^7.0.0",
    "https-proxy-agent": "^7.0.1",
    "lru-cache": "^10.0.1",
    "socks-proxy-agent": "^8.0.3"
  },
  "devDependencies": {
    "@npmcli/eslint-config": "^4.0.0",
    "@npmcli/template-oss": "4.21.3",
    "minipass-fetch": "^3.0.3",
    "nock": "^13.2.7",
    "semver": "^7.5.4",
    "simple-socks": "^3.1.0",
    "tap": "^16.3.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/npm/agent.git"
  },
  "tap": {
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  }
}
## @npmcli/agent

A pair of Agent implementations for nodejs that provide consistent keep-alives, granular timeouts, dns caching, and proxy support.

### Usage

```js
const { getAgent, HttpAgent } = require('@npmcli/agent')
const fetch = require('minipass-fetch')

const main = async () => {
    // if you know what agent you need, you can create one directly
    const agent = new HttpAgent(agentOptions)
    // or you can use the getAgent helper, it will determine and create an Agent
    // instance for you as well as reuse that agent for new requests as appropriate
    const agent = getAgent('https://registry.npmjs.org/npm', agentOptions)
    // minipass-fetch is just an example, this will work for any http client that
    // supports node's Agents
    const res = await fetch('https://registry.npmjs.org/npm', { agent })
}

main()
```

### Options

All options supported by the node Agent implementations are supported here, see [the docs](https://nodejs.org/api/http.html#new-agentoptions) for those.

Options that have been added by this module include:

- `family`: what tcp family to use, can be `4` for IPv4, `6` for IPv6 or `0` for both.
- `proxy`: a URL to a supported proxy, currently supports `HTTP CONNECT` based http/https proxies as well as socks4 and 5.
- `dns`: configuration for the built-in dns cache
    - `ttl`: how long (in milliseconds) to keep cached dns entries, defaults to `5 * 60 * 100 (5 minutes)`
    - `lookup`: optional function to override how dns lookups are performed, defaults to `require('dns').lookup`
- `timeouts`: a set of granular timeouts, all default to `0`
    - `connection`: time between initiating connection and actually connecting
    - `idle`: time between data packets (if a top level `timeout` is provided, it will be copied here)
    - `response`: time between sending a request and receiving a response
    - `transfer`: time between starting to receive a request and consuming the response fully
// given an input that may or may not be an object, return an object that has
// a copy of every defined property listed in 'copy'. if the input is not an
// object, assign it to the property named by 'wrap'
const getOptions = (input, { copy, wrap }) => {
  const result = {}

  if (input && typeof input === 'object') {
    for (const prop of copy) {
      if (input[prop] !== undefined) {
        result[prop] = input[prop]
      }
    }
  } else {
    result[wrap] = input
  }

  return result
}

module.exports = getOptions
const semver = require('semver')

const satisfies = (range) => {
  return semver.satisfies(process.version, range, { includePrerelease: true })
}

module.exports = {
  satisfies,
}
'use strict'
const { inspect } = require('util')

// adapted from node's internal/errors
// https://github.com/nodejs/node/blob/c8a04049/lib/internal/errors.js

// close copy of node's internal SystemError class.
class SystemError {
  constructor (code, prefix, context) {
    // XXX context.code is undefined in all constructors used in cp/polyfill
    // that may be a bug copied from node, maybe the constructor should use
    // `code` not `errno`?  nodejs/node#41104
    let message = `${prefix}: ${context.syscall} returned ` +
                  `${context.code} (${context.message})`

    if (context.path !== undefined) {
      message += ` ${context.path}`
    }
    if (context.dest !== undefined) {
      message += ` => ${context.dest}`
    }

    this.code = code
    Object.defineProperties(this, {
      name: {
        value: 'SystemError',
        enumerable: false,
        writable: true,
        configurable: true,
      },
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true,
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false,
      },
      errno: {
        get () {
          return context.errno
        },
        set (value) {
          context.errno = value
        },
        enumerable: true,
        configurable: true,
      },
      syscall: {
        get () {
          return context.syscall
        },
        set (value) {
          context.syscall = value
        },
        enumerable: true,
        configurable: true,
      },
    })

    if (context.path !== undefined) {
      Object.defineProperty(this, 'path', {
        get () {
          return context.path
        },
        set (value) {
          context.path = value
        },
        enumerable: true,
        configurable: true,
      })
    }

    if (context.dest !== undefined) {
      Object.defineProperty(this, 'dest', {
        get () {
          return context.dest
        },
        set (value) {
          context.dest = value
        },
        enumerable: true,
        configurable: true,
      })
    }
  }

  toString () {
    return `${this.name} [${this.code}]: ${this.message}`
  }

  [Symbol.for('nodejs.util.inspect.custom')] (_recurseTimes, ctx) {
    return inspect(this, {
      ...ctx,
      getters: true,
      customInspect: false,
    })
  }
}

function E (code, message) {
  module.exports[code] = class NodeError extends SystemError {
    constructor (ctx) {
      super(code, message, ctx)
    }
  }
}

E('ERR_FS_CP_DIR_TO_NON_DIR', 'Cannot overwrite directory with non-directory')
E('ERR_FS_CP_EEXIST', 'Target already exists')
E('ERR_FS_CP_EINVAL', 'Invalid src or dest')
E('ERR_FS_CP_FIFO_PIPE', 'Cannot copy a FIFO pipe')
E('ERR_FS_CP_NON_DIR_TO_DIR', 'Cannot overwrite non-directory with directory')
E('ERR_FS_CP_SOCKET', 'Cannot copy a socket file')
E('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY', 'Cannot overwrite symlink in subdirectory of self')
E('ERR_FS_CP_UNKNOWN', 'Cannot copy an unknown file type')
E('ERR_FS_EISDIR', 'Path is a directory')

module.exports.ERR_INVALID_ARG_TYPE = class ERR_INVALID_ARG_TYPE extends Error {
  constructor (name, expected, actual) {
    super()
    this.code = 'ERR_INVALID_ARG_TYPE'
    this.message = `The ${name} argument must be ${expected}. Received ${typeof actual}`
  }
}
const fs = require('fs/promises')
const getOptions = require('../common/get-options.js')
const node = require('../common/node.js')
const polyfill = require('./polyfill.js')

// node 16.7.0 added fs.cp
const useNative = node.satisfies('>=16.7.0')

const cp = async (src, dest, opts) => {
  const options = getOptions(opts, {
    copy: ['dereference', 'errorOnExist', 'filter', 'force', 'preserveTimestamps', 'recursive'],
  })

  // the polyfill is tested separately from this module, no need to hack
  // process.version to try to trigger it just for coverage
  // istanbul ignore next
  return useNative
    ? fs.cp(src, dest, options)
    : polyfill(src, dest, options)
}

module.exports = cp
(The MIT License)

Copyright (c) 2011-2017 JP Richardson

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
 merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// this file is a modified version of the code in node 17.2.0
// which is, in turn, a modified version of the fs-extra module on npm
// node core changes:
// - Use of the assert module has been replaced with core's error system.
// - All code related to the glob dependency has been removed.
// - Bring your own custom fs module is not currently supported.
// - Some basic code cleanup.
// changes here:
// - remove all callback related code
// - drop sync support
// - change assertions back to non-internal methods (see options.js)
// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows
'use strict'

const {
  ERR_FS_CP_DIR_TO_NON_DIR,
  ERR_FS_CP_EEXIST,
  ERR_FS_CP_EINVAL,
  ERR_FS_CP_FIFO_PIPE,
  ERR_FS_CP_NON_DIR_TO_DIR,
  ERR_FS_CP_SOCKET,
  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
  ERR_FS_CP_UNKNOWN,
  ERR_FS_EISDIR,
  ERR_INVALID_ARG_TYPE,
} = require('./errors.js')
const {
  constants: {
    errno: {
      EEXIST,
      EISDIR,
      EINVAL,
      ENOTDIR,
    },
  },
} = require('os')
const {
  chmod,
  copyFile,
  lstat,
  mkdir,
  readdir,
  readlink,
  stat,
  symlink,
  unlink,
  utimes,
} = require('fs/promises')
const {
  dirname,
  isAbsolute,
  join,
  parse,
  resolve,
  sep,
  toNamespacedPath,
} = require('path')
const { fileURLToPath } = require('url')

const defaultOptions = {
  dereference: false,
  errorOnExist: false,
  filter: undefined,
  force: true,
  preserveTimestamps: false,
  recursive: false,
}

async function cp (src, dest, opts) {
  if (opts != null && typeof opts !== 'object') {
    throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts)
  }
  return cpFn(
    toNamespacedPath(getValidatedPath(src)),
    toNamespacedPath(getValidatedPath(dest)),
    { ...defaultOptions, ...opts })
}

function getValidatedPath (fileURLOrPath) {
  const path = fileURLOrPath != null && fileURLOrPath.href
      && fileURLOrPath.origin
    ? fileURLToPath(fileURLOrPath)
    : fileURLOrPath
  return path
}

async function cpFn (src, dest, opts) {
  // Warn about using preserveTimestamps on 32-bit node
  // istanbul ignore next
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    const warning = 'Using the preserveTimestamps option in 32-bit ' +
      'node is not recommended'
    process.emitWarning(warning, 'TimestampPrecisionWarning')
  }
  const stats = await checkPaths(src, dest, opts)
  const { srcStat, destStat } = stats
  await checkParentPaths(src, srcStat, dest)
  if (opts.filter) {
    return handleFilter(checkParentDir, destStat, src, dest, opts)
  }
  return checkParentDir(destStat, src, dest, opts)
}

async function checkPaths (src, dest, opts) {
  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts)
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      throw new ERR_FS_CP_EINVAL({
        message: 'src and dest cannot be the same',
        path: dest,
        syscall: 'cp',
        errno: EINVAL,
      })
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new ERR_FS_CP_DIR_TO_NON_DIR({
        message: `cannot overwrite directory ${src} ` +
            `with non-directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: EISDIR,
      })
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new ERR_FS_CP_NON_DIR_TO_DIR({
        message: `cannot overwrite non-directory ${src} ` +
            `with directory ${dest}`,
        path: dest,
        syscall: 'cp',
        errno: ENOTDIR,
      })
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
    })
  }
  return { srcStat, destStat }
}

function areIdentical (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino &&
    destStat.dev === srcStat.dev
}

function getStats (src, dest, opts) {
  const statFunc = opts.dereference ?
    (file) => stat(file, { bigint: true }) :
    (file) => lstat(file, { bigint: true })
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      // istanbul ignore next: unsure how to cover.
      if (err.code === 'ENOENT') {
        return null
      }
      // istanbul ignore next: unsure how to cover.
      throw err
    }),
  ])
}

async function checkParentDir (destStat, src, dest, opts) {
  const destParent = dirname(dest)
  const dirExists = await pathExists(destParent)
  if (dirExists) {
    return getStatsForCopy(destStat, src, dest, opts)
  }
  await mkdir(destParent, { recursive: true })
  return getStatsForCopy(destStat, src, dest, opts)
}

function pathExists (dest) {
  return stat(dest).then(
    () => true,
    // istanbul ignore next: not sure when this would occur
    (err) => (err.code === 'ENOENT' ? false : Promise.reject(err)))
}

// Recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
async function checkParentPaths (src, srcStat, dest) {
  const srcParent = resolve(dirname(src))
  const destParent = resolve(dirname(dest))
  if (destParent === srcParent || destParent === parse(destParent).root) {
    return
  }
  let destStat
  try {
    destStat = await stat(destParent, { bigint: true })
  } catch (err) {
    // istanbul ignore else: not sure when this would occur
    if (err.code === 'ENOENT') {
      return
    }
    // istanbul ignore next: not sure when this would occur
    throw err
  }
  if (areIdentical(srcStat, destStat)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${src} to a subdirectory of self ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
    })
  }
  return checkParentPaths(src, srcStat, destParent)
}

const normalizePathToArray = (path) =>
  resolve(path).split(sep).filter(Boolean)

// Return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = normalizePathToArray(src)
  const destArr = normalizePathToArray(dest)
  return srcArr.every((cur, i) => destArr[i] === cur)
}

async function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  const include = await opts.filter(src, dest)
  if (include) {
    return onInclude(destStat, src, dest, opts, cb)
  }
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter) {
    return handleFilter(getStatsForCopy, destStat, src, dest, opts)
  }
  return getStatsForCopy(destStat, src, dest, opts)
}

async function getStatsForCopy (destStat, src, dest, opts) {
  const statFn = opts.dereference ? stat : lstat
  const srcStat = await statFn(src)
  // istanbul ignore else: can't portably test FIFO
  if (srcStat.isDirectory() && opts.recursive) {
    return onDir(srcStat, destStat, src, dest, opts)
  } else if (srcStat.isDirectory()) {
    throw new ERR_FS_EISDIR({
      message: `${src} is a directory (not copied)`,
      path: src,
      syscall: 'cp',
      errno: EINVAL,
    })
  } else if (srcStat.isFile() ||
            srcStat.isCharacterDevice() ||
            srcStat.isBlockDevice()) {
    return onFile(srcStat, destStat, src, dest, opts)
  } else if (srcStat.isSymbolicLink()) {
    return onLink(destStat, src, dest)
  } else if (srcStat.isSocket()) {
    throw new ERR_FS_CP_SOCKET({
      message: `cannot copy a socket file: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
    })
  } else if (srcStat.isFIFO()) {
    throw new ERR_FS_CP_FIFO_PIPE({
      message: `cannot copy a FIFO pipe: ${dest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
    })
  }
  // istanbul ignore next: should be unreachable
  throw new ERR_FS_CP_UNKNOWN({
    message: `cannot copy an unknown file type: ${dest}`,
    path: dest,
    syscall: 'cp',
    errno: EINVAL,
  })
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) {
    return _copyFile(srcStat, src, dest, opts)
  }
  return mayCopyFile(srcStat, src, dest, opts)
}

async function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.force) {
    await unlink(dest)
    return _copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new ERR_FS_CP_EEXIST({
      message: `${dest} already exists`,
      path: dest,
      syscall: 'cp',
      errno: EEXIST,
    })
  }
}

async function _copyFile (srcStat, src, dest, opts) {
  await copyFile(src, dest)
  if (opts.preserveTimestamps) {
    return handleTimestampsAndMode(srcStat.mode, src, dest)
  }
  return setDestMode(dest, srcStat.mode)
}

async function handleTimestampsAndMode (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    await makeFileWritable(dest, srcMode)
    return setDestTimestampsAndMode(srcMode, src, dest)
  }
  return setDestTimestampsAndMode(srcMode, src, dest)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200)
}

async function setDestTimestampsAndMode (srcMode, src, dest) {
  await setDestTimestamps(src, dest)
  return setDestMode(dest, srcMode)
}

function setDestMode (dest, srcMode) {
  return chmod(dest, srcMode)
}

async function setDestTimestamps (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = await stat(src)
  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) {
    return mkDirAndCopy(srcStat.mode, src, dest, opts)
  }
  return copyDir(src, dest, opts)
}

async function mkDirAndCopy (srcMode, src, dest, opts) {
  await mkdir(dest)
  await copyDir(src, dest, opts)
  return setDestMode(dest, srcMode)
}

async function copyDir (src, dest, opts) {
  const dir = await readdir(src)
  for (let i = 0; i < dir.length; i++) {
    const item = dir[i]
    const srcItem = join(src, item)
    const destItem = join(dest, item)
    const { destStat } = await checkPaths(srcItem, destItem, opts)
    await startCopy(destStat, srcItem, destItem, opts)
  }
}

async function onLink (destStat, src, dest) {
  let resolvedSrc = await readlink(src)
  if (!isAbsolute(resolvedSrc)) {
    resolvedSrc = resolve(dirname(src), resolvedSrc)
  }
  if (!destStat) {
    return symlink(resolvedSrc, dest)
  }
  let resolvedDest
  try {
    resolvedDest = await readlink(dest)
  } catch (err) {
    // Dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    // istanbul ignore next: can only test on windows
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {
      return symlink(resolvedSrc, dest)
    }
    // istanbul ignore next: should not be possible
    throw err
  }
  if (!isAbsolute(resolvedDest)) {
    resolvedDest = resolve(dirname(dest), resolvedDest)
  }
  if (isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new ERR_FS_CP_EINVAL({
      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +
            `${resolvedDest}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
    })
  }
  // Do not copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  const srcStat = await stat(src)
  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
      path: dest,
      syscall: 'cp',
      errno: EINVAL,
    })
  }
  return copyLink(resolvedSrc, dest)
}

async function copyLink (resolvedSrc, dest) {
  await unlink(dest)
  return symlink(resolvedSrc, dest)
}

module.exports = cp
'use strict'

const cp = require('./cp/index.js')
const withTempDir = require('./with-temp-dir.js')
const readdirScoped = require('./readdir-scoped.js')
const moveFile = require('./move-file.js')

module.exports = {
  cp,
  withTempDir,
  readdirScoped,
  moveFile,
}
const { dirname, join, resolve, relative, isAbsolute } = require('path')
const fs = require('fs/promises')

const pathExists = async path => {
  try {
    await fs.access(path)
    return true
  } catch (er) {
    return er.code !== 'ENOENT'
  }
}

const moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {
  if (!source || !destination) {
    throw new TypeError('`source` and `destination` file required')
  }

  options = {
    overwrite: true,
    ...options,
  }

  if (!options.overwrite && await pathExists(destination)) {
    throw new Error(`The destination file exists: ${destination}`)
  }

  await fs.mkdir(dirname(destination), { recursive: true })

  try {
    await fs.rename(source, destination)
  } catch (error) {
    if (error.code === 'EXDEV' || error.code === 'EPERM') {
      const sourceStat = await fs.lstat(source)
      if (sourceStat.isDirectory()) {
        const files = await fs.readdir(source)
        await Promise.all(files.map((file) =>
          moveFile(join(source, file), join(destination, file), options, false, symlinks)
        ))
      } else if (sourceStat.isSymbolicLink()) {
        symlinks.push({ source, destination })
      } else {
        await fs.copyFile(source, destination)
      }
    } else {
      throw error
    }
  }

  if (root) {
    await Promise.all(symlinks.map(async ({ source: symSource, destination: symDestination }) => {
      let target = await fs.readlink(symSource)
      // junction symlinks in windows will be absolute paths, so we need to
      // make sure they point to the symlink destination
      if (isAbsolute(target)) {
        target = resolve(symDestination, relative(symSource, target))
      }
      // try to determine what the actual file is so we can create the correct
      // type of symlink in windows
      let targetStat = 'file'
      try {
        targetStat = await fs.stat(resolve(dirname(symSource), target))
        if (targetStat.isDirectory()) {
          targetStat = 'junction'
        }
      } catch {
        // targetStat remains 'file'
      }
      await fs.symlink(
        target,
        symDestination,
        targetStat
      )
    }))
    await fs.rm(source, { recursive: true, force: true })
  }
}

module.exports = moveFile
const { readdir } = require('fs/promises')
const { join } = require('path')

const readdirScoped = async (dir) => {
  const results = []

  for (const item of await readdir(dir)) {
    if (item.startsWith('@')) {
      for (const scopedItem of await readdir(join(dir, item))) {
        results.push(join(item, scopedItem))
      }
    } else {
      results.push(item)
    }
  }

  return results
}

module.exports = readdirScoped
const { join, sep } = require('path')

const getOptions = require('./common/get-options.js')
const { mkdir, mkdtemp, rm } = require('fs/promises')

// create a temp directory, ensure its permissions match its parent, then call
// the supplied function passing it the path to the directory. clean up after
// the function finishes, whether it throws or not
const withTempDir = async (root, fn, opts) => {
  const options = getOptions(opts, {
    copy: ['tmpPrefix'],
  })
  // create the directory
  await mkdir(root, { recursive: true })

  const target = await mkdtemp(join(`${root}${sep}`, options.tmpPrefix || ''))
  let err
  let result

  try {
    result = await fn(target)
  } catch (_err) {
    err = _err
  }

  try {
    await rm(target, { force: true, recursive: true })
  } catch {
    // ignore errors
  }

  if (err) {
    throw err
  }

  return result
}

module.exports = withTempDir
<!-- This file is automatically added by @npmcli/template-oss. Do not edit. -->

ISC License

Copyright npm, Inc.

Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby
granted, provided that the above copyright notice and this
permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND NPM DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
EVENT SHALL NPM BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
#!/usr/bin/env node
// Standalone semver comparison program.
// Exits successfully and prints matching version(s) if
// any supplied version is valid and passes all tests.

const argv = process.argv.slice(2)

let versions = []

const range = []

let inc = null

const version = require('../package.json').version

let loose = false

let includePrerelease = false

let coerce = false

let rtl = false

let identifier

let identifierBase

const semver = require('../')
const parseOptions = require('../internal/parse-options')

let reverse = false

let options = {}

const main = () => {
  if (!argv.length) {
    return help()
  }
  while (argv.length) {
    let a = argv.shift()
    const indexOfEqualSign = a.indexOf('=')
    if (indexOfEqualSign !== -1) {
      const value = a.slice(indexOfEqualSign + 1)
      a = a.slice(0, indexOfEqualSign)
      argv.unshift(value)
    }
    switch (a) {
      case '-rv': case '-rev': case '--rev': case '--reverse':
        reverse = true
        break
      case '-l': case '--loose':
        loose = true
        break
      case '-p': case '--include-prerelease':
        includePrerelease = true
        break
      case '-v': case '--version':
        versions.push(argv.shift())
        break
      case '-i': case '--inc': case '--increment':
        switch (argv[0]) {
          case 'major': case 'minor': case 'patch': case 'prerelease':
          case 'premajor': case 'preminor': case 'prepatch':
            inc = argv.shift()
            break
          default:
            inc = 'patch'
            break
        }
        break
      case '--preid':
        identifier = argv.shift()
        break
      case '-r': case '--range':
        range.push(argv.shift())
        break
      case '-n':
        identifierBase = argv.shift()
        if (identifierBase === 'false') {
          identifierBase = false
        }
        break
      case '-c': case '--coerce':
        coerce = true
        break
      case '--rtl':
        rtl = true
        break
      case '--ltr':
        rtl = false
        break
      case '-h': case '--help': case '-?':
        return help()
      default:
        versions.push(a)
        break
    }
  }

  options = parseOptions({ loose, includePrerelease, rtl })

  versions = versions.map((v) => {
    return coerce ? (semver.coerce(v, options) || { version: v }).version : v
  }).filter((v) => {
    return semver.valid(v)
  })
  if (!versions.length) {
    return fail()
  }
  if (inc && (versions.length !== 1 || range.length)) {
    return failInc()
  }

  for (let i = 0, l = range.length; i < l; i++) {
    versions = versions.filter((v) => {
      return semver.satisfies(v, range[i], options)
    })
    if (!versions.length) {
      return fail()
    }
  }
  versions
    .sort((a, b) => semver[reverse ? 'rcompare' : 'compare'](a, b, options))
    .map(v => semver.clean(v, options))
    .map(v => inc ? semver.inc(v, inc, options, identifier, identifierBase) : v)
    .forEach(v => console.log(v))
}

const failInc = () => {
  console.error('--inc can only be used on a single version with no range')
  fail()
}

const fail = () => process.exit(1)

const help = () => console.log(
`SemVer ${version}

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

--rtl
        Coerce version strings right to left

--ltr
        Coerce version strings left to right (default)

-n <base>
        Base number to be used for the prerelease identifier.
        Can be either 0 or 1, or false to omit the number altogether.
        Defaults to 0.

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.`)

main()
#!/usr/bin/env node
// Standalone semver comparison program.
// Exits successfully and prints matching version(s) if
// any supplied version is valid and passes all tests.

const argv = process.argv.slice(2)

let versions = []

const range = []

let inc = null

const version = require('../package.json').version

let loose = false

let includePrerelease = false

let coerce = false

let rtl = false

let identifier

let identifierBase

const semver = require('../')
const parseOptions = require('../internal/parse-options')

let reverse = false

let options = {}

const main = () => {
  if (!argv.length) {
    return help()
  }
  while (argv.length) {
    let a = argv.shift()
    const indexOfEqualSign = a.indexOf('=')
    if (indexOfEqualSign !== -1) {
      const value = a.slice(indexOfEqualSign + 1)
      a = a.slice(0, indexOfEqualSign)
      argv.unshift(value)
    }
    switch (a) {
      case '-rv': case '-rev': case '--rev': case '--reverse':
        reverse = true
        break
      case '-l': case '--loose':
        loose = true
        break
      case '-p': case '--include-prerelease':
        includePrerelease = true
        break
      case '-v': case '--version':
        versions.push(argv.shift())
        break
      case '-i': case '--inc': case '--increment':
        switch (argv[0]) {
          case 'major': case 'minor': case 'patch': case 'prerelease':
          case 'premajor': case 'preminor': case 'prepatch':
            inc = argv.shift()
            break
          default:
            inc = 'patch'
            break
        }
        break
      case '--preid':
        identifier = argv.shift()
        break
      case '-r': case '--range':
        range.push(argv.shift())
        break
      case '-n':
        identifierBase = argv.shift()
        if (identifierBase === 'false') {
          identifierBase = false
        }
        break
      case '-c': case '--coerce':
        coerce = true
        break
      case '--rtl':
        rtl = true
        break
      case '--ltr':
        rtl = false
        break
      case '-h': case '--help': case '-?':
        return help()
      default:
        versions.push(a)
        break
    }
  }

  options = parseOptions({ loose, includePrerelease, rtl })

  versions = versions.map((v) => {
    return coerce ? (semver.coerce(v, options) || { version: v }).version : v
  }).filter((v) => {
    return semver.valid(v)
  })
  if (!versions.length) {
    return fail()
  }
  if (inc && (versions.length !== 1 || range.length)) {
    return failInc()
  }

  for (let i = 0, l = range.length; i < l; i++) {
    versions = versions.filter((v) => {
      return semver.satisfies(v, range[i], options)
    })
    if (!versions.length) {
      return fail()
    }
  }
  versions
    .sort((a, b) => semver[reverse ? 'rcompare' : 'compare'](a, b, options))
    .map(v => semver.clean(v, options))
    .map(v => inc ? semver.inc(v, inc, options, identifier, identifierBase) : v)
    .forEach(v => console.log(v))
}

const failInc = () => {
  console.error('--inc can only be used on a single version with no range')
  fail()
}

const fail = () => process.exit(1)

const help = () => console.log(
`SemVer ${version}

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

--rtl
        Coerce version strings right to left

--ltr
        Coerce version strings left to right (default)

-n <base>
        Base number to be used for the prerelease identifier.
        Can be either 0 or 1, or false to omit the number altogether.
        Defaults to 0.

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.`)

main()
const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = require('../internal/parse-options')
const { safeRe: re, t } = require('../internal/re')
const cmp = require('../functions/cmp')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const Range = require('./range')
module.exports = {
  SemVer: require('./semver.js'),
  Range: require('./range.js'),
  Comparator: require('./comparator.js'),
}
const SPACE_CHARACTERS = /\s+/g

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.formatted = undefined
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')

    // First, split on ||
    this.set = this.raw
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.formatted = undefined
  }

  get range () {
    if (this.formatted === undefined) {
      this.formatted = ''
      for (let i = 0; i < this.set.length; i++) {
        if (i > 0) {
          this.formatted += '||'
        }
        const comps = this.set[i]
        for (let k = 0; k < comps.length; k++) {
          if (k > 0) {
            this.formatted += ' '
          }
          this.formatted += comps[k].toString().trim()
        }
      }
    }
    return this.formatted
  }

  format () {
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug('tilde trim', range)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug('caret trim', range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = require('../internal/lrucache')
const cache = new LRU()

const parseOptions = require('../internal/parse-options')
const Comparator = require('./comparator')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = require('../internal/re')
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceTilde(c, options))
    .join(' ')
}

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceCaret(c, options))
    .join(' ')
}

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp
    .split(/\s+/)
    .map((c) => replaceXRange(c, options))
    .join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}
const debug = require('../internal/debug')
const { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')
const { safeRe: re, t } = require('../internal/re')

const parseOptions = require('../internal/parse-options')
const { compareIdentifiers } = require('../internal/identifiers')
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('build compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer
const parse = require('./parse')
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean
const eq = require('./eq')
const neq = require('./neq')
const gt = require('./gt')
const gte = require('./gte')
const lt = require('./lt')
const lte = require('./lte')

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp
const SemVer = require('../classes/semver')
const parse = require('./parse')
const { safeRe: re, t } = require('../internal/re')

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]
    let next
    while ((next = coerceRtlRegex.exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    coerceRtlRegex.lastIndex = -1
  }

  if (match === null) {
    return null
  }

  const major = match[2]
  const minor = match[3] || '0'
  const patch = match[4] || '0'
  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''

  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
}
module.exports = coerce
const SemVer = require('../classes/semver')
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild
const compare = require('./compare')
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose
const SemVer = require('../classes/semver')
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare
const parse = require('./parse.js')

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length
  const lowHasPre = !!lowVersion.prerelease.length

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // Otherwise it can be determined by checking the high version

    if (highVersion.patch) {
      // anything higher than a patch bump would result in the wrong version
      return 'patch'
    }

    if (highVersion.minor) {
      // anything higher than a minor bump would result in the wrong version
      return 'minor'
    }

    // bumping major/minor/patch all have same result
    return 'major'
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
}

module.exports = diff
const compare = require('./compare')
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq
const compare = require('./compare')
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt
const compare = require('./compare')
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte
const SemVer = require('../classes/semver')

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc
const compare = require('./compare')
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt
const compare = require('./compare')
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte
const SemVer = require('../classes/semver')
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major
const SemVer = require('../classes/semver')
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor
const compare = require('./compare')
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq
const SemVer = require('../classes/semver')
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse
const SemVer = require('../classes/semver')
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch
const parse = require('./parse')
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease
const compare = require('./compare')
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare
const compareBuild = require('./compare-build')
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort
const Range = require('../classes/range')
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies
const compareBuild = require('./compare-build')
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort
const parse = require('./parse')
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid
// just pre-load all the stuff that index.js lazily exports
const internalRe = require('./internal/re')
const constants = require('./internal/constants')
const SemVer = require('./classes/semver')
const identifiers = require('./internal/identifiers')
const parse = require('./functions/parse')
const valid = require('./functions/valid')
const clean = require('./functions/clean')
const inc = require('./functions/inc')
const diff = require('./functions/diff')
const major = require('./functions/major')
const minor = require('./functions/minor')
const patch = require('./functions/patch')
const prerelease = require('./functions/prerelease')
const compare = require('./functions/compare')
const rcompare = require('./functions/rcompare')
const compareLoose = require('./functions/compare-loose')
const compareBuild = require('./functions/compare-build')
const sort = require('./functions/sort')
const rsort = require('./functions/rsort')
const gt = require('./functions/gt')
const lt = require('./functions/lt')
const eq = require('./functions/eq')
const neq = require('./functions/neq')
const gte = require('./functions/gte')
const lte = require('./functions/lte')
const cmp = require('./functions/cmp')
const coerce = require('./functions/coerce')
const Comparator = require('./classes/comparator')
const Range = require('./classes/range')
const satisfies = require('./functions/satisfies')
const toComparators = require('./ranges/to-comparators')
const maxSatisfying = require('./ranges/max-satisfying')
const minSatisfying = require('./ranges/min-satisfying')
const minVersion = require('./ranges/min-version')
const validRange = require('./ranges/valid')
const outside = require('./ranges/outside')
const gtr = require('./ranges/gtr')
const ltr = require('./ranges/ltr')
const intersects = require('./ranges/intersects')
const simplifyRange = require('./ranges/simplify')
const subset = require('./ranges/subset')
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}
const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug
const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}
class LRUCache {
  constructor () {
    this.max = 1000
    this.map = new Map()
  }

  get (key) {
    const value = this.map.get(key)
    if (value === undefined) {
      return undefined
    } else {
      // Remove the key from the map and add it to the end
      this.map.delete(key)
      this.map.set(key, value)
      return value
    }
  }

  delete (key) {
    return this.map.delete(key)
  }

  set (key, value) {
    const deleted = this.delete(key)

    if (!deleted && value !== undefined) {
      // If cache is full, delete the least recently used item
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value
        this.delete(firstKey)
      }

      this.map.set(key, value)
    }

    return this
  }
}

module.exports = LRUCache
// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions
const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = require('./constants')
const debug = require('./debug')
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
createToken('COERCEFULL', src[t.COERCEPLAIN] +
              `(?:${src[t.PRERELEASE]})?` +
              `(?:${src[t.BUILD]})?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)
createToken('COERCERTLFULL', src[t.COERCEFULL], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')
The ISC License

Copyright (c) Isaac Z. Schlueter and Contributors

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
{
  "name": "semver",
  "version": "7.6.3",
  "description": "The semantic version parser used by npm.",
  "main": "index.js",
  "scripts": {
    "test": "tap",
    "snap": "tap",
    "lint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\"",
    "postlint": "template-oss-check",
    "lintfix": "npm run lint -- --fix",
    "posttest": "npm run lint",
    "template-oss-apply": "template-oss-apply --force"
  },
  "devDependencies": {
    "@npmcli/eslint-config": "^4.0.0",
    "@npmcli/template-oss": "4.22.0",
    "benchmark": "^2.1.4",
    "tap": "^16.0.0"
  },
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/npm/node-semver.git"
  },
  "bin": {
    "semver": "bin/semver.js"
  },
  "files": [
    "bin/",
    "lib/",
    "classes/",
    "functions/",
    "internal/",
    "ranges/",
    "index.js",
    "preload.js",
    "range.bnf"
  ],
  "tap": {
    "timeout": 30,
    "coverage-map": "map.js",
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  },
  "engines": {
    "node": ">=10"
  },
  "author": "GitHub Inc.",
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "version": "4.22.0",
    "engines": ">=10",
    "distPaths": [
      "classes/",
      "functions/",
      "internal/",
      "ranges/",
      "index.js",
      "preload.js",
      "range.bnf"
    ],
    "allowPaths": [
      "/classes/",
      "/functions/",
      "/internal/",
      "/ranges/",
      "/index.js",
      "/preload.js",
      "/range.bnf",
      "/benchmarks"
    ],
    "publish": "true"
  }
}
// XXX remove in v8 or beyond
module.exports = require('./index.js')
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | [1-9] ( [0-9] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
// Determine if version is greater than all the versions possible in the range.
const outside = require('./outside')
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr
const Range = require('../classes/range')
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects
const outside = require('./outside')
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr
const SemVer = require('../classes/semver')
const Range = require('../classes/range')

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying
const SemVer = require('../classes/semver')
const Range = require('../classes/range')
const gt = require('../functions/gt')

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion
const SemVer = require('../classes/semver')
const Comparator = require('../classes/comparator')
const { ANY } = Comparator
const Range = require('../classes/range')
const satisfies = require('../functions/satisfies')
const gt = require('../functions/gt')
const lt = require('../functions/lt')
const lte = require('../functions/lte')
const gte = require('../functions/gte')

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}
const Range = require('../classes/range.js')
const Comparator = require('../classes/comparator.js')
const { ANY } = Comparator
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset
const Range = require('../classes/range')

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators
const Range = require('../classes/range')
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange
semver(1) -- The semantic versioner for npm
===========================================

## Install

```bash
npm install semver
````

## Usage

As a node module:

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

You can also just load the module for the function that you care about if
you'd like to minimize your footprint.

```js
// load the whole API at once in a single object
const semver = require('semver')

// or just load the bits you need
// all of them listed here, just pick and choose what you want

// classes
const SemVer = require('semver/classes/semver')
const Comparator = require('semver/classes/comparator')
const Range = require('semver/classes/range')

// functions for working with versions
const semverParse = require('semver/functions/parse')
const semverValid = require('semver/functions/valid')
const semverClean = require('semver/functions/clean')
const semverInc = require('semver/functions/inc')
const semverDiff = require('semver/functions/diff')
const semverMajor = require('semver/functions/major')
const semverMinor = require('semver/functions/minor')
const semverPatch = require('semver/functions/patch')
const semverPrerelease = require('semver/functions/prerelease')
const semverCompare = require('semver/functions/compare')
const semverRcompare = require('semver/functions/rcompare')
const semverCompareLoose = require('semver/functions/compare-loose')
const semverCompareBuild = require('semver/functions/compare-build')
const semverSort = require('semver/functions/sort')
const semverRsort = require('semver/functions/rsort')

// low-level comparators between versions
const semverGt = require('semver/functions/gt')
const semverLt = require('semver/functions/lt')
const semverEq = require('semver/functions/eq')
const semverNeq = require('semver/functions/neq')
const semverGte = require('semver/functions/gte')
const semverLte = require('semver/functions/lte')
const semverCmp = require('semver/functions/cmp')
const semverCoerce = require('semver/functions/coerce')

// working with ranges
const semverSatisfies = require('semver/functions/satisfies')
const semverMaxSatisfying = require('semver/ranges/max-satisfying')
const semverMinSatisfying = require('semver/ranges/min-satisfying')
const semverToComparators = require('semver/ranges/to-comparators')
const semverMinVersion = require('semver/ranges/min-version')
const semverValidRange = require('semver/ranges/valid')
const semverOutside = require('semver/ranges/outside')
const semverGtr = require('semver/ranges/gtr')
const semverLtr = require('semver/ranges/ltr')
const semverIntersects = require('semver/ranges/intersects')
const semverSimplifyRange = require('semver/ranges/simplify')
const semverRangeSubset = require('semver/ranges/subset')
```

As a command-line utility:

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-n <0|1>
        This is the base to be used for the prerelease identifier.

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

--rtl
        Coerce version strings right to left

--ltr
        Coerce version strings left to right (default)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## Versions

A "version" is described by the `v2.0.0` specification found at
<https://semver.org/>.

A leading `"="` or `"v"` character is stripped off and ignored.

## Ranges

A `version range` is a set of `comparators` that specify versions
that satisfy the range.

A `comparator` is composed of an `operator` and a `version`.  The set
of primitive `operators` is:

* `<` Less than
* `<=` Less than or equal to
* `>` Greater than
* `>=` Greater than or equal to
* `=` Equal.  If no operator is specified, then equality is assumed,
  so this operator is optional but MAY be included.

For example, the comparator `>=1.2.7` would match the versions
`1.2.7`, `1.2.8`, `2.5.3`, and `1.3.9`, but not the versions `1.2.6`
or `1.1.0`. The comparator `>1` is equivalent to `>=2.0.0` and
would match the versions `2.0.0` and `3.1.0`, but not the versions
`1.0.1` or `1.1.0`.

Comparators can be joined by whitespace to form a `comparator set`,
which is satisfied by the **intersection** of all of the comparators
it includes.

A range is composed of one or more comparator sets, joined by `||`.  A
version matches a range if and only if every comparator in at least
one of the `||`-separated comparator sets is satisfied by the version.

For example, the range `>=1.2.7 <1.3.0` would match the versions
`1.2.7`, `1.2.8`, and `1.2.99`, but not the versions `1.2.6`, `1.3.0`,
or `1.1.0`.

The range `1.2.7 || >=1.2.9 <2.0.0` would match the versions `1.2.7`,
`1.2.9`, and `1.4.6`, but not the versions `1.2.8` or `2.0.0`.

### Prerelease Tags

If a version has a prerelease tag (for example, `1.2.3-alpha.3`) then
it will only be allowed to satisfy comparator sets if at least one
comparator with the same `[major, minor, patch]` tuple also has a
prerelease tag.

For example, the range `>1.2.3-alpha.3` would be allowed to match the
version `1.2.3-alpha.7`, but it would *not* be satisfied by
`3.4.5-alpha.9`, even though `3.4.5-alpha.9` is technically "greater
than" `1.2.3-alpha.3` according to the SemVer sort rules.  The version
range only accepts prerelease tags on the `1.2.3` version.
Version `3.4.5` *would* satisfy the range because it does not have a
prerelease flag, and `3.4.5` is greater than `1.2.3-alpha.7`.

The purpose of this behavior is twofold.  First, prerelease versions
frequently are updated very quickly, and contain many breaking changes
that are (by the author's design) not yet fit for public consumption.
Therefore, by default, they are excluded from range-matching
semantics.

Second, a user who has opted into using a prerelease version has
indicated the intent to use *that specific* set of
alpha/beta/rc versions.  By including a prerelease tag in the range,
the user is indicating that they are aware of the risk.  However, it
is still not appropriate to assume that they have opted into taking a
similar risk on the *next* set of prerelease versions.

Note that this behavior can be suppressed (treating all prerelease
versions as if they were normal versions, for range-matching)
by setting the `includePrerelease` flag on the options
object to any
[functions](https://github.com/npm/node-semver#functions) that do
range matching.

#### Prerelease Identifiers

The method `.inc` takes an additional `identifier` string argument that
will append the value of the string as a prerelease identifier:

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

command-line example:

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

Which then can be used to increment further:

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

#### Prerelease Identifier Base

The method `.inc` takes an optional parameter 'identifierBase' string
that will let you let your prerelease number as zero-based or one-based.
Set to `false` to omit the prerelease number altogether.
If you do not specify this parameter, it will default to zero-based.

```javascript
semver.inc('1.2.3', 'prerelease', 'beta', '1')
// '1.2.4-beta.1'
```

```javascript
semver.inc('1.2.3', 'prerelease', 'beta', false)
// '1.2.4-beta'
```

command-line example:

```bash
$ semver 1.2.3 -i prerelease --preid beta -n 1
1.2.4-beta.1
```

```bash
$ semver 1.2.3 -i prerelease --preid beta -n false
1.2.4-beta
```

### Advanced Range Syntax

Advanced range syntax desugars to primitive comparators in
deterministic ways.

Advanced ranges may be combined in the same way as primitive
comparators using white space or `||`.

#### Hyphen Ranges `X.Y.Z - A.B.C`

Specifies an inclusive set.

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

If a partial version is provided as the first version in the inclusive
range, then the missing pieces are replaced with zeroes.

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

If a partial version is provided as the second version in the
inclusive range, then all versions that start with the supplied parts
of the tuple are accepted, but nothing that would be greater than the
provided tuple parts.

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0-0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0-0`

#### X-Ranges `1.2.x` `1.X` `1.2.*` `*`

Any of `X`, `x`, or `*` may be used to "stand in" for one of the
numeric values in the `[major, minor, patch]` tuple.

* `*` := `>=0.0.0` (Any non-prerelease version satisfies, unless
  `includePrerelease` is specified, in which case any version at all
  satisfies)
* `1.x` := `>=1.0.0 <2.0.0-0` (Matching major version)
* `1.2.x` := `>=1.2.0 <1.3.0-0` (Matching major and minor versions)

A partial version range is treated as an X-Range, so the special
character is in fact optional.

* `""` (empty string) := `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0-0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0-0`

#### Tilde Ranges `~1.2.3` `~1.2` `~1`

Allows patch-level changes if a minor version is specified on the
comparator.  Allows minor-level changes if not.

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0-0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0-0` (Same as `1.2.x`)
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0-0` (Same as `1.x`)
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0-0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0-0` (Same as `0.2.x`)
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0-0` (Same as `0.x`)
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0-0` Note that prereleases in
  the `1.2.3` version will be allowed, if they are greater than or
  equal to `beta.2`.  So, `1.2.3-beta.4` would be allowed, but
  `1.2.4-beta.2` would not, because it is a prerelease of a
  different `[major, minor, patch]` tuple.

#### Caret Ranges `^1.2.3` `^0.2.5` `^0.0.4`

Allows changes that do not modify the left-most non-zero element in the
`[major, minor, patch]` tuple.  In other words, this allows patch and
minor updates for versions `1.0.0` and above, patch updates for
versions `0.X >=0.1.0`, and *no* updates for versions `0.0.X`.

Many authors treat a `0.x` version as if the `x` were the major
"breaking-change" indicator.

Caret ranges are ideal when an author may make breaking changes
between `0.2.4` and `0.3.0` releases, which is a common practice.
However, it presumes that there will *not* be breaking changes between
`0.2.4` and `0.2.5`.  It allows for changes that are presumed to be
additive (but non-breaking), according to commonly observed practices.

* `^1.2.3` := `>=1.2.3 <2.0.0-0`
* `^0.2.3` := `>=0.2.3 <0.3.0-0`
* `^0.0.3` := `>=0.0.3 <0.0.4-0`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0-0` Note that prereleases in
  the `1.2.3` version will be allowed, if they are greater than or
  equal to `beta.2`.  So, `1.2.3-beta.4` would be allowed, but
  `1.2.4-beta.2` would not, because it is a prerelease of a
  different `[major, minor, patch]` tuple.
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4-0`  Note that prereleases in the
  `0.0.3` version *only* will be allowed, if they are greater than or
  equal to `beta`.  So, `0.0.3-pr.2` would be allowed.

When parsing caret ranges, a missing `patch` value desugars to the
number `0`, but will allow flexibility within that value, even if the
major and minor versions are both `0`.

* `^1.2.x` := `>=1.2.0 <2.0.0-0`
* `^0.0.x` := `>=0.0.0 <0.1.0-0`
* `^0.0` := `>=0.0.0 <0.1.0-0`

A missing `minor` and `patch` values will desugar to zero, but also
allow flexibility within those values, even if the major version is
zero.

* `^1.x` := `>=1.0.0 <2.0.0-0`
* `^0.x` := `>=0.0.0 <1.0.0-0`

### Range Grammar

Putting all this together, here is a Backus-Naur grammar for ranges,
for the benefit of parser authors:

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## Functions

All methods and classes take a final `options` object argument.  All
options in this object are `false` by default.  The options supported
are:

- `loose`: Be more forgiving about not-quite-valid semver strings.
  (Any resulting output will always be 100% strict compliant, of
  course.)  For backwards compatibility reasons, if the `options`
  argument is a boolean value instead of an object, it is interpreted
  to be the `loose` param.
- `includePrerelease`: Set to suppress the [default
  behavior](https://github.com/npm/node-semver#prerelease-tags) of
  excluding prerelease tagged versions from ranges unless they are
  explicitly opted into.

Strict-mode Comparators and Ranges will be strict about the SemVer
strings that they parse.

* `valid(v)`: Return the parsed version, or null if it's not valid.
* `inc(v, release, options, identifier, identifierBase)`: 
  Return the version incremented by the release
  type (`major`, `premajor`, `minor`, `preminor`, `patch`,
  `prepatch`, or `prerelease`), or null if it's not valid
  * `premajor` in one call will bump the version up to the next major
    version and down to a prerelease of that major version.
    `preminor`, and `prepatch` work the same way.
  * If called from a non-prerelease version, `prerelease` will work the
    same as `prepatch`. It increments the patch version and then makes a
    prerelease. If the input version is already a prerelease it simply
    increments it.
  * `identifier` can be used to prefix `premajor`, `preminor`,
    `prepatch`, or `prerelease` version increments. `identifierBase`
    is the base to be used for the `prerelease` identifier.
* `prerelease(v)`: Returns an array of prerelease components, or null
  if none exist. Example: `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)`: Return the major version number.
* `minor(v)`: Return the minor version number.
* `patch(v)`: Return the patch version number.
* `intersects(r1, r2, loose)`: Return true if the two supplied ranges
  or comparators intersect.
* `parse(v)`: Attempt to parse a string as a semantic version, returning either
  a `SemVer` object or `null`.

### Comparison

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)`: `v1 == v2` This is true if they're logically equivalent,
  even if they're not the same string.  You already know how to
  compare strings.
* `neq(v1, v2)`: `v1 != v2` The opposite of `eq`.
* `cmp(v1, comparator, v2)`: Pass in a comparison string, and it'll call
  the corresponding function above.  `"==="` and `"!=="` do simple
  string comparison, but are included for completeness.  Throws if an
  invalid comparison string is provided.
* `compare(v1, v2)`: Return `0` if `v1 == v2`, or `1` if `v1` is greater, or `-1` if
  `v2` is greater.  Sorts in ascending order if passed to `Array.sort()`.
* `rcompare(v1, v2)`: The reverse of `compare`.  Sorts an array of versions
  in descending order when passed to `Array.sort()`.
* `compareBuild(v1, v2)`: The same as `compare` but considers `build` when two versions
  are equal.  Sorts in ascending order if passed to `Array.sort()`.
* `compareLoose(v1, v2)`: Short for `compare(v1, v2, { loose: true })`.
* `diff(v1, v2)`: Returns the difference between two versions by the release type
  (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch`, or `prerelease`),
  or null if the versions are the same.

### Sorting

* `sort(versions)`: Returns a sorted array of versions based on the `compareBuild` 
  function.
* `rsort(versions)`: The reverse of `sort`. Returns an array of versions based on
  the `compareBuild` function in descending order.

### Comparators

* `intersects(comparator)`: Return true if the comparators intersect

### Ranges

* `validRange(range)`: Return the valid range or null if it's not valid
* `satisfies(version, range)`: Return true if the version satisfies the
  range.
* `maxSatisfying(versions, range)`: Return the highest version in the list
  that satisfies the range, or `null` if none of them do.
* `minSatisfying(versions, range)`: Return the lowest version in the list
  that satisfies the range, or `null` if none of them do.
* `minVersion(range)`: Return the lowest version that can match
  the given range.
* `gtr(version, range)`: Return `true` if the version is greater than all the
  versions possible in the range.
* `ltr(version, range)`: Return `true` if the version is less than all the
  versions possible in the range.
* `outside(version, range, hilo)`: Return true if the version is outside
  the bounds of the range in either the high or low direction.  The
  `hilo` argument must be either the string `'>'` or `'<'`.  (This is
  the function called by `gtr` and `ltr`.)
* `intersects(range)`: Return true if any of the range comparators intersect.
* `simplifyRange(versions, range)`: Return a "simplified" range that
  matches the same items in the `versions` list as the range specified.  Note
  that it does *not* guarantee that it would match the same versions in all
  cases, only for the set of versions provided.  This is useful when
  generating ranges by joining together multiple versions with `||`
  programmatically, to provide the user with something a bit more
  ergonomic.  If the provided range is shorter in string-length than the
  generated range, then that is returned.
* `subset(subRange, superRange)`: Return `true` if the `subRange` range is
  entirely contained by the `superRange` range.

Note that, since ranges may be non-contiguous, a version might not be
greater than a range, less than a range, *or* satisfy a range!  For
example, the range `1.2 <1.2.9 || >2.0.0` would have a hole from `1.2.9`
until `2.0.0`, so version `1.2.10` would not be greater than the
range (because `2.0.1` satisfies, which is higher), nor less than the
range (since `1.2.8` satisfies, which is lower), and it also does not
satisfy the range.

If you want to know if a version satisfies or does not satisfy a
range, use the `satisfies(version, range)` function.

### Coercion

* `coerce(version, options)`: Coerces a string to semver if possible

This aims to provide a very forgiving translation of a non-semver string to
semver. It looks for the first digit in a string and consumes all
remaining characters which satisfy at least a partial semver (e.g., `1`,
`1.2`, `1.2.3`) up to the max permitted length (256 characters).  Longer
versions are simply truncated (`4.6.3.9.2-alpha2` becomes `4.6.3`).  All
surrounding text is simply ignored (`v3.4 replaces v3.3.1` becomes
`3.4.0`).  Only text which lacks digits will fail coercion (`version one`
is not valid).  The maximum length for any semver component considered for
coercion is 16 characters; longer components will be ignored
(`10000000000000000.4.7.4` becomes `4.7.4`).  The maximum value for any
semver component is `Number.MAX_SAFE_INTEGER || (2**53 - 1)`; higher value
components are invalid (`9999999999999999.4.7.4` is likely invalid).

If the `options.rtl` flag is set, then `coerce` will return the right-most
coercible tuple that does not share an ending index with a longer coercible
tuple.  For example, `1.2.3.4` will return `2.3.4` in rtl mode, not
`4.0.0`.  `1.2.3/4` will return `4.0.0`, because the `4` is not a part of
any other overlapping SemVer tuple.

If the `options.includePrerelease` flag is set, then the `coerce` result will contain
prerelease and build parts of a version.  For example, `1.2.3.4-rc.1+rev.2`
will preserve prerelease `rc.1` and build `rev.2` in the result.

### Clean

* `clean(version)`: Clean a string to be a valid semver if possible

This will return a cleaned and trimmed semver version. If the provided
version is not valid a null will be returned. This does not work for
ranges.

ex.
* `s.clean(' = v 2.1.5foo')`: `null`
* `s.clean(' = v 2.1.5foo', { loose: true })`: `'2.1.5-foo'`
* `s.clean(' = v 2.1.5-foo')`: `null`
* `s.clean(' = v 2.1.5-foo', { loose: true })`: `'2.1.5-foo'`
* `s.clean('=v2.1.5')`: `'2.1.5'`
* `s.clean('  =v2.1.5')`: `'2.1.5'`
* `s.clean('      2.1.5   ')`: `'2.1.5'`
* `s.clean('~1.0.0')`: `null`

## Constants

As a convenience, helper constants are exported to provide information about what `node-semver` supports:

### `RELEASE_TYPES`

- major
- premajor
- minor
- preminor
- patch
- prepatch
- prerelease

```
const semver = require('semver');

if (semver.RELEASE_TYPES.includes(arbitraryUserInput)) {
  console.log('This is a valid release type!');
} else {
  console.warn('This is NOT a valid release type!');
}
```

### `SEMVER_SPEC_VERSION`

2.0.0

```
const semver = require('semver');

console.log('We are currently using the semver specification version:', semver.SEMVER_SPEC_VERSION);
```

## Exported Modules

<!--
TODO: Make sure that all of these items are documented (classes aren't,
eg), and then pull the module name into the documentation for that specific
thing.
-->

You may pull in just the part of this semver utility that you need if you
are sensitive to packing and tree-shaking concerns.  The main
`require('semver')` export uses getter functions to lazily load the parts
of the API that are used.

The following modules are available:

* `require('semver')`
* `require('semver/classes')`
* `require('semver/classes/comparator')`
* `require('semver/classes/range')`
* `require('semver/classes/semver')`
* `require('semver/functions/clean')`
* `require('semver/functions/cmp')`
* `require('semver/functions/coerce')`
* `require('semver/functions/compare')`
* `require('semver/functions/compare-build')`
* `require('semver/functions/compare-loose')`
* `require('semver/functions/diff')`
* `require('semver/functions/eq')`
* `require('semver/functions/gt')`
* `require('semver/functions/gte')`
* `require('semver/functions/inc')`
* `require('semver/functions/lt')`
* `require('semver/functions/lte')`
* `require('semver/functions/major')`
* `require('semver/functions/minor')`
* `require('semver/functions/neq')`
* `require('semver/functions/parse')`
* `require('semver/functions/patch')`
* `require('semver/functions/prerelease')`
* `require('semver/functions/rcompare')`
* `require('semver/functions/rsort')`
* `require('semver/functions/satisfies')`
* `require('semver/functions/sort')`
* `require('semver/functions/valid')`
* `require('semver/ranges/gtr')`
* `require('semver/ranges/intersects')`
* `require('semver/ranges/ltr')`
* `require('semver/ranges/max-satisfying')`
* `require('semver/ranges/min-satisfying')`
* `require('semver/ranges/min-version')`
* `require('semver/ranges/outside')`
* `require('semver/ranges/simplify')`
* `require('semver/ranges/subset')`
* `require('semver/ranges/to-comparators')`
* `require('semver/ranges/valid')`

{
  "name": "@npmcli/fs",
  "version": "3.1.1",
  "description": "filesystem utilities for the npm cli",
  "main": "lib/index.js",
  "files": [
    "bin/",
    "lib/"
  ],
  "scripts": {
    "snap": "tap",
    "test": "tap",
    "npmclilint": "npmcli-lint",
    "lint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\"",
    "lintfix": "npm run lint -- --fix",
    "posttest": "npm run lint",
    "postsnap": "npm run lintfix --",
    "postlint": "template-oss-check",
    "template-oss-apply": "template-oss-apply --force"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/npm/fs.git"
  },
  "keywords": [
    "npm",
    "oss"
  ],
  "author": "GitHub Inc.",
  "license": "ISC",
  "devDependencies": {
    "@npmcli/eslint-config": "^4.0.0",
    "@npmcli/template-oss": "4.22.0",
    "tap": "^16.0.1"
  },
  "dependencies": {
    "semver": "^7.3.5"
  },
  "engines": {
    "node": "^14.17.0 || ^16.13.0 || >=18.0.0"
  },
  "templateOSS": {
    "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
    "version": "4.22.0"
  },
  "tap": {
    "nyc-arg": [
      "--exclude",
      "tap-snapshots/**"
    ]
  }
}
# @npmcli/fs

polyfills, and extensions, of the core `fs` module.

## Features

- `fs.cp` polyfill for node < 16.7.0
- `fs.withTempDir` added
- `fs.readdirScoped` added
- `fs.moveFile` added

## `fs.withTempDir(root, fn, options) -> Promise`

### Parameters

- `root`: the directory in which to create the temporary directory
- `fn`: a function that will be called with the path to the temporary directory
- `options`
  - `tmpPrefix`: a prefix to be used in the generated directory name

### Usage

The `withTempDir` function creates a temporary directory, runs the provided
function (`fn`), then removes the temporary directory and resolves or rejects
based on the result of `fn`.

```js
const fs = require('@npmcli/fs')
const os = require('os')

// this function will be called with the full path to the temporary directory
// it is called with `await` behind the scenes, so can be async if desired.
const myFunction = async (tempPath) => {
  return 'done!'
}

const main = async () => {
  const result = await fs.withTempDir(os.tmpdir(), myFunction)
  // result === 'done!'
}

main()
```

## `fs.readdirScoped(root) -> Promise`

### Parameters

- `root`: the directory to read

### Usage

Like `fs.readdir` but handling `@org/module` dirs as if they were
a single entry.

```javascript
const { readdirScoped } = require('@npmcli/fs')
const entries = await readdirScoped('node_modules')
// entries will be something like: ['a', '@org/foo', '@org/bar']
```

## `fs.moveFile(source, dest, options) -> Promise`

A fork of [move-file](https://github.com/sindresorhus/move-file) with
support for Common JS.

### Highlights

- Promise API.
- Supports moving a file across partitions and devices.
- Optionally prevent overwriting an existing file.
- Creates non-existent destination directories for you.
- Automatically recurses when source is a directory.

### Parameters

- `source`: File, or directory, you want to move.
- `dest`: Where you want the file or directory moved.
- `options`
  - `overwrite` (`boolean`, default: `true`): Overwrite existing destination file(s).

### Usage

The built-in
[`fs.rename()`](https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback)
is just a JavaScript wrapper for the C `rename(2)` function, which doesn't
support moving files across partitions or devices. This module is what you
would have expected `fs.rename()` to be.

```js
const { moveFile } = require('@npmcli/fs');

(async () => {
	await moveFile('source/unicorn.png', 'destination/unicorn.png');
	console.log('The file has been moved');
})();
```
# EditorConfig is awesome: http://EditorConfig.org

# top-most EditorConfig file
root = true

# Copied from Node.js to ease compatibility in PR.
[*]
charset = utf-8
end_of_line = lf
indent_size = 2
indent_style = space
insert_final_newline = true
trim_trailing_whitespace = true
quote_type = single
# Changelog

## [0.11.0](https://github.com/pkgjs/parseargs/compare/v0.10.0...v0.11.0) (2022-10-08)


### Features

* add `default` option parameter ([#142](https://github.com/pkgjs/parseargs/issues/142)) ([cd20847](https://github.com/pkgjs/parseargs/commit/cd20847a00b2f556aa9c085ac83b942c60868ec1))

## [0.10.0](https://github.com/pkgjs/parseargs/compare/v0.9.1...v0.10.0) (2022-07-21)


### Features

* add parsed meta-data to returned properties ([#129](https://github.com/pkgjs/parseargs/issues/129)) ([91bfb4d](https://github.com/pkgjs/parseargs/commit/91bfb4d3f7b6937efab1b27c91c45d1205f1497e))

## [0.9.1](https://github.com/pkgjs/parseargs/compare/v0.9.0...v0.9.1) (2022-06-20)


### Bug Fixes

* **runtime:** support node 14+ ([#135](https://github.com/pkgjs/parseargs/issues/135)) ([6a1c5a6](https://github.com/pkgjs/parseargs/commit/6a1c5a6f7cadf2f035e004027e2742e3c4ce554b))

## [0.9.0](https://github.com/pkgjs/parseargs/compare/v0.8.0...v0.9.0) (2022-05-23)


### ⚠ BREAKING CHANGES

* drop handling of electron arguments (#121)

### Code Refactoring

* drop handling of electron arguments ([#121](https://github.com/pkgjs/parseargs/issues/121)) ([a2ffd53](https://github.com/pkgjs/parseargs/commit/a2ffd537c244a062371522b955acb45a404fc9f2))

## [0.8.0](https://github.com/pkgjs/parseargs/compare/v0.7.1...v0.8.0) (2022-05-16)


### ⚠ BREAKING CHANGES

* switch type:string option arguments to greedy, but with error for suspect cases in strict mode (#88)
* positionals now opt-in when strict:true (#116)
* create result.values with null prototype (#111)

### Features

* create result.values with null prototype ([#111](https://github.com/pkgjs/parseargs/issues/111)) ([9d539c3](https://github.com/pkgjs/parseargs/commit/9d539c3d57f269c160e74e0656ad4fa84ff92ec2))
* positionals now opt-in when strict:true ([#116](https://github.com/pkgjs/parseargs/issues/116)) ([3643338](https://github.com/pkgjs/parseargs/commit/364333826b746e8a7dc5505b4b22fd19ac51df3b))
* switch type:string option arguments to greedy, but with error for suspect cases in strict mode ([#88](https://github.com/pkgjs/parseargs/issues/88)) ([c2b5e72](https://github.com/pkgjs/parseargs/commit/c2b5e72161991dfdc535909f1327cc9b970fe7e8))

### [0.7.1](https://github.com/pkgjs/parseargs/compare/v0.7.0...v0.7.1) (2022-04-15)


### Bug Fixes

* resist pollution ([#106](https://github.com/pkgjs/parseargs/issues/106)) ([ecf2dec](https://github.com/pkgjs/parseargs/commit/ecf2dece0a9f2a76d789384d5d71c68ffe64022a))

## [0.7.0](https://github.com/pkgjs/parseargs/compare/v0.6.0...v0.7.0) (2022-04-13)


### Features

* Add strict mode to parser ([#74](https://github.com/pkgjs/parseargs/issues/74)) ([8267d02](https://github.com/pkgjs/parseargs/commit/8267d02083a87b8b8a71fcce08348d1e031ea91c))

## [0.6.0](https://github.com/pkgjs/parseargs/compare/v0.5.0...v0.6.0) (2022-04-11)


### ⚠ BREAKING CHANGES

* rework results to remove redundant `flags` property and store value true for boolean options (#83)
* switch to existing ERR_INVALID_ARG_VALUE (#97)

### Code Refactoring

* rework results to remove redundant `flags` property and store value true for boolean options ([#83](https://github.com/pkgjs/parseargs/issues/83)) ([be153db](https://github.com/pkgjs/parseargs/commit/be153dbed1d488cb7b6e27df92f601ba7337713d))
* switch to existing ERR_INVALID_ARG_VALUE ([#97](https://github.com/pkgjs/parseargs/issues/97)) ([084a23f](https://github.com/pkgjs/parseargs/commit/084a23f9fde2da030b159edb1c2385f24579ce40))

## [0.5.0](https://github.com/pkgjs/parseargs/compare/v0.4.0...v0.5.0) (2022-04-10)


### ⚠ BREAKING CHANGES

* Require type to be specified for each supplied option (#95)

### Features

* Require type to be specified for each supplied option ([#95](https://github.com/pkgjs/parseargs/issues/95)) ([02cd018](https://github.com/pkgjs/parseargs/commit/02cd01885b8aaa59f2db8308f2d4479e64340068))

## [0.4.0](https://github.com/pkgjs/parseargs/compare/v0.3.0...v0.4.0) (2022-03-12)


### ⚠ BREAKING CHANGES

* parsing, revisit short option groups, add support for combined short and value (#75)
* restructure configuration to take options bag (#63)

### Code Refactoring

* parsing, revisit short option groups, add support for combined short and value ([#75](https://github.com/pkgjs/parseargs/issues/75)) ([a92600f](https://github.com/pkgjs/parseargs/commit/a92600fa6c214508ab1e016fa55879a314f541af))
* restructure configuration to take options bag ([#63](https://github.com/pkgjs/parseargs/issues/63)) ([b412095](https://github.com/pkgjs/parseargs/commit/b4120957d90e809ee8b607b06e747d3e6a6b213e))

## [0.3.0](https://github.com/pkgjs/parseargs/compare/v0.2.0...v0.3.0) (2022-02-06)


### Features

* **parser:** support short-option groups ([#59](https://github.com/pkgjs/parseargs/issues/59)) ([882067b](https://github.com/pkgjs/parseargs/commit/882067bc2d7cbc6b796f8e5a079a99bc99d4e6ba))

## [0.2.0](https://github.com/pkgjs/parseargs/compare/v0.1.1...v0.2.0) (2022-02-05)


### Features

* basic support for shorts ([#50](https://github.com/pkgjs/parseargs/issues/50)) ([a2f36d7](https://github.com/pkgjs/parseargs/commit/a2f36d7da4145af1c92f76806b7fe2baf6beeceb))


### Bug Fixes

* always store value for a=b ([#43](https://github.com/pkgjs/parseargs/issues/43)) ([a85e8dc](https://github.com/pkgjs/parseargs/commit/a85e8dc06379fd2696ee195cc625de8fac6aee42))
* support single dash as positional ([#49](https://github.com/pkgjs/parseargs/issues/49)) ([d795bf8](https://github.com/pkgjs/parseargs/commit/d795bf877d068fd67aec381f30b30b63f97109ad))

### [0.1.1](https://github.com/pkgjs/parseargs/compare/v0.1.0...v0.1.1) (2022-01-25)


### Bug Fixes

* only use arrays in results for multiples ([#42](https://github.com/pkgjs/parseargs/issues/42)) ([c357584](https://github.com/pkgjs/parseargs/commit/c357584847912506319ed34a0840080116f4fd65))

## 0.1.0 (2022-01-22)


### Features

* expand scenarios covered by default arguments for environments ([#20](https://github.com/pkgjs/parseargs/issues/20)) ([582ada7](https://github.com/pkgjs/parseargs/commit/582ada7be0eca3a73d6e0bd016e7ace43449fa4c))
* update readme and include contributing guidelines ([8edd6fc](https://github.com/pkgjs/parseargs/commit/8edd6fc863cd705f6fac732724159ebe8065a2b0))


### Bug Fixes

* do not strip excess leading dashes on long option names ([#21](https://github.com/pkgjs/parseargs/issues/21)) ([f848590](https://github.com/pkgjs/parseargs/commit/f848590ebf3249ed5979ff47e003fa6e1a8ec5c0))
* name & readme ([3f057c1](https://github.com/pkgjs/parseargs/commit/3f057c1b158a1bdbe878c64b57460c58e56e465f))
* package.json values ([9bac300](https://github.com/pkgjs/parseargs/commit/9bac300e00cd76c77076bf9e75e44f8929512da9))
* update readme name ([957d8d9](https://github.com/pkgjs/parseargs/commit/957d8d96e1dcb48297c0a14345d44c0123b2883e))


### Build System

* first release as minor ([421c6e2](https://github.com/pkgjs/parseargs/commit/421c6e2569a8668ad14fac5a5af5be60479a7571))
'use strict';

// This example shows how to understand if a default value is used or not.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  file: { short: 'f', type: 'string', default: 'FOO' },
};

const { values, tokens } = parseArgs({ options, tokens: true });

const isFileDefault = !tokens.some((token) => token.kind === 'option' &&
 token.name === 'file'
);

console.log(values);
console.log(`Is the file option [${values.file}] the default value? ${isFileDefault}`);

// Try the following:
//    node is-default-value.js
//    node is-default-value.js -f FILE
//    node is-default-value.js --file FILE
'use strict';

// This is an example of using tokens to add a custom behaviour.
//
// Require the use of `=` for long options and values by blocking
// the use of space separated values.
// So allow `--foo=bar`, and not allow `--foo bar`.
//
// Note: this is not a common behaviour, most CLIs allow both forms.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  file: { short: 'f', type: 'string' },
  log: { type: 'string' },
};

const { values, tokens } = parseArgs({ options, tokens: true });

const badToken = tokens.find((token) => token.kind === 'option' &&
  token.value != null &&
  token.rawName.startsWith('--') &&
  !token.inlineValue
);
if (badToken) {
  throw new Error(`Option value for '${badToken.rawName}' must be inline, like '${badToken.rawName}=VALUE'`);
}

console.log(values);

// Try the following:
//    node limit-long-syntax.js -f FILE --log=LOG
//    node limit-long-syntax.js --file FILE
'use strict';

// This example is used in the documentation.

// How might I add my own support for --no-foo?

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  'color': { type: 'boolean' },
  'no-color': { type: 'boolean' },
  'logfile': { type: 'string' },
  'no-logfile': { type: 'boolean' },
};
const { values, tokens } = parseArgs({ options, tokens: true });

// Reprocess the option tokens and overwrite the returned values.
tokens
  .filter((token) => token.kind === 'option')
  .forEach((token) => {
    if (token.name.startsWith('no-')) {
      // Store foo:false for --no-foo
      const positiveName = token.name.slice(3);
      values[positiveName] = false;
      delete values[token.name];
    } else {
      // Resave value so last one wins if both --foo and --no-foo.
      values[token.name] = token.value ?? true;
    }
  });

const color = values.color;
const logfile = values.logfile ?? 'default.log';

console.log({ logfile, color });

// Try the following:
//    node negate.js
//    node negate.js --no-logfile --no-color
//    negate.js --logfile=test.log --color
//    node negate.js --no-logfile --logfile=test.log --color --no-color
'use strict';

// This is an example of using tokens to add a custom behaviour.
//
// Throw an error if an option is used more than once.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const options = {
  ding: { type: 'boolean', short: 'd' },
  beep: { type: 'boolean', short: 'b' }
};
const { values, tokens } = parseArgs({ options, tokens: true });

const seenBefore = new Set();
tokens.forEach((token) => {
  if (token.kind !== 'option') return;
  if (seenBefore.has(token.name)) {
    throw new Error(`option '${token.name}' used multiple times`);
  }
  seenBefore.add(token.name);
});

console.log(values);

// Try the following:
//    node no-repeated-options --ding --beep
//    node no-repeated-options --beep -b
//    node no-repeated-options -ddd
// This is an example of using tokens to add a custom behaviour.
//
// This adds a option order check so that --some-unstable-option
// may only be used after --enable-experimental-options
//
// Note: this is not a common behaviour, the order of different options
// does not usually matter.

import { parseArgs } from '../index.js';

function findTokenIndex(tokens, target) {
  return tokens.findIndex((token) => token.kind === 'option' &&
    token.name === target
  );
}

const experimentalName = 'enable-experimental-options';
const unstableName = 'some-unstable-option';

const options = {
  [experimentalName]: { type: 'boolean' },
  [unstableName]: { type: 'boolean' },
};

const { values, tokens } = parseArgs({ options, tokens: true });

const experimentalIndex = findTokenIndex(tokens, experimentalName);
const unstableIndex = findTokenIndex(tokens, unstableName);
if (unstableIndex !== -1 &&
  ((experimentalIndex === -1) || (unstableIndex < experimentalIndex))) {
  throw new Error(`'--${experimentalName}' must be specified before '--${unstableName}'`);
}

console.log(values);

/* eslint-disable max-len */
// Try the following:
//    node ordered-options.mjs
//    node ordered-options.mjs --some-unstable-option
//    node ordered-options.mjs --some-unstable-option --enable-experimental-options
//    node ordered-options.mjs --enable-experimental-options --some-unstable-option
'use strict';

// This example is used in the documentation.

// 1. const { parseArgs } = require('node:util'); // from node
// 2. const { parseArgs } = require('@pkgjs/parseargs'); // from package
const { parseArgs } = require('..'); // in repo

const args = ['-f', '--bar', 'b'];
const options = {
  foo: {
    type: 'boolean',
    short: 'f'
  },
  bar: {
    type: 'string'
  }
};
const {
  values,
  positionals
} = parseArgs({ args, options });
console.log(values, positionals);

// Try the following:
//    node simple-hard-coded.js
'use strict';

const {
  ArrayPrototypeForEach,
  ArrayPrototypeIncludes,
  ArrayPrototypeMap,
  ArrayPrototypePush,
  ArrayPrototypePushApply,
  ArrayPrototypeShift,
  ArrayPrototypeSlice,
  ArrayPrototypeUnshiftApply,
  ObjectEntries,
  ObjectPrototypeHasOwnProperty: ObjectHasOwn,
  StringPrototypeCharAt,
  StringPrototypeIndexOf,
  StringPrototypeSlice,
  StringPrototypeStartsWith,
} = require('./internal/primordials');

const {
  validateArray,
  validateBoolean,
  validateBooleanArray,
  validateObject,
  validateString,
  validateStringArray,
  validateUnion,
} = require('./internal/validators');

const {
  kEmptyObject,
} = require('./internal/util');

const {
  findLongOptionForShort,
  isLoneLongOption,
  isLoneShortOption,
  isLongOptionAndValue,
  isOptionValue,
  isOptionLikeValue,
  isShortOptionAndValue,
  isShortOptionGroup,
  useDefaultValueOption,
  objectGetOwn,
  optionsGetOwn,
} = require('./utils');

const {
  codes: {
    ERR_INVALID_ARG_VALUE,
    ERR_PARSE_ARGS_INVALID_OPTION_VALUE,
    ERR_PARSE_ARGS_UNKNOWN_OPTION,
    ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL,
  },
} = require('./internal/errors');

function getMainArgs() {
  // Work out where to slice process.argv for user supplied arguments.

  // Check node options for scenarios where user CLI args follow executable.
  const execArgv = process.execArgv;
  if (ArrayPrototypeIncludes(execArgv, '-e') ||
      ArrayPrototypeIncludes(execArgv, '--eval') ||
      ArrayPrototypeIncludes(execArgv, '-p') ||
      ArrayPrototypeIncludes(execArgv, '--print')) {
    return ArrayPrototypeSlice(process.argv, 1);
  }

  // Normally first two arguments are executable and script, then CLI arguments
  return ArrayPrototypeSlice(process.argv, 2);
}

/**
 * In strict mode, throw for possible usage errors like --foo --bar
 *
 * @param {object} token - from tokens as available from parseArgs
 */
function checkOptionLikeValue(token) {
  if (!token.inlineValue && isOptionLikeValue(token.value)) {
    // Only show short example if user used short option.
    const example = StringPrototypeStartsWith(token.rawName, '--') ?
      `'${token.rawName}=-XYZ'` :
      `'--${token.name}=-XYZ' or '${token.rawName}-XYZ'`;
    const errorMessage = `Option '${token.rawName}' argument is ambiguous.
Did you forget to specify the option argument for '${token.rawName}'?
To specify an option argument starting with a dash use ${example}.`;
    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(errorMessage);
  }
}

/**
 * In strict mode, throw for usage errors.
 *
 * @param {object} config - from config passed to parseArgs
 * @param {object} token - from tokens as available from parseArgs
 */
function checkOptionUsage(config, token) {
  if (!ObjectHasOwn(config.options, token.name)) {
    throw new ERR_PARSE_ARGS_UNKNOWN_OPTION(
      token.rawName, config.allowPositionals);
  }

  const short = optionsGetOwn(config.options, token.name, 'short');
  const shortAndLong = `${short ? `-${short}, ` : ''}--${token.name}`;
  const type = optionsGetOwn(config.options, token.name, 'type');
  if (type === 'string' && typeof token.value !== 'string') {
    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(`Option '${shortAndLong} <value>' argument missing`);
  }
  // (Idiomatic test for undefined||null, expecting undefined.)
  if (type === 'boolean' && token.value != null) {
    throw new ERR_PARSE_ARGS_INVALID_OPTION_VALUE(`Option '${shortAndLong}' does not take an argument`);
  }
}


/**
 * Store the option value in `values`.
 *
 * @param {string} longOption - long option name e.g. 'foo'
 * @param {string|undefined} optionValue - value from user args
 * @param {object} options - option configs, from parseArgs({ options })
 * @param {object} values - option values returned in `values` by parseArgs
 */
function storeOption(longOption, optionValue, options, values) {
  if (longOption === '__proto__') {
    return; // No. Just no.
  }

  // We store based on the option value rather than option type,
  // preserving the users intent for author to deal with.
  const newValue = optionValue ?? true;
  if (optionsGetOwn(options, longOption, 'multiple')) {
    // Always store value in array, including for boolean.
    // values[longOption] starts out not present,
    // first value is added as new array [newValue],
    // subsequent values are pushed to existing array.
    // (note: values has null prototype, so simpler usage)
    if (values[longOption]) {
      ArrayPrototypePush(values[longOption], newValue);
    } else {
      values[longOption] = [newValue];
    }
  } else {
    values[longOption] = newValue;
  }
}

/**
 * Store the default option value in `values`.
 *
 * @param {string} longOption - long option name e.g. 'foo'
 * @param {string
 *         | boolean
 *         | string[]
 *         | boolean[]} optionValue - default value from option config
 * @param {object} values - option values returned in `values` by parseArgs
 */
function storeDefaultOption(longOption, optionValue, values) {
  if (longOption === '__proto__') {
    return; // No. Just no.
  }

  values[longOption] = optionValue;
}

/**
 * Process args and turn into identified tokens:
 * - option (along with value, if any)
 * - positional
 * - option-terminator
 *
 * @param {string[]} args - from parseArgs({ args }) or mainArgs
 * @param {object} options - option configs, from parseArgs({ options })
 */
function argsToTokens(args, options) {
  const tokens = [];
  let index = -1;
  let groupCount = 0;

  const remainingArgs = ArrayPrototypeSlice(args);
  while (remainingArgs.length > 0) {
    const arg = ArrayPrototypeShift(remainingArgs);
    const nextArg = remainingArgs[0];
    if (groupCount > 0)
      groupCount--;
    else
      index++;

    // Check if `arg` is an options terminator.
    // Guideline 10 in https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
    if (arg === '--') {
      // Everything after a bare '--' is considered a positional argument.
      ArrayPrototypePush(tokens, { kind: 'option-terminator', index });
      ArrayPrototypePushApply(
        tokens, ArrayPrototypeMap(remainingArgs, (arg) => {
          return { kind: 'positional', index: ++index, value: arg };
        })
      );
      break; // Finished processing args, leave while loop.
    }

    if (isLoneShortOption(arg)) {
      // e.g. '-f'
      const shortOption = StringPrototypeCharAt(arg, 1);
      const longOption = findLongOptionForShort(shortOption, options);
      let value;
      let inlineValue;
      if (optionsGetOwn(options, longOption, 'type') === 'string' &&
          isOptionValue(nextArg)) {
        // e.g. '-f', 'bar'
        value = ArrayPrototypeShift(remainingArgs);
        inlineValue = false;
      }
      ArrayPrototypePush(
        tokens,
        { kind: 'option', name: longOption, rawName: arg,
          index, value, inlineValue });
      if (value != null) ++index;
      continue;
    }

    if (isShortOptionGroup(arg, options)) {
      // Expand -fXzy to -f -X -z -y
      const expanded = [];
      for (let index = 1; index < arg.length; index++) {
        const shortOption = StringPrototypeCharAt(arg, index);
        const longOption = findLongOptionForShort(shortOption, options);
        if (optionsGetOwn(options, longOption, 'type') !== 'string' ||
          index === arg.length - 1) {
          // Boolean option, or last short in group. Well formed.
          ArrayPrototypePush(expanded, `-${shortOption}`);
        } else {
          // String option in middle. Yuck.
          // Expand -abfFILE to -a -b -fFILE
          ArrayPrototypePush(expanded, `-${StringPrototypeSlice(arg, index)}`);
          break; // finished short group
        }
      }
      ArrayPrototypeUnshiftApply(remainingArgs, expanded);
      groupCount = expanded.length;
      continue;
    }

    if (isShortOptionAndValue(arg, options)) {
      // e.g. -fFILE
      const shortOption = StringPrototypeCharAt(arg, 1);
      const longOption = findLongOptionForShort(shortOption, options);
      const value = StringPrototypeSlice(arg, 2);
      ArrayPrototypePush(
        tokens,
        { kind: 'option', name: longOption, rawName: `-${shortOption}`,
          index, value, inlineValue: true });
      continue;
    }

    if (isLoneLongOption(arg)) {
      // e.g. '--foo'
      const longOption = StringPrototypeSlice(arg, 2);
      let value;
      let inlineValue;
      if (optionsGetOwn(options, longOption, 'type') === 'string' &&
          isOptionValue(nextArg)) {
        // e.g. '--foo', 'bar'
        value = ArrayPrototypeShift(remainingArgs);
        inlineValue = false;
      }
      ArrayPrototypePush(
        tokens,
        { kind: 'option', name: longOption, rawName: arg,
          index, value, inlineValue });
      if (value != null) ++index;
      continue;
    }

    if (isLongOptionAndValue(arg)) {
      // e.g. --foo=bar
      const equalIndex = StringPrototypeIndexOf(arg, '=');
      const longOption = StringPrototypeSlice(arg, 2, equalIndex);
      const value = StringPrototypeSlice(arg, equalIndex + 1);
      ArrayPrototypePush(
        tokens,
        { kind: 'option', name: longOption, rawName: `--${longOption}`,
          index, value, inlineValue: true });
      continue;
    }

    ArrayPrototypePush(tokens, { kind: 'positional', index, value: arg });
  }

  return tokens;
}

const parseArgs = (config = kEmptyObject) => {
  const args = objectGetOwn(config, 'args') ?? getMainArgs();
  const strict = objectGetOwn(config, 'strict') ?? true;
  const allowPositionals = objectGetOwn(config, 'allowPositionals') ?? !strict;
  const returnTokens = objectGetOwn(config, 'tokens') ?? false;
  const options = objectGetOwn(config, 'options') ?? { __proto__: null };
  // Bundle these up for passing to strict-mode checks.
  const parseConfig = { args, strict, options, allowPositionals };

  // Validate input configuration.
  validateArray(args, 'args');
  validateBoolean(strict, 'strict');
  validateBoolean(allowPositionals, 'allowPositionals');
  validateBoolean(returnTokens, 'tokens');
  validateObject(options, 'options');
  ArrayPrototypeForEach(
    ObjectEntries(options),
    ({ 0: longOption, 1: optionConfig }) => {
      validateObject(optionConfig, `options.${longOption}`);

      // type is required
      const optionType = objectGetOwn(optionConfig, 'type');
      validateUnion(optionType, `options.${longOption}.type`, ['string', 'boolean']);

      if (ObjectHasOwn(optionConfig, 'short')) {
        const shortOption = optionConfig.short;
        validateString(shortOption, `options.${longOption}.short`);
        if (shortOption.length !== 1) {
          throw new ERR_INVALID_ARG_VALUE(
            `options.${longOption}.short`,
            shortOption,
            'must be a single character'
          );
        }
      }

      const multipleOption = objectGetOwn(optionConfig, 'multiple');
      if (ObjectHasOwn(optionConfig, 'multiple')) {
        validateBoolean(multipleOption, `options.${longOption}.multiple`);
      }

      const defaultValue = objectGetOwn(optionConfig, 'default');
      if (defaultValue !== undefined) {
        let validator;
        switch (optionType) {
          case 'string':
            validator = multipleOption ? validateStringArray : validateString;
            break;

          case 'boolean':
            validator = multipleOption ? validateBooleanArray : validateBoolean;
            break;
        }
        validator(defaultValue, `options.${longOption}.default`);
      }
    }
  );

  // Phase 1: identify tokens
  const tokens = argsToTokens(args, options);

  // Phase 2: process tokens into parsed option values and positionals
  const result = {
    values: { __proto__: null },
    positionals: [],
  };
  if (returnTokens) {
    result.tokens = tokens;
  }
  ArrayPrototypeForEach(tokens, (token) => {
    if (token.kind === 'option') {
      if (strict) {
        checkOptionUsage(parseConfig, token);
        checkOptionLikeValue(token);
      }
      storeOption(token.name, token.value, options, result.values);
    } else if (token.kind === 'positional') {
      if (!allowPositionals) {
        throw new ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL(token.value);
      }
      ArrayPrototypePush(result.positionals, token.value);
    }
  });

  // Phase 3: fill in default values for missing args
  ArrayPrototypeForEach(ObjectEntries(options), ({ 0: longOption,
                                                   1: optionConfig }) => {
    const mustSetDefault = useDefaultValueOption(longOption,
                                                 optionConfig,
                                                 result.values);
    if (mustSetDefault) {
      storeDefaultOption(longOption,
                         objectGetOwn(optionConfig, 'default'),
                         result.values);
    }
  });


  return result;
};

module.exports = {
  parseArgs,
};
'use strict';

class ERR_INVALID_ARG_TYPE extends TypeError {
  constructor(name, expected, actual) {
    super(`${name} must be ${expected} got ${actual}`);
    this.code = 'ERR_INVALID_ARG_TYPE';
  }
}

class ERR_INVALID_ARG_VALUE extends TypeError {
  constructor(arg1, arg2, expected) {
    super(`The property ${arg1} ${expected}. Received '${arg2}'`);
    this.code = 'ERR_INVALID_ARG_VALUE';
  }
}

class ERR_PARSE_ARGS_INVALID_OPTION_VALUE extends Error {
  constructor(message) {
    super(message);
    this.code = 'ERR_PARSE_ARGS_INVALID_OPTION_VALUE';
  }
}

class ERR_PARSE_ARGS_UNKNOWN_OPTION extends Error {
  constructor(option, allowPositionals) {
    const suggestDashDash = allowPositionals ? `. To specify a positional argument starting with a '-', place it at the end of the command after '--', as in '-- ${JSON.stringify(option)}` : '';
    super(`Unknown option '${option}'${suggestDashDash}`);
    this.code = 'ERR_PARSE_ARGS_UNKNOWN_OPTION';
  }
}

class ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL extends Error {
  constructor(positional) {
    super(`Unexpected argument '${positional}'. This command does not take positional arguments`);
    this.code = 'ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL';
  }
}

module.exports = {
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE,
    ERR_PARSE_ARGS_INVALID_OPTION_VALUE,
    ERR_PARSE_ARGS_UNKNOWN_OPTION,
    ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL,
  }
};
/*
This file is copied from https://github.com/nodejs/node/blob/v14.19.3/lib/internal/per_context/primordials.js
under the following license:

Copyright Node.js contributors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
*/

'use strict';

/* eslint-disable node-core/prefer-primordials */

// This file subclasses and stores the JS builtins that come from the VM
// so that Node.js's builtin modules do not need to later look these up from
// the global proxy, which can be mutated by users.

// Use of primordials have sometimes a dramatic impact on performance, please
// benchmark all changes made in performance-sensitive areas of the codebase.
// See: https://github.com/nodejs/node/pull/38248

const primordials = {};

const {
  defineProperty: ReflectDefineProperty,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
  ownKeys: ReflectOwnKeys,
} = Reflect;

// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.
// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`
// and `Function.prototype.call` after it may have been mutated by users.
const { apply, bind, call } = Function.prototype;
const uncurryThis = bind.bind(call);
primordials.uncurryThis = uncurryThis;

// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.
// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`
// and `Function.prototype.apply` after it may have been mutated by users.
const applyBind = bind.bind(apply);
primordials.applyBind = applyBind;

// Methods that accept a variable number of arguments, and thus it's useful to
// also create `${prefix}${key}Apply`, which uses `Function.prototype.apply`,
// instead of `Function.prototype.call`, and thus doesn't require iterator
// destructuring.
const varargsMethods = [
  // 'ArrayPrototypeConcat' is omitted, because it performs the spread
  // on its own for arrays and array-likes with a truthy
  // @@isConcatSpreadable symbol property.
  'ArrayOf',
  'ArrayPrototypePush',
  'ArrayPrototypeUnshift',
  // 'FunctionPrototypeCall' is omitted, since there's 'ReflectApply'
  // and 'FunctionPrototypeApply'.
  'MathHypot',
  'MathMax',
  'MathMin',
  'StringPrototypeConcat',
  'TypedArrayOf',
];

function getNewKey(key) {
  return typeof key === 'symbol' ?
    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :
    `${key[0].toUpperCase()}${key.slice(1)}`;
}

function copyAccessor(dest, prefix, key, { enumerable, get, set }) {
  ReflectDefineProperty(dest, `${prefix}Get${key}`, {
    value: uncurryThis(get),
    enumerable
  });
  if (set !== undefined) {
    ReflectDefineProperty(dest, `${prefix}Set${key}`, {
      value: uncurryThis(set),
      enumerable
    });
  }
}

function copyPropsRenamed(src, dest, prefix) {
  for (const key of ReflectOwnKeys(src)) {
    const newKey = getNewKey(key);
    const desc = ReflectGetOwnPropertyDescriptor(src, key);
    if ('get' in desc) {
      copyAccessor(dest, prefix, newKey, desc);
    } else {
      const name = `${prefix}${newKey}`;
      ReflectDefineProperty(dest, name, desc);
      if (varargsMethods.includes(name)) {
        ReflectDefineProperty(dest, `${name}Apply`, {
          // `src` is bound as the `this` so that the static `this` points
          // to the object it was defined on,
          // e.g.: `ArrayOfApply` gets a `this` of `Array`:
          value: applyBind(desc.value, src),
        });
      }
    }
  }
}

function copyPropsRenamedBound(src, dest, prefix) {
  for (const key of ReflectOwnKeys(src)) {
    const newKey = getNewKey(key);
    const desc = ReflectGetOwnPropertyDescriptor(src, key);
    if ('get' in desc) {
      copyAccessor(dest, prefix, newKey, desc);
    } else {
      const { value } = desc;
      if (typeof value === 'function') {
        desc.value = value.bind(src);
      }

      const name = `${prefix}${newKey}`;
      ReflectDefineProperty(dest, name, desc);
      if (varargsMethods.includes(name)) {
        ReflectDefineProperty(dest, `${name}Apply`, {
          value: applyBind(value, src),
        });
      }
    }
  }
}

function copyPrototype(src, dest, prefix) {
  for (const key of ReflectOwnKeys(src)) {
    const newKey = getNewKey(key);
    const desc = ReflectGetOwnPropertyDescriptor(src, key);
    if ('get' in desc) {
      copyAccessor(dest, prefix, newKey, desc);
    } else {
      const { value } = desc;
      if (typeof value === 'function') {
        desc.value = uncurryThis(value);
      }

      const name = `${prefix}${newKey}`;
      ReflectDefineProperty(dest, name, desc);
      if (varargsMethods.includes(name)) {
        ReflectDefineProperty(dest, `${name}Apply`, {
          value: applyBind(value),
        });
      }
    }
  }
}

// Create copies of configurable value properties of the global object
[
  'Proxy',
  'globalThis',
].forEach((name) => {
  // eslint-disable-next-line no-restricted-globals
  primordials[name] = globalThis[name];
});

// Create copies of URI handling functions
[
  decodeURI,
  decodeURIComponent,
  encodeURI,
  encodeURIComponent,
].forEach((fn) => {
  primordials[fn.name] = fn;
});

// Create copies of the namespace objects
[
  'JSON',
  'Math',
  'Proxy',
  'Reflect',
].forEach((name) => {
  // eslint-disable-next-line no-restricted-globals
  copyPropsRenamed(global[name], primordials, name);
});

// Create copies of intrinsic objects
[
  'Array',
  'ArrayBuffer',
  'BigInt',
  'BigInt64Array',
  'BigUint64Array',
  'Boolean',
  'DataView',
  'Date',
  'Error',
  'EvalError',
  'Float32Array',
  'Float64Array',
  'Function',
  'Int16Array',
  'Int32Array',
  'Int8Array',
  'Map',
  'Number',
  'Object',
  'RangeError',
  'ReferenceError',
  'RegExp',
  'Set',
  'String',
  'Symbol',
  'SyntaxError',
  'TypeError',
  'URIError',
  'Uint16Array',
  'Uint32Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'WeakMap',
  'WeakSet',
].forEach((name) => {
  // eslint-disable-next-line no-restricted-globals
  const original = global[name];
  primordials[name] = original;
  copyPropsRenamed(original, primordials, name);
  copyPrototype(original.prototype, primordials, `${name}Prototype`);
});

// Create copies of intrinsic objects that require a valid `this` to call
// static methods.
// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all
[
  'Promise',
].forEach((name) => {
  // eslint-disable-next-line no-restricted-globals
  const original = global[name];
  primordials[name] = original;
  copyPropsRenamedBound(original, primordials, name);
  copyPrototype(original.prototype, primordials, `${name}Prototype`);
});

// Create copies of abstract intrinsic objects that are not directly exposed
// on the global object.
// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object
[
  { name: 'TypedArray', original: Reflect.getPrototypeOf(Uint8Array) },
  { name: 'ArrayIterator', original: {
    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]()),
  } },
  { name: 'StringIterator', original: {
    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]()),
  } },
].forEach(({ name, original }) => {
  primordials[name] = original;
  // The static %TypedArray% methods require a valid `this`, but can't be bound,
  // as they need a subclass constructor as the receiver:
  copyPrototype(original, primordials, name);
  copyPrototype(original.prototype, primordials, `${name}Prototype`);
});

/* eslint-enable node-core/prefer-primordials */

const {
  ArrayPrototypeForEach,
  FunctionPrototypeCall,
  Map,
  ObjectFreeze,
  ObjectSetPrototypeOf,
  Set,
  SymbolIterator,
  WeakMap,
  WeakSet,
} = primordials;

// Because these functions are used by `makeSafe`, which is exposed
// on the `primordials` object, it's important to use const references
// to the primordials that they use:
const createSafeIterator = (factory, next) => {
  class SafeIterator {
    constructor(iterable) {
      this._iterator = factory(iterable);
    }
    next() {
      return next(this._iterator);
    }
    [SymbolIterator]() {
      return this;
    }
  }
  ObjectSetPrototypeOf(SafeIterator.prototype, null);
  ObjectFreeze(SafeIterator.prototype);
  ObjectFreeze(SafeIterator);
  return SafeIterator;
};

primordials.SafeArrayIterator = createSafeIterator(
  primordials.ArrayPrototypeSymbolIterator,
  primordials.ArrayIteratorPrototypeNext
);
primordials.SafeStringIterator = createSafeIterator(
  primordials.StringPrototypeSymbolIterator,
  primordials.StringIteratorPrototypeNext
);

const copyProps = (src, dest) => {
  ArrayPrototypeForEach(ReflectOwnKeys(src), (key) => {
    if (!ReflectGetOwnPropertyDescriptor(dest, key)) {
      ReflectDefineProperty(
        dest,
        key,
        ReflectGetOwnPropertyDescriptor(src, key));
    }
  });
};

const makeSafe = (unsafe, safe) => {
  if (SymbolIterator in unsafe.prototype) {
    const dummy = new unsafe();
    let next; // We can reuse the same `next` method.

    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype), (key) => {
      if (!ReflectGetOwnPropertyDescriptor(safe.prototype, key)) {
        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype, key);
        if (
          typeof desc.value === 'function' &&
          desc.value.length === 0 &&
          SymbolIterator in (FunctionPrototypeCall(desc.value, dummy) ?? {})
        ) {
          const createIterator = uncurryThis(desc.value);
          next = next ?? uncurryThis(createIterator(dummy).next);
          const SafeIterator = createSafeIterator(createIterator, next);
          desc.value = function() {
            return new SafeIterator(this);
          };
        }
        ReflectDefineProperty(safe.prototype, key, desc);
      }
    });
  } else {
    copyProps(unsafe.prototype, safe.prototype);
  }
  copyProps(unsafe, safe);

  ObjectSetPrototypeOf(safe.prototype, null);
  ObjectFreeze(safe.prototype);
  ObjectFreeze(safe);
  return safe;
};
primordials.makeSafe = makeSafe;

// Subclass the constructors because we need to use their prototype
// methods later.
// Defining the `constructor` is necessary here to avoid the default
// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.
primordials.SafeMap = makeSafe(
  Map,
  class SafeMap extends Map {
    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor
  }
);
primordials.SafeWeakMap = makeSafe(
  WeakMap,
  class SafeWeakMap extends WeakMap {
    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor
  }
);
primordials.SafeSet = makeSafe(
  Set,
  class SafeSet extends Set {
    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor
  }
);
primordials.SafeWeakSet = makeSafe(
  WeakSet,
  class SafeWeakSet extends WeakSet {
    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor
  }
);

ObjectSetPrototypeOf(primordials, null);
ObjectFreeze(primordials);

module.exports = primordials;
'use strict';

// This is a placeholder for util.js in node.js land.

const {
  ObjectCreate,
  ObjectFreeze,
} = require('./primordials');

const kEmptyObject = ObjectFreeze(ObjectCreate(null));

module.exports = {
  kEmptyObject,
};
'use strict';

// This file is a proxy of the original file located at:
// https://github.com/nodejs/node/blob/main/lib/internal/validators.js
// Every addition or modification to this file must be evaluated
// during the PR review.

const {
  ArrayIsArray,
  ArrayPrototypeIncludes,
  ArrayPrototypeJoin,
} = require('./primordials');

const {
  codes: {
    ERR_INVALID_ARG_TYPE
  }
} = require('./errors');

function validateString(value, name) {
  if (typeof value !== 'string') {
    throw new ERR_INVALID_ARG_TYPE(name, 'String', value);
  }
}

function validateUnion(value, name, union) {
  if (!ArrayPrototypeIncludes(union, value)) {
    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value);
  }
}

function validateBoolean(value, name) {
  if (typeof value !== 'boolean') {
    throw new ERR_INVALID_ARG_TYPE(name, 'Boolean', value);
  }
}

function validateArray(value, name) {
  if (!ArrayIsArray(value)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value);
  }
}

function validateStringArray(value, name) {
  validateArray(value, name);
  for (let i = 0; i < value.length; i++) {
    validateString(value[i], `${name}[${i}]`);
  }
}

function validateBooleanArray(value, name) {
  validateArray(value, name);
  for (let i = 0; i < value.length; i++) {
    validateBoolean(value[i], `${name}[${i}]`);
  }
}

/**
 * @param {unknown} value
 * @param {string} name
 * @param {{
 *   allowArray?: boolean,
 *   allowFunction?: boolean,
 *   nullable?: boolean
 * }} [options]
 */
function validateObject(value, name, options) {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if ((!nullable && value === null) ||
      (!allowArray && ArrayIsArray(value)) ||
      (typeof value !== 'object' && (
        !allowFunction || typeof value !== 'function'
      ))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);
  }
}

module.exports = {
  validateArray,
  validateObject,
  validateString,
  validateStringArray,
  validateUnion,
  validateBoolean,
  validateBooleanArray,
};
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
{
  "name": "@pkgjs/parseargs",
  "version": "0.11.0",
  "description": "Polyfill of future proposal for `util.parseArgs()`",
  "engines": {
    "node": ">=14"
  },
  "main": "index.js",
  "exports": {
    ".": "./index.js",
    "./package.json": "./package.json"
  },
  "scripts": {
    "coverage": "c8 --check-coverage tape 'test/*.js'",
    "test": "c8 tape 'test/*.js'",
    "posttest": "eslint .",
    "fix": "npm run posttest -- --fix"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:pkgjs/parseargs.git"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/pkgjs/parseargs/issues"
  },
  "homepage": "https://github.com/pkgjs/parseargs#readme",
  "devDependencies": {
    "c8": "^7.10.0",
    "eslint": "^8.2.0",
    "eslint-plugin-node-core": "iansu/eslint-plugin-node-core",
    "tape": "^5.2.2"
  }
}
<!-- omit in toc -->
# parseArgs

[![Coverage][coverage-image]][coverage-url]

Polyfill of `util.parseArgs()`

## `util.parseArgs([config])`

<!-- YAML
added: v18.3.0
changes:
  - version: REPLACEME
    pr-url: https://github.com/nodejs/node/pull/43459
    description: add support for returning detailed parse information
                 using `tokens` in input `config` and returned properties.
-->

> Stability: 1 - Experimental

* `config` {Object} Used to provide arguments for parsing and to configure
  the parser. `config` supports the following properties:
  * `args` {string\[]} array of argument strings. **Default:** `process.argv`
    with `execPath` and `filename` removed.
  * `options` {Object} Used to describe arguments known to the parser.
    Keys of `options` are the long names of options and values are an
    {Object} accepting the following properties:
    * `type` {string} Type of argument, which must be either `boolean` or `string`.
    * `multiple` {boolean} Whether this option can be provided multiple
      times. If `true`, all values will be collected in an array. If
      `false`, values for the option are last-wins. **Default:** `false`.
    * `short` {string} A single character alias for the option.
    * `default` {string | boolean | string\[] | boolean\[]} The default option
      value when it is not set by args. It must be of the same type as the
      the `type` property. When `multiple` is `true`, it must be an array.
  * `strict` {boolean} Should an error be thrown when unknown arguments
    are encountered, or when arguments are passed that do not match the
    `type` configured in `options`.
    **Default:** `true`.
  * `allowPositionals` {boolean} Whether this command accepts positional
    arguments.
    **Default:** `false` if `strict` is `true`, otherwise `true`.
  * `tokens` {boolean} Return the parsed tokens. This is useful for extending
    the built-in behavior, from adding additional checks through to reprocessing
    the tokens in different ways.
    **Default:** `false`.

* Returns: {Object} The parsed command line arguments:
  * `values` {Object} A mapping of parsed option names with their {string}
    or {boolean} values.
  * `positionals` {string\[]} Positional arguments.
  * `tokens` {Object\[] | undefined} See [parseArgs tokens](#parseargs-tokens)
    section. Only returned if `config` includes `tokens: true`.

Provides a higher level API for command-line argument parsing than interacting
with `process.argv` directly. Takes a specification for the expected arguments
and returns a structured object with the parsed options and positionals.

```mjs
import { parseArgs } from 'node:util';
const args = ['-f', '--bar', 'b'];
const options = {
  foo: {
    type: 'boolean',
    short: 'f'
  },
  bar: {
    type: 'string'
  }
};
const {
  values,
  positionals
} = parseArgs({ args, options });
console.log(values, positionals);
// Prints: [Object: null prototype] { foo: true, bar: 'b' } []
```

```cjs
const { parseArgs } = require('node:util');
const args = ['-f', '--bar', 'b'];
const options = {
  foo: {
    type: 'boolean',
    short: 'f'
  },
  bar: {
    type: 'string'
  }
};
const {
  values,
  positionals
} = parseArgs({ args, options });
console.log(values, positionals);
// Prints: [Object: null prototype] { foo: true, bar: 'b' } []
```

`util.parseArgs` is experimental and behavior may change. Join the
conversation in [pkgjs/parseargs][] to contribute to the design.

### `parseArgs` `tokens`

Detailed parse information is available for adding custom behaviours by
specifying `tokens: true` in the configuration.
The returned tokens have properties describing:

* all tokens
  * `kind` {string} One of 'option', 'positional', or 'option-terminator'.
  * `index` {number} Index of element in `args` containing token. So the
    source argument for a token is `args[token.index]`.
* option tokens
  * `name` {string} Long name of option.
  * `rawName` {string} How option used in args, like `-f` of `--foo`.
  * `value` {string | undefined} Option value specified in args.
    Undefined for boolean options.
  * `inlineValue` {boolean | undefined} Whether option value specified inline,
    like `--foo=bar`.
* positional tokens
  * `value` {string} The value of the positional argument in args (i.e. `args[index]`).
* option-terminator token

The returned tokens are in the order encountered in the input args. Options
that appear more than once in args produce a token for each use. Short option
groups like `-xy` expand to a token for each option. So `-xxx` produces
three tokens.

For example to use the returned tokens to add support for a negated option
like `--no-color`, the tokens can be reprocessed to change the value stored
for the negated option.

```mjs
import { parseArgs } from 'node:util';

const options = {
  'color': { type: 'boolean' },
  'no-color': { type: 'boolean' },
  'logfile': { type: 'string' },
  'no-logfile': { type: 'boolean' },
};
const { values, tokens } = parseArgs({ options, tokens: true });

// Reprocess the option tokens and overwrite the returned values.
tokens
  .filter((token) => token.kind === 'option')
  .forEach((token) => {
    if (token.name.startsWith('no-')) {
      // Store foo:false for --no-foo
      const positiveName = token.name.slice(3);
      values[positiveName] = false;
      delete values[token.name];
    } else {
      // Resave value so last one wins if both --foo and --no-foo.
      values[token.name] = token.value ?? true;
    }
  });

const color = values.color;
const logfile = values.logfile ?? 'default.log';

console.log({ logfile, color });
```

```cjs
const { parseArgs } = require('node:util');

const options = {
  'color': { type: 'boolean' },
  'no-color': { type: 'boolean' },
  'logfile': { type: 'string' },
  'no-logfile': { type: 'boolean' },
};
const { values, tokens } = parseArgs({ options, tokens: true });

// Reprocess the option tokens and overwrite the returned values.
tokens
  .filter((token) => token.kind === 'option')
  .forEach((token) => {
    if (token.name.startsWith('no-')) {
      // Store foo:false for --no-foo
      const positiveName = token.name.slice(3);
      values[positiveName] = false;
      delete values[token.name];
    } else {
      // Resave value so last one wins if both --foo and --no-foo.
      values[token.name] = token.value ?? true;
    }
  });

const color = values.color;
const logfile = values.logfile ?? 'default.log';

console.log({ logfile, color });
```

Example usage showing negated options, and when an option is used
multiple ways then last one wins.

```console
$ node negate.js
{ logfile: 'default.log', color: undefined }
$ node negate.js --no-logfile --no-color
{ logfile: false, color: false }
$ node negate.js --logfile=test.log --color
{ logfile: 'test.log', color: true }
$ node negate.js --no-logfile --logfile=test.log --color --no-color
{ logfile: 'test.log', color: false }
```

-----

<!-- omit in toc -->
## Table of Contents
- [`util.parseArgs([config])`](#utilparseargsconfig)
- [Scope](#scope)
- [Version Matchups](#version-matchups)
- [🚀 Getting Started](#-getting-started)
- [🙌 Contributing](#-contributing)
- [💡 `process.mainArgs` Proposal](#-processmainargs-proposal)
  - [Implementation:](#implementation)
- [📃 Examples](#-examples)
- [F.A.Qs](#faqs)
- [Links & Resources](#links--resources)

-----

## Scope

It is already possible to build great arg parsing modules on top of what Node.js provides; the prickly API is abstracted away by these modules. Thus, process.parseArgs() is not necessarily intended for library authors; it is intended for developers of simple CLI tools, ad-hoc scripts, deployed Node.js applications, and learning materials.

It is exceedingly difficult to provide an API which would both be friendly to these Node.js users while being extensible enough for libraries to build upon. We chose to prioritize these use cases because these are currently not well-served by Node.js' API.

----

## Version Matchups

| Node.js | @pkgjs/parseArgs |
| -- | -- |
| [v18.3.0](https://nodejs.org/docs/latest-v18.x/api/util.html#utilparseargsconfig) | [v0.9.1](https://github.com/pkgjs/parseargs/tree/v0.9.1#utilparseargsconfig) |
| [v16.17.0](https://nodejs.org/dist/latest-v16.x/docs/api/util.html#utilparseargsconfig), [v18.7.0](https://nodejs.org/docs/latest-v18.x/api/util.html#utilparseargsconfig) | [0.10.0](https://github.com/pkgjs/parseargs/tree/v0.10.0#utilparseargsconfig) |

----

## 🚀 Getting Started

1. **Install dependencies.**

   ```bash
   npm install
   ```

2. **Open the index.js file and start editing!**

3. **Test your code by calling parseArgs through our test file**

   ```bash
   npm test
   ```

----

## 🙌 Contributing

Any person who wants to contribute to the initiative is welcome! Please first read the [Contributing Guide](CONTRIBUTING.md)

Additionally, reading the [`Examples w/ Output`](#-examples-w-output) section of this document will be the best way to familiarize yourself with the target expected behavior for parseArgs() once it is fully implemented.

This package was implemented using [tape](https://www.npmjs.com/package/tape) as its test harness.

----

## 💡 `process.mainArgs` Proposal

> Note: This can be moved forward independently of the `util.parseArgs()` proposal/work.

### Implementation:

```javascript
process.mainArgs = process.argv.slice(process._exec ? 1 : 2)
```

----

## 📃 Examples

```js
const { parseArgs } = require('@pkgjs/parseargs');
```

```js
const { parseArgs } = require('@pkgjs/parseargs');
// specify the options that may be used
const options = {
  foo: { type: 'string'},
  bar: { type: 'boolean' },
};
const args = ['--foo=a', '--bar'];
const { values, positionals } = parseArgs({ args, options });
// values = { foo: 'a', bar: true }
// positionals = []
```

```js
const { parseArgs } = require('@pkgjs/parseargs');
// type:string & multiple
const options = {
  foo: {
    type: 'string',
    multiple: true,
  },
};
const args = ['--foo=a', '--foo', 'b'];
const { values, positionals } = parseArgs({ args, options });
// values = { foo: [ 'a', 'b' ] }
// positionals = []
```

```js
const { parseArgs } = require('@pkgjs/parseargs');
// shorts
const options = {
  foo: {
    short: 'f',
    type: 'boolean'
  },
};
const args = ['-f', 'b'];
const { values, positionals } = parseArgs({ args, options, allowPositionals: true });
// values = { foo: true }
// positionals = ['b']
```

```js
const { parseArgs } = require('@pkgjs/parseargs');
// unconfigured
const options = {};
const args = ['-f', '--foo=a', '--bar', 'b'];
const { values, positionals } = parseArgs({ strict: false, args, options, allowPositionals: true });
// values = { f: true, foo: 'a', bar: true }
// positionals = ['b']
```

----

## F.A.Qs

- Is `cmd --foo=bar baz` the same as `cmd baz --foo=bar`?
  - yes
- Does the parser execute a function?
  - no
- Does the parser execute one of several functions, depending on input?
  - no
- Can subcommands take options that are distinct from the main command?
  - no
- Does it output generated help when no options match?
  - no
- Does it generated short usage?  Like: `usage: ls [-ABCFGHLOPRSTUWabcdefghiklmnopqrstuwx1] [file ...]`
  - no (no usage/help at all)
- Does the user provide the long usage text?  For each option?  For the whole command?
  - no
- Do subcommands (if implemented) have their own usage output?
  - no
- Does usage print if the user runs `cmd --help`?
  - no
- Does it set `process.exitCode`?
  - no
- Does usage print to stderr or stdout?
  - N/A
- Does it check types?  (Say, specify that an option is a boolean, number, etc.)
  - no
- Can an option have more than one type?  (string or false, for example)
  - no
- Can the user define a type?  (Say, `type: path` to call `path.resolve()` on the argument.)
  - no
- Does a `--foo=0o22` mean 0, 22, 18, or "0o22"?
  - `"0o22"`
- Does it coerce types?
  - no
- Does `--no-foo` coerce to `--foo=false`?  For all options?  Only boolean options?
  - no, it sets `{values:{'no-foo': true}}`
- Is `--foo` the same as `--foo=true`?  Only for known booleans?  Only at the end?
  - no, they are not the same. There is no special handling of `true` as a value so it is just another string.
- Does it read environment variables?  Ie, is `FOO=1 cmd` the same as `cmd --foo=1`?
  - no
- Do unknown arguments raise an error?  Are they parsed?  Are they treated as positional arguments?
  - no, they are parsed, not treated as positionals
- Does `--` signal the end of options?
  - yes
- Is `--` included as a positional?
  - no
- Is `program -- foo` the same as `program foo`?
  - yes, both store `{positionals:['foo']}`
- Does the API specify whether a `--` was present/relevant?
  - no
- Is `-bar` the same as `--bar`?
  - no, `-bar` is a short option or options, with expansion logic that follows the
    [Utility Syntax Guidelines in POSIX.1-2017](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html). `-bar` expands to `-b`, `-a`, `-r`.
- Is `---foo` the same as `--foo`?
  - no
  - the first is a long option named `'-foo'`
  - the second is a long option named `'foo'`
- Is `-` a positional? ie, `bash some-test.sh | tap -`
  - yes

## Links & Resources

* [Initial Tooling Issue](https://github.com/nodejs/tooling/issues/19)
* [Initial Proposal](https://github.com/nodejs/node/pull/35015)
* [parseArgs Proposal](https://github.com/nodejs/node/pull/42675)

[coverage-image]: https://img.shields.io/nycrc/pkgjs/parseargs
[coverage-url]: https://github.com/pkgjs/parseargs/blob/main/.nycrc
[pkgjs/parseargs]: https://github.com/pkgjs/parseargs
'use strict';

const {
  ArrayPrototypeFind,
  ObjectEntries,
  ObjectPrototypeHasOwnProperty: ObjectHasOwn,
  StringPrototypeCharAt,
  StringPrototypeIncludes,
  StringPrototypeStartsWith,
} = require('./internal/primordials');

const {
  validateObject,
} = require('./internal/validators');

// These are internal utilities to make the parsing logic easier to read, and
// add lots of detail for the curious. They are in a separate file to allow
// unit testing, although that is not essential (this could be rolled into
// main file and just tested implicitly via API).
//
// These routines are for internal use, not for export to client.

/**
 * Return the named property, but only if it is an own property.
 */
function objectGetOwn(obj, prop) {
  if (ObjectHasOwn(obj, prop))
    return obj[prop];
}

/**
 * Return the named options property, but only if it is an own property.
 */
function optionsGetOwn(options, longOption, prop) {
  if (ObjectHasOwn(options, longOption))
    return objectGetOwn(options[longOption], prop);
}

/**
 * Determines if the argument may be used as an option value.
 * @example
 * isOptionValue('V') // returns true
 * isOptionValue('-v') // returns true (greedy)
 * isOptionValue('--foo') // returns true (greedy)
 * isOptionValue(undefined) // returns false
 */
function isOptionValue(value) {
  if (value == null) return false;

  // Open Group Utility Conventions are that an option-argument
  // is the argument after the option, and may start with a dash.
  return true; // greedy!
}

/**
 * Detect whether there is possible confusion and user may have omitted
 * the option argument, like `--port --verbose` when `port` of type:string.
 * In strict mode we throw errors if value is option-like.
 */
function isOptionLikeValue(value) {
  if (value == null) return false;

  return value.length > 1 && StringPrototypeCharAt(value, 0) === '-';
}

/**
 * Determines if `arg` is just a short option.
 * @example '-f'
 */
function isLoneShortOption(arg) {
  return arg.length === 2 &&
    StringPrototypeCharAt(arg, 0) === '-' &&
    StringPrototypeCharAt(arg, 1) !== '-';
}

/**
 * Determines if `arg` is a lone long option.
 * @example
 * isLoneLongOption('a') // returns false
 * isLoneLongOption('-a') // returns false
 * isLoneLongOption('--foo') // returns true
 * isLoneLongOption('--foo=bar') // returns false
 */
function isLoneLongOption(arg) {
  return arg.length > 2 &&
    StringPrototypeStartsWith(arg, '--') &&
    !StringPrototypeIncludes(arg, '=', 3);
}

/**
 * Determines if `arg` is a long option and value in the same argument.
 * @example
 * isLongOptionAndValue('--foo') // returns false
 * isLongOptionAndValue('--foo=bar') // returns true
 */
function isLongOptionAndValue(arg) {
  return arg.length > 2 &&
    StringPrototypeStartsWith(arg, '--') &&
    StringPrototypeIncludes(arg, '=', 3);
}

/**
 * Determines if `arg` is a short option group.
 *
 * See Guideline 5 of the [Open Group Utility Conventions](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html).
 *   One or more options without option-arguments, followed by at most one
 *   option that takes an option-argument, should be accepted when grouped
 *   behind one '-' delimiter.
 * @example
 * isShortOptionGroup('-a', {}) // returns false
 * isShortOptionGroup('-ab', {}) // returns true
 * // -fb is an option and a value, not a short option group
 * isShortOptionGroup('-fb', {
 *   options: { f: { type: 'string' } }
 * }) // returns false
 * isShortOptionGroup('-bf', {
 *   options: { f: { type: 'string' } }
 * }) // returns true
 * // -bfb is an edge case, return true and caller sorts it out
 * isShortOptionGroup('-bfb', {
 *   options: { f: { type: 'string' } }
 * }) // returns true
 */
function isShortOptionGroup(arg, options) {
  if (arg.length <= 2) return false;
  if (StringPrototypeCharAt(arg, 0) !== '-') return false;
  if (StringPrototypeCharAt(arg, 1) === '-') return false;

  const firstShort = StringPrototypeCharAt(arg, 1);
  const longOption = findLongOptionForShort(firstShort, options);
  return optionsGetOwn(options, longOption, 'type') !== 'string';
}

/**
 * Determine if arg is a short string option followed by its value.
 * @example
 * isShortOptionAndValue('-a', {}); // returns false
 * isShortOptionAndValue('-ab', {}); // returns false
 * isShortOptionAndValue('-fFILE', {
 *   options: { foo: { short: 'f', type: 'string' }}
 * }) // returns true
 */
function isShortOptionAndValue(arg, options) {
  validateObject(options, 'options');

  if (arg.length <= 2) return false;
  if (StringPrototypeCharAt(arg, 0) !== '-') return false;
  if (StringPrototypeCharAt(arg, 1) === '-') return false;

  const shortOption = StringPrototypeCharAt(arg, 1);
  const longOption = findLongOptionForShort(shortOption, options);
  return optionsGetOwn(options, longOption, 'type') === 'string';
}

/**
 * Find the long option associated with a short option. Looks for a configured
 * `short` and returns the short option itself if a long option is not found.
 * @example
 * findLongOptionForShort('a', {}) // returns 'a'
 * findLongOptionForShort('b', {
 *   options: { bar: { short: 'b' } }
 * }) // returns 'bar'
 */
function findLongOptionForShort(shortOption, options) {
  validateObject(options, 'options');
  const longOptionEntry = ArrayPrototypeFind(
    ObjectEntries(options),
    ({ 1: optionConfig }) => objectGetOwn(optionConfig, 'short') === shortOption
  );
  return longOptionEntry?.[0] ?? shortOption;
}

/**
 * Check if the given option includes a default value
 * and that option has not been set by the input args.
 *
 * @param {string} longOption - long option name e.g. 'foo'
 * @param {object} optionConfig - the option configuration properties
 * @param {object} values - option values returned in `values` by parseArgs
 */
function useDefaultValueOption(longOption, optionConfig, values) {
  return objectGetOwn(optionConfig, 'default') !== undefined &&
    values[longOption] === undefined;
}

module.exports = {
  findLongOptionForShort,
  isLoneLongOption,
  isLoneShortOption,
  isLongOptionAndValue,
  isOptionValue,
  isOptionLikeValue,
  isShortOptionAndValue,
  isShortOptionGroup,
  useDefaultValueOption,
  objectGetOwn,
  optionsGetOwn,
};
const { STATUS_CODES } = require('http');

module.exports = function (res, code=200, data='', headers={}) {
	res.writeHead(code, headers);
	res.end(data || STATUS_CODES[code]);
}
{
  "name": "@polka/send",
  "version": "0.4.0",
  "description": "An extremely simple response helper",
  "repository": "lukeed/polka",
  "license": "MIT",
  "files": [
    "*.js"
  ],
  "author": {
    "name": "Luke Edwards",
    "email": "luke@lukeed.com",
    "url": "https://lukeed.com"
  },
  "publishConfig": {
    "access": "public"
  }
}
# @polka/send [![npm](https://img.shields.io/npm/v/@polka/send.svg)](https://npmjs.org/package/@polka/send)

> An extremely simple HTTP Response helper &mdash; _not_ limited to [Polka][polka]!

:sparkles: For a more "magical" helper, check out [`@polka/send-type`][send-type] instead~

## Install

```
$ npm install --save @polka/send
```

## Usage

```js
const send = require('@polka/send');

module.exports = function (req, res, next) {
  if (!req.getHeader('authorization')) {
    return send(res, 401, 'Token required!');
  }
  next();
}
```

## API

### send(res, code, data, headers)

#### res
Type: `ServerReponse`

The outgoing HTTP response.

#### code
Type: `Number`<br>
Default: `200`

The `statusCode` for your response.

#### data
Type: `String`<br>
Default: `''`

The `body` for your response. Defaults to the `statusText` for the given `statusCode`.

> **Important:** You are responsible for ensure your `data` is a string! <br>For inferred `Content-Type`s and response-casting, check out [`@polka/send-type`][send-type] instead!

#### headers
Type: `Object`<br>
Default: `{}`

The `headers` for your response.


## Support

Any issues or questions can be sent to the [Polka][polka] repo, but please specify that you are using `@polka/send`.


## License

MIT © [Luke Edwards](https://lukeed.com)

[polka]: https://github.com/lukeed/polka
[send-type]: https://github.com/lukeed/polka/tree/master/packages/send-type
module.exports = function (req) {
	let url = req.url;
	if (url === void 0) return url;

	let obj = req._parsedUrl;
	if (obj && obj._raw === url) return obj;

	obj = {};
	obj.query = obj.search = null;
	obj.href = obj.path = obj.pathname = url;

	let idx = url.indexOf('?', 1);
	if (idx !== -1) {
		obj.search = url.substring(idx);
		obj.query = obj.search.substring(1);
		obj.pathname = url.substring(0, idx);
	}

	obj._raw = url;

	return (req._parsedUrl = obj);
}
{
  "name": "@polka/url",
  "version": "0.5.0",
  "description": "Super fast, memoized `req.url` parser",
  "repository": "lukeed/polka",
  "license": "MIT",
  "files": [
    "*.js"
  ],
  "author": {
    "name": "Luke Edwards",
    "email": "luke@lukeed.com",
    "url": "https://lukeed.com"
  },
  "publishConfig": {
    "access": "public"
  }
}
# @polka/url [![npm](https://badgen.now.sh/npm/v/@polka/url)](https://npmjs.org/package/@polka/url)

> Super fast, memoized `req.url` parser; _not_ limited to [Polka][polka]!

Parses the `url` from a [`IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage) request. The returned object will always only contain the following keys: `search`, `query`, `pathname`, `path`, `href`, and `_raw`.

> **Note:** This library does not process `protocol`, `hostname`, `port`, etc.<br>This is because the incoming `req.url` value only begins with the path information.

Parsed requests will be mutated with a `_parsedUrl` key, containing the returned output. This is used for future memoization, so as to avoid parsing the same `url` value multiple times.

## Install

```
$ npm install --save @polka/url
```

## Usage

```js
const parse = require('@polka/url');

let req = { url: '/foo/bar?fizz=buzz' };
let foo = parse(req);
//=> { search: '?fizz=buzz',
//=>   query: 'fizz=buzz',
//=>   pathname: '/foo/bar',
//=>   path: '/foo/bar?fizz=buzz',
//=>   href: '/foo/bar?fizz=buzz',
//=>   _raw: '/foo/bar?fizz=buzz' }

// Attaches result for future memoization
assert.deepEqual(foo, req._parsedUrl); //=> true
```

## API

### url(req)
Returns: `Object` or `undefined`

> **Important:** The `req` must have a `url` key, otherwise `undefined` will be returned.<br>If no input is provided at all, a `TypeError` will be thrown.

#### req
Type: `IncomingMessage` or `Object`

The incoming HTTP request (`req`) or a plain `Object` with a `url` key.

> **Note:** In Node.js servers, the [`req.url`](https://nodejs.org/api/http.html#http_message_url) begins with a pathname & does not include a `hash`.


## Benchmarks

> Running the `parseurl` benchmark suite on Node 10.9.0

```
Parsing: "/foo/bar?user=tj&pet=fluffy"
  nativeurl  x  3,496,593 ops/sec ±0.78% (194 runs sampled)
  parseurl   x  5,702,515 ops/sec ±0.59% (194 runs sampled)
  @polka/url x 11,510,281 ops/sec ±1.93% (192 runs sampled)

REPEAT: "/foo/bar?user=tj&pet=fluffy"
  nativeurl  x  3,344,884 ops/sec ±0.13% (191 runs sampled)
  parseurl   x 20,386,848 ops/sec ±0.22% (192 runs sampled)
  @polka/url x 21,088,923 ops/sec ±0.58% (191 runs sampled)

Parsing: "/foo/bar"
  nativeurl  x  9,808,119 ops/sec ±0.51% (190 runs sampled)
  parseurl   x 26,186,627 ops/sec ±0.16% (195 runs sampled)
  @polka/url x 43,946,765 ops/sec ±0.55% (194 runs sampled)

Parsing: "/"
  nativeurl  x 15,698,746 ops/sec ±0.79% (192 runs sampled)
  parseurl   x 36,861,339 ops/sec ±0.19% (195 runs sampled)
  @polka/url x 48,295,119 ops/sec ±0.51% (194 runs sampled)
```


## Support

Any issues or questions can be sent to the [Polka][polka] repository.<br>However, please specify that your inquiry is about `@polka/url` specifically.


## License

MIT © [Luke Edwards](https://lukeed.com)

[polka]: https://github.com/lukeed/polka
module.exports = {
  extends: [
    // If your ./custom.eslintrc.cjs has root: true, you can remove this entry
    '../../.eslintrc.js',

    // Add overrides to ./custom.eslintrc.cjs
    './custom.eslintrc.cjs',

    // These are must-have rules for any nx lib
    '../../nx-must-have.eslintrc.js',

    // Prettier config must be last
    '../../prettier.eslintrc.js',
  ],
  plugins: [],
  ignorePatterns: ['!**/*'],
  overrides: [
    {
      files: ['*.js', '*.jsx'],
      rules: {},
    },
    {
      files: ['*.json'],
      parser: 'jsonc-eslint-parser',
    },
  ],
  env: {
    jest: true,
  },
};
// If your team has any existing or specific eslint rules, you can add these here

module.exports = {
  // If you need root: true, please remove the '../../.eslintrc.js'
  // entry from ./.eslintrc.cjs
  root: false,
  plugins: ['jest'],
  extends: ['plugin:jest/recommended'],
};
export default {
  displayName: '@postman-app/app-updater',
  preset: './../../jest.preset.js',
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        // This is not preferred, but otherwise @postman/aether throws for TS files
        isolatedModules: true,
        tsconfig: '<rootDir>/tsconfig.spec.json',
      },
    ],
    '^.+\\.jsx?$': ['babel-jest', { rootMode: 'upward' }],
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  collectCoverageFrom: ['src/**/*.{js,jsx,ts,tsx}', '!**/node_modules/**'],
  coverageDirectory: '<rootDir>/../../coverage/libs/@postman-app/app-updater',
  setupFilesAfterEnv: [],
};
{
  "name": "@postman-app/app-updater",
  "description": "Simple updater module for the postman app",
  "version": "1.0.10",
  "license": "UNLICENSED",
  "main": "src/index.js",
  "exports": {
    ".": "./src/index.js"
  },
  "sideEffects": false,
  "keywords": [],
  "scripts": {
    "test-lint": "nx lint @postman-app/app-updater",
    "test-unit": "nx test @postman-app/app-updater"
  },
  "private": true,
  "repository": {
    "type": "git",
    "url": "https://github.com/postman-eng/postman-app.git"
  },
  "type": "commonjs",
  "dependencies": {
    "@postman/hermes": "1.1.4"
  }
}
{
  "name": "@postman-app/app-updater",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "projectType": "library",
  "sourceRoot": "platform-libs/app-updater/src",
  "targets": {
    "test": {
      "executor": "@nx/jest:jest",
      "options": {
        "jestConfig": "{projectRoot}/jest.config.ts",
        "passWithNoTests": true
      }
    },
    "lint": {
      "executor": "@nx/eslint:lint",
      "outputs": ["{options.outputFile}"],
      "options": {
        "eslintConfig": "{projectRoot}/.eslintrc.cjs"
      }
    }
  },
  "tags": ["type:lib", "type:platform-lib"]
}
# Postman App Updater @postman/app-updater

> This is a simple module which helps in orchestrating the `auto-updater` modules.

Right now it is orchestrating the [electron.auto-updater](https://electronjs.org/docs/api/auto-updater) module.

> The implementation of `electron.auto-updater` is explained in this
> [wiki](https://postmanlabs.atlassian.net/wiki/spaces/ENGINEERING/pages/340066360/AutoUpdate+Electron+1.8.3+Squirrel+integration)

Example:

```javascript
const AppUpdaterAdapter = {
  getCurrentVersion() {
    // eg: return '0.0.2'
  },

  getLastKnownVersion(cb) {
    // eg: cb('0.0.1')
  },

  setLastKnownVersion(version) {
    // Handle storing the version
  },

  getAutoUpdater() {
    // auto-updater to be used.
    // eg: return electron.autoUpdater;
  },
};

const Updater = new require('@postman/app-updater')(AppUpdaterAdapter);
```

## Events

### `checkingForUpdates`

Only for **`macOS`** and **`windows`**.

This will be emitted when the `auto-updater` start checking for updates

### `updateAvailable`

#### Returns

- `event` Object
- `notes` [String]
- `name` [String] (**On Windows only `name` is available.**)
- `date` [String]
- `url` [String]

This will be emitted when the `auto-updater` finds the update is available.

Happens when the updateURL returns **200** status code with update information.

### `updateDownloaded`

This will be emitted when the `auto-updater` downloaded the update.

### `updateNotAvailable`

This will be emitted when the `auto-updater` finds that there is not update available.

Happens when the updateURL returns **204** status code.

### `beforeAppQuit`

This will be emitted before the module calls the `auto-updater.quitAndInstall()` in the `restartAndUpdate` method.

### Event: 'versionUpdated'

### Returns

- `lastKnownVersion` [String]
- `currentVersion` String

This will be emitted when the `checkVersionUpdate` method finds that there is a version update happened.

## API

## For Linux

When a linux app is updated, it will start the new app with command line flags `--updated` and `--eid=$eid`.
These flags are used to cleanup the the installation directory. Old tar files, unfinished packages and old extracted packages will be deleted.

### `Updater.downloadUpdate(updateInfo)`

- `updateInfo` Object
- `updateInfo.updateServerDomain` String
- `updateInfo.platform` String
- `updateInfo.version` String
- `updateInfo.channel` String

This method will orchestrate the auto-updater to download the update if available.

## For Windows and MacOS:

When this method it called, It generates the `updateURL` using `Updater.getFeedURL(updateInfo)`

It calls `auto-updater.setFeedUrl(updateURL)` and then it calls `auto-updater.checkForUpdates()`

#### Fires

- `checkingForUpdates`
- `updateAvailable`
- `updateDownloaded`
- `updateNotAvailable`
- `error`

### `Updater.restartToUpdate()`

This method is used quit the app and initiate the restart of the app to update.

It first triggers the `quittingApp` event then calls `autoUpdater.quitAndInstall()`

#### Fires

- `quittingApp`

### `Updater.checkVersionUpdate()`

This method is used to check whether there is a version update happened, and also to store the current version.

#### Fires

- `versionUpdated`

## Contributing

### Running unit tests

Run `nx test @postman-app/app-updater` to execute the unit tests via [Jest](https://jestjs.io).

### Running linting

Run `nx lint @postman-app/app-updater` to execute the unit tests via Eslint.

Run `nx lint @postman-app/app-updater --fix` or `nx run @postman-app/app-updater:lint:fix` to run linting with autofix
const EventEmitter = require('events');

/**
 * @class AbstractUpdater
 * @extends EventEmitter
 * @description This holds the common functionalities for orchestrating the auto-updater.
 */
class AbstractUpdater extends EventEmitter {
  /**
   * @method constructor
   * @param {Object} updaterOptions
   * @param {Object} updaterOptions.adapter
   * @param {Object} updaterOptions.autoUpdater
   */
  constructor(updaterOptions) {
    super();
    this.assignUpdaterOptions(updaterOptions);
    this.attachAutoUpdaterListeners();

    // Assign constants
    this.FRESH_INSTALL = 'freshInstall';
    this.UNINSTALL = 'uninstall';
    this.OBSOLETE = 'obsolete';
  }

  /**
   * @method init
   * @description This method will be called to initialize the necessary things
   * before we decide to proceed with app start
   *
   * ===========================================================
   * = Callback will not be called if the app start is invalid.=
   * ===========================================================
   *
   * If any updater needs to stop the app start, it can be done here by not calling the callback.
   * @param {Function} cb Callback to be called with error and updateStatus
   */
  init(cb) {
    // eslint-disable-line class-methods-use-this
    cb && cb(null);
  }

  /**
   * @private
   * @method assignUpdaterOptions
   * @description This is used to assign the updaterOptions to this context.
   * @param {Object} updaterOptions The updater options.
   * @param {Object} updaterOptions.adapter Adapter that needs to be used by the updater.autoUpdater
   * @param {Object} updaterOptions.autoUpdater AutoUpdater to be used.
   */
  assignUpdaterOptions(updaterOptions = {}) {
    const { adapter, autoUpdater } = updaterOptions;

    this.adapter = adapter;
    this.logger = adapter.getLogger();

    this.context =
      typeof this.logger?.getContext === 'function'
        ? this.logger?.getContext('@postman/app-updater', 'starship')
        : { api: '@postman/app-updater', domain: 'starship' };
    this.autoUpdater = autoUpdater;
  }

  /**
   * @private
   * @method attachAutoUpdaterListeners
   * @description This is used to attach the listeners for the autoUpdater used.
   */
  attachAutoUpdaterListeners() {
    this.autoUpdater.on('update-available', this.onUpdateAvailable.bind(this));
    this.autoUpdater.on(
      'checking-for-update',
      this.onCheckingForUpdate.bind(this)
    );
    this.autoUpdater.on(
      'update-downloaded',
      this.onUpdateDownloaded.bind(this)
    );
    this.autoUpdater.on(
      'update-not-available',
      this.onUpdateNotAvailable.bind(this)
    );
    this.autoUpdater.on('error', this.onUpdateError.bind(this));
  }

  /**
   * @method onUpdateAvailable
   * @param {Object=} update
   * @fires AbstractUpdater#event:checkingForUpdates
   * @listens this.autoUpdater#event:update-available
   */
  onUpdateAvailable(update) {
    this.logger.info('@postman/app-updater: Update Available');
    this.emit('updateAvailable', update);
  }

  /**
   * @method onCheckingForUpdate
   * @param {Object=} update
   * @fires AbstractUpdater#event:checkingForUpdates
   * @listens this.autoUpdater#event:checking-for-update
   */
  onCheckingForUpdate(update) {
    this.logger.info('@postman/app-updater: Checking for update');
    this.emit('checkingForUpdates', update);
  }

  /**
   * @method onUpdateDownloaded
   * @param {Object} event
   * @param {String=} notes
   * @param {String=} name
   * @param {String=} date
   * @param {String=} url
   * @fires AbstractUpdater#event:updateDownloaded
   * @listens this.autoUpdater#event:update-downloaded
   */
  onUpdateDownloaded(event, notes, name, date, url) {
    this.logger.info(
      '@postman/app-updater: Update updateDownloaded',
      notes,
      name,
      date,
      url
    );
    this.emit('updateDownloaded', event, notes, name, date, url);
  }

  /**
   * @method onUpdateNotAvailable
   * @fires AbstractUpdater#event:updateNotAvailable
   * @listens this.autoUpdater#event:update-not-available
   */
  onUpdateNotAvailable() {
    this.logger.info('@postman/app-updater: updateNotAvailable');
    this.emit('updateNotAvailable');
  }

  /**
   * @param {Error} err
   * @param {Object=} info
   * @fires AbstractUpdater#event:error
   * @listens this.autoUpdater#event:error
   */
  onUpdateError(err, info) {
    this.logger.error('@postman/app-updater: error', err, {
      context: this.context,
      info: JSON.stringify(info),
    });
    this.emit('error', err, info);
  }

  /**
   * @method checkForVersionUpdated
   * @description This is used to send the check and send version update status to the renderer
   * If the current version is not the last known version
   * 1. Notify renderer for version update
   * 2. Sets the current version as the lastKnowVersion.
   * @fires AbstractUpdater#event:versionUpdated
   */
  checkForVersionUpdated() {
    this.adapter.getLastKnownVersion((err, lastKnownVersion) => {
      if (!err) {
        // Get the current app version
        let currentVersion = this.adapter.getCurrentVersion();

        // If the current version is not the last known version
        if (
          typeof lastKnownVersion === 'string' &&
          lastKnownVersion.length > 0 &&
          currentVersion !== lastKnownVersion
        ) {
          // Sends message through adapter
          this.logger.info(
            '@postman/app-updater: version Updated',
            lastKnownVersion,
            currentVersion
          );
          this.emit('versionUpdated', lastKnownVersion, currentVersion);
        }

        // Sets the current version as last known version
        this.adapter.setLastKnownVersion(currentVersion);
      }
    });
  }

  /**
   * @method downloadUpdate
   * @description This method is used to check and download the update for the updateInfo provided.
   * @param {Object} updateInfo
   * @param {String} updateInfo.updateServerDomain
   * @param {String} updateInfo.platform
   * @param {String} updateInfo.version
   * @param {String} updateInfo.channel
   */
  downloadUpdate(updateInfo) {
    var updateURL = this.getFeedUrl(updateInfo);
    this.autoUpdater.setFeedURL(updateURL);
    this.autoUpdater.checkForUpdates();
  }

  /**
   * @method restartAppToUpdate
   * @description This method is used to apply updates and restart the app.
   * @fires AbstractUpdater#event:quittingApp
   */
  restartAppToUpdate(canRestart) {
    this.emit('beforeAppQuit');
    if (canRestart.restart) {
      this.logger.info('@postman/app-updater: restarting app to update');
    } else {
      this.logger.info('@postman/app-updater: quitting app to update');
    }
    this.autoUpdater.quitAndInstall(canRestart);
  }

  /**
   * @method getFeedUrl
   * @param {Object} updateInfo
   * @returns {String} The updateURL to which update needs to be checked for.
   */
  getFeedUrl(updateInfo) {
    // eslint-disable-line class-methods-use-this
    var releaseServerPath = [
      'update',
      updateInfo.platform.toUpperCase(),
      updateInfo.version,
      updateInfo.channel,
    ].join('/');

    // app release endpoints for windows. arch is included in the platform (WIN32/WIN64)
    return `${updateInfo.updateServerDomain}${releaseServerPath}?${updateInfo.additionalParamsString}`;
  }
}

module.exports = AbstractUpdater;
const AbstractUpdater = require('./AbstractUpdater');

describe('AbstractUpdater', function () {
  let abstractUpdater;
  let globalUpdaterOptions = {
    autoUpdater: {
      on: jest.fn(),
    },
    adapter: {
      getLogger: function () {
        return {
          error: jest.fn(),
          info: jest.fn(),
          warn: jest.fn(),
          getContext: jest.fn().mockReturnValue({
            api: '@postman/app-updater',
            domain: 'starship',
          }),
        };
      },
      getCurrentVersion: jest.fn(),
      getLastKnownVersion: jest.fn(),
      setLastKnownVersion: jest.fn(),
    },
  };

  beforeEach(function () {
    abstractUpdater = new AbstractUpdater(globalUpdaterOptions);
  });

  describe('getFeedUrl', function () {
    it('should return a string', () => {
      const updateInfo = {
        platform: 'LINUX',
        version: '6.1.0',
        updateServerDomain: 'https://dl-beta.pstmn.io/',
        additionalParamsString: 'params',
      };
      const returnVal = abstractUpdater.getFeedUrl(updateInfo);

      expect(returnVal).toEqual(
        'https://dl-beta.pstmn.io/update/LINUX/6.1.0/?params'
      );
    });

    it('should throw error if the updateInfo is of type String', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl('updateInfo');
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo is of type Array', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl([]);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo is just spaces', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl('  ');
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo.platform is not of type string', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl({ platform: 12 });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  describe('assignUpdaterOptions', function () {
    it('should throw error if updaterOptions is null', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions(null);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should not throw an error if adapter and autoUpdater property of updaterOptions have truthy value', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions(globalUpdaterOptions);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeNull();
      }
    });

    it('should throw an error if adapter and autoUpdater does not exist as a property of updaterOptions', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({});
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if adapter is empty', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({
          adapter: '',
          autoUpdater: 'something2',
        });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if autoUpdater is empty', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({
          adapter: 'something',
          autoUpdater: '',
        });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if adapter and autoUpdater is null', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({
          adapter: null,
          autoUpdater: null,
        });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  describe('validation', function () {
    it('should handle when getContext is not a function gracefully', function () {
      const abstractUpdater = new AbstractUpdater({
        autoUpdater: {
          on: jest.fn(),
        },
        adapter: {
          getLogger: function () {
            return {
              error: jest.fn(),
              info: jest.fn(),
              warn: jest.fn(),
              getContext: 'not a function',
            };
          },
          getCurrentVersion: jest.fn(),
          getLastKnownVersion: jest.fn(),
          setLastKnownVersion: jest.fn(),
        },
      });

      expect(abstractUpdater.context).toEqual({
        api: '@postman/app-updater',
        domain: 'starship',
      });
    });
  });

  describe('downloadUpdate', function () {
    it('should throw an error if updateInfo is null', () => {
      let error = null;
      try {
        abstractUpdater.downloadUpdate(null);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if updateInfo.platform is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: 'domain',
        platform: '',
        version: '6.2.0',
        channel: 'stage',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if updateInfo.version is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: 'domain',
        platform: 'Linux',
        version: '',
        channel: 'stage',
      };
      try {
        AbstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if updateInfo.updateServerDomain is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: '',
        platform: 'Linux',
        version: '6.2.0',
        channel: 'stage',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if updateInfo.channel is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: 'domain',
        platform: 'Linux',
        version: '6.2.0',
        channel: '',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if all the properties of updateInfo is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: '',
        platform: '',
        version: '',
        channel: '',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  describe('EventEmitter', function () {
    it('should invoke event emitter', function () {
      const emitterSpy = jest.spyOn(abstractUpdater, 'emit');
      let error = null;

      try {
        abstractUpdater.onCheckingForUpdate({ appName: 'PostmanStage' });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeNull();
        expect(emitterSpy).toHaveBeenCalledTimes(1);
      }
    });
  });

  describe('onUpdateError', function () {
    let emitterStub;
    let loggerStub;

    beforeEach(function () {
      emitterStub = jest
        .spyOn(abstractUpdater, 'emit')
        .mockImplementation(() => {});
      loggerStub = jest.spyOn(abstractUpdater.logger, 'error');
    });

    afterEach(function () {
      emitterStub.mockRestore();
      loggerStub.mockRestore();
    });

    it('Should invoke error logger', function () {
      const errInstance = new Error('Error occurred while updating');

      abstractUpdater.onUpdateError(errInstance, null);

      expect(emitterStub).toHaveBeenCalledTimes(1);
      expect(emitterStub).toHaveBeenCalledWith('error', errInstance, null);
      expect(loggerStub).toHaveBeenCalledTimes(1);
      expect(loggerStub).toHaveBeenCalledWith(
        '@postman/app-updater: error',
        errInstance,
        {
          context: { api: '@postman/app-updater', domain: 'starship' },
          info: 'null',
        }
      );
    });
  });

  describe('checkForVersionUpdated', function () {
    let emitSpy;

    beforeEach(function () {
      emitSpy = jest.spyOn(abstractUpdater, 'emit');
    });

    it('should not emit version updated when lastKnownVersion is empty string', async () => {
      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(null, '')
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue('1.0.0');

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).not.toHaveBeenCalledWith('versionUpdated');
    });

    it('should not emit version updated when lastKnownVersion equals currentVersion', async () => {
      const currentVersion = '1.0.0';

      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(null, currentVersion)
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue(
        currentVersion
      );

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).not.toHaveBeenCalledWith('versionUpdated');
    });

    it('should emit version updated when versions differ', async () => {
      const lastKnownVersion = '1.0.0';
      const currentVersion = '2.0.0';

      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(null, lastKnownVersion)
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue(
        currentVersion
      );

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).toHaveBeenCalledWith(
        'versionUpdated',
        lastKnownVersion,
        currentVersion
      );
      expect(
        globalUpdaterOptions.adapter.setLastKnownVersion
      ).toHaveBeenCalledWith(currentVersion);
    });

    it('should not emit when getLastKnownVersion returns error', async () => {
      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(new Error('Failed'))
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue('1.0.0');

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).not.toHaveBeenCalledWith('versionUpdated');
      expect(
        globalUpdaterOptions.adapter.setLastKnownVersion
      ).not.toHaveBeenCalled();
    });
  });
});
const hermes = require('@postman/hermes'),
  { EventEmitter } = require('events');

/**
 * @class LinuxAutoUpdater
 * @extends EventEmitter
 * @description It orchestrate the `@postman/hermes` for the linux auto update.
 */
class LinuxAutoUpdater extends EventEmitter {
  /**
   * @method constructor
   * @param {Object} options
   * @param {Function} options.quitApp Function to quit the app
   * @param {Function} options.logger Function to push the logs from the module
   * @param {Function} options.appInstallationPath Function to get app installation path
   * @param {Function} options.appName Function to get app name
   */
  constructor(options) {
    super();
    this.quitApp = options.quitApp;
    this.logger = options.logger;
    this.updateInfo = null;
    this.originalFs = options.originalFs;

    this.cleanUp(
      {
        appInstallationPath: options.appInstallationPath,
        appName: options.appName,
      },
      (err) => {
        if (err) {
          this.logger.error(
            'LinuxAutoUpdater~Cleanup - Error in initial cleanup'
          );
        } else {
          this.logger.info(
            'LinuxAutoUpdater~Cleanup - Initial cleanup successful'
          );
        }
      }
    );
  }

  /**
   * @method downloadUpdate
   * @param {String} appName The appName for which update need to perform.
   * @param {String} downloadURL The downloadURL of the latest version app.
   * @param {String} downloadVersion The latest version to be downloaded.
   * @param {String} downloadDirectory The directory where the latest app will be downloaded
   * @fires LinuxAutoUpdater#event:update-downloaded
   * @fires LinuxAutoUpdater#event:error
   *
   * In ideal case, the flow would be.
   * In any case of failure, it emits error with the error and the info it holds.
   *   hermes.clear
   *         |
   *         |
   *   hermes.download
   *         |
   *         |
   *   hermes.extract
   *         |
   *         |
   *  this.emit('update-downloaded)
   */
  downloadUpdate(appName, downloadURL, downloadVersion, downloadDirectory) {
    this.updateInfo = hermes.init({ packageName: appName });

    // Cleanup before downloading
    this.cleanUp(
      {
        appInstallationPath: downloadDirectory,
        appName: appName,
      },
      (err) => {
        if (err) {
          this.logger.error(
            'LinuxAutoUpdater~Cleanup - Error in cleanup before download'
          );
        }

        // Download & Extract
        let inputDownloadData = Object.assign({}, this.updateInfo, {
          downloadURL,
          downloadDirectory,
        });

        hermes.download(inputDownloadData, (err, downloadInfo) => {
          this.updateInfo = downloadInfo;
          if (err) {
            this.emit('error', err, downloadInfo); // downloadInfo will hold the error info as well
            return;
          }

          let event = {},
            notes = '',
            date = '';

          hermes.extract(downloadInfo, (extractError, extractInfo) => {
            this.updateInfo = extractInfo;
            if (extractError) {
              this.emit('error', extractError, extractInfo); // ExtractInfo will have the error info as well.
              return;
            }

            // Adding logs to capture the standard output of child process created inside hermes
            this.logger.info(
              'LinuxAutoUpdater~Extraction completed',
              extractInfo
            );

            // Reaching here means, the file is downloaded and extracted
            // For consistency with windows and mac, we are emitting this event at the end.

            // appName = 'Postman'
            // downloadVersion ='x.y.z'
            // releaseName = 'Postman x.y.z'
            const releaseName = appName + ' ' + downloadVersion;
            this.emit(
              'update-downloaded',
              event,
              notes,
              releaseName,
              date,
              downloadURL
            );
          });
        });
      }
    );
  }

  /**
   * @method cleanUp
   * @description Calls the hermes to clear the older downloads and files
   **/
  cleanUp(options, cb) {
    // eslint-disable-line class-methods-use-this

    // eslint-disable-next-line no-unreachable
    if (!options || !options.appInstallationPath || !options.appName) {
      this.logger.info(
        'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        options
      );
      // eslint-disable-next-line no-useless-return
      return cb(
        new Error('LinuxAutoUpdater~cleanUp: Missing parameters, bailing out')
      );
    }

    let clearInputData = {
      appName: options.appName,
      directory: options.appInstallationPath,
      fileSystemModule: this.originalFs,
    };

    hermes.clear(clearInputData, (err) => {
      if (err) {
        this.logger.error(
          'LinuxAutoUpdater~cleanUp - Error in cleanup old downloads',
          err
        );
      }
      cb(err);
    });
  }

  /**
   * @method quitAndInstall
   * @param {Object} canRestart
   * @fires LinuxAutoUpdater#event:error
   *
   * It calls the `hermes.swap` module with the updateInfo & canRestart flag it holds and quits the app.
   * Incase of any error before quitting the app, it emits the `error` and won't quit the app.
   */
  quitAndInstall(canRestart) {
    this.logger.info('LinuxAutoUpdater~quitAndInstall - Initiated');
    hermes.swap(
      Object.assign({}, this.updateInfo, canRestart),
      (err, extractInfo) => {
        if (err) {
          this.emit('error', extractInfo);
          return;
        }
        this.logger.info(
          'LinuxAutoUpdater~quitAndInstall - Quitting for update'
        );
      }
    );
  }
}

module.exports = LinuxAutoUpdater;
const hermes = require('@postman/hermes');

const LinuxAutoUpdater = require('./LinuxAutoUpdater');

describe('LinuxAutoUpdater', function () {
  let linuxAutoUpdater;
  const options = {
    quitApp: jest.fn(),
    logger: {
      error: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
    },
    appInstallationPath: '/home/postman/Downloads/postman-app',
    appName: 'postman',
    originalFs: require('fs'),
  };

  describe('downloadUpdate', function () {
    beforeEach(function () {
      linuxAutoUpdater = new LinuxAutoUpdater(options);
    });

    it('should throw an error if the updateInfo.appName is empty', () => {
      let err = null,
        appName = '',
        downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
        downloadDirectory = '/home/postman/Downloads/postman-app/';

      try {
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      } catch (e) {
        err = e;
      } finally {
        expect(err).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if the updateInfo.appName is not of type string', () => {
      let err = null,
        appName = 1,
        downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
        downloadDirectory = '/home/postman/Downloads/postman-app/';

      try {
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      } catch (e) {
        err = e;
      } finally {
        expect(err).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if the updateInfo.downloadURL is empty', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL = '';
        const downloadDirectory = '/home/postman/Downloads/postman-app/';
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });

    it('should throw an error if the updateInfo.downloadURL is not of type string', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL = 8675;
        const downloadDirectory = '/home/postman/Downloads/postman-app/';
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });

    it('should throw an error if the updateInfo.downloadDirectory is empty', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64';
        const downloadDirectory = '';
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });

    it('should throw an error if the updateInfo.downloadDirectory is not of type string', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64';
        const downloadDirectory = 1;
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });
  });

  describe('cleanUp', function () {
    let loggerSpy, hermesClearSpy;

    beforeEach(function () {
      linuxAutoUpdater = new LinuxAutoUpdater(options);
      loggerSpy = jest.spyOn(options.logger, 'info');
      hermesClearSpy = jest.spyOn(hermes, 'clear');
    });

    afterEach(function () {
      loggerSpy.mockRestore();
      hermesClearSpy.mockRestore();
    });

    it('should throw an error if options(argument) is empty', async () => {
      let options = {},
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options have falsy values', async () => {
      let options = false,
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appInstallationPath is empty', async () => {
      let options = {
          appName: 'Postman',
          appInstallationPath: '',
        },
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appInstallationPath is not a string', async () => {
      let options = {
          appName: 'Postman',
          appInstallationPath: 123,
        },
        expectedError =
          'InvalidArgumentException: Hermes~clear - clearInputData.directory should be of type string', // eslint-disable-line max-len
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(hermesClearSpy).toHaveBeenCalledTimes(1);
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appName is empty', async () => {
      let options = {
          appName: '',
          appInstallationPath: '/home/postman/Downloads/postman-app/',
        },
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appName is not a string', async () => {
      let options = {
          appName: 123,
          appInstallationPath: '/home/postman/Downloads/postman-app/',
        },
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err).toBeInstanceOf(Error);
              expect(hermesClearSpy).toHaveBeenCalledTimes(1);
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });
  });

  describe('quitAndInstall', function () {
    let quitAppSpy, hermesSwapSpy;

    beforeEach(function () {
      linuxAutoUpdater = new LinuxAutoUpdater(options);
      quitAppSpy = jest.spyOn(options, 'quitApp');
      hermesSwapSpy = jest.spyOn(hermes, 'swap');
    });

    afterEach(function () {
      quitAppSpy.mockRestore();
      hermesSwapSpy.mockRestore();
    });

    it('should throw an error if updateInfo is empty', () => {
      let err = null,
        updateInfo = {};

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo is not an object', () => {
      let err = null,
        updateInfo = 'foo';

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo.eId is empty', () => {
      let err = null,
        updateInfo = {
          eID: '',
          packageName: 'somePackage',
          downloadURL: 'http://sample.com/foo.tar.gz',
          downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
          downloadChecksumAlgorithm: 'sha1',
          downloadInfo: {
            status: 'DOWNLOAD_COMPLETED',
            error: null,
            downloadDirectory: 'User/PathForDownloadDirectory',
          },
          extractInfo: {
            status: 'EXTRACTION_SUCCESSFUL',
            error: null,
            extractDirectory: 'User/PathForExtractDirectory',
          },
        };

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo.packageName is empty', () => {
      let err = null,
        updateInfo = {
          eID: 'somePackage-xxxxxxxxxxxxx',
          packageName: '',
          downloadURL: 'http://sample.com/foo.tar.gz',
          downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
          downloadChecksumAlgorithm: 'sha1',
          downloadInfo: {
            status: 'DOWNLOAD_COMPLETED',
            error: null,
            downloadDirectory: 'User/PathForDownloadDirectory',
          },
          extractInfo: {
            status: 'EXTRACTION_SUCCESSFUL',
            error: null,
            extractDirectory: 'User/PathForExtractDirectory',
          },
        };

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo.extractInfo is empty', () => {
      let err = null,
        updateInfo = {
          eID: 'somePackage-xxxxxxxxxxxxx',
          packageName: 'somePackage',
          downloadURL: 'http://sample.com/foo.tar.gz',
          downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
          downloadChecksumAlgorithm: 'sha1',
          downloadInfo: {
            status: 'DOWNLOAD_COMPLETED',
            error: null,
            downloadDirectory: 'User/PathForDownloadDirectory',
          },
          extractInfo: {},
        };

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });
  });
});
const AbstractUpdater = require('./AbstractUpdater');

class DarwinUpdater extends AbstractUpdater {
  constructor(updaterOptions) {
    super(updaterOptions);
  }

  /**
   * @method getFeedUrl
   * @param {Object} updateInfo
   */
  getFeedUrl(updateInfo) {
    // eslint-disable-line class-methods-use-this
    var argsArray = [
      `currentVersion=${updateInfo.version}`,
      `platform=${updateInfo.platform.toLowerCase()}`,
      `channel=${updateInfo.channel}`,
      `arch=${updateInfo.arch}`,
      updateInfo.additionalParamsString,
    ];
    return `${updateInfo.updateServerDomain}update/status?${argsArray.join(
      '&'
    )}`;
  }
}

module.exports = DarwinUpdater;
const DarwinUpdater = require('./DarwinUpdater');

describe('darwinUpdater', function () {
  let darwinUpdater;
  const updaterOptions = {
    autoUpdater: {
      on: jest.fn(),
    },
    adapter: {
      getLogger: function () {
        return {
          error: jest.fn(),
          info: jest.fn(),
          warn: jest.fn(),
          getContext: jest.fn().mockReturnValue({
            api: '@postman/app-updater',
            domain: 'starship',
          }),
        };
      },
    },
  };

  beforeAll(function () {
    darwinUpdater = new DarwinUpdater(updaterOptions);
  });

  describe('getFeedUrl', function () {
    it('should return a string for 64 bit', () => {
      const updateInfo = {
        platform: 'OSX',
        arch: '64',
        version: '6.1.0',
        updateServerDomain: 'https://dl-beta.pstmn.io/',
        channel: 'stable',
        additionalParamsString: 'params',
      };
      const returnVal = darwinUpdater.getFeedUrl(updateInfo);

      expect(returnVal).toEqual(
        'https://dl-beta.pstmn.io/update/status?currentVersion=6.1.0&platform=osx&channel=stable&arch=64&params'
      );
    });

    it('should return a string for arm64 bit', () => {
      const updateInfo = {
        platform: 'OSX',
        arch: 'arm64',
        version: '6.1.0',
        updateServerDomain: 'https://dl-beta.pstmn.io/',
        channel: 'stable',
        additionalParamsString: 'params',
      };
      const returnVal = darwinUpdater.getFeedUrl(updateInfo);

      expect(returnVal).toEqual(
        'https://dl-beta.pstmn.io/update/status?currentVersion=6.1.0&platform=osx&channel=stable&arch=arm64&params'
      );
    });

    it('should throw error if the updateInfo is of type String', () => {
      let error = null;
      try {
        darwinUpdater.getFeedUrl('updateInfo');
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo is of type Array', () => {
      let error = null;
      try {
        darwinUpdater.getFeedUrl([]);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo is whitespace', () => {
      let error = null;
      try {
        darwinUpdater.getFeedUrl(' ');
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo.platform is not of type string', () => {
      let error = null;
      try {
        darwinUpdater.getFeedUrl({ platform: 12 });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });
});
const WINDOWS = 'Windows_NT';
const DARWIN = 'Darwin';
const LINUX = 'Linux';

/**
 * @method initializeUpdater
 * @description Provides the updater class Instance based on the OS.
 * It uses Node.os.type() to detect the os.
 * https://nodejs.org/dist/latest-v8.x/docs/api/os.html#os_os_type
 *
 * @returns {?Object} WindowsAutoUpdate || DarwinUpdater || LinuxUpdater || null
 */
function init(options = {}) {
  const { adapter } = options;
  const os = require('os').type();
  const updaterOptions = { adapter, autoUpdater: adapter.getAutoUpdater() };

  switch (os) {
    case WINDOWS: {
      const WindowsUpdater = require('./WindowsUpdater');
      return new WindowsUpdater(updaterOptions);
    }
    case DARWIN: {
      const DarwinUpdater = require('./DarwinUpdater');
      return new DarwinUpdater(updaterOptions);
    }
    case LINUX: {
      const LinuxUpdater = require('./LinuxUpdater');
      const LinuxAutoUpdater = require('./autoUpdater/LinuxAutoUpdater');
      return new LinuxUpdater(
        Object.assign(updaterOptions, {
          autoUpdater: new LinuxAutoUpdater({
            quitApp: adapter.quitApp,
            logger: adapter.getLogger(),
            appInstallationPath: adapter.getAppInstallationPath(),
            appName: adapter.getAppName(),
            originalFs: adapter.getOriginalFs(),
          }),
        })
      );
    }
    default:
      return null;
  }
}

module.exports = { init };
import { init } from './index.js';

describe('AppUpdater', () => {
  it('should work', () => {
    expect(typeof init).toBe('function');
  });
});
const AbstractUpdater = require('./AbstractUpdater');

/**
 * @class LinuxUpdater
 * @extends AbstractUpdater
 *
 * It overrides the methods specific for linux updater.
 */
class LinuxUpdater extends AbstractUpdater {
  constructor(updaterOptions) {
    super(updaterOptions);
  }

  downloadUpdate(updateInfo) {
    this.logger.info(
      'LinuxUpdater~downloadUpdate - UpdateInfo received',
      updateInfo
    );
    this.autoUpdater.downloadUpdate(
      this.adapter.getAppName(),
      updateInfo.downloadURL,
      updateInfo.downloadVersion,
      this.adapter.getAppInstallationPath()
    );
  }
}

module.exports = LinuxUpdater;
const LinuxUpdater = require('./LinuxUpdater');

describe('linuxUpdater', function () {
  let linuxUpdater,
    updaterOptions = {
      adapter: {
        getAppName: jest.fn(),
        getAppInstallationPath: jest.fn(),
        getAutoUpdater: jest.fn(),
        getLogger: function () {
          return {
            error: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            getContext: jest.fn().mockReturnValue({
              api: '@postman/app-updater',
              domain: 'starship',
            }),
          };
        },
        getOriginalFs: require('fs'),
      },
      autoUpdater: {
        on: jest.fn(),
        downloadUpdate: jest.fn(),
      },
    };

  beforeAll(function () {
    linuxUpdater = new LinuxUpdater(updaterOptions);
  });

  describe('downloadUpdate', function () {
    it('should have updateInfo as an argument', () => {
      let error = null,
        updateInfo = {
          additionalParamsString: 'installationId',
          appId: '7d7c3dea-961e-4b19-b5d7-2106d03a152e',
          arch: '64',
          channel: 'beta',
          downloadURL: 'https://dl.pstmn.io/download/version/6.7.0/osx_64',
          platform: 'OSX',
          updateServerDomain: 'https://dl.pstmn.io/',
          userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2)',
          userId: '0',
          version: '6.7.0',
        };

      try {
        linuxUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeNull();
      }
    });
  });
});
const fs = require('fs'),
  path = require('path'),
  child_process = require('child_process'), // eslint-disable-line security/detect-child-process
  AbstractUpdater = require('./AbstractUpdater'),
  SHORTCUT_EXTENSION = '.lnk', // https://en.wikipedia.org/wiki/Shortcut_(computing)#Implementations
  // https://github.com/Squirrel/Squirrel.Windows/blob/8877944cf21a58c18341d6640bed2014582d1380/src/Squirrel/IUpdateManager.cs#L16
  SQUIRREL_DESKTOP_ENUM = 'Desktop',
  SQUIRREL_START_MENU_ENUM = 'StartMenu';

class WindowsUpdater extends AbstractUpdater {
  constructor(updaterOptions = {}) {
    super(updaterOptions);

    this.on('versionUpdated', this.createOrUpdateShortcuts.bind(this));
  }

  /**
   * @method init
   * @description This method will be called to initialize the necessary things.
   *
   * ===========================================================
   * = Callback will not be called if the app start is invalid.=
   * ===========================================================
   *
   * The callback will not be called when it decides that the app start is not valid
   * Callback will not be called if the windows app is called with following params.
   * - squirrel-install - It calls the updater.exe to create shortcut in (Desktop & StartMenu) and launch the app
   * - squirrel-updated - It calls the updater.exe to create shortcut in Desktop(If already exists) and StartMenu
   * - squirrel-uninstall - It deletes the shortcuts created
   * - squirrel-obsolete - It just quits the app, as it the invalid version
   *
   * @param {Function} cb Callback to be called with error and updateStatus
   */
  init(cb) {
    // If it is windows, go for it, or else bail out and call the callback.
    if (process.platform !== 'win32') {
      cb && cb(null);
      return;
    }

    let cmd = process.argv[1],
      target = path.basename(process.execPath),
      quitApp = this.adapter.quitApp;

    // Create a shortcut on fresh installation
    if (cmd === '--squirrel-install') {
      this.run([String('--createShortcut=' + target)], quitApp);
      return;
    }

    // Delete the shortcut on un-installation
    if (cmd === '--squirrel-uninstall') {
      this.run([String('--removeShortcut=' + target)], quitApp);
      return;
    }

    // This is called when the out-of-date app is no longer the newest version
    // At this point we should just quit this app
    if (cmd === '--squirrel-obsolete') {
      quitApp();
      return;
    }
    cb && cb(null);
  }

  /**
   * Spawns Update.exe in detached mode with the provided arguments
   *
   * @param {Array<String>} args
   * @param {Function} [done]
   */
  run(args, done = () => {}) {
    // eslint-disable-line class-methods-use-this
    var updateExe = path.resolve(
      path.dirname(process.execPath),
      '..',
      'Update.exe'
    );
    child_process.spawn(updateExe, args, { detached: true }).on('close', done);
  }

  /**
   * 1. Moves the stub file to one level up
   * 2. Updates the desktop and start menu shortcuts
   */
  createOrUpdateShortcuts() {
    let errPrefix = 'WindowsUpdater~createOrUpdateShortcuts',
      desktopPath = this.adapter.getDesktopPath(),
      appName = this.adapter.getAppName(),
      desktopShortcut = path.resolve(
        desktopPath,
        `${appName}${SHORTCUT_EXTENSION}`
      ),
      latestVersionDir = path.dirname(process.execPath),
      targetExe = path.basename(process.execPath),
      latestStubExe = path.resolve(
        latestVersionDir,
        `${appName}_ExecutionStub.exe`
      ),
      rootStubExe = path.resolve(latestVersionDir, '..', `${appName}.exe`),
      shortcutLocations = [SQUIRREL_START_MENU_ENUM]; // Always update in startMenu for now.

    /**
     * With squirrel 1.5.0, [a change](https://github.com/Squirrel/Squirrel.Windows/pull/868) was made where a
     * stub executable was added at one level above the version specific folder.
     * But, this stub is added when we do a fresh install or when the app using
     * the latest version (>=1.5.0) of squirrel is updated. This is not added when an app using
     * the old version (<1.5.0) of squirrel updates to an app using the later version of squirrel (>=1.5.0)
     * So for users, who are upgrading from <= v7.3.x Postman to >= v7.3.x Postman,
     * the stub exe won't be created/moved automatically.
     * This stub file is used to reference the icon in the shortcuts.
     * Without this, [the Postman icon breaks]([https://github.com/postmanlabs/postman-app-support/issues/6897])
     * So, for those users we are manually moving the stub exe to one level up.
     * This workaround was suggested by a squirrel contributor
     * [here:](https://github.com/Squirrel/Squirrel.Windows/issues/1075#issuecomment-311488107)
     * -> If a stub exe is present in the latest app folder, move it to one level up while renaming it
     */
    try {
      if (fs.existsSync(latestStubExe)) {
        fs.renameSync(latestStubExe, rootStubExe);
      }
    } catch (caughtErr) {
      let err = new Error(
        `${errPrefix}: Could not move the stub exe to parent level`
      );
      this.emit('warning', err, { error_message: caughtErr.message });
    }

    /**
     * Update the desktop shortcut only if it is available.
     * Reason is user might deleted the shortcut after install and adding them again on update is wrong.
     * We use the --shortcut-locations options to provide the places needs to be updated.
     * - startMenu [As for now we are always updating / creating]
     * - desktop [Only updating, we won't create on app update]
     */
    try {
      if (fs.existsSync(desktopShortcut)) {
        shortcutLocations.push(SQUIRREL_DESKTOP_ENUM);
      }
    } catch (caughtErr) {
      let err = new Error(
        `${errPrefix}: Error while checking for existence of desktop file`
      );
      this.emit('warning', err, { error_message: caughtErr.message });
    }

    // create/update the shortcuts
    // This is not same as handling the case when the new app starts with --squirrel-updated flag, where it should
    // quit immediately afterwards
    // This function is run after the new app opens, and it should not quit
    this.run([
      `--createShortcut=${targetExe}`,
      `--shortcut-locations=${shortcutLocations.join(',')}`,
    ]);
  }
}

module.exports = WindowsUpdater;
const child_process = require('child_process');

const WindowsUpdater = require('./WindowsUpdater');

describe('WindowsUpdater', function () {
  let updaterOptions = {
    autoUpdater: {
      on: jest.fn(),
    },
    adapter: {
      getLogger: function () {
        return {
          error: jest.fn(),
          info: jest.fn(),
          warn: jest.fn(),
          getContext: jest.fn().mockReturnValue({
            api: '@postman/app-updater',
            domain: 'starship',
          }),
        };
      },
      quitApp: jest.fn(),
    },
  };

  describe('run', function () {
    it('should throw error if args is not a Array<string>', () => {
      let args = 123,
        windowsUpdater = new WindowsUpdater(updaterOptions),
        spawnSpy = jest.spyOn(child_process, 'spawn'),
        done = updaterOptions.adapter.quitApp;

      let error = null;
      try {
        windowsUpdater.run(args, done);
      } catch (e) {
        error = e;
      } finally {
        expect(error.name).toEqual('TypeError');
        expect(spawnSpy).toHaveBeenCalledTimes(1);
      }
    });
  });
});
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {},
  "files": [],
  "include": [],
  "types": ["node", "jest", "@testing-library/jest-dom"],
  "references": [
    {
      "path": "./tsconfig.lib.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../build/@postman-app/app-updater",
    "tsBuildInfoFile": "../../build/@postman-app/app-updater/tsconfig.lib.tsbuildinfo",
    "declaration": true,
    "noEmit": false,
    "emitDeclarationOnly": true,
    "composite": true,
    "types": ["node"],
    "module": "esnext"
  },
  "// NOTE_1:": "if this package imports any other TS projects, add those here",
  "// NOTE_2:": "example: \"references\": [{ \"path\": \"../path_to_other_dir\" }] ",
  "references": [],
  "files": ["../../global.d.ts", "../../types/globals/flows/global.d.ts"],
  "exclude": [
    "jest.config.ts",
    "**/*.spec.ts",
    "**/*.test.ts",
    "**/*.spec.tsx",
    "**/*.test.tsx",
    "**/*.spec.js",
    "**/*.test.js",
    "**/*.spec.jsx",
    "**/*.test.jsx",
    "**/__tests__/*",
    "**/__tests__/**/*"
  ],
  "include": ["src/**/*.js", "src/**/*.jsx", "src/**/*.ts", "src/**/*.tsx"]
}
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../build/@postman-app/app-updater",
    "tsBuildInfoFile": "../../build/@postman-app/app-updater/tsconfig.spec.tsbuildinfo",
    "module": "ES2015",
    "composite": true,
    "noEmit": false,
    "emitDeclarationOnly": true,
    "types": ["jest", "node"]
  },
  "include": [
    "jest.config.ts",
    "**/*.test.ts",
    "**/*.spec.ts",
    "**/*.test.tsx",
    "**/*.spec.tsx",
    "**/*.test.js",
    "**/*.spec.js",
    "**/*.test.jsx",
    "**/*.spec.jsx",
    "**/__tests__/**/*.ts",
    "**/*.d.ts",
    "../../global.d.ts",
    "../../types/globals/flows/global.d.ts"
  ]
}
# App Logger Changelog

#### v2.1.0 (Aug 23, 2022)
* [SFDTN-2521] Added sentry tags for availability specific error reporting.

#### v2.0.0 (May 30, 2022)
* [SFDTN-2373] Updated Sentry Transport to identify crashes and report source errors.

#### v1.0.5 (Mar 16, 2022)
* [SFDTN-2280] Added support for NewRelic as a log collector

#### v1.0.3 (August 06, 2020)
* [CFDTN-83] Added add setLogLevel api for originator

#### v1.0.2 (March 15, 2019)
* Added add collector api for originatormodule.exports = require('./lib/');
const { expect } = require('chai'),
    AbstractCollector = require('../AbstractCollector');

describe('AbstractCollector', () => {
    it('should create collector instance with a transporter', () => {
        let collector = new AbstractCollector();

        expect(collector.transports).to.be.an('array');
        expect(collector.transports.length).to.be.equal(1);
    });

    it('should through error if the options are of type string', () => {

        // eslint-disable-next-line no-new,max-len
        expect(() => { new AbstractCollector('options'); }).to.throw('InvalidParamsException: options should be of type object if provided');
    });

    it('should through error if the options.transport are of type string', () => {

        // eslint-disable-next-line no-new,max-len
        expect(() => { new AbstractCollector({ transports: 'transports' }); }).to.throw('InvalidParamsException: options.transports should be of type array if provided');
    });

    it('should call the log function of the transport provided when log method is called', () => {
        let level = 'info',
            inputData = 'message',
            outputData = null,
            expectedData = { level, data: inputData },
            Collector = new AbstractCollector({
                transports: [{ log: (level, data) => { outputData = { level, data }; } }]
            });

        Collector.log(level, inputData);

        expect(outputData).to.be.eql(expectedData);
    });
});
/**
 * @class AbstractCollector
 * @description It holds the overall instance of a collector
 * @throws InvalidParamsException
 */
class AbstractCollector {
    /**
     * @method constructor
     * @param {Object} options
     * @param {Array=[]} options.transports
     */
    constructor (options = {}) {
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new Error('InvalidParamsException: options should be of type object if provided');
        }

        if (options.transports && !Array.isArray(options.transports)) {
            throw new Error('InvalidParamsException: options.transports should be of type array if provided');
        }
        this.transports = options.transports || [console];
    }

    /**
     * @method log
     * @description It wraps logger module and pass the message to it.
     * It,
     * - Pass the message as object { message: sanitizedInput }
     * @param {[String]} level
     * @param {*} message
     */
    log (level, message) {
        this.transports.forEach((transport) => {
            transport.log(level, message);
        });
    }

    /**
     * @description Switches the log level of Collector
     * Useful when debugging internally or externally
     * Need to be overriden as per the Collector requirement
     * @param {String} level should be among the valid log levels
     */
    // eslint-disable-next-line class-methods-use-this, no-unused-vars, no-empty-function
    setLogLevel (level) { }

}

module.exports = AbstractCollector;
module.exports = {
    Console: require('./winston/WinstonCollector'),
    File: require('./winston/FileCollector'),
    NewRelic: require('./winston/NewRelicCollector'),
    Sentry: require('./winston/SentryCollector')
};
const path = require('path'),
    fs = require('fs'),
    { expect } = require('chai'),
    AbstractCollector = require('../../AbstractCollector'),
    FileCollector = require('../FileCollector'),
    LOG_FILE_DIR = path.resolve(__dirname, '..', '..', '..', '..', 'test_logs'),
    LOG_FILE = path.resolve(LOG_FILE_DIR, 'winston.log'),
    resetLogFile = (done) => {
        setTimeout(() => {
            try {
                if (!fs.existsSync(LOG_FILE_DIR)) {
                    fs.mkdirSync(LOG_FILE_DIR);
                }

                fs.unlinkSync(LOG_FILE + 1);
                fs.unlinkSync(LOG_FILE + 2);
            }
            catch (e) {
                // Don't fail test case if unlink fails
            }
            finally {
                done();
            }
        }, 1000);
    };

describe('Winston/FileCollector', function () {
    before((done) => {
        resetLogFile(done);
    });

    afterEach((done) => {
        resetLogFile(done);
    });

    it('should throw error if the file option is not provided', () => {
        // eslint-disable-next-line no-new, max-len
        expect(() => { new FileCollector(); }).to.throw('InvalidParamsException: options.file should be a valid non empty string');
    });

    it('should throw error if the file option is empty', () => {
        // eslint-disable-next-line no-new, max-len
        expect(() => { new FileCollector({ file: '' }); }).to.throw('InvalidParamsException: options.file should be a valid non empty string');
    });

    it('should throw error if the file option is not of type string', () => {
        // eslint-disable-next-line no-new, max-len
        expect(() => { new FileCollector({ file: ['file'] }); }).to.throw('InvalidParamsException: options.file should be a valid non empty string');
    });

    it('should create Collector instance with winston file transport', () => {
        let fileCollector = new FileCollector({ file: LOG_FILE + 1 });
        expect(fileCollector.transports).to.be.an('array');
        expect(fileCollector.transports).to.not.be.empty;
    });

    it('should create Collector instance of type Abstract Collector', () => {
        let fileCollector = new FileCollector({ file: LOG_FILE + 2 });
        expect(fileCollector instanceof AbstractCollector).to.be.true;
    });
});
const { expect } = require('chai'),
    sinon = require('sinon'),
    _ = require('lodash'),
    AbstractCollector = require('../../AbstractCollector'),
    NewRelicCollector = require('../NewRelicCollector'),
    { ERROR, INFO } = require('../../../constants/level'),
    dummyNewrelic = {
        recordCustomEvent: _.noop,
        setMetadata: _.noop
    };

describe('Winston/NewRelicCollector', () => {
    let sandbox = null;

    before(() => {
        sandbox = sinon.sandbox.create();
    });

    afterEach(() => {
        sandbox.restore();
    });

    it('should create Collector instance with level as error', () => {
        let newrelicCollector = new NewRelicCollector({ newrelic: dummyNewrelic });
        expect(newrelicCollector.transports).to.be.an('array');
        expect(newrelicCollector.transports).to.not.be.empty;
        expect(newrelicCollector.transports[0].level).to.be.eql(ERROR);
    });

    it('should create Collector instance of type Abstract Collector', () => {
        let newrelicCollector = new NewRelicCollector({ newrelic: dummyNewrelic });
        expect(newrelicCollector instanceof AbstractCollector).to.be.true;
    });

    it('should call the newrelic.recordCustomEvent', () => {
        let NewRelicCollectorInstance = new NewRelicCollector({ newrelic: dummyNewrelic }),
            spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent');
        NewRelicCollectorInstance.log(ERROR, {
            messages: ['error', { context: { api: 'echo', domain: 'echo' } }]
        });
        expect(spy.callCount).to.equal(1);
    });

    it('should not call the newrelic.recordCustomEvent when it is not error level', () => {
        let NewRelicCollectorInstance = new NewRelicCollector({ newrelic: dummyNewrelic }),
            spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent');
        NewRelicCollectorInstance.log(INFO, {
            messages: ['info', { context: { api: 'echo', domain: 'echo' } }]
        });
        expect(spy.callCount).to.equal(0);
    });

    it('should not call the newrelic.recordCustomEvent when context data is not passed', () => {
        let NewRelicCollectorInstance = new NewRelicCollector({ newrelic: dummyNewrelic }),
            spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent');
        NewRelicCollectorInstance.log(ERROR, {
            messages: ['error']
        });
        expect(spy.callCount).to.equal(0);
    });
});
const { expect } = require('chai'),
    sinon = require('sinon'),
    _ = require('lodash'),
    AbstractCollector = require('../../AbstractCollector'),
    SentryCollector = require('../SentryCollector'),
    { ERROR, INFO } = require('../../../constants/level'),
    dummySentry = {
        withScope: (cb) => {
            scope = {
                setExtra: dummySentry.setExtra
            };
            cb(scope);
        },
        captureException: _.noop,
        setExtra: _.noop
    };

describe('Winston/SentryCollector', () => {
    let sandbox = null;

    before(() => {
        sandbox = sinon.sandbox.create();
    });

    afterEach(() => {
        sandbox.restore();
    });

    it('should create Collector instance with level as error', () => {
        let sentryCollector = new SentryCollector({ sentry: dummySentry });
        expect(sentryCollector.transports).to.be.an('array');
        expect(sentryCollector.transports).to.not.be.empty;
        expect(sentryCollector.transports[0].level).to.be.eql(ERROR);
    });

    it('should create Collector instance of type Abstract Collector', () => {
        let sentryCollector = new SentryCollector({ sentry: dummySentry });
        expect(sentryCollector instanceof AbstractCollector).to.be.true;
    });

    it('should call the sentry.captureException', () => {
        let SentryCollectorInstance = new SentryCollector({ sentry: dummySentry }),
            spy = sandbox.spy(dummySentry, 'captureException');
        SentryCollectorInstance.log(ERROR, {
            messages: ['error', { crash: true }]
        });
        expect(spy.callCount).to.equal(1);
    });


    it('should not call the sentry.captureException when it is not error level', () => {
        let SentryCollectorInstance = new SentryCollector({ sentry: dummySentry }),
            spy = sandbox.spy(dummySentry, 'captureException');
        SentryCollectorInstance.log(INFO, {
            messages: ['info']
        });
        expect(spy.callCount).to.equal(0);
    });

});
const { expect } = require('chai'),
    AbstractCollector = require('../../AbstractCollector'),
    WinstonCollector = require('../WinstonCollector');

describe('Winston/Collector', () => {

    it('should create Collector instance with winston console transport', () => {
        let consoleCollector = new WinstonCollector();
        expect(consoleCollector.transports).to.be.an('array');
        expect(consoleCollector.transports).to.not.be.empty;
    });

    it('should create Collector instance of type Abstract Collector', () => {
        let consoleCollector = new WinstonCollector();
        expect(consoleCollector instanceof AbstractCollector).to.be.true;
    });
});
const winston = require('winston'),
    WinstonCollector = require('./WinstonCollector'),
    { file } = require('../../helpers/format'),
    format = winston.format.printf(file),

    MAX_FILES_COUNT = 5,
    MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

/**
 * @extends WinstonCollector
 * @class WinstonFileCollector
 * @description This holds the basic details winston file collector
 */
class WinstonFileCollector extends WinstonCollector {
    /**
     * @method constructor
     * @description It calls the super with the winston file transport as its transport module
     * @param {[Object={}]} options
     * @param {String} options.file
     * @throws InvalidParamsException
     */
    constructor (options = {}) {

        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new Error('InvalidParamsException: options should be of type object if provided');
        }

        let file = options.file;

        // Validate the file input
        if (!file || typeof file !== 'string') {
            throw new Error('InvalidParamsException: options.file should be a valid non empty string');
        }

        super(Object.assign(
            {},
            options,
            {
                transports: [new winston.transports.File({
                    filename: file,
                    maxFiles: MAX_FILES_COUNT,
                    maxsize: MAX_FILE_SIZE,
                    format
                })]
            })
        );
    }
}

module.exports = WinstonFileCollector;
const WinstonCollector = require('./WinstonCollector'),
    WinstonNewRelicTransport = require('../../transports/winston/NewRelicTransport'),
    { ERROR } = require('../../constants/level');

/**
 * @extends WinstonCollector
 * @class WinstonNewRelicCollector
 * @description This holds the basic details winston NewRelic collector
 */
class WinstonNewRelicCollector extends WinstonCollector {
    /**
     * @method constructor
     * @description It calls the super with the winston NewRelic transport as its transport module
     * @param {[Object={}]} options
     * @param {Object} options.newrelic
     * @throws InvalidParamsException
     */
    constructor (options = {}) {
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new Error('InvalidParamsException: options should be of type object if provided');
        }

        super(Object.assign(
            {},
            options,
            {
                level: ERROR, // Only errors are sent to NewRelic
                transports: [new WinstonNewRelicTransport({ newrelic: options.newrelic })]
            })
        );
    }

    /**
     * @description For NewRelic, switching log level should not be allowed.
     * Which would otherwise lead to info/warn messages to be sent to NewRelic
     * @param {String} level should be among the valid log levels
     * @override
     */
    // eslint-disable-next-line class-methods-use-this, no-unused-vars, no-empty-function
    setLogLevel (level) { }
}

module.exports = WinstonNewRelicCollector;
const WinstonCollector = require('./WinstonCollector'),
    WinstonSentryTransport = require('../../transports/winston/SentryTransport'),
    { ERROR } = require('../../constants/level');

/**
 * @extends WinstonCollector
 * @class WinstonSentryCollector
 * @description This holds the basic details winston sentry collector
 */
class WinstonSentryCollector extends WinstonCollector {
    /**
     * @method constructor
     * @description It calls the super with the winston sentry transport as its transport module
     * @param {[Object={}]} options
     * @param {Object} options.sentry
     * @throws InvalidParamsException
     */
    constructor (options = {}) {

        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new Error('InvalidParamsException: options should be of type object if provided');
        }

        super(Object.assign(
            {},
            options,
            {
                level: ERROR, // Only errors are sent to sentry
                transports: [new WinstonSentryTransport({ sentry: options.sentry })]
            })
        );
    }

    /**
     * @description For Sentry, switching log level should not be allowed.
     * Which would otherwise lead to info/warn messages to be sent to Sentry
     * @param {String} level should be among the valid log levels
     * @override
     */
    // eslint-disable-next-line class-methods-use-this, no-unused-vars, no-empty-function
    setLogLevel (level) { }
}

module.exports = WinstonSentryCollector;
const winston = require('winston'),
    { consoleFormat } = require('../../helpers/format'),
    AbstractCollector = require('../AbstractCollector'),
    format = winston.format.printf(consoleFormat),
    { INFO } = require('../../constants/level'),
    { isValidLevel } = require('../../helpers/validate');

/**
 * @extends AbstractCollector
 * @class WinstonCollector
 * @description This holds the basic details of winston collector, it uses the transport provided
 * otherwise uses winston console transport
 */
class WinstonCollector extends AbstractCollector {
    /**
     * @method constructor
     * @description It calls the super with the winston as its logger module
     * @param {[Object={}]} options
     * @throws InvalidParamsException
     */
    constructor (options = {}) {
        super(Object.assign(
            {},
            options,
            {
                transports: [
                    WinstonCollector._getLogger({
                        level: options.level || INFO,
                        transports: options.transports || [new winston.transports.Console({ format })]
                    })
                ]
            })
        );
    }

    /**
     * @method _getLogger
     * @param {Array = []} transports
     * @description It creates the winston logger with the transports available.
     * @return {WinstonInstance}
     */
    static _getLogger ({ level, transports }) {
        return winston.createLogger({ level, transports });
    }

    /**
     * @description Switches the log level of the collector
     * Useful when debugging internally or externally
     *
     * @param {String} level should be among the valid log levels
     * @override
     */
    setLogLevel (level) {
        if (!isValidLevel(level)) {
            return;
        }

        this.transports.forEach((transport) => {
            transport.level = level;
        });
    }
}

module.exports = WinstonCollector;
module.exports = {
    ERROR: 'error',
    WARN: 'warn',
    INFO: 'info'
};
const { expect } = require('chai'),
    { consoleFormat } = require('../format');

describe('Console Format', () => {
    it('should not fail for undefined', () => {
        expect(consoleFormat()).to.equal('undefined undefined undefined undefined');
    });

    it('should not fail for missing of all property', () => {
        expect(consoleFormat({})).to.equal('undefined undefined undefined undefined');
    });

    it('should not fail for missing of single property level', () => {
        let expectedMessage = '12345 origin undefined "foo"';
        // eslint-disable-next-line max-len
        expect(consoleFormat({ origin: 'origin', timestamp: 12345, messages: 'foo' })).to.equal(expectedMessage);
    });

    it('should not fail for additional property level (sessionId)', () => {
        let expectedMessage = '12345 origin info "foo"';
        // eslint-disable-next-line max-len
        expect(consoleFormat({ origin: 'origin', level: 'info', sessionId: 1234567, timestamp: 12345, messages: 'foo' })).to.equal(expectedMessage);
    });

    it('should stringify message object', () => {
        let expectedMessage = '12345 origin error {"foo":"bar"}';
        // eslint-disable-next-line max-len
        expect(consoleFormat({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: { foo: 'bar' } })).to.equal(expectedMessage);
    });

    it('should stringify message array', () => {
        let expectedMessage = '12345 origin error "foo","bar"';
        // eslint-disable-next-line max-len
        expect(consoleFormat({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: ['foo', 'bar'] })).to.equal(expectedMessage);
    });

    it('should stringify message array of objects', () => {
        let expectedMessage = '12345 origin error {"foo":"bar"}';
        // eslint-disable-next-line max-len
        expect(consoleFormat({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: [{ foo: 'bar' }] })).to.equal(expectedMessage);
    });

    it('should stringify circular JSON', () => {
        let expectedMessage = '12345 origin error {"a":["~","~a"]},[{"a":"~"},"~"]',
            message = [{}];

        message[0].a = message;
        message.push(message);

        // eslint-disable-next-line max-len
        expect(consoleFormat({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: message })).to.equal(expectedMessage);
    });
});
const { expect } = require('chai'),
    { file } = require('../format');

describe('File Format', () => {
    it('should not fail for undefined', () => {
        expect(file()).to.equal('[undefined][undefined][undefined][undefined][undefined]');
    });

    it('should not fail for missing of all property', () => {
        expect(file({})).to.equal('[undefined][undefined][undefined][undefined][undefined]');
    });

    it('should not fail for missing of single property(level)', () => {
        let expectedMessage = '[123][12345][origin][undefined]["foo"]';
        // eslint-disable-next-line max-len
        expect(file({ origin: 'origin', sessionId: 123, timestamp: 12345, messages: 'foo' })).to.equal(expectedMessage);
    });

    it('should stringify message object', () => {
        let expectedMessage = '[123][12345][origin][error][{"foo":"bar"}]';
        // eslint-disable-next-line max-len
        expect(file({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: { foo: 'bar' } })).to.equal(expectedMessage);
    });

    it('should stringify message array', () => {
        let expectedMessage = '[123][12345][origin][error]["foo","bar"]';
        // eslint-disable-next-line max-len
        expect(file({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: ['foo', 'bar'] })).to.equal(expectedMessage);
    });

    it('should stringify circular JSON', () => {
        let expectedMessage = '[123][12345][origin][error][{"a":["~","~a"]},[{"a":"~"},"~"]]',
            message = [{}];

        message[0].a = message;
        message.push(message);

        // eslint-disable-next-line max-len
        expect(file({ level: 'error', sessionId: 123, origin: 'origin', timestamp: 12345, messages: message })).to.equal(expectedMessage);
    });
});
const { expect } = require('chai'),
    sanitize = require('../sanitize');

describe('Sanitize', () => {
    it('should return undefined for undefined', () => {
        expect(sanitize()).to.be.undefined;
    });

    it('should return string for string', () => {
        expect(sanitize('string')).to.eql('"string"');
    });

    it('should return object for object', () => {
        expect(sanitize({ foo: 'bar' })).to.eql('{"foo":"bar"}');
    });

    it('should return boolean for boolean', () => {
        expect(sanitize(true)).to.eql('true');
        expect(sanitize(false)).to.eql('false');
    });

    it('should return Object for Error Object', () => {
        let sanitizedError = sanitize(new Error('message')),
            parsedSanitizedError = JSON.parse(sanitizedError);

        expect(typeof sanitizedError).to.eql('string');
        expect(parsedSanitizedError.message).to.eql('message');
        expect(parsedSanitizedError.stack).to.not.Empty;
    });

    it('should not encode ~ in the message', () => {
        expect(sanitize(['module~message'])).to.be.eql('"module~message"');
    });
});
const { expect } = require('chai'),
    { ERROR, WARN, INFO } = require('../../constants/level'),
    { isValidLevel } = require('../validate');

describe('Validate - isValidLevel', () => {
    it('should return false for undefined', () => {
        expect(isValidLevel()).to.be.false;
    });

    it('should return false for random string', () => {
        expect(isValidLevel('random string')).to.be.false;
    });

    it('should return true for error', () => {
        expect(isValidLevel(ERROR)).to.be.true;
    });

    it('should return true for warn', () => {
        expect(isValidLevel(WARN)).to.be.true;
    });

    it('should return false for info ', () => {
        expect(isValidLevel(INFO)).to.be.true;
    });
});
const sanitize = require('./sanitize');

module.exports = {
    /**
     * @description It format the message it receives for file
     * @param {[Object={}]} info
     * @return {String}
     */
    file (info = {}) {
        let messages = '';
        try {
            messages = sanitize(info.messages);
        }
        catch (e) {
            console.error(e);
        }
        return `[${info.sessionId}][${info.timestamp}][${info.origin}][${info.level}][${messages}]`;
    },

    /**
     * @description It format the message it receives, for console
     * @param {[Object={}]} info
     * @return {*}
     */
    consoleFormat (info = {}) {
        let messages = '';
        try {
            messages = sanitize(info.messages);
        }
        catch (e) {
            console.error(e);
        }
        return `${info.timestamp} ${info.origin} ${info.level} ${messages}`;
    }
};
const serializeError = require('serialize-error'),
    CircularJSON = require('circular-json'),

    /**
    * @description It sanitizes the message it receives, using serializeError if it is error
    * or uses circularjson stringify for other types.
    * @param {*=''} message
    * @return {*}
    */
    sanitizeMessage = (message) => {
        return message instanceof Error ? JSON.stringify(serializeError(message)) : CircularJSON.stringify(message);
    };

/**
 * @description it iterates over the messages to sanitize
 * @param {Array=} messages
 * @returns {String}
 */
module.exports = (messages) => {

    // There is a case where circularjson.stringify was encoding the ~ characters.
    // To avoid that, we pass each argument to stringify instead as a whole
    // https://github.com/WebReflection/circular-json/issues/45
    if (Array.isArray(messages)) {
        return messages.map(sanitizeMessage).join(',');
    }

    return sanitizeMessage(messages);
};
const { ERROR, WARN, INFO } = require('../constants/level'),
    allowedLevels = {
        [ERROR]: true,
        [WARN]: true,
        [INFO]: true
    };


module.exports = {
    /**
     * @method isValidLevel
     * @description It checks whether the provided level is valid
     * @param {String} level
     * @returns {Boolean}
     */
    isValidLevel: (level) => {
        return Boolean(allowedLevels[level]);
    }
};
module.exports = {
    Originator: require('./originators').AbstractOriginator,
    Collectors: require('./collectors')
};
const os = require('os'),
    path = require('path'),
    fs = require('fs'),
    _ = require('lodash'),
    sinon = require('sinon'),
    { expect } = require('chai'),
    Originator = require('../AbstractOriginator'),
    Collector = require('../../collectors/AbstractCollector'),
    WinstonConsoleCollector = require('../../../').Collectors.Console,
    WinstonFileCollector = require('../../../').Collectors.File,
    WinstonSentryCollector = require('../../collectors/winston/SentryCollector'),
    LOG_FILE_DIR = path.resolve(__dirname, '..', '..', 'test_logs'),
    LOG_FILE = path.resolve(LOG_FILE_DIR, 'winston.log'),
    dummySentry = {
        withScope: (cb) => {
            scope = {
                setExtra: dummySentry.setExtra
            };
            cb(scope);
        },
        captureException: _.noop,
        setExtra: _.noop
    },
    resetLogFile = (done) => {
        setTimeout(() => {
            try {
                if (!fs.existsSync(LOG_FILE_DIR)) {
                    fs.mkdirSync(LOG_FILE_DIR);
                }
                fs.unlinkSync(LOG_FILE + 1);
                fs.unlinkSync(LOG_FILE + 2);
                fs.unlinkSync(LOG_FILE + 3);
                fs.unlinkSync(LOG_FILE + 4);
                fs.unlinkSync(LOG_FILE + 5);
                fs.unlinkSync(LOG_FILE + 6);
                fs.unlinkSync(LOG_FILE + 7);
            }
            catch (e) {
                // Don't fail test case if unlink fails
            }
            finally {
                done();
            }
        }, 1000);

    },
    stdMocks = require('std-mocks');

describe('Originator', () => {
    let sandbox = null;
    before((done) => {
        global.Date.now = () => {
            return 123456;
        };
        resetLogFile(done);
        sandbox = sinon.sandbox.create();
    });

    afterEach((done) => {
        resetLogFile(done);
        sandbox.restore();
    });


    it('should thrown Invalid param exception on wrong options type', () => {
        // eslint-disable-next-line no-new,max-len
        expect(() => { new Originator('options'); }).to.throw('InvalidParamException: options should be of type Object');
    });

    it('should create originator instance with default level as info', () => {
        let originator = new Originator({ origin: 'foo' });

        expect(originator.error).to.not.empty;
        expect(originator.warn).to.not.empty;
        expect(originator.info).to.not.empty;
        expect(originator.level).to.equal('info');
    });

    it('should create originator instance level as error', () => {
        let originator = new Originator({ level: 'error', origin: 'foo' });

        expect(originator.level).to.equal('error');
    });

    it('should create originator instance level as warn', () => {
        let originator = new Originator({ level: 'warn', origin: 'foo' });

        expect(originator.level).to.equal('warn');
    });

    it('should create originator instance level as info', () => {
        let originator = new Originator({ level: 'info', origin: 'foo' });

        expect(originator.level).to.equal('info');
    });

    it('should create originator instance level as info when invalid level is provided', () => {
        let originator = new Originator({ level: 'invalid', origin: 'foo' });

        expect(originator.level).to.equal('info');
    });

    it('should log on calling error method', () => {
        let originator = new Originator({ origin: 'foo', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['error { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'message\' ] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.error('message');
        stdMocks.restore();

        output = stdMocks.flush();

        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should add collector after initialization', () => {
        let originator = new Originator({ origin: 'foo', collectors: [] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['error { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'message\' ] }\n']; // eslint-disable-line max-len

        originator.addCollector(new Collector());

        stdMocks.use();
        originator.error('message');
        stdMocks.restore();

        output = stdMocks.flush();

        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should log on calling warn method', () => {
        let originator = new Originator({ origin: 'foo', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['warn { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'message\' ] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.warn('message');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should log on calling info method', () => {
        let originator = new Originator({ origin: 'foo', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['info { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'message\' ] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.info('message');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should log on calling error method with sessionId', () => {
        let originator = new Originator({ origin: 'foo', sessionId: 'newSession', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['error { sessionId: \'newSession\',\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'message\' ] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.error('message');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should log on calling info method with empty message', () => {
        let originator = new Originator({ origin: 'foo', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['info { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.info();
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should log on calling info method with 2 messages', () => {
        let originator = new Originator({ origin: 'foo', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['info { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'first\', \'second\' ] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.info('first', 'second');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should log on calling info method with 3 messages', () => {
        let originator = new Originator({ origin: 'foo', collectors: [new Collector()] }),
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = ['info { sessionId: 123456,\n  timestamp: 123456,\n  origin: \'foo\',\n  messages: [ \'first\', \'second\', \'third\' ] }\n']; // eslint-disable-line max-len

        stdMocks.use();
        originator.info('first', 'second', 'third');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should create originators with winston console collector', () => {
        let output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo info "foo"${os.EOL}`,
                `123456 bar error "Foo Error"${os.EOL}`,
                `123456 foo warn {"foo":"bar"}${os.EOL}`
            ],
            collectors = [new WinstonConsoleCollector()],
            fooLogger = new Originator({ collectors, origin: 'foo' }),
            barLogger = new Originator({ collectors, origin: 'bar' });

        stdMocks.use();
        fooLogger.info('foo');
        barLogger.error('Foo Error');
        fooLogger.warn({ foo: 'bar' });
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(3);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should create originators with winston console collector and call with two arguments', () => {
        let output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo info "foo","bar"${os.EOL}`
            ],
            collectors = [new WinstonConsoleCollector()],
            fooLogger = new Originator({ collectors, origin: 'foo' });

        stdMocks.use();
        fooLogger.info('foo', 'bar');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);
    });

    it('should create originator with winston file collector', (done) => {
        let fileString = '',
            expectedFileOut = `[123456][123456][foo][info]["foo"]${os.EOL}[123456][123456][foo][warn][{"foo":"bar"}]${os.EOL}`, // eslint-disable-line max-len
            collectors = [new WinstonFileCollector({ file: LOG_FILE + 1 })],
            fooLogger = new Originator({ collectors, origin: 'foo' });

        fooLogger.info('foo');
        fooLogger.warn({ foo: 'bar' });

        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 1, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should create originator with winston file collector and call with two arguments', (done) => {
        let fileString = '',
            expectedFileOut = `[123456][123456][foo][info]["foo","bar"]${os.EOL}`,
            collectors = [new WinstonFileCollector({ file: LOG_FILE + 2 })],
            fooLogger = new Originator({ collectors, origin: 'foo' });

        fooLogger.info('foo', 'bar');

        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 2, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should create originator with winston file and winston console collector', (done) => {
        let fileString = '',
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo info "foo"${os.EOL}`,
                `123456 foo warn {"foo":"bar"}${os.EOL}`
            ],
            expectedFileOut = `[123456][123456][foo][info]["foo"]${os.EOL}[123456][123456][foo][warn][{"foo":"bar"}]${os.EOL}`, // eslint-disable-line max-len
            collectors = [
                new WinstonConsoleCollector(),
                new WinstonFileCollector({ file: LOG_FILE + 3 })
            ],
            fooLogger = new Originator({ collectors: collectors, origin: 'foo' });

        stdMocks.use();
        fooLogger.info('foo');
        fooLogger.warn({ foo: 'bar' });
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(2);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);


        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 3, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should log info and higher messages after changing log level to info', (done) => {
        let fileString = '',
            expectedFileOut = `[123456][123456][foo][info]["foo"]${os.EOL}[123456][123456][foo][warn]["bar"]${os.EOL}[123456][123456][foo][error]["foobar",{"crash":true}]${os.EOL}`, // eslint-disable-line max-len
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo info "foo"${os.EOL}`,
                `123456 foo warn "bar"${os.EOL}`,
                `123456 foo error "foobar",{"crash":true}${os.EOL}`
            ],
            sentryExceptionSpy = sandbox.spy(dummySentry, 'captureException'),
            collectors = [
                new WinstonConsoleCollector(),
                new WinstonFileCollector({ file: LOG_FILE + 4 }),
                new WinstonSentryCollector({ sentry: dummySentry })
            ],
            fooLogger = new Originator({ collectors: collectors, origin: 'foo' });

        fooLogger.setLogLevel('info');

        stdMocks.use();
        fooLogger.info('foo');
        fooLogger.warn('bar');
        fooLogger.error('foobar', { crash: true });
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(3);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);

        // sentry should be called only once (for error)
        expect(sentryExceptionSpy.callCount).to.equal(1);

        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 4, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should log warn and higher messages after changing log level to warn', (done) => {
        let fileString = '',
            expectedFileOut = `[123456][123456][foo][warn]["bar"]${os.EOL}[123456][123456][foo][error]["foobar",{"crash":true}]${os.EOL}`, // eslint-disable-line max-len
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo warn "bar"${os.EOL}`,
                `123456 foo error "foobar",{"crash":true}${os.EOL}`
            ],
            sentryExceptionSpy = sandbox.spy(dummySentry, 'captureException'),
            collectors = [
                new WinstonConsoleCollector(),
                new WinstonFileCollector({ file: LOG_FILE + 5 }),
                new WinstonSentryCollector({ sentry: dummySentry })
            ],
            fooLogger = new Originator({ collectors: collectors, origin: 'foo' });

        fooLogger.setLogLevel('warn');

        stdMocks.use();
        fooLogger.info('foo');
        fooLogger.warn('bar');
        fooLogger.error('foobar', { crash: true });
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(2);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);

        // sentry should be called only once (for error)
        expect(sentryExceptionSpy.callCount).to.equal(1);

        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 5, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should log error and higher messages after changing log level to error', (done) => {
        let fileString = '',
            expectedFileOut = `[123456][123456][foo][error]["foobar",{"crash":true}]${os.EOL}`,
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo error "foobar",{"crash":true}${os.EOL}`
            ],
            sentryExceptionSpy = sandbox.spy(dummySentry, 'captureException'),
            collectors = [
                new WinstonConsoleCollector(),
                new WinstonFileCollector({ file: LOG_FILE + 6 }),
                new WinstonSentryCollector({ sentry: dummySentry })
            ],
            fooLogger = new Originator({ collectors: collectors, origin: 'foo' });

        fooLogger.setLogLevel('error');

        stdMocks.use();
        fooLogger.info('foo');
        fooLogger.warn('bar');
        fooLogger.error('foobar', { crash: true });
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(1);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);

        // sentry should be called only once (for error)
        expect(sentryExceptionSpy.callCount).to.equal(1);

        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 6, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should log messages as per set log level', (done) => {
        let fileString = '',
            expectedFileOut = `[123456][123456][foo][warn]["bar"]${os.EOL}[123456][123456][foo][error]["foobar",{"crash":true}]${os.EOL}[123456][123456][foo][info]["foo"]${os.EOL}[123456][123456][foo][warn]["bar"]${os.EOL}[123456][123456][foo][error]["foobar",{"context":{"api":"foo","domain":"bar"},"crash":true}]${os.EOL}[123456][123456][foo][error]["foobar"]${os.EOL}`, // eslint-disable-line max-len
            output = {},
            stdout = [],
            stderr = [],
            expectedStdout = [
                `123456 foo warn "bar"${os.EOL}`,
                `123456 foo error "foobar",{"crash":true}${os.EOL}`,
                `123456 foo info "foo"${os.EOL}`,
                `123456 foo warn "bar"${os.EOL}`,
                `123456 foo error "foobar",{"context":{"api":"foo","domain":"bar"},"crash":true}${os.EOL}`,
                `123456 foo error "foobar"${os.EOL}`
            ],
            sentryExceptionSpy = sandbox.spy(dummySentry, 'captureException'),
            collectors = [
                new WinstonConsoleCollector(),
                new WinstonFileCollector({ file: LOG_FILE + 7 }),
                new WinstonSentryCollector({ sentry: dummySentry })
            ],
            fooLogger = new Originator({ collectors: collectors, origin: 'foo' });

        stdMocks.use();
        fooLogger.setLogLevel('warn');

        fooLogger.info('foo');
        fooLogger.warn('bar');
        fooLogger.error('foobar', { crash: true });

        fooLogger.setLogLevel('info');

        fooLogger.info('foo');
        fooLogger.warn('bar');
        fooLogger.error('foobar', { context: { api: 'foo', domain: 'bar' }, crash: true });

        fooLogger.setLogLevel('error');

        fooLogger.info('foo');
        fooLogger.warn('bar');
        fooLogger.error('foobar');
        stdMocks.restore();

        output = stdMocks.flush();
        stdout = output.stdout;
        stderr = output.stderr;

        expect(stdout).to.be.an('array');
        expect(stdout).to.have.lengthOf(6);
        expect(stdout).to.eql(expectedStdout);
        expect(stderr).to.be.an('array');
        expect(stderr).to.have.lengthOf(0);

        // sentry should be called only once (for error)
        expect(sentryExceptionSpy.callCount).to.equal(2);

        // Reading file immediately will throw error
        setTimeout(() => {
            fileString = fs.readFileSync(LOG_FILE + 7, { encoding: 'utf-8' });
            try {
                expect(fileString).to.equal(expectedFileOut);
                done();
            }
            catch (e) {
                done(e);
            }
        }, 1000);
    });

    it('should return a context object when getContext() is called', (done) => {
        let collectors = [
                new WinstonConsoleCollector()
            ],
            fooLogger = new Originator({ collectors: collectors, origin: 'foo' });

        expect(fooLogger.getContext('foo', 'bar')).to.be.a('object').and.be.eql({
            api: 'foo',
            domain: 'bar'
        });
        done();
    });

});
const { isValidLevel } = require('../helpers/validate'),
    { ERROR, WARN, INFO } = require('../constants/level'),
    Collector = require('../collectors/AbstractCollector');

/**
 * @class Originator
 * @description This holds the basic details of an originator
 *
 */
class Originator {
    /**
     * @method constructor
     * @description It initialize the necessary props for originator
     * @param {[Object={}]} options
     * @param {String=} options.level
     * @param {String=} options.sessionId
     * @param {String=} options.origin
     * @param {Array=} options.collectors
     * @throws InvalidParamsException
     */
    constructor (options = {}) {

        // Thrown error if the options is not of type object
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new Error('InvalidParamException: options should be of type Object');
        }

        this.sessionId = options.sessionId || Date.now();

        this.origin = options.origin || 'Unknown Origin';

        this.collectors = options.collectors || [];

        // Set the level
        this.level = isValidLevel(options.level) ? options.level : INFO;
    }

    /**
     * @description Switches the log level
     * Useful when debugging internally or externally
     *
     * @param {String} level should be among the valid log levels
     */
    setLogLevel (level) {
        if (isValidLevel(level) === false) { return; }
        this.level = level;
        this.collectors.forEach((collector) => {
            collector.setLogLevel(this.level);
        });
    }

    /**
     * @private
     * @method _log
     * @description It calls the log function of all the collectors with the level and sanitized message
     * @param {[String]} level
     * @param {Array = []} messages
     */
    _log (level, messages) {
        this.collectors.forEach((collector) => {
            collector.log(
                level,
                {
                    sessionId: this.sessionId,
                    timestamp: Date.now(),
                    origin: this.origin,
                    messages
                }
            );
        });
    }

    // eslint-disable-next-line jsdoc/check-param-names
    /**
     * @method error
     * @description It calls the _log with level ERROR
     * @param {...*}
     */
    error (...args) {
        this._log(ERROR, args);
    }

    // eslint-disable-next-line jsdoc/check-param-names
    /**
     * @method warn
     * @description It calls the _log with level WARN
     * @param {...*}
     */
    warn (...args) {
        this._log(WARN, args);
    }

    // eslint-disable-next-line jsdoc/check-param-names
    /**
     * @method info
     * @description It calls the _log with default level INFO
     * @param {...*}
     */
    info (...args) {
        this._log(INFO, args);
    }

    /**
     * @method addCollector
     * @description It adds the collector to the collectors we have
     * @param {Collector} collector
     * @throws InvalidParamException
     */
    addCollector (collector) {
        // Thrown error if the collector is not of type Collector
        if (!(collector instanceof Collector)) {
            throw new Error('InvalidParamException: collector of type Collector');
        }

        this.collectors.push(collector);
    }

    /**
     * @method getContext
     * @description Generates a context object, it can be attached to the log event. Must be present for NewRelic logger
     * @param  {String} api - Name of the component
     * @param  {String} domain - Name of the team which owns the component
     */
    // eslint-disable-next-line class-methods-use-this
    getContext (api, domain) {
        return {
            api,
            domain
        };
    }
}

module.exports = Originator;
module.exports = {
    AbstractOriginator: require('./AbstractOriginator')
};
[123456][123456][foo][info]["foo","bar"]
[123456][123456][foo][info]["foo"]
[123456][123456][foo][warn][{"foo":"bar"}]
[123456][123456][foo][info]["foo"]
[123456][123456][foo][warn]["bar"]
[123456][123456][foo][error]["foobar",{"sentry":true}]
[123456][123456][foo][warn]["bar"]
[123456][123456][foo][error]["foobar",{"sentry":true}]
[123456][123456][foo][error]["foobar",{"sentry":true}]
[123456][123456][foo][warn]["bar"]
[123456][123456][foo][error]["foobar",{"sentry":true}]
[123456][123456][foo][info]["foo"]
[123456][123456][foo][warn]["bar"]
[123456][123456][foo][error]["foobar",{"context":{"api":"foo","domain":"bar"},"sentry":true}]
[123456][123456][foo][error]["foobar"]
const { expect } = require('chai'),
    sinon = require('sinon'),
    _ = require('lodash'),
    NewRelicTransport = require('../NewRelicTransport'),
    dummyNewrelic = {
        recordCustomEvent: _.noop,
        setMetadata: _.noop
    };

describe('Winston/NewRelicTransport', () => {
    let sandbox = null;

    before(() => {
        sandbox = sinon.sandbox.create();
    });

    afterEach(() => {
        sandbox.restore();
    });


    it('should create NewRelic instance with the newrelic provided', () => {
        let newRelicTransport = new NewRelicTransport({ newrelic: dummyNewrelic });
        expect(newRelicTransport.log).to.be.a('function');
    });

    describe('NewRelicTransport.log', () => {
        it('should call newrelic.recordCustomEvent with the info.messages[0] of error type', () => {
            let newRelicTransport = new NewRelicTransport({ newrelic: dummyNewrelic }),
                spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent'),
                error = new Error('test'),
                info = { messages: [error, { context: { api: 'echo', domain: 'echo' } }] };

            newRelicTransport.log(info, _.noop);
            expect(spy.calledWith(error));
        });

        it('should call newrelic.recordCustomEvent with the info.messages[0] of string type by converting to error type', () => { // eslint-disable-line max-len
            let newRelicTransport = new NewRelicTransport({ newrelic: dummyNewrelic }),
                spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent'),
                info = { messages: ['test', { context: { api: 'echo', domain: 'foobar' } }] };

            newRelicTransport.log(info, _.noop);

            // Check event type
            expect(spy.args[0][0]).to.be.a('string').and.be.eql('postmanAppError');
            // Check event body
            expect(spy.args[0][1]).to.be.a('object');
            // Check JSON body
            expect(spy.args[0][1].api).to.be.a('string').and.be.eql('echo');
            expect(spy.args[0][1].context).to.be.a('string').and.be.eql('test');
            expect(spy.args[0][1].domain).to.be.a('string').and.be.eql('foobar');
            expect(spy.args[0][1].message).to.be.a('string').and.be.eql('test');
            expect(spy.args[0][1].stack).to.be.a('string');

        });

        it('should not call newrelic.recordCustomEvent if info.messages does not have a context object', () => { // eslint-disable-line max-len
            let newRelicTransport = new NewRelicTransport({ newrelic: dummyNewrelic }),
                spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent'),
                info = { messages: ['test'] };

            newRelicTransport.log(info, _.noop);

            expect(spy.args).to.be.a('array').and.be.eql([]);
        });

        it('should call newrelic.recordCustomEvent when info.messages[0] is a string but info.messages[1] is an error', () => { // eslint-disable-line max-len
            let newRelicTransport = new NewRelicTransport({ newrelic: dummyNewrelic }),
                spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent'),
                info = { messages: [
                    'test',
                    new Error('sample error'),
                    { context: { api: 'echo', domain: 'foobar' } }
                ] };

            newRelicTransport.log(info, _.noop);

            // Check event type
            expect(spy.args[0][0]).to.be.a('string').and.be.eql('postmanAppError');
            // Check event body
            expect(spy.args[0][1]).to.be.a('object');
            // Check JSON body
            expect(spy.args[0][1].api).to.be.a('string').and.be.eql('echo');
            expect(spy.args[0][1].context).to.be.a('string').and.be.eql('test');
            expect(spy.args[0][1].domain).to.be.a('string').and.be.eql('foobar');
            expect(spy.args[0][1].message).to.be.a('string').and.be.eql('sample error');
            expect(spy.args[0][1].stack).to.be.a('string');

        });

        it('should add the extra metadata into the newrelic event if it is passed with the context object', () => { // eslint-disable-line max-len
            let newRelicTransport = new NewRelicTransport({ newrelic: dummyNewrelic }),
                spy = sandbox.spy(dummyNewrelic, 'recordCustomEvent'),
                info = { messages: [
                    'test',
                    new Error('sample error'),
                    {
                        context: { api: 'echo', domain: 'foobar' },
                        someMeta: 'data'
                    }
                ] };

            newRelicTransport.log(info, _.noop);

            // Check event type
            expect(spy.args[0][0]).to.be.a('string').and.be.eql('postmanAppError');
            // Check event body
            expect(spy.args[0][1]).to.be.a('object');
            // Check JSON body
            expect(spy.args[0][1].api).to.be.a('string').and.be.eql('echo');
            expect(spy.args[0][1].context).to.be.a('string').and.be.eql('test');
            expect(spy.args[0][1].domain).to.be.a('string').and.be.eql('foobar');
            expect(spy.args[0][1].message).to.be.a('string').and.be.eql('sample error');
            expect(spy.args[0][1].someMeta).to.be.a('string').and.be.eql('data');
            expect(spy.args[0][1].stack).to.be.a('string');

        });
    });
});
const { expect } = require('chai'),
    sinon = require('sinon'),
    _ = require('lodash'),
    SentryTransport = require('../SentryTransport'),
    dummySentry = {
        withScope: (cb) => {
            scope = {
                setExtra: dummySentry.setExtra
            };
            cb(scope);
        },
        captureException: _.noop,
        setExtra: _.noop
    };

describe('Winston/SentryTransport', () => {
    let sandbox = null;

    before(() => {
        sandbox = sinon.sandbox.create();
    });

    afterEach(() => {
        sandbox.restore();
    });


    it('should create Sentry instance with the sentry provided', () => {
        let sentryTransport = new SentryTransport({ sentry: dummySentry });
        expect(sentryTransport.log).to.be.a('function');
    });

    describe('SentryTransport.log', () => {
        it('should call the sentry.captureException with the info.messages[0] of error type', () => {
            let sentryTransport = new SentryTransport({ sentry: dummySentry }),
                spy = sandbox.spy(dummySentry, 'captureException'),
                error = new Error('test'),
                info = { messages: [error, { crash: true }] };

            sentryTransport.log(info, _.noop);
            expect(spy.calledWith(error));
        });

        it('should call the sentry.captureException with the info.messages[0] of string type by converting to error type', () => { // eslint-disable-line max-len
            let sentryTransport = new SentryTransport({ sentry: dummySentry }),
                spy = sandbox.spy(dummySentry, 'captureException'),
                info = { messages: ['test', { crash: true }] };

            sentryTransport.log(info, _.noop);
            expect(spy.args[0][0]).to.be.a('error');
        });

        it('should call the sentry.captureException with the info.messages[0] and attaches following values to extra property', () => { // eslint-disable-line max-len
            let sentryTransport = new SentryTransport({ sentry: dummySentry }),
                spy = sandbox.spy(dummySentry, 'captureException'),
                spyExtra = sandbox.spy(dummySentry, 'setExtra'),
                error = new Error('test'),
                extraData = 'extra data',
                info = { messages: [error, extraData, { crash: true }] };

            sentryTransport.log(info, _.noop);
            expect(spy.args[0][0]).to.be.a('error');
            expect(spyExtra.args[0][1]).to.be.a('array');
            expect(spyExtra.args[0][1]).to.be.eql([extraData, { crash: true }]);
        });
    });
});
const _ = require('lodash'),
    Transport = require('winston-transport');

/**
 * Inherit from `winston-transport` so you can take advantage
 * of the base functionality and `.exceptions.handle()`.
 */
module.exports = class NewRelicTransport extends Transport {
    constructor (opts) {
        super(opts);
        this.newrelic = opts.newrelic;
    }

    /**
     * @description It sends event to NewRelic.
     * @param {Object} info
     * @param {Function} callback
     */
    log (info, callback) {
        setImmediate(() => {
            this.emit('logged', info);
        });

        let errorMessage = info.messages[0],
            // We'll pass metadata as the last object
            metadata = info.messages[info.messages.length - 1],
            event = {
                sessionId: info.sessionId,
                origin: info.origin
            };

        // Don't push error to NewRelic if context data about the module is not passed
        // @TODO remove this condition when NewRelic is no longer Opt-in
        if (!metadata.context || !metadata.context.api || !metadata.context.domain) {
            return callback();
        }

        // If the event has a timestamp, send that to NewRelic (NewRelic attaches current time is there's no timestamp)
        if (info.timestamp) {
            event.timestamp = info.timestamp;
        }

        // If the none of the first 2 elements were Errors, then create a new Error instance
        if (!(errorMessage instanceof Error) && !(info.messages[1] instanceof Error)) {
            errorMessage = new Error(errorMessage);
        }

        // Context contain a name for the error, errorMessage is either a user defined string or an instance of Error
        event.context = errorMessage.message || errorMessage;

        // Log the error message (this will contain extra data when multiple error instances are passed)
        event.message = errorMessage.message || info.messages[1].message;

        // Populate the error stack trace
        event.stack = errorMessage.stack || info.messages[1].stack;

        // Merge the context data and the event object
        event = _.merge(metadata.context, event);

        // Remove the context data before merging the data into the event
        // Since this is already added, extra data would become redundant
        delete metadata.context;

        // Merge the data in metadata into the event data
        _.forEach(metadata, (val, key) => {
            // Stringify if some value is of object type (NewRelic doesn't accept objects in event)
            if (typeof val === 'object') {
                event[key] = JSON.stringify(val);
            }
            else {
                event[key] = val;
            }
        });

        this.newrelic.recordCustomEvent('postmanAppError', event);

        return callback();
    }
};
const Transport = require('winston-transport');

/**
 * Inherit from `winston-transport` so you can take advantage
 * of the base functionality and `.exceptions.handle()`.
 */
module.exports = class SentryTransport extends Transport {
    constructor (opts) {
        super(opts);
        this.sentry = opts.sentry;
    }

    /**
     * @description It sends messages to sentry.
     * @param {Object} info
     * @param {Function} callback
     */
    log (info, callback) {
        setImmediate(() => {
            this.emit('logged', info);
        });

        let errorMessage = info.messages[0],
            extraData = info.messages[info.messages.length - 1];

        if (!extraData || !extraData.crash) {
            return callback();
        }

        if (!(errorMessage instanceof Error)) {
            errorMessage = new Error(errorMessage);
        }

        this.sentry.withScope((scope) => {
            // This is the original error that caused the crash to occur
            let originalErr = info.messages[2],
                crashRegex = /CrashHandler/,
                fromCrashHandler = crashRegex.test(errorMessage.message);

            if (fromCrashHandler) {
                // We can not use 'scope' here to set the tags.
                // scope is bound to the error that invoked this function - logger.error invoked from CrashHandler
                // To set the tags on the out-of-scope error, directly use this.sentry.setTag
                this.sentry.setTag('fromCrashHandler', 'true');

                // Sentry doesn't reflect modifications on error it captures.
                // Thus, to add our desired improvements, creating a new error object and populating it.
                let errToReport = new Error();

                errToReport.name = `[From CrashHandler] ${originalErr.name}`;
                errToReport.message = originalErr.message;
                errToReport.stack = originalErr.stack;

                this.sentry.captureException(errToReport);
            }
            else if (extraData.meta && extraData.meta.domain && extraData.meta.category) {
                // For recording searchable custom errors for a particular category, domain.
                scope.setTag('category', extraData.meta.category);
                scope.setTag('domain', extraData.meta.domain);

                this.sentry.captureException(originalErr);
            }
            else {
                // Add additional params to extra context
                scope.setExtra('extra', info.messages.slice(1));
                // Sending to sentry as exception
                this.sentry.captureException(errorMessage);
            }

        });

        callback();
    }
};
/*! (C) WebReflection Mit Style License */
var CircularJSON=function(JSON,RegExp){var specialChar="~",safeSpecialChar="\\x"+("0"+specialChar.charCodeAt(0).toString(16)).slice(-2),escapedSafeSpecialChar="\\"+safeSpecialChar,specialCharRG=new RegExp(safeSpecialChar,"g"),safeSpecialCharRG=new RegExp(escapedSafeSpecialChar,"g"),safeStartWithSpecialCharRG=new RegExp("(?:^|([^\\\\]))"+escapedSafeSpecialChar),indexOf=[].indexOf||function(v){for(var i=this.length;i--&&this[i]!==v;);return i},$String=String;function generateReplacer(value,replacer,resolve){var doNotIgnore=false,inspect=!!replacer,path=[],all=[value],seen=[value],mapp=[resolve?specialChar:"[Circular]"],last=value,lvl=1,i,fn;if(inspect){fn=typeof replacer==="object"?function(key,value){return key!==""&&replacer.indexOf(key)<0?void 0:value}:replacer}return function(key,value){if(inspect)value=fn.call(this,key,value);if(doNotIgnore){if(last!==this){i=lvl-indexOf.call(all,this)-1;lvl-=i;all.splice(lvl,all.length);path.splice(lvl-1,path.length);last=this}if(typeof value==="object"&&value){if(indexOf.call(all,value)<0){all.push(last=value)}lvl=all.length;i=indexOf.call(seen,value);if(i<0){i=seen.push(value)-1;if(resolve){path.push((""+key).replace(specialCharRG,safeSpecialChar));mapp[i]=specialChar+path.join(specialChar)}else{mapp[i]=mapp[0]}}else{value=mapp[i]}}else{if(typeof value==="string"&&resolve){value=value.replace(safeSpecialChar,escapedSafeSpecialChar).replace(specialChar,safeSpecialChar)}}}else{doNotIgnore=true}return value}}function retrieveFromPath(current,keys){for(var i=0,length=keys.length;i<length;current=current[keys[i++].replace(safeSpecialCharRG,specialChar)]);return current}function generateReviver(reviver){return function(key,value){var isString=typeof value==="string";if(isString&&value.charAt(0)===specialChar){return new $String(value.slice(1))}if(key==="")value=regenerate(value,value,{});if(isString)value=value.replace(safeStartWithSpecialCharRG,"$1"+specialChar).replace(escapedSafeSpecialChar,safeSpecialChar);return reviver?reviver.call(this,key,value):value}}function regenerateArray(root,current,retrieve){for(var i=0,length=current.length;i<length;i++){current[i]=regenerate(root,current[i],retrieve)}return current}function regenerateObject(root,current,retrieve){for(var key in current){if(current.hasOwnProperty(key)){current[key]=regenerate(root,current[key],retrieve)}}return current}function regenerate(root,current,retrieve){return current instanceof Array?regenerateArray(root,current,retrieve):current instanceof $String?current.length?retrieve.hasOwnProperty(current)?retrieve[current]:retrieve[current]=retrieveFromPath(root,current.split(specialChar)):root:current instanceof Object?regenerateObject(root,current,retrieve):current}var CircularJSON={stringify:function stringify(value,replacer,space,doNotResolve){return CircularJSON.parser.stringify(value,generateReplacer(value,replacer,!doNotResolve),space)},parse:function parse(text,reviver){return CircularJSON.parser.parse(text,generateReviver(reviver))},parser:JSON};return CircularJSON}(JSON,RegExp);
/*!
Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
var CircularJSON = (function(JSON, RegExp){
var
  // should be a not so common char
  // possibly one JSON does not encode
  // possibly one encodeURIComponent does not encode
  // right now this char is '~' but this might change in the future
  specialChar = '~',
  safeSpecialChar = '\\x' + (
    '0' + specialChar.charCodeAt(0).toString(16)
  ).slice(-2),
  escapedSafeSpecialChar = '\\' + safeSpecialChar,
  specialCharRG = new RegExp(safeSpecialChar, 'g'),
  safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),

  safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\]))' + escapedSafeSpecialChar),

  indexOf = [].indexOf || function(v){
    for(var i=this.length;i--&&this[i]!==v;);
    return i;
  },
  $String = String  // there's no way to drop warnings in JSHint
                    // about new String ... well, I need that here!
                    // faked, and happy linter!
;

function generateReplacer(value, replacer, resolve) {
  var
    doNotIgnore = false,
    inspect = !!replacer,
    path = [],
    all  = [value],
    seen = [value],
    mapp = [resolve ? specialChar : '[Circular]'],
    last = value,
    lvl  = 1,
    i, fn
  ;
  if (inspect) {
    fn = typeof replacer === 'object' ?
      function (key, value) {
        return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;
      } :
      replacer;
  }
  return function(key, value) {
    // the replacer has rights to decide
    // if a new object should be returned
    // or if there's some key to drop
    // let's call it here rather than "too late"
    if (inspect) value = fn.call(this, key, value);

    // first pass should be ignored, since it's just the initial object
    if (doNotIgnore) {
      if (last !== this) {
        i = lvl - indexOf.call(all, this) - 1;
        lvl -= i;
        all.splice(lvl, all.length);
        path.splice(lvl - 1, path.length);
        last = this;
      }
      // console.log(lvl, key, path);
      if (typeof value === 'object' && value) {
    	// if object isn't referring to parent object, add to the
        // object path stack. Otherwise it is already there.
        if (indexOf.call(all, value) < 0) {
          all.push(last = value);
        }
        lvl = all.length;
        i = indexOf.call(seen, value);
        if (i < 0) {
          i = seen.push(value) - 1;
          if (resolve) {
            // key cannot contain specialChar but could be not a string
            path.push(('' + key).replace(specialCharRG, safeSpecialChar));
            mapp[i] = specialChar + path.join(specialChar);
          } else {
            mapp[i] = mapp[0];
          }
        } else {
          value = mapp[i];
        }
      } else {
        if (typeof value === 'string' && resolve) {
          // ensure no special char involved on deserialization
          // in this case only first char is important
          // no need to replace all value (better performance)
          value = value .replace(safeSpecialChar, escapedSafeSpecialChar)
                        .replace(specialChar, safeSpecialChar);
        }
      }
    } else {
      doNotIgnore = true;
    }
    return value;
  };
}

function retrieveFromPath(current, keys) {
  for(var i = 0, length = keys.length; i < length; current = current[
    // keys should be normalized back here
    keys[i++].replace(safeSpecialCharRG, specialChar)
  ]);
  return current;
}

function generateReviver(reviver) {
  return function(key, value) {
    var isString = typeof value === 'string';
    if (isString && value.charAt(0) === specialChar) {
      return new $String(value.slice(1));
    }
    if (key === '') value = regenerate(value, value, {});
    // again, only one needed, do not use the RegExp for this replacement
    // only keys need the RegExp
    if (isString) value = value .replace(safeStartWithSpecialCharRG, '$1' + specialChar)
                                .replace(escapedSafeSpecialChar, safeSpecialChar);
    return reviver ? reviver.call(this, key, value) : value;
  };
}

function regenerateArray(root, current, retrieve) {
  for (var i = 0, length = current.length; i < length; i++) {
    current[i] = regenerate(root, current[i], retrieve);
  }
  return current;
}

function regenerateObject(root, current, retrieve) {
  for (var key in current) {
    if (current.hasOwnProperty(key)) {
      current[key] = regenerate(root, current[key], retrieve);
    }
  }
  return current;
}

function regenerate(root, current, retrieve) {
  return current instanceof Array ?
    // fast Array reconstruction
    regenerateArray(root, current, retrieve) :
    (
      current instanceof $String ?
        (
          // root is an empty string
          current.length ?
            (
              retrieve.hasOwnProperty(current) ?
                retrieve[current] :
                retrieve[current] = retrieveFromPath(
                  root, current.split(specialChar)
                )
            ) :
            root
        ) :
        (
          current instanceof Object ?
            // dedicated Object parser
            regenerateObject(root, current, retrieve) :
            // value as it is
            current
        )
    )
  ;
}

var CircularJSON = {
  stringify: function stringify(value, replacer, space, doNotResolve) {
    return CircularJSON.parser.stringify(
      value,
      generateReplacer(value, replacer, !doNotResolve),
      space
    );
  },
  parse: function parse(text, reviver) {
    return CircularJSON.parser.parse(
      text,
      generateReviver(reviver)
    );
  },
  // A parser should be an API 1:1 compatible with JSON
  // it should expose stringify and parse methods.
  // The default parser is the native JSON.
  parser: JSON
};

return CircularJSON;

}(JSON, RegExp));/*!
Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
var
  // should be a not so common char
  // possibly one JSON does not encode
  // possibly one encodeURIComponent does not encode
  // right now this char is '~' but this might change in the future
  specialChar = '~',
  safeSpecialChar = '\\x' + (
    '0' + specialChar.charCodeAt(0).toString(16)
  ).slice(-2),
  escapedSafeSpecialChar = '\\' + safeSpecialChar,
  specialCharRG = new RegExp(safeSpecialChar, 'g'),
  safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),

  safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\]))' + escapedSafeSpecialChar),

  indexOf = [].indexOf || function(v){
    for(var i=this.length;i--&&this[i]!==v;);
    return i;
  },
  $String = String  // there's no way to drop warnings in JSHint
                    // about new String ... well, I need that here!
                    // faked, and happy linter!
;

function generateReplacer(value, replacer, resolve) {
  var
    doNotIgnore = false,
    inspect = !!replacer,
    path = [],
    all  = [value],
    seen = [value],
    mapp = [resolve ? specialChar : '[Circular]'],
    last = value,
    lvl  = 1,
    i, fn
  ;
  if (inspect) {
    fn = typeof replacer === 'object' ?
      function (key, value) {
        return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;
      } :
      replacer;
  }
  return function(key, value) {
    // the replacer has rights to decide
    // if a new object should be returned
    // or if there's some key to drop
    // let's call it here rather than "too late"
    if (inspect) value = fn.call(this, key, value);

    // first pass should be ignored, since it's just the initial object
    if (doNotIgnore) {
      if (last !== this) {
        i = lvl - indexOf.call(all, this) - 1;
        lvl -= i;
        all.splice(lvl, all.length);
        path.splice(lvl - 1, path.length);
        last = this;
      }
      // console.log(lvl, key, path);
      if (typeof value === 'object' && value) {
    	// if object isn't referring to parent object, add to the
        // object path stack. Otherwise it is already there.
        if (indexOf.call(all, value) < 0) {
          all.push(last = value);
        }
        lvl = all.length;
        i = indexOf.call(seen, value);
        if (i < 0) {
          i = seen.push(value) - 1;
          if (resolve) {
            // key cannot contain specialChar but could be not a string
            path.push(('' + key).replace(specialCharRG, safeSpecialChar));
            mapp[i] = specialChar + path.join(specialChar);
          } else {
            mapp[i] = mapp[0];
          }
        } else {
          value = mapp[i];
        }
      } else {
        if (typeof value === 'string' && resolve) {
          // ensure no special char involved on deserialization
          // in this case only first char is important
          // no need to replace all value (better performance)
          value = value .replace(safeSpecialChar, escapedSafeSpecialChar)
                        .replace(specialChar, safeSpecialChar);
        }
      }
    } else {
      doNotIgnore = true;
    }
    return value;
  };
}

function retrieveFromPath(current, keys) {
  for(var i = 0, length = keys.length; i < length; current = current[
    // keys should be normalized back here
    keys[i++].replace(safeSpecialCharRG, specialChar)
  ]);
  return current;
}

function generateReviver(reviver) {
  return function(key, value) {
    var isString = typeof value === 'string';
    if (isString && value.charAt(0) === specialChar) {
      return new $String(value.slice(1));
    }
    if (key === '') value = regenerate(value, value, {});
    // again, only one needed, do not use the RegExp for this replacement
    // only keys need the RegExp
    if (isString) value = value .replace(safeStartWithSpecialCharRG, '$1' + specialChar)
                                .replace(escapedSafeSpecialChar, safeSpecialChar);
    return reviver ? reviver.call(this, key, value) : value;
  };
}

function regenerateArray(root, current, retrieve) {
  for (var i = 0, length = current.length; i < length; i++) {
    current[i] = regenerate(root, current[i], retrieve);
  }
  return current;
}

function regenerateObject(root, current, retrieve) {
  for (var key in current) {
    if (current.hasOwnProperty(key)) {
      current[key] = regenerate(root, current[key], retrieve);
    }
  }
  return current;
}

function regenerate(root, current, retrieve) {
  return current instanceof Array ?
    // fast Array reconstruction
    regenerateArray(root, current, retrieve) :
    (
      current instanceof $String ?
        (
          // root is an empty string
          current.length ?
            (
              retrieve.hasOwnProperty(current) ?
                retrieve[current] :
                retrieve[current] = retrieveFromPath(
                  root, current.split(specialChar)
                )
            ) :
            root
        ) :
        (
          current instanceof Object ?
            // dedicated Object parser
            regenerateObject(root, current, retrieve) :
            // value as it is
            current
        )
    )
  ;
}

var CircularJSON = {
  stringify: function stringify(value, replacer, space, doNotResolve) {
    return CircularJSON.parser.stringify(
      value,
      generateReplacer(value, replacer, !doNotResolve),
      space
    );
  },
  parse: function parse(text, reviver) {
    return CircularJSON.parser.parse(
      text,
      generateReviver(reviver)
    );
  },
  // A parser should be an API 1:1 compatible with JSON
  // it should expose stringify and parse methods.
  // The default parser is the native JSON.
  parser: JSON
};

module.exports = CircularJSON;
Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
{
  "version": "0.5.9",
  "name": "circular-json",
  "description": "JSON does not handle circular references. This version does",
  "license": "MIT",
  "homepage": "https://github.com/WebReflection/circular-json",
  "keywords": [
    "JSON",
    "circular",
    "reference",
    "recursive",
    "recursion",
    "parse",
    "stringify"
  ],
  "generator": "https://github.com/WebReflection/gitstrap",
  "author": {
    "name": "Andrea Giammarchi",
    "web": "http://webreflection.blogspot.com/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/WebReflection/circular-json.git"
  },
  "unpkg": "build/circular-json.js",
  "main": "./build/circular-json.node.js",
  "scripts": {
    "test": "istanbul cover test/circular-json.js",
    "coveralls": "cat ./coverage/lcov.info | coveralls",
    "web": "$(sleep 2 && open http://0.0.0.0:7151/) & tiny-cdn run ./"
  },
  "devDependencies": {
    "coveralls": "^2.13.0",
    "istanbul": "^0.4.5",
    "tiny-cdn": "^0.7.0",
    "tressa": "^0.3.1"
  }
}
CircularJSON
============

[![donate](https://img.shields.io/badge/$-donate-ff69b4.svg?maxAge=2592000&style=flat)](https://github.com/WebReflection/donate) ![Downloads](https://img.shields.io/npm/dm/circular-json.svg) [![Build Status](https://travis-ci.org/WebReflection/circular-json.svg?branch=master)](https://travis-ci.org/WebReflection/circular-json) [![Coverage Status](https://coveralls.io/repos/github/WebReflection/circular-json/badge.svg?branch=master)](https://coveralls.io/github/WebReflection/circular-json?branch=master)

Serializes and deserializes otherwise valid JSON objects containing circular references into and from a specialized JSON format.

- - -

## The future of this module is called [flatted](https://github.com/WebReflection/flatted#flatted)

Smaller, faster, and able to produce on average a reduced output too, [flatted](https://github.com/WebReflection/flatted#flatted) is the new, bloatless, ESM and CJS compatible, circular JSON parser.

It has now reached V1 and it implements the exact same JSON API.

Please note **CircularJSON is in maintenance only** and **[flatted](https://github.com/WebReflection/flatted#flatted) is its successor**.

- - -

### A Working Solution To A Common Problem
A usage example:

```JavaScript
var object = {};
object.arr = [
  object, object
];
object.arr.push(object.arr);
object.obj = object;

var serialized = CircularJSON.stringify(object);
// '{"arr":["~","~","~arr"],"obj":"~"}'
// NOTE: CircularJSON DOES NOT parse JS
// it handles receiver and reviver callbacks

var unserialized = CircularJSON.parse(serialized);
// { arr: [ [Circular], [Circular] ],
// obj: [Circular] }

unserialized.obj === unserialized;
unserialized.arr[0] === unserialized;
unserialized.arr.pop() === unserialized.arr;
```

A quick summary:

  * **new** in version `0.5`, you can specify a JSON parser different from JSON itself. `CircularJSON.parser = ABetterJSON;` is all you need.
  * uses `~` as a special prefix symbol to denote which parent the reference belongs to (i.e. `~root~child1~child2`)
  * reasonably fast in both serialization and deserialization
  * compact serialization for easier and slimmer transportation across environments
  * [tested and covered](test/circular-json.js) over nasty structures too
  * compatible with all JavaScript engines

Node Installation & Usage
============

```bash
npm install --save circular-json
```

```javascript
'use strict';

var
  CircularJSON = require('circular-json'),
  obj = { foo: 'bar' },
  str
;
  
obj.self = obj;
str = CircularJSON.stringify(obj);
```

There are no dependencies.

Browser Installation & Usage
================

* Global: <build/circular-json.js>
* AMD: <build/circular-json.amd.js>
* CommonJS: <build/circular-json.node.js>

(generated via [gitstrap](https://github.com/WebReflection/gitstrap))

```html
<script src="build/circular-json.js"></script>
```

```javascript
'use strict';

var CircularJSON = window.CircularJSON
  , obj = { foo: 'bar' }
  , str
  ;
  
obj.self = obj;
str = CircularJSON.stringify(obj);
```

NOTE: Platforms without native JSON (i.e. MSIE <= 8) requires `json3.js` or similar.

It is also *a bad idea* to `CircularJSON.parse(JSON.stringify(object))` because of those manipulation used in `CircularJSON.stringify()` able to make parsing safe and secure.

As summary: `CircularJSON.parse(CircularJSON.stringify(object))` is the way to go, same is for `JSON.parse(JSON.stringify(object))`.

API
===

It's the same as native JSON, except the fourth parameter `placeholder`, which circular references to be replaced with `"[Circular]"` (i.e. for logging).

* CircularJSON.stringify(object, replacer, spacer, placeholder)
* CircularJSON.parse(string, reviver)

Bear in mind `JSON.parse(CircularJSON.stringify(object))` will work but not produce the expected output.

Similar Libraries
=======

### Why Not the [@izs](https://twitter.com/izs) One
The module [json-stringify-safe](https://github.com/isaacs/json-stringify-safe) seems to be for `console.log()`  but it's completely pointless for `JSON.parse()`, being latter one unable to retrieve back the initial structure. Here an example:

```JavaScript
// a logged object with circular references
{
  "circularRef": "[Circular]",
  "list": [
    "[Circular]",
    "[Circular]"
  ]
}
// what do we do with above output ?
```

Just type this in your `node` console: `var o = {}; o.a = o; console.log(o);`. The output will be `{ a: [Circular] }` ... good, but that ain't really solving the problem.

However, if that's all you need, the function used to create that kind of output is probably faster than `CircularJSON` and surely fits in less lines of code.


### Why Not {{put random name}} Solution
So here the thing: circular references can be wrong but, if there is a need for them, any attempt to ignore them or remove them can be considered just a failure.

Not because the method is bad or it's not working, simply because the circular info, the one we needed and used in the first place, is lost!

In this case, `CircularJSON` does even more than just solve circular and recursions: it maps all same objects so that less memory is used as well on deserialization as less bandwidth too!
It's able to redefine those references back later on so the way we store is the way we retrieve and in a reasonably performant way, also trusting the snappy and native `JSON` methods to iterate.

*/
/*!
{
  "name": "@postman/app-logger",
  "version": "2.1.0",
  "description": "Logger module for the postman app",
  "main": "index.js",
  "engines": {
    "node": ">=8.15.0"
  },
  "scripts": {
    "test-unit": "node ./npm/test-unit.js",
    "test-system": "node ./npm/test-system.js",
    "test-lint": "node ./npm/test-lint.js",
    "test": "node ./npm/test.js"
  },
  "keywords": [
    "logger",
    "postman-app"
  ],
  "files": [
    "lib/",
    "index.js"
  ],
  "dependencies": {
    "circular-json": "0.5.9",
    "serialize-error": "2.1.0",
    "winston": "3.1.0"
  },
  "devDependencies": {
    "chai": "3.5.0",
    "chalk": "2.4.0",
    "eslint": "4.18.2",
    "eslint-plugin-jsdoc": "3.6.2",
    "eslint-plugin-lodash": "2.7.0",
    "eslint-plugin-security": "1.4.0",
    "lodash": "4.17.10",
    "mocha": "5.2.0",
    "prettyjson": "1.1.3",
    "shelljs": "0.6.0",
    "sinon": "1.17.7",
    "snyk": "1.110.2",
    "std-mocks": "1.0.1"
  }
}
# Postman-app logger

A simple logger module to use inside postman-app
// Definitions by: Carlos Ballesteros Velasco <https://github.com/soywiz>
//                 Leon Yu <https://github.com/leonyu>
//                 BendingBender <https://github.com/BendingBender>
//                 Maple Miao <https://github.com/mapleeit>

/// <reference types="node" />
import * as stream from 'stream';
import * as http from 'http';

export = FormData;

// Extracted because @types/node doesn't export interfaces.
interface ReadableOptions {
  highWaterMark?: number;
  encoding?: string;
  objectMode?: boolean;
  read?(this: stream.Readable, size: number): void;
  destroy?(this: stream.Readable, error: Error | null, callback: (error: Error | null) => void): void;
  autoDestroy?: boolean;
}

interface Options extends ReadableOptions {
  writable?: boolean;
  readable?: boolean;
  dataSize?: number;
  maxDataSize?: number;
  pauseStreams?: boolean;
}

declare class FormData extends stream.Readable {
  constructor(options?: Options);
  append(key: string, value: any, options?: FormData.AppendOptions | string): void;
  getHeaders(userHeaders?: FormData.Headers): FormData.Headers;
  submit(
    params: string | FormData.SubmitOptions,
    callback?: (error: Error | null, response: http.IncomingMessage) => void
  ): http.ClientRequest;
  getBuffer(): Buffer;
  getBoundary(): string;
  getLength(callback: (err: Error | null, length: number) => void): void;
  getLengthSync(): number;
  hasKnownLength(): boolean;
}

declare namespace FormData {
  interface Headers {
    [key: string]: any;
  }

  interface AppendOptions {
    header?: string | Headers;
    knownLength?: number;
    filename?: string;
    filepath?: string;
    contentType?: string;
  }

  interface SubmitOptions extends http.RequestOptions {
    protocol?: 'https:' | 'http:';
  }
}
/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;
var CombinedStream = require('combined-stream');
var util = require('util');
var path = require('path');
var http = require('http');
var https = require('https');
var parseUrl = require('url').parse;
var fs = require('fs');
var mime = require('mime-types');
var asynckit = require('asynckit');
var populate = require('./populate.js');

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};
  value = value || '';

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._encodeHeaderParam = function(str, lang) {
  if (!lang || typeof lang !== 'string') {
    lang = '';
  }

  // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
  // @note see RFC 8187
  // @todo use postman-urlencoder instead of encodeURIComponent for consistency
  return 'UTF-8\'' + lang + '\'' + encodeURIComponent(str).
    // Note that although RFC3986 reserves "!", RFC8187 does not,
    // so we do not need to escape it
    replace(/['()*]/g, function(c) {
      return '%' + c.charCodeAt(0).toString(16);
    }).
    // The following are not required for percent-encoding per RFC8187,
    // so we can allow for a little better readability over the wire: |`^
    replace(/%(?:7C|60|5E)/g, unescape);
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition = []
    , NON_ASCII_REGEX = /[^\t\x20-\x7e\x80-\xff]/
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (typeof options.filename === 'string') {
    // custom filename take precedence
    filename = path.basename(options.filename);
  } else if (value && (value.name || value.path)) {
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(value.name || value.path);
  } else if (value && value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  // bail if no valid filename
  if (typeof filename !== 'string') {
    return;
  }

  contentDisposition.push('filename="' + filename + '"');

  // add "filename*" param if filename is not in ASCII
  if (NON_ASCII_REGEX.test(filename)) {
    contentDisposition.push('filename*=' + this._encodeHeaderParam(filename));
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};
Copyright (c) 2012 Felix Geisendörfer (felix@debuggable.com) and contributors
Copyright (c) 2020 Postman Inc.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
{
  "name": "@postman/form-data",
  "description": "A library to create readable \"multipart/form-data\" streams. Can be used to submit forms and file uploads to other web applications.",
  "version": "3.1.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/postmanlabs/form-data.git"
  },
  "main": "./lib/form_data",
  "browser": "./lib/browser",
  "typings": "./index.d.ts",
  "scripts": {
    "pretest": "rimraf coverage test/tmp",
    "test": "istanbul cover test/run.js",
    "posttest": "istanbul report lcov text",
    "lint": "eslint lib/*.js test/*.js test/integration/*.js",
    "report": "istanbul report lcov text",
    "ci-lint": "is-node-modern 8 && npm run lint || is-node-not-modern 8",
    "ci-test": "npm run test && npm run browser && npm run report",
    "predebug": "rimraf coverage test/tmp",
    "debug": "verbose=1 ./test/run.js",
    "browser": "browserify -t browserify-istanbul test/run-browser.js | obake --coverage",
    "check": "istanbul check-coverage coverage/coverage*.json",
    "files": "pkgfiles --sort=name"
  },
  "pre-commit": [
    "lint",
    "ci-test",
    "check"
  ],
  "engines": {
    "node": ">= 6"
  },
  "dependencies": {
    "asynckit": "^0.4.0",
    "combined-stream": "^1.0.8",
    "mime-types": "^2.1.12"
  },
  "devDependencies": {
    "@types/node": "^12.0.10",
    "browserify": "^13.1.1",
    "browserify-istanbul": "^2.0.0",
    "cross-spawn": "^6.0.5",
    "eslint": "^6.0.1",
    "fake": "^0.2.2",
    "far": "^0.0.7",
    "formidable": "^1.0.17",
    "is-node-modern": "^1.0.0",
    "istanbul": "^0.4.5",
    "obake": "^0.1.2",
    "puppeteer": "^1.19.0",
    "pkgfiles": "^2.3.0",
    "pre-commit": "^1.1.3",
    "request": "^2.88.0",
    "rimraf": "^2.7.1",
    "tape": "^4.6.2",
    "typescript": "^3.5.2"
  },
  "license": "MIT"
}
# Form-Data [![NPM Module](https://img.shields.io/npm/v/@postman/form-data.svg)](https://www.npmjs.com/package/@postman/form-data) [![Build Status](https://travis-ci.com/postmanlabs/form-data.svg?branch=master)](https://travis-ci.com/postmanlabs/form-data) [![codecov](https://codecov.io/gh/postmanlabs/form-data/branch/master/graph/badge.svg)](https://codecov.io/gh/postmanlabs/form-data)

A library to create readable ```"multipart/form-data"``` streams. Can be used to submit forms and file uploads to other web applications.

The API of this library is inspired by the [XMLHttpRequest-2 FormData Interface][xhr2-fd].

[xhr2-fd]: http://dev.w3.org/2006/webapi/XMLHttpRequest-2/Overview.html#the-formdata-interface

## Install

```
npm install --save form-data
```

## Usage

In this example we are constructing a form with 3 fields that contain a string,
a buffer and a file stream.

``` javascript
var FormData = require('form-data');
var fs = require('fs');

var form = new FormData();
form.append('my_field', 'my value');
form.append('my_buffer', new Buffer(10));
form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
```

Also you can use http-response stream:

``` javascript
var FormData = require('form-data');
var http = require('http');

var form = new FormData();

http.request('http://nodejs.org/images/logo.png', function(response) {
  form.append('my_field', 'my value');
  form.append('my_buffer', new Buffer(10));
  form.append('my_logo', response);
});
```

Or @mikeal's [request](https://github.com/request/request) stream:

``` javascript
var FormData = require('form-data');
var request = require('request');

var form = new FormData();

form.append('my_field', 'my value');
form.append('my_buffer', new Buffer(10));
form.append('my_logo', request('http://nodejs.org/images/logo.png'));
```

In order to submit this form to a web application, call ```submit(url, [callback])``` method:

``` javascript
form.submit('http://example.org/', function(err, res) {
  // res – response object (http.IncomingMessage)  //
  res.resume();
});

```

For more advanced request manipulations ```submit()``` method returns ```http.ClientRequest``` object, or you can choose from one of the alternative submission methods.

### Custom options

You can provide custom options, such as `maxDataSize`:

``` javascript
var FormData = require('form-data');

var form = new FormData({ maxDataSize: 20971520 });
form.append('my_field', 'my value');
form.append('my_buffer', /* something big */);
```

List of available options could be found in [combined-stream](https://github.com/felixge/node-combined-stream/blob/master/lib/combined_stream.js#L7-L15)

### Alternative submission methods

You can use node's http client interface:

``` javascript
var http = require('http');

var request = http.request({
  method: 'post',
  host: 'example.org',
  path: '/upload',
  headers: form.getHeaders()
});

form.pipe(request);

request.on('response', function(res) {
  console.log(res.statusCode);
});
```

Or if you would prefer the `'Content-Length'` header to be set for you:

``` javascript
form.submit('example.org/upload', function(err, res) {
  console.log(res.statusCode);
});
```

To use custom headers and pre-known length in parts:

``` javascript
var CRLF = '\r\n';
var form = new FormData();

var options = {
  header: CRLF + '--' + form.getBoundary() + CRLF + 'X-Custom-Header: 123' + CRLF + CRLF,
  knownLength: 1
};

form.append('my_buffer', buffer, options);

form.submit('http://example.com/', function(err, res) {
  if (err) throw err;
  console.log('Done');
});
```

Form-Data can recognize and fetch all the required information from common types of streams (```fs.readStream```, ```http.response``` and ```mikeal's request```), for some other types of streams you'd need to provide "file"-related information manually:

``` javascript
someModule.stream(function(err, stdout, stderr) {
  if (err) throw err;

  var form = new FormData();

  form.append('file', stdout, {
    filename: 'unicycle.jpg', // ... or:
    filepath: 'photos/toys/unicycle.jpg',
    contentType: 'image/jpeg',
    knownLength: 19806
  });

  form.submit('http://example.com/', function(err, res) {
    if (err) throw err;
    console.log('Done');
  });
});
```

The `filepath` property overrides `filename` and may contain a relative path. This is typically used when uploading [multiple files from a directory](https://wicg.github.io/entries-api/#dom-htmlinputelement-webkitdirectory).

For edge cases, like POST request to URL with query string or to pass HTTP auth credentials, object can be passed to `form.submit()` as first parameter:

``` javascript
form.submit({
  host: 'example.com',
  path: '/probably.php?extra=params',
  auth: 'username:password'
}, function(err, res) {
  console.log(res.statusCode);
});
```

In case you need to also send custom HTTP headers with the POST request, you can use the `headers` key in first parameter of `form.submit()`:

``` javascript
form.submit({
  host: 'example.com',
  path: '/surelynot.php',
  headers: {'x-test-header': 'test-header-value'}
}, function(err, res) {
  console.log(res.statusCode);
});
```

### Methods

- [_Void_ append( **String** _field_, **Mixed** _value_ [, **Mixed** _options_] )](https://github.compostmanlabsa/form-data#void-append-string-field-mixed-value--mixed-options-).
- [_Headers_ getHeaders( [**Headers** _userHeaders_] )](https://github.com/postmanlabs/form-data#array-getheaders-array-userheaders-)
- [_String_ getBoundary()](https://github.com/postmanlabs/form-data#string-getboundary)
- [_Buffer_ getBuffer()](https://github.com/postmanlabs/form-data#buffer-getbuffer)
- [_Integer_ getLengthSync()](https://github.com/postmanlabs/form-data#integer-getlengthsync)
- [_Integer_ getLength( **function** _callback_ )](https://github.com/postmanlabs/form-data#integer-getlength-function-callback-)
- [_Boolean_ hasKnownLength()](https://github.com/postmanlabs/form-data#boolean-hasknownlength)
- [_Request_ submit( _params_, **function** _callback_ )](https://github.com/postmanlabs/form-data#request-submit-params-function-callback-)
- [_String_ toString()](https://github.com/postmanlabs/form-data#string-tostring)

#### _Void_ append( **String** _field_, **Mixed** _value_ [, **Mixed** _options_] )
Append data to the form. You can submit about any format (string, integer, boolean, buffer, etc.). However, Arrays are not supported and need to be turned into strings by the user.
```javascript
var form = new FormData();
form.append( 'my_string', 'my value' );
form.append( 'my_integer', 1 );
form.append( 'my_boolean', true );
form.append( 'my_buffer', new Buffer(10) );
form.append( 'my_array_as_json', JSON.stringify( ['bird','cute'] ) )
```

You may provide a string for options, or an object.
```javascript
// Set filename by providing a string for options
form.append( 'my_file', fs.createReadStream('/foo/bar.jpg'), 'bar.jpg' );

// provide an object.
form.append( 'my_file', fs.createReadStream('/foo/bar.jpg'), {filename: 'bar.jpg', contentType: 'image/jpeg', knownLength: 19806} );
```

#### _Headers_ getHeaders( [**Headers** _userHeaders_] )
This method adds the correct `content-type` header to the provided array of `userHeaders`.

#### _String_ getBoundary()
Return the boundary of the formData. A boundary consists of 26 `-` followed by 24 numbers
for example:
```javascript
--------------------------515890814546601021194782
```
_Note: The boundary must be unique and may not appear in the data._

#### _Buffer_ getBuffer()
Return the full formdata request package, as a Buffer. You can insert this Buffer in e.g. Axios to send multipart data.
```javascript
var form = new FormData();
form.append( 'my_buffer', Buffer.from([0x4a,0x42,0x20,0x52,0x6f,0x63,0x6b,0x73]) );
form.append( 'my_file', fs.readFileSync('/foo/bar.jpg') );

axios.post( 'https://example.com/path/to/api',
            form.getBuffer(),
            form.getHeaders()
          )
```
**Note:** Because the output is of type Buffer, you can only append types that are accepted by Buffer: *string, Buffer, ArrayBuffer, Array, or Array-like Object*. A ReadStream for example will result in an error.

#### _Integer_ getLengthSync()
Same as `getLength` but synchronous.

_Note: getLengthSync __doesn't__ calculate streams length._

#### _Integer_ getLength( **function** _callback_ )
Returns the `Content-Length` async. The callback is used to handle errors and continue once the length has been calculated
```javascript
this.getLength(function(err, length) {
  if (err) {
    this._error(err);
    return;
  }

  // add content length
  request.setHeader('Content-Length', length);

  ...
}.bind(this));
```

#### _Boolean_ hasKnownLength()
Checks if the length of added values is known.

#### _Request_ submit( _params_, **function** _callback_ )
Submit the form to a web application.
```javascript
var form = new FormData();
form.append( 'my_string', 'Hello World' );

form.submit( 'http://example.com/', function(err, res) {
  // res – response object (http.IncomingMessage)  //
  res.resume();
} );
```

#### _String_ toString()
Returns the form data as a string. Don't use this if you are sending files or buffers, use `getBuffer()` instead.

### Integration with other libraries

#### Request

Form submission using  [request](https://github.com/request/request):

```javascript
var formData = {
  my_field: 'my_value',
  my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),
};

request.post({url:'http://service.com/upload', formData: formData}, function(err, httpResponse, body) {
  if (err) {
    return console.error('upload failed:', err);
  }
  console.log('Upload successful!  Server responded with:', body);
});
```

For more details see [request readme](https://github.com/request/request#multipartform-data-multipart-form-uploads).

#### node-fetch

You can also submit a form using [node-fetch](https://github.com/bitinn/node-fetch):

```javascript
var form = new FormData();

form.append('a', 1);

fetch('http://example.com', { method: 'POST', body: form })
    .then(function(res) {
        return res.json();
    }).then(function(json) {
        console.log(json);
    });
```

#### axios

In Node.js you can post a file using [axios](https://github.com/axios/axios):
```javascript
const form = new FormData();
const stream = fs.createReadStream(PATH_TO_FILE);

form.append('image', stream);

// In Node.js environment you need to set boundary in the header field 'Content-Type' by calling method `getHeaders`
const formHeaders = form.getHeaders();

axios.post('http://example.com', form, {
  headers: {
    ...formHeaders,
  },
})
.then(response => response)
.catch(error => error)
```

## Notes

- ```getLengthSync()``` method DOESN'T calculate length for streams, use ```knownLength``` options as workaround.
- Starting version `2.x` FormData has dropped support for `node@0.10.x`.
- Starting version `3.x` FormData has dropped support for `node@4.x`.

## License

Form-Data is released under the [MIT](License) license.
import { ServiceDefinition } from './make-client';
import { Server, UntypedServiceImplementation } from './server';
interface GetServiceDefinition {
    (): ServiceDefinition;
}
interface GetHandlers {
    (): UntypedServiceImplementation;
}
export declare function registerAdminService(getServiceDefinition: GetServiceDefinition, getHandlers: GetHandlers): void;
export declare function addAdminServicesToServer(server: Server): void;
export {};
"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerAdminService = registerAdminService;
exports.addAdminServicesToServer = addAdminServicesToServer;
const registeredAdminServices = [];
function registerAdminService(getServiceDefinition, getHandlers) {
    registeredAdminServices.push({ getServiceDefinition, getHandlers });
}
function addAdminServicesToServer(server) {
    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
        server.addService(getServiceDefinition(), getHandlers());
    }
}
//# sourceMappingURL=admin.js.map{"version":3,"file":"admin.js","sourceRoot":"","sources":["../../src/admin.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAkBH,oDAKC;AAED,4DAIC;AAhBD,MAAM,uBAAuB,GAGvB,EAAE,CAAC;AAET,SAAgB,oBAAoB,CAClC,oBAA0C,EAC1C,WAAwB;IAExB,uBAAuB,CAAC,IAAI,CAAC,EAAE,oBAAoB,EAAE,WAAW,EAAE,CAAC,CAAC;AACtE,CAAC;AAED,SAAgB,wBAAwB,CAAC,MAAc;IACrD,KAAK,MAAM,EAAE,oBAAoB,EAAE,WAAW,EAAE,IAAI,uBAAuB,EAAE,CAAC;QAC5E,MAAM,CAAC,UAAU,CAAC,oBAAoB,EAAE,EAAE,WAAW,EAAE,CAAC,CAAC;IAC3D,CAAC;AACH,CAAC"}export interface BackoffOptions {
    initialDelay?: number;
    multiplier?: number;
    jitter?: number;
    maxDelay?: number;
}
export declare class BackoffTimeout {
    private callback;
    /**
     * The delay time at the start, and after each reset.
     */
    private readonly initialDelay;
    /**
     * The exponential backoff multiplier.
     */
    private readonly multiplier;
    /**
     * The maximum delay time
     */
    private readonly maxDelay;
    /**
     * The maximum fraction by which the delay time can randomly vary after
     * applying the multiplier.
     */
    private readonly jitter;
    /**
     * The delay time for the next time the timer runs.
     */
    private nextDelay;
    /**
     * The handle of the underlying timer. If running is false, this value refers
     * to an object representing a timer that has ended, but it can still be
     * interacted with without error.
     */
    private timerId;
    /**
     * Indicates whether the timer is currently running.
     */
    private running;
    /**
     * Indicates whether the timer should keep the Node process running if no
     * other async operation is doing so.
     */
    private hasRef;
    /**
     * The time that the currently running timer was started. Only valid if
     * running is true.
     */
    private startTime;
    /**
     * The approximate time that the currently running timer will end. Only valid
     * if running is true.
     */
    private endTime;
    constructor(callback: () => void, options?: BackoffOptions);
    private runTimer;
    /**
     * Call the callback after the current amount of delay time
     */
    runOnce(): void;
    /**
     * Stop the timer. The callback will not be called until `runOnce` is called
     * again.
     */
    stop(): void;
    /**
     * Reset the delay time to its initial value. If the timer is still running,
     * retroactively apply that reset to the current timer.
     */
    reset(): void;
    /**
     * Check whether the timer is currently running.
     */
    isRunning(): boolean;
    /**
     * Set that while the timer is running, it should keep the Node process
     * running.
     */
    ref(): void;
    /**
     * Set that while the timer is running, it should not keep the Node process
     * running.
     */
    unref(): void;
    /**
     * Get the approximate timestamp of when the timer will fire. Only valid if
     * this.isRunning() is true.
     */
    getEndTime(): Date;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackoffTimeout = void 0;
const INITIAL_BACKOFF_MS = 1000;
const BACKOFF_MULTIPLIER = 1.6;
const MAX_BACKOFF_MS = 120000;
const BACKOFF_JITTER = 0.2;
/**
 * Get a number uniformly at random in the range [min, max)
 * @param min
 * @param max
 */
function uniformRandom(min, max) {
    return Math.random() * (max - min) + min;
}
class BackoffTimeout {
    constructor(callback, options) {
        this.callback = callback;
        /**
         * The delay time at the start, and after each reset.
         */
        this.initialDelay = INITIAL_BACKOFF_MS;
        /**
         * The exponential backoff multiplier.
         */
        this.multiplier = BACKOFF_MULTIPLIER;
        /**
         * The maximum delay time
         */
        this.maxDelay = MAX_BACKOFF_MS;
        /**
         * The maximum fraction by which the delay time can randomly vary after
         * applying the multiplier.
         */
        this.jitter = BACKOFF_JITTER;
        /**
         * Indicates whether the timer is currently running.
         */
        this.running = false;
        /**
         * Indicates whether the timer should keep the Node process running if no
         * other async operation is doing so.
         */
        this.hasRef = true;
        /**
         * The time that the currently running timer was started. Only valid if
         * running is true.
         */
        this.startTime = new Date();
        /**
         * The approximate time that the currently running timer will end. Only valid
         * if running is true.
         */
        this.endTime = new Date();
        if (options) {
            if (options.initialDelay) {
                this.initialDelay = options.initialDelay;
            }
            if (options.multiplier) {
                this.multiplier = options.multiplier;
            }
            if (options.jitter) {
                this.jitter = options.jitter;
            }
            if (options.maxDelay) {
                this.maxDelay = options.maxDelay;
            }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => { }, 0);
        clearTimeout(this.timerId);
    }
    runTimer(delay) {
        var _a, _b;
        this.endTime = this.startTime;
        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);
        clearTimeout(this.timerId);
        this.timerId = setTimeout(() => {
            this.callback();
            this.running = false;
        }, delay);
        if (!this.hasRef) {
            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    }
    /**
     * Call the callback after the current amount of delay time
     */
    runOnce() {
        this.running = true;
        this.startTime = new Date();
        this.runTimer(this.nextDelay);
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay =
            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
    }
    /**
     * Stop the timer. The callback will not be called until `runOnce` is called
     * again.
     */
    stop() {
        clearTimeout(this.timerId);
        this.running = false;
    }
    /**
     * Reset the delay time to its initial value. If the timer is still running,
     * retroactively apply that reset to the current timer.
     */
    reset() {
        this.nextDelay = this.initialDelay;
        if (this.running) {
            const now = new Date();
            const newEndTime = this.startTime;
            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
            clearTimeout(this.timerId);
            if (now < newEndTime) {
                this.runTimer(newEndTime.getTime() - now.getTime());
            }
            else {
                this.running = false;
            }
        }
    }
    /**
     * Check whether the timer is currently running.
     */
    isRunning() {
        return this.running;
    }
    /**
     * Set that while the timer is running, it should keep the Node process
     * running.
     */
    ref() {
        var _a, _b;
        this.hasRef = true;
        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * Set that while the timer is running, it should not keep the Node process
     * running.
     */
    unref() {
        var _a, _b;
        this.hasRef = false;
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * Get the approximate timestamp of when the timer will fire. Only valid if
     * this.isRunning() is true.
     */
    getEndTime() {
        return this.endTime;
    }
}
exports.BackoffTimeout = BackoffTimeout;
//# sourceMappingURL=backoff-timeout.js.map{"version":3,"file":"backoff-timeout.js","sourceRoot":"","sources":["../../src/backoff-timeout.ts"],"names":[],"mappings":"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"}import { Metadata } from './metadata';
export interface CallMetadataOptions {
    service_url: string;
}
export type CallMetadataGenerator = (options: CallMetadataOptions, cb: (err: Error | null, metadata?: Metadata) => void) => void;
export interface OldOAuth2Client {
    getRequestMetadata: (url: string, callback: (err: Error | null, headers?: {
        [index: string]: string;
    }) => void) => void;
}
export interface CurrentOAuth2Client {
    getRequestHeaders: (url?: string) => Promise<{
        [index: string]: string;
    }>;
}
export type OAuth2Client = OldOAuth2Client | CurrentOAuth2Client;
/**
 * A class that represents a generic method of adding authentication-related
 * metadata on a per-request basis.
 */
export declare abstract class CallCredentials {
    /**
     * Asynchronously generates a new Metadata object.
     * @param options Options used in generating the Metadata object.
     */
    abstract generateMetadata(options: CallMetadataOptions): Promise<Metadata>;
    /**
     * Creates a new CallCredentials object from properties of both this and
     * another CallCredentials object. This object's metadata generator will be
     * called first.
     * @param callCredentials The other CallCredentials object.
     */
    abstract compose(callCredentials: CallCredentials): CallCredentials;
    /**
     * Check whether two call credentials objects are equal. Separate
     * SingleCallCredentials with identical metadata generator functions are
     * equal.
     * @param other The other CallCredentials object to compare with.
     */
    abstract _equals(other: CallCredentials): boolean;
    /**
     * Creates a new CallCredentials object from a given function that generates
     * Metadata objects.
     * @param metadataGenerator A function that accepts a set of options, and
     * generates a Metadata object based on these options, which is passed back
     * to the caller via a supplied (err, metadata) callback.
     */
    static createFromMetadataGenerator(metadataGenerator: CallMetadataGenerator): CallCredentials;
    /**
     * Create a gRPC credential from a Google credential object.
     * @param googleCredentials The authentication client to use.
     * @return The resulting CallCredentials object.
     */
    static createFromGoogleCredential(googleCredentials: OAuth2Client): CallCredentials;
    static createEmpty(): CallCredentials;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallCredentials = void 0;
const metadata_1 = require("./metadata");
function isCurrentOauth2Client(client) {
    return ('getRequestHeaders' in client &&
        typeof client.getRequestHeaders === 'function');
}
/**
 * A class that represents a generic method of adding authentication-related
 * metadata on a per-request basis.
 */
class CallCredentials {
    /**
     * Creates a new CallCredentials object from a given function that generates
     * Metadata objects.
     * @param metadataGenerator A function that accepts a set of options, and
     * generates a Metadata object based on these options, which is passed back
     * to the caller via a supplied (err, metadata) callback.
     */
    static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
    }
    /**
     * Create a gRPC credential from a Google credential object.
     * @param googleCredentials The authentication client to use.
     * @return The resulting CallCredentials object.
     */
    static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options, callback) => {
            let getHeaders;
            if (isCurrentOauth2Client(googleCredentials)) {
                getHeaders = googleCredentials.getRequestHeaders(options.service_url);
            }
            else {
                getHeaders = new Promise((resolve, reject) => {
                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        if (!headers) {
                            reject(new Error('Headers not set by metadata plugin'));
                            return;
                        }
                        resolve(headers);
                    });
                });
            }
            getHeaders.then(headers => {
                const metadata = new metadata_1.Metadata();
                for (const key of Object.keys(headers)) {
                    metadata.add(key, headers[key]);
                }
                callback(null, metadata);
            }, err => {
                callback(err);
            });
        });
    }
    static createEmpty() {
        return new EmptyCallCredentials();
    }
}
exports.CallCredentials = CallCredentials;
class ComposedCallCredentials extends CallCredentials {
    constructor(creds) {
        super();
        this.creds = creds;
    }
    async generateMetadata(options) {
        const base = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));
        for (const gen of generated) {
            base.merge(gen);
        }
        return base;
    }
    compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof ComposedCallCredentials) {
            return this.creds.every((value, index) => value._equals(other.creds[index]));
        }
        else {
            return false;
        }
    }
}
class SingleCallCredentials extends CallCredentials {
    constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
    }
    generateMetadata(options) {
        return new Promise((resolve, reject) => {
            this.metadataGenerator(options, (err, metadata) => {
                if (metadata !== undefined) {
                    resolve(metadata);
                }
                else {
                    reject(err);
                }
            });
        });
    }
    compose(other) {
        return new ComposedCallCredentials([this, other]);
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof SingleCallCredentials) {
            return this.metadataGenerator === other.metadataGenerator;
        }
        else {
            return false;
        }
    }
}
class EmptyCallCredentials extends CallCredentials {
    generateMetadata(options) {
        return Promise.resolve(new metadata_1.Metadata());
    }
    compose(other) {
        return other;
    }
    _equals(other) {
        return other instanceof EmptyCallCredentials;
    }
}
//# sourceMappingURL=call-credentials.js.map{"version":3,"file":"call-credentials.js","sourceRoot":"","sources":["../../src/call-credentials.ts"],"names":[],"mappings":"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"}import { CallCredentials } from './call-credentials';
import { Status } from './constants';
import { Deadline } from './deadline';
import { Metadata } from './metadata';
import { ServerSurfaceCall } from './server-call';
export interface CallStreamOptions {
    deadline: Deadline;
    flags: number;
    host: string;
    parentCall: ServerSurfaceCall | null;
}
export type PartialCallStreamOptions = Partial<CallStreamOptions>;
export interface StatusObject {
    code: Status;
    details: string;
    metadata: Metadata;
}
export type PartialStatusObject = Pick<StatusObject, 'code' | 'details'> & {
    metadata?: Metadata | null | undefined;
};
export declare const enum WriteFlags {
    BufferHint = 1,
    NoCompress = 2,
    WriteThrough = 4
}
export interface WriteObject {
    message: Buffer;
    flags?: number;
}
export interface MetadataListener {
    (metadata: Metadata, next: (metadata: Metadata) => void): void;
}
export interface MessageListener {
    (message: any, next: (message: any) => void): void;
}
export interface StatusListener {
    (status: StatusObject, next: (status: StatusObject) => void): void;
}
export interface FullListener {
    onReceiveMetadata: MetadataListener;
    onReceiveMessage: MessageListener;
    onReceiveStatus: StatusListener;
}
export type Listener = Partial<FullListener>;
/**
 * An object with methods for handling the responses to a call.
 */
export interface InterceptingListener {
    onReceiveMetadata(metadata: Metadata): void;
    onReceiveMessage(message: any): void;
    onReceiveStatus(status: StatusObject): void;
}
export declare function isInterceptingListener(listener: Listener | InterceptingListener): listener is InterceptingListener;
export declare class InterceptingListenerImpl implements InterceptingListener {
    private listener;
    private nextListener;
    private processingMetadata;
    private hasPendingMessage;
    private pendingMessage;
    private processingMessage;
    private pendingStatus;
    constructor(listener: FullListener, nextListener: InterceptingListener);
    private processPendingMessage;
    private processPendingStatus;
    onReceiveMetadata(metadata: Metadata): void;
    onReceiveMessage(message: any): void;
    onReceiveStatus(status: StatusObject): void;
}
export interface WriteCallback {
    (error?: Error | null): void;
}
export interface MessageContext {
    callback?: WriteCallback;
    flags?: number;
}
export interface Call {
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    start(metadata: Metadata, listener: InterceptingListener): void;
    sendMessageWithContext(context: MessageContext, message: Buffer): void;
    startRead(): void;
    halfClose(): void;
    getCallNumber(): number;
    setCredentials(credentials: CallCredentials): void;
}
export interface DeadlineInfoProvider {
    getDeadlineInfo(): string[];
}
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterceptingListenerImpl = void 0;
exports.isInterceptingListener = isInterceptingListener;
function isInterceptingListener(listener) {
    return (listener.onReceiveMetadata !== undefined &&
        listener.onReceiveMetadata.length === 1);
}
class InterceptingListenerImpl {
    constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.processingMessage = false;
        this.pendingStatus = null;
    }
    processPendingMessage() {
        if (this.hasPendingMessage) {
            this.nextListener.onReceiveMessage(this.pendingMessage);
            this.pendingMessage = null;
            this.hasPendingMessage = false;
        }
    }
    processPendingStatus() {
        if (this.pendingStatus) {
            this.nextListener.onReceiveStatus(this.pendingStatus);
        }
    }
    onReceiveMetadata(metadata) {
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, metadata => {
            this.processingMetadata = false;
            this.nextListener.onReceiveMetadata(metadata);
            this.processPendingMessage();
            this.processPendingStatus();
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    onReceiveMessage(message) {
        /* If this listener processes messages asynchronously, the last message may
         * be reordered with respect to the status */
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, msg => {
            this.processingMessage = false;
            if (this.processingMetadata) {
                this.pendingMessage = msg;
                this.hasPendingMessage = true;
            }
            else {
                this.nextListener.onReceiveMessage(msg);
                this.processPendingStatus();
            }
        });
    }
    onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, processedStatus => {
            if (this.processingMetadata || this.processingMessage) {
                this.pendingStatus = processedStatus;
            }
            else {
                this.nextListener.onReceiveStatus(processedStatus);
            }
        });
    }
}
exports.InterceptingListenerImpl = InterceptingListenerImpl;
//# sourceMappingURL=call-interface.js.map{"version":3,"file":"call-interface.js","sourceRoot":"","sources":["../../src/call-interface.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAqEH,wDAOC;AAPD,SAAgB,sBAAsB,CACpC,QAAyC;IAEzC,OAAO,CACL,QAAQ,CAAC,iBAAiB,KAAK,SAAS;QACxC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,KAAK,CAAC,CACxC,CAAC;AACJ,CAAC;AAED,MAAa,wBAAwB;IAMnC,YACU,QAAsB,EACtB,YAAkC;QADlC,aAAQ,GAAR,QAAQ,CAAc;QACtB,iBAAY,GAAZ,YAAY,CAAsB;QAPpC,uBAAkB,GAAG,KAAK,CAAC;QAC3B,sBAAiB,GAAG,KAAK,CAAC;QAE1B,sBAAiB,GAAG,KAAK,CAAC;QAC1B,kBAAa,GAAwB,IAAI,CAAC;IAI/C,CAAC;IAEI,qBAAqB;QAC3B,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC3B,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACxD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;YAC3B,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;QACjC,CAAC;IACH,CAAC;IAEO,oBAAoB;QAC1B,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACxD,CAAC;IACH,CAAC;IAED,iBAAiB,CAAC,QAAkB;QAClC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;YACnD,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;YAChC,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;YAC9C,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC7B,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC9B,CAAC,CAAC,CAAC;IACL,CAAC;IACD,8DAA8D;IAC9D,gBAAgB,CAAC,OAAY;QAC3B;qDAC6C;QAC7C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;QAC9B,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,CAAC,EAAE;YAC5C,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;YAC/B,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;gBAC5B,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC;gBAC1B,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAChC,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;gBACxC,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC9B,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IACD,eAAe,CAAC,MAAoB;QAClC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,MAAM,EAAE,eAAe,CAAC,EAAE;YACtD,IAAI,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACtD,IAAI,CAAC,aAAa,GAAG,eAAe,CAAC;YACvC,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;YACrD,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AA3DD,4DA2DC"}export declare function getNextCallNumber(): number;
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextCallNumber = getNextCallNumber;
let nextCallNumber = 0;
function getNextCallNumber() {
    return nextCallNumber++;
}
//# sourceMappingURL=call-number.js.map{"version":3,"file":"call-number.js","sourceRoot":"","sources":["../../src/call-number.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAIH,8CAEC;AAJD,IAAI,cAAc,GAAG,CAAC,CAAC;AAEvB,SAAgB,iBAAiB;IAC/B,OAAO,cAAc,EAAE,CAAC;AAC1B,CAAC"}import { EventEmitter } from 'events';
import { Duplex, Readable, Writable } from 'stream';
import { StatusObject } from './call-interface';
import { EmitterAugmentation1 } from './events';
import { Metadata } from './metadata';
import { ObjectReadable, ObjectWritable, WriteCallback } from './object-stream';
import { InterceptingCallInterface } from './client-interceptors';
/**
 * A type extending the built-in Error object with additional fields.
 */
export type ServiceError = StatusObject & Error;
/**
 * A base type for all user-facing values returned by client-side method calls.
 */
export type SurfaceCall = {
    call?: InterceptingCallInterface;
    cancel(): void;
    getPeer(): string;
} & EmitterAugmentation1<'metadata', Metadata> & EmitterAugmentation1<'status', StatusObject> & EventEmitter;
/**
 * A type representing the return value of a unary method call.
 */
export type ClientUnaryCall = SurfaceCall;
/**
 * A type representing the return value of a server stream method call.
 */
export type ClientReadableStream<ResponseType> = {
    deserialize: (chunk: Buffer) => ResponseType;
} & SurfaceCall & ObjectReadable<ResponseType>;
/**
 * A type representing the return value of a client stream method call.
 */
export type ClientWritableStream<RequestType> = {
    serialize: (value: RequestType) => Buffer;
} & SurfaceCall & ObjectWritable<RequestType>;
/**
 * A type representing the return value of a bidirectional stream method call.
 */
export type ClientDuplexStream<RequestType, ResponseType> = ClientWritableStream<RequestType> & ClientReadableStream<ResponseType>;
/**
 * Construct a ServiceError from a StatusObject. This function exists primarily
 * as an attempt to make the error stack trace clearly communicate that the
 * error is not necessarily a problem in gRPC itself.
 * @param status
 */
export declare function callErrorFromStatus(status: StatusObject, callerStack: string): ServiceError;
export declare class ClientUnaryCallImpl extends EventEmitter implements ClientUnaryCall {
    call?: InterceptingCallInterface;
    constructor();
    cancel(): void;
    getPeer(): string;
}
export declare class ClientReadableStreamImpl<ResponseType> extends Readable implements ClientReadableStream<ResponseType> {
    readonly deserialize: (chunk: Buffer) => ResponseType;
    call?: InterceptingCallInterface;
    constructor(deserialize: (chunk: Buffer) => ResponseType);
    cancel(): void;
    getPeer(): string;
    _read(_size: number): void;
}
export declare class ClientWritableStreamImpl<RequestType> extends Writable implements ClientWritableStream<RequestType> {
    readonly serialize: (value: RequestType) => Buffer;
    call?: InterceptingCallInterface;
    constructor(serialize: (value: RequestType) => Buffer);
    cancel(): void;
    getPeer(): string;
    _write(chunk: RequestType, encoding: string, cb: WriteCallback): void;
    _final(cb: Function): void;
}
export declare class ClientDuplexStreamImpl<RequestType, ResponseType> extends Duplex implements ClientDuplexStream<RequestType, ResponseType> {
    readonly serialize: (value: RequestType) => Buffer;
    readonly deserialize: (chunk: Buffer) => ResponseType;
    call?: InterceptingCallInterface;
    constructor(serialize: (value: RequestType) => Buffer, deserialize: (chunk: Buffer) => ResponseType);
    cancel(): void;
    getPeer(): string;
    _read(_size: number): void;
    _write(chunk: RequestType, encoding: string, cb: WriteCallback): void;
    _final(cb: Function): void;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = void 0;
exports.callErrorFromStatus = callErrorFromStatus;
const events_1 = require("events");
const stream_1 = require("stream");
const constants_1 = require("./constants");
/**
 * Construct a ServiceError from a StatusObject. This function exists primarily
 * as an attempt to make the error stack trace clearly communicate that the
 * error is not necessarily a problem in gRPC itself.
 * @param status
 */
function callErrorFromStatus(status, callerStack) {
    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
    const error = new Error(message);
    const stack = `${error.stack}\nfor call at\n${callerStack}`;
    return Object.assign(new Error(message), status, { stack });
}
class ClientUnaryCallImpl extends events_1.EventEmitter {
    constructor() {
        super();
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
}
exports.ClientUnaryCallImpl = ClientUnaryCallImpl;
class ClientReadableStreamImpl extends stream_1.Readable {
    constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
}
exports.ClientReadableStreamImpl = ClientReadableStreamImpl;
class ClientWritableStreamImpl extends stream_1.Writable {
    constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _write(chunk, encoding, cb) {
        var _a;
        const context = {
            callback: cb,
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
            context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
    }
}
exports.ClientWritableStreamImpl = ClientWritableStreamImpl;
class ClientDuplexStreamImpl extends stream_1.Duplex {
    constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
    }
    cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
    }
    _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
    _write(chunk, encoding, cb) {
        var _a;
        const context = {
            callback: cb,
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
            context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
    }
}
exports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
//# sourceMappingURL=call.js.map{"version":3,"file":"call.js","sourceRoot":"","sources":["../../src/call.ts"],"names":[],"mappings":"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"}import { ConnectionOptions, PeerCertificate, SecureContext } from 'tls';
import { CallCredentials } from './call-credentials';
/**
 * A callback that will receive the expected hostname and presented peer
 * certificate as parameters. The callback should return an error to
 * indicate that the presented certificate is considered invalid and
 * otherwise returned undefined.
 */
export type CheckServerIdentityCallback = (hostname: string, cert: PeerCertificate) => Error | undefined;
/**
 * Additional peer verification options that can be set when creating
 * SSL credentials.
 */
export interface VerifyOptions {
    /**
     * If set, this callback will be invoked after the usual hostname verification
     * has been performed on the peer certificate.
     */
    checkServerIdentity?: CheckServerIdentityCallback;
}
/**
 * A class that contains credentials for communicating over a channel, as well
 * as a set of per-call credentials, which are applied to every method call made
 * over a channel initialized with an instance of this class.
 */
export declare abstract class ChannelCredentials {
    protected callCredentials: CallCredentials;
    protected constructor(callCredentials?: CallCredentials);
    /**
     * Returns a copy of this object with the included set of per-call credentials
     * expanded to include callCredentials.
     * @param callCredentials A CallCredentials object to associate with this
     * instance.
     */
    abstract compose(callCredentials: CallCredentials): ChannelCredentials;
    /**
     * Gets the set of per-call credentials associated with this instance.
     */
    _getCallCredentials(): CallCredentials;
    /**
     * Gets a SecureContext object generated from input parameters if this
     * instance was created with createSsl, or null if this instance was created
     * with createInsecure.
     */
    abstract _getConnectionOptions(): ConnectionOptions | null;
    /**
     * Indicates whether this credentials object creates a secure channel.
     */
    abstract _isSecure(): boolean;
    /**
     * Check whether two channel credentials objects are equal. Two secure
     * credentials are equal if they were constructed with the same parameters.
     * @param other The other ChannelCredentials Object
     */
    abstract _equals(other: ChannelCredentials): boolean;
    /**
     * Return a new ChannelCredentials instance with a given set of credentials.
     * The resulting instance can be used to construct a Channel that communicates
     * over TLS.
     * @param rootCerts The root certificate data.
     * @param privateKey The client certificate private key, if available.
     * @param certChain The client certificate key chain, if available.
     * @param verifyOptions Additional options to modify certificate verification
     */
    static createSsl(rootCerts?: Buffer | null, privateKey?: Buffer | null, certChain?: Buffer | null, verifyOptions?: VerifyOptions): ChannelCredentials;
    /**
     * Return a new ChannelCredentials instance with credentials created using
     * the provided secureContext. The resulting instances can be used to
     * construct a Channel that communicates over TLS. gRPC will not override
     * anything in the provided secureContext, so the environment variables
     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
     * not be applied.
     * @param secureContext The return value of tls.createSecureContext()
     * @param verifyOptions Additional options to modify certificate verification
     */
    static createFromSecureContext(secureContext: SecureContext, verifyOptions?: VerifyOptions): ChannelCredentials;
    /**
     * Return a new ChannelCredentials instance with no credentials.
     */
    static createInsecure(): ChannelCredentials;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelCredentials = void 0;
const tls_1 = require("tls");
const call_credentials_1 = require("./call-credentials");
const tls_helpers_1 = require("./tls-helpers");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function verifyIsBufferOrNull(obj, friendlyName) {
    if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
    }
}
/**
 * A class that contains credentials for communicating over a channel, as well
 * as a set of per-call credentials, which are applied to every method call made
 * over a channel initialized with an instance of this class.
 */
class ChannelCredentials {
    constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
    }
    /**
     * Gets the set of per-call credentials associated with this instance.
     */
    _getCallCredentials() {
        return this.callCredentials;
    }
    /**
     * Return a new ChannelCredentials instance with a given set of credentials.
     * The resulting instance can be used to construct a Channel that communicates
     * over TLS.
     * @param rootCerts The root certificate data.
     * @param privateKey The client certificate private key, if available.
     * @param certChain The client certificate key chain, if available.
     * @param verifyOptions Additional options to modify certificate verification
     */
    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        var _a;
        verifyIsBufferOrNull(rootCerts, 'Root certificate');
        verifyIsBufferOrNull(privateKey, 'Private key');
        verifyIsBufferOrNull(certChain, 'Certificate chain');
        if (privateKey && !certChain) {
            throw new Error('Private key must be given with accompanying certificate chain');
        }
        if (!privateKey && certChain) {
            throw new Error('Certificate chain must be given with accompanying private key');
        }
        const secureContext = (0, tls_1.createSecureContext)({
            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,
            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,
            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,
            ciphers: tls_helpers_1.CIPHER_SUITES,
        });
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
    }
    /**
     * Return a new ChannelCredentials instance with credentials created using
     * the provided secureContext. The resulting instances can be used to
     * construct a Channel that communicates over TLS. gRPC will not override
     * anything in the provided secureContext, so the environment variables
     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
     * not be applied.
     * @param secureContext The return value of tls.createSecureContext()
     * @param verifyOptions Additional options to modify certificate verification
     */
    static createFromSecureContext(secureContext, verifyOptions) {
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
    }
    /**
     * Return a new ChannelCredentials instance with no credentials.
     */
    static createInsecure() {
        return new InsecureChannelCredentialsImpl();
    }
}
exports.ChannelCredentials = ChannelCredentials;
class InsecureChannelCredentialsImpl extends ChannelCredentials {
    constructor() {
        super();
    }
    compose(callCredentials) {
        throw new Error('Cannot compose insecure credentials');
    }
    _getConnectionOptions() {
        return null;
    }
    _isSecure() {
        return false;
    }
    _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
    }
}
class SecureChannelCredentialsImpl extends ChannelCredentials {
    constructor(secureContext, verifyOptions) {
        super();
        this.secureContext = secureContext;
        this.verifyOptions = verifyOptions;
        this.connectionOptions = {
            secureContext,
        };
        // Node asserts that this option is a function, so we cannot pass undefined
        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {
            this.connectionOptions.checkServerIdentity =
                verifyOptions.checkServerIdentity;
        }
    }
    compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
    }
    _getConnectionOptions() {
        // Copy to prevent callers from mutating this.connectionOptions
        return Object.assign({}, this.connectionOptions);
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
            return (this.secureContext === other.secureContext &&
                this.verifyOptions.checkServerIdentity ===
                    other.verifyOptions.checkServerIdentity);
        }
        else {
            return false;
        }
    }
}
class ComposedChannelCredentialsImpl extends ChannelCredentials {
    constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
    }
    compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
    }
    _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
    }
    _isSecure() {
        return true;
    }
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
            return (this.channelCredentials._equals(other.channelCredentials) &&
                this.callCredentials._equals(other.callCredentials));
        }
        else {
            return false;
        }
    }
}
//# sourceMappingURL=channel-credentials.js.map{"version":3,"file":"channel-credentials.js","sourceRoot":"","sources":["../../src/channel-credentials.ts"],"names":[],"mappings":"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"}import { CompressionAlgorithms } from './compression-algorithms';
/**
 * An interface that contains options used when initializing a Channel instance.
 */
export interface ChannelOptions {
    'grpc.ssl_target_name_override'?: string;
    'grpc.primary_user_agent'?: string;
    'grpc.secondary_user_agent'?: string;
    'grpc.default_authority'?: string;
    'grpc.keepalive_time_ms'?: number;
    'grpc.keepalive_timeout_ms'?: number;
    'grpc.keepalive_permit_without_calls'?: number;
    'grpc.service_config'?: string;
    'grpc.max_concurrent_streams'?: number;
    'grpc.initial_reconnect_backoff_ms'?: number;
    'grpc.max_reconnect_backoff_ms'?: number;
    'grpc.use_local_subchannel_pool'?: number;
    'grpc.max_send_message_length'?: number;
    'grpc.max_receive_message_length'?: number;
    'grpc.enable_http_proxy'?: number;
    'grpc.http_connect_target'?: string;
    'grpc.http_connect_creds'?: string;
    'grpc.default_compression_algorithm'?: CompressionAlgorithms;
    'grpc.enable_channelz'?: number;
    'grpc.dns_min_time_between_resolutions_ms'?: number;
    'grpc.enable_retries'?: number;
    'grpc.per_rpc_retry_buffer_size'?: number;
    'grpc.retry_buffer_size'?: number;
    'grpc.max_connection_age_ms'?: number;
    'grpc.max_connection_age_grace_ms'?: number;
    'grpc.max_connection_idle_ms'?: number;
    'grpc-node.max_session_memory'?: number;
    'grpc.service_config_disable_resolution'?: number;
    'grpc.client_idle_timeout_ms'?: number;
    /**
     * Set the enableTrace option in TLS clients and servers
     */
    'grpc-node.tls_enable_trace'?: number;
    'grpc.lb.ring_hash.ring_size_cap'?: number;
    'grpc-node.retry_max_attempts_limit'?: number;
    [key: string]: any;
}
/**
 * This is for checking provided options at runtime. This is an object for
 * easier membership checking.
 */
export declare const recognizedOptions: {
    'grpc.ssl_target_name_override': boolean;
    'grpc.primary_user_agent': boolean;
    'grpc.secondary_user_agent': boolean;
    'grpc.default_authority': boolean;
    'grpc.keepalive_time_ms': boolean;
    'grpc.keepalive_timeout_ms': boolean;
    'grpc.keepalive_permit_without_calls': boolean;
    'grpc.service_config': boolean;
    'grpc.max_concurrent_streams': boolean;
    'grpc.initial_reconnect_backoff_ms': boolean;
    'grpc.max_reconnect_backoff_ms': boolean;
    'grpc.use_local_subchannel_pool': boolean;
    'grpc.max_send_message_length': boolean;
    'grpc.max_receive_message_length': boolean;
    'grpc.enable_http_proxy': boolean;
    'grpc.enable_channelz': boolean;
    'grpc.dns_min_time_between_resolutions_ms': boolean;
    'grpc.enable_retries': boolean;
    'grpc.per_rpc_retry_buffer_size': boolean;
    'grpc.retry_buffer_size': boolean;
    'grpc.max_connection_age_ms': boolean;
    'grpc.max_connection_age_grace_ms': boolean;
    'grpc-node.max_session_memory': boolean;
    'grpc.service_config_disable_resolution': boolean;
    'grpc.client_idle_timeout_ms': boolean;
    'grpc-node.tls_enable_trace': boolean;
    'grpc.lb.ring_hash.ring_size_cap': boolean;
    'grpc-node.retry_max_attempts_limit': boolean;
};
export declare function channelOptionsEqual(options1: ChannelOptions, options2: ChannelOptions): boolean;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.recognizedOptions = void 0;
exports.channelOptionsEqual = channelOptionsEqual;
/**
 * This is for checking provided options at runtime. This is an object for
 * easier membership checking.
 */
exports.recognizedOptions = {
    'grpc.ssl_target_name_override': true,
    'grpc.primary_user_agent': true,
    'grpc.secondary_user_agent': true,
    'grpc.default_authority': true,
    'grpc.keepalive_time_ms': true,
    'grpc.keepalive_timeout_ms': true,
    'grpc.keepalive_permit_without_calls': true,
    'grpc.service_config': true,
    'grpc.max_concurrent_streams': true,
    'grpc.initial_reconnect_backoff_ms': true,
    'grpc.max_reconnect_backoff_ms': true,
    'grpc.use_local_subchannel_pool': true,
    'grpc.max_send_message_length': true,
    'grpc.max_receive_message_length': true,
    'grpc.enable_http_proxy': true,
    'grpc.enable_channelz': true,
    'grpc.dns_min_time_between_resolutions_ms': true,
    'grpc.enable_retries': true,
    'grpc.per_rpc_retry_buffer_size': true,
    'grpc.retry_buffer_size': true,
    'grpc.max_connection_age_ms': true,
    'grpc.max_connection_age_grace_ms': true,
    'grpc-node.max_session_memory': true,
    'grpc.service_config_disable_resolution': true,
    'grpc.client_idle_timeout_ms': true,
    'grpc-node.tls_enable_trace': true,
    'grpc.lb.ring_hash.ring_size_cap': true,
    'grpc-node.retry_max_attempts_limit': true,
};
function channelOptionsEqual(options1, options2) {
    const keys1 = Object.keys(options1).sort();
    const keys2 = Object.keys(options2).sort();
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
            return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=channel-options.js.map{"version":3,"file":"channel-options.js","sourceRoot":"","sources":["../../src/channel-options.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AA0FH,kDAkBC;AArDD;;;GAGG;AACU,QAAA,iBAAiB,GAAG;IAC/B,+BAA+B,EAAE,IAAI;IACrC,yBAAyB,EAAE,IAAI;IAC/B,2BAA2B,EAAE,IAAI;IACjC,wBAAwB,EAAE,IAAI;IAC9B,wBAAwB,EAAE,IAAI;IAC9B,2BAA2B,EAAE,IAAI;IACjC,qCAAqC,EAAE,IAAI;IAC3C,qBAAqB,EAAE,IAAI;IAC3B,6BAA6B,EAAE,IAAI;IACnC,mCAAmC,EAAE,IAAI;IACzC,+BAA+B,EAAE,IAAI;IACrC,gCAAgC,EAAE,IAAI;IACtC,8BAA8B,EAAE,IAAI;IACpC,iCAAiC,EAAE,IAAI;IACvC,wBAAwB,EAAE,IAAI;IAC9B,sBAAsB,EAAE,IAAI;IAC5B,0CAA0C,EAAE,IAAI;IAChD,qBAAqB,EAAE,IAAI;IAC3B,gCAAgC,EAAE,IAAI;IACtC,wBAAwB,EAAE,IAAI;IAC9B,4BAA4B,EAAE,IAAI;IAClC,kCAAkC,EAAE,IAAI;IACxC,8BAA8B,EAAE,IAAI;IACpC,wCAAwC,EAAE,IAAI;IAC9C,6BAA6B,EAAE,IAAI;IACnC,4BAA4B,EAAE,IAAI;IAClC,iCAAiC,EAAE,IAAI;IACvC,oCAAoC,EAAE,IAAI;CAC3C,CAAC;AAEF,SAAgB,mBAAmB,CACjC,QAAwB,EACxB,QAAwB;IAExB,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,CAAC;IAC3C,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,CAAC;IAC3C,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE,CAAC;QAClC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QACzC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;YAC1B,OAAO,KAAK,CAAC;QACf,CAAC;QACD,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAC9C,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC"}import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { ServerSurfaceCall } from './server-call';
import { ConnectivityState } from './connectivity-state';
import type { ChannelRef } from './channelz';
import { Call } from './call-interface';
import { Deadline } from './deadline';
/**
 * An interface that represents a communication channel to a server specified
 * by a given address.
 */
export interface Channel {
    /**
     * Close the channel. This has the same functionality as the existing
     * grpc.Client.prototype.close
     */
    close(): void;
    /**
     * Return the target that this channel connects to
     */
    getTarget(): string;
    /**
     * Get the channel's current connectivity state. This method is here mainly
     * because it is in the existing internal Channel class, and there isn't
     * another good place to put it.
     * @param tryToConnect If true, the channel will start connecting if it is
     *     idle. Otherwise, idle channels will only start connecting when a
     *     call starts.
     */
    getConnectivityState(tryToConnect: boolean): ConnectivityState;
    /**
     * Watch for connectivity state changes. This is also here mainly because
     * it is in the existing external Channel class.
     * @param currentState The state to watch for transitions from. This should
     *     always be populated by calling getConnectivityState immediately
     *     before.
     * @param deadline A deadline for waiting for a state change
     * @param callback Called with no error when a state change, or with an
     *     error if the deadline passes without a state change.
     */
    watchConnectivityState(currentState: ConnectivityState, deadline: Date | number, callback: (error?: Error) => void): void;
    /**
     * Get the channelz reference object for this channel. A request to the
     * channelz service for the id in this object will provide information
     * about this channel.
     */
    getChannelzRef(): ChannelRef;
    /**
     * Create a call object. Call is an opaque type that is used by the Client
     * class. This function is called by the gRPC library when starting a
     * request. Implementers should return an instance of Call that is returned
     * from calling createCall on an instance of the provided Channel class.
     * @param method The full method string to request.
     * @param deadline The call deadline
     * @param host A host string override for making the request
     * @param parentCall A server call to propagate some information from
     * @param propagateFlags A bitwise combination of elements of grpc.propagate
     *     that indicates what information to propagate from parentCall.
     */
    createCall(method: string, deadline: Deadline, host: string | null | undefined, parentCall: ServerSurfaceCall | null, propagateFlags: number | null | undefined): Call;
}
export declare class ChannelImplementation implements Channel {
    private internalChannel;
    constructor(target: string, credentials: ChannelCredentials, options: ChannelOptions);
    close(): void;
    getTarget(): string;
    getConnectivityState(tryToConnect: boolean): ConnectivityState;
    watchConnectivityState(currentState: ConnectivityState, deadline: Date | number, callback: (error?: Error) => void): void;
    /**
     * Get the channelz reference object for this channel. The returned value is
     * garbage if channelz is disabled for this channel.
     * @returns
     */
    getChannelzRef(): ChannelRef;
    createCall(method: string, deadline: Deadline, host: string | null | undefined, parentCall: ServerSurfaceCall | null, propagateFlags: number | null | undefined): Call;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelImplementation = void 0;
const channel_credentials_1 = require("./channel-credentials");
const internal_channel_1 = require("./internal-channel");
class ChannelImplementation {
    constructor(target, credentials, options) {
        if (typeof target !== 'string') {
            throw new TypeError('Channel target must be a string');
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
            throw new TypeError('Channel credentials must be a ChannelCredentials object');
        }
        if (options) {
            if (typeof options !== 'object') {
                throw new TypeError('Channel options must be an object');
            }
        }
        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
    }
    close() {
        this.internalChannel.close();
    }
    getTarget() {
        return this.internalChannel.getTarget();
    }
    getConnectivityState(tryToConnect) {
        return this.internalChannel.getConnectivityState(tryToConnect);
    }
    watchConnectivityState(currentState, deadline, callback) {
        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
    }
    /**
     * Get the channelz reference object for this channel. The returned value is
     * garbage if channelz is disabled for this channel.
     * @returns
     */
    getChannelzRef() {
        return this.internalChannel.getChannelzRef();
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== 'string') {
            throw new TypeError('Channel#createCall: method must be a string');
        }
        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
            throw new TypeError('Channel#createCall: deadline must be a number or Date');
        }
        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
    }
}
exports.ChannelImplementation = ChannelImplementation;
//# sourceMappingURL=channel.js.map{"version":3,"file":"channel.js","sourceRoot":"","sources":["../../src/channel.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAEH,+DAA2D;AAO3D,yDAAqD;AAoErD,MAAa,qBAAqB;IAGhC,YACE,MAAc,EACd,WAA+B,EAC/B,OAAuB;QAEvB,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE,CAAC;YAC/B,MAAM,IAAI,SAAS,CAAC,iCAAiC,CAAC,CAAC;QACzD,CAAC;QACD,IAAI,CAAC,CAAC,WAAW,YAAY,wCAAkB,CAAC,EAAE,CAAC;YACjD,MAAM,IAAI,SAAS,CACjB,yDAAyD,CAC1D,CAAC;QACJ,CAAC;QACD,IAAI,OAAO,EAAE,CAAC;YACZ,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;gBAChC,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;YAC3D,CAAC;QACH,CAAC;QAED,IAAI,CAAC,eAAe,GAAG,IAAI,kCAAe,CAAC,MAAM,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;IAC3E,CAAC;IAED,KAAK;QACH,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;IAC/B,CAAC;IAED,SAAS;QACP,OAAO,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,CAAC;IAC1C,CAAC;IAED,oBAAoB,CAAC,YAAqB;QACxC,OAAO,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,YAAY,CAAC,CAAC;IACjE,CAAC;IAED,sBAAsB,CACpB,YAA+B,EAC/B,QAAuB,EACvB,QAAiC;QAEjC,IAAI,CAAC,eAAe,CAAC,sBAAsB,CACzC,YAAY,EACZ,QAAQ,EACR,QAAQ,CACT,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,cAAc;QACZ,OAAO,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;IAC/C,CAAC;IAED,UAAU,CACR,MAAc,EACd,QAAkB,EAClB,IAA+B,EAC/B,UAAoC,EACpC,cAAyC;QAEzC,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE,CAAC;YAC/B,MAAM,IAAI,SAAS,CAAC,6CAA6C,CAAC,CAAC;QACrE,CAAC;QACD,IAAI,CAAC,CAAC,OAAO,QAAQ,KAAK,QAAQ,IAAI,QAAQ,YAAY,IAAI,CAAC,EAAE,CAAC;YAChE,MAAM,IAAI,SAAS,CACjB,uDAAuD,CACxD,CAAC;QACJ,CAAC;QACD,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU,CACpC,MAAM,EACN,QAAQ,EACR,IAAI,EACJ,UAAU,EACV,cAAc,CACf,CAAC;IACJ,CAAC;CACF;AAjFD,sDAiFC"}import { OrderedMap } from '@js-sdsl/ordered-map';
import { ConnectivityState } from './connectivity-state';
import { ChannelTrace } from './generated/grpc/channelz/v1/ChannelTrace';
import { SubchannelAddress } from './subchannel-address';
import { ChannelzDefinition, ChannelzHandlers } from './generated/grpc/channelz/v1/Channelz';
export type TraceSeverity = 'CT_UNKNOWN' | 'CT_INFO' | 'CT_WARNING' | 'CT_ERROR';
interface Ref {
    kind: EntityTypes;
    id: number;
    name: string;
}
export interface ChannelRef extends Ref {
    kind: EntityTypes.channel;
}
export interface SubchannelRef extends Ref {
    kind: EntityTypes.subchannel;
}
export interface ServerRef extends Ref {
    kind: EntityTypes.server;
}
export interface SocketRef extends Ref {
    kind: EntityTypes.socket;
}
interface TraceEvent {
    description: string;
    severity: TraceSeverity;
    timestamp: Date;
    childChannel?: ChannelRef;
    childSubchannel?: SubchannelRef;
}
export declare class ChannelzTraceStub {
    readonly events: TraceEvent[];
    readonly creationTimestamp: Date;
    readonly eventsLogged = 0;
    addTrace(): void;
    getTraceMessage(): ChannelTrace;
}
export declare class ChannelzTrace {
    events: TraceEvent[];
    creationTimestamp: Date;
    eventsLogged: number;
    constructor();
    addTrace(severity: TraceSeverity, description: string, child?: ChannelRef | SubchannelRef): void;
    getTraceMessage(): ChannelTrace;
}
export declare class ChannelzChildrenTracker {
    private channelChildren;
    private subchannelChildren;
    private socketChildren;
    private trackerMap;
    refChild(child: ChannelRef | SubchannelRef | SocketRef): void;
    unrefChild(child: ChannelRef | SubchannelRef | SocketRef): void;
    getChildLists(): ChannelzChildren;
}
export declare class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
    refChild(): void;
    unrefChild(): void;
}
export declare class ChannelzCallTracker {
    callsStarted: number;
    callsSucceeded: number;
    callsFailed: number;
    lastCallStartedTimestamp: Date | null;
    addCallStarted(): void;
    addCallSucceeded(): void;
    addCallFailed(): void;
}
export declare class ChannelzCallTrackerStub extends ChannelzCallTracker {
    addCallStarted(): void;
    addCallSucceeded(): void;
    addCallFailed(): void;
}
export interface ChannelzChildren {
    channels: OrderedMap<number, {
        ref: ChannelRef;
        count: number;
    }>;
    subchannels: OrderedMap<number, {
        ref: SubchannelRef;
        count: number;
    }>;
    sockets: OrderedMap<number, {
        ref: SocketRef;
        count: number;
    }>;
}
export interface ChannelInfo {
    target: string;
    state: ConnectivityState;
    trace: ChannelzTrace | ChannelzTraceStub;
    callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;
    children: ChannelzChildren;
}
export type SubchannelInfo = ChannelInfo;
export interface ServerInfo {
    trace: ChannelzTrace;
    callTracker: ChannelzCallTracker;
    listenerChildren: ChannelzChildren;
    sessionChildren: ChannelzChildren;
}
export interface TlsInfo {
    cipherSuiteStandardName: string | null;
    cipherSuiteOtherName: string | null;
    localCertificate: Buffer | null;
    remoteCertificate: Buffer | null;
}
export interface SocketInfo {
    localAddress: SubchannelAddress | null;
    remoteAddress: SubchannelAddress | null;
    security: TlsInfo | null;
    remoteName: string | null;
    streamsStarted: number;
    streamsSucceeded: number;
    streamsFailed: number;
    messagesSent: number;
    messagesReceived: number;
    keepAlivesSent: number;
    lastLocalStreamCreatedTimestamp: Date | null;
    lastRemoteStreamCreatedTimestamp: Date | null;
    lastMessageSentTimestamp: Date | null;
    lastMessageReceivedTimestamp: Date | null;
    localFlowControlWindow: number | null;
    remoteFlowControlWindow: number | null;
}
interface ChannelEntry {
    ref: ChannelRef;
    getInfo(): ChannelInfo;
}
interface SubchannelEntry {
    ref: SubchannelRef;
    getInfo(): SubchannelInfo;
}
interface ServerEntry {
    ref: ServerRef;
    getInfo(): ServerInfo;
}
interface SocketEntry {
    ref: SocketRef;
    getInfo(): SocketInfo;
}
export declare const enum EntityTypes {
    channel = "channel",
    subchannel = "subchannel",
    server = "server",
    socket = "socket"
}
export type RefByType<T extends EntityTypes> = T extends EntityTypes.channel ? ChannelRef : T extends EntityTypes.server ? ServerRef : T extends EntityTypes.socket ? SocketRef : T extends EntityTypes.subchannel ? SubchannelRef : never;
export type EntryByType<T extends EntityTypes> = T extends EntityTypes.channel ? ChannelEntry : T extends EntityTypes.server ? ServerEntry : T extends EntityTypes.socket ? SocketEntry : T extends EntityTypes.subchannel ? SubchannelEntry : never;
export type InfoByType<T extends EntityTypes> = T extends EntityTypes.channel ? ChannelInfo : T extends EntityTypes.subchannel ? SubchannelInfo : T extends EntityTypes.server ? ServerInfo : T extends EntityTypes.socket ? SocketInfo : never;
export declare const registerChannelzChannel: (name: string, getInfo: () => InfoByType<EntityTypes.channel>, channelzEnabled: boolean) => RefByType<EntityTypes.channel>;
export declare const registerChannelzSubchannel: (name: string, getInfo: () => InfoByType<EntityTypes.subchannel>, channelzEnabled: boolean) => RefByType<EntityTypes.subchannel>;
export declare const registerChannelzServer: (name: string, getInfo: () => InfoByType<EntityTypes.server>, channelzEnabled: boolean) => RefByType<EntityTypes.server>;
export declare const registerChannelzSocket: (name: string, getInfo: () => InfoByType<EntityTypes.socket>, channelzEnabled: boolean) => RefByType<EntityTypes.socket>;
export declare function unregisterChannelzRef(ref: ChannelRef | SubchannelRef | ServerRef | SocketRef): void;
export declare function getChannelzHandlers(): ChannelzHandlers;
export declare function getChannelzServiceDefinition(): ChannelzDefinition;
export declare function setup(): void;
export {};
"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = void 0;
exports.unregisterChannelzRef = unregisterChannelzRef;
exports.getChannelzHandlers = getChannelzHandlers;
exports.getChannelzServiceDefinition = getChannelzServiceDefinition;
exports.setup = setup;
const net_1 = require("net");
const ordered_map_1 = require("@js-sdsl/ordered-map");
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const subchannel_address_1 = require("./subchannel-address");
const admin_1 = require("./admin");
const make_client_1 = require("./make-client");
function channelRefToMessage(ref) {
    return {
        channel_id: ref.id,
        name: ref.name,
    };
}
function subchannelRefToMessage(ref) {
    return {
        subchannel_id: ref.id,
        name: ref.name,
    };
}
function serverRefToMessage(ref) {
    return {
        server_id: ref.id,
    };
}
function socketRefToMessage(ref) {
    return {
        socket_id: ref.id,
        name: ref.name,
    };
}
/**
 * The loose upper bound on the number of events that should be retained in a
 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
 * number that should be large enough to contain the recent relevant
 * information, but small enough to not use excessive memory.
 */
const TARGET_RETAINED_TRACES = 32;
/**
 * Default number of sockets/servers/channels/subchannels to return
 */
const DEFAULT_MAX_RESULTS = 100;
class ChannelzTraceStub {
    constructor() {
        this.events = [];
        this.creationTimestamp = new Date();
        this.eventsLogged = 0;
    }
    addTrace() { }
    getTraceMessage() {
        return {
            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
            num_events_logged: this.eventsLogged,
            events: [],
        };
    }
}
exports.ChannelzTraceStub = ChannelzTraceStub;
class ChannelzTrace {
    constructor() {
        this.events = [];
        this.eventsLogged = 0;
        this.creationTimestamp = new Date();
    }
    addTrace(severity, description, child) {
        const timestamp = new Date();
        this.events.push({
            description: description,
            severity: severity,
            timestamp: timestamp,
            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,
            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,
        });
        // Whenever the trace array gets too large, discard the first half
        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
            this.events = this.events.slice(TARGET_RETAINED_TRACES);
        }
        this.eventsLogged += 1;
    }
    getTraceMessage() {
        return {
            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
            num_events_logged: this.eventsLogged,
            events: this.events.map(event => {
                return {
                    description: event.description,
                    severity: event.severity,
                    timestamp: dateToProtoTimestamp(event.timestamp),
                    channel_ref: event.childChannel
                        ? channelRefToMessage(event.childChannel)
                        : null,
                    subchannel_ref: event.childSubchannel
                        ? subchannelRefToMessage(event.childSubchannel)
                        : null,
                };
            }),
        };
    }
}
exports.ChannelzTrace = ChannelzTrace;
class ChannelzChildrenTracker {
    constructor() {
        this.channelChildren = new ordered_map_1.OrderedMap();
        this.subchannelChildren = new ordered_map_1.OrderedMap();
        this.socketChildren = new ordered_map_1.OrderedMap();
        this.trackerMap = {
            ["channel" /* EntityTypes.channel */]: this.channelChildren,
            ["subchannel" /* EntityTypes.subchannel */]: this.subchannelChildren,
            ["socket" /* EntityTypes.socket */]: this.socketChildren,
        };
    }
    refChild(child) {
        const tracker = this.trackerMap[child.kind];
        const trackedChild = tracker.find(child.id);
        if (trackedChild.equals(tracker.end())) {
            tracker.setElement(child.id, {
                ref: child,
                count: 1,
            }, trackedChild);
        }
        else {
            trackedChild.pointer[1].count += 1;
        }
    }
    unrefChild(child) {
        const tracker = this.trackerMap[child.kind];
        const trackedChild = tracker.getElementByKey(child.id);
        if (trackedChild !== undefined) {
            trackedChild.count -= 1;
            if (trackedChild.count === 0) {
                tracker.eraseElementByKey(child.id);
            }
        }
    }
    getChildLists() {
        return {
            channels: this.channelChildren,
            subchannels: this.subchannelChildren,
            sockets: this.socketChildren,
        };
    }
}
exports.ChannelzChildrenTracker = ChannelzChildrenTracker;
class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
    refChild() { }
    unrefChild() { }
}
exports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;
class ChannelzCallTracker {
    constructor() {
        this.callsStarted = 0;
        this.callsSucceeded = 0;
        this.callsFailed = 0;
        this.lastCallStartedTimestamp = null;
    }
    addCallStarted() {
        this.callsStarted += 1;
        this.lastCallStartedTimestamp = new Date();
    }
    addCallSucceeded() {
        this.callsSucceeded += 1;
    }
    addCallFailed() {
        this.callsFailed += 1;
    }
}
exports.ChannelzCallTracker = ChannelzCallTracker;
class ChannelzCallTrackerStub extends ChannelzCallTracker {
    addCallStarted() { }
    addCallSucceeded() { }
    addCallFailed() { }
}
exports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
const entityMaps = {
    ["channel" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),
    ["subchannel" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),
    ["server" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),
    ["socket" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap(),
};
const generateRegisterFn = (kind) => {
    let nextId = 1;
    function getNextId() {
        return nextId++;
    }
    const entityMap = entityMaps[kind];
    return (name, getInfo, channelzEnabled) => {
        const id = getNextId();
        const ref = { id, name, kind };
        if (channelzEnabled) {
            entityMap.setElement(id, { ref, getInfo });
        }
        return ref;
    };
};
exports.registerChannelzChannel = generateRegisterFn("channel" /* EntityTypes.channel */);
exports.registerChannelzSubchannel = generateRegisterFn("subchannel" /* EntityTypes.subchannel */);
exports.registerChannelzServer = generateRegisterFn("server" /* EntityTypes.server */);
exports.registerChannelzSocket = generateRegisterFn("socket" /* EntityTypes.socket */);
function unregisterChannelzRef(ref) {
    entityMaps[ref.kind].eraseElementByKey(ref.id);
}
/**
 * Parse a single section of an IPv6 address as two bytes
 * @param addressSection A hexadecimal string of length up to 4
 * @returns The pair of bytes representing this address section
 */
function parseIPv6Section(addressSection) {
    const numberValue = Number.parseInt(addressSection, 16);
    return [(numberValue / 256) | 0, numberValue % 256];
}
/**
 * Parse a chunk of an IPv6 address string to some number of bytes
 * @param addressChunk Some number of segments of up to 4 hexadecimal
 *   characters each, joined by colons.
 * @returns The list of bytes representing this address chunk
 */
function parseIPv6Chunk(addressChunk) {
    if (addressChunk === '') {
        return [];
    }
    const bytePairs = addressChunk
        .split(':')
        .map(section => parseIPv6Section(section));
    const result = [];
    return result.concat(...bytePairs);
}
/**
 * Converts an IPv4 or IPv6 address from string representation to binary
 * representation
 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
 * @returns
 */
function ipAddressStringToBuffer(ipAddress) {
    if ((0, net_1.isIPv4)(ipAddress)) {
        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));
    }
    else if ((0, net_1.isIPv6)(ipAddress)) {
        let leftSection;
        let rightSection;
        const doubleColonIndex = ipAddress.indexOf('::');
        if (doubleColonIndex === -1) {
            leftSection = ipAddress;
            rightSection = '';
        }
        else {
            leftSection = ipAddress.substring(0, doubleColonIndex);
            rightSection = ipAddress.substring(doubleColonIndex + 2);
        }
        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
    }
    else {
        return null;
    }
}
function connectivityStateToMessage(state) {
    switch (state) {
        case connectivity_state_1.ConnectivityState.CONNECTING:
            return {
                state: 'CONNECTING',
            };
        case connectivity_state_1.ConnectivityState.IDLE:
            return {
                state: 'IDLE',
            };
        case connectivity_state_1.ConnectivityState.READY:
            return {
                state: 'READY',
            };
        case connectivity_state_1.ConnectivityState.SHUTDOWN:
            return {
                state: 'SHUTDOWN',
            };
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
            return {
                state: 'TRANSIENT_FAILURE',
            };
        default:
            return {
                state: 'UNKNOWN',
            };
    }
}
function dateToProtoTimestamp(date) {
    if (!date) {
        return null;
    }
    const millisSinceEpoch = date.getTime();
    return {
        seconds: (millisSinceEpoch / 1000) | 0,
        nanos: (millisSinceEpoch % 1000) * 1000000,
    };
}
function getChannelMessage(channelEntry) {
    const resolvedInfo = channelEntry.getInfo();
    const channelRef = [];
    const subchannelRef = [];
    resolvedInfo.children.channels.forEach(el => {
        channelRef.push(channelRefToMessage(el[1].ref));
    });
    resolvedInfo.children.subchannels.forEach(el => {
        subchannelRef.push(subchannelRefToMessage(el[1].ref));
    });
    return {
        ref: channelRefToMessage(channelEntry.ref),
        data: {
            target: resolvedInfo.target,
            state: connectivityStateToMessage(resolvedInfo.state),
            calls_started: resolvedInfo.callTracker.callsStarted,
            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
            calls_failed: resolvedInfo.callTracker.callsFailed,
            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
            trace: resolvedInfo.trace.getTraceMessage(),
        },
        channel_ref: channelRef,
        subchannel_ref: subchannelRef,
    };
}
function GetChannel(call, callback) {
    const channelId = parseInt(call.request.channel_id, 10);
    const channelEntry = entityMaps["channel" /* EntityTypes.channel */].getElementByKey(channelId);
    if (channelEntry === undefined) {
        callback({
            code: constants_1.Status.NOT_FOUND,
            details: 'No channel data found for id ' + channelId,
        });
        return;
    }
    callback(null, { channel: getChannelMessage(channelEntry) });
}
function GetTopChannels(call, callback) {
    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
    const resultList = [];
    const startId = parseInt(call.request.start_channel_id, 10);
    const channelEntries = entityMaps["channel" /* EntityTypes.channel */];
    let i;
    for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {
        resultList.push(getChannelMessage(i.pointer[1]));
    }
    callback(null, {
        channel: resultList,
        end: i.equals(channelEntries.end()),
    });
}
function getServerMessage(serverEntry) {
    const resolvedInfo = serverEntry.getInfo();
    const listenSocket = [];
    resolvedInfo.listenerChildren.sockets.forEach(el => {
        listenSocket.push(socketRefToMessage(el[1].ref));
    });
    return {
        ref: serverRefToMessage(serverEntry.ref),
        data: {
            calls_started: resolvedInfo.callTracker.callsStarted,
            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
            calls_failed: resolvedInfo.callTracker.callsFailed,
            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
            trace: resolvedInfo.trace.getTraceMessage(),
        },
        listen_socket: listenSocket,
    };
}
function GetServer(call, callback) {
    const serverId = parseInt(call.request.server_id, 10);
    const serverEntries = entityMaps["server" /* EntityTypes.server */];
    const serverEntry = serverEntries.getElementByKey(serverId);
    if (serverEntry === undefined) {
        callback({
            code: constants_1.Status.NOT_FOUND,
            details: 'No server data found for id ' + serverId,
        });
        return;
    }
    callback(null, { server: getServerMessage(serverEntry) });
}
function GetServers(call, callback) {
    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
    const startId = parseInt(call.request.start_server_id, 10);
    const serverEntries = entityMaps["server" /* EntityTypes.server */];
    const resultList = [];
    let i;
    for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {
        resultList.push(getServerMessage(i.pointer[1]));
    }
    callback(null, {
        server: resultList,
        end: i.equals(serverEntries.end()),
    });
}
function GetSubchannel(call, callback) {
    const subchannelId = parseInt(call.request.subchannel_id, 10);
    const subchannelEntry = entityMaps["subchannel" /* EntityTypes.subchannel */].getElementByKey(subchannelId);
    if (subchannelEntry === undefined) {
        callback({
            code: constants_1.Status.NOT_FOUND,
            details: 'No subchannel data found for id ' + subchannelId,
        });
        return;
    }
    const resolvedInfo = subchannelEntry.getInfo();
    const listenSocket = [];
    resolvedInfo.children.sockets.forEach(el => {
        listenSocket.push(socketRefToMessage(el[1].ref));
    });
    const subchannelMessage = {
        ref: subchannelRefToMessage(subchannelEntry.ref),
        data: {
            target: resolvedInfo.target,
            state: connectivityStateToMessage(resolvedInfo.state),
            calls_started: resolvedInfo.callTracker.callsStarted,
            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
            calls_failed: resolvedInfo.callTracker.callsFailed,
            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
            trace: resolvedInfo.trace.getTraceMessage(),
        },
        socket_ref: listenSocket,
    };
    callback(null, { subchannel: subchannelMessage });
}
function subchannelAddressToAddressMessage(subchannelAddress) {
    var _a;
    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
        return {
            address: 'tcpip_address',
            tcpip_address: {
                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,
                port: subchannelAddress.port,
            },
        };
    }
    else {
        return {
            address: 'uds_address',
            uds_address: {
                filename: subchannelAddress.path,
            },
        };
    }
}
function GetSocket(call, callback) {
    var _a, _b, _c, _d, _e;
    const socketId = parseInt(call.request.socket_id, 10);
    const socketEntry = entityMaps["socket" /* EntityTypes.socket */].getElementByKey(socketId);
    if (socketEntry === undefined) {
        callback({
            code: constants_1.Status.NOT_FOUND,
            details: 'No socket data found for id ' + socketId,
        });
        return;
    }
    const resolvedInfo = socketEntry.getInfo();
    const securityMessage = resolvedInfo.security
        ? {
            model: 'tls',
            tls: {
                cipher_suite: resolvedInfo.security.cipherSuiteStandardName
                    ? 'standard_name'
                    : 'other_name',
                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,
                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,
                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,
                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,
            },
        }
        : null;
    const socketMessage = {
        ref: socketRefToMessage(socketEntry.ref),
        local: resolvedInfo.localAddress
            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)
            : null,
        remote: resolvedInfo.remoteAddress
            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)
            : null,
        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,
        security: securityMessage,
        data: {
            keep_alives_sent: resolvedInfo.keepAlivesSent,
            streams_started: resolvedInfo.streamsStarted,
            streams_succeeded: resolvedInfo.streamsSucceeded,
            streams_failed: resolvedInfo.streamsFailed,
            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
            messages_received: resolvedInfo.messagesReceived,
            messages_sent: resolvedInfo.messagesSent,
            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
            local_flow_control_window: resolvedInfo.localFlowControlWindow
                ? { value: resolvedInfo.localFlowControlWindow }
                : null,
            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow
                ? { value: resolvedInfo.remoteFlowControlWindow }
                : null,
        },
    };
    callback(null, { socket: socketMessage });
}
function GetServerSockets(call, callback) {
    const serverId = parseInt(call.request.server_id, 10);
    const serverEntry = entityMaps["server" /* EntityTypes.server */].getElementByKey(serverId);
    if (serverEntry === undefined) {
        callback({
            code: constants_1.Status.NOT_FOUND,
            details: 'No server data found for id ' + serverId,
        });
        return;
    }
    const startId = parseInt(call.request.start_socket_id, 10);
    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
    const resolvedInfo = serverEntry.getInfo();
    // If we wanted to include listener sockets in the result, this line would
    // instead say
    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
    const allSockets = resolvedInfo.sessionChildren.sockets;
    const resultList = [];
    let i;
    for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {
        resultList.push(socketRefToMessage(i.pointer[1].ref));
    }
    callback(null, {
        socket_ref: resultList,
        end: i.equals(allSockets.end()),
    });
}
function getChannelzHandlers() {
    return {
        GetChannel,
        GetTopChannels,
        GetServer,
        GetServers,
        GetSubchannel,
        GetSocket,
        GetServerSockets,
    };
}
let loadedChannelzDefinition = null;
function getChannelzServiceDefinition() {
    if (loadedChannelzDefinition) {
        return loadedChannelzDefinition;
    }
    /* The purpose of this complexity is to avoid loading @postman/proto-loader at
     * runtime for users who will not use/enable channelz. */
    const loaderLoadSync = require('@postman/proto-loader')
        .loadSync;
    const loadedProto = loaderLoadSync('channelz.proto', {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        includeDirs: [`${__dirname}/../../proto`],
    });
    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
    loadedChannelzDefinition =
        channelzGrpcObject.grpc.channelz.v1.Channelz.service;
    return loadedChannelzDefinition;
}
function setup() {
    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
}
//# sourceMappingURL=channelz.js.map{"version":3,"file":"channelz.js","sourceRoot":"","sources":["../../src/channelz.ts"],"names":[],"mappings":"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"}import { Metadata } from './metadata';
import { Listener, MetadataListener, MessageListener, StatusListener, InterceptingListener, MessageContext } from './call-interface';
import { Status } from './constants';
import { Channel } from './channel';
import { CallOptions } from './client';
import { ClientMethodDefinition } from './make-client';
/**
 * Error class associated with passing both interceptors and interceptor
 * providers to a client constructor or as call options.
 */
export declare class InterceptorConfigurationError extends Error {
    constructor(message: string);
}
export interface MetadataRequester {
    (metadata: Metadata, listener: InterceptingListener, next: (metadata: Metadata, listener: InterceptingListener | Listener) => void): void;
}
export interface MessageRequester {
    (message: any, next: (message: any) => void): void;
}
export interface CloseRequester {
    (next: () => void): void;
}
export interface CancelRequester {
    (next: () => void): void;
}
/**
 * An object with methods for intercepting and modifying outgoing call operations.
 */
export interface FullRequester {
    start: MetadataRequester;
    sendMessage: MessageRequester;
    halfClose: CloseRequester;
    cancel: CancelRequester;
}
export type Requester = Partial<FullRequester>;
export declare class ListenerBuilder {
    private metadata;
    private message;
    private status;
    withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this;
    withOnReceiveMessage(onReceiveMessage: MessageListener): this;
    withOnReceiveStatus(onReceiveStatus: StatusListener): this;
    build(): Listener;
}
export declare class RequesterBuilder {
    private start;
    private message;
    private halfClose;
    private cancel;
    withStart(start: MetadataRequester): this;
    withSendMessage(sendMessage: MessageRequester): this;
    withHalfClose(halfClose: CloseRequester): this;
    withCancel(cancel: CancelRequester): this;
    build(): Requester;
}
export interface InterceptorOptions extends CallOptions {
    method_definition: ClientMethodDefinition<any, any>;
}
export interface InterceptingCallInterface {
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;
    sendMessageWithContext(context: MessageContext, message: any): void;
    sendMessage(message: any): void;
    startRead(): void;
    halfClose(): void;
}
export declare class InterceptingCall implements InterceptingCallInterface {
    private nextCall;
    /**
     * The requester that this InterceptingCall uses to modify outgoing operations
     */
    private requester;
    /**
     * Indicates that metadata has been passed to the requester's start
     * method but it has not been passed to the corresponding next callback
     */
    private processingMetadata;
    /**
     * Message context for a pending message that is waiting for
     */
    private pendingMessageContext;
    private pendingMessage;
    /**
     * Indicates that a message has been passed to the requester's sendMessage
     * method but it has not been passed to the corresponding next callback
     */
    private processingMessage;
    /**
     * Indicates that a status was received but could not be propagated because
     * a message was still being processed.
     */
    private pendingHalfClose;
    constructor(nextCall: InterceptingCallInterface, requester?: Requester);
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    private processPendingMessage;
    private processPendingHalfClose;
    start(metadata: Metadata, interceptingListener?: Partial<InterceptingListener>): void;
    sendMessageWithContext(context: MessageContext, message: any): void;
    sendMessage(message: any): void;
    startRead(): void;
    halfClose(): void;
}
export interface NextCall {
    (options: InterceptorOptions): InterceptingCallInterface;
}
export interface Interceptor {
    (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;
}
export interface InterceptorProvider {
    (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;
}
export interface InterceptorArguments {
    clientInterceptors: Interceptor[];
    clientInterceptorProviders: InterceptorProvider[];
    callInterceptors: Interceptor[];
    callInterceptorProviders: InterceptorProvider[];
}
export declare function getInterceptingCall(interceptorArgs: InterceptorArguments, methodDefinition: ClientMethodDefinition<any, any>, options: CallOptions, channel: Channel): InterceptingCallInterface;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;
exports.getInterceptingCall = getInterceptingCall;
const metadata_1 = require("./metadata");
const call_interface_1 = require("./call-interface");
const constants_1 = require("./constants");
const error_1 = require("./error");
/**
 * Error class associated with passing both interceptors and interceptor
 * providers to a client constructor or as call options.
 */
class InterceptorConfigurationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InterceptorConfigurationError';
        Error.captureStackTrace(this, InterceptorConfigurationError);
    }
}
exports.InterceptorConfigurationError = InterceptorConfigurationError;
class ListenerBuilder {
    constructor() {
        this.metadata = undefined;
        this.message = undefined;
        this.status = undefined;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
    }
    withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
    }
    build() {
        return {
            onReceiveMetadata: this.metadata,
            onReceiveMessage: this.message,
            onReceiveStatus: this.status,
        };
    }
}
exports.ListenerBuilder = ListenerBuilder;
class RequesterBuilder {
    constructor() {
        this.start = undefined;
        this.message = undefined;
        this.halfClose = undefined;
        this.cancel = undefined;
    }
    withStart(start) {
        this.start = start;
        return this;
    }
    withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
    }
    withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
    }
    withCancel(cancel) {
        this.cancel = cancel;
        return this;
    }
    build() {
        return {
            start: this.start,
            sendMessage: this.message,
            halfClose: this.halfClose,
            cancel: this.cancel,
        };
    }
}
exports.RequesterBuilder = RequesterBuilder;
/**
 * A Listener with a default pass-through implementation of each method. Used
 * for filling out Listeners with some methods omitted.
 */
const defaultListener = {
    onReceiveMetadata: (metadata, next) => {
        next(metadata);
    },
    onReceiveMessage: (message, next) => {
        next(message);
    },
    onReceiveStatus: (status, next) => {
        next(status);
    },
};
/**
 * A Requester with a default pass-through implementation of each method. Used
 * for filling out Requesters with some methods omitted.
 */
const defaultRequester = {
    start: (metadata, listener, next) => {
        next(metadata, listener);
    },
    sendMessage: (message, next) => {
        next(message);
    },
    halfClose: next => {
        next();
    },
    cancel: next => {
        next();
    },
};
class InterceptingCall {
    constructor(nextCall, requester) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        /**
         * Indicates that metadata has been passed to the requester's start
         * method but it has not been passed to the corresponding next callback
         */
        this.processingMetadata = false;
        /**
         * Message context for a pending message that is waiting for
         */
        this.pendingMessageContext = null;
        /**
         * Indicates that a message has been passed to the requester's sendMessage
         * method but it has not been passed to the corresponding next callback
         */
        this.processingMessage = false;
        /**
         * Indicates that a status was received but could not be propagated because
         * a message was still being processed.
         */
        this.pendingHalfClose = false;
        if (requester) {
            this.requester = {
                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,
            };
        }
        else {
            this.requester = defaultRequester;
        }
    }
    cancelWithStatus(status, details) {
        this.requester.cancel(() => {
            this.nextCall.cancelWithStatus(status, details);
        });
    }
    getPeer() {
        return this.nextCall.getPeer();
    }
    processPendingMessage() {
        if (this.pendingMessageContext) {
            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
            this.pendingMessageContext = null;
            this.pendingMessage = null;
        }
    }
    processPendingHalfClose() {
        if (this.pendingHalfClose) {
            this.nextCall.halfClose();
        }
    }
    start(metadata, interceptingListener) {
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = {
            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),
            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),
            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),
        };
        this.processingMetadata = true;
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
            var _a, _b, _c;
            this.processingMetadata = false;
            let finalInterceptingListener;
            if ((0, call_interface_1.isInterceptingListener)(listener)) {
                finalInterceptingListener = listener;
            }
            else {
                const fullListener = {
                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,
                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,
                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,
                };
                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
            }
            this.nextCall.start(md, finalInterceptingListener);
            this.processPendingMessage();
            this.processPendingHalfClose();
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, finalMessage => {
            this.processingMessage = false;
            if (this.processingMetadata) {
                this.pendingMessageContext = context;
                this.pendingMessage = message;
            }
            else {
                this.nextCall.sendMessageWithContext(context, finalMessage);
                this.processPendingHalfClose();
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage(message) {
        this.sendMessageWithContext({}, message);
    }
    startRead() {
        this.nextCall.startRead();
    }
    halfClose() {
        this.requester.halfClose(() => {
            if (this.processingMetadata || this.processingMessage) {
                this.pendingHalfClose = true;
            }
            else {
                this.nextCall.halfClose();
            }
        });
    }
}
exports.InterceptingCall = InterceptingCall;
function getCall(channel, path, options) {
    var _a, _b;
    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
    const host = options.host;
    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
    const propagateFlags = options.propagate_flags;
    const credentials = options.credentials;
    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
    if (credentials) {
        call.setCredentials(credentials);
    }
    return call;
}
/**
 * InterceptingCall implementation that directly owns the underlying Call
 * object and handles serialization and deseraizliation.
 */
class BaseInterceptingCall {
    constructor(call, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
    }
    cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
    }
    getPeer() {
        return this.call.getPeer();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessageWithContext(context, message) {
        let serialized;
        try {
            serialized = this.methodDefinition.requestSerialize(message);
        }
        catch (e) {
            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);
            return;
        }
        this.call.sendMessageWithContext(context, serialized);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage(message) {
        this.sendMessageWithContext({}, message);
    }
    start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
            onReceiveMetadata: metadata => {
                var _a;
                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);
            },
            onReceiveMessage: message => {
                var _a;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let deserialized;
                try {
                    deserialized = this.methodDefinition.responseDeserialize(message);
                }
                catch (e) {
                    readError = {
                        code: constants_1.Status.INTERNAL,
                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,
                        metadata: new metadata_1.Metadata(),
                    };
                    this.call.cancelWithStatus(readError.code, readError.details);
                    return;
                }
                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
            },
            onReceiveStatus: status => {
                var _a, _b;
                if (readError) {
                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
                }
                else {
                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
                }
            },
        });
    }
    startRead() {
        this.call.startRead();
    }
    halfClose() {
        this.call.halfClose();
    }
}
/**
 * BaseInterceptingCall with special-cased behavior for methods with unary
 * responses.
 */
class BaseUnaryInterceptingCall extends BaseInterceptingCall {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(call, methodDefinition) {
        super(call, methodDefinition);
    }
    start(metadata, listener) {
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = {
            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage: (message) => {
                var _a;
                receivedMessage = true;
                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);
            },
            onReceiveStatus: (status) => {
                var _a, _b;
                if (!receivedMessage) {
                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);
                }
                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);
            },
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
    }
}
/**
 * BaseInterceptingCall with special-cased behavior for methods with streaming
 * responses.
 */
class BaseStreamingInterceptingCall extends BaseInterceptingCall {
}
function getBottomInterceptingCall(channel, options, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
methodDefinition) {
    const call = getCall(channel, methodDefinition.path, options);
    if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
    }
    else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
    }
}
function getInterceptingCall(interceptorArgs, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
methodDefinition, options, channel) {
    if (interceptorArgs.clientInterceptors.length > 0 &&
        interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
            'to the client constructor. Only one of these is allowed.');
    }
    if (interceptorArgs.callInterceptors.length > 0 &&
        interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
            'options. Only one of these is allowed.');
    }
    let interceptors = [];
    // Interceptors passed to the call override interceptors passed to the client constructor
    if (interceptorArgs.callInterceptors.length > 0 ||
        interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = []
            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))
            .filter(interceptor => interceptor);
        // Filter out falsy values when providers return nothing
    }
    else {
        interceptors = []
            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))
            .filter(interceptor => interceptor);
        // Filter out falsy values when providers return nothing
    }
    const interceptorOptions = Object.assign({}, options, {
        method_definition: methodDefinition,
    });
    /* For each interceptor in the list, the nextCall function passed to it is
     * based on the next interceptor in the list, using a nextCall function
     * constructed with the following interceptor in the list, and so on. The
     * initialValue, which is effectively at the end of the list, is a nextCall
     * function that invokes getBottomInterceptingCall, the result of which
     * handles (de)serialization and also gets the underlying call from the
     * channel. */
    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return currentOptions => nextInterceptor(currentOptions, nextCall);
    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
    return getCall(interceptorOptions);
}
//# sourceMappingURL=client-interceptors.js.map{"version":3,"file":"client-interceptors.js","sourceRoot":"","sources":["../../src/client-interceptors.ts"],"names":[],"mappings":"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"}import { ClientDuplexStream, ClientReadableStream, ClientUnaryCall, ClientWritableStream, ServiceError, SurfaceCall } from './call';
import { CallCredentials } from './call-credentials';
import { Channel } from './channel';
import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { Metadata } from './metadata';
import { ClientMethodDefinition } from './make-client';
import { Interceptor, InterceptorProvider } from './client-interceptors';
import { ServerUnaryCall, ServerReadableStream, ServerWritableStream, ServerDuplexStream } from './server-call';
import { Deadline } from './deadline';
declare const CHANNEL_SYMBOL: unique symbol;
declare const INTERCEPTOR_SYMBOL: unique symbol;
declare const INTERCEPTOR_PROVIDER_SYMBOL: unique symbol;
declare const CALL_INVOCATION_TRANSFORMER_SYMBOL: unique symbol;
export interface UnaryCallback<ResponseType> {
    (err: ServiceError | null, value?: ResponseType): void;
}
export interface CallOptions {
    deadline?: Deadline;
    host?: string;
    parent?: ServerUnaryCall<any, any> | ServerReadableStream<any, any> | ServerWritableStream<any, any> | ServerDuplexStream<any, any>;
    propagate_flags?: number;
    credentials?: CallCredentials;
    interceptors?: Interceptor[];
    interceptor_providers?: InterceptorProvider[];
}
export interface CallProperties<RequestType, ResponseType> {
    argument?: RequestType;
    metadata: Metadata;
    call: SurfaceCall;
    channel: Channel;
    methodDefinition: ClientMethodDefinition<RequestType, ResponseType>;
    callOptions: CallOptions;
    callback?: UnaryCallback<ResponseType>;
}
export interface CallInvocationTransformer {
    (callProperties: CallProperties<any, any>): CallProperties<any, any>;
}
export type ClientOptions = Partial<ChannelOptions> & {
    channelOverride?: Channel;
    channelFactoryOverride?: (address: string, credentials: ChannelCredentials, options: ClientOptions) => Channel;
    interceptors?: Interceptor[];
    interceptor_providers?: InterceptorProvider[];
    callInvocationTransformer?: CallInvocationTransformer;
};
/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
export declare class Client {
    private readonly [CHANNEL_SYMBOL];
    private readonly [INTERCEPTOR_SYMBOL];
    private readonly [INTERCEPTOR_PROVIDER_SYMBOL];
    private readonly [CALL_INVOCATION_TRANSFORMER_SYMBOL]?;
    constructor(address: string, credentials: ChannelCredentials, options?: ClientOptions);
    close(): void;
    getChannel(): Channel;
    waitForReady(deadline: Deadline, callback: (error?: Error) => void): void;
    private checkOptionalUnaryResponseArguments;
    makeUnaryRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, metadata: Metadata, options: CallOptions, callback: UnaryCallback<ResponseType>): ClientUnaryCall;
    makeUnaryRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, metadata: Metadata, callback: UnaryCallback<ResponseType>): ClientUnaryCall;
    makeUnaryRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, options: CallOptions, callback: UnaryCallback<ResponseType>): ClientUnaryCall;
    makeUnaryRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, callback: UnaryCallback<ResponseType>): ClientUnaryCall;
    makeClientStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, metadata: Metadata, options: CallOptions, callback: UnaryCallback<ResponseType>): ClientWritableStream<RequestType>;
    makeClientStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, metadata: Metadata, callback: UnaryCallback<ResponseType>): ClientWritableStream<RequestType>;
    makeClientStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, options: CallOptions, callback: UnaryCallback<ResponseType>): ClientWritableStream<RequestType>;
    makeClientStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, callback: UnaryCallback<ResponseType>): ClientWritableStream<RequestType>;
    private checkMetadataAndOptions;
    makeServerStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, metadata: Metadata, options?: CallOptions): ClientReadableStream<ResponseType>;
    makeServerStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, argument: RequestType, options?: CallOptions): ClientReadableStream<ResponseType>;
    makeBidiStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, metadata: Metadata, options?: CallOptions): ClientDuplexStream<RequestType, ResponseType>;
    makeBidiStreamRequest<RequestType, ResponseType>(method: string, serialize: (value: RequestType) => Buffer, deserialize: (value: Buffer) => ResponseType, options?: CallOptions): ClientDuplexStream<RequestType, ResponseType>;
}
export {};
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const call_1 = require("./call");
const channel_1 = require("./channel");
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const client_interceptors_1 = require("./client-interceptors");
const CHANNEL_SYMBOL = Symbol();
const INTERCEPTOR_SYMBOL = Symbol();
const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
function isFunction(arg) {
    return typeof arg === 'function';
}
function getErrorStackString(error) {
    var _a;
    return ((_a = error.stack) === null || _a === void 0 ? void 0 : _a.split('\n').slice(1).join('\n')) || 'no stack trace available';
}
/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
class Client {
    constructor(address, credentials, options = {}) {
        var _a, _b;
        options = Object.assign({}, options);
        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
                'to the client constructor. Only one of these is allowed.');
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
            options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) {
            this[CHANNEL_SYMBOL] = options.channelOverride;
        }
        else if (options.channelFactoryOverride) {
            const channelFactoryOverride = options.channelFactoryOverride;
            delete options.channelFactoryOverride;
            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
        }
        else {
            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
        }
    }
    close() {
        this[CHANNEL_SYMBOL].close();
    }
    getChannel() {
        return this[CHANNEL_SYMBOL];
    }
    waitForReady(deadline, callback) {
        const checkState = (err) => {
            if (err) {
                callback(new Error('Failed to connect before the deadline'));
                return;
            }
            let newState;
            try {
                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
            }
            catch (e) {
                callback(new Error('The channel has been closed'));
                return;
            }
            if (newState === connectivity_state_1.ConnectivityState.READY) {
                callback();
            }
            else {
                try {
                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
                }
                catch (e) {
                    callback(new Error('The channel has been closed'));
                }
            }
        };
        setImmediate(checkState);
    }
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        }
        else if (isFunction(arg2)) {
            if (arg1 instanceof metadata_1.Metadata) {
                return { metadata: arg1, options: {}, callback: arg2 };
            }
            else {
                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
            }
        }
        else {
            if (!(arg1 instanceof metadata_1.Metadata &&
                arg2 instanceof Object &&
                isFunction(arg3))) {
                throw new Error('Incorrect arguments passed');
            }
            return { metadata: arg1, options: arg2, callback: arg3 };
        }
    }
    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
            path: method,
            requestStream: false,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            argument: argument,
            metadata: checkedArguments.metadata,
            call: new call_1.ClientUnaryCallImpl(),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
            callback: checkedArguments.callback,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
            onReceiveMetadata: metadata => {
                emitter.emit('metadata', metadata);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) {
                if (responseMessage !== null) {
                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');
                }
                responseMessage = message;
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) {
                    if (responseMessage === null) {
                        const callerStack = getErrorStackString(callerStackError);
                        callProperties.callback((0, call_1.callErrorFromStatus)({
                            code: constants_1.Status.UNIMPLEMENTED,
                            details: 'No message received',
                            metadata: status.metadata,
                        }, callerStack));
                    }
                    else {
                        callProperties.callback(null, responseMessage);
                    }
                }
                else {
                    const callerStack = getErrorStackString(callerStackError);
                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
                }
                /* Avoid retaining the callerStackError object in the call context of
                 * the status event handler. */
                callerStackError = null;
                emitter.emit('status', status);
            },
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
    }
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
            path: method,
            requestStream: true,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            metadata: checkedArguments.metadata,
            call: new call_1.ClientWritableStreamImpl(serialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
            callback: checkedArguments.callback,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
            onReceiveMetadata: metadata => {
                emitter.emit('metadata', metadata);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) {
                if (responseMessage !== null) {
                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');
                }
                responseMessage = message;
                call.startRead();
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) {
                    if (responseMessage === null) {
                        const callerStack = getErrorStackString(callerStackError);
                        callProperties.callback((0, call_1.callErrorFromStatus)({
                            code: constants_1.Status.UNIMPLEMENTED,
                            details: 'No message received',
                            metadata: status.metadata,
                        }, callerStack));
                    }
                    else {
                        callProperties.callback(null, responseMessage);
                    }
                }
                else {
                    const callerStack = getErrorStackString(callerStackError);
                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
                }
                /* Avoid retaining the callerStackError object in the call context of
                 * the status event handler. */
                callerStackError = null;
                emitter.emit('status', status);
            },
        });
        return emitter;
    }
    checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
            metadata = arg1;
            if (arg2) {
                options = arg2;
            }
            else {
                options = {};
            }
        }
        else {
            if (arg1) {
                options = arg1;
            }
            else {
                options = {};
            }
            metadata = new metadata_1.Metadata();
        }
        return { metadata, options };
    }
    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
            path: method,
            requestStream: false,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            argument: argument,
            metadata: checkedArguments.metadata,
            call: new call_1.ClientReadableStreamImpl(deserialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        stream.call = call;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
            onReceiveMetadata(metadata) {
                stream.emit('metadata', metadata);
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) {
                stream.push(message);
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) {
                    const callerStack = getErrorStackString(callerStackError);
                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
                }
                /* Avoid retaining the callerStackError object in the call context of
                 * the status event handler. */
                callerStackError = null;
                stream.emit('status', status);
            },
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
    }
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
            path: method,
            requestStream: true,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
        };
        let callProperties = {
            metadata: checkedArguments.metadata,
            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        stream.call = call;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
            onReceiveMetadata(metadata) {
                stream.emit('metadata', metadata);
            },
            onReceiveMessage(message) {
                stream.push(message);
            },
            onReceiveStatus(status) {
                if (receivedStatus) {
                    return;
                }
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) {
                    const callerStack = getErrorStackString(callerStackError);
                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
                }
                /* Avoid retaining the callerStackError object in the call context of
                 * the status event handler. */
                callerStackError = null;
                stream.emit('status', status);
            },
        });
        return stream;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"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"}export declare enum CompressionAlgorithms {
    identity = 0,
    deflate = 1,
    gzip = 2
}
"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressionAlgorithms = void 0;
var CompressionAlgorithms;
(function (CompressionAlgorithms) {
    CompressionAlgorithms[CompressionAlgorithms["identity"] = 0] = "identity";
    CompressionAlgorithms[CompressionAlgorithms["deflate"] = 1] = "deflate";
    CompressionAlgorithms[CompressionAlgorithms["gzip"] = 2] = "gzip";
})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));
//# sourceMappingURL=compression-algorithms.js.map{"version":3,"file":"compression-algorithms.js","sourceRoot":"","sources":["../../src/compression-algorithms.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAEH,IAAY,qBAIX;AAJD,WAAY,qBAAqB;IAC/B,yEAAY,CAAA;IACZ,uEAAW,CAAA;IACX,iEAAQ,CAAA;AACV,CAAC,EAJW,qBAAqB,qCAArB,qBAAqB,QAIhC"}import { WriteObject } from './call-interface';
import { Channel } from './channel';
import { ChannelOptions } from './channel-options';
import { BaseFilter, Filter, FilterFactory } from './filter';
import { Metadata } from './metadata';
type SharedCompressionFilterConfig = {
    serverSupportedEncodingHeader?: string;
};
export declare class CompressionFilter extends BaseFilter implements Filter {
    private sharedFilterConfig;
    private sendCompression;
    private receiveCompression;
    private currentCompressionAlgorithm;
    private maxReceiveMessageLength;
    private maxSendMessageLength;
    constructor(channelOptions: ChannelOptions, sharedFilterConfig: SharedCompressionFilterConfig);
    sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;
    receiveMetadata(metadata: Metadata): Metadata;
    sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;
    receiveMessage(message: Promise<Buffer>): Promise<Buffer>;
}
export declare class CompressionFilterFactory implements FilterFactory<CompressionFilter> {
    private readonly options;
    private sharedFilterConfig;
    constructor(channel: Channel, options: ChannelOptions);
    createFilter(): CompressionFilter;
}
export {};
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompressionFilterFactory = exports.CompressionFilter = void 0;
const zlib = require("zlib");
const compression_algorithms_1 = require("./compression-algorithms");
const constants_1 = require("./constants");
const filter_1 = require("./filter");
const logging = require("./logging");
const isCompressionAlgorithmKey = (key) => {
    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');
};
class CompressionHandler {
    /**
     * @param message Raw uncompressed message bytes
     * @param compress Indicates whether the message should be compressed
     * @return Framed message, compressed if applicable
     */
    async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
            messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
    }
    /**
     * @param data Framed message, possibly compressed
     * @return Uncompressed message
     */
    async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
            messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
    }
}
class IdentityHandler extends CompressionHandler {
    async compressMessage(message) {
        return message;
    }
    async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        /* With "identity" compression, messages should always be marked as
         * uncompressed */
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
    }
    decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
    }
}
class DeflateHandler extends CompressionHandler {
    constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
    }
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.deflate(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            let totalLength = 0;
            const messageParts = [];
            const decompresser = zlib.createInflate();
            decompresser.on('data', (chunk) => {
                messageParts.push(chunk);
                totalLength += chunk.byteLength;
                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
                    decompresser.destroy();
                    reject({
                        code: constants_1.Status.RESOURCE_EXHAUSTED,
                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
                    });
                }
            });
            decompresser.on('end', () => {
                resolve(Buffer.concat(messageParts));
            });
            decompresser.write(message);
            decompresser.end();
        });
    }
}
class GzipHandler extends CompressionHandler {
    constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
    }
    compressMessage(message) {
        return new Promise((resolve, reject) => {
            zlib.gzip(message, (err, output) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(output);
                }
            });
        });
    }
    decompressMessage(message) {
        return new Promise((resolve, reject) => {
            let totalLength = 0;
            const messageParts = [];
            const decompresser = zlib.createGunzip();
            decompresser.on('data', (chunk) => {
                messageParts.push(chunk);
                totalLength += chunk.byteLength;
                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
                    decompresser.destroy();
                    reject({
                        code: constants_1.Status.RESOURCE_EXHAUSTED,
                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
                    });
                }
            });
            decompresser.on('end', () => {
                resolve(Buffer.concat(messageParts));
            });
            decompresser.write(message);
            decompresser.end();
        });
    }
}
class UnknownHandler extends CompressionHandler {
    constructor(compressionName) {
        super();
        this.compressionName = compressionName;
    }
    compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
    }
    decompressMessage(message) {
        // This should be unreachable
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
    }
}
function getCompressionHandler(compressionName, maxReceiveMessageSize) {
    switch (compressionName) {
        case 'identity':
            return new IdentityHandler();
        case 'deflate':
            return new DeflateHandler(maxReceiveMessageSize);
        case 'gzip':
            return new GzipHandler(maxReceiveMessageSize);
        default:
            return new UnknownHandler(compressionName);
    }
}
class CompressionFilter extends filter_1.BaseFilter {
    constructor(channelOptions, sharedFilterConfig) {
        var _a, _b, _c;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = 'identity';
        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.maxSendMessageLength = (_b = channelOptions['grpc.max_send_message_length']) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        if (compressionAlgorithmKey !== undefined) {
            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
                const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === void 0 ? void 0 : _c.split(',');
                /**
                 * There are two possible situations here:
                 * 1) We don't have any info yet from the server about what compression it supports
                 *    In that case we should just use what the client tells us to use
                 * 2) We've previously received a response from the server including a grpc-accept-encoding header
                 *    In that case we only want to use the encoding chosen by the client if the server supports it
                 */
                if (!serverSupportedEncodings ||
                    serverSupportedEncodings.includes(clientSelectedEncoding)) {
                    this.currentCompressionAlgorithm = clientSelectedEncoding;
                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);
                }
            }
            else {
                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
            }
        }
    }
    async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
        headers.set('accept-encoding', 'identity');
        // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
        if (this.currentCompressionAlgorithm === 'identity') {
            headers.remove('grpc-encoding');
        }
        else {
            headers.set('grpc-encoding', this.currentCompressionAlgorithm);
        }
        return headers;
    }
    receiveMetadata(metadata) {
        const receiveEncoding = metadata.get('grpc-encoding');
        if (receiveEncoding.length > 0) {
            const encoding = receiveEncoding[0];
            if (typeof encoding === 'string') {
                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
            }
        }
        metadata.remove('grpc-encoding');
        /* Check to see if the compression we're using to send messages is supported by the server
         * If not, reset the sendCompression filter and have it use the default IdentityHandler */
        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];
        if (serverSupportedEncodingsHeader) {
            this.sharedFilterConfig.serverSupportedEncodingHeader =
                serverSupportedEncodingsHeader;
            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');
            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
                this.sendCompression = new IdentityHandler();
                this.currentCompressionAlgorithm = 'identity';
            }
        }
        metadata.remove('grpc-accept-encoding');
        return metadata;
    }
    async sendMessage(message) {
        var _a;
        /* This filter is special. The input message is the bare message bytes,
         * and the output is a framed and possibly compressed message. For this
         * reason, this filter should be at the bottom of the filter stack */
        const resolvedMessage = await message;
        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
            throw {
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
            };
        }
        let compress;
        if (this.sendCompression instanceof IdentityHandler) {
            compress = false;
        }
        else {
            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;
        }
        return {
            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
            flags: resolvedMessage.flags,
        };
    }
    async receiveMessage(message) {
        /* This filter is also special. The input message is framed and possibly
         * compressed, and the output message is deframed and uncompressed. So
         * this is another reason that this filter should be at the bottom of the
         * filter stack. */
        return this.receiveCompression.readMessage(await message);
    }
}
exports.CompressionFilter = CompressionFilter;
class CompressionFilterFactory {
    constructor(channel, options) {
        this.options = options;
        this.sharedFilterConfig = {};
    }
    createFilter() {
        return new CompressionFilter(this.options, this.sharedFilterConfig);
    }
}
exports.CompressionFilterFactory = CompressionFilterFactory;
//# sourceMappingURL=compression-filter.js.map{"version":3,"file":"compression-filter.js","sourceRoot":"","sources":["../../src/compression-filter.ts"],"names":[],"mappings":"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"}export declare enum ConnectivityState {
    IDLE = 0,
    CONNECTING = 1,
    READY = 2,
    TRANSIENT_FAILURE = 3,
    SHUTDOWN = 4
}
"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectivityState = void 0;
var ConnectivityState;
(function (ConnectivityState) {
    ConnectivityState[ConnectivityState["IDLE"] = 0] = "IDLE";
    ConnectivityState[ConnectivityState["CONNECTING"] = 1] = "CONNECTING";
    ConnectivityState[ConnectivityState["READY"] = 2] = "READY";
    ConnectivityState[ConnectivityState["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
    ConnectivityState[ConnectivityState["SHUTDOWN"] = 4] = "SHUTDOWN";
})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));
//# sourceMappingURL=connectivity-state.js.map{"version":3,"file":"connectivity-state.js","sourceRoot":"","sources":["../../src/connectivity-state.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAEH,IAAY,iBAMX;AAND,WAAY,iBAAiB;IAC3B,yDAAI,CAAA;IACJ,qEAAU,CAAA;IACV,2DAAK,CAAA;IACL,mFAAiB,CAAA;IACjB,iEAAQ,CAAA;AACV,CAAC,EANW,iBAAiB,iCAAjB,iBAAiB,QAM5B"}export declare enum Status {
    OK = 0,
    CANCELLED = 1,
    UNKNOWN = 2,
    INVALID_ARGUMENT = 3,
    DEADLINE_EXCEEDED = 4,
    NOT_FOUND = 5,
    ALREADY_EXISTS = 6,
    PERMISSION_DENIED = 7,
    RESOURCE_EXHAUSTED = 8,
    FAILED_PRECONDITION = 9,
    ABORTED = 10,
    OUT_OF_RANGE = 11,
    UNIMPLEMENTED = 12,
    INTERNAL = 13,
    UNAVAILABLE = 14,
    DATA_LOSS = 15,
    UNAUTHENTICATED = 16
}
export declare enum LogVerbosity {
    DEBUG = 0,
    INFO = 1,
    ERROR = 2,
    NONE = 3
}
/**
 * NOTE: This enum is not currently used in any implemented API in this
 * library. It is included only for type parity with the other implementation.
 */
export declare enum Propagate {
    DEADLINE = 1,
    CENSUS_STATS_CONTEXT = 2,
    CENSUS_TRACING_CONTEXT = 4,
    CANCELLATION = 8,
    DEFAULTS = 65535
}
export declare const DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
export declare const DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH: number;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;
var Status;
(function (Status) {
    Status[Status["OK"] = 0] = "OK";
    Status[Status["CANCELLED"] = 1] = "CANCELLED";
    Status[Status["UNKNOWN"] = 2] = "UNKNOWN";
    Status[Status["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status[Status["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status[Status["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status[Status["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status[Status["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status[Status["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status[Status["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status[Status["ABORTED"] = 10] = "ABORTED";
    Status[Status["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status[Status["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status[Status["INTERNAL"] = 13] = "INTERNAL";
    Status[Status["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status[Status["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status[Status["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(Status || (exports.Status = Status = {}));
var LogVerbosity;
(function (LogVerbosity) {
    LogVerbosity[LogVerbosity["DEBUG"] = 0] = "DEBUG";
    LogVerbosity[LogVerbosity["INFO"] = 1] = "INFO";
    LogVerbosity[LogVerbosity["ERROR"] = 2] = "ERROR";
    LogVerbosity[LogVerbosity["NONE"] = 3] = "NONE";
})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));
/**
 * NOTE: This enum is not currently used in any implemented API in this
 * library. It is included only for type parity with the other implementation.
 */
var Propagate;
(function (Propagate) {
    Propagate[Propagate["DEADLINE"] = 1] = "DEADLINE";
    Propagate[Propagate["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
    Propagate[Propagate["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
    Propagate[Propagate["CANCELLATION"] = 8] = "CANCELLATION";
    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43
    Propagate[Propagate["DEFAULTS"] = 65535] = "DEFAULTS";
})(Propagate || (exports.Propagate = Propagate = {}));
// -1 means unlimited
exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
// 4 MB default
exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
//# sourceMappingURL=constants.js.map{"version":3,"file":"constants.js","sourceRoot":"","sources":["../../src/constants.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAEH,IAAY,MAkBX;AAlBD,WAAY,MAAM;IAChB,+BAAM,CAAA;IACN,6CAAS,CAAA;IACT,yCAAO,CAAA;IACP,2DAAgB,CAAA;IAChB,6DAAiB,CAAA;IACjB,6CAAS,CAAA;IACT,uDAAc,CAAA;IACd,6DAAiB,CAAA;IACjB,+DAAkB,CAAA;IAClB,iEAAmB,CAAA;IACnB,0CAAO,CAAA;IACP,oDAAY,CAAA;IACZ,sDAAa,CAAA;IACb,4CAAQ,CAAA;IACR,kDAAW,CAAA;IACX,8CAAS,CAAA;IACT,0DAAe,CAAA;AACjB,CAAC,EAlBW,MAAM,sBAAN,MAAM,QAkBjB;AAED,IAAY,YAKX;AALD,WAAY,YAAY;IACtB,iDAAS,CAAA;IACT,+CAAI,CAAA;IACJ,iDAAK,CAAA;IACL,+CAAI,CAAA;AACN,CAAC,EALW,YAAY,4BAAZ,YAAY,QAKvB;AAED;;;GAGG;AACH,IAAY,SAWX;AAXD,WAAY,SAAS;IACnB,iDAAY,CAAA;IACZ,yEAAwB,CAAA;IACxB,6EAA0B,CAAA;IAC1B,yDAAgB,CAAA;IAChB,4FAA4F;IAC5F,qDAIwB,CAAA;AAC1B,CAAC,EAXW,SAAS,yBAAT,SAAS,QAWpB;AAED,qBAAqB;AACR,QAAA,+BAA+B,GAAG,CAAC,CAAC,CAAC;AAElD,eAAe;AACF,QAAA,kCAAkC,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC"}import { Status } from './constants';
export declare function restrictControlPlaneStatusCode(code: Status, details: string): {
    code: Status;
    details: string;
};
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
const constants_1 = require("./constants");
const INAPPROPRIATE_CONTROL_PLANE_CODES = [
    constants_1.Status.OK,
    constants_1.Status.INVALID_ARGUMENT,
    constants_1.Status.NOT_FOUND,
    constants_1.Status.ALREADY_EXISTS,
    constants_1.Status.FAILED_PRECONDITION,
    constants_1.Status.ABORTED,
    constants_1.Status.OUT_OF_RANGE,
    constants_1.Status.DATA_LOSS,
];
function restrictControlPlaneStatusCode(code, details) {
    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
        return {
            code: constants_1.Status.INTERNAL,
            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,
        };
    }
    else {
        return { code, details };
    }
}
//# sourceMappingURL=control-plane-status.js.map{"version":3,"file":"control-plane-status.js","sourceRoot":"","sources":["../../src/control-plane-status.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAeH,wEAYC;AAzBD,2CAAqC;AAErC,MAAM,iCAAiC,GAAa;IAClD,kBAAM,CAAC,EAAE;IACT,kBAAM,CAAC,gBAAgB;IACvB,kBAAM,CAAC,SAAS;IAChB,kBAAM,CAAC,cAAc;IACrB,kBAAM,CAAC,mBAAmB;IAC1B,kBAAM,CAAC,OAAO;IACd,kBAAM,CAAC,YAAY;IACnB,kBAAM,CAAC,SAAS;CACjB,CAAC;AAEF,SAAgB,8BAA8B,CAC5C,IAAY,EACZ,OAAe;IAEf,IAAI,iCAAiC,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QACrD,OAAO;YACL,IAAI,EAAE,kBAAM,CAAC,QAAQ;YACrB,OAAO,EAAE,sCAAsC,IAAI,IAAI,kBAAM,CAAC,IAAI,CAAC,IAAI,OAAO,EAAE;SACjF,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC;IAC3B,CAAC;AACH,CAAC"}export type Deadline = Date | number;
export declare function minDeadline(...deadlineList: Deadline[]): Deadline;
export declare function getDeadlineTimeoutString(deadline: Deadline): string;
/**
 * Get the timeout value that should be passed to setTimeout now for the timer
 * to end at the deadline. For any deadline before now, the timer should end
 * immediately, represented by a value of 0. For any deadline more than
 * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will
 * end at that time, so it is treated as infinitely far in the future.
 * @param deadline
 * @returns
 */
export declare function getRelativeTimeout(deadline: Deadline): number;
export declare function deadlineToString(deadline: Deadline): string;
/**
 * Calculate the difference between two dates as a number of seconds and format
 * it as a string.
 * @param startDate
 * @param endDate
 * @returns
 */
export declare function formatDateDifference(startDate: Date, endDate: Date): string;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.minDeadline = minDeadline;
exports.getDeadlineTimeoutString = getDeadlineTimeoutString;
exports.getRelativeTimeout = getRelativeTimeout;
exports.deadlineToString = deadlineToString;
exports.formatDateDifference = formatDateDifference;
function minDeadline(...deadlineList) {
    let minValue = Infinity;
    for (const deadline of deadlineList) {
        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
        if (deadlineMsecs < minValue) {
            minValue = deadlineMsecs;
        }
    }
    return minValue;
}
const units = [
    ['m', 1],
    ['S', 1000],
    ['M', 60 * 1000],
    ['H', 60 * 60 * 1000],
];
function getDeadlineTimeoutString(deadline) {
    const now = new Date().getTime();
    if (deadline instanceof Date) {
        deadline = deadline.getTime();
    }
    const timeoutMs = Math.max(deadline - now, 0);
    for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
            return String(Math.ceil(amount)) + unit;
        }
    }
    throw new Error('Deadline is too far in the future');
}
/**
 * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args
 * In particular, "When delay is larger than 2147483647 or less than 1, the
 * delay will be set to 1. Non-integer delays are truncated to an integer."
 * This number of milliseconds is almost 25 days.
 */
const MAX_TIMEOUT_TIME = 2147483647;
/**
 * Get the timeout value that should be passed to setTimeout now for the timer
 * to end at the deadline. For any deadline before now, the timer should end
 * immediately, represented by a value of 0. For any deadline more than
 * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will
 * end at that time, so it is treated as infinitely far in the future.
 * @param deadline
 * @returns
 */
function getRelativeTimeout(deadline) {
    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
    const now = new Date().getTime();
    const timeout = deadlineMs - now;
    if (timeout < 0) {
        return 0;
    }
    else if (timeout > MAX_TIMEOUT_TIME) {
        return Infinity;
    }
    else {
        return timeout;
    }
}
function deadlineToString(deadline) {
    if (deadline instanceof Date) {
        return deadline.toISOString();
    }
    else {
        const dateDeadline = new Date(deadline);
        if (Number.isNaN(dateDeadline.getTime())) {
            return '' + deadline;
        }
        else {
            return dateDeadline.toISOString();
        }
    }
}
/**
 * Calculate the difference between two dates as a number of seconds and format
 * it as a string.
 * @param startDate
 * @param endDate
 * @returns
 */
function formatDateDifference(startDate, endDate) {
    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';
}
//# sourceMappingURL=deadline.js.map{"version":3,"file":"deadline.js","sourceRoot":"","sources":["../../src/deadline.ts"],"names":[],"mappings":"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"}export interface Duration {
    seconds: number;
    nanos: number;
}
export declare function msToDuration(millis: number): Duration;
export declare function durationToMs(duration: Duration): number;
export declare function isDuration(value: any): value is Duration;
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.msToDuration = msToDuration;
exports.durationToMs = durationToMs;
exports.isDuration = isDuration;
function msToDuration(millis) {
    return {
        seconds: (millis / 1000) | 0,
        nanos: ((millis % 1000) * 1000000) | 0,
    };
}
function durationToMs(duration) {
    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;
}
function isDuration(value) {
    return typeof value.seconds === 'number' && typeof value.nanos === 'number';
}
//# sourceMappingURL=duration.js.map{"version":3,"file":"duration.js","sourceRoot":"","sources":["../../src/duration.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAOH,oCAKC;AAED,oCAEC;AAED,gCAEC;AAbD,SAAgB,YAAY,CAAC,MAAc;IACzC,OAAO;QACL,OAAO,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC;QAC5B,KAAK,EAAE,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,OAAS,CAAC,GAAG,CAAC;KACzC,CAAC;AACJ,CAAC;AAED,SAAgB,YAAY,CAAC,QAAkB;IAC7C,OAAO,CAAC,QAAQ,CAAC,OAAO,GAAG,IAAI,GAAG,QAAQ,CAAC,KAAK,GAAG,OAAS,CAAC,GAAG,CAAC,CAAC;AACpE,CAAC;AAED,SAAgB,UAAU,CAAC,KAAU;IACnC,OAAO,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,CAAC;AAC9E,CAAC"}export declare const GRPC_NODE_USE_ALTERNATIVE_RESOLVER: boolean;
"use strict";
/*
 * Copyright 2024 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = void 0;
exports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== void 0 ? _a : 'false') === 'true';
//# sourceMappingURL=environment.js.map{"version":3,"file":"environment.js","sourceRoot":"","sources":["../../src/environment.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;;AAEU,QAAA,kCAAkC,GAC7C,CAAC,MAAA,OAAO,CAAC,GAAG,CAAC,kCAAkC,mCAAI,OAAO,CAAC,KAAK,MAAM,CAAC"}export declare function getErrorMessage(error: unknown): string;
export declare function getErrorCode(error: unknown): number | null;
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorMessage = getErrorMessage;
exports.getErrorCode = getErrorCode;
function getErrorMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    else {
        return String(error);
    }
}
function getErrorCode(error) {
    if (typeof error === 'object' &&
        error !== null &&
        'code' in error &&
        typeof error.code === 'number') {
        return error.code;
    }
    else {
        return null;
    }
}
//# sourceMappingURL=error.js.map{"version":3,"file":"error.js","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAEH,0CAMC;AAED,oCAWC;AAnBD,SAAgB,eAAe,CAAC,KAAc;IAC5C,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;QAC3B,OAAO,KAAK,CAAC,OAAO,CAAC;IACvB,CAAC;SAAM,CAAC;QACN,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;AACH,CAAC;AAED,SAAgB,YAAY,CAAC,KAAc;IACzC,IACE,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,KAAK,IAAI;QACd,MAAM,IAAI,KAAK;QACf,OAAQ,KAAiC,CAAC,IAAI,KAAK,QAAQ,EAC3D,CAAC;QACD,OAAQ,KAAgC,CAAC,IAAI,CAAC;IAChD,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC"}export interface EmitterAugmentation1<Name extends string | symbol, Arg> {
    addListener(event: Name, listener: (arg1: Arg) => void): this;
    emit(event: Name, arg1: Arg): boolean;
    on(event: Name, listener: (arg1: Arg) => void): this;
    once(event: Name, listener: (arg1: Arg) => void): this;
    prependListener(event: Name, listener: (arg1: Arg) => void): this;
    prependOnceListener(event: Name, listener: (arg1: Arg) => void): this;
    removeListener(event: Name, listener: (arg1: Arg) => void): this;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=events.js.map{"version":3,"file":"events.js","sourceRoot":"","sources":["../../src/events.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG"}export { trace, log } from './logging';
export { Resolver, ResolverListener, registerResolver, ConfigSelector, createResolver, } from './resolver';
export { GrpcUri, uriToString, splitHostPort, HostPort } from './uri-parser';
export { Duration, durationToMs } from './duration';
export { BackoffTimeout } from './backoff-timeout';
export { LoadBalancer, TypedLoadBalancingConfig, ChannelControlHelper, createChildChannelControlHelper, registerLoadBalancerType, selectLbConfigFromList, parseLoadBalancingConfig, isLoadBalancerNameRegistered, } from './load-balancer';
export { LeafLoadBalancer } from './load-balancer-pick-first';
export { SubchannelAddress, subchannelAddressToString, Endpoint, endpointToString, endpointHasAddress, EndpointMap, } from './subchannel-address';
export { ChildLoadBalancerHandler } from './load-balancer-child-handler';
export { Picker, UnavailablePicker, QueuePicker, PickResult, PickArgs, PickResultType, } from './picker';
export { Call as CallStream } from './call-interface';
export { Filter, BaseFilter, FilterFactory } from './filter';
export { FilterStackFactory } from './filter-stack';
export { registerAdminService } from './admin';
export { SubchannelInterface, BaseSubchannelWrapper, ConnectivityStateListener, HealthListener, } from './subchannel-interface';
export { OutlierDetectionRawConfig, SuccessRateEjectionConfig, FailurePercentageEjectionConfig, } from './load-balancer-outlier-detection';
export { createServerCredentialsWithInterceptors } from './server-credentials';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;
var logging_1 = require("./logging");
Object.defineProperty(exports, "trace", { enumerable: true, get: function () { return logging_1.trace; } });
Object.defineProperty(exports, "log", { enumerable: true, get: function () { return logging_1.log; } });
var resolver_1 = require("./resolver");
Object.defineProperty(exports, "registerResolver", { enumerable: true, get: function () { return resolver_1.registerResolver; } });
Object.defineProperty(exports, "createResolver", { enumerable: true, get: function () { return resolver_1.createResolver; } });
var uri_parser_1 = require("./uri-parser");
Object.defineProperty(exports, "uriToString", { enumerable: true, get: function () { return uri_parser_1.uriToString; } });
Object.defineProperty(exports, "splitHostPort", { enumerable: true, get: function () { return uri_parser_1.splitHostPort; } });
var duration_1 = require("./duration");
Object.defineProperty(exports, "durationToMs", { enumerable: true, get: function () { return duration_1.durationToMs; } });
var backoff_timeout_1 = require("./backoff-timeout");
Object.defineProperty(exports, "BackoffTimeout", { enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } });
var load_balancer_1 = require("./load-balancer");
Object.defineProperty(exports, "createChildChannelControlHelper", { enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } });
Object.defineProperty(exports, "registerLoadBalancerType", { enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } });
Object.defineProperty(exports, "selectLbConfigFromList", { enumerable: true, get: function () { return load_balancer_1.selectLbConfigFromList; } });
Object.defineProperty(exports, "parseLoadBalancingConfig", { enumerable: true, get: function () { return load_balancer_1.parseLoadBalancingConfig; } });
Object.defineProperty(exports, "isLoadBalancerNameRegistered", { enumerable: true, get: function () { return load_balancer_1.isLoadBalancerNameRegistered; } });
var load_balancer_pick_first_1 = require("./load-balancer-pick-first");
Object.defineProperty(exports, "LeafLoadBalancer", { enumerable: true, get: function () { return load_balancer_pick_first_1.LeafLoadBalancer; } });
var subchannel_address_1 = require("./subchannel-address");
Object.defineProperty(exports, "subchannelAddressToString", { enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } });
Object.defineProperty(exports, "endpointToString", { enumerable: true, get: function () { return subchannel_address_1.endpointToString; } });
Object.defineProperty(exports, "endpointHasAddress", { enumerable: true, get: function () { return subchannel_address_1.endpointHasAddress; } });
Object.defineProperty(exports, "EndpointMap", { enumerable: true, get: function () { return subchannel_address_1.EndpointMap; } });
var load_balancer_child_handler_1 = require("./load-balancer-child-handler");
Object.defineProperty(exports, "ChildLoadBalancerHandler", { enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } });
var picker_1 = require("./picker");
Object.defineProperty(exports, "UnavailablePicker", { enumerable: true, get: function () { return picker_1.UnavailablePicker; } });
Object.defineProperty(exports, "QueuePicker", { enumerable: true, get: function () { return picker_1.QueuePicker; } });
Object.defineProperty(exports, "PickResultType", { enumerable: true, get: function () { return picker_1.PickResultType; } });
var filter_1 = require("./filter");
Object.defineProperty(exports, "BaseFilter", { enumerable: true, get: function () { return filter_1.BaseFilter; } });
var filter_stack_1 = require("./filter-stack");
Object.defineProperty(exports, "FilterStackFactory", { enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } });
var admin_1 = require("./admin");
Object.defineProperty(exports, "registerAdminService", { enumerable: true, get: function () { return admin_1.registerAdminService; } });
var subchannel_interface_1 = require("./subchannel-interface");
Object.defineProperty(exports, "BaseSubchannelWrapper", { enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } });
var server_credentials_1 = require("./server-credentials");
Object.defineProperty(exports, "createServerCredentialsWithInterceptors", { enumerable: true, get: function () { return server_credentials_1.createServerCredentialsWithInterceptors; } });
//# sourceMappingURL=experimental.js.map{"version":3,"file":"experimental.js","sourceRoot":"","sources":["../../src/experimental.ts"],"names":[],"mappings":";;;AAAA,qCAAuC;AAA9B,gGAAA,KAAK,OAAA;AAAE,8FAAA,GAAG,OAAA;AACnB,uCAMoB;AAHlB,4GAAA,gBAAgB,OAAA;AAEhB,0GAAA,cAAc,OAAA;AAEhB,2CAA6E;AAA3D,yGAAA,WAAW,OAAA;AAAE,2GAAA,aAAa,OAAA;AAC5C,uCAAoD;AAAjC,wGAAA,YAAY,OAAA;AAC/B,qDAAmD;AAA1C,iHAAA,cAAc,OAAA;AACvB,iDASyB;AALvB,gIAAA,+BAA+B,OAAA;AAC/B,yHAAA,wBAAwB,OAAA;AACxB,uHAAA,sBAAsB,OAAA;AACtB,yHAAA,wBAAwB,OAAA;AACxB,6HAAA,4BAA4B,OAAA;AAE9B,uEAA8D;AAArD,4HAAA,gBAAgB,OAAA;AACzB,2DAO8B;AAL5B,+HAAA,yBAAyB,OAAA;AAEzB,sHAAA,gBAAgB,OAAA;AAChB,wHAAA,kBAAkB,OAAA;AAClB,iHAAA,WAAW,OAAA;AAEb,6EAAyE;AAAhE,uIAAA,wBAAwB,OAAA;AACjC,mCAOkB;AALhB,2GAAA,iBAAiB,OAAA;AACjB,qGAAA,WAAW,OAAA;AAGX,wGAAA,cAAc,OAAA;AAGhB,mCAA6D;AAA5C,oGAAA,UAAU,OAAA;AAC3B,+CAAoD;AAA3C,kHAAA,kBAAkB,OAAA;AAC3B,iCAA+C;AAAtC,6GAAA,oBAAoB,OAAA;AAC7B,+DAKgC;AAH9B,6HAAA,qBAAqB,OAAA;AAUvB,2DAA+E;AAAtE,6IAAA,uCAAuC,OAAA"}import { StatusObject, WriteObject } from './call-interface';
import { Filter, FilterFactory } from './filter';
import { Metadata } from './metadata';
export declare class FilterStack implements Filter {
    private readonly filters;
    constructor(filters: Filter[]);
    sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;
    receiveMetadata(metadata: Metadata): Metadata;
    sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;
    receiveMessage(message: Promise<Buffer>): Promise<Buffer>;
    receiveTrailers(status: StatusObject): StatusObject;
    push(filters: Filter[]): void;
    getFilters(): Filter[];
}
export declare class FilterStackFactory implements FilterFactory<FilterStack> {
    private readonly factories;
    constructor(factories: Array<FilterFactory<Filter>>);
    push(filterFactories: FilterFactory<Filter>[]): void;
    clone(): FilterStackFactory;
    createFilter(): FilterStack;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterStackFactory = exports.FilterStack = void 0;
class FilterStack {
    constructor(filters) {
        this.filters = filters;
    }
    sendMetadata(metadata) {
        let result = metadata;
        for (let i = 0; i < this.filters.length; i++) {
            result = this.filters[i].sendMetadata(result);
        }
        return result;
    }
    receiveMetadata(metadata) {
        let result = metadata;
        for (let i = this.filters.length - 1; i >= 0; i--) {
            result = this.filters[i].receiveMetadata(result);
        }
        return result;
    }
    sendMessage(message) {
        let result = message;
        for (let i = 0; i < this.filters.length; i++) {
            result = this.filters[i].sendMessage(result);
        }
        return result;
    }
    receiveMessage(message) {
        let result = message;
        for (let i = this.filters.length - 1; i >= 0; i--) {
            result = this.filters[i].receiveMessage(result);
        }
        return result;
    }
    receiveTrailers(status) {
        let result = status;
        for (let i = this.filters.length - 1; i >= 0; i--) {
            result = this.filters[i].receiveTrailers(result);
        }
        return result;
    }
    push(filters) {
        this.filters.unshift(...filters);
    }
    getFilters() {
        return this.filters;
    }
}
exports.FilterStack = FilterStack;
class FilterStackFactory {
    constructor(factories) {
        this.factories = factories;
    }
    push(filterFactories) {
        this.factories.unshift(...filterFactories);
    }
    clone() {
        return new FilterStackFactory([...this.factories]);
    }
    createFilter() {
        return new FilterStack(this.factories.map(factory => factory.createFilter()));
    }
}
exports.FilterStackFactory = FilterStackFactory;
//# sourceMappingURL=filter-stack.js.map{"version":3,"file":"filter-stack.js","sourceRoot":"","sources":["../../src/filter-stack.ts"],"names":[],"mappings":"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"}import { StatusObject, WriteObject } from './call-interface';
import { Metadata } from './metadata';
/**
 * Filter classes represent related per-call logic and state that is primarily
 * used to modify incoming and outgoing data. All async filters can be
 * rejected. The rejection error must be a StatusObject, and a rejection will
 * cause the call to end with that status.
 */
export interface Filter {
    sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;
    receiveMetadata(metadata: Metadata): Metadata;
    sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;
    receiveMessage(message: Promise<Buffer>): Promise<Buffer>;
    receiveTrailers(status: StatusObject): StatusObject;
}
export declare abstract class BaseFilter implements Filter {
    sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;
    receiveMetadata(metadata: Metadata): Metadata;
    sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;
    receiveMessage(message: Promise<Buffer>): Promise<Buffer>;
    receiveTrailers(status: StatusObject): StatusObject;
}
export interface FilterFactory<T extends Filter> {
    createFilter(): T;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseFilter = void 0;
class BaseFilter {
    async sendMetadata(metadata) {
        return metadata;
    }
    receiveMetadata(metadata) {
        return metadata;
    }
    async sendMessage(message) {
        return message;
    }
    async receiveMessage(message) {
        return message;
    }
    receiveTrailers(status) {
        return status;
    }
}
exports.BaseFilter = BaseFilter;
//# sourceMappingURL=filter.js.map{"version":3,"file":"filter.js","sourceRoot":"","sources":["../../src/filter.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAuBH,MAAsB,UAAU;IAC9B,KAAK,CAAC,YAAY,CAAC,QAA2B;QAC5C,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,eAAe,CAAC,QAAkB;QAChC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,OAA6B;QAC7C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,OAAwB;QAC3C,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,eAAe,CAAC,MAAoB;QAClC,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AApBD,gCAoBC"}import type * as grpc from '../index';
import type { MessageTypeDefinition } from '@postman/proto-loader';
import type { ChannelzClient as _grpc_channelz_v1_ChannelzClient, ChannelzDefinition as _grpc_channelz_v1_ChannelzDefinition } from './grpc/channelz/v1/Channelz';
type SubtypeConstructor<Constructor extends new (...args: any) => any, Subtype> = {
    new (...args: ConstructorParameters<Constructor>): Subtype;
};
export interface ProtoGrpcType {
    google: {
        protobuf: {
            Any: MessageTypeDefinition;
            BoolValue: MessageTypeDefinition;
            BytesValue: MessageTypeDefinition;
            DoubleValue: MessageTypeDefinition;
            Duration: MessageTypeDefinition;
            FloatValue: MessageTypeDefinition;
            Int32Value: MessageTypeDefinition;
            Int64Value: MessageTypeDefinition;
            StringValue: MessageTypeDefinition;
            Timestamp: MessageTypeDefinition;
            UInt32Value: MessageTypeDefinition;
            UInt64Value: MessageTypeDefinition;
        };
    };
    grpc: {
        channelz: {
            v1: {
                Address: MessageTypeDefinition;
                Channel: MessageTypeDefinition;
                ChannelConnectivityState: MessageTypeDefinition;
                ChannelData: MessageTypeDefinition;
                ChannelRef: MessageTypeDefinition;
                ChannelTrace: MessageTypeDefinition;
                ChannelTraceEvent: MessageTypeDefinition;
                /**
                 * Channelz is a service exposed by gRPC servers that provides detailed debug
                 * information.
                 */
                Channelz: SubtypeConstructor<typeof grpc.Client, _grpc_channelz_v1_ChannelzClient> & {
                    service: _grpc_channelz_v1_ChannelzDefinition;
                };
                GetChannelRequest: MessageTypeDefinition;
                GetChannelResponse: MessageTypeDefinition;
                GetServerRequest: MessageTypeDefinition;
                GetServerResponse: MessageTypeDefinition;
                GetServerSocketsRequest: MessageTypeDefinition;
                GetServerSocketsResponse: MessageTypeDefinition;
                GetServersRequest: MessageTypeDefinition;
                GetServersResponse: MessageTypeDefinition;
                GetSocketRequest: MessageTypeDefinition;
                GetSocketResponse: MessageTypeDefinition;
                GetSubchannelRequest: MessageTypeDefinition;
                GetSubchannelResponse: MessageTypeDefinition;
                GetTopChannelsRequest: MessageTypeDefinition;
                GetTopChannelsResponse: MessageTypeDefinition;
                Security: MessageTypeDefinition;
                Server: MessageTypeDefinition;
                ServerData: MessageTypeDefinition;
                ServerRef: MessageTypeDefinition;
                Socket: MessageTypeDefinition;
                SocketData: MessageTypeDefinition;
                SocketOption: MessageTypeDefinition;
                SocketOptionLinger: MessageTypeDefinition;
                SocketOptionTcpInfo: MessageTypeDefinition;
                SocketOptionTimeout: MessageTypeDefinition;
                SocketRef: MessageTypeDefinition;
                Subchannel: MessageTypeDefinition;
                SubchannelRef: MessageTypeDefinition;
            };
        };
    };
}
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=channelz.js.map{"version":3,"file":"channelz.js","sourceRoot":"","sources":["../../../src/generated/channelz.ts"],"names":[],"mappings":""}import type { AnyExtension } from '@postman/proto-loader';
export type Any = AnyExtension | {
    type_url: string;
    value: Buffer | Uint8Array | string;
};
export interface Any__Output {
    'type_url': (string);
    'value': (Buffer);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Any.js.map{"version":3,"file":"Any.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/Any.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface BoolValue {
    'value'?: (boolean);
}
export interface BoolValue__Output {
    'value': (boolean);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=BoolValue.js.map{"version":3,"file":"BoolValue.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/BoolValue.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface BytesValue {
    'value'?: (Buffer | Uint8Array | string);
}
export interface BytesValue__Output {
    'value': (Buffer);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=BytesValue.js.map{"version":3,"file":"BytesValue.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/BytesValue.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface DoubleValue {
    'value'?: (number | string);
}
export interface DoubleValue__Output {
    'value': (number);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=DoubleValue.js.map{"version":3,"file":"DoubleValue.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/DoubleValue.ts"],"names":[],"mappings":";AAAA,sBAAsB"}import type { Long } from '@postman/proto-loader';
export interface Duration {
    'seconds'?: (number | string | Long);
    'nanos'?: (number);
}
export interface Duration__Output {
    'seconds': (string);
    'nanos': (number);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Duration.js.map{"version":3,"file":"Duration.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/Duration.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface FloatValue {
    'value'?: (number | string);
}
export interface FloatValue__Output {
    'value': (number);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=FloatValue.js.map{"version":3,"file":"FloatValue.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/FloatValue.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface Int32Value {
    'value'?: (number);
}
export interface Int32Value__Output {
    'value': (number);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Int32Value.js.map{"version":3,"file":"Int32Value.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/Int32Value.ts"],"names":[],"mappings":";AAAA,sBAAsB"}import type { Long } from '@postman/proto-loader';
export interface Int64Value {
    'value'?: (number | string | Long);
}
export interface Int64Value__Output {
    'value': (string);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Int64Value.js.map{"version":3,"file":"Int64Value.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/Int64Value.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface StringValue {
    'value'?: (string);
}
export interface StringValue__Output {
    'value': (string);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=StringValue.js.map{"version":3,"file":"StringValue.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/StringValue.ts"],"names":[],"mappings":";AAAA,sBAAsB"}import type { Long } from '@postman/proto-loader';
export interface Timestamp {
    'seconds'?: (number | string | Long);
    'nanos'?: (number);
}
export interface Timestamp__Output {
    'seconds': (string);
    'nanos': (number);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Timestamp.js.map{"version":3,"file":"Timestamp.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/Timestamp.ts"],"names":[],"mappings":";AAAA,sBAAsB"}export interface UInt32Value {
    'value'?: (number);
}
export interface UInt32Value__Output {
    'value': (number);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=UInt32Value.js.map{"version":3,"file":"UInt32Value.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/UInt32Value.ts"],"names":[],"mappings":";AAAA,sBAAsB"}import type { Long } from '@postman/proto-loader';
export interface UInt64Value {
    'value'?: (number | string | Long);
}
export interface UInt64Value__Output {
    'value': (string);
}
"use strict";
// Original file: null
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=UInt64Value.js.map{"version":3,"file":"UInt64Value.js","sourceRoot":"","sources":["../../../../../src/generated/google/protobuf/UInt64Value.ts"],"names":[],"mappings":";AAAA,sBAAsB"}import type { Any as _google_protobuf_Any, Any__Output as _google_protobuf_Any__Output } from '../../../google/protobuf/Any';
/**
 * An address type not included above.
 */
export interface _grpc_channelz_v1_Address_OtherAddress {
    /**
     * The human readable version of the value.  This value should be set.
     */
    'name'?: (string);
    /**
     * The actual address message.
     */
    'value'?: (_google_protobuf_Any | null);
}
/**
 * An address type not included above.
 */
export interface _grpc_channelz_v1_Address_OtherAddress__Output {
    /**
     * The human readable version of the value.  This value should be set.
     */
    'name': (string);
    /**
     * The actual address message.
     */
    'value': (_google_protobuf_Any__Output | null);
}
export interface _grpc_channelz_v1_Address_TcpIpAddress {
    /**
     * Either the IPv4 or IPv6 address in bytes.  Will be either 4 bytes or 16
     * bytes in length.
     */
    'ip_address'?: (Buffer | Uint8Array | string);
    /**
     * 0-64k, or -1 if not appropriate.
     */
    'port'?: (number);
}
export interface _grpc_channelz_v1_Address_TcpIpAddress__Output {
    /**
     * Either the IPv4 or IPv6 address in bytes.  Will be either 4 bytes or 16
     * bytes in length.
     */
    'ip_address': (Buffer);
    /**
     * 0-64k, or -1 if not appropriate.
     */
    'port': (number);
}
/**
 * A Unix Domain Socket address.
 */
export interface _grpc_channelz_v1_Address_UdsAddress {
    'filename'?: (string);
}
/**
 * A Unix Domain Socket address.
 */
export interface _grpc_channelz_v1_Address_UdsAddress__Output {
    'filename': (string);
}
/**
 * Address represents the address used to create the socket.
 */
export interface Address {
    'tcpip_address'?: (_grpc_channelz_v1_Address_TcpIpAddress | null);
    'uds_address'?: (_grpc_channelz_v1_Address_UdsAddress | null);
    'other_address'?: (_grpc_channelz_v1_Address_OtherAddress | null);
    'address'?: "tcpip_address" | "uds_address" | "other_address";
}
/**
 * Address represents the address used to create the socket.
 */
export interface Address__Output {
    'tcpip_address'?: (_grpc_channelz_v1_Address_TcpIpAddress__Output | null);
    'uds_address'?: (_grpc_channelz_v1_Address_UdsAddress__Output | null);
    'other_address'?: (_grpc_channelz_v1_Address_OtherAddress__Output | null);
    'address': "tcpip_address" | "uds_address" | "other_address";
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Address.js.map{"version":3,"file":"Address.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Address.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { ChannelRef as _grpc_channelz_v1_ChannelRef, ChannelRef__Output as _grpc_channelz_v1_ChannelRef__Output } from '../../../grpc/channelz/v1/ChannelRef';
import type { ChannelData as _grpc_channelz_v1_ChannelData, ChannelData__Output as _grpc_channelz_v1_ChannelData__Output } from '../../../grpc/channelz/v1/ChannelData';
import type { SubchannelRef as _grpc_channelz_v1_SubchannelRef, SubchannelRef__Output as _grpc_channelz_v1_SubchannelRef__Output } from '../../../grpc/channelz/v1/SubchannelRef';
import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';
/**
 * Channel is a logical grouping of channels, subchannels, and sockets.
 */
export interface Channel {
    /**
     * The identifier for this channel. This should bet set.
     */
    'ref'?: (_grpc_channelz_v1_ChannelRef | null);
    /**
     * Data specific to this channel.
     */
    'data'?: (_grpc_channelz_v1_ChannelData | null);
    /**
     * There are no ordering guarantees on the order of channel refs.
     * There may not be cycles in the ref graph.
     * A channel ref may be present in more than one channel or subchannel.
     */
    'channel_ref'?: (_grpc_channelz_v1_ChannelRef)[];
    /**
     * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
     * There are no ordering guarantees on the order of subchannel refs.
     * There may not be cycles in the ref graph.
     * A sub channel ref may be present in more than one channel or subchannel.
     */
    'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef)[];
    /**
     * There are no ordering guarantees on the order of sockets.
     */
    'socket_ref'?: (_grpc_channelz_v1_SocketRef)[];
}
/**
 * Channel is a logical grouping of channels, subchannels, and sockets.
 */
export interface Channel__Output {
    /**
     * The identifier for this channel. This should bet set.
     */
    'ref': (_grpc_channelz_v1_ChannelRef__Output | null);
    /**
     * Data specific to this channel.
     */
    'data': (_grpc_channelz_v1_ChannelData__Output | null);
    /**
     * There are no ordering guarantees on the order of channel refs.
     * There may not be cycles in the ref graph.
     * A channel ref may be present in more than one channel or subchannel.
     */
    'channel_ref': (_grpc_channelz_v1_ChannelRef__Output)[];
    /**
     * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
     * There are no ordering guarantees on the order of subchannel refs.
     * There may not be cycles in the ref graph.
     * A sub channel ref may be present in more than one channel or subchannel.
     */
    'subchannel_ref': (_grpc_channelz_v1_SubchannelRef__Output)[];
    /**
     * There are no ordering guarantees on the order of sockets.
     */
    'socket_ref': (_grpc_channelz_v1_SocketRef__Output)[];
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Channel.js.map{"version":3,"file":"Channel.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Channel.ts"],"names":[],"mappings":";AAAA,sCAAsC"}export declare const _grpc_channelz_v1_ChannelConnectivityState_State: {
    readonly UNKNOWN: "UNKNOWN";
    readonly IDLE: "IDLE";
    readonly CONNECTING: "CONNECTING";
    readonly READY: "READY";
    readonly TRANSIENT_FAILURE: "TRANSIENT_FAILURE";
    readonly SHUTDOWN: "SHUTDOWN";
};
export type _grpc_channelz_v1_ChannelConnectivityState_State = 'UNKNOWN' | 0 | 'IDLE' | 1 | 'CONNECTING' | 2 | 'READY' | 3 | 'TRANSIENT_FAILURE' | 4 | 'SHUTDOWN' | 5;
export type _grpc_channelz_v1_ChannelConnectivityState_State__Output = typeof _grpc_channelz_v1_ChannelConnectivityState_State[keyof typeof _grpc_channelz_v1_ChannelConnectivityState_State];
/**
 * These come from the specified states in this document:
 * https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md
 */
export interface ChannelConnectivityState {
    'state'?: (_grpc_channelz_v1_ChannelConnectivityState_State);
}
/**
 * These come from the specified states in this document:
 * https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md
 */
export interface ChannelConnectivityState__Output {
    'state': (_grpc_channelz_v1_ChannelConnectivityState_State__Output);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports._grpc_channelz_v1_ChannelConnectivityState_State = void 0;
// Original file: proto/channelz.proto
exports._grpc_channelz_v1_ChannelConnectivityState_State = {
    UNKNOWN: 'UNKNOWN',
    IDLE: 'IDLE',
    CONNECTING: 'CONNECTING',
    READY: 'READY',
    TRANSIENT_FAILURE: 'TRANSIENT_FAILURE',
    SHUTDOWN: 'SHUTDOWN',
};
//# sourceMappingURL=ChannelConnectivityState.js.map{"version":3,"file":"ChannelConnectivityState.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ChannelConnectivityState.ts"],"names":[],"mappings":";AAAA,sCAAsC;;;AAGtC,sCAAsC;AAEzB,QAAA,gDAAgD,GAAG;IAC9D,OAAO,EAAE,SAAS;IAClB,IAAI,EAAE,MAAM;IACZ,UAAU,EAAE,YAAY;IACxB,KAAK,EAAE,OAAO;IACd,iBAAiB,EAAE,mBAAmB;IACtC,QAAQ,EAAE,UAAU;CACZ,CAAC"}import type { ChannelConnectivityState as _grpc_channelz_v1_ChannelConnectivityState, ChannelConnectivityState__Output as _grpc_channelz_v1_ChannelConnectivityState__Output } from '../../../grpc/channelz/v1/ChannelConnectivityState';
import type { ChannelTrace as _grpc_channelz_v1_ChannelTrace, ChannelTrace__Output as _grpc_channelz_v1_ChannelTrace__Output } from '../../../grpc/channelz/v1/ChannelTrace';
import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { Long } from '@postman/proto-loader';
/**
 * Channel data is data related to a specific Channel or Subchannel.
 */
export interface ChannelData {
    /**
     * The connectivity state of the channel or subchannel.  Implementations
     * should always set this.
     */
    'state'?: (_grpc_channelz_v1_ChannelConnectivityState | null);
    /**
     * The target this channel originally tried to connect to.  May be absent
     */
    'target'?: (string);
    /**
     * A trace of recent events on the channel.  May be absent.
     */
    'trace'?: (_grpc_channelz_v1_ChannelTrace | null);
    /**
     * The number of calls started on the channel
     */
    'calls_started'?: (number | string | Long);
    /**
     * The number of calls that have completed with an OK status
     */
    'calls_succeeded'?: (number | string | Long);
    /**
     * The number of calls that have completed with a non-OK status
     */
    'calls_failed'?: (number | string | Long);
    /**
     * The last time a call was started on the channel.
     */
    'last_call_started_timestamp'?: (_google_protobuf_Timestamp | null);
}
/**
 * Channel data is data related to a specific Channel or Subchannel.
 */
export interface ChannelData__Output {
    /**
     * The connectivity state of the channel or subchannel.  Implementations
     * should always set this.
     */
    'state': (_grpc_channelz_v1_ChannelConnectivityState__Output | null);
    /**
     * The target this channel originally tried to connect to.  May be absent
     */
    'target': (string);
    /**
     * A trace of recent events on the channel.  May be absent.
     */
    'trace': (_grpc_channelz_v1_ChannelTrace__Output | null);
    /**
     * The number of calls started on the channel
     */
    'calls_started': (string);
    /**
     * The number of calls that have completed with an OK status
     */
    'calls_succeeded': (string);
    /**
     * The number of calls that have completed with a non-OK status
     */
    'calls_failed': (string);
    /**
     * The last time a call was started on the channel.
     */
    'last_call_started_timestamp': (_google_protobuf_Timestamp__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ChannelData.js.map{"version":3,"file":"ChannelData.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ChannelData.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
/**
 * ChannelRef is a reference to a Channel.
 */
export interface ChannelRef {
    /**
     * The globally unique id for this channel.  Must be a positive number.
     */
    'channel_id'?: (number | string | Long);
    /**
     * An optional name associated with the channel.
     */
    'name'?: (string);
}
/**
 * ChannelRef is a reference to a Channel.
 */
export interface ChannelRef__Output {
    /**
     * The globally unique id for this channel.  Must be a positive number.
     */
    'channel_id': (string);
    /**
     * An optional name associated with the channel.
     */
    'name': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ChannelRef.js.map{"version":3,"file":"ChannelRef.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ChannelRef.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { ChannelTraceEvent as _grpc_channelz_v1_ChannelTraceEvent, ChannelTraceEvent__Output as _grpc_channelz_v1_ChannelTraceEvent__Output } from '../../../grpc/channelz/v1/ChannelTraceEvent';
import type { Long } from '@postman/proto-loader';
/**
 * ChannelTrace represents the recent events that have occurred on the channel.
 */
export interface ChannelTrace {
    /**
     * Number of events ever logged in this tracing object. This can differ from
     * events.size() because events can be overwritten or garbage collected by
     * implementations.
     */
    'num_events_logged'?: (number | string | Long);
    /**
     * Time that this channel was created.
     */
    'creation_timestamp'?: (_google_protobuf_Timestamp | null);
    /**
     * List of events that have occurred on this channel.
     */
    'events'?: (_grpc_channelz_v1_ChannelTraceEvent)[];
}
/**
 * ChannelTrace represents the recent events that have occurred on the channel.
 */
export interface ChannelTrace__Output {
    /**
     * Number of events ever logged in this tracing object. This can differ from
     * events.size() because events can be overwritten or garbage collected by
     * implementations.
     */
    'num_events_logged': (string);
    /**
     * Time that this channel was created.
     */
    'creation_timestamp': (_google_protobuf_Timestamp__Output | null);
    /**
     * List of events that have occurred on this channel.
     */
    'events': (_grpc_channelz_v1_ChannelTraceEvent__Output)[];
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ChannelTrace.js.map{"version":3,"file":"ChannelTrace.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ChannelTrace.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { ChannelRef as _grpc_channelz_v1_ChannelRef, ChannelRef__Output as _grpc_channelz_v1_ChannelRef__Output } from '../../../grpc/channelz/v1/ChannelRef';
import type { SubchannelRef as _grpc_channelz_v1_SubchannelRef, SubchannelRef__Output as _grpc_channelz_v1_SubchannelRef__Output } from '../../../grpc/channelz/v1/SubchannelRef';
/**
 * The supported severity levels of trace events.
 */
export declare const _grpc_channelz_v1_ChannelTraceEvent_Severity: {
    readonly CT_UNKNOWN: "CT_UNKNOWN";
    readonly CT_INFO: "CT_INFO";
    readonly CT_WARNING: "CT_WARNING";
    readonly CT_ERROR: "CT_ERROR";
};
/**
 * The supported severity levels of trace events.
 */
export type _grpc_channelz_v1_ChannelTraceEvent_Severity = 'CT_UNKNOWN' | 0 | 'CT_INFO' | 1 | 'CT_WARNING' | 2 | 'CT_ERROR' | 3;
/**
 * The supported severity levels of trace events.
 */
export type _grpc_channelz_v1_ChannelTraceEvent_Severity__Output = typeof _grpc_channelz_v1_ChannelTraceEvent_Severity[keyof typeof _grpc_channelz_v1_ChannelTraceEvent_Severity];
/**
 * A trace event is an interesting thing that happened to a channel or
 * subchannel, such as creation, address resolution, subchannel creation, etc.
 */
export interface ChannelTraceEvent {
    /**
     * High level description of the event.
     */
    'description'?: (string);
    /**
     * the severity of the trace event
     */
    'severity'?: (_grpc_channelz_v1_ChannelTraceEvent_Severity);
    /**
     * When this event occurred.
     */
    'timestamp'?: (_google_protobuf_Timestamp | null);
    'channel_ref'?: (_grpc_channelz_v1_ChannelRef | null);
    'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef | null);
    /**
     * ref of referenced channel or subchannel.
     * Optional, only present if this event refers to a child object. For example,
     * this field would be filled if this trace event was for a subchannel being
     * created.
     */
    'child_ref'?: "channel_ref" | "subchannel_ref";
}
/**
 * A trace event is an interesting thing that happened to a channel or
 * subchannel, such as creation, address resolution, subchannel creation, etc.
 */
export interface ChannelTraceEvent__Output {
    /**
     * High level description of the event.
     */
    'description': (string);
    /**
     * the severity of the trace event
     */
    'severity': (_grpc_channelz_v1_ChannelTraceEvent_Severity__Output);
    /**
     * When this event occurred.
     */
    'timestamp': (_google_protobuf_Timestamp__Output | null);
    'channel_ref'?: (_grpc_channelz_v1_ChannelRef__Output | null);
    'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef__Output | null);
    /**
     * ref of referenced channel or subchannel.
     * Optional, only present if this event refers to a child object. For example,
     * this field would be filled if this trace event was for a subchannel being
     * created.
     */
    'child_ref': "channel_ref" | "subchannel_ref";
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports._grpc_channelz_v1_ChannelTraceEvent_Severity = void 0;
// Original file: proto/channelz.proto
/**
 * The supported severity levels of trace events.
 */
exports._grpc_channelz_v1_ChannelTraceEvent_Severity = {
    CT_UNKNOWN: 'CT_UNKNOWN',
    CT_INFO: 'CT_INFO',
    CT_WARNING: 'CT_WARNING',
    CT_ERROR: 'CT_ERROR',
};
//# sourceMappingURL=ChannelTraceEvent.js.map{"version":3,"file":"ChannelTraceEvent.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ChannelTraceEvent.ts"],"names":[],"mappings":";AAAA,sCAAsC;;;AAMtC,sCAAsC;AAEtC;;GAEG;AACU,QAAA,4CAA4C,GAAG;IAC1D,UAAU,EAAE,YAAY;IACxB,OAAO,EAAE,SAAS;IAClB,UAAU,EAAE,YAAY;IACxB,QAAQ,EAAE,UAAU;CACZ,CAAC"}import type * as grpc from '../../../../index';
import type { MethodDefinition } from '@postman/proto-loader';
import type { GetChannelRequest as _grpc_channelz_v1_GetChannelRequest, GetChannelRequest__Output as _grpc_channelz_v1_GetChannelRequest__Output } from '../../../grpc/channelz/v1/GetChannelRequest';
import type { GetChannelResponse as _grpc_channelz_v1_GetChannelResponse, GetChannelResponse__Output as _grpc_channelz_v1_GetChannelResponse__Output } from '../../../grpc/channelz/v1/GetChannelResponse';
import type { GetServerRequest as _grpc_channelz_v1_GetServerRequest, GetServerRequest__Output as _grpc_channelz_v1_GetServerRequest__Output } from '../../../grpc/channelz/v1/GetServerRequest';
import type { GetServerResponse as _grpc_channelz_v1_GetServerResponse, GetServerResponse__Output as _grpc_channelz_v1_GetServerResponse__Output } from '../../../grpc/channelz/v1/GetServerResponse';
import type { GetServerSocketsRequest as _grpc_channelz_v1_GetServerSocketsRequest, GetServerSocketsRequest__Output as _grpc_channelz_v1_GetServerSocketsRequest__Output } from '../../../grpc/channelz/v1/GetServerSocketsRequest';
import type { GetServerSocketsResponse as _grpc_channelz_v1_GetServerSocketsResponse, GetServerSocketsResponse__Output as _grpc_channelz_v1_GetServerSocketsResponse__Output } from '../../../grpc/channelz/v1/GetServerSocketsResponse';
import type { GetServersRequest as _grpc_channelz_v1_GetServersRequest, GetServersRequest__Output as _grpc_channelz_v1_GetServersRequest__Output } from '../../../grpc/channelz/v1/GetServersRequest';
import type { GetServersResponse as _grpc_channelz_v1_GetServersResponse, GetServersResponse__Output as _grpc_channelz_v1_GetServersResponse__Output } from '../../../grpc/channelz/v1/GetServersResponse';
import type { GetSocketRequest as _grpc_channelz_v1_GetSocketRequest, GetSocketRequest__Output as _grpc_channelz_v1_GetSocketRequest__Output } from '../../../grpc/channelz/v1/GetSocketRequest';
import type { GetSocketResponse as _grpc_channelz_v1_GetSocketResponse, GetSocketResponse__Output as _grpc_channelz_v1_GetSocketResponse__Output } from '../../../grpc/channelz/v1/GetSocketResponse';
import type { GetSubchannelRequest as _grpc_channelz_v1_GetSubchannelRequest, GetSubchannelRequest__Output as _grpc_channelz_v1_GetSubchannelRequest__Output } from '../../../grpc/channelz/v1/GetSubchannelRequest';
import type { GetSubchannelResponse as _grpc_channelz_v1_GetSubchannelResponse, GetSubchannelResponse__Output as _grpc_channelz_v1_GetSubchannelResponse__Output } from '../../../grpc/channelz/v1/GetSubchannelResponse';
import type { GetTopChannelsRequest as _grpc_channelz_v1_GetTopChannelsRequest, GetTopChannelsRequest__Output as _grpc_channelz_v1_GetTopChannelsRequest__Output } from '../../../grpc/channelz/v1/GetTopChannelsRequest';
import type { GetTopChannelsResponse as _grpc_channelz_v1_GetTopChannelsResponse, GetTopChannelsResponse__Output as _grpc_channelz_v1_GetTopChannelsResponse__Output } from '../../../grpc/channelz/v1/GetTopChannelsResponse';
/**
 * Channelz is a service exposed by gRPC servers that provides detailed debug
 * information.
 */
export interface ChannelzClient extends grpc.Client {
    /**
     * Returns a single Channel, or else a NOT_FOUND code.
     */
    GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
    GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
    GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
    GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Returns a single Server, or else a NOT_FOUND code.
     */
    GetServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    GetServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    GetServer(argument: _grpc_channelz_v1_GetServerRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    GetServer(argument: _grpc_channelz_v1_GetServerRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Returns a single Server, or else a NOT_FOUND code.
     */
    getServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    getServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    getServer(argument: _grpc_channelz_v1_GetServerRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    getServer(argument: _grpc_channelz_v1_GetServerRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Gets all server sockets that exist in the process.
     */
    GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Gets all server sockets that exist in the process.
     */
    getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Gets all servers that exist in the process.
     */
    GetServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    GetServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    GetServers(argument: _grpc_channelz_v1_GetServersRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    GetServers(argument: _grpc_channelz_v1_GetServersRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Gets all servers that exist in the process.
     */
    getServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    getServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    getServers(argument: _grpc_channelz_v1_GetServersRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    getServers(argument: _grpc_channelz_v1_GetServersRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Returns a single Socket or else a NOT_FOUND code.
     */
    GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Returns a single Socket or else a NOT_FOUND code.
     */
    getSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    getSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    getSocket(argument: _grpc_channelz_v1_GetSocketRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    getSocket(argument: _grpc_channelz_v1_GetSocketRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Returns a single Subchannel, or else a NOT_FOUND code.
     */
    GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Returns a single Subchannel, or else a NOT_FOUND code.
     */
    getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Gets all root channels (i.e. channels the application has directly
     * created). This does not include subchannels nor non-top level channels.
     */
    GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    /**
     * Gets all root channels (i.e. channels the application has directly
     * created). This does not include subchannels nor non-top level channels.
     */
    getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
    getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
}
/**
 * Channelz is a service exposed by gRPC servers that provides detailed debug
 * information.
 */
export interface ChannelzHandlers extends grpc.UntypedServiceImplementation {
    /**
     * Returns a single Channel, or else a NOT_FOUND code.
     */
    GetChannel: grpc.handleUnaryCall<_grpc_channelz_v1_GetChannelRequest__Output, _grpc_channelz_v1_GetChannelResponse>;
    /**
     * Returns a single Server, or else a NOT_FOUND code.
     */
    GetServer: grpc.handleUnaryCall<_grpc_channelz_v1_GetServerRequest__Output, _grpc_channelz_v1_GetServerResponse>;
    /**
     * Gets all server sockets that exist in the process.
     */
    GetServerSockets: grpc.handleUnaryCall<_grpc_channelz_v1_GetServerSocketsRequest__Output, _grpc_channelz_v1_GetServerSocketsResponse>;
    /**
     * Gets all servers that exist in the process.
     */
    GetServers: grpc.handleUnaryCall<_grpc_channelz_v1_GetServersRequest__Output, _grpc_channelz_v1_GetServersResponse>;
    /**
     * Returns a single Socket or else a NOT_FOUND code.
     */
    GetSocket: grpc.handleUnaryCall<_grpc_channelz_v1_GetSocketRequest__Output, _grpc_channelz_v1_GetSocketResponse>;
    /**
     * Returns a single Subchannel, or else a NOT_FOUND code.
     */
    GetSubchannel: grpc.handleUnaryCall<_grpc_channelz_v1_GetSubchannelRequest__Output, _grpc_channelz_v1_GetSubchannelResponse>;
    /**
     * Gets all root channels (i.e. channels the application has directly
     * created). This does not include subchannels nor non-top level channels.
     */
    GetTopChannels: grpc.handleUnaryCall<_grpc_channelz_v1_GetTopChannelsRequest__Output, _grpc_channelz_v1_GetTopChannelsResponse>;
}
export interface ChannelzDefinition extends grpc.ServiceDefinition {
    GetChannel: MethodDefinition<_grpc_channelz_v1_GetChannelRequest, _grpc_channelz_v1_GetChannelResponse, _grpc_channelz_v1_GetChannelRequest__Output, _grpc_channelz_v1_GetChannelResponse__Output>;
    GetServer: MethodDefinition<_grpc_channelz_v1_GetServerRequest, _grpc_channelz_v1_GetServerResponse, _grpc_channelz_v1_GetServerRequest__Output, _grpc_channelz_v1_GetServerResponse__Output>;
    GetServerSockets: MethodDefinition<_grpc_channelz_v1_GetServerSocketsRequest, _grpc_channelz_v1_GetServerSocketsResponse, _grpc_channelz_v1_GetServerSocketsRequest__Output, _grpc_channelz_v1_GetServerSocketsResponse__Output>;
    GetServers: MethodDefinition<_grpc_channelz_v1_GetServersRequest, _grpc_channelz_v1_GetServersResponse, _grpc_channelz_v1_GetServersRequest__Output, _grpc_channelz_v1_GetServersResponse__Output>;
    GetSocket: MethodDefinition<_grpc_channelz_v1_GetSocketRequest, _grpc_channelz_v1_GetSocketResponse, _grpc_channelz_v1_GetSocketRequest__Output, _grpc_channelz_v1_GetSocketResponse__Output>;
    GetSubchannel: MethodDefinition<_grpc_channelz_v1_GetSubchannelRequest, _grpc_channelz_v1_GetSubchannelResponse, _grpc_channelz_v1_GetSubchannelRequest__Output, _grpc_channelz_v1_GetSubchannelResponse__Output>;
    GetTopChannels: MethodDefinition<_grpc_channelz_v1_GetTopChannelsRequest, _grpc_channelz_v1_GetTopChannelsResponse, _grpc_channelz_v1_GetTopChannelsRequest__Output, _grpc_channelz_v1_GetTopChannelsResponse__Output>;
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Channelz.js.map{"version":3,"file":"Channelz.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Channelz.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetChannelRequest {
    /**
     * channel_id is the identifier of the specific channel to get.
     */
    'channel_id'?: (number | string | Long);
}
export interface GetChannelRequest__Output {
    /**
     * channel_id is the identifier of the specific channel to get.
     */
    'channel_id': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetChannelRequest.js.map{"version":3,"file":"GetChannelRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetChannelRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Channel as _grpc_channelz_v1_Channel, Channel__Output as _grpc_channelz_v1_Channel__Output } from '../../../grpc/channelz/v1/Channel';
export interface GetChannelResponse {
    /**
     * The Channel that corresponds to the requested channel_id.  This field
     * should be set.
     */
    'channel'?: (_grpc_channelz_v1_Channel | null);
}
export interface GetChannelResponse__Output {
    /**
     * The Channel that corresponds to the requested channel_id.  This field
     * should be set.
     */
    'channel': (_grpc_channelz_v1_Channel__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetChannelResponse.js.map{"version":3,"file":"GetChannelResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetChannelResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetServerRequest {
    /**
     * server_id is the identifier of the specific server to get.
     */
    'server_id'?: (number | string | Long);
}
export interface GetServerRequest__Output {
    /**
     * server_id is the identifier of the specific server to get.
     */
    'server_id': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetServerRequest.js.map{"version":3,"file":"GetServerRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetServerRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Server as _grpc_channelz_v1_Server, Server__Output as _grpc_channelz_v1_Server__Output } from '../../../grpc/channelz/v1/Server';
export interface GetServerResponse {
    /**
     * The Server that corresponds to the requested server_id.  This field
     * should be set.
     */
    'server'?: (_grpc_channelz_v1_Server | null);
}
export interface GetServerResponse__Output {
    /**
     * The Server that corresponds to the requested server_id.  This field
     * should be set.
     */
    'server': (_grpc_channelz_v1_Server__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetServerResponse.js.map{"version":3,"file":"GetServerResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetServerResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetServerSocketsRequest {
    'server_id'?: (number | string | Long);
    /**
     * start_socket_id indicates that only sockets at or above this id should be
     * included in the results.
     * To request the first page, this must be set to 0. To request
     * subsequent pages, the client generates this value by adding 1 to
     * the highest seen result ID.
     */
    'start_socket_id'?: (number | string | Long);
    /**
     * If non-zero, the server will return a page of results containing
     * at most this many items. If zero, the server will choose a
     * reasonable page size.  Must never be negative.
     */
    'max_results'?: (number | string | Long);
}
export interface GetServerSocketsRequest__Output {
    'server_id': (string);
    /**
     * start_socket_id indicates that only sockets at or above this id should be
     * included in the results.
     * To request the first page, this must be set to 0. To request
     * subsequent pages, the client generates this value by adding 1 to
     * the highest seen result ID.
     */
    'start_socket_id': (string);
    /**
     * If non-zero, the server will return a page of results containing
     * at most this many items. If zero, the server will choose a
     * reasonable page size.  Must never be negative.
     */
    'max_results': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetServerSocketsRequest.js.map{"version":3,"file":"GetServerSocketsRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetServerSocketsRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';
export interface GetServerSocketsResponse {
    /**
     * list of socket refs that the connection detail service knows about.  Sorted in
     * ascending socket_id order.
     * Must contain at least 1 result, otherwise 'end' must be true.
     */
    'socket_ref'?: (_grpc_channelz_v1_SocketRef)[];
    /**
     * If set, indicates that the list of sockets is the final list.  Requesting
     * more sockets will only return more if they are created after this RPC
     * completes.
     */
    'end'?: (boolean);
}
export interface GetServerSocketsResponse__Output {
    /**
     * list of socket refs that the connection detail service knows about.  Sorted in
     * ascending socket_id order.
     * Must contain at least 1 result, otherwise 'end' must be true.
     */
    'socket_ref': (_grpc_channelz_v1_SocketRef__Output)[];
    /**
     * If set, indicates that the list of sockets is the final list.  Requesting
     * more sockets will only return more if they are created after this RPC
     * completes.
     */
    'end': (boolean);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetServerSocketsResponse.js.map{"version":3,"file":"GetServerSocketsResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetServerSocketsResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetServersRequest {
    /**
     * start_server_id indicates that only servers at or above this id should be
     * included in the results.
     * To request the first page, this must be set to 0. To request
     * subsequent pages, the client generates this value by adding 1 to
     * the highest seen result ID.
     */
    'start_server_id'?: (number | string | Long);
    /**
     * If non-zero, the server will return a page of results containing
     * at most this many items. If zero, the server will choose a
     * reasonable page size.  Must never be negative.
     */
    'max_results'?: (number | string | Long);
}
export interface GetServersRequest__Output {
    /**
     * start_server_id indicates that only servers at or above this id should be
     * included in the results.
     * To request the first page, this must be set to 0. To request
     * subsequent pages, the client generates this value by adding 1 to
     * the highest seen result ID.
     */
    'start_server_id': (string);
    /**
     * If non-zero, the server will return a page of results containing
     * at most this many items. If zero, the server will choose a
     * reasonable page size.  Must never be negative.
     */
    'max_results': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetServersRequest.js.map{"version":3,"file":"GetServersRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetServersRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Server as _grpc_channelz_v1_Server, Server__Output as _grpc_channelz_v1_Server__Output } from '../../../grpc/channelz/v1/Server';
export interface GetServersResponse {
    /**
     * list of servers that the connection detail service knows about.  Sorted in
     * ascending server_id order.
     * Must contain at least 1 result, otherwise 'end' must be true.
     */
    'server'?: (_grpc_channelz_v1_Server)[];
    /**
     * If set, indicates that the list of servers is the final list.  Requesting
     * more servers will only return more if they are created after this RPC
     * completes.
     */
    'end'?: (boolean);
}
export interface GetServersResponse__Output {
    /**
     * list of servers that the connection detail service knows about.  Sorted in
     * ascending server_id order.
     * Must contain at least 1 result, otherwise 'end' must be true.
     */
    'server': (_grpc_channelz_v1_Server__Output)[];
    /**
     * If set, indicates that the list of servers is the final list.  Requesting
     * more servers will only return more if they are created after this RPC
     * completes.
     */
    'end': (boolean);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetServersResponse.js.map{"version":3,"file":"GetServersResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetServersResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetSocketRequest {
    /**
     * socket_id is the identifier of the specific socket to get.
     */
    'socket_id'?: (number | string | Long);
    /**
     * If true, the response will contain only high level information
     * that is inexpensive to obtain. Fields thay may be omitted are
     * documented.
     */
    'summary'?: (boolean);
}
export interface GetSocketRequest__Output {
    /**
     * socket_id is the identifier of the specific socket to get.
     */
    'socket_id': (string);
    /**
     * If true, the response will contain only high level information
     * that is inexpensive to obtain. Fields thay may be omitted are
     * documented.
     */
    'summary': (boolean);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetSocketRequest.js.map{"version":3,"file":"GetSocketRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetSocketRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Socket as _grpc_channelz_v1_Socket, Socket__Output as _grpc_channelz_v1_Socket__Output } from '../../../grpc/channelz/v1/Socket';
export interface GetSocketResponse {
    /**
     * The Socket that corresponds to the requested socket_id.  This field
     * should be set.
     */
    'socket'?: (_grpc_channelz_v1_Socket | null);
}
export interface GetSocketResponse__Output {
    /**
     * The Socket that corresponds to the requested socket_id.  This field
     * should be set.
     */
    'socket': (_grpc_channelz_v1_Socket__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetSocketResponse.js.map{"version":3,"file":"GetSocketResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetSocketResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetSubchannelRequest {
    /**
     * subchannel_id is the identifier of the specific subchannel to get.
     */
    'subchannel_id'?: (number | string | Long);
}
export interface GetSubchannelRequest__Output {
    /**
     * subchannel_id is the identifier of the specific subchannel to get.
     */
    'subchannel_id': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetSubchannelRequest.js.map{"version":3,"file":"GetSubchannelRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetSubchannelRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Subchannel as _grpc_channelz_v1_Subchannel, Subchannel__Output as _grpc_channelz_v1_Subchannel__Output } from '../../../grpc/channelz/v1/Subchannel';
export interface GetSubchannelResponse {
    /**
     * The Subchannel that corresponds to the requested subchannel_id.  This
     * field should be set.
     */
    'subchannel'?: (_grpc_channelz_v1_Subchannel | null);
}
export interface GetSubchannelResponse__Output {
    /**
     * The Subchannel that corresponds to the requested subchannel_id.  This
     * field should be set.
     */
    'subchannel': (_grpc_channelz_v1_Subchannel__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetSubchannelResponse.js.map{"version":3,"file":"GetSubchannelResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetSubchannelResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
export interface GetTopChannelsRequest {
    /**
     * start_channel_id indicates that only channels at or above this id should be
     * included in the results.
     * To request the first page, this should be set to 0. To request
     * subsequent pages, the client generates this value by adding 1 to
     * the highest seen result ID.
     */
    'start_channel_id'?: (number | string | Long);
    /**
     * If non-zero, the server will return a page of results containing
     * at most this many items. If zero, the server will choose a
     * reasonable page size.  Must never be negative.
     */
    'max_results'?: (number | string | Long);
}
export interface GetTopChannelsRequest__Output {
    /**
     * start_channel_id indicates that only channels at or above this id should be
     * included in the results.
     * To request the first page, this should be set to 0. To request
     * subsequent pages, the client generates this value by adding 1 to
     * the highest seen result ID.
     */
    'start_channel_id': (string);
    /**
     * If non-zero, the server will return a page of results containing
     * at most this many items. If zero, the server will choose a
     * reasonable page size.  Must never be negative.
     */
    'max_results': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetTopChannelsRequest.js.map{"version":3,"file":"GetTopChannelsRequest.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetTopChannelsRequest.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Channel as _grpc_channelz_v1_Channel, Channel__Output as _grpc_channelz_v1_Channel__Output } from '../../../grpc/channelz/v1/Channel';
export interface GetTopChannelsResponse {
    /**
     * list of channels that the connection detail service knows about.  Sorted in
     * ascending channel_id order.
     * Must contain at least 1 result, otherwise 'end' must be true.
     */
    'channel'?: (_grpc_channelz_v1_Channel)[];
    /**
     * If set, indicates that the list of channels is the final list.  Requesting
     * more channels can only return more if they are created after this RPC
     * completes.
     */
    'end'?: (boolean);
}
export interface GetTopChannelsResponse__Output {
    /**
     * list of channels that the connection detail service knows about.  Sorted in
     * ascending channel_id order.
     * Must contain at least 1 result, otherwise 'end' must be true.
     */
    'channel': (_grpc_channelz_v1_Channel__Output)[];
    /**
     * If set, indicates that the list of channels is the final list.  Requesting
     * more channels can only return more if they are created after this RPC
     * completes.
     */
    'end': (boolean);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=GetTopChannelsResponse.js.map{"version":3,"file":"GetTopChannelsResponse.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/GetTopChannelsResponse.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Any as _google_protobuf_Any, Any__Output as _google_protobuf_Any__Output } from '../../../google/protobuf/Any';
export interface _grpc_channelz_v1_Security_OtherSecurity {
    /**
     * The human readable version of the value.
     */
    'name'?: (string);
    /**
     * The actual security details message.
     */
    'value'?: (_google_protobuf_Any | null);
}
export interface _grpc_channelz_v1_Security_OtherSecurity__Output {
    /**
     * The human readable version of the value.
     */
    'name': (string);
    /**
     * The actual security details message.
     */
    'value': (_google_protobuf_Any__Output | null);
}
export interface _grpc_channelz_v1_Security_Tls {
    /**
     * The cipher suite name in the RFC 4346 format:
     * https://tools.ietf.org/html/rfc4346#appendix-C
     */
    'standard_name'?: (string);
    /**
     * Some other way to describe the cipher suite if
     * the RFC 4346 name is not available.
     */
    'other_name'?: (string);
    /**
     * the certificate used by this endpoint.
     */
    'local_certificate'?: (Buffer | Uint8Array | string);
    /**
     * the certificate used by the remote endpoint.
     */
    'remote_certificate'?: (Buffer | Uint8Array | string);
    'cipher_suite'?: "standard_name" | "other_name";
}
export interface _grpc_channelz_v1_Security_Tls__Output {
    /**
     * The cipher suite name in the RFC 4346 format:
     * https://tools.ietf.org/html/rfc4346#appendix-C
     */
    'standard_name'?: (string);
    /**
     * Some other way to describe the cipher suite if
     * the RFC 4346 name is not available.
     */
    'other_name'?: (string);
    /**
     * the certificate used by this endpoint.
     */
    'local_certificate': (Buffer);
    /**
     * the certificate used by the remote endpoint.
     */
    'remote_certificate': (Buffer);
    'cipher_suite': "standard_name" | "other_name";
}
/**
 * Security represents details about how secure the socket is.
 */
export interface Security {
    'tls'?: (_grpc_channelz_v1_Security_Tls | null);
    'other'?: (_grpc_channelz_v1_Security_OtherSecurity | null);
    'model'?: "tls" | "other";
}
/**
 * Security represents details about how secure the socket is.
 */
export interface Security__Output {
    'tls'?: (_grpc_channelz_v1_Security_Tls__Output | null);
    'other'?: (_grpc_channelz_v1_Security_OtherSecurity__Output | null);
    'model': "tls" | "other";
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Security.js.map{"version":3,"file":"Security.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Security.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { ServerRef as _grpc_channelz_v1_ServerRef, ServerRef__Output as _grpc_channelz_v1_ServerRef__Output } from '../../../grpc/channelz/v1/ServerRef';
import type { ServerData as _grpc_channelz_v1_ServerData, ServerData__Output as _grpc_channelz_v1_ServerData__Output } from '../../../grpc/channelz/v1/ServerData';
import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';
/**
 * Server represents a single server.  There may be multiple servers in a single
 * program.
 */
export interface Server {
    /**
     * The identifier for a Server.  This should be set.
     */
    'ref'?: (_grpc_channelz_v1_ServerRef | null);
    /**
     * The associated data of the Server.
     */
    'data'?: (_grpc_channelz_v1_ServerData | null);
    /**
     * The sockets that the server is listening on.  There are no ordering
     * guarantees.  This may be absent.
     */
    'listen_socket'?: (_grpc_channelz_v1_SocketRef)[];
}
/**
 * Server represents a single server.  There may be multiple servers in a single
 * program.
 */
export interface Server__Output {
    /**
     * The identifier for a Server.  This should be set.
     */
    'ref': (_grpc_channelz_v1_ServerRef__Output | null);
    /**
     * The associated data of the Server.
     */
    'data': (_grpc_channelz_v1_ServerData__Output | null);
    /**
     * The sockets that the server is listening on.  There are no ordering
     * guarantees.  This may be absent.
     */
    'listen_socket': (_grpc_channelz_v1_SocketRef__Output)[];
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Server.js.map{"version":3,"file":"Server.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Server.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { ChannelTrace as _grpc_channelz_v1_ChannelTrace, ChannelTrace__Output as _grpc_channelz_v1_ChannelTrace__Output } from '../../../grpc/channelz/v1/ChannelTrace';
import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { Long } from '@postman/proto-loader';
/**
 * ServerData is data for a specific Server.
 */
export interface ServerData {
    /**
     * A trace of recent events on the server.  May be absent.
     */
    'trace'?: (_grpc_channelz_v1_ChannelTrace | null);
    /**
     * The number of incoming calls started on the server
     */
    'calls_started'?: (number | string | Long);
    /**
     * The number of incoming calls that have completed with an OK status
     */
    'calls_succeeded'?: (number | string | Long);
    /**
     * The number of incoming calls that have a completed with a non-OK status
     */
    'calls_failed'?: (number | string | Long);
    /**
     * The last time a call was started on the server.
     */
    'last_call_started_timestamp'?: (_google_protobuf_Timestamp | null);
}
/**
 * ServerData is data for a specific Server.
 */
export interface ServerData__Output {
    /**
     * A trace of recent events on the server.  May be absent.
     */
    'trace': (_grpc_channelz_v1_ChannelTrace__Output | null);
    /**
     * The number of incoming calls started on the server
     */
    'calls_started': (string);
    /**
     * The number of incoming calls that have completed with an OK status
     */
    'calls_succeeded': (string);
    /**
     * The number of incoming calls that have a completed with a non-OK status
     */
    'calls_failed': (string);
    /**
     * The last time a call was started on the server.
     */
    'last_call_started_timestamp': (_google_protobuf_Timestamp__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ServerData.js.map{"version":3,"file":"ServerData.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ServerData.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
/**
 * ServerRef is a reference to a Server.
 */
export interface ServerRef {
    /**
     * A globally unique identifier for this server.  Must be a positive number.
     */
    'server_id'?: (number | string | Long);
    /**
     * An optional name associated with the server.
     */
    'name'?: (string);
}
/**
 * ServerRef is a reference to a Server.
 */
export interface ServerRef__Output {
    /**
     * A globally unique identifier for this server.  Must be a positive number.
     */
    'server_id': (string);
    /**
     * An optional name associated with the server.
     */
    'name': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ServerRef.js.map{"version":3,"file":"ServerRef.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/ServerRef.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';
import type { SocketData as _grpc_channelz_v1_SocketData, SocketData__Output as _grpc_channelz_v1_SocketData__Output } from '../../../grpc/channelz/v1/SocketData';
import type { Address as _grpc_channelz_v1_Address, Address__Output as _grpc_channelz_v1_Address__Output } from '../../../grpc/channelz/v1/Address';
import type { Security as _grpc_channelz_v1_Security, Security__Output as _grpc_channelz_v1_Security__Output } from '../../../grpc/channelz/v1/Security';
/**
 * Information about an actual connection.  Pronounced "sock-ay".
 */
export interface Socket {
    /**
     * The identifier for the Socket.
     */
    'ref'?: (_grpc_channelz_v1_SocketRef | null);
    /**
     * Data specific to this Socket.
     */
    'data'?: (_grpc_channelz_v1_SocketData | null);
    /**
     * The locally bound address.
     */
    'local'?: (_grpc_channelz_v1_Address | null);
    /**
     * The remote bound address.  May be absent.
     */
    'remote'?: (_grpc_channelz_v1_Address | null);
    /**
     * Security details for this socket.  May be absent if not available, or
     * there is no security on the socket.
     */
    'security'?: (_grpc_channelz_v1_Security | null);
    /**
     * Optional, represents the name of the remote endpoint, if different than
     * the original target name.
     */
    'remote_name'?: (string);
}
/**
 * Information about an actual connection.  Pronounced "sock-ay".
 */
export interface Socket__Output {
    /**
     * The identifier for the Socket.
     */
    'ref': (_grpc_channelz_v1_SocketRef__Output | null);
    /**
     * Data specific to this Socket.
     */
    'data': (_grpc_channelz_v1_SocketData__Output | null);
    /**
     * The locally bound address.
     */
    'local': (_grpc_channelz_v1_Address__Output | null);
    /**
     * The remote bound address.  May be absent.
     */
    'remote': (_grpc_channelz_v1_Address__Output | null);
    /**
     * Security details for this socket.  May be absent if not available, or
     * there is no security on the socket.
     */
    'security': (_grpc_channelz_v1_Security__Output | null);
    /**
     * Optional, represents the name of the remote endpoint, if different than
     * the original target name.
     */
    'remote_name': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Socket.js.map{"version":3,"file":"Socket.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Socket.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { Int64Value as _google_protobuf_Int64Value, Int64Value__Output as _google_protobuf_Int64Value__Output } from '../../../google/protobuf/Int64Value';
import type { SocketOption as _grpc_channelz_v1_SocketOption, SocketOption__Output as _grpc_channelz_v1_SocketOption__Output } from '../../../grpc/channelz/v1/SocketOption';
import type { Long } from '@postman/proto-loader';
/**
 * SocketData is data associated for a specific Socket.  The fields present
 * are specific to the implementation, so there may be minor differences in
 * the semantics.  (e.g. flow control windows)
 */
export interface SocketData {
    /**
     * The number of streams that have been started.
     */
    'streams_started'?: (number | string | Long);
    /**
     * The number of streams that have ended successfully:
     * On client side, received frame with eos bit set;
     * On server side, sent frame with eos bit set.
     */
    'streams_succeeded'?: (number | string | Long);
    /**
     * The number of streams that have ended unsuccessfully:
     * On client side, ended without receiving frame with eos bit set;
     * On server side, ended without sending frame with eos bit set.
     */
    'streams_failed'?: (number | string | Long);
    /**
     * The number of grpc messages successfully sent on this socket.
     */
    'messages_sent'?: (number | string | Long);
    /**
     * The number of grpc messages received on this socket.
     */
    'messages_received'?: (number | string | Long);
    /**
     * The number of keep alives sent.  This is typically implemented with HTTP/2
     * ping messages.
     */
    'keep_alives_sent'?: (number | string | Long);
    /**
     * The last time a stream was created by this endpoint.  Usually unset for
     * servers.
     */
    'last_local_stream_created_timestamp'?: (_google_protobuf_Timestamp | null);
    /**
     * The last time a stream was created by the remote endpoint.  Usually unset
     * for clients.
     */
    'last_remote_stream_created_timestamp'?: (_google_protobuf_Timestamp | null);
    /**
     * The last time a message was sent by this endpoint.
     */
    'last_message_sent_timestamp'?: (_google_protobuf_Timestamp | null);
    /**
     * The last time a message was received by this endpoint.
     */
    'last_message_received_timestamp'?: (_google_protobuf_Timestamp | null);
    /**
     * The amount of window, granted to the local endpoint by the remote endpoint.
     * This may be slightly out of date due to network latency.  This does NOT
     * include stream level or TCP level flow control info.
     */
    'local_flow_control_window'?: (_google_protobuf_Int64Value | null);
    /**
     * The amount of window, granted to the remote endpoint by the local endpoint.
     * This may be slightly out of date due to network latency.  This does NOT
     * include stream level or TCP level flow control info.
     */
    'remote_flow_control_window'?: (_google_protobuf_Int64Value | null);
    /**
     * Socket options set on this socket.  May be absent if 'summary' is set
     * on GetSocketRequest.
     */
    'option'?: (_grpc_channelz_v1_SocketOption)[];
}
/**
 * SocketData is data associated for a specific Socket.  The fields present
 * are specific to the implementation, so there may be minor differences in
 * the semantics.  (e.g. flow control windows)
 */
export interface SocketData__Output {
    /**
     * The number of streams that have been started.
     */
    'streams_started': (string);
    /**
     * The number of streams that have ended successfully:
     * On client side, received frame with eos bit set;
     * On server side, sent frame with eos bit set.
     */
    'streams_succeeded': (string);
    /**
     * The number of streams that have ended unsuccessfully:
     * On client side, ended without receiving frame with eos bit set;
     * On server side, ended without sending frame with eos bit set.
     */
    'streams_failed': (string);
    /**
     * The number of grpc messages successfully sent on this socket.
     */
    'messages_sent': (string);
    /**
     * The number of grpc messages received on this socket.
     */
    'messages_received': (string);
    /**
     * The number of keep alives sent.  This is typically implemented with HTTP/2
     * ping messages.
     */
    'keep_alives_sent': (string);
    /**
     * The last time a stream was created by this endpoint.  Usually unset for
     * servers.
     */
    'last_local_stream_created_timestamp': (_google_protobuf_Timestamp__Output | null);
    /**
     * The last time a stream was created by the remote endpoint.  Usually unset
     * for clients.
     */
    'last_remote_stream_created_timestamp': (_google_protobuf_Timestamp__Output | null);
    /**
     * The last time a message was sent by this endpoint.
     */
    'last_message_sent_timestamp': (_google_protobuf_Timestamp__Output | null);
    /**
     * The last time a message was received by this endpoint.
     */
    'last_message_received_timestamp': (_google_protobuf_Timestamp__Output | null);
    /**
     * The amount of window, granted to the local endpoint by the remote endpoint.
     * This may be slightly out of date due to network latency.  This does NOT
     * include stream level or TCP level flow control info.
     */
    'local_flow_control_window': (_google_protobuf_Int64Value__Output | null);
    /**
     * The amount of window, granted to the remote endpoint by the local endpoint.
     * This may be slightly out of date due to network latency.  This does NOT
     * include stream level or TCP level flow control info.
     */
    'remote_flow_control_window': (_google_protobuf_Int64Value__Output | null);
    /**
     * Socket options set on this socket.  May be absent if 'summary' is set
     * on GetSocketRequest.
     */
    'option': (_grpc_channelz_v1_SocketOption__Output)[];
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SocketData.js.map{"version":3,"file":"SocketData.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SocketData.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Any as _google_protobuf_Any, Any__Output as _google_protobuf_Any__Output } from '../../../google/protobuf/Any';
/**
 * SocketOption represents socket options for a socket.  Specifically, these
 * are the options returned by getsockopt().
 */
export interface SocketOption {
    /**
     * The full name of the socket option.  Typically this will be the upper case
     * name, such as "SO_REUSEPORT".
     */
    'name'?: (string);
    /**
     * The human readable value of this socket option.  At least one of value or
     * additional will be set.
     */
    'value'?: (string);
    /**
     * Additional data associated with the socket option.  At least one of value
     * or additional will be set.
     */
    'additional'?: (_google_protobuf_Any | null);
}
/**
 * SocketOption represents socket options for a socket.  Specifically, these
 * are the options returned by getsockopt().
 */
export interface SocketOption__Output {
    /**
     * The full name of the socket option.  Typically this will be the upper case
     * name, such as "SO_REUSEPORT".
     */
    'name': (string);
    /**
     * The human readable value of this socket option.  At least one of value or
     * additional will be set.
     */
    'value': (string);
    /**
     * Additional data associated with the socket option.  At least one of value
     * or additional will be set.
     */
    'additional': (_google_protobuf_Any__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SocketOption.js.map{"version":3,"file":"SocketOption.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SocketOption.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Duration as _google_protobuf_Duration, Duration__Output as _google_protobuf_Duration__Output } from '../../../google/protobuf/Duration';
/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_LINGER.
 */
export interface SocketOptionLinger {
    /**
     * active maps to `struct linger.l_onoff`
     */
    'active'?: (boolean);
    /**
     * duration maps to `struct linger.l_linger`
     */
    'duration'?: (_google_protobuf_Duration | null);
}
/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_LINGER.
 */
export interface SocketOptionLinger__Output {
    /**
     * active maps to `struct linger.l_onoff`
     */
    'active': (boolean);
    /**
     * duration maps to `struct linger.l_linger`
     */
    'duration': (_google_protobuf_Duration__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SocketOptionLinger.js.map{"version":3,"file":"SocketOptionLinger.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SocketOptionLinger.ts"],"names":[],"mappings":";AAAA,sCAAsC"}/**
 * For use with SocketOption's additional field.  Tcp info for
 * SOL_TCP and TCP_INFO.
 */
export interface SocketOptionTcpInfo {
    'tcpi_state'?: (number);
    'tcpi_ca_state'?: (number);
    'tcpi_retransmits'?: (number);
    'tcpi_probes'?: (number);
    'tcpi_backoff'?: (number);
    'tcpi_options'?: (number);
    'tcpi_snd_wscale'?: (number);
    'tcpi_rcv_wscale'?: (number);
    'tcpi_rto'?: (number);
    'tcpi_ato'?: (number);
    'tcpi_snd_mss'?: (number);
    'tcpi_rcv_mss'?: (number);
    'tcpi_unacked'?: (number);
    'tcpi_sacked'?: (number);
    'tcpi_lost'?: (number);
    'tcpi_retrans'?: (number);
    'tcpi_fackets'?: (number);
    'tcpi_last_data_sent'?: (number);
    'tcpi_last_ack_sent'?: (number);
    'tcpi_last_data_recv'?: (number);
    'tcpi_last_ack_recv'?: (number);
    'tcpi_pmtu'?: (number);
    'tcpi_rcv_ssthresh'?: (number);
    'tcpi_rtt'?: (number);
    'tcpi_rttvar'?: (number);
    'tcpi_snd_ssthresh'?: (number);
    'tcpi_snd_cwnd'?: (number);
    'tcpi_advmss'?: (number);
    'tcpi_reordering'?: (number);
}
/**
 * For use with SocketOption's additional field.  Tcp info for
 * SOL_TCP and TCP_INFO.
 */
export interface SocketOptionTcpInfo__Output {
    'tcpi_state': (number);
    'tcpi_ca_state': (number);
    'tcpi_retransmits': (number);
    'tcpi_probes': (number);
    'tcpi_backoff': (number);
    'tcpi_options': (number);
    'tcpi_snd_wscale': (number);
    'tcpi_rcv_wscale': (number);
    'tcpi_rto': (number);
    'tcpi_ato': (number);
    'tcpi_snd_mss': (number);
    'tcpi_rcv_mss': (number);
    'tcpi_unacked': (number);
    'tcpi_sacked': (number);
    'tcpi_lost': (number);
    'tcpi_retrans': (number);
    'tcpi_fackets': (number);
    'tcpi_last_data_sent': (number);
    'tcpi_last_ack_sent': (number);
    'tcpi_last_data_recv': (number);
    'tcpi_last_ack_recv': (number);
    'tcpi_pmtu': (number);
    'tcpi_rcv_ssthresh': (number);
    'tcpi_rtt': (number);
    'tcpi_rttvar': (number);
    'tcpi_snd_ssthresh': (number);
    'tcpi_snd_cwnd': (number);
    'tcpi_advmss': (number);
    'tcpi_reordering': (number);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SocketOptionTcpInfo.js.map{"version":3,"file":"SocketOptionTcpInfo.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SocketOptionTcpInfo.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Duration as _google_protobuf_Duration, Duration__Output as _google_protobuf_Duration__Output } from '../../../google/protobuf/Duration';
/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_RCVTIMEO and SO_SNDTIMEO
 */
export interface SocketOptionTimeout {
    'duration'?: (_google_protobuf_Duration | null);
}
/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_RCVTIMEO and SO_SNDTIMEO
 */
export interface SocketOptionTimeout__Output {
    'duration': (_google_protobuf_Duration__Output | null);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SocketOptionTimeout.js.map{"version":3,"file":"SocketOptionTimeout.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SocketOptionTimeout.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
/**
 * SocketRef is a reference to a Socket.
 */
export interface SocketRef {
    /**
     * The globally unique id for this socket.  Must be a positive number.
     */
    'socket_id'?: (number | string | Long);
    /**
     * An optional name associated with the socket.
     */
    'name'?: (string);
}
/**
 * SocketRef is a reference to a Socket.
 */
export interface SocketRef__Output {
    /**
     * The globally unique id for this socket.  Must be a positive number.
     */
    'socket_id': (string);
    /**
     * An optional name associated with the socket.
     */
    'name': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SocketRef.js.map{"version":3,"file":"SocketRef.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SocketRef.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { SubchannelRef as _grpc_channelz_v1_SubchannelRef, SubchannelRef__Output as _grpc_channelz_v1_SubchannelRef__Output } from '../../../grpc/channelz/v1/SubchannelRef';
import type { ChannelData as _grpc_channelz_v1_ChannelData, ChannelData__Output as _grpc_channelz_v1_ChannelData__Output } from '../../../grpc/channelz/v1/ChannelData';
import type { ChannelRef as _grpc_channelz_v1_ChannelRef, ChannelRef__Output as _grpc_channelz_v1_ChannelRef__Output } from '../../../grpc/channelz/v1/ChannelRef';
import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';
/**
 * Subchannel is a logical grouping of channels, subchannels, and sockets.
 * A subchannel is load balanced over by it's ancestor
 */
export interface Subchannel {
    /**
     * The identifier for this channel.
     */
    'ref'?: (_grpc_channelz_v1_SubchannelRef | null);
    /**
     * Data specific to this channel.
     */
    'data'?: (_grpc_channelz_v1_ChannelData | null);
    /**
     * There are no ordering guarantees on the order of channel refs.
     * There may not be cycles in the ref graph.
     * A channel ref may be present in more than one channel or subchannel.
     */
    'channel_ref'?: (_grpc_channelz_v1_ChannelRef)[];
    /**
     * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
     * There are no ordering guarantees on the order of subchannel refs.
     * There may not be cycles in the ref graph.
     * A sub channel ref may be present in more than one channel or subchannel.
     */
    'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef)[];
    /**
     * There are no ordering guarantees on the order of sockets.
     */
    'socket_ref'?: (_grpc_channelz_v1_SocketRef)[];
}
/**
 * Subchannel is a logical grouping of channels, subchannels, and sockets.
 * A subchannel is load balanced over by it's ancestor
 */
export interface Subchannel__Output {
    /**
     * The identifier for this channel.
     */
    'ref': (_grpc_channelz_v1_SubchannelRef__Output | null);
    /**
     * Data specific to this channel.
     */
    'data': (_grpc_channelz_v1_ChannelData__Output | null);
    /**
     * There are no ordering guarantees on the order of channel refs.
     * There may not be cycles in the ref graph.
     * A channel ref may be present in more than one channel or subchannel.
     */
    'channel_ref': (_grpc_channelz_v1_ChannelRef__Output)[];
    /**
     * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
     * There are no ordering guarantees on the order of subchannel refs.
     * There may not be cycles in the ref graph.
     * A sub channel ref may be present in more than one channel or subchannel.
     */
    'subchannel_ref': (_grpc_channelz_v1_SubchannelRef__Output)[];
    /**
     * There are no ordering guarantees on the order of sockets.
     */
    'socket_ref': (_grpc_channelz_v1_SocketRef__Output)[];
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Subchannel.js.map{"version":3,"file":"Subchannel.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/Subchannel.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import type { Long } from '@postman/proto-loader';
/**
 * SubchannelRef is a reference to a Subchannel.
 */
export interface SubchannelRef {
    /**
     * The globally unique id for this subchannel.  Must be a positive number.
     */
    'subchannel_id'?: (number | string | Long);
    /**
     * An optional name associated with the subchannel.
     */
    'name'?: (string);
}
/**
 * SubchannelRef is a reference to a Subchannel.
 */
export interface SubchannelRef__Output {
    /**
     * The globally unique id for this subchannel.  Must be a positive number.
     */
    'subchannel_id': (string);
    /**
     * An optional name associated with the subchannel.
     */
    'name': (string);
}
"use strict";
// Original file: proto/channelz.proto
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=SubchannelRef.js.map{"version":3,"file":"SubchannelRef.js","sourceRoot":"","sources":["../../../../../../src/generated/grpc/channelz/v1/SubchannelRef.ts"],"names":[],"mappings":";AAAA,sCAAsC"}import { Socket } from 'net';
import * as tls from 'tls';
import { SubchannelAddress } from './subchannel-address';
import { ChannelOptions } from './channel-options';
import { GrpcUri } from './uri-parser';
export interface ProxyMapResult {
    target: GrpcUri;
    extraOptions: ChannelOptions;
}
export declare function mapProxyName(target: GrpcUri, options: ChannelOptions): ProxyMapResult;
export interface ProxyConnectionResult {
    socket?: Socket;
    realTarget?: GrpcUri;
}
export declare function getProxiedConnection(address: SubchannelAddress, channelOptions: ChannelOptions, connectionOptions: tls.ConnectionOptions): Promise<ProxyConnectionResult>;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapProxyName = mapProxyName;
exports.getProxiedConnection = getProxiedConnection;
const logging_1 = require("./logging");
const constants_1 = require("./constants");
const resolver_1 = require("./resolver");
const http = require("http");
const tls = require("tls");
const logging = require("./logging");
const subchannel_address_1 = require("./subchannel-address");
const uri_parser_1 = require("./uri-parser");
const url_1 = require("url");
const resolver_dns_1 = require("./resolver-dns");
const TRACER_NAME = 'proxy';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
function getProxyInfo() {
    let proxyEnv = '';
    let envVar = '';
    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
     * fallback behavior can be removed if there's a demand for it.
     */
    if (process.env.grpc_proxy) {
        envVar = 'grpc_proxy';
        proxyEnv = process.env.grpc_proxy;
    }
    else if (process.env.https_proxy) {
        envVar = 'https_proxy';
        proxyEnv = process.env.https_proxy;
    }
    else if (process.env.http_proxy) {
        envVar = 'http_proxy';
        proxyEnv = process.env.http_proxy;
    }
    else {
        return {};
    }
    let proxyUrl;
    try {
        proxyUrl = new url_1.URL(proxyEnv);
    }
    catch (e) {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
    }
    if (proxyUrl.protocol !== 'http:') {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
    }
    let userCred = null;
    if (proxyUrl.username) {
        if (proxyUrl.password) {
            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');
            userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
        }
        else {
            userCred = proxyUrl.username;
        }
    }
    const hostname = proxyUrl.hostname;
    let port = proxyUrl.port;
    /* The proxy URL uses the scheme "http:", which has a default port number of
     * 80. We need to set that explicitly here if it is omitted because otherwise
     * it will use gRPC's default port 443. */
    if (port === '') {
        port = '80';
    }
    const result = {
        address: `${hostname}:${port}`,
    };
    if (userCred) {
        result.creds = userCred;
    }
    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);
    return result;
}
function getNoProxyHostList() {
    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
    let noProxyStr = process.env.no_grpc_proxy;
    let envVar = 'no_grpc_proxy';
    if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = 'no_proxy';
    }
    if (noProxyStr) {
        trace('No proxy server list set by environment variable ' + envVar);
        return noProxyStr.split(',');
    }
    else {
        return [];
    }
}
function mapProxyName(target, options) {
    var _a;
    const noProxyResult = {
        target: target,
        extraOptions: {},
    };
    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
    }
    if (target.scheme === 'unix') {
        return noProxyResult;
    }
    const proxyInfo = getProxyInfo();
    if (!proxyInfo.address) {
        return noProxyResult;
    }
    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
    if (!hostPort) {
        return noProxyResult;
    }
    const serverHost = hostPort.host;
    for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));
            return noProxyResult;
        }
    }
    const extraOptions = {
        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),
    };
    if (proxyInfo.creds) {
        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
    }
    return {
        target: {
            scheme: 'dns',
            path: proxyInfo.address,
        },
        extraOptions: extraOptions,
    };
}
function getProxiedConnection(address, channelOptions, connectionOptions) {
    var _a;
    if (!('grpc.http_connect_target' in channelOptions)) {
        return Promise.resolve({});
    }
    const realTarget = channelOptions['grpc.http_connect_target'];
    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
    if (parsedTarget === null) {
        return Promise.resolve({});
    }
    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);
    if (splitHostPost === null) {
        return Promise.resolve({});
    }
    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;
    const options = {
        method: 'CONNECT',
        path: hostPort,
    };
    const headers = {
        Host: hostPort,
    };
    // Connect to the subchannel address as a proxy
    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
        options.host = address.host;
        options.port = address.port;
    }
    else {
        options.socketPath = address.path;
    }
    if ('grpc.http_connect_creds' in channelOptions) {
        headers['Proxy-Authorization'] =
            'Basic ' +
                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');
    }
    options.headers = headers;
    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
    return new Promise((resolve, reject) => {
        const request = http.request(options);
        request.once('connect', (res, socket, head) => {
            var _a;
            request.removeAllListeners();
            socket.removeAllListeners();
            if (res.statusCode === 200) {
                trace('Successfully connected to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString);
                // The HTTP client may have already read a few bytes of the proxied
                // connection. If that's the case, put them back into the socket.
                // See https://github.com/grpc/grpc-node/issues/2744.
                if (head.length > 0) {
                    socket.unshift(head);
                }
                if ('secureContext' in connectionOptions) {
                    /* The proxy is connecting to a TLS server, so upgrade this socket
                     * connection to a TLS connection.
                     * This is a workaround for https://github.com/nodejs/node/issues/32922
                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
                    const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);
                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {
                        trace('Successfully established a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString);
                        resolve({ socket: cts, realTarget: parsedTarget });
                    });
                    cts.on('error', (error) => {
                        trace('Failed to establish a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString +
                            ' with error ' +
                            error.message);
                        reject();
                    });
                }
                else {
                    trace('Successfully established a plaintext connection to ' +
                        options.path +
                        ' through proxy ' +
                        proxyAddressString);
                    resolve({
                        socket,
                        realTarget: parsedTarget,
                    });
                }
            }
            else {
                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString +
                    ' with status ' +
                    res.statusCode);
                reject();
            }
        });
        request.once('error', err => {
            request.removeAllListeners();
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +
                proxyAddressString +
                ' with error ' +
                err.message);
            reject();
        });
        request.end();
    });
}
//# sourceMappingURL=http_proxy.js.map{"version":3,"file":"http_proxy.js","sourceRoot":"","sources":["../../src/http_proxy.ts"],"names":[],"mappings":"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"}import { ClientDuplexStream, ClientReadableStream, ClientUnaryCall, ClientWritableStream, ServiceError } from './call';
import { CallCredentials, OAuth2Client } from './call-credentials';
import { StatusObject } from './call-interface';
import { Channel, ChannelImplementation } from './channel';
import { CompressionAlgorithms } from './compression-algorithms';
import { ConnectivityState } from './connectivity-state';
import { ChannelCredentials, VerifyOptions } from './channel-credentials';
import { CallOptions, Client, ClientOptions, CallInvocationTransformer, CallProperties, UnaryCallback } from './client';
import { LogVerbosity, Status, Propagate } from './constants';
import { Deserialize, loadPackageDefinition, makeClientConstructor, MethodDefinition, Serialize, ServiceDefinition } from './make-client';
import { Metadata, MetadataOptions, MetadataValue } from './metadata';
import { ConnectionInjector, Server, ServerOptions, UntypedHandleCall, UntypedServiceImplementation } from './server';
import { KeyCertPair, ServerCredentials } from './server-credentials';
import { StatusBuilder } from './status-builder';
import { handleBidiStreamingCall, handleServerStreamingCall, handleClientStreamingCall, handleUnaryCall, sendUnaryData, ServerUnaryCall, ServerReadableStream, ServerWritableStream, ServerDuplexStream, ServerErrorResponse } from './server-call';
export { OAuth2Client };
/**** Client Credentials ****/
export declare const credentials: {
    /**
     * Combine a ChannelCredentials with any number of CallCredentials into a
     * single ChannelCredentials object.
     * @param channelCredentials The ChannelCredentials object.
     * @param callCredentials Any number of CallCredentials objects.
     * @return The resulting ChannelCredentials object.
     */
    combineChannelCredentials: (channelCredentials: ChannelCredentials, ...callCredentials: CallCredentials[]) => ChannelCredentials;
    /**
     * Combine any number of CallCredentials into a single CallCredentials
     * object.
     * @param first The first CallCredentials object.
     * @param additional Any number of additional CallCredentials objects.
     * @return The resulting CallCredentials object.
     */
    combineCallCredentials: (first: CallCredentials, ...additional: CallCredentials[]) => CallCredentials;
    createInsecure: typeof ChannelCredentials.createInsecure;
    createSsl: typeof ChannelCredentials.createSsl;
    createFromSecureContext: typeof ChannelCredentials.createFromSecureContext;
    createFromMetadataGenerator: typeof CallCredentials.createFromMetadataGenerator;
    createFromGoogleCredential: typeof CallCredentials.createFromGoogleCredential;
    createEmpty: typeof CallCredentials.createEmpty;
};
/**** Metadata ****/
export { Metadata, MetadataOptions, MetadataValue };
/**** Constants ****/
export { LogVerbosity as logVerbosity, Status as status, ConnectivityState as connectivityState, Propagate as propagate, CompressionAlgorithms as compressionAlgorithms, };
/**** Client ****/
export { Client, ClientOptions, loadPackageDefinition, makeClientConstructor, makeClientConstructor as makeGenericClientConstructor, CallProperties, CallInvocationTransformer, ChannelImplementation as Channel, Channel as ChannelInterface, UnaryCallback as requestCallback, };
/**
 * Close a Client object.
 * @param client The client to close.
 */
export declare const closeClient: (client: Client) => void;
export declare const waitForClientReady: (client: Client, deadline: Date | number, callback: (error?: Error) => void) => void;
export { sendUnaryData, ChannelCredentials, CallCredentials, Deadline, Serialize as serialize, Deserialize as deserialize, ClientUnaryCall, ClientReadableStream, ClientWritableStream, ClientDuplexStream, CallOptions, MethodDefinition, StatusObject, ServiceError, ServerUnaryCall, ServerReadableStream, ServerWritableStream, ServerDuplexStream, ServerErrorResponse, ServiceDefinition, UntypedHandleCall, UntypedServiceImplementation, VerifyOptions, };
/**** Server ****/
export { handleBidiStreamingCall, handleServerStreamingCall, handleUnaryCall, handleClientStreamingCall, };
export type Call = ClientUnaryCall | ClientReadableStream<any> | ClientWritableStream<any> | ClientDuplexStream<any, any>;
/**** Unimplemented function stubs ****/
export declare const loadObject: (value: any, options: any) => never;
export declare const load: (filename: any, format: any, options: any) => never;
export declare const setLogger: (logger: Partial<Console>) => void;
export declare const setLogVerbosity: (verbosity: LogVerbosity) => void;
export { ConnectionInjector, Server, ServerOptions };
export { ServerCredentials };
export { KeyCertPair };
export declare const getClientChannel: (client: Client) => Channel;
export { StatusBuilder };
export { Listener, InterceptingListener } from './call-interface';
export { Requester, ListenerBuilder, RequesterBuilder, Interceptor, InterceptorOptions, InterceptorProvider, InterceptingCall, InterceptorConfigurationError, NextCall, } from './client-interceptors';
export { GrpcObject, ServiceClientConstructor, ProtobufTypeDefinition, } from './make-client';
export { ChannelOptions } from './channel-options';
export { getChannelzServiceDefinition, getChannelzHandlers } from './channelz';
export { addAdminServicesToServer } from './admin';
export { ServiceConfig, LoadBalancingConfig, MethodConfig, RetryPolicy, } from './service-config';
export { ServerListener, FullServerListener, ServerListenerBuilder, Responder, FullResponder, ResponderBuilder, ServerInterceptingCallInterface, ServerInterceptingCall, ServerInterceptor, } from './server-interceptors';
import * as experimental from './experimental';
export { experimental };
import { Deadline } from './deadline';
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;
const call_credentials_1 = require("./call-credentials");
Object.defineProperty(exports, "CallCredentials", { enumerable: true, get: function () { return call_credentials_1.CallCredentials; } });
const channel_1 = require("./channel");
Object.defineProperty(exports, "Channel", { enumerable: true, get: function () { return channel_1.ChannelImplementation; } });
const compression_algorithms_1 = require("./compression-algorithms");
Object.defineProperty(exports, "compressionAlgorithms", { enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } });
const connectivity_state_1 = require("./connectivity-state");
Object.defineProperty(exports, "connectivityState", { enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } });
const channel_credentials_1 = require("./channel-credentials");
Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } });
const client_1 = require("./client");
Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
const constants_1 = require("./constants");
Object.defineProperty(exports, "logVerbosity", { enumerable: true, get: function () { return constants_1.LogVerbosity; } });
Object.defineProperty(exports, "status", { enumerable: true, get: function () { return constants_1.Status; } });
Object.defineProperty(exports, "propagate", { enumerable: true, get: function () { return constants_1.Propagate; } });
const logging = require("./logging");
const make_client_1 = require("./make-client");
Object.defineProperty(exports, "loadPackageDefinition", { enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } });
Object.defineProperty(exports, "makeClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
Object.defineProperty(exports, "makeGenericClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
const metadata_1 = require("./metadata");
Object.defineProperty(exports, "Metadata", { enumerable: true, get: function () { return metadata_1.Metadata; } });
const server_1 = require("./server");
Object.defineProperty(exports, "Server", { enumerable: true, get: function () { return server_1.Server; } });
const server_credentials_1 = require("./server-credentials");
Object.defineProperty(exports, "ServerCredentials", { enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } });
const status_builder_1 = require("./status-builder");
Object.defineProperty(exports, "StatusBuilder", { enumerable: true, get: function () { return status_builder_1.StatusBuilder; } });
/**** Client Credentials ****/
// Using assign only copies enumerable properties, which is what we want
exports.credentials = {
    /**
     * Combine a ChannelCredentials with any number of CallCredentials into a
     * single ChannelCredentials object.
     * @param channelCredentials The ChannelCredentials object.
     * @param callCredentials Any number of CallCredentials objects.
     * @return The resulting ChannelCredentials object.
     */
    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
    },
    /**
     * Combine any number of CallCredentials into a single CallCredentials
     * object.
     * @param first The first CallCredentials object.
     * @param additional Any number of additional CallCredentials objects.
     * @return The resulting CallCredentials object.
     */
    combineCallCredentials: (first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
    },
    // from channel-credentials.ts
    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
    // from call-credentials.ts
    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
    createEmpty: call_credentials_1.CallCredentials.createEmpty,
};
/**
 * Close a Client object.
 * @param client The client to close.
 */
const closeClient = (client) => client.close();
exports.closeClient = closeClient;
const waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
exports.waitForClientReady = waitForClientReady;
/* eslint-enable @typescript-eslint/no-explicit-any */
/**** Unimplemented function stubs ****/
/* eslint-disable @typescript-eslint/no-explicit-any */
const loadObject = (value, options) => {
    throw new Error('Not available in this library. Use @postman/proto-loader and loadPackageDefinition instead');
};
exports.loadObject = loadObject;
const load = (filename, format, options) => {
    throw new Error('Not available in this library. Use @postman/proto-loader and loadPackageDefinition instead');
};
exports.load = load;
const setLogger = (logger) => {
    logging.setLogger(logger);
};
exports.setLogger = setLogger;
const setLogVerbosity = (verbosity) => {
    logging.setLoggerVerbosity(verbosity);
};
exports.setLogVerbosity = setLogVerbosity;
const getClientChannel = (client) => {
    return client_1.Client.prototype.getChannel.call(client);
};
exports.getClientChannel = getClientChannel;
var client_interceptors_1 = require("./client-interceptors");
Object.defineProperty(exports, "ListenerBuilder", { enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } });
Object.defineProperty(exports, "RequesterBuilder", { enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } });
Object.defineProperty(exports, "InterceptingCall", { enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } });
Object.defineProperty(exports, "InterceptorConfigurationError", { enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } });
var channelz_1 = require("./channelz");
Object.defineProperty(exports, "getChannelzServiceDefinition", { enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } });
Object.defineProperty(exports, "getChannelzHandlers", { enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } });
var admin_1 = require("./admin");
Object.defineProperty(exports, "addAdminServicesToServer", { enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } });
var server_interceptors_1 = require("./server-interceptors");
Object.defineProperty(exports, "ServerListenerBuilder", { enumerable: true, get: function () { return server_interceptors_1.ServerListenerBuilder; } });
Object.defineProperty(exports, "ResponderBuilder", { enumerable: true, get: function () { return server_interceptors_1.ResponderBuilder; } });
Object.defineProperty(exports, "ServerInterceptingCall", { enumerable: true, get: function () { return server_interceptors_1.ServerInterceptingCall; } });
const experimental = require("./experimental");
exports.experimental = experimental;
const resolver_dns = require("./resolver-dns");
const resolver_uds = require("./resolver-uds");
const resolver_ip = require("./resolver-ip");
const load_balancer_pick_first = require("./load-balancer-pick-first");
const load_balancer_round_robin = require("./load-balancer-round-robin");
const load_balancer_outlier_detection = require("./load-balancer-outlier-detection");
const channelz = require("./channelz");
(() => {
    resolver_dns.setup();
    resolver_uds.setup();
    resolver_ip.setup();
    load_balancer_pick_first.setup();
    load_balancer_round_robin.setup();
    load_balancer_outlier_detection.setup();
    channelz.setup();
})();
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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"}import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { PickResult } from './picker';
import { Metadata } from './metadata';
import { CallConfig } from './resolver';
import { ServerSurfaceCall } from './server-call';
import { ConnectivityState } from './connectivity-state';
import { ChannelRef } from './channelz';
import { LoadBalancingCall } from './load-balancing-call';
import { CallCredentials } from './call-credentials';
import { Call, StatusObject } from './call-interface';
import { Deadline } from './deadline';
import { ResolvingCall } from './resolving-call';
import { RetryingCall } from './retrying-call';
import { BaseSubchannelWrapper, SubchannelInterface } from './subchannel-interface';
interface NoneConfigResult {
    type: 'NONE';
}
interface SuccessConfigResult {
    type: 'SUCCESS';
    config: CallConfig;
}
interface ErrorConfigResult {
    type: 'ERROR';
    error: StatusObject;
}
type GetConfigResult = NoneConfigResult | SuccessConfigResult | ErrorConfigResult;
declare class ChannelSubchannelWrapper extends BaseSubchannelWrapper implements SubchannelInterface {
    private channel;
    private refCount;
    private subchannelStateListener;
    constructor(childSubchannel: SubchannelInterface, channel: InternalChannel);
    ref(): void;
    unref(): void;
}
export declare class InternalChannel {
    private readonly credentials;
    private readonly options;
    private readonly resolvingLoadBalancer;
    private readonly subchannelPool;
    private connectivityState;
    private currentPicker;
    /**
     * Calls queued up to get a call config. Should only be populated before the
     * first time the resolver returns a result, which includes the ConfigSelector.
     */
    private configSelectionQueue;
    private pickQueue;
    private connectivityStateWatchers;
    private readonly defaultAuthority;
    private readonly filterStackFactory;
    private readonly target;
    /**
     * This timer does not do anything on its own. Its purpose is to hold the
     * event loop open while there are any pending calls for the channel that
     * have not yet been assigned to specific subchannels. In other words,
     * the invariant is that callRefTimer is reffed if and only if pickQueue
     * is non-empty.
     */
    private readonly callRefTimer;
    private configSelector;
    /**
     * This is the error from the name resolver if it failed most recently. It
     * is only used to end calls that start while there is no config selector
     * and the name resolver is in backoff, so it should be nulled if
     * configSelector becomes set or the channel state becomes anything other
     * than TRANSIENT_FAILURE.
     */
    private currentResolutionError;
    private readonly retryBufferTracker;
    private keepaliveTime;
    private readonly wrappedSubchannels;
    private callCount;
    private idleTimer;
    private readonly idleTimeoutMs;
    private lastActivityTimestamp;
    private readonly channelzEnabled;
    private readonly originalTarget;
    private readonly channelzRef;
    private readonly channelzTrace;
    private readonly callTracker;
    private readonly childrenTracker;
    /**
     * Randomly generated ID to be passed to the config selector, for use by
     * ring_hash in xDS. An integer distributed approximately uniformly between
     * 0 and MAX_SAFE_INTEGER.
     */
    private readonly randomChannelId;
    constructor(target: string, credentials: ChannelCredentials, options: ChannelOptions);
    private getChannelzInfo;
    private trace;
    private callRefTimerRef;
    private callRefTimerUnref;
    private removeConnectivityStateWatcher;
    private updateState;
    throttleKeepalive(newKeepaliveTime: number): void;
    removeWrappedSubchannel(wrappedSubchannel: ChannelSubchannelWrapper): void;
    doPick(metadata: Metadata, extraPickInfo: {
        [key: string]: string;
    }): PickResult;
    queueCallForPick(call: LoadBalancingCall): void;
    getConfig(method: string, metadata: Metadata): GetConfigResult;
    queueCallForConfig(call: ResolvingCall): void;
    private enterIdle;
    private startIdleTimeout;
    private maybeStartIdleTimer;
    private onCallStart;
    private onCallEnd;
    createLoadBalancingCall(callConfig: CallConfig, method: string, host: string, credentials: CallCredentials, deadline: Deadline): LoadBalancingCall;
    createRetryingCall(callConfig: CallConfig, method: string, host: string, credentials: CallCredentials, deadline: Deadline): RetryingCall;
    createInnerCall(callConfig: CallConfig, method: string, host: string, credentials: CallCredentials, deadline: Deadline): LoadBalancingCall | RetryingCall;
    createResolvingCall(method: string, deadline: Deadline, host: string | null | undefined, parentCall: ServerSurfaceCall | null, propagateFlags: number | null | undefined): ResolvingCall;
    close(): void;
    getTarget(): string;
    getConnectivityState(tryToConnect: boolean): ConnectivityState;
    watchConnectivityState(currentState: ConnectivityState, deadline: Date | number, callback: (error?: Error) => void): void;
    /**
     * Get the channelz reference object for this channel. The returned value is
     * garbage if channelz is disabled for this channel.
     * @returns
     */
    getChannelzRef(): ChannelRef;
    createCall(method: string, deadline: Deadline, host: string | null | undefined, parentCall: ServerSurfaceCall | null, propagateFlags: number | null | undefined): Call;
    getOptions(): ChannelOptions;
}
export {};
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalChannel = void 0;
const channel_credentials_1 = require("./channel-credentials");
const resolving_load_balancer_1 = require("./resolving-load-balancer");
const subchannel_pool_1 = require("./subchannel-pool");
const picker_1 = require("./picker");
const metadata_1 = require("./metadata");
const constants_1 = require("./constants");
const filter_stack_1 = require("./filter-stack");
const compression_filter_1 = require("./compression-filter");
const resolver_1 = require("./resolver");
const logging_1 = require("./logging");
const http_proxy_1 = require("./http_proxy");
const uri_parser_1 = require("./uri-parser");
const connectivity_state_1 = require("./connectivity-state");
const channelz_1 = require("./channelz");
const load_balancing_call_1 = require("./load-balancing-call");
const deadline_1 = require("./deadline");
const resolving_call_1 = require("./resolving-call");
const call_number_1 = require("./call-number");
const control_plane_status_1 = require("./control-plane-status");
const retrying_call_1 = require("./retrying-call");
const subchannel_interface_1 = require("./subchannel-interface");
/**
 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
 */
const MAX_TIMEOUT_TIME = 2147483647;
const MIN_IDLE_TIMEOUT_MS = 1000;
// 30 minutes
const DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;
const RETRY_THROTTLER_MAP = new Map();
const DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB
const DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB
class ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
    constructor(childSubchannel, channel) {
        super(childSubchannel);
        this.channel = channel;
        this.refCount = 0;
        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
            channel.throttleKeepalive(keepaliveTime);
        };
        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);
    }
    ref() {
        this.child.ref();
        this.refCount += 1;
    }
    unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
            this.child.removeConnectivityStateListener(this.subchannelStateListener);
            this.channel.removeWrappedSubchannel(this);
        }
    }
}
class ShutdownPicker {
    pick(pickArgs) {
        return {
            pickResultType: picker_1.PickResultType.DROP,
            status: {
                code: constants_1.Status.UNAVAILABLE,
                details: 'Channel closed before call started',
                metadata: new metadata_1.Metadata()
            },
            subchannel: null,
            onCallStarted: null,
            onCallEnded: null
        };
    }
}
class InternalChannel {
    constructor(target, credentials, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        /**
         * Calls queued up to get a call config. Should only be populated before the
         * first time the resolver returns a result, which includes the ConfigSelector.
         */
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        /**
         * This is the error from the name resolver if it failed most recently. It
         * is only used to end calls that start while there is no config selector
         * and the name resolver is in backoff, so it should be nulled if
         * configSelector becomes set or the channel state becomes anything other
         * than TRANSIENT_FAILURE.
         */
        this.currentResolutionError = null;
        this.wrappedSubchannels = new Set();
        this.callCount = 0;
        this.idleTimer = null;
        // Channelz info
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        /**
         * Randomly generated ID to be passed to the config selector, for use by
         * ring_hash in xDS. An integer distributed approximately uniformly between
         * 0 and MAX_SAFE_INTEGER.
         */
        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        if (typeof target !== 'string') {
            throw new TypeError('Channel target must be a string');
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
            throw new TypeError('Channel credentials must be a ChannelCredentials object');
        }
        if (options) {
            if (typeof options !== 'object') {
                throw new TypeError('Channel options must be an object');
            }
        }
        this.originalTarget = target;
        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
        if (originalTargetUri === null) {
            throw new Error(`Could not parse target name "${target}"`);
        }
        /* This ensures that the target has a scheme that is registered with the
         * resolver */
        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
        if (defaultSchemeMapResult === null) {
            throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options['grpc.enable_channelz'] === 0) {
            this.channelzEnabled = false;
        }
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
            this.channelzTrace.addTrace('CT_INFO', 'Channel created');
        }
        if (this.options['grpc.default_authority']) {
            this.defaultAuthority = this.options['grpc.default_authority'];
        }
        else {
            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
        }
        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
         * the grpc.use_local_subchannel_pool channel option means. */
        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);
        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== void 0 ? _f : -1;
        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
        const channelControlHelper = {
            createSubchannel: (subchannelAddress, subchannelArgs) => {
                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
                subchannel.throttleKeepalive(this.keepaliveTime);
                if (this.channelzEnabled) {
                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());
                }
                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
                this.wrappedSubchannels.add(wrappedSubchannel);
                return wrappedSubchannel;
            },
            updateState: (connectivityState, picker) => {
                this.currentPicker = picker;
                const queueCopy = this.pickQueue.slice();
                this.pickQueue = [];
                if (queueCopy.length > 0) {
                    this.callRefTimerUnref();
                }
                for (const call of queueCopy) {
                    call.doPick();
                }
                this.updateState(connectivityState);
            },
            requestReresolution: () => {
                // This should never be called.
                throw new Error('Resolving load balancer should never call requestReresolution');
            },
            addChannelzChild: (child) => {
                if (this.channelzEnabled) {
                    this.childrenTracker.refChild(child);
                }
            },
            removeChannelzChild: (child) => {
                if (this.channelzEnabled) {
                    this.childrenTracker.unrefChild(child);
                }
            },
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {
            if (serviceConfig.retryThrottling) {
                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
            }
            else {
                RETRY_THROTTLER_MAP.delete(this.getTarget());
            }
            if (this.channelzEnabled) {
                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');
            }
            this.configSelector = configSelector;
            this.currentResolutionError = null;
            /* We process the queue asynchronously to ensure that the corresponding
             * load balancer update has completed. */
            process.nextTick(() => {
                const localQueue = this.configSelectionQueue;
                this.configSelectionQueue = [];
                if (localQueue.length > 0) {
                    this.callRefTimerUnref();
                }
                for (const call of localQueue) {
                    call.getConfig();
                }
            });
        }, status => {
            if (this.channelzEnabled) {
                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +
                    status.code +
                    ' and details "' +
                    status.details +
                    '"');
            }
            if (this.configSelectionQueue.length > 0) {
                this.trace('Name resolution failed with calls queued for config selection');
            }
            if (this.configSelector === null) {
                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
            }
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            if (localQueue.length > 0) {
                this.callRefTimerUnref();
            }
            for (const call of localQueue) {
                call.reportResolverError(status);
            }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
            new compression_filter_1.CompressionFilterFactory(this, this.options),
        ]);
        this.trace('Channel constructed with options ' +
            JSON.stringify(options, undefined, 2));
        const error = new Error();
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +
            this.channelzRef.id +
            ') ' +
            'Channel constructed \n' +
            ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf('\n') + 1)));
        this.lastActivityTimestamp = new Date();
    }
    getChannelzInfo() {
        return {
            target: this.originalTarget,
            state: this.connectivityState,
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            children: this.childrenTracker.getChildLists(),
        };
    }
    trace(text, verbosityOverride) {
        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);
    }
    callRefTimerRef() {
        var _a, _b, _c, _d;
        // If the hasRef function does not exist, always run the code
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
            this.trace('callRefTimer.ref | configSelectionQueue.length=' +
                this.configSelectionQueue.length +
                ' pickQueue.length=' +
                this.pickQueue.length);
            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
    }
    callRefTimerUnref() {
        var _a, _b;
        // If the hasRef function does not exist, always run the code
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
            this.trace('callRefTimer.unref | configSelectionQueue.length=' +
                this.configSelectionQueue.length +
                ' pickQueue.length=' +
                this.pickQueue.length);
            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    }
    removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);
        if (watcherIndex >= 0) {
            this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
    }
    updateState(newState) {
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +
            this.channelzRef.id +
            ') ' +
            (0, uri_parser_1.uriToString)(this.target) +
            ' ' +
            connectivity_state_1.ConnectivityState[this.connectivityState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
        }
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
            if (newState !== watcherObject.currentState) {
                if (watcherObject.timer) {
                    clearTimeout(watcherObject.timer);
                }
                this.removeConnectivityStateWatcher(watcherObject);
                watcherObject.callback();
            }
        }
        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.currentResolutionError = null;
        }
    }
    throttleKeepalive(newKeepaliveTime) {
        if (newKeepaliveTime > this.keepaliveTime) {
            this.keepaliveTime = newKeepaliveTime;
            for (const wrappedSubchannel of this.wrappedSubchannels) {
                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
            }
        }
    }
    removeWrappedSubchannel(wrappedSubchannel) {
        this.wrappedSubchannels.delete(wrappedSubchannel);
    }
    doPick(metadata, extraPickInfo) {
        return this.currentPicker.pick({
            metadata: metadata,
            extraPickInfo: extraPickInfo,
        });
    }
    queueCallForPick(call) {
        this.pickQueue.push(call);
        this.callRefTimerRef();
    }
    getConfig(method, metadata) {
        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {
            this.resolvingLoadBalancer.exitIdle();
        }
        if (this.configSelector) {
            return {
                type: 'SUCCESS',
                config: this.configSelector(method, metadata, this.randomChannelId),
            };
        }
        else {
            if (this.currentResolutionError) {
                return {
                    type: 'ERROR',
                    error: this.currentResolutionError,
                };
            }
            else {
                return {
                    type: 'NONE',
                };
            }
        }
    }
    queueCallForConfig(call) {
        this.configSelectionQueue.push(call);
        this.callRefTimerRef();
    }
    enterIdle() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.IDLE);
        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
        if (this.idleTimer) {
            clearTimeout(this.idleTimer);
            this.idleTimer = null;
        }
    }
    startIdleTimeout(timeoutMs) {
        var _a, _b;
        this.idleTimer = setTimeout(() => {
            if (this.callCount > 0) {
                /* If there is currently a call, the channel will not go idle for a
                 * period of at least idleTimeoutMs, so check again after that time.
                 */
                this.startIdleTimeout(this.idleTimeoutMs);
                return;
            }
            const now = new Date();
            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
            if (timeSinceLastActivity >= this.idleTimeoutMs) {
                this.trace('Idle timer triggered after ' +
                    this.idleTimeoutMs +
                    'ms of inactivity');
                this.enterIdle();
            }
            else {
                /* Whenever the timer fires with the latest activity being too recent,
                 * set the timer again for the time when the time since the last
                 * activity is equal to the timeout. This should result in the timer
                 * firing no more than once every idleTimeoutMs/2 on average. */
                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
            }
        }, timeoutMs);
        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    maybeStartIdleTimer() {
        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN &&
            !this.idleTimer) {
            this.startIdleTimeout(this.idleTimeoutMs);
        }
    }
    onCallStart() {
        if (this.channelzEnabled) {
            this.callTracker.addCallStarted();
        }
        this.callCount += 1;
    }
    onCallEnd(status) {
        if (this.channelzEnabled) {
            if (status.code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
            }
            else {
                this.callTracker.addCallFailed();
            }
        }
        this.callCount -= 1;
        this.lastActivityTimestamp = new Date();
        this.maybeStartIdleTimer();
    }
    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace('createLoadBalancingCall [' + callNumber + '] method="' + method + '"');
        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
    }
    createRetryingCall(callConfig, method, host, credentials, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace('createRetryingCall [' + callNumber + '] method="' + method + '"');
        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
    }
    createInnerCall(callConfig, method, host, credentials, deadline) {
        // Create a RetryingCall if retries are enabled
        if (this.options['grpc.enable_retries'] === 0) {
            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
        }
        else {
            return this.createRetryingCall(callConfig, method, host, credentials, deadline);
        }
    }
    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace('createResolvingCall [' +
            callNumber +
            '] method="' +
            method +
            '", deadline=' +
            (0, deadline_1.deadlineToString)(deadline));
        const finalOptions = {
            deadline: deadline,
            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
            host: host !== null && host !== void 0 ? host : this.defaultAuthority,
            parentCall: parentCall,
        };
        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
        this.onCallStart();
        call.addStatusWatcher(status => {
            this.onCallEnd(status);
        });
        return call;
    }
    close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
        this.currentPicker = new ShutdownPicker();
        for (const call of this.configSelectionQueue) {
            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');
        }
        this.configSelectionQueue = [];
        for (const call of this.pickQueue) {
            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');
        }
        this.pickQueue = [];
        clearInterval(this.callRefTimer);
        if (this.idleTimer) {
            clearTimeout(this.idleTimer);
        }
        if (this.channelzEnabled) {
            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        }
        this.subchannelPool.unrefUnusedSubchannels();
    }
    getTarget() {
        return (0, uri_parser_1.uriToString)(this.target);
    }
    getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
            this.resolvingLoadBalancer.exitIdle();
            this.lastActivityTimestamp = new Date();
            this.maybeStartIdleTimer();
        }
        return connectivityState;
    }
    watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        let timer = null;
        if (deadline !== Infinity) {
            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
            const now = new Date();
            if (deadline === -Infinity || deadlineDate <= now) {
                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
                return;
            }
            timer = setTimeout(() => {
                this.removeConnectivityStateWatcher(watcherObject);
                callback(new Error('Deadline passed without connectivity state change'));
            }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
            currentState,
            callback,
            timer,
        };
        this.connectivityStateWatchers.push(watcherObject);
    }
    /**
     * Get the channelz reference object for this channel. The returned value is
     * garbage if channelz is disabled for this channel.
     * @returns
     */
    getChannelzRef() {
        return this.channelzRef;
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== 'string') {
            throw new TypeError('Channel#createCall: method must be a string');
        }
        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
            throw new TypeError('Channel#createCall: deadline must be a number or Date');
        }
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
            throw new Error('Channel has been shut down');
        }
        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
    }
    getOptions() {
        return this.options;
    }
}
exports.InternalChannel = InternalChannel;
//# sourceMappingURL=internal-channel.js.map{"version":3,"file":"internal-channel.js","sourceRoot":"","sources":["../../src/internal-channel.ts"],"names":[],"mappings":"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"}import { LoadBalancer, ChannelControlHelper, TypedLoadBalancingConfig } from './load-balancer';
import { Endpoint } from './subchannel-address';
import { ChannelOptions } from './channel-options';
export declare class ChildLoadBalancerHandler implements LoadBalancer {
    private readonly channelControlHelper;
    private readonly options;
    private currentChild;
    private pendingChild;
    private latestConfig;
    private ChildPolicyHelper;
    constructor(channelControlHelper: ChannelControlHelper, options: ChannelOptions);
    protected configUpdateRequiresNewPolicyInstance(oldConfig: TypedLoadBalancingConfig, newConfig: TypedLoadBalancingConfig): boolean;
    /**
     * Prerequisites: lbConfig !== null and lbConfig.name is registered
     * @param endpointList
     * @param lbConfig
     * @param attributes
     */
    updateAddressList(endpointList: Endpoint[], lbConfig: TypedLoadBalancingConfig, attributes: {
        [key: string]: unknown;
    }): void;
    exitIdle(): void;
    resetBackoff(): void;
    destroy(): void;
    getTypeName(): string;
}
"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChildLoadBalancerHandler = void 0;
const load_balancer_1 = require("./load-balancer");
const connectivity_state_1 = require("./connectivity-state");
const TYPE_NAME = 'child_load_balancer_helper';
class ChildLoadBalancerHandler {
    constructor(channelControlHelper, options) {
        this.channelControlHelper = channelControlHelper;
        this.options = options;
        this.currentChild = null;
        this.pendingChild = null;
        this.latestConfig = null;
        this.ChildPolicyHelper = class {
            constructor(parent) {
                this.parent = parent;
                this.child = null;
            }
            createSubchannel(subchannelAddress, subchannelArgs) {
                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
            }
            updateState(connectivityState, picker) {
                var _a;
                if (this.calledByPendingChild()) {
                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
                        return;
                    }
                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.parent.currentChild = this.parent.pendingChild;
                    this.parent.pendingChild = null;
                }
                else if (!this.calledByCurrentChild()) {
                    return;
                }
                this.parent.channelControlHelper.updateState(connectivityState, picker);
            }
            requestReresolution() {
                var _a;
                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
                if (this.child === latestChild) {
                    this.parent.channelControlHelper.requestReresolution();
                }
            }
            setChild(newChild) {
                this.child = newChild;
            }
            addChannelzChild(child) {
                this.parent.channelControlHelper.addChannelzChild(child);
            }
            removeChannelzChild(child) {
                this.parent.channelControlHelper.removeChannelzChild(child);
            }
            calledByPendingChild() {
                return this.child === this.parent.pendingChild;
            }
            calledByCurrentChild() {
                return this.child === this.parent.currentChild;
            }
        };
    }
    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
    }
    /**
     * Prerequisites: lbConfig !== null and lbConfig.name is registered
     * @param endpointList
     * @param lbConfig
     * @param attributes
     */
    updateAddressList(endpointList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null ||
            this.latestConfig === null ||
            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
            const newHelper = new this.ChildPolicyHelper(this);
            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper, this.options);
            newHelper.setChild(newChild);
            if (this.currentChild === null) {
                this.currentChild = newChild;
                childToUpdate = this.currentChild;
            }
            else {
                if (this.pendingChild) {
                    this.pendingChild.destroy();
                }
                this.pendingChild = newChild;
                childToUpdate = this.pendingChild;
            }
        }
        else {
            if (this.pendingChild === null) {
                childToUpdate = this.currentChild;
            }
            else {
                childToUpdate = this.pendingChild;
            }
        }
        this.latestConfig = lbConfig;
        childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
    }
    exitIdle() {
        if (this.currentChild) {
            this.currentChild.exitIdle();
            if (this.pendingChild) {
                this.pendingChild.exitIdle();
            }
        }
    }
    resetBackoff() {
        if (this.currentChild) {
            this.currentChild.resetBackoff();
            if (this.pendingChild) {
                this.pendingChild.resetBackoff();
            }
        }
    }
    destroy() {
        /* Note: state updates are only propagated from the child balancer if that
         * object is equal to this.currentChild or this.pendingChild. Since this
         * function sets both of those to null, no further state updates will
         * occur after this function returns. */
        if (this.currentChild) {
            this.currentChild.destroy();
            this.currentChild = null;
        }
        if (this.pendingChild) {
            this.pendingChild.destroy();
            this.pendingChild = null;
        }
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
//# sourceMappingURL=load-balancer-child-handler.js.map{"version":3,"file":"load-balancer-child-handler.js","sourceRoot":"","sources":["../../src/load-balancer-child-handler.ts"],"names":[],"mappings":"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"}import { ChannelOptions } from './channel-options';
import { Duration } from './duration';
import { ChannelControlHelper } from './experimental';
import { LoadBalancer, TypedLoadBalancingConfig } from './load-balancer';
import { Endpoint } from './subchannel-address';
import { LoadBalancingConfig } from './service-config';
export interface SuccessRateEjectionConfig {
    readonly stdev_factor: number;
    readonly enforcement_percentage: number;
    readonly minimum_hosts: number;
    readonly request_volume: number;
}
export interface FailurePercentageEjectionConfig {
    readonly threshold: number;
    readonly enforcement_percentage: number;
    readonly minimum_hosts: number;
    readonly request_volume: number;
}
export interface OutlierDetectionRawConfig {
    interval?: Duration;
    base_ejection_time?: Duration;
    max_ejection_time?: Duration;
    max_ejection_percent?: number;
    success_rate_ejection?: Partial<SuccessRateEjectionConfig>;
    failure_percentage_ejection?: Partial<FailurePercentageEjectionConfig>;
    child_policy: LoadBalancingConfig[];
}
export declare class OutlierDetectionLoadBalancingConfig implements TypedLoadBalancingConfig {
    private readonly childPolicy;
    private readonly intervalMs;
    private readonly baseEjectionTimeMs;
    private readonly maxEjectionTimeMs;
    private readonly maxEjectionPercent;
    private readonly successRateEjection;
    private readonly failurePercentageEjection;
    constructor(intervalMs: number | null, baseEjectionTimeMs: number | null, maxEjectionTimeMs: number | null, maxEjectionPercent: number | null, successRateEjection: Partial<SuccessRateEjectionConfig> | null, failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null, childPolicy: TypedLoadBalancingConfig);
    getLoadBalancerName(): string;
    toJsonObject(): object;
    getIntervalMs(): number;
    getBaseEjectionTimeMs(): number;
    getMaxEjectionTimeMs(): number;
    getMaxEjectionPercent(): number;
    getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null;
    getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null;
    getChildPolicy(): TypedLoadBalancingConfig;
    static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig;
}
export declare class OutlierDetectionLoadBalancer implements LoadBalancer {
    private childBalancer;
    private entryMap;
    private latestConfig;
    private ejectionTimer;
    private timerStartTime;
    constructor(channelControlHelper: ChannelControlHelper, options: ChannelOptions);
    private isCountingEnabled;
    private getCurrentEjectionPercent;
    private runSuccessRateCheck;
    private runFailurePercentageCheck;
    private eject;
    private uneject;
    private switchAllBuckets;
    private startTimer;
    private runChecks;
    updateAddressList(endpointList: Endpoint[], lbConfig: TypedLoadBalancingConfig, attributes: {
        [key: string]: unknown;
    }): void;
    exitIdle(): void;
    resetBackoff(): void;
    destroy(): void;
    getTypeName(): string;
}
export declare function setup(): void;
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;
exports.setup = setup;
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const duration_1 = require("./duration");
const experimental_1 = require("./experimental");
const load_balancer_1 = require("./load-balancer");
const load_balancer_child_handler_1 = require("./load-balancer-child-handler");
const picker_1 = require("./picker");
const subchannel_address_1 = require("./subchannel-address");
const subchannel_interface_1 = require("./subchannel-interface");
const logging = require("./logging");
const TRACER_NAME = 'outlier_detection';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'outlier_detection';
const OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';
const defaultSuccessRateEjectionConfig = {
    stdev_factor: 1900,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 100,
};
const defaultFailurePercentageEjectionConfig = {
    threshold: 85,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 50,
};
function validateFieldType(obj, fieldName, expectedType, objectName) {
    if (fieldName in obj &&
        obj[fieldName] !== undefined &&
        typeof obj[fieldName] !== expectedType) {
        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
    }
}
function validatePositiveDuration(obj, fieldName, objectName) {
    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
    if (fieldName in obj && obj[fieldName] !== undefined) {
        if (!(0, duration_1.isDuration)(obj[fieldName])) {
            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
        }
        if (!(obj[fieldName].seconds >= 0 &&
            obj[fieldName].seconds <= 315576000000 &&
            obj[fieldName].nanos >= 0 &&
            obj[fieldName].nanos <= 999999999)) {
            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
        }
    }
}
function validatePercentage(obj, fieldName, objectName) {
    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
    validateFieldType(obj, fieldName, 'number', objectName);
    if (fieldName in obj &&
        obj[fieldName] !== undefined &&
        !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
    }
}
class OutlierDetectionLoadBalancingConfig {
    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
        this.childPolicy = childPolicy;
        if (childPolicy.getLoadBalancerName() === 'pick_first') {
            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');
        }
        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;
        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;
        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;
        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
        this.successRateEjection = successRateEjection
            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
        this.failurePercentageEjection = failurePercentageEjection
            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        var _a, _b;
        return {
            outlier_detection: {
                interval: (0, duration_1.msToDuration)(this.intervalMs),
                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
                max_ejection_percent: this.maxEjectionPercent,
                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== void 0 ? _a : undefined,
                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== void 0 ? _b : undefined,
                child_policy: [this.childPolicy.toJsonObject()],
            },
        };
    }
    getIntervalMs() {
        return this.intervalMs;
    }
    getBaseEjectionTimeMs() {
        return this.baseEjectionTimeMs;
    }
    getMaxEjectionTimeMs() {
        return this.maxEjectionTimeMs;
    }
    getMaxEjectionPercent() {
        return this.maxEjectionPercent;
    }
    getSuccessRateEjectionConfig() {
        return this.successRateEjection;
    }
    getFailurePercentageEjectionConfig() {
        return this.failurePercentageEjection;
    }
    getChildPolicy() {
        return this.childPolicy;
    }
    static createFromJson(obj) {
        var _a;
        validatePositiveDuration(obj, 'interval');
        validatePositiveDuration(obj, 'base_ejection_time');
        validatePositiveDuration(obj, 'max_ejection_time');
        validatePercentage(obj, 'max_ejection_percent');
        if ('success_rate_ejection' in obj &&
            obj.success_rate_ejection !== undefined) {
            if (typeof obj.success_rate_ejection !== 'object') {
                throw new Error('outlier detection config success_rate_ejection must be an object');
            }
            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');
            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');
            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');
            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');
        }
        if ('failure_percentage_ejection' in obj &&
            obj.failure_percentage_ejection !== undefined) {
            if (typeof obj.failure_percentage_ejection !== 'object') {
                throw new Error('outlier detection config failure_percentage_ejection must be an object');
            }
            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');
            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');
            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');
            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');
        }
        if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {
            throw new Error('outlier detection config child_policy must be an array');
        }
        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
        if (!childPolicy) {
            throw new Error('outlier detection config child_policy: no valid recognized policy found');
        }
        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
    }
}
exports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
    constructor(childSubchannel, mapEntry) {
        super(childSubchannel);
        this.mapEntry = mapEntry;
        this.refCount = 0;
    }
    ref() {
        this.child.ref();
        this.refCount += 1;
    }
    unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
            if (this.mapEntry) {
                const index = this.mapEntry.subchannelWrappers.indexOf(this);
                if (index >= 0) {
                    this.mapEntry.subchannelWrappers.splice(index, 1);
                }
            }
        }
    }
    eject() {
        this.setHealthy(false);
    }
    uneject() {
        this.setHealthy(true);
    }
    getMapEntry() {
        return this.mapEntry;
    }
    getWrappedSubchannel() {
        return this.child;
    }
}
function createEmptyBucket() {
    return {
        success: 0,
        failure: 0,
    };
}
class CallCounter {
    constructor() {
        this.activeBucket = createEmptyBucket();
        this.inactiveBucket = createEmptyBucket();
    }
    addSuccess() {
        this.activeBucket.success += 1;
    }
    addFailure() {
        this.activeBucket.failure += 1;
    }
    switchBuckets() {
        this.inactiveBucket = this.activeBucket;
        this.activeBucket = createEmptyBucket();
    }
    getLastSuccesses() {
        return this.inactiveBucket.success;
    }
    getLastFailures() {
        return this.inactiveBucket.failure;
    }
}
class OutlierDetectionPicker {
    constructor(wrappedPicker, countCalls) {
        this.wrappedPicker = wrappedPicker;
        this.countCalls = countCalls;
    }
    pick(pickArgs) {
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
            const subchannelWrapper = wrappedPick.subchannel;
            const mapEntry = subchannelWrapper.getMapEntry();
            if (mapEntry) {
                let onCallEnded = wrappedPick.onCallEnded;
                if (this.countCalls) {
                    onCallEnded = statusCode => {
                        var _a;
                        if (statusCode === constants_1.Status.OK) {
                            mapEntry.counter.addSuccess();
                        }
                        else {
                            mapEntry.counter.addFailure();
                        }
                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);
                    };
                }
                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });
            }
            else {
                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
            }
        }
        else {
            return wrappedPick;
        }
    }
}
class OutlierDetectionLoadBalancer {
    constructor(channelControlHelper, options) {
        this.entryMap = new subchannel_address_1.EndpointMap();
        this.latestConfig = null;
        this.timerStartTime = null;
        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
            createSubchannel: (subchannelAddress, subchannelArgs) => {
                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {
                    // If the address is ejected, propagate that to the new subchannel wrapper
                    subchannelWrapper.eject();
                }
                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
                return subchannelWrapper;
            },
            updateState: (connectivityState, picker) => {
                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
                }
                else {
                    channelControlHelper.updateState(connectivityState, picker);
                }
            },
        }), options);
        this.ejectionTimer = setInterval(() => { }, 0);
        clearInterval(this.ejectionTimer);
    }
    isCountingEnabled() {
        return (this.latestConfig !== null &&
            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
                this.latestConfig.getFailurePercentageEjectionConfig() !== null));
    }
    getCurrentEjectionPercent() {
        let ejectionCount = 0;
        for (const mapEntry of this.entryMap.values()) {
            if (mapEntry.currentEjectionTimestamp !== null) {
                ejectionCount += 1;
            }
        }
        return (ejectionCount * 100) / this.entryMap.size;
    }
    runSuccessRateCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
            return;
        }
        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
        if (!successRateConfig) {
            return;
        }
        trace('Running success rate check');
        // Step 1
        const targetRequestVolume = successRateConfig.request_volume;
        let addresesWithTargetVolume = 0;
        const successRates = [];
        for (const [endpoint, mapEntry] of this.entryMap.entries()) {
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            trace('Stats for ' +
                (0, subchannel_address_1.endpointToString)(endpoint) +
                ': successes=' +
                successes +
                ' failures=' +
                failures +
                ' targetRequestVolume=' +
                targetRequestVolume);
            if (successes + failures >= targetRequestVolume) {
                addresesWithTargetVolume += 1;
                successRates.push(successes / (successes + failures));
            }
        }
        trace('Found ' +
            addresesWithTargetVolume +
            ' success rate candidates; currentEjectionPercent=' +
            this.getCurrentEjectionPercent() +
            ' successRates=[' +
            successRates +
            ']');
        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
            return;
        }
        // Step 2
        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
        let successRateDeviationSum = 0;
        for (const rate of successRates) {
            const deviation = rate - successRateMean;
            successRateDeviationSum += deviation * deviation;
        }
        const successRateVariance = successRateDeviationSum / successRates.length;
        const successRateStdev = Math.sqrt(successRateVariance);
        const ejectionThreshold = successRateMean -
            successRateStdev * (successRateConfig.stdev_factor / 1000);
        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);
        // Step 3
        for (const [address, mapEntry] of this.entryMap.entries()) {
            // Step 3.i
            if (this.getCurrentEjectionPercent() >=
                this.latestConfig.getMaxEjectionPercent()) {
                break;
            }
            // Step 3.ii
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            if (successes + failures < targetRequestVolume) {
                continue;
            }
            // Step 3.iii
            const successRate = successes / (successes + failures);
            trace('Checking candidate ' + address + ' successRate=' + successRate);
            if (successRate < ejectionThreshold) {
                const randomNumber = Math.random() * 100;
                trace('Candidate ' +
                    address +
                    ' randomNumber=' +
                    randomNumber +
                    ' enforcement_percentage=' +
                    successRateConfig.enforcement_percentage);
                if (randomNumber < successRateConfig.enforcement_percentage) {
                    trace('Ejecting candidate ' + address);
                    this.eject(mapEntry, ejectionTimestamp);
                }
            }
        }
    }
    runFailurePercentageCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
            return;
        }
        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
        if (!failurePercentageConfig) {
            return;
        }
        trace('Running failure percentage check. threshold=' +
            failurePercentageConfig.threshold +
            ' request volume threshold=' +
            failurePercentageConfig.request_volume);
        // Step 1
        let addressesWithTargetVolume = 0;
        for (const mapEntry of this.entryMap.values()) {
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            if (successes + failures >= failurePercentageConfig.request_volume) {
                addressesWithTargetVolume += 1;
            }
        }
        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
            return;
        }
        // Step 2
        for (const [address, mapEntry] of this.entryMap.entries()) {
            // Step 2.i
            if (this.getCurrentEjectionPercent() >=
                this.latestConfig.getMaxEjectionPercent()) {
                break;
            }
            // Step 2.ii
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            trace('Candidate successes=' + successes + ' failures=' + failures);
            if (successes + failures < failurePercentageConfig.request_volume) {
                continue;
            }
            // Step 2.iii
            const failurePercentage = (failures * 100) / (failures + successes);
            if (failurePercentage > failurePercentageConfig.threshold) {
                const randomNumber = Math.random() * 100;
                trace('Candidate ' +
                    address +
                    ' randomNumber=' +
                    randomNumber +
                    ' enforcement_percentage=' +
                    failurePercentageConfig.enforcement_percentage);
                if (randomNumber < failurePercentageConfig.enforcement_percentage) {
                    trace('Ejecting candidate ' + address);
                    this.eject(mapEntry, ejectionTimestamp);
                }
            }
        }
    }
    eject(mapEntry, ejectionTimestamp) {
        mapEntry.currentEjectionTimestamp = new Date();
        mapEntry.ejectionTimeMultiplier += 1;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
            subchannelWrapper.eject();
        }
    }
    uneject(mapEntry) {
        mapEntry.currentEjectionTimestamp = null;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
            subchannelWrapper.uneject();
        }
    }
    switchAllBuckets() {
        for (const mapEntry of this.entryMap.values()) {
            mapEntry.counter.switchBuckets();
        }
    }
    startTimer(delayMs) {
        var _a, _b;
        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    runChecks() {
        const ejectionTimestamp = new Date();
        trace('Ejection timer running');
        this.switchAllBuckets();
        if (!this.latestConfig) {
            return;
        }
        this.timerStartTime = ejectionTimestamp;
        this.startTimer(this.latestConfig.getIntervalMs());
        this.runSuccessRateCheck(ejectionTimestamp);
        this.runFailurePercentageCheck(ejectionTimestamp);
        for (const [address, mapEntry] of this.entryMap.entries()) {
            if (mapEntry.currentEjectionTimestamp === null) {
                if (mapEntry.ejectionTimeMultiplier > 0) {
                    mapEntry.ejectionTimeMultiplier -= 1;
                }
            }
            else {
                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
                returnTime.setMilliseconds(returnTime.getMilliseconds() +
                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
                if (returnTime < new Date()) {
                    trace('Unejecting ' + address);
                    this.uneject(mapEntry);
                }
            }
        }
    }
    updateAddressList(endpointList, lbConfig, attributes) {
        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
            return;
        }
        for (const endpoint of endpointList) {
            if (!this.entryMap.has(endpoint)) {
                trace('Adding map entry for ' + (0, subchannel_address_1.endpointToString)(endpoint));
                this.entryMap.set(endpoint, {
                    counter: new CallCounter(),
                    currentEjectionTimestamp: null,
                    ejectionTimeMultiplier: 0,
                    subchannelWrappers: [],
                });
            }
        }
        this.entryMap.deleteMissing(endpointList);
        const childPolicy = lbConfig.getChildPolicy();
        this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);
        if (lbConfig.getSuccessRateEjectionConfig() ||
            lbConfig.getFailurePercentageEjectionConfig()) {
            if (this.timerStartTime) {
                trace('Previous timer existed. Replacing timer');
                clearTimeout(this.ejectionTimer);
                const remainingDelay = lbConfig.getIntervalMs() -
                    (new Date().getTime() - this.timerStartTime.getTime());
                this.startTimer(remainingDelay);
            }
            else {
                trace('Starting new timer');
                this.timerStartTime = new Date();
                this.startTimer(lbConfig.getIntervalMs());
                this.switchAllBuckets();
            }
        }
        else {
            trace('Counting disabled. Cancelling timer.');
            this.timerStartTime = null;
            clearTimeout(this.ejectionTimer);
            for (const mapEntry of this.entryMap.values()) {
                this.uneject(mapEntry);
                mapEntry.ejectionTimeMultiplier = 0;
            }
        }
        this.latestConfig = lbConfig;
    }
    exitIdle() {
        this.childBalancer.exitIdle();
    }
    resetBackoff() {
        this.childBalancer.resetBackoff();
    }
    destroy() {
        clearTimeout(this.ejectionTimer);
        this.childBalancer.destroy();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
function setup() {
    if (OUTLIER_DETECTION_ENABLED) {
        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
    }
}
//# sourceMappingURL=load-balancer-outlier-detection.js.map{"version":3,"file":"load-balancer-outlier-detection.js","sourceRoot":"","sources":["../../src/load-balancer-outlier-detection.ts"],"names":[],"mappings":"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"}import { LoadBalancer, ChannelControlHelper, TypedLoadBalancingConfig } from './load-balancer';
import { ConnectivityState } from './connectivity-state';
import { Picker } from './picker';
import { Endpoint } from './subchannel-address';
import { ChannelOptions } from './channel-options';
export declare class PickFirstLoadBalancingConfig implements TypedLoadBalancingConfig {
    private readonly shuffleAddressList;
    constructor(shuffleAddressList: boolean);
    getLoadBalancerName(): string;
    toJsonObject(): object;
    getShuffleAddressList(): boolean;
    static createFromJson(obj: any): PickFirstLoadBalancingConfig;
}
/**
 * Return a new array with the elements of the input array in a random order
 * @param list The input array
 * @returns A shuffled array of the elements of list
 */
export declare function shuffled<T>(list: T[]): T[];
export declare class PickFirstLoadBalancer implements LoadBalancer {
    private readonly channelControlHelper;
    /**
     * The list of subchannels this load balancer is currently attempting to
     * connect to.
     */
    private children;
    /**
     * The current connectivity state of the load balancer.
     */
    private currentState;
    /**
     * The index within the `subchannels` array of the subchannel with the most
     * recently started connection attempt.
     */
    private currentSubchannelIndex;
    /**
     * The currently picked subchannel used for making calls. Populated if
     * and only if the load balancer's current state is READY. In that case,
     * the subchannel's current state is also READY.
     */
    private currentPick;
    /**
     * Listener callback attached to each subchannel in the `subchannels` list
     * while establishing a connection.
     */
    private subchannelStateListener;
    private pickedSubchannelHealthListener;
    /**
     * Timer reference for the timer tracking when to start
     */
    private connectionDelayTimeout;
    private triedAllSubchannels;
    /**
     * The LB policy enters sticky TRANSIENT_FAILURE mode when all
     * subchannels have failed to connect at least once, and it stays in that
     * mode until a connection attempt is successful. While in sticky TF mode,
     * the LB policy continuously attempts to connect to all of its subchannels.
     */
    private stickyTransientFailureMode;
    private reportHealthStatus;
    /**
     * Indicates whether we called channelControlHelper.requestReresolution since
     * the last call to updateAddressList
     */
    private requestedResolutionSinceLastUpdate;
    /**
     * The most recent error reported by any subchannel as it transitioned to
     * TRANSIENT_FAILURE.
     */
    private lastError;
    private latestAddressList;
    /**
     * Load balancer that attempts to connect to each backend in the address list
     * in order, and picks the first one that connects, using it for every
     * request.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     */
    constructor(channelControlHelper: ChannelControlHelper, options: ChannelOptions);
    private allChildrenHaveReportedTF;
    private calculateAndReportNewState;
    private requestReresolution;
    private maybeEnterStickyTransientFailureMode;
    private removeCurrentPick;
    private onSubchannelStateUpdate;
    private startNextSubchannelConnecting;
    /**
     * Have a single subchannel in the `subchannels` list start connecting.
     * @param subchannelIndex The index into the `subchannels` list.
     */
    private startConnecting;
    private pickSubchannel;
    private updateState;
    private resetSubchannelList;
    private connectToAddressList;
    updateAddressList(endpointList: Endpoint[], lbConfig: TypedLoadBalancingConfig): void;
    exitIdle(): void;
    resetBackoff(): void;
    destroy(): void;
    getTypeName(): string;
}
/**
 * This class handles the leaf load balancing operations for a single endpoint.
 * It is a thin wrapper around a PickFirstLoadBalancer with a different API
 * that more closely reflects how it will be used as a leaf balancer.
 */
export declare class LeafLoadBalancer {
    private endpoint;
    private pickFirstBalancer;
    private latestState;
    private latestPicker;
    constructor(endpoint: Endpoint, channelControlHelper: ChannelControlHelper, options: ChannelOptions);
    startConnecting(): void;
    /**
     * Update the endpoint associated with this LeafLoadBalancer to a new
     * endpoint. Does not trigger connection establishment if a connection
     * attempt is not already in progress.
     * @param newEndpoint
     */
    updateEndpoint(newEndpoint: Endpoint): void;
    getConnectivityState(): ConnectivityState;
    getPicker(): Picker;
    getEndpoint(): Endpoint;
    exitIdle(): void;
    destroy(): void;
}
export declare function setup(): void;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;
exports.shuffled = shuffled;
exports.setup = setup;
const load_balancer_1 = require("./load-balancer");
const connectivity_state_1 = require("./connectivity-state");
const picker_1 = require("./picker");
const subchannel_address_1 = require("./subchannel-address");
const logging = require("./logging");
const constants_1 = require("./constants");
const subchannel_address_2 = require("./subchannel-address");
const net_1 = require("net");
const TRACER_NAME = 'pick_first';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'pick_first';
/**
 * Delay after starting a connection on a subchannel before starting a
 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
 */
const CONNECTION_DELAY_INTERVAL_MS = 250;
class PickFirstLoadBalancingConfig {
    constructor(shuffleAddressList) {
        this.shuffleAddressList = shuffleAddressList;
    }
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    toJsonObject() {
        return {
            [TYPE_NAME]: {
                shuffleAddressList: this.shuffleAddressList,
            },
        };
    }
    getShuffleAddressList() {
        return this.shuffleAddressList;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static createFromJson(obj) {
        if ('shuffleAddressList' in obj &&
            !(typeof obj.shuffleAddressList === 'boolean')) {
            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');
        }
        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
    }
}
exports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
/**
 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
 * picked subchannel.
 */
class PickFirstPicker {
    constructor(subchannel) {
        this.subchannel = subchannel;
    }
    pick(pickArgs) {
        return {
            pickResultType: picker_1.PickResultType.COMPLETE,
            subchannel: this.subchannel,
            status: null,
            onCallStarted: null,
            onCallEnded: null,
        };
    }
}
/**
 * Return a new array with the elements of the input array in a random order
 * @param list The input array
 * @returns A shuffled array of the elements of list
 */
function shuffled(list) {
    const result = list.slice();
    for (let i = result.length - 1; i > 1; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const temp = result[i];
        result[i] = result[j];
        result[j] = temp;
    }
    return result;
}
/**
 * Interleave addresses in addressList by family in accordance with RFC-8304 section 4
 * @param addressList
 * @returns
 */
function interleaveAddressFamilies(addressList) {
    const result = [];
    const ipv6Addresses = [];
    const ipv4Addresses = [];
    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
    for (const address of addressList) {
        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
            ipv6Addresses.push(address);
        }
        else {
            ipv4Addresses.push(address);
        }
    }
    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
    for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {
        if (i < firstList.length) {
            result.push(firstList[i]);
        }
        if (i < secondList.length) {
            result.push(secondList[i]);
        }
    }
    return result;
}
const REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';
class PickFirstLoadBalancer {
    /**
     * Load balancer that attempts to connect to each backend in the address list
     * in order, and picks the first one that connects, using it for every
     * request.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     */
    constructor(channelControlHelper, options) {
        this.channelControlHelper = channelControlHelper;
        /**
         * The list of subchannels this load balancer is currently attempting to
         * connect to.
         */
        this.children = [];
        /**
         * The current connectivity state of the load balancer.
         */
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        /**
         * The index within the `subchannels` array of the subchannel with the most
         * recently started connection attempt.
         */
        this.currentSubchannelIndex = 0;
        /**
         * The currently picked subchannel used for making calls. Populated if
         * and only if the load balancer's current state is READY. In that case,
         * the subchannel's current state is also READY.
         */
        this.currentPick = null;
        /**
         * Listener callback attached to each subchannel in the `subchannels` list
         * while establishing a connection.
         */
        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
        };
        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
        this.triedAllSubchannels = false;
        /**
         * The LB policy enters sticky TRANSIENT_FAILURE mode when all
         * subchannels have failed to connect at least once, and it stays in that
         * mode until a connection attempt is successful. While in sticky TF mode,
         * the LB policy continuously attempts to connect to all of its subchannels.
         */
        this.stickyTransientFailureMode = false;
        /**
         * Indicates whether we called channelControlHelper.requestReresolution since
         * the last call to updateAddressList
         */
        this.requestedResolutionSinceLastUpdate = false;
        /**
         * The most recent error reported by any subchannel as it transitioned to
         * TRANSIENT_FAILURE.
         */
        this.lastError = null;
        this.latestAddressList = null;
        this.connectionDelayTimeout = setTimeout(() => { }, 0);
        clearTimeout(this.connectionDelayTimeout);
        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
    }
    allChildrenHaveReportedTF() {
        return this.children.every(child => child.hasReportedTransientFailure);
    }
    calculateAndReportNewState() {
        if (this.currentPick) {
            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
                    details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`,
                }));
            }
            else {
                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));
            }
        }
        else if (this.children.length === 0) {
            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
        else {
            if (this.stickyTransientFailureMode) {
                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
                    details: `No connection established. Last error: ${this.lastError}`,
                }));
            }
            else {
                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
        }
    }
    requestReresolution() {
        this.requestedResolutionSinceLastUpdate = true;
        this.channelControlHelper.requestReresolution();
    }
    maybeEnterStickyTransientFailureMode() {
        if (!this.allChildrenHaveReportedTF()) {
            return;
        }
        if (!this.requestedResolutionSinceLastUpdate) {
            /* Each time we get an update we reset each subchannel's
             * hasReportedTransientFailure flag, so the next time we get to this
             * point after that, each subchannel has reported TRANSIENT_FAILURE
             * at least once since then. That is the trigger for requesting
             * reresolution, whether or not the LB policy is already in sticky TF
             * mode. */
            this.requestReresolution();
        }
        if (this.stickyTransientFailureMode) {
            return;
        }
        this.stickyTransientFailureMode = true;
        for (const { subchannel } of this.children) {
            subchannel.startConnecting();
        }
        this.calculateAndReportNewState();
    }
    removeCurrentPick() {
        if (this.currentPick !== null) {
            /* Unref can cause a state change, which can cause a change in the value
             * of this.currentPick, so we hold a local reference to make sure that
             * does not impact this function. */
            const currentPick = this.currentPick;
            this.currentPick = null;
            currentPick.unref();
            currentPick.removeConnectivityStateListener(this.subchannelStateListener);
            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());
            if (this.reportHealthStatus) {
                currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
            }
        }
    }
    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
        var _a;
        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {
            if (newState !== connectivity_state_1.ConnectivityState.READY) {
                this.removeCurrentPick();
                this.calculateAndReportNewState();
            }
            return;
        }
        for (const [index, child] of this.children.entries()) {
            if (subchannel.realSubchannelEquals(child.subchannel)) {
                if (newState === connectivity_state_1.ConnectivityState.READY) {
                    this.pickSubchannel(child.subchannel);
                }
                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                    child.hasReportedTransientFailure = true;
                    if (errorMessage) {
                        this.lastError = errorMessage;
                    }
                    this.maybeEnterStickyTransientFailureMode();
                    if (index === this.currentSubchannelIndex) {
                        this.startNextSubchannelConnecting(index + 1);
                    }
                }
                child.subchannel.startConnecting();
                return;
            }
        }
    }
    startNextSubchannelConnecting(startIndex) {
        clearTimeout(this.connectionDelayTimeout);
        if (this.triedAllSubchannels) {
            return;
        }
        for (const [index, child] of this.children.entries()) {
            if (index >= startIndex) {
                const subchannelState = child.subchannel.getConnectivityState();
                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
                    this.startConnecting(index);
                    return;
                }
            }
        }
        this.triedAllSubchannels = true;
        this.maybeEnterStickyTransientFailureMode();
    }
    /**
     * Have a single subchannel in the `subchannels` list start connecting.
     * @param subchannelIndex The index into the `subchannels` list.
     */
    startConnecting(subchannelIndex) {
        var _a, _b;
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===
            connectivity_state_1.ConnectivityState.IDLE) {
            trace('Start connecting to subchannel with address ' +
                this.children[subchannelIndex].subchannel.getAddress());
            process.nextTick(() => {
                var _a;
                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();
            });
        }
        this.connectionDelayTimeout = setTimeout(() => {
            this.startNextSubchannelConnecting(subchannelIndex + 1);
        }, CONNECTION_DELAY_INTERVAL_MS);
        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    pickSubchannel(subchannel) {
        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {
            return;
        }
        trace('Pick subchannel with address ' + subchannel.getAddress());
        this.stickyTransientFailureMode = false;
        this.removeCurrentPick();
        this.currentPick = subchannel;
        subchannel.ref();
        if (this.reportHealthStatus) {
            subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
        }
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
        this.calculateAndReportNewState();
    }
    updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
    }
    resetSubchannelList() {
        for (const child of this.children) {
            if (!(this.currentPick &&
                child.subchannel.realSubchannelEquals(this.currentPick))) {
                /* The connectivity state listener is the same whether the subchannel
                 * is in the list of children or it is the currentPick, so if it is in
                 * both, removing it here would cause problems. In particular, that
                 * always happens immediately after the subchannel is picked. */
                child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
            }
            /* Refs are counted independently for the children list and the
             * currentPick, so we call unref whether or not the child is the
             * currentPick. Channelz child references are also refcounted, so
             * removeChannelzChild can be handled the same way. */
            child.subchannel.unref();
            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
        }
        this.currentSubchannelIndex = 0;
        this.children = [];
        this.triedAllSubchannels = false;
        this.requestedResolutionSinceLastUpdate = false;
    }
    connectToAddressList(addressList) {
        const newChildrenList = addressList.map(address => ({
            subchannel: this.channelControlHelper.createSubchannel(address, {}),
            hasReportedTransientFailure: false,
        }));
        trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');
        for (const { subchannel } of newChildrenList) {
            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
                this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
                subchannel.addConnectivityStateListener(this.subchannelStateListener);
                this.pickSubchannel(subchannel);
                return;
            }
        }
        /* Ref each subchannel before resetting the list, to ensure that
         * subchannels shared between the list don't drop to 0 refs during the
         * transition. */
        for (const { subchannel } of newChildrenList) {
            subchannel.ref();
            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        }
        this.resetSubchannelList();
        this.children = newChildrenList;
        for (const { subchannel } of this.children) {
            subchannel.addConnectivityStateListener(this.subchannelStateListener);
        }
        for (const child of this.children) {
            if (child.subchannel.getConnectivityState() ===
                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                child.hasReportedTransientFailure = true;
            }
        }
        this.startNextSubchannelConnecting(0);
        this.calculateAndReportNewState();
    }
    updateAddressList(endpointList, lbConfig) {
        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
            return;
        }
        /* Previously, an update would be discarded if it was identical to the
         * previous update, to minimize churn. Now the DNS resolver is
         * rate-limited, so that is less of a concern. */
        if (lbConfig.getShuffleAddressList()) {
            endpointList = shuffled(endpointList);
        }
        const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
        trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');
        if (rawAddressList.length === 0) {
            throw new Error('No addresses in endpoint list passed to pick_first');
        }
        const addressList = interleaveAddressFamilies(rawAddressList);
        this.latestAddressList = addressList;
        this.connectToAddressList(addressList);
    }
    exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE &&
            this.latestAddressList) {
            this.connectToAddressList(this.latestAddressList);
        }
    }
    resetBackoff() {
        /* The pick first load balancer does not have a connection backoff, so this
         * does nothing */
    }
    destroy() {
        this.resetSubchannelList();
        this.removeCurrentPick();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.PickFirstLoadBalancer = PickFirstLoadBalancer;
const LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);
/**
 * This class handles the leaf load balancing operations for a single endpoint.
 * It is a thin wrapper around a PickFirstLoadBalancer with a different API
 * that more closely reflects how it will be used as a leaf balancer.
 */
class LeafLoadBalancer {
    constructor(endpoint, channelControlHelper, options) {
        this.endpoint = endpoint;
        this.latestState = connectivity_state_1.ConnectivityState.IDLE;
        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
            updateState: (connectivityState, picker) => {
                this.latestState = connectivityState;
                this.latestPicker = picker;
                channelControlHelper.updateState(connectivityState, picker);
            },
        });
        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, Object.assign(Object.assign({}, options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));
        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
    }
    startConnecting() {
        this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);
    }
    /**
     * Update the endpoint associated with this LeafLoadBalancer to a new
     * endpoint. Does not trigger connection establishment if a connection
     * attempt is not already in progress.
     * @param newEndpoint
     */
    updateEndpoint(newEndpoint) {
        this.endpoint = newEndpoint;
        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
            this.startConnecting();
        }
    }
    getConnectivityState() {
        return this.latestState;
    }
    getPicker() {
        return this.latestPicker;
    }
    getEndpoint() {
        return this.endpoint;
    }
    exitIdle() {
        this.pickFirstBalancer.exitIdle();
    }
    destroy() {
        this.pickFirstBalancer.destroy();
    }
}
exports.LeafLoadBalancer = LeafLoadBalancer;
function setup() {
    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
}
//# sourceMappingURL=load-balancer-pick-first.js.map{"version":3,"file":"load-balancer-pick-first.js","sourceRoot":"","sources":["../../src/load-balancer-pick-first.ts"],"names":[],"mappings":"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"}import { LoadBalancer, ChannelControlHelper, TypedLoadBalancingConfig } from './load-balancer';
import { Endpoint } from './subchannel-address';
import { ChannelOptions } from './channel-options';
export declare class RoundRobinLoadBalancer implements LoadBalancer {
    private readonly channelControlHelper;
    private readonly options;
    private children;
    private currentState;
    private currentReadyPicker;
    private updatesPaused;
    private childChannelControlHelper;
    private lastError;
    constructor(channelControlHelper: ChannelControlHelper, options: ChannelOptions);
    private countChildrenWithState;
    private calculateAndUpdateState;
    private updateState;
    private resetSubchannelList;
    updateAddressList(endpointList: Endpoint[], lbConfig: TypedLoadBalancingConfig): void;
    exitIdle(): void;
    resetBackoff(): void;
    destroy(): void;
    getTypeName(): string;
}
export declare function setup(): void;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoundRobinLoadBalancer = void 0;
exports.setup = setup;
const load_balancer_1 = require("./load-balancer");
const connectivity_state_1 = require("./connectivity-state");
const picker_1 = require("./picker");
const logging = require("./logging");
const constants_1 = require("./constants");
const subchannel_address_1 = require("./subchannel-address");
const load_balancer_pick_first_1 = require("./load-balancer-pick-first");
const TRACER_NAME = 'round_robin';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'round_robin';
class RoundRobinLoadBalancingConfig {
    getLoadBalancerName() {
        return TYPE_NAME;
    }
    constructor() { }
    toJsonObject() {
        return {
            [TYPE_NAME]: {},
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig();
    }
}
class RoundRobinPicker {
    constructor(children, nextIndex = 0) {
        this.children = children;
        this.nextIndex = nextIndex;
    }
    pick(pickArgs) {
        const childPicker = this.children[this.nextIndex].picker;
        this.nextIndex = (this.nextIndex + 1) % this.children.length;
        return childPicker.pick(pickArgs);
    }
    /**
     * Check what the next subchannel returned would be. Used by the load
     * balancer implementation to preserve this part of the picker state if
     * possible when a subchannel connects or disconnects.
     */
    peekNextEndpoint() {
        return this.children[this.nextIndex].endpoint;
    }
}
class RoundRobinLoadBalancer {
    constructor(channelControlHelper, options) {
        this.channelControlHelper = channelControlHelper;
        this.options = options;
        this.children = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.updatesPaused = false;
        this.lastError = null;
        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
            updateState: (connectivityState, picker) => {
                this.calculateAndUpdateState();
            },
        });
    }
    countChildrenWithState(state) {
        return this.children.filter(child => child.getConnectivityState() === state)
            .length;
    }
    calculateAndUpdateState() {
        if (this.updatesPaused) {
            return;
        }
        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
            const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
            let index = 0;
            if (this.currentReadyPicker !== null) {
                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
                index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
                if (index < 0) {
                    index = 0;
                }
            }
            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({
                endpoint: child.getEndpoint(),
                picker: child.getPicker(),
            })), index));
        }
        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
                details: `No connection established. Last error: ${this.lastError}`,
            }));
        }
        else {
            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
        /* round_robin should keep all children connected, this is how we do that.
         * We can't do this more efficiently in the individual child's updateState
         * callback because that doesn't have a reference to which child the state
         * change is associated with. */
        for (const child of this.children) {
            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
                child.exitIdle();
            }
        }
    }
    updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        if (newState === connectivity_state_1.ConnectivityState.READY) {
            this.currentReadyPicker = picker;
        }
        else {
            this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
    }
    resetSubchannelList() {
        for (const child of this.children) {
            child.destroy();
        }
    }
    updateAddressList(endpointList, lbConfig) {
        this.resetSubchannelList();
        trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));
        this.updatesPaused = true;
        this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.options));
        for (const child of this.children) {
            child.startConnecting();
        }
        this.updatesPaused = false;
        this.calculateAndUpdateState();
    }
    exitIdle() {
        /* The round_robin LB policy is only in the IDLE state if it has no
         * addresses to try to connect to and it has no picked subchannel.
         * In that case, there is no meaningful action that can be taken here. */
    }
    resetBackoff() {
        // This LB policy has no backoff to reset
    }
    destroy() {
        this.resetSubchannelList();
    }
    getTypeName() {
        return TYPE_NAME;
    }
}
exports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
function setup() {
    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
}
//# sourceMappingURL=load-balancer-round-robin.js.map{"version":3,"file":"load-balancer-round-robin.js","sourceRoot":"","sources":["../../src/load-balancer-round-robin.ts"],"names":[],"mappings":"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"}import { ChannelOptions } from './channel-options';
import { Endpoint, SubchannelAddress } from './subchannel-address';
import { ConnectivityState } from './connectivity-state';
import { Picker } from './picker';
import type { ChannelRef, SubchannelRef } from './channelz';
import { SubchannelInterface } from './subchannel-interface';
import { LoadBalancingConfig } from './service-config';
/**
 * A collection of functions associated with a channel that a load balancer
 * can call as necessary.
 */
export interface ChannelControlHelper {
    /**
     * Returns a subchannel connected to the specified address.
     * @param subchannelAddress The address to connect to
     * @param subchannelArgs Extra channel arguments specified by the load balancer
     */
    createSubchannel(subchannelAddress: SubchannelAddress, subchannelArgs: ChannelOptions): SubchannelInterface;
    /**
     * Passes a new subchannel picker up to the channel. This is called if either
     * the connectivity state changes or if a different picker is needed for any
     * other reason.
     * @param connectivityState New connectivity state
     * @param picker New picker
     */
    updateState(connectivityState: ConnectivityState, picker: Picker): void;
    /**
     * Request new data from the resolver.
     */
    requestReresolution(): void;
    addChannelzChild(child: ChannelRef | SubchannelRef): void;
    removeChannelzChild(child: ChannelRef | SubchannelRef): void;
}
/**
 * Create a child ChannelControlHelper that overrides some methods of the
 * parent while letting others pass through to the parent unmodified. This
 * allows other code to create these children without needing to know about
 * all of the methods to be passed through.
 * @param parent
 * @param overrides
 */
export declare function createChildChannelControlHelper(parent: ChannelControlHelper, overrides: Partial<ChannelControlHelper>): ChannelControlHelper;
/**
 * Tracks one or more connected subchannels and determines which subchannel
 * each request should use.
 */
export interface LoadBalancer {
    /**
     * Gives the load balancer a new list of addresses to start connecting to.
     * The load balancer will start establishing connections with the new list,
     * but will continue using any existing connections until the new connections
     * are established
     * @param endpointList The new list of addresses to connect to
     * @param lbConfig The load balancing config object from the service config,
     *     if one was provided
     */
    updateAddressList(endpointList: Endpoint[], lbConfig: TypedLoadBalancingConfig, attributes: {
        [key: string]: unknown;
    }): void;
    /**
     * If the load balancer is currently in the IDLE state, start connecting.
     */
    exitIdle(): void;
    /**
     * If the load balancer is currently in the CONNECTING or TRANSIENT_FAILURE
     * state, reset the current connection backoff timeout to its base value and
     * transition to CONNECTING if in TRANSIENT_FAILURE.
     */
    resetBackoff(): void;
    /**
     * The load balancer unrefs all of its subchannels and stops calling methods
     * of its channel control helper.
     */
    destroy(): void;
    /**
     * Get the type name for this load balancer type. Must be constant across an
     * entire load balancer implementation class and must match the name that the
     * balancer implementation class was registered with.
     */
    getTypeName(): string;
}
export interface LoadBalancerConstructor {
    new (channelControlHelper: ChannelControlHelper, options: ChannelOptions): LoadBalancer;
}
export interface TypedLoadBalancingConfig {
    getLoadBalancerName(): string;
    toJsonObject(): object;
}
export interface TypedLoadBalancingConfigConstructor {
    new (...args: any): TypedLoadBalancingConfig;
    createFromJson(obj: any): TypedLoadBalancingConfig;
}
export declare function registerLoadBalancerType(typeName: string, loadBalancerType: LoadBalancerConstructor, loadBalancingConfigType: TypedLoadBalancingConfigConstructor): void;
export declare function registerDefaultLoadBalancerType(typeName: string): void;
export declare function createLoadBalancer(config: TypedLoadBalancingConfig, channelControlHelper: ChannelControlHelper, options: ChannelOptions): LoadBalancer | null;
export declare function isLoadBalancerNameRegistered(typeName: string): boolean;
export declare function parseLoadBalancingConfig(rawConfig: LoadBalancingConfig): TypedLoadBalancingConfig;
export declare function getDefaultConfig(): TypedLoadBalancingConfig;
export declare function selectLbConfigFromList(configs: LoadBalancingConfig[], fallbackTodefault?: boolean): TypedLoadBalancingConfig | null;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createChildChannelControlHelper = createChildChannelControlHelper;
exports.registerLoadBalancerType = registerLoadBalancerType;
exports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
exports.createLoadBalancer = createLoadBalancer;
exports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
exports.parseLoadBalancingConfig = parseLoadBalancingConfig;
exports.getDefaultConfig = getDefaultConfig;
exports.selectLbConfigFromList = selectLbConfigFromList;
const logging_1 = require("./logging");
const constants_1 = require("./constants");
/**
 * Create a child ChannelControlHelper that overrides some methods of the
 * parent while letting others pass through to the parent unmodified. This
 * allows other code to create these children without needing to know about
 * all of the methods to be passed through.
 * @param parent
 * @param overrides
 */
function createChildChannelControlHelper(parent, overrides) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return {
        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),
        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),
        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),
        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),
        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),
    };
}
const registeredLoadBalancerTypes = {};
let defaultLoadBalancerType = null;
function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
    registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType,
    };
}
function registerDefaultLoadBalancerType(typeName) {
    defaultLoadBalancerType = typeName;
}
function createLoadBalancer(config, channelControlHelper, options) {
    const typeName = config.getLoadBalancerName();
    if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper, options);
    }
    else {
        return null;
    }
}
function isLoadBalancerNameRegistered(typeName) {
    return typeName in registeredLoadBalancerTypes;
}
function parseLoadBalancingConfig(rawConfig) {
    const keys = Object.keys(rawConfig);
    if (keys.length !== 1) {
        throw new Error('Provided load balancing config has multiple conflicting entries');
    }
    const typeName = keys[0];
    if (typeName in registeredLoadBalancerTypes) {
        try {
            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
        }
        catch (e) {
            throw new Error(`${typeName}: ${e.message}`);
        }
    }
    else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
    }
}
function getDefaultConfig() {
    if (!defaultLoadBalancerType) {
        throw new Error('No default load balancer type registered');
    }
    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
}
function selectLbConfigFromList(configs, fallbackTodefault = false) {
    for (const config of configs) {
        try {
            return parseLoadBalancingConfig(config);
        }
        catch (e) {
            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, 'Config parsing failed with error', e.message);
            continue;
        }
    }
    if (fallbackTodefault) {
        if (defaultLoadBalancerType) {
            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
        }
        else {
            return null;
        }
    }
    else {
        return null;
    }
}
//# sourceMappingURL=load-balancer.js.map{"version":3,"file":"load-balancer.js","sourceRoot":"","sources":["../../src/load-balancer.ts"],"names":[],"mappings":"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"}import { CallCredentials } from './call-credentials';
import { Call, DeadlineInfoProvider, InterceptingListener, MessageContext, StatusObject } from './call-interface';
import { Status } from './constants';
import { Deadline } from './deadline';
import { InternalChannel } from './internal-channel';
import { Metadata } from './metadata';
import { CallConfig } from './resolver';
export type RpcProgress = 'NOT_STARTED' | 'DROP' | 'REFUSED' | 'PROCESSED';
export interface StatusObjectWithProgress extends StatusObject {
    progress: RpcProgress;
}
export interface LoadBalancingCallInterceptingListener extends InterceptingListener {
    onReceiveStatus(status: StatusObjectWithProgress): void;
}
export declare class LoadBalancingCall implements Call, DeadlineInfoProvider {
    private readonly channel;
    private readonly callConfig;
    private readonly methodName;
    private readonly host;
    private readonly credentials;
    private readonly deadline;
    private readonly callNumber;
    private child;
    private readPending;
    private pendingMessage;
    private pendingHalfClose;
    private ended;
    private serviceUrl;
    private metadata;
    private listener;
    private onCallEnded;
    private startTime;
    private childStartTime;
    constructor(channel: InternalChannel, callConfig: CallConfig, methodName: string, host: string, credentials: CallCredentials, deadline: Deadline, callNumber: number);
    getDeadlineInfo(): string[];
    private trace;
    private outputStatus;
    doPick(): void;
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    start(metadata: Metadata, listener: LoadBalancingCallInterceptingListener): void;
    sendMessageWithContext(context: MessageContext, message: Buffer): void;
    startRead(): void;
    halfClose(): void;
    setCredentials(credentials: CallCredentials): void;
    getCallNumber(): number;
}
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadBalancingCall = void 0;
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const deadline_1 = require("./deadline");
const metadata_1 = require("./metadata");
const picker_1 = require("./picker");
const uri_parser_1 = require("./uri-parser");
const logging = require("./logging");
const control_plane_status_1 = require("./control-plane-status");
const http2 = require("http2");
const TRACER_NAME = 'load_balancing_call';
class LoadBalancingCall {
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
        var _a, _b;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.metadata = null;
        this.listener = null;
        this.onCallEnded = null;
        this.childStartTime = null;
        const splitPath = this.methodName.split('/');
        let serviceName = '';
        /* The standard path format is "/{serviceName}/{methodName}", so if we split
         * by '/', the first item should be empty and the second should be the
         * service name */
        if (splitPath.length >= 2) {
            serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';
        /* Currently, call credentials are only allowed on HTTPS connections, so we
         * can assume that the scheme is "https" */
        this.serviceUrl = `https://${hostname}/${serviceName}`;
        this.startTime = new Date();
    }
    getDeadlineInfo() {
        var _a, _b;
        const deadlineInfo = [];
        if (this.childStartTime) {
            if (this.childStartTime > this.startTime) {
                if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {
                    deadlineInfo.push('wait_for_ready');
                }
                deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);
            }
            deadlineInfo.push(...this.child.getDeadlineInfo());
            return deadlineInfo;
        }
        else {
            if ((_b = this.metadata) === null || _b === void 0 ? void 0 : _b.getOptions().waitForReady) {
                deadlineInfo.push('wait_for_ready');
            }
            deadlineInfo.push('Waiting for LB pick');
        }
        return deadlineInfo;
    }
    trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
    }
    outputStatus(status, progress) {
        var _a, _b;
        if (!this.ended) {
            this.ended = true;
            this.trace('ended with status: code=' +
                status.code +
                ' details="' +
                status.details +
                '" start time=' +
                this.startTime.toISOString());
            const finalStatus = Object.assign(Object.assign({}, status), { progress });
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);
            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);
        }
    }
    doPick() {
        var _a, _b;
        if (this.ended) {
            return;
        }
        if (!this.metadata) {
            throw new Error('doPick called before start');
        }
        this.trace('Pick called');
        const finalMetadata = this.metadata.clone();
        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
        const subchannelString = pickResult.subchannel
            ? '(' +
                pickResult.subchannel.getChannelzRef().id +
                ') ' +
                pickResult.subchannel.getAddress()
            : '' + pickResult.subchannel;
        this.trace('Pick result: ' +
            picker_1.PickResultType[pickResult.pickResultType] +
            ' subchannel: ' +
            subchannelString +
            ' status: ' +
            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +
            ' ' +
            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));
        switch (pickResult.pickResultType) {
            case picker_1.PickResultType.COMPLETE:
                this.credentials
                    .generateMetadata({ service_url: this.serviceUrl })
                    .then(credsMetadata => {
                    var _a, _b, _c;
                    /* If this call was cancelled (e.g. by the deadline) before
                     * metadata generation finished, we shouldn't do anything with
                     * it. */
                    if (this.ended) {
                        this.trace('Credentials metadata generation finished after call ended');
                        return;
                    }
                    finalMetadata.merge(credsMetadata);
                    if (finalMetadata.get('authorization').length > 1) {
                        this.outputStatus({
                            code: constants_1.Status.INTERNAL,
                            details: '"authorization" metadata cannot have multiple values',
                            metadata: new metadata_1.Metadata(),
                        }, 'PROCESSED');
                    }
                    if (pickResult.subchannel.getConnectivityState() !==
                        connectivity_state_1.ConnectivityState.READY) {
                        this.trace('Picked subchannel ' +
                            subchannelString +
                            ' has state ' +
                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +
                            ' after getting credentials metadata. Retrying pick');
                        this.doPick();
                        return;
                    }
                    if (this.deadline !== Infinity) {
                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
                    }
                    try {
                        this.child = pickResult
                            .subchannel.getRealSubchannel()
                            .createCall(finalMetadata, this.host, this.methodName, {
                            onReceiveMetadata: metadata => {
                                this.trace('Received metadata');
                                this.listener.onReceiveMetadata(metadata);
                            },
                            onReceiveMessage: message => {
                                this.trace('Received message');
                                this.listener.onReceiveMessage(message);
                            },
                            onReceiveStatus: status => {
                                this.trace('Received status');
                                if (status.rstCode ===
                                    http2.constants.NGHTTP2_REFUSED_STREAM) {
                                    this.outputStatus(status, 'REFUSED');
                                }
                                else {
                                    this.outputStatus(status, 'PROCESSED');
                                }
                            },
                        });
                        this.childStartTime = new Date();
                    }
                    catch (error) {
                        this.trace('Failed to start call on picked subchannel ' +
                            subchannelString +
                            ' with error ' +
                            error.message);
                        this.outputStatus({
                            code: constants_1.Status.INTERNAL,
                            details: 'Failed to start HTTP/2 stream with error ' +
                                error.message,
                            metadata: new metadata_1.Metadata(),
                        }, 'NOT_STARTED');
                        return;
                    }
                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);
                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);
                    this.onCallEnded = pickResult.onCallEnded;
                    this.trace('Created child call [' + this.child.getCallNumber() + ']');
                    if (this.readPending) {
                        this.child.startRead();
                    }
                    if (this.pendingMessage) {
                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
                    }
                    if (this.pendingHalfClose) {
                        this.child.halfClose();
                    }
                }, (error) => {
                    // We assume the error code isn't 0 (Status.OK)
                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
                    this.outputStatus({
                        code: code,
                        details: details,
                        metadata: new metadata_1.Metadata(),
                    }, 'PROCESSED');
                });
                break;
            case picker_1.PickResultType.DROP:
                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
                setImmediate(() => {
                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');
                });
                break;
            case picker_1.PickResultType.TRANSIENT_FAILURE:
                if (this.metadata.getOptions().waitForReady) {
                    this.channel.queueCallForPick(this);
                }
                else {
                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
                    setImmediate(() => {
                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');
                    });
                }
                break;
            case picker_1.PickResultType.QUEUE:
                this.channel.queueCallForPick(this);
        }
    }
    cancelWithStatus(status, details) {
        var _a;
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
    }
    start(metadata, listener) {
        this.trace('start called');
        this.listener = listener;
        this.metadata = metadata;
        this.doPick();
    }
    sendMessageWithContext(context, message) {
        this.trace('write() called with message of length ' + message.length);
        if (this.child) {
            this.child.sendMessageWithContext(context, message);
        }
        else {
            this.pendingMessage = { context, message };
        }
    }
    startRead() {
        this.trace('startRead called');
        if (this.child) {
            this.child.startRead();
        }
        else {
            this.readPending = true;
        }
    }
    halfClose() {
        this.trace('halfClose called');
        if (this.child) {
            this.child.halfClose();
        }
        else {
            this.pendingHalfClose = true;
        }
    }
    setCredentials(credentials) {
        throw new Error('Method not implemented.');
    }
    getCallNumber() {
        return this.callNumber;
    }
}
exports.LoadBalancingCall = LoadBalancingCall;
//# sourceMappingURL=load-balancing-call.js.map{"version":3,"file":"load-balancing-call.js","sourceRoot":"","sources":["../../src/load-balancing-call.ts"],"names":[],"mappings":"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"}import { LogVerbosity } from './constants';
export declare const getLogger: () => Partial<Console>;
export declare const setLogger: (logger: Partial<Console>) => void;
export declare const setLoggerVerbosity: (verbosity: LogVerbosity) => void;
export declare const log: (severity: LogVerbosity, ...args: any[]) => void;
export declare function trace(severity: LogVerbosity, tracer: string, text: string): void;
export declare function isTracerEnabled(tracer: string): boolean;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;
exports.trace = trace;
exports.isTracerEnabled = isTracerEnabled;
const constants_1 = require("./constants");
const process_1 = require("process");
const clientVersion = require('../../package.json').version;
const DEFAULT_LOGGER = {
    error: (message, ...optionalParams) => {
        console.error('E ' + message, ...optionalParams);
    },
    info: (message, ...optionalParams) => {
        console.error('I ' + message, ...optionalParams);
    },
    debug: (message, ...optionalParams) => {
        console.error('D ' + message, ...optionalParams);
    },
};
let _logger = DEFAULT_LOGGER;
let _logVerbosity = constants_1.LogVerbosity.ERROR;
const verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';
switch (verbosityString.toUpperCase()) {
    case 'DEBUG':
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
    case 'INFO':
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
    case 'ERROR':
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
    case 'NONE':
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
    default:
    // Ignore any other values
}
const getLogger = () => {
    return _logger;
};
exports.getLogger = getLogger;
const setLogger = (logger) => {
    _logger = logger;
};
exports.setLogger = setLogger;
const setLoggerVerbosity = (verbosity) => {
    _logVerbosity = verbosity;
};
exports.setLoggerVerbosity = setLoggerVerbosity;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const log = (severity, ...args) => {
    let logFunction;
    if (severity >= _logVerbosity) {
        switch (severity) {
            case constants_1.LogVerbosity.DEBUG:
                logFunction = _logger.debug;
                break;
            case constants_1.LogVerbosity.INFO:
                logFunction = _logger.info;
                break;
            case constants_1.LogVerbosity.ERROR:
                logFunction = _logger.error;
                break;
        }
        /* Fall back to _logger.error when other methods are not available for
         * compatiblity with older behavior that always logged to _logger.error */
        if (!logFunction) {
            logFunction = _logger.error;
        }
        if (logFunction) {
            logFunction.bind(_logger)(...args);
        }
    }
};
exports.log = log;
const tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';
const enabledTracers = new Set();
const disabledTracers = new Set();
for (const tracerName of tracersString.split(',')) {
    if (tracerName.startsWith('-')) {
        disabledTracers.add(tracerName.substring(1));
    }
    else {
        enabledTracers.add(tracerName);
    }
}
const allEnabled = enabledTracers.has('all');
function trace(severity, tracer, text) {
    if (isTracerEnabled(tracer)) {
        (0, exports.log)(severity, new Date().toISOString() +
            ' | v' +
            clientVersion +
            ' ' +
            process_1.pid +
            ' | ' +
            tracer +
            ' | ' +
            text);
    }
}
function isTracerEnabled(tracer) {
    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));
}
//# sourceMappingURL=logging.js.map{"version":3,"file":"logging.js","sourceRoot":"","sources":["../../src/logging.ts"],"names":[],"mappings":"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"}import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { Client } from './client';
import { UntypedServiceImplementation } from './server';
export interface Serialize<T> {
    (value: T): Buffer;
}
export interface Deserialize<T> {
    (bytes: Buffer): T;
}
export interface ClientMethodDefinition<RequestType, ResponseType> {
    path: string;
    requestStream: boolean;
    responseStream: boolean;
    requestSerialize: Serialize<RequestType>;
    responseDeserialize: Deserialize<ResponseType>;
    originalName?: string;
}
export interface ServerMethodDefinition<RequestType, ResponseType> {
    path: string;
    requestStream: boolean;
    responseStream: boolean;
    responseSerialize: Serialize<ResponseType>;
    requestDeserialize: Deserialize<RequestType>;
    originalName?: string;
}
export interface MethodDefinition<RequestType, ResponseType> extends ClientMethodDefinition<RequestType, ResponseType>, ServerMethodDefinition<RequestType, ResponseType> {
}
export type ServiceDefinition<ImplementationType = UntypedServiceImplementation> = {
    readonly [index in keyof ImplementationType]: MethodDefinition<any, any>;
};
export interface ProtobufTypeDefinition {
    format: string;
    type: object;
    fileDescriptorProtos: Buffer[];
}
export interface PackageDefinition {
    [index: string]: ServiceDefinition | ProtobufTypeDefinition;
}
export interface ServiceClient extends Client {
    [methodName: string]: Function;
}
export interface ServiceClientConstructor {
    new (address: string, credentials: ChannelCredentials, options?: Partial<ChannelOptions>): ServiceClient;
    service: ServiceDefinition;
    serviceName: string;
}
/**
 * Creates a constructor for a client with the given methods, as specified in
 * the methods argument. The resulting class will have an instance method for
 * each method in the service, which is a partial application of one of the
 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
 * arguments predefined.
 * @param methods An object mapping method names to
 *     method attributes
 * @param serviceName The fully qualified name of the service
 * @param classOptions An options object.
 * @return New client constructor, which is a subclass of
 *     {@link grpc.Client}, and has the same arguments as that constructor.
 */
export declare function makeClientConstructor(methods: ServiceDefinition, serviceName: string, classOptions?: {}): ServiceClientConstructor;
export interface GrpcObject {
    [index: string]: GrpcObject | ServiceClientConstructor | ProtobufTypeDefinition;
}
/**
 * Load a gRPC package definition as a gRPC object hierarchy.
 * @param packageDef The package definition object.
 * @return The resulting gRPC object.
 */
export declare function loadPackageDefinition(packageDef: PackageDefinition): GrpcObject;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeClientConstructor = makeClientConstructor;
exports.loadPackageDefinition = loadPackageDefinition;
const client_1 = require("./client");
/**
 * Map with short names for each of the requester maker functions. Used in
 * makeClientConstructor
 * @private
 */
const requesterFuncs = {
    unary: client_1.Client.prototype.makeUnaryRequest,
    server_stream: client_1.Client.prototype.makeServerStreamRequest,
    client_stream: client_1.Client.prototype.makeClientStreamRequest,
    bidi: client_1.Client.prototype.makeBidiStreamRequest,
};
/**
 * Returns true, if given key is included in the blacklisted
 * keys.
 * @param key key for check, string.
 */
function isPrototypePolluted(key) {
    return ['__proto__', 'prototype', 'constructor'].includes(key);
}
/**
 * Creates a constructor for a client with the given methods, as specified in
 * the methods argument. The resulting class will have an instance method for
 * each method in the service, which is a partial application of one of the
 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
 * arguments predefined.
 * @param methods An object mapping method names to
 *     method attributes
 * @param serviceName The fully qualified name of the service
 * @param classOptions An options object.
 * @return New client constructor, which is a subclass of
 *     {@link grpc.Client}, and has the same arguments as that constructor.
 */
function makeClientConstructor(methods, serviceName, classOptions) {
    if (!classOptions) {
        classOptions = {};
    }
    class ServiceClientImpl extends client_1.Client {
    }
    Object.keys(methods).forEach(name => {
        if (isPrototypePolluted(name)) {
            return;
        }
        const attrs = methods[name];
        let methodType;
        // TODO(murgatroid99): Verify that we don't need this anymore
        if (typeof name === 'string' && name.charAt(0) === '$') {
            throw new Error('Method names cannot start with $');
        }
        if (attrs.requestStream) {
            if (attrs.responseStream) {
                methodType = 'bidi';
            }
            else {
                methodType = 'client_stream';
            }
        }
        else {
            if (attrs.responseStream) {
                methodType = 'server_stream';
            }
            else {
                methodType = 'unary';
            }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name] = methodFunc;
        // Associate all provided attributes with the method
        Object.assign(ServiceClientImpl.prototype[name], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
            ServiceClientImpl.prototype[attrs.originalName] =
                ServiceClientImpl.prototype[name];
        }
    });
    ServiceClientImpl.service = methods;
    ServiceClientImpl.serviceName = serviceName;
    return ServiceClientImpl;
}
function partial(fn, path, serialize, deserialize) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function (...args) {
        return fn.call(this, path, serialize, deserialize, ...args);
    };
}
function isProtobufTypeDefinition(obj) {
    return 'format' in obj;
}
/**
 * Load a gRPC package definition as a gRPC object hierarchy.
 * @param packageDef The package definition object.
 * @return The resulting gRPC object.
 */
function loadPackageDefinition(packageDef) {
    const result = {};
    for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
            const service = packageDef[serviceFqn];
            const nameComponents = serviceFqn.split('.');
            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
                continue;
            }
            const serviceName = nameComponents[nameComponents.length - 1];
            let current = result;
            for (const packageName of nameComponents.slice(0, -1)) {
                if (!current[packageName]) {
                    current[packageName] = {};
                }
                current = current[packageName];
            }
            if (isProtobufTypeDefinition(service)) {
                current[serviceName] = service;
            }
            else {
                current[serviceName] = makeClientConstructor(service, serviceName, {});
            }
        }
    }
    return result;
}
//# sourceMappingURL=make-client.js.map{"version":3,"file":"make-client.js","sourceRoot":"","sources":["../../src/make-client.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAwGH,sDA2DC;AAgCD,sDA2BC;AA1ND,qCAAkC;AAmDlC;;;;GAIG;AACH,MAAM,cAAc,GAAG;IACrB,KAAK,EAAE,eAAM,CAAC,SAAS,CAAC,gBAAgB;IACxC,aAAa,EAAE,eAAM,CAAC,SAAS,CAAC,uBAAuB;IACvD,aAAa,EAAE,eAAM,CAAC,SAAS,CAAC,uBAAuB;IACvD,IAAI,EAAE,eAAM,CAAC,SAAS,CAAC,qBAAqB;CAC7C,CAAC;AAgBF;;;;GAIG;AACH,SAAS,mBAAmB,CAAC,GAAW;IACtC,OAAO,CAAC,WAAW,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AACjE,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,SAAgB,qBAAqB,CACnC,OAA0B,EAC1B,WAAmB,EACnB,YAAiB;IAEjB,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,YAAY,GAAG,EAAE,CAAC;IACpB,CAAC;IAED,MAAM,iBAAkB,SAAQ,eAAM;KAIrC;IAED,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QAClC,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC;YAC9B,OAAO;QACT,CAAC;QACD,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QAC5B,IAAI,UAAuC,CAAC;QAC5C,6DAA6D;QAC7D,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YACvD,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACtD,CAAC;QACD,IAAI,KAAK,CAAC,aAAa,EAAE,CAAC;YACxB,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;gBACzB,UAAU,GAAG,MAAM,CAAC;YACtB,CAAC;iBAAM,CAAC;gBACN,UAAU,GAAG,eAAe,CAAC;YAC/B,CAAC;QACH,CAAC;aAAM,CAAC;YACN,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;gBACzB,UAAU,GAAG,eAAe,CAAC;YAC/B,CAAC;iBAAM,CAAC;gBACN,UAAU,GAAG,OAAO,CAAC;YACvB,CAAC;QACH,CAAC;QACD,MAAM,SAAS,GAAG,KAAK,CAAC,gBAAgB,CAAC;QACzC,MAAM,WAAW,GAAG,KAAK,CAAC,mBAAmB,CAAC;QAC9C,MAAM,UAAU,GAAG,OAAO,CACxB,cAAc,CAAC,UAAU,CAAC,EAC1B,KAAK,CAAC,IAAI,EACV,SAAS,EACT,WAAW,CACZ,CAAC;QACF,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC;QAC/C,oDAAoD;QACpD,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;QACxD,IAAI,KAAK,CAAC,YAAY,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC;YACnE,iBAAiB,CAAC,SAAS,CAAC,KAAK,CAAC,YAAY,CAAC;gBAC7C,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACtC,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,iBAAiB,CAAC,OAAO,GAAG,OAAO,CAAC;IACpC,iBAAiB,CAAC,WAAW,GAAG,WAAW,CAAC;IAE5C,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAED,SAAS,OAAO,CACd,EAAY,EACZ,IAAY,EACZ,SAAmB,EACnB,WAAqB;IAErB,8DAA8D;IAC9D,OAAO,UAAqB,GAAG,IAAW;QACxC,OAAO,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,CAAC;IAC9D,CAAC,CAAC;AACJ,CAAC;AASD,SAAS,wBAAwB,CAC/B,GAA+C;IAE/C,OAAO,QAAQ,IAAI,GAAG,CAAC;AACzB,CAAC;AAED;;;;GAIG;AACH,SAAgB,qBAAqB,CACnC,UAA6B;IAE7B,MAAM,MAAM,GAAe,EAAE,CAAC;IAC9B,KAAK,MAAM,UAAU,IAAI,UAAU,EAAE,CAAC;QACpC,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE,CAAC;YACjE,MAAM,OAAO,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC;YACvC,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC7C,IAAI,cAAc,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;gBACrE,SAAS;YACX,CAAC;YACD,MAAM,WAAW,GAAG,cAAc,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAC9D,IAAI,OAAO,GAAG,MAAM,CAAC;YACrB,KAAK,MAAM,WAAW,IAAI,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBACtD,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC;oBAC1B,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC;gBAC5B,CAAC;gBACD,OAAO,GAAG,OAAO,CAAC,WAAW,CAAe,CAAC;YAC/C,CAAC;YACD,IAAI,wBAAwB,CAAC,OAAO,CAAC,EAAE,CAAC;gBACtC,OAAO,CAAC,WAAW,CAAC,GAAG,OAAO,CAAC;YACjC,CAAC;iBAAM,CAAC;gBACN,OAAO,CAAC,WAAW,CAAC,GAAG,qBAAqB,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC;YACzE,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC"}import * as http2 from 'http2';
export type MetadataValue = string | Buffer;
export type MetadataObject = Map<string, MetadataValue[]>;
export interface MetadataOptions {
    idempotentRequest?: boolean;
    waitForReady?: boolean;
    cacheableRequest?: boolean;
    corked?: boolean;
}
/**
 * A class for storing metadata. Keys are normalized to lowercase ASCII.
 */
export declare class Metadata {
    protected internalRepr: MetadataObject;
    private options;
    constructor(options?: MetadataOptions);
    /**
     * Sets the given value for the given key by replacing any other values
     * associated with that key. Normalizes the key.
     * @param key The key to whose value should be set.
     * @param value The value to set. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    set(key: string, value: MetadataValue): void;
    /**
     * Adds the given value for the given key by appending to a list of previous
     * values associated with that key. Normalizes the key.
     * @param key The key for which a new value should be appended.
     * @param value The value to add. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    add(key: string, value: MetadataValue): void;
    /**
     * Removes the given key and any associated values. Normalizes the key.
     * @param key The key whose values should be removed.
     */
    remove(key: string): void;
    /**
     * Gets a list of all values associated with the key. Normalizes the key.
     * @param key The key whose value should be retrieved.
     * @return A list of values associated with the given key.
     */
    get(key: string): MetadataValue[];
    /**
     * Gets a plain object mapping each key to the first value associated with it.
     * This reflects the most common way that people will want to see metadata.
     * @return A key/value mapping of the metadata.
     */
    getMap(): {
        [key: string]: MetadataValue;
    };
    /**
     * Clones the metadata object.
     * @return The newly cloned object.
     */
    clone(): Metadata;
    /**
     * Merges all key-value pairs from a given Metadata object into this one.
     * If both this object and the given object have values in the same key,
     * values from the other Metadata object will be appended to this object's
     * values.
     * @param other A Metadata object.
     */
    merge(other: Metadata): void;
    setOptions(options: MetadataOptions): void;
    getOptions(): MetadataOptions;
    /**
     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
     */
    toHttp2Headers(): http2.OutgoingHttpHeaders;
    /**
     * This modifies the behavior of JSON.stringify to show an object
     * representation of the metadata map.
     */
    toJSON(): {
        [key: string]: MetadataValue[];
    };
    /**
     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
     * object.
     * @param headers An IncomingHttpHeaders object.
     */
    static fromHttp2Headers(headers: http2.IncomingHttpHeaders): Metadata;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metadata = void 0;
const logging_1 = require("./logging");
const constants_1 = require("./constants");
const error_1 = require("./error");
const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
function isLegalKey(key) {
    return LEGAL_KEY_REGEX.test(key);
}
function isLegalNonBinaryValue(value) {
    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
}
function isBinaryKey(key) {
    return key.endsWith('-bin');
}
function isCustomMetadata(key) {
    return !key.startsWith('grpc-');
}
function normalizeKey(key) {
    return key.toLowerCase();
}
function validate(key, value) {
    if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
    }
    if (value !== null && value !== undefined) {
        if (isBinaryKey(key)) {
            if (!Buffer.isBuffer(value)) {
                throw new Error("keys that end with '-bin' must have Buffer values");
            }
        }
        else {
            if (Buffer.isBuffer(value)) {
                throw new Error("keys that don't end with '-bin' must have String values");
            }
            if (!isLegalNonBinaryValue(value)) {
                throw new Error('Metadata string value "' + value + '" contains illegal characters');
            }
        }
    }
}
/**
 * A class for storing metadata. Keys are normalized to lowercase ASCII.
 */
class Metadata {
    constructor(options = {}) {
        this.internalRepr = new Map();
        this.options = options;
    }
    /**
     * Sets the given value for the given key by replacing any other values
     * associated with that key. Normalizes the key.
     * @param key The key to whose value should be set.
     * @param value The value to set. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    set(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
    }
    /**
     * Adds the given value for the given key by appending to a list of previous
     * values associated with that key. Normalizes the key.
     * @param key The key for which a new value should be appended.
     * @param value The value to add. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    add(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === undefined) {
            this.internalRepr.set(key, [value]);
        }
        else {
            existingValue.push(value);
        }
    }
    /**
     * Removes the given key and any associated values. Normalizes the key.
     * @param key The key whose values should be removed.
     */
    remove(key) {
        key = normalizeKey(key);
        // validate(key);
        this.internalRepr.delete(key);
    }
    /**
     * Gets a list of all values associated with the key. Normalizes the key.
     * @param key The key whose value should be retrieved.
     * @return A list of values associated with the given key.
     */
    get(key) {
        key = normalizeKey(key);
        // validate(key);
        return this.internalRepr.get(key) || [];
    }
    /**
     * Gets a plain object mapping each key to the first value associated with it.
     * This reflects the most common way that people will want to see metadata.
     * @return A key/value mapping of the metadata.
     */
    getMap() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
            if (values.length > 0) {
                const v = values[0];
                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
            }
        }
        return result;
    }
    /**
     * Clones the metadata object.
     * @return The newly cloned object.
     */
    clone() {
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        for (const [key, value] of this.internalRepr) {
            const clonedValue = value.map(v => {
                if (Buffer.isBuffer(v)) {
                    return Buffer.from(v);
                }
                else {
                    return v;
                }
            });
            newInternalRepr.set(key, clonedValue);
        }
        return newMetadata;
    }
    /**
     * Merges all key-value pairs from a given Metadata object into this one.
     * If both this object and the given object have values in the same key,
     * values from the other Metadata object will be appended to this object's
     * values.
     * @param other A Metadata object.
     */
    merge(other) {
        for (const [key, values] of other.internalRepr) {
            const mergedValue = (this.internalRepr.get(key) || []).concat(values);
            this.internalRepr.set(key, mergedValue);
        }
    }
    setOptions(options) {
        this.options = options;
    }
    getOptions() {
        return this.options;
    }
    /**
     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
     */
    toHttp2Headers() {
        // NOTE: Node <8.9 formats http2 headers incorrectly.
        const result = {};
        for (const [key, values] of this.internalRepr) {
            // We assume that the user's interaction with this object is limited to
            // through its public API (i.e. keys and values are already validated).
            result[key] = values.map(bufToString);
        }
        return result;
    }
    /**
     * This modifies the behavior of JSON.stringify to show an object
     * representation of the metadata map.
     */
    toJSON() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
            result[key] = values;
        }
        return result;
    }
    /**
     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
     * object.
     * @param headers An IncomingHttpHeaders object.
     */
    static fromHttp2Headers(headers) {
        const result = new Metadata();
        for (const key of Object.keys(headers)) {
            // Reserved headers (beginning with `:`) are not valid keys.
            if (key.charAt(0) === ':') {
                continue;
            }
            const values = headers[key];
            try {
                if (isBinaryKey(key)) {
                    if (Array.isArray(values)) {
                        values.forEach(value => {
                            result.add(key, Buffer.from(value, 'base64'));
                        });
                    }
                    else if (values !== undefined) {
                        if (isCustomMetadata(key)) {
                            values.split(',').forEach(v => {
                                result.add(key, Buffer.from(v.trim(), 'base64'));
                            });
                        }
                        else {
                            result.add(key, Buffer.from(values, 'base64'));
                        }
                    }
                }
                else {
                    if (Array.isArray(values)) {
                        values.forEach(value => {
                            result.add(key, value);
                        });
                    }
                    else if (values !== undefined) {
                        result.add(key, values);
                    }
                }
            }
            catch (error) {
                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
            }
        }
        return result;
    }
}
exports.Metadata = Metadata;
const bufToString = (val) => {
    return Buffer.isBuffer(val) ? val.toString('base64') : val;
};
//# sourceMappingURL=metadata.js.map{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../src/metadata.ts"],"names":[],"mappings":"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"}import { Readable, Writable } from 'stream';
import { EmitterAugmentation1 } from './events';
export type WriteCallback = (error: Error | null | undefined) => void;
export interface IntermediateObjectReadable<T> extends Readable {
    read(size?: number): any & T;
}
export type ObjectReadable<T> = {
    read(size?: number): T;
} & EmitterAugmentation1<'data', T> & IntermediateObjectReadable<T>;
export interface IntermediateObjectWritable<T> extends Writable {
    _write(chunk: any & T, encoding: string, callback: Function): void;
    write(chunk: any & T, cb?: WriteCallback): boolean;
    write(chunk: any & T, encoding?: any, cb?: WriteCallback): boolean;
    setDefaultEncoding(encoding: string): this;
    end(): ReturnType<Writable['end']> extends Writable ? this : void;
    end(chunk: any & T, cb?: Function): ReturnType<Writable['end']> extends Writable ? this : void;
    end(chunk: any & T, encoding?: any, cb?: Function): ReturnType<Writable['end']> extends Writable ? this : void;
}
export interface ObjectWritable<T> extends IntermediateObjectWritable<T> {
    _write(chunk: T, encoding: string, callback: Function): void;
    write(chunk: T, cb?: Function): boolean;
    write(chunk: T, encoding?: any, cb?: Function): boolean;
    setDefaultEncoding(encoding: string): this;
    end(): ReturnType<Writable['end']> extends Writable ? this : void;
    end(chunk: T, cb?: Function): ReturnType<Writable['end']> extends Writable ? this : void;
    end(chunk: T, encoding?: any, cb?: Function): ReturnType<Writable['end']> extends Writable ? this : void;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=object-stream.js.map{"version":3,"file":"object-stream.js","sourceRoot":"","sources":["../../src/object-stream.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG"}import { StatusObject } from './call-interface';
import { Metadata } from './metadata';
import { Status } from './constants';
import { LoadBalancer } from './load-balancer';
import { SubchannelInterface } from './subchannel-interface';
export declare enum PickResultType {
    COMPLETE = 0,
    QUEUE = 1,
    TRANSIENT_FAILURE = 2,
    DROP = 3
}
export interface PickResult {
    pickResultType: PickResultType;
    /**
     * The subchannel to use as the transport for the call. Only meaningful if
     * `pickResultType` is COMPLETE. If null, indicates that the call should be
     * dropped.
     */
    subchannel: SubchannelInterface | null;
    /**
     * The status object to end the call with. Populated if and only if
     * `pickResultType` is TRANSIENT_FAILURE.
     */
    status: StatusObject | null;
    onCallStarted: (() => void) | null;
    onCallEnded: ((statusCode: Status) => void) | null;
}
export interface CompletePickResult extends PickResult {
    pickResultType: PickResultType.COMPLETE;
    subchannel: SubchannelInterface | null;
    status: null;
    onCallStarted: (() => void) | null;
    onCallEnded: ((statusCode: Status) => void) | null;
}
export interface QueuePickResult extends PickResult {
    pickResultType: PickResultType.QUEUE;
    subchannel: null;
    status: null;
    onCallStarted: null;
    onCallEnded: null;
}
export interface TransientFailurePickResult extends PickResult {
    pickResultType: PickResultType.TRANSIENT_FAILURE;
    subchannel: null;
    status: StatusObject;
    onCallStarted: null;
    onCallEnded: null;
}
export interface DropCallPickResult extends PickResult {
    pickResultType: PickResultType.DROP;
    subchannel: null;
    status: StatusObject;
    onCallStarted: null;
    onCallEnded: null;
}
export interface PickArgs {
    metadata: Metadata;
    extraPickInfo: {
        [key: string]: string;
    };
}
/**
 * A proxy object representing the momentary state of a load balancer. Picks
 * subchannels or returns other information based on that state. Should be
 * replaced every time the load balancer changes state.
 */
export interface Picker {
    pick(pickArgs: PickArgs): PickResult;
}
/**
 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
 * state. Always responds to every pick request with an UNAVAILABLE status.
 */
export declare class UnavailablePicker implements Picker {
    private status;
    constructor(status?: Partial<StatusObject>);
    pick(pickArgs: PickArgs): TransientFailurePickResult;
}
/**
 * A standard picker representing a load balancer in the IDLE or CONNECTING
 * state. Always responds to every pick request with a QUEUE pick result
 * indicating that the pick should be tried again with the next `Picker`. Also
 * reports back to the load balancer that a connection should be established
 * once any pick is attempted.
 * If the childPicker is provided, delegate to it instead of returning the
 * hardcoded QUEUE pick result, but still calls exitIdle.
 */
export declare class QueuePicker {
    private loadBalancer;
    private childPicker?;
    private calledExitIdle;
    constructor(loadBalancer: LoadBalancer, childPicker?: Picker | undefined);
    pick(pickArgs: PickArgs): PickResult;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;
const metadata_1 = require("./metadata");
const constants_1 = require("./constants");
var PickResultType;
(function (PickResultType) {
    PickResultType[PickResultType["COMPLETE"] = 0] = "COMPLETE";
    PickResultType[PickResultType["QUEUE"] = 1] = "QUEUE";
    PickResultType[PickResultType["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
    PickResultType[PickResultType["DROP"] = 3] = "DROP";
})(PickResultType || (exports.PickResultType = PickResultType = {}));
/**
 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
 * state. Always responds to every pick request with an UNAVAILABLE status.
 */
class UnavailablePicker {
    constructor(status) {
        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);
    }
    pick(pickArgs) {
        return {
            pickResultType: PickResultType.TRANSIENT_FAILURE,
            subchannel: null,
            status: this.status,
            onCallStarted: null,
            onCallEnded: null,
        };
    }
}
exports.UnavailablePicker = UnavailablePicker;
/**
 * A standard picker representing a load balancer in the IDLE or CONNECTING
 * state. Always responds to every pick request with a QUEUE pick result
 * indicating that the pick should be tried again with the next `Picker`. Also
 * reports back to the load balancer that a connection should be established
 * once any pick is attempted.
 * If the childPicker is provided, delegate to it instead of returning the
 * hardcoded QUEUE pick result, but still calls exitIdle.
 */
class QueuePicker {
    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
    constructor(loadBalancer, childPicker) {
        this.loadBalancer = loadBalancer;
        this.childPicker = childPicker;
        this.calledExitIdle = false;
    }
    pick(pickArgs) {
        if (!this.calledExitIdle) {
            process.nextTick(() => {
                this.loadBalancer.exitIdle();
            });
            this.calledExitIdle = true;
        }
        if (this.childPicker) {
            return this.childPicker.pick(pickArgs);
        }
        else {
            return {
                pickResultType: PickResultType.QUEUE,
                subchannel: null,
                status: null,
                onCallStarted: null,
                onCallEnded: null,
            };
        }
    }
}
exports.QueuePicker = QueuePicker;
//# sourceMappingURL=picker.js.map{"version":3,"file":"picker.js","sourceRoot":"","sources":["../../src/picker.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAGH,yCAAsC;AACtC,2CAAqC;AAIrC,IAAY,cAKX;AALD,WAAY,cAAc;IACxB,2DAAQ,CAAA;IACR,qDAAK,CAAA;IACL,6EAAiB,CAAA;IACjB,mDAAI,CAAA;AACN,CAAC,EALW,cAAc,8BAAd,cAAc,QAKzB;AAiED;;;GAGG;AACH,MAAa,iBAAiB;IAE5B,YAAY,MAA8B;QACxC,IAAI,CAAC,MAAM,mBACT,IAAI,EAAE,kBAAM,CAAC,WAAW,EACxB,OAAO,EAAE,2BAA2B,EACpC,QAAQ,EAAE,IAAI,mBAAQ,EAAE,IACrB,MAAM,CACV,CAAC;IACJ,CAAC;IACD,IAAI,CAAC,QAAkB;QACrB,OAAO;YACL,cAAc,EAAE,cAAc,CAAC,iBAAiB;YAChD,UAAU,EAAE,IAAI;YAChB,MAAM,EAAE,IAAI,CAAC,MAAM;YACnB,aAAa,EAAE,IAAI;YACnB,WAAW,EAAE,IAAI;SAClB,CAAC;IACJ,CAAC;CACF;AAnBD,8CAmBC;AAED;;;;;;;;GAQG;AACH,MAAa,WAAW;IAEtB,uFAAuF;IACvF,YACU,YAA0B,EAC1B,WAAoB;QADpB,iBAAY,GAAZ,YAAY,CAAc;QAC1B,gBAAW,GAAX,WAAW,CAAS;QAJtB,mBAAc,GAAG,KAAK,CAAC;IAK5B,CAAC;IAEJ,IAAI,CAAC,QAAkB;QACrB,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACpB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;YAC/B,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC7B,CAAC;QACD,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACrB,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzC,CAAC;aAAM,CAAC;YACN,OAAO;gBACL,cAAc,EAAE,cAAc,CAAC,KAAK;gBACpC,UAAU,EAAE,IAAI;gBAChB,MAAM,EAAE,IAAI;gBACZ,aAAa,EAAE,IAAI;gBACnB,WAAW,EAAE,IAAI;aAClB,CAAC;QACJ,CAAC;IACH,CAAC;CACF;AA3BD,kCA2BC"}/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
export declare const DEFAULT_PORT = 443;
/**
 * Set up the DNS resolver class by registering it as the handler for the
 * "dns:" prefix and as the default resolver.
 */
export declare function setup(): void;
export interface DnsUrl {
    host: string;
    port?: string;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PORT = void 0;
exports.setup = setup;
const resolver_1 = require("./resolver");
const node_dns_1 = require("node:dns");
const service_config_1 = require("./service-config");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const logging = require("./logging");
const constants_2 = require("./constants");
const uri_parser_1 = require("./uri-parser");
const net_1 = require("net");
const backoff_timeout_1 = require("./backoff-timeout");
const environment_1 = require("./environment");
const TRACER_NAME = 'dns_resolver';
function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
}
/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
exports.DEFAULT_PORT = 443;
const DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;
/**
 * Resolver implementation that handles DNS names and IP addresses.
 */
class DnsResolver {
    constructor(target, listener, channelOptions) {
        var _a, _b, _c;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.continueResolving = false;
        this.isNextResolutionTimerRunning = false;
        this.isServiceConfigEnabled = true;
        this.returnedIpResult = false;
        this.alternativeResolver = new node_dns_1.promises.Resolver();
        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
        if (target.authority) {
            this.alternativeResolver.setServers([target.authority]);
        }
        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
        if (hostPort === null) {
            this.ipResult = null;
            this.dnsHostname = null;
            this.port = null;
        }
        else {
            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
                this.ipResult = [
                    {
                        addresses: [
                            {
                                host: hostPort.host,
                                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,
                            },
                        ],
                    },
                ];
                this.dnsHostname = null;
                this.port = null;
            }
            else {
                this.ipResult = null;
                this.dnsHostname = hostPort.host;
                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;
            }
        }
        this.percentage = Math.random() * 100;
        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {
            this.isServiceConfigEnabled = false;
        }
        this.defaultResolutionError = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
            metadata: new metadata_1.Metadata(),
        };
        const backoffOptions = {
            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
        };
        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
            if (this.continueResolving) {
                this.startResolutionWithBackoff();
            }
        }, backoffOptions);
        this.backoff.unref();
        this.minTimeBetweenResolutionsMs =
            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
        this.nextResolutionTimer = setTimeout(() => { }, 0);
        clearTimeout(this.nextResolutionTimer);
    }
    /**
     * If the target is an IP address, just provide that address as a result.
     * Otherwise, initiate A, AAAA, and TXT lookups
     */
    startResolution() {
        if (this.ipResult !== null) {
            if (!this.returnedIpResult) {
                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));
                setImmediate(() => {
                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
                });
                this.returnedIpResult = true;
            }
            this.backoff.stop();
            this.backoff.reset();
            this.stopNextResolutionTimer();
            return;
        }
        if (this.dnsHostname === null) {
            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));
            setImmediate(() => {
                this.listener.onError({
                    code: constants_1.Status.UNAVAILABLE,
                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
                    metadata: new metadata_1.Metadata(),
                });
            });
            this.stopNextResolutionTimer();
        }
        else {
            if (this.pendingLookupPromise !== null) {
                return;
            }
            trace('Looking up DNS hostname ' + this.dnsHostname);
            /* We clear out latestLookupResult here to ensure that it contains the
             * latest result since the last time we started resolving. That way, the
             * TXT resolution handler can use it, but only if it finishes second. We
             * don't clear out any previous service config results because it's
             * better to use a service config that's slightly out of date than to
             * revert to an effectively blank one. */
            this.latestLookupResult = null;
            const hostname = this.dnsHostname;
            this.pendingLookupPromise = this.lookup(hostname);
            this.pendingLookupPromise.then(addressList => {
                if (this.pendingLookupPromise === null) {
                    return;
                }
                this.pendingLookupPromise = null;
                this.backoff.reset();
                this.backoff.stop();
                this.latestLookupResult = addressList.map(address => ({
                    addresses: [address],
                }));
                const allAddressesString = '[' +
                    addressList.map(addr => addr.host + ':' + addr.port).join(',') +
                    ']';
                trace('Resolved addresses for target ' +
                    (0, uri_parser_1.uriToString)(this.target) +
                    ': ' +
                    allAddressesString);
                if (this.latestLookupResult.length === 0) {
                    this.listener.onError(this.defaultResolutionError);
                    return;
                }
                /* If the TXT lookup has not yet finished, both of the last two
                 * arguments will be null, which is the equivalent of getting an
                 * empty TXT response. When the TXT lookup does finish, its handler
                 * can update the service config by using the same address list */
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
            }, err => {
                if (this.pendingLookupPromise === null) {
                    return;
                }
                trace('Resolution error for target ' +
                    (0, uri_parser_1.uriToString)(this.target) +
                    ': ' +
                    err.message);
                this.pendingLookupPromise = null;
                this.stopNextResolutionTimer();
                this.listener.onError(this.defaultResolutionError);
            });
            /* If there already is a still-pending TXT resolution, we can just use
             * that result when it comes in */
            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
                /* We handle the TXT query promise differently than the others because
                 * the name resolution attempt as a whole is a success even if the TXT
                 * lookup fails */
                this.pendingTxtPromise = this.resolveTxt(hostname);
                this.pendingTxtPromise.then(txtRecord => {
                    if (this.pendingTxtPromise === null) {
                        return;
                    }
                    this.pendingTxtPromise = null;
                    try {
                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
                    }
                    catch (err) {
                        this.latestServiceConfigError = {
                            code: constants_1.Status.UNAVAILABLE,
                            details: `Parsing service config failed with error ${err.message}`,
                            metadata: new metadata_1.Metadata(),
                        };
                    }
                    if (this.latestLookupResult !== null) {
                        /* We rely here on the assumption that calling this function with
                         * identical parameters will be essentialy idempotent, and calling
                         * it with the same address list and a different service config
                         * should result in a fast and seamless switchover. */
                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
                    }
                }, err => {
                    /* If TXT lookup fails we should do nothing, which means that we
                     * continue to use the result of the most recent successful lookup,
                     * or the default null config object if there has never been a
                     * successful lookup. We do not set the latestServiceConfigError
                     * here because that is specifically used for response validation
                     * errors. We still need to handle this error so that it does not
                     * bubble up as an unhandled promise rejection. */
                });
            }
        }
    }
    async lookup(hostname) {
        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
            trace('Using alternative DNS resolver.');
            const records = await Promise.allSettled([
                this.alternativeResolver.resolve4(hostname),
                this.alternativeResolver.resolve6(hostname),
            ]);
            if (records.every(result => result.status === 'rejected')) {
                throw new Error(records[0].reason);
            }
            return records
                .reduce((acc, result) => {
                return result.status === 'fulfilled'
                    ? [...acc, ...result.value]
                    : acc;
            }, [])
                .map(addr => ({
                host: addr,
                port: +this.port,
            }));
        }
        /* We lookup both address families here and then split them up later
         * because when looking up a single family, dns.lookup outputs an error
         * if the name exists but there are no records for that family, and that
         * error is indistinguishable from other kinds of errors */
        const addressList = await node_dns_1.promises.lookup(hostname, { all: true });
        return addressList.map(addr => ({ host: addr.address, port: +this.port }));
    }
    async resolveTxt(hostname) {
        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
            trace('Using alternative DNS resolver.');
            return this.alternativeResolver.resolveTxt(hostname);
        }
        return node_dns_1.promises.resolveTxt(hostname);
    }
    startNextResolutionTimer() {
        var _a, _b;
        clearTimeout(this.nextResolutionTimer);
        this.nextResolutionTimer = setTimeout(() => {
            this.stopNextResolutionTimer();
            if (this.continueResolving) {
                this.startResolutionWithBackoff();
            }
        }, this.minTimeBetweenResolutionsMs);
        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.isNextResolutionTimerRunning = true;
    }
    stopNextResolutionTimer() {
        clearTimeout(this.nextResolutionTimer);
        this.isNextResolutionTimerRunning = false;
    }
    startResolutionWithBackoff() {
        if (this.pendingLookupPromise === null) {
            this.continueResolving = false;
            this.backoff.runOnce();
            this.startNextResolutionTimer();
            this.startResolution();
        }
    }
    updateResolution() {
        /* If there is a pending lookup, just let it finish. Otherwise, if the
         * nextResolutionTimer or backoff timer is running, set the
         * continueResolving flag to resolve when whichever of those timers
         * fires. Otherwise, start resolving immediately. */
        if (this.pendingLookupPromise === null) {
            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
                if (this.isNextResolutionTimerRunning) {
                    trace('resolution update delayed by "min time between resolutions" rate limit');
                }
                else {
                    trace('resolution update delayed by backoff timer until ' +
                        this.backoff.getEndTime().toISOString());
                }
                this.continueResolving = true;
            }
            else {
                this.startResolutionWithBackoff();
            }
        }
    }
    /**
     * Reset the resolver to the same state it had when it was created. In-flight
     * DNS requests cannot be cancelled, but they are discarded and their results
     * will be ignored.
     */
    destroy() {
        this.continueResolving = false;
        this.backoff.reset();
        this.backoff.stop();
        this.stopNextResolutionTimer();
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.returnedIpResult = false;
    }
    /**
     * Get the default authority for the given target. For IP targets, that is
     * the IP address. For DNS targets, it is the hostname.
     * @param target
     */
    static getDefaultAuthority(target) {
        return target.path;
    }
}
/**
 * Set up the DNS resolver class by registering it as the handler for the
 * "dns:" prefix and as the default resolver.
 */
function setup() {
    (0, resolver_1.registerResolver)('dns', DnsResolver);
    (0, resolver_1.registerDefaultScheme)('dns');
}
//# sourceMappingURL=resolver-dns.js.map{"version":3,"file":"resolver-dns.js","sourceRoot":"","sources":["../../src/resolver-dns.ts"],"names":[],"mappings":"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"}export declare function setup(): void;
"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = setup;
const net_1 = require("net");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const resolver_1 = require("./resolver");
const uri_parser_1 = require("./uri-parser");
const logging = require("./logging");
const TRACER_NAME = 'ip_resolver';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const IPV4_SCHEME = 'ipv4';
const IPV6_SCHEME = 'ipv6';
/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
const DEFAULT_PORT = 443;
class IpResolver {
    constructor(target, listener, channelOptions) {
        var _a;
        this.listener = listener;
        this.endpoints = [];
        this.error = null;
        this.hasReturnedResult = false;
        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
            this.error = {
                code: constants_1.Status.UNAVAILABLE,
                details: `Unrecognized scheme ${target.scheme} in IP resolver`,
                metadata: new metadata_1.Metadata(),
            };
            return;
        }
        const pathList = target.path.split(',');
        for (const path of pathList) {
            const hostPort = (0, uri_parser_1.splitHostPort)(path);
            if (hostPort === null) {
                this.error = {
                    code: constants_1.Status.UNAVAILABLE,
                    details: `Failed to parse ${target.scheme} address ${path}`,
                    metadata: new metadata_1.Metadata(),
                };
                return;
            }
            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||
                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {
                this.error = {
                    code: constants_1.Status.UNAVAILABLE,
                    details: `Failed to parse ${target.scheme} address ${path}`,
                    metadata: new metadata_1.Metadata(),
                };
                return;
            }
            addresses.push({
                host: hostPort.host,
                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,
            });
        }
        this.endpoints = addresses.map(address => ({ addresses: [address] }));
        trace('Parsed ' + target.scheme + ' address list ' + addresses);
    }
    updateResolution() {
        if (!this.hasReturnedResult) {
            this.hasReturnedResult = true;
            process.nextTick(() => {
                if (this.error) {
                    this.listener.onError(this.error);
                }
                else {
                    this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
                }
            });
        }
    }
    destroy() {
        this.hasReturnedResult = false;
    }
    static getDefaultAuthority(target) {
        return target.path.split(',')[0];
    }
}
function setup() {
    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
}
//# sourceMappingURL=resolver-ip.js.map{"version":3,"file":"resolver-ip.js","sourceRoot":"","sources":["../../src/resolver-ip.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;AAsGH,sBAGC;AAvGD,6BAAqC;AAGrC,2CAAmD;AACnD,yCAAsC;AACtC,yCAA0E;AAE1E,6CAAmE;AACnE,qCAAqC;AAErC,MAAM,WAAW,GAAG,aAAa,CAAC;AAElC,SAAS,KAAK,CAAC,IAAY;IACzB,OAAO,CAAC,KAAK,CAAC,wBAAY,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;AACvD,CAAC;AAED,MAAM,WAAW,GAAG,MAAM,CAAC;AAC3B,MAAM,WAAW,GAAG,MAAM,CAAC;AAE3B;;GAEG;AACH,MAAM,YAAY,GAAG,GAAG,CAAC;AAEzB,MAAM,UAAU;IAId,YACE,MAAe,EACP,QAA0B,EAClC,cAA8B;;QADtB,aAAQ,GAAR,QAAQ,CAAkB;QAL5B,cAAS,GAAe,EAAE,CAAC;QAC3B,UAAK,GAAwB,IAAI,CAAC;QAClC,sBAAiB,GAAG,KAAK,CAAC;QAMhC,KAAK,CAAC,kCAAkC,GAAG,IAAA,wBAAW,EAAC,MAAM,CAAC,CAAC,CAAC;QAChE,MAAM,SAAS,GAAwB,EAAE,CAAC;QAC1C,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,MAAM,KAAK,WAAW,CAAC,EAAE,CAAC;YACtE,IAAI,CAAC,KAAK,GAAG;gBACX,IAAI,EAAE,kBAAM,CAAC,WAAW;gBACxB,OAAO,EAAE,uBAAuB,MAAM,CAAC,MAAM,iBAAiB;gBAC9D,QAAQ,EAAE,IAAI,mBAAQ,EAAE;aACzB,CAAC;YACF,OAAO;QACT,CAAC;QACD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACxC,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE,CAAC;YAC5B,MAAM,QAAQ,GAAG,IAAA,0BAAa,EAAC,IAAI,CAAC,CAAC;YACrC,IAAI,QAAQ,KAAK,IAAI,EAAE,CAAC;gBACtB,IAAI,CAAC,KAAK,GAAG;oBACX,IAAI,EAAE,kBAAM,CAAC,WAAW;oBACxB,OAAO,EAAE,mBAAmB,MAAM,CAAC,MAAM,YAAY,IAAI,EAAE;oBAC3D,QAAQ,EAAE,IAAI,mBAAQ,EAAE;iBACzB,CAAC;gBACF,OAAO;YACT,CAAC;YACD,IACE,CAAC,MAAM,CAAC,MAAM,KAAK,WAAW,IAAI,CAAC,IAAA,YAAM,EAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACzD,CAAC,MAAM,CAAC,MAAM,KAAK,WAAW,IAAI,CAAC,IAAA,YAAM,EAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EACzD,CAAC;gBACD,IAAI,CAAC,KAAK,GAAG;oBACX,IAAI,EAAE,kBAAM,CAAC,WAAW;oBACxB,OAAO,EAAE,mBAAmB,MAAM,CAAC,MAAM,YAAY,IAAI,EAAE;oBAC3D,QAAQ,EAAE,IAAI,mBAAQ,EAAE;iBACzB,CAAC;gBACF,OAAO;YACT,CAAC;YACD,SAAS,CAAC,IAAI,CAAC;gBACb,IAAI,EAAE,QAAQ,CAAC,IAAI;gBACnB,IAAI,EAAE,MAAA,QAAQ,CAAC,IAAI,mCAAI,YAAY;aACpC,CAAC,CAAC;QACL,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,SAAS,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;QACtE,KAAK,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,GAAG,gBAAgB,GAAG,SAAS,CAAC,CAAC;IAClE,CAAC;IACD,gBAAgB;QACd,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC5B,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAC9B,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACpB,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;oBACf,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACpC,CAAC;qBAAM,CAAC;oBACN,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAClC,IAAI,CAAC,SAAS,EACd,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,EAAE,CACH,CAAC;gBACJ,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IACD,OAAO;QACL,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;IACjC,CAAC;IAED,MAAM,CAAC,mBAAmB,CAAC,MAAe;QACxC,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACnC,CAAC;CACF;AAED,SAAgB,KAAK;IACnB,IAAA,2BAAgB,EAAC,WAAW,EAAE,UAAU,CAAC,CAAC;IAC1C,IAAA,2BAAgB,EAAC,WAAW,EAAE,UAAU,CAAC,CAAC;AAC5C,CAAC"}export declare function setup(): void;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = setup;
const resolver_1 = require("./resolver");
class UdsResolver {
    constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.hasReturnedResult = false;
        this.endpoints = [];
        let path;
        if (target.authority === '') {
            path = '/' + target.path;
        }
        else {
            path = target.path;
        }
        this.endpoints = [{ addresses: [{ path }] }];
    }
    updateResolution() {
        if (!this.hasReturnedResult) {
            this.hasReturnedResult = true;
            process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
        }
    }
    destroy() {
        this.hasReturnedResult = false;
    }
    static getDefaultAuthority(target) {
        return 'localhost';
    }
}
function setup() {
    (0, resolver_1.registerResolver)('unix', UdsResolver);
}
//# sourceMappingURL=resolver-uds.js.map{"version":3,"file":"resolver-uds.js","sourceRoot":"","sources":["../../src/resolver-uds.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;AA8CH,sBAEC;AA9CD,yCAA0E;AAK1E,MAAM,WAAW;IAGf,YACE,MAAe,EACP,QAA0B,EAClC,cAA8B;QADtB,aAAQ,GAAR,QAAQ,CAAkB;QAJ5B,sBAAiB,GAAG,KAAK,CAAC;QAC1B,cAAS,GAAe,EAAE,CAAC;QAMjC,IAAI,IAAY,CAAC;QACjB,IAAI,MAAM,CAAC,SAAS,KAAK,EAAE,EAAE,CAAC;YAC5B,IAAI,GAAG,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;QAC3B,CAAC;aAAM,CAAC;YACN,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;QACrB,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/C,CAAC;IACD,gBAAgB;QACd,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC5B,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAC9B,OAAO,CAAC,QAAQ,CACd,IAAI,CAAC,QAAQ,CAAC,sBAAsB,EACpC,IAAI,CAAC,SAAS,EACd,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,EAAE,CACH,CAAC;QACJ,CAAC;IACH,CAAC;IAED,OAAO;QACL,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;IACjC,CAAC;IAED,MAAM,CAAC,mBAAmB,CAAC,MAAe;QACxC,OAAO,WAAW,CAAC;IACrB,CAAC;CACF;AAED,SAAgB,KAAK;IACnB,IAAA,2BAAgB,EAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AACxC,CAAC"}import { MethodConfig, ServiceConfig } from './service-config';
import { StatusObject } from './call-interface';
import { Endpoint } from './subchannel-address';
import { GrpcUri } from './uri-parser';
import { ChannelOptions } from './channel-options';
import { Metadata } from './metadata';
import { Status } from './constants';
import { Filter, FilterFactory } from './filter';
export interface CallConfig {
    methodConfig: MethodConfig;
    onCommitted?: () => void;
    pickInformation: {
        [key: string]: string;
    };
    status: Status;
    dynamicFilterFactories: FilterFactory<Filter>[];
}
/**
 * Selects a configuration for a method given the name and metadata. Defined in
 * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc
 */
export interface ConfigSelector {
    (methodName: string, metadata: Metadata, channelId: number): CallConfig;
}
/**
 * A listener object passed to the resolver's constructor that provides name
 * resolution updates back to the resolver's owner.
 */
export interface ResolverListener {
    /**
     * Called whenever the resolver has new name resolution results to report
     * @param addressList The new list of backend addresses
     * @param serviceConfig The new service configuration corresponding to the
     *     `addressList`. Will be `null` if no service configuration was
     *     retrieved or if the service configuration was invalid
     * @param serviceConfigError If non-`null`, indicates that the retrieved
     *     service configuration was invalid
     */
    onSuccessfulResolution(addressList: Endpoint[], serviceConfig: ServiceConfig | null, serviceConfigError: StatusObject | null, configSelector: ConfigSelector | null, attributes: {
        [key: string]: unknown;
    }): void;
    /**
     * Called whenever a name resolution attempt fails.
     * @param error Describes how resolution failed
     */
    onError(error: StatusObject): void;
}
/**
 * A resolver class that handles one or more of the name syntax schemes defined
 * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 */
export interface Resolver {
    /**
     * Indicates that the caller wants new name resolution data. Calling this
     * function may eventually result in calling one of the `ResolverListener`
     * functions, but that is not guaranteed. Those functions will never be
     * called synchronously with the constructor or updateResolution.
     */
    updateResolution(): void;
    /**
     * Discard all resources owned by the resolver. A later call to
     * `updateResolution` should reinitialize those resources.  No
     * `ResolverListener` callbacks should be called after `destroy` is called
     * until `updateResolution` is called again.
     */
    destroy(): void;
}
export interface ResolverConstructor {
    new (target: GrpcUri, listener: ResolverListener, channelOptions: ChannelOptions): Resolver;
    /**
     * Get the default authority for a target. This loosely corresponds to that
     * target's hostname. Throws an error if this resolver class cannot parse the
     * `target`.
     * @param target
     */
    getDefaultAuthority(target: GrpcUri): string;
}
/**
 * Register a resolver class to handle target names prefixed with the `prefix`
 * string. This prefix should correspond to a URI scheme name listed in the
 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 * @param prefix
 * @param resolverClass
 */
export declare function registerResolver(scheme: string, resolverClass: ResolverConstructor): void;
/**
 * Register a default resolver to handle target names that do not start with
 * any registered prefix.
 * @param resolverClass
 */
export declare function registerDefaultScheme(scheme: string): void;
/**
 * Create a name resolver for the specified target, if possible. Throws an
 * error if no such name resolver can be created.
 * @param target
 * @param listener
 */
export declare function createResolver(target: GrpcUri, listener: ResolverListener, options: ChannelOptions): Resolver;
/**
 * Get the default authority for the specified target, if possible. Throws an
 * error if no registered name resolver can parse that target string.
 * @param target
 */
export declare function getDefaultAuthority(target: GrpcUri): string;
export declare function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerResolver = registerResolver;
exports.registerDefaultScheme = registerDefaultScheme;
exports.createResolver = createResolver;
exports.getDefaultAuthority = getDefaultAuthority;
exports.mapUriDefaultScheme = mapUriDefaultScheme;
const uri_parser_1 = require("./uri-parser");
const registeredResolvers = {};
let defaultScheme = null;
/**
 * Register a resolver class to handle target names prefixed with the `prefix`
 * string. This prefix should correspond to a URI scheme name listed in the
 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 * @param prefix
 * @param resolverClass
 */
function registerResolver(scheme, resolverClass) {
    registeredResolvers[scheme] = resolverClass;
}
/**
 * Register a default resolver to handle target names that do not start with
 * any registered prefix.
 * @param resolverClass
 */
function registerDefaultScheme(scheme) {
    defaultScheme = scheme;
}
/**
 * Create a name resolver for the specified target, if possible. Throws an
 * error if no such name resolver can be created.
 * @param target
 * @param listener
 */
function createResolver(target, listener, options) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
    }
    else {
        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
    }
}
/**
 * Get the default authority for the specified target, if possible. Throws an
 * error if no registered name resolver can parse that target string.
 * @param target
 */
function getDefaultAuthority(target) {
    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
    }
    else {
        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
    }
}
function mapUriDefaultScheme(target) {
    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
            return {
                scheme: defaultScheme,
                authority: undefined,
                path: (0, uri_parser_1.uriToString)(target),
            };
        }
        else {
            return null;
        }
    }
    return target;
}
//# sourceMappingURL=resolver.js.map{"version":3,"file":"resolver.js","sourceRoot":"","sources":["../../src/resolver.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;AAsGH,4CAKC;AAOD,sDAEC;AAQD,wCAYC;AAOD,kDAMC;AAED,kDAaC;AA/JD,6CAAoD;AAuFpD,MAAM,mBAAmB,GAA8C,EAAE,CAAC;AAC1E,IAAI,aAAa,GAAkB,IAAI,CAAC;AAExC;;;;;;GAMG;AACH,SAAgB,gBAAgB,CAC9B,MAAc,EACd,aAAkC;IAElC,mBAAmB,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC;AAC9C,CAAC;AAED;;;;GAIG;AACH,SAAgB,qBAAqB,CAAC,MAAc;IAClD,aAAa,GAAG,MAAM,CAAC;AACzB,CAAC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAC5B,MAAe,EACf,QAA0B,EAC1B,OAAuB;IAEvB,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,IAAI,mBAAmB,EAAE,CAAC;QACxE,OAAO,IAAI,mBAAmB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC3E,CAAC;SAAM,CAAC;QACN,MAAM,IAAI,KAAK,CACb,2CAA2C,IAAA,wBAAW,EAAC,MAAM,CAAC,EAAE,CACjE,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,MAAe;IACjD,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,IAAI,MAAM,CAAC,MAAM,IAAI,mBAAmB,EAAE,CAAC;QACxE,OAAO,mBAAmB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;IACxE,CAAC;SAAM,CAAC;QACN,MAAM,IAAI,KAAK,CAAC,kBAAkB,IAAA,wBAAW,EAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IAC3D,CAAC;AACH,CAAC;AAED,SAAgB,mBAAmB,CAAC,MAAe;IACjD,IAAI,MAAM,CAAC,MAAM,KAAK,SAAS,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,IAAI,mBAAmB,CAAC,EAAE,CAAC;QAC3E,IAAI,aAAa,KAAK,IAAI,EAAE,CAAC;YAC3B,OAAO;gBACL,MAAM,EAAE,aAAa;gBACrB,SAAS,EAAE,SAAS;gBACpB,IAAI,EAAE,IAAA,wBAAW,EAAC,MAAM,CAAC;aAC1B,CAAC;QACJ,CAAC;aAAM,CAAC;YACN,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC"}import { CallCredentials } from './call-credentials';
import { Call, CallStreamOptions, InterceptingListener, MessageContext, StatusObject } from './call-interface';
import { Status } from './constants';
import { FilterStackFactory } from './filter-stack';
import { InternalChannel } from './internal-channel';
import { Metadata } from './metadata';
export declare class ResolvingCall implements Call {
    private readonly channel;
    private readonly method;
    private readonly filterStackFactory;
    private credentials;
    private callNumber;
    private child;
    private readPending;
    private pendingMessage;
    private pendingHalfClose;
    private ended;
    private readFilterPending;
    private writeFilterPending;
    private pendingChildStatus;
    private metadata;
    private listener;
    private deadline;
    private host;
    private statusWatchers;
    private deadlineTimer;
    private filterStack;
    private deadlineStartTime;
    private configReceivedTime;
    private childStartTime;
    constructor(channel: InternalChannel, method: string, options: CallStreamOptions, filterStackFactory: FilterStackFactory, credentials: CallCredentials, callNumber: number);
    private trace;
    private runDeadlineTimer;
    private outputStatus;
    private sendMessageOnChild;
    getConfig(): void;
    reportResolverError(status: StatusObject): void;
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    start(metadata: Metadata, listener: InterceptingListener): void;
    sendMessageWithContext(context: MessageContext, message: Buffer): void;
    startRead(): void;
    halfClose(): void;
    setCredentials(credentials: CallCredentials): void;
    addStatusWatcher(watcher: (status: StatusObject) => void): void;
    getCallNumber(): number;
}
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolvingCall = void 0;
const constants_1 = require("./constants");
const deadline_1 = require("./deadline");
const metadata_1 = require("./metadata");
const logging = require("./logging");
const control_plane_status_1 = require("./control-plane-status");
const TRACER_NAME = 'resolving_call';
class ResolvingCall {
    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {
        this.channel = channel;
        this.method = method;
        this.filterStackFactory = filterStackFactory;
        this.credentials = credentials;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.readFilterPending = false;
        this.writeFilterPending = false;
        this.pendingChildStatus = null;
        this.metadata = null;
        this.listener = null;
        this.statusWatchers = [];
        this.deadlineTimer = setTimeout(() => { }, 0);
        this.filterStack = null;
        this.deadlineStartTime = null;
        this.configReceivedTime = null;
        this.childStartTime = null;
        this.deadline = options.deadline;
        this.host = options.host;
        if (options.parentCall) {
            if (options.flags & constants_1.Propagate.CANCELLATION) {
                options.parentCall.on('cancelled', () => {
                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');
                });
            }
            if (options.flags & constants_1.Propagate.DEADLINE) {
                this.trace('Propagating deadline from parent: ' +
                    options.parentCall.getDeadline());
                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
            }
        }
        this.trace('Created');
        this.runDeadlineTimer();
    }
    trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
    }
    runDeadlineTimer() {
        clearTimeout(this.deadlineTimer);
        this.deadlineStartTime = new Date();
        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));
        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);
        if (timeout !== Infinity) {
            this.trace('Deadline will be reached in ' + timeout + 'ms');
            const handleDeadline = () => {
                if (!this.deadlineStartTime) {
                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
                    return;
                }
                const deadlineInfo = [];
                const deadlineEndTime = new Date();
                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
                if (this.configReceivedTime) {
                    if (this.configReceivedTime > this.deadlineStartTime) {
                        deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
                    }
                    if (this.childStartTime) {
                        if (this.childStartTime > this.configReceivedTime) {
                            deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
                        }
                    }
                    else {
                        deadlineInfo.push('waiting for metadata filters');
                    }
                }
                else {
                    deadlineInfo.push('waiting for name resolution');
                }
                if (this.child) {
                    deadlineInfo.push(...this.child.getDeadlineInfo());
                }
                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));
            };
            if (timeout <= 0) {
                process.nextTick(handleDeadline);
            }
            else {
                this.deadlineTimer = setTimeout(handleDeadline, timeout);
            }
        }
    }
    outputStatus(status) {
        if (!this.ended) {
            this.ended = true;
            if (!this.filterStack) {
                this.filterStack = this.filterStackFactory.createFilter();
            }
            clearTimeout(this.deadlineTimer);
            const filteredStatus = this.filterStack.receiveTrailers(status);
            this.trace('ended with status: code=' +
                filteredStatus.code +
                ' details="' +
                filteredStatus.details +
                '"');
            this.statusWatchers.forEach(watcher => watcher(filteredStatus));
            process.nextTick(() => {
                var _a;
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
            });
        }
    }
    sendMessageOnChild(context, message) {
        if (!this.child) {
            throw new Error('sendMessageonChild called with child not populated');
        }
        const child = this.child;
        this.writeFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {
            this.writeFilterPending = false;
            child.sendMessageWithContext(context, filteredMessage.message);
            if (this.pendingHalfClose) {
                child.halfClose();
            }
        }, (status) => {
            this.cancelWithStatus(status.code, status.details);
        });
    }
    getConfig() {
        if (this.ended) {
            return;
        }
        if (!this.metadata || !this.listener) {
            throw new Error('getConfig called before start');
        }
        const configResult = this.channel.getConfig(this.method, this.metadata);
        if (configResult.type === 'NONE') {
            this.channel.queueCallForConfig(this);
            return;
        }
        else if (configResult.type === 'ERROR') {
            if (this.metadata.getOptions().waitForReady) {
                this.channel.queueCallForConfig(this);
            }
            else {
                this.outputStatus(configResult.error);
            }
            return;
        }
        // configResult.type === 'SUCCESS'
        this.configReceivedTime = new Date();
        const config = configResult.config;
        if (config.status !== constants_1.Status.OK) {
            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);
            this.outputStatus({
                code: code,
                details: details,
                metadata: new metadata_1.Metadata(),
            });
            return;
        }
        if (config.methodConfig.timeout) {
            const configDeadline = new Date();
            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +
                config.methodConfig.timeout.nanos / 1000000);
            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
            this.runDeadlineTimer();
        }
        this.filterStackFactory.push(config.dynamicFilterFactories);
        this.filterStack = this.filterStackFactory.createFilter();
        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {
            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
            this.trace('Created child [' + this.child.getCallNumber() + ']');
            this.childStartTime = new Date();
            this.child.start(filteredMetadata, {
                onReceiveMetadata: metadata => {
                    this.trace('Received metadata');
                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
                },
                onReceiveMessage: message => {
                    this.trace('Received message');
                    this.readFilterPending = true;
                    this.filterStack.receiveMessage(message).then(filteredMesssage => {
                        this.trace('Finished filtering received message');
                        this.readFilterPending = false;
                        this.listener.onReceiveMessage(filteredMesssage);
                        if (this.pendingChildStatus) {
                            this.outputStatus(this.pendingChildStatus);
                        }
                    }, (status) => {
                        this.cancelWithStatus(status.code, status.details);
                    });
                },
                onReceiveStatus: status => {
                    this.trace('Received status');
                    if (this.readFilterPending) {
                        this.pendingChildStatus = status;
                    }
                    else {
                        this.outputStatus(status);
                    }
                },
            });
            if (this.readPending) {
                this.child.startRead();
            }
            if (this.pendingMessage) {
                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
            }
            else if (this.pendingHalfClose) {
                this.child.halfClose();
            }
        }, (status) => {
            this.outputStatus(status);
        });
    }
    reportResolverError(status) {
        var _a;
        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {
            this.channel.queueCallForConfig(this);
        }
        else {
            this.outputStatus(status);
        }
    }
    cancelWithStatus(status, details) {
        var _a;
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus({
            code: status,
            details: details,
            metadata: new metadata_1.Metadata(),
        });
    }
    getPeer() {
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
    }
    start(metadata, listener) {
        this.trace('start called');
        this.metadata = metadata.clone();
        this.listener = listener;
        this.getConfig();
    }
    sendMessageWithContext(context, message) {
        this.trace('write() called with message of length ' + message.length);
        if (this.child) {
            this.sendMessageOnChild(context, message);
        }
        else {
            this.pendingMessage = { context, message };
        }
    }
    startRead() {
        this.trace('startRead called');
        if (this.child) {
            this.child.startRead();
        }
        else {
            this.readPending = true;
        }
    }
    halfClose() {
        this.trace('halfClose called');
        if (this.child && !this.writeFilterPending) {
            this.child.halfClose();
        }
        else {
            this.pendingHalfClose = true;
        }
    }
    setCredentials(credentials) {
        this.credentials = this.credentials.compose(credentials);
    }
    addStatusWatcher(watcher) {
        this.statusWatchers.push(watcher);
    }
    getCallNumber() {
        return this.callNumber;
    }
}
exports.ResolvingCall = ResolvingCall;
//# sourceMappingURL=resolving-call.js.map{"version":3,"file":"resolving-call.js","sourceRoot":"","sources":["../../src/resolving-call.ts"],"names":[],"mappings":"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"}import { ChannelControlHelper, LoadBalancer, TypedLoadBalancingConfig } from './load-balancer';
import { ServiceConfig } from './service-config';
import { ConfigSelector } from './resolver';
import { StatusObject } from './call-interface';
import { Endpoint } from './subchannel-address';
import { GrpcUri } from './uri-parser';
import { ChannelOptions } from './channel-options';
export interface ResolutionCallback {
    (serviceConfig: ServiceConfig, configSelector: ConfigSelector): void;
}
export interface ResolutionFailureCallback {
    (status: StatusObject): void;
}
export declare class ResolvingLoadBalancer implements LoadBalancer {
    private readonly target;
    private readonly channelControlHelper;
    private readonly onSuccessfulResolution;
    private readonly onFailedResolution;
    /**
     * The resolver class constructed for the target address.
     */
    private readonly innerResolver;
    private readonly childLoadBalancer;
    private latestChildState;
    private latestChildPicker;
    /**
     * This resolving load balancer's current connectivity state.
     */
    private currentState;
    private readonly defaultServiceConfig;
    /**
     * The service config object from the last successful resolution, if
     * available. A value of null indicates that we have not yet received a valid
     * service config from the resolver.
     */
    private previousServiceConfig;
    /**
     * The backoff timer for handling name resolution failures.
     */
    private readonly backoffTimeout;
    /**
     * Indicates whether we should attempt to resolve again after the backoff
     * timer runs out.
     */
    private continueResolving;
    /**
     * Wrapper class that behaves like a `LoadBalancer` and also handles name
     * resolution internally.
     * @param target The address of the backend to connect to.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     * @param defaultServiceConfig The default service configuration to be used
     *     if none is provided by the name resolver. A `null` value indicates
     *     that the default behavior should be the default unconfigured behavior.
     *     In practice, that means using the "pick first" load balancer
     *     implmentation
     */
    constructor(target: GrpcUri, channelControlHelper: ChannelControlHelper, channelOptions: ChannelOptions, onSuccessfulResolution: ResolutionCallback, onFailedResolution: ResolutionFailureCallback);
    private updateResolution;
    private updateState;
    private handleResolutionFailure;
    exitIdle(): void;
    updateAddressList(endpointList: Endpoint[], lbConfig: TypedLoadBalancingConfig | null): never;
    resetBackoff(): void;
    destroy(): void;
    getTypeName(): string;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolvingLoadBalancer = void 0;
const load_balancer_1 = require("./load-balancer");
const service_config_1 = require("./service-config");
const connectivity_state_1 = require("./connectivity-state");
const resolver_1 = require("./resolver");
const picker_1 = require("./picker");
const backoff_timeout_1 = require("./backoff-timeout");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const logging = require("./logging");
const constants_2 = require("./constants");
const uri_parser_1 = require("./uri-parser");
const load_balancer_child_handler_1 = require("./load-balancer-child-handler");
const TRACER_NAME = 'resolving_load_balancer';
function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
}
/**
 * Name match levels in order from most to least specific. This is the order in
 * which searches will be performed.
 */
const NAME_MATCH_LEVEL_ORDER = [
    'SERVICE_AND_METHOD',
    'SERVICE',
    'EMPTY',
];
function hasMatchingName(service, method, methodConfig, matchLevel) {
    for (const name of methodConfig.name) {
        switch (matchLevel) {
            case 'EMPTY':
                if (!name.service && !name.method) {
                    return true;
                }
                break;
            case 'SERVICE':
                if (name.service === service && !name.method) {
                    return true;
                }
                break;
            case 'SERVICE_AND_METHOD':
                if (name.service === service && name.method === method) {
                    return true;
                }
        }
    }
    return false;
}
function findMatchingConfig(service, method, methodConfigs, matchLevel) {
    for (const config of methodConfigs) {
        if (hasMatchingName(service, method, config, matchLevel)) {
            return config;
        }
    }
    return null;
}
function getDefaultConfigSelector(serviceConfig) {
    return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split('/').filter(x => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';
        if (serviceConfig && serviceConfig.methodConfig) {
            /* Check for the following in order, and return the first method
             * config that matches:
             * 1. A name that exactly matches the service and method
             * 2. A name with no method set that matches the service
             * 3. An empty name
             */
            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);
                if (matchingConfig) {
                    return {
                        methodConfig: matchingConfig,
                        pickInformation: {},
                        status: constants_1.Status.OK,
                        dynamicFilterFactories: [],
                    };
                }
            }
        }
        return {
            methodConfig: { name: [] },
            pickInformation: {},
            status: constants_1.Status.OK,
            dynamicFilterFactories: [],
        };
    };
}
class ResolvingLoadBalancer {
    /**
     * Wrapper class that behaves like a `LoadBalancer` and also handles name
     * resolution internally.
     * @param target The address of the backend to connect to.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     * @param defaultServiceConfig The default service configuration to be used
     *     if none is provided by the name resolver. A `null` value indicates
     *     that the default behavior should be the default unconfigured behavior.
     *     In practice, that means using the "pick first" load balancer
     *     implmentation
     */
    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        /**
         * This resolving load balancer's current connectivity state.
         */
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        /**
         * The service config object from the last successful resolution, if
         * available. A value of null indicates that we have not yet received a valid
         * service config from the resolver.
         */
        this.previousServiceConfig = null;
        /**
         * Indicates whether we should attempt to resolve again after the backoff
         * timer runs out.
         */
        this.continueResolving = false;
        if (channelOptions['grpc.service_config']) {
            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));
        }
        else {
            this.defaultServiceConfig = {
                loadBalancingConfig: [],
                methodConfig: [],
            };
        }
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
            requestReresolution: () => {
                /* If the backoffTimeout is running, we're still backing off from
                 * making resolve requests, so we shouldn't make another one here.
                 * In that case, the backoff timer callback will call
                 * updateResolution */
                if (this.backoffTimeout.isRunning()) {
                    trace('requestReresolution delayed by backoff timer until ' +
                        this.backoffTimeout.getEndTime().toISOString());
                    this.continueResolving = true;
                }
                else {
                    this.updateResolution();
                }
            },
            updateState: (newState, picker) => {
                this.latestChildState = newState;
                this.latestChildPicker = picker;
                this.updateState(newState, picker);
            },
            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),
        }, channelOptions);
        this.innerResolver = (0, resolver_1.createResolver)(target, {
            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
                var _a;
                this.backoffTimeout.stop();
                this.backoffTimeout.reset();
                let workingServiceConfig = null;
                /* This first group of conditionals implements the algorithm described
                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
                 * in the section called "Behavior on receiving a new gRPC Config".
                 */
                if (serviceConfig === null) {
                    // Step 4 and 5
                    if (serviceConfigError === null) {
                        // Step 5
                        this.previousServiceConfig = null;
                        workingServiceConfig = this.defaultServiceConfig;
                    }
                    else {
                        // Step 4
                        if (this.previousServiceConfig === null) {
                            // Step 4.ii
                            this.handleResolutionFailure(serviceConfigError);
                        }
                        else {
                            // Step 4.i
                            workingServiceConfig = this.previousServiceConfig;
                        }
                    }
                }
                else {
                    // Step 3
                    workingServiceConfig = serviceConfig;
                    this.previousServiceConfig = serviceConfig;
                }
                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
                const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
                if (loadBalancingConfig === null) {
                    // There were load balancing configs but none are supported. This counts as a resolution failure
                    this.handleResolutionFailure({
                        code: constants_1.Status.UNAVAILABLE,
                        details: 'All load balancer options in service config are not compatible',
                        metadata: new metadata_1.Metadata(),
                    });
                    return;
                }
                this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, attributes);
                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
            },
            onError: (error) => {
                this.handleResolutionFailure(error);
            },
        }, channelOptions);
        const backoffOptions = {
            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
            if (this.continueResolving) {
                this.updateResolution();
                this.continueResolving = false;
            }
            else {
                this.updateState(this.latestChildState, this.latestChildPicker);
            }
        }, backoffOptions);
        this.backoffTimeout.unref();
    }
    updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
            /* this.latestChildPicker is initialized as new QueuePicker(this), which
             * is an appropriate value here if the child LB policy is unset.
             * Otherwise, we want to delegate to the child here, in case that
             * triggers something. */
            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker);
        }
        this.backoffTimeout.runOnce();
    }
    updateState(connectivityState, picker) {
        trace((0, uri_parser_1.uriToString)(this.target) +
            ' ' +
            connectivity_state_1.ConnectivityState[this.currentState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[connectivityState]);
        // Ensure that this.exitIdle() is called by the picker
        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
            picker = new picker_1.QueuePicker(this, picker);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
    }
    handleResolutionFailure(error) {
        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
            this.onFailedResolution(error);
        }
    }
    exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||
            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            if (this.backoffTimeout.isRunning()) {
                this.continueResolving = true;
            }
            else {
                this.updateResolution();
            }
        }
        this.childLoadBalancer.exitIdle();
    }
    updateAddressList(endpointList, lbConfig) {
        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
    }
    resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
    }
    destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.backoffTimeout.reset();
        this.backoffTimeout.stop();
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
    }
    getTypeName() {
        return 'resolving_load_balancer';
    }
}
exports.ResolvingLoadBalancer = ResolvingLoadBalancer;
//# sourceMappingURL=resolving-load-balancer.js.map{"version":3,"file":"resolving-load-balancer.js","sourceRoot":"","sources":["../../src/resolving-load-balancer.ts"],"names":[],"mappings":"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"}import { CallCredentials } from './call-credentials';
import { Status } from './constants';
import { Deadline } from './deadline';
import { Metadata } from './metadata';
import { CallConfig } from './resolver';
import { Call, DeadlineInfoProvider, InterceptingListener, MessageContext } from './call-interface';
import { InternalChannel } from './internal-channel';
export declare class RetryThrottler {
    private readonly maxTokens;
    private readonly tokenRatio;
    private tokens;
    constructor(maxTokens: number, tokenRatio: number, previousRetryThrottler?: RetryThrottler);
    addCallSucceeded(): void;
    addCallFailed(): void;
    canRetryCall(): boolean;
}
export declare class MessageBufferTracker {
    private totalLimit;
    private limitPerCall;
    private totalAllocated;
    private allocatedPerCall;
    constructor(totalLimit: number, limitPerCall: number);
    allocate(size: number, callId: number): boolean;
    free(size: number, callId: number): void;
    freeAll(callId: number): void;
}
export declare class RetryingCall implements Call, DeadlineInfoProvider {
    private readonly channel;
    private readonly callConfig;
    private readonly methodName;
    private readonly host;
    private readonly credentials;
    private readonly deadline;
    private readonly callNumber;
    private readonly bufferTracker;
    private readonly retryThrottler?;
    private state;
    private listener;
    private initialMetadata;
    private underlyingCalls;
    private writeBuffer;
    /**
     * The offset of message indices in the writeBuffer. For example, if
     * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15
     * is in writeBuffer[5].
     */
    private writeBufferOffset;
    /**
     * Tracks whether a read has been started, so that we know whether to start
     * reads on new child calls. This only matters for the first read, because
     * once a message comes in the child call becomes committed and there will
     * be no new child calls.
     */
    private readStarted;
    private transparentRetryUsed;
    /**
     * Number of attempts so far
     */
    private attempts;
    private hedgingTimer;
    private committedCallIndex;
    private initialRetryBackoffSec;
    private nextRetryBackoffSec;
    private startTime;
    private maxAttempts;
    constructor(channel: InternalChannel, callConfig: CallConfig, methodName: string, host: string, credentials: CallCredentials, deadline: Deadline, callNumber: number, bufferTracker: MessageBufferTracker, retryThrottler?: RetryThrottler | undefined);
    getDeadlineInfo(): string[];
    getCallNumber(): number;
    private trace;
    private reportStatus;
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    private getBufferEntry;
    private getNextBufferIndex;
    private clearSentMessages;
    private commitCall;
    private commitCallWithMostMessages;
    private isStatusCodeInList;
    private getNextRetryBackoffMs;
    private maybeRetryCall;
    private countActiveCalls;
    private handleProcessedStatus;
    private getPushback;
    private handleChildStatus;
    private maybeStartHedgingAttempt;
    private maybeStartHedgingTimer;
    private startNewAttempt;
    start(metadata: Metadata, listener: InterceptingListener): void;
    private handleChildWriteCompleted;
    private sendNextChildMessage;
    sendMessageWithContext(context: MessageContext, message: Buffer): void;
    startRead(): void;
    halfClose(): void;
    setCredentials(newCredentials: CallCredentials): void;
    getMethod(): string;
    getHost(): string;
}
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;
const constants_1 = require("./constants");
const deadline_1 = require("./deadline");
const metadata_1 = require("./metadata");
const logging = require("./logging");
const TRACER_NAME = 'retrying_call';
class RetryThrottler {
    constructor(maxTokens, tokenRatio, previousRetryThrottler) {
        this.maxTokens = maxTokens;
        this.tokenRatio = tokenRatio;
        if (previousRetryThrottler) {
            /* When carrying over tokens from a previous config, rescale them to the
             * new max value */
            this.tokens =
                previousRetryThrottler.tokens *
                    (maxTokens / previousRetryThrottler.maxTokens);
        }
        else {
            this.tokens = maxTokens;
        }
    }
    addCallSucceeded() {
        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
    }
    addCallFailed() {
        this.tokens = Math.min(this.tokens - 1, 0);
    }
    canRetryCall() {
        return this.tokens > this.maxTokens / 2;
    }
}
exports.RetryThrottler = RetryThrottler;
class MessageBufferTracker {
    constructor(totalLimit, limitPerCall) {
        this.totalLimit = totalLimit;
        this.limitPerCall = limitPerCall;
        this.totalAllocated = 0;
        this.allocatedPerCall = new Map();
    }
    allocate(size, callId) {
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.limitPerCall - currentPerCall < size ||
            this.totalLimit - this.totalAllocated < size) {
            return false;
        }
        this.allocatedPerCall.set(callId, currentPerCall + size);
        this.totalAllocated += size;
        return true;
    }
    free(size, callId) {
        var _a;
        if (this.totalAllocated < size) {
            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= size;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (currentPerCall < size) {
            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
        }
        this.allocatedPerCall.set(callId, currentPerCall - size);
    }
    freeAll(callId) {
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.totalAllocated < currentPerCall) {
            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= currentPerCall;
        this.allocatedPerCall.delete(callId);
    }
}
exports.MessageBufferTracker = MessageBufferTracker;
const PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';
const DEFAULT_MAX_ATTEMPTS_LIMIT = 5;
class RetryingCall {
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
        var _a;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.bufferTracker = bufferTracker;
        this.retryThrottler = retryThrottler;
        this.listener = null;
        this.initialMetadata = null;
        this.underlyingCalls = [];
        this.writeBuffer = [];
        /**
         * The offset of message indices in the writeBuffer. For example, if
         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15
         * is in writeBuffer[5].
         */
        this.writeBufferOffset = 0;
        /**
         * Tracks whether a read has been started, so that we know whether to start
         * reads on new child calls. This only matters for the first read, because
         * once a message comes in the child call becomes committed and there will
         * be no new child calls.
         */
        this.readStarted = false;
        this.transparentRetryUsed = false;
        /**
         * Number of attempts so far
         */
        this.attempts = 0;
        this.hedgingTimer = null;
        this.committedCallIndex = null;
        this.initialRetryBackoffSec = 0;
        this.nextRetryBackoffSec = 0;
        const maxAttemptsLimit = (_a = channel.getOptions()['grpc-node.retry_max_attempts_limit']) !== null && _a !== void 0 ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;
        if (callConfig.methodConfig.retryPolicy) {
            this.state = 'RETRY';
            const retryPolicy = callConfig.methodConfig.retryPolicy;
            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
            this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
        }
        else if (callConfig.methodConfig.hedgingPolicy) {
            this.state = 'HEDGING';
            this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
        }
        else {
            this.state = 'TRANSPARENT_ONLY';
            this.maxAttempts = 1;
        }
        this.startTime = new Date();
    }
    getDeadlineInfo() {
        if (this.underlyingCalls.length === 0) {
            return [];
        }
        const deadlineInfo = [];
        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
        if (this.underlyingCalls.length > 1) {
            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
        }
        if (latestCall.startTime > this.startTime) {
            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
        }
        deadlineInfo.push(...latestCall.call.getDeadlineInfo());
        return deadlineInfo;
    }
    getCallNumber() {
        return this.callNumber;
    }
    trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
    }
    reportStatus(statusObject) {
        this.trace('ended with status: code=' +
            statusObject.code +
            ' details="' +
            statusObject.details +
            '" start time=' +
            this.startTime.toISOString());
        this.bufferTracker.freeAll(this.callNumber);
        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
        this.writeBuffer = [];
        process.nextTick(() => {
            var _a;
            // Explicitly construct status object to remove progress field
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({
                code: statusObject.code,
                details: statusObject.details,
                metadata: statusObject.metadata,
            });
        });
    }
    cancelWithStatus(status, details) {
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });
        for (const { call } of this.underlyingCalls) {
            call.cancelWithStatus(status, details);
        }
    }
    getPeer() {
        if (this.committedCallIndex !== null) {
            return this.underlyingCalls[this.committedCallIndex].call.getPeer();
        }
        else {
            return 'unknown';
        }
    }
    getBufferEntry(messageIndex) {
        var _a;
        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {
            entryType: 'FREED',
            allocated: false,
        });
    }
    getNextBufferIndex() {
        return this.writeBufferOffset + this.writeBuffer.length;
    }
    clearSentMessages() {
        if (this.state !== 'COMMITTED') {
            return;
        }
        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {
            const bufferEntry = this.getBufferEntry(messageIndex);
            if (bufferEntry.allocated) {
                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
            }
        }
        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
        this.writeBufferOffset = earliestNeededMessageIndex;
    }
    commitCall(index) {
        if (this.state === 'COMMITTED') {
            return;
        }
        if (this.underlyingCalls[index].state === 'COMPLETED') {
            return;
        }
        this.trace('Committing call [' +
            this.underlyingCalls[index].call.getCallNumber() +
            '] at index ' +
            index);
        this.state = 'COMMITTED';
        this.committedCallIndex = index;
        for (let i = 0; i < this.underlyingCalls.length; i++) {
            if (i === index) {
                continue;
            }
            if (this.underlyingCalls[i].state === 'COMPLETED') {
                continue;
            }
            this.underlyingCalls[i].state = 'COMPLETED';
            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');
        }
        this.clearSentMessages();
    }
    commitCallWithMostMessages() {
        if (this.state === 'COMMITTED') {
            return;
        }
        let mostMessages = -1;
        let callWithMostMessages = -1;
        for (const [index, childCall] of this.underlyingCalls.entries()) {
            if (childCall.state === 'ACTIVE' &&
                childCall.nextMessageToSend > mostMessages) {
                mostMessages = childCall.nextMessageToSend;
                callWithMostMessages = index;
            }
        }
        if (callWithMostMessages === -1) {
            /* There are no active calls, disable retries to force the next call that
             * is started to be committed. */
            this.state = 'TRANSPARENT_ONLY';
        }
        else {
            this.commitCall(callWithMostMessages);
        }
    }
    isStatusCodeInList(list, code) {
        return list.some(value => value === code ||
            value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());
    }
    getNextRetryBackoffMs() {
        var _a;
        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;
        if (!retryPolicy) {
            return 0;
        }
        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
        return nextBackoffMs;
    }
    maybeRetryCall(pushback, callback) {
        if (this.state !== 'RETRY') {
            callback(false);
            return;
        }
        if (this.attempts >= this.maxAttempts) {
            callback(false);
            return;
        }
        let retryDelayMs;
        if (pushback === null) {
            retryDelayMs = this.getNextRetryBackoffMs();
        }
        else if (pushback < 0) {
            this.state = 'TRANSPARENT_ONLY';
            callback(false);
            return;
        }
        else {
            retryDelayMs = pushback;
            this.nextRetryBackoffSec = this.initialRetryBackoffSec;
        }
        setTimeout(() => {
            var _a, _b;
            if (this.state !== 'RETRY') {
                callback(false);
                return;
            }
            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {
                callback(true);
                this.attempts += 1;
                this.startNewAttempt();
            }
        }, retryDelayMs);
    }
    countActiveCalls() {
        let count = 0;
        for (const call of this.underlyingCalls) {
            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {
                count += 1;
            }
        }
        return count;
    }
    handleProcessedStatus(status, callIndex, pushback) {
        var _a, _b, _c;
        switch (this.state) {
            case 'COMMITTED':
            case 'TRANSPARENT_ONLY':
                this.commitCall(callIndex);
                this.reportStatus(status);
                break;
            case 'HEDGING':
                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {
                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();
                    let delayMs;
                    if (pushback === null) {
                        delayMs = 0;
                    }
                    else if (pushback < 0) {
                        this.state = 'TRANSPARENT_ONLY';
                        this.commitCall(callIndex);
                        this.reportStatus(status);
                        return;
                    }
                    else {
                        delayMs = pushback;
                    }
                    setTimeout(() => {
                        this.maybeStartHedgingAttempt();
                        // If after trying to start a call there are no active calls, this was the last one
                        if (this.countActiveCalls() === 0) {
                            this.commitCall(callIndex);
                            this.reportStatus(status);
                        }
                    }, delayMs);
                }
                else {
                    this.commitCall(callIndex);
                    this.reportStatus(status);
                }
                break;
            case 'RETRY':
                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();
                    this.maybeRetryCall(pushback, retried => {
                        if (!retried) {
                            this.commitCall(callIndex);
                            this.reportStatus(status);
                        }
                    });
                }
                else {
                    this.commitCall(callIndex);
                    this.reportStatus(status);
                }
                break;
        }
    }
    getPushback(metadata) {
        const mdValue = metadata.get('grpc-retry-pushback-ms');
        if (mdValue.length === 0) {
            return null;
        }
        try {
            return parseInt(mdValue[0]);
        }
        catch (e) {
            return -1;
        }
    }
    handleChildStatus(status, callIndex) {
        var _a;
        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {
            return;
        }
        this.trace('state=' +
            this.state +
            ' handling status with progress ' +
            status.progress +
            ' from child [' +
            this.underlyingCalls[callIndex].call.getCallNumber() +
            '] in state ' +
            this.underlyingCalls[callIndex].state);
        this.underlyingCalls[callIndex].state = 'COMPLETED';
        if (status.code === constants_1.Status.OK) {
            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();
            this.commitCall(callIndex);
            this.reportStatus(status);
            return;
        }
        if (this.state === 'COMMITTED') {
            this.reportStatus(status);
            return;
        }
        const pushback = this.getPushback(status.metadata);
        switch (status.progress) {
            case 'NOT_STARTED':
                // RPC never leaves the client, always safe to retry
                this.startNewAttempt();
                break;
            case 'REFUSED':
                // RPC reaches the server library, but not the server application logic
                if (this.transparentRetryUsed) {
                    this.handleProcessedStatus(status, callIndex, pushback);
                }
                else {
                    this.transparentRetryUsed = true;
                    this.startNewAttempt();
                }
                break;
            case 'DROP':
                this.commitCall(callIndex);
                this.reportStatus(status);
                break;
            case 'PROCESSED':
                this.handleProcessedStatus(status, callIndex, pushback);
                break;
        }
    }
    maybeStartHedgingAttempt() {
        if (this.state !== 'HEDGING') {
            return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
            return;
        }
        if (this.attempts >= this.maxAttempts) {
            return;
        }
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
    }
    maybeStartHedgingTimer() {
        var _a, _b, _c;
        if (this.hedgingTimer) {
            clearTimeout(this.hedgingTimer);
        }
        if (this.state !== 'HEDGING') {
            return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
            return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= this.maxAttempts) {
            return;
        }
        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';
        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
        this.hedgingTimer = setTimeout(() => {
            this.maybeStartHedgingAttempt();
        }, hedgingDelaySec * 1000);
        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
    }
    startNewAttempt() {
        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
        this.trace('Created child call [' +
            child.getCallNumber() +
            '] for attempt ' +
            this.attempts);
        const index = this.underlyingCalls.length;
        this.underlyingCalls.push({
            state: 'ACTIVE',
            call: child,
            nextMessageToSend: 0,
            startTime: new Date()
        });
        const previousAttempts = this.attempts - 1;
        const initialMetadata = this.initialMetadata.clone();
        if (previousAttempts > 0) {
            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
        }
        let receivedMetadata = false;
        child.start(initialMetadata, {
            onReceiveMetadata: metadata => {
                this.trace('Received metadata from child [' + child.getCallNumber() + ']');
                this.commitCall(index);
                receivedMetadata = true;
                if (previousAttempts > 0) {
                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
                }
                if (this.underlyingCalls[index].state === 'ACTIVE') {
                    this.listener.onReceiveMetadata(metadata);
                }
            },
            onReceiveMessage: message => {
                this.trace('Received message from child [' + child.getCallNumber() + ']');
                this.commitCall(index);
                if (this.underlyingCalls[index].state === 'ACTIVE') {
                    this.listener.onReceiveMessage(message);
                }
            },
            onReceiveStatus: status => {
                this.trace('Received status from child [' + child.getCallNumber() + ']');
                if (!receivedMetadata && previousAttempts > 0) {
                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
                }
                this.handleChildStatus(status, index);
            },
        });
        this.sendNextChildMessage(index);
        if (this.readStarted) {
            child.startRead();
        }
    }
    start(metadata, listener) {
        this.trace('start called');
        this.listener = listener;
        this.initialMetadata = metadata;
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
    }
    handleChildWriteCompleted(childIndex) {
        var _a, _b;
        const childCall = this.underlyingCalls[childIndex];
        const messageIndex = childCall.nextMessageToSend;
        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.clearSentMessages();
        childCall.nextMessageToSend += 1;
        this.sendNextChildMessage(childIndex);
    }
    sendNextChildMessage(childIndex) {
        const childCall = this.underlyingCalls[childIndex];
        if (childCall.state === 'COMPLETED') {
            return;
        }
        if (this.getBufferEntry(childCall.nextMessageToSend)) {
            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
            switch (bufferEntry.entryType) {
                case 'MESSAGE':
                    childCall.call.sendMessageWithContext({
                        callback: error => {
                            // Ignore error
                            this.handleChildWriteCompleted(childIndex);
                        },
                    }, bufferEntry.message.message);
                    break;
                case 'HALF_CLOSE':
                    childCall.nextMessageToSend += 1;
                    childCall.call.halfClose();
                    break;
                case 'FREED':
                    // Should not be possible
                    break;
            }
        }
    }
    sendMessageWithContext(context, message) {
        var _a;
        this.trace('write() called with message of length ' + message.length);
        const writeObj = {
            message,
            flags: context.flags,
        };
        const messageIndex = this.getNextBufferIndex();
        const bufferEntry = {
            entryType: 'MESSAGE',
            message: writeObj,
            allocated: this.bufferTracker.allocate(message.length, this.callNumber),
        };
        this.writeBuffer.push(bufferEntry);
        if (bufferEntry.allocated) {
            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
            for (const [callIndex, call] of this.underlyingCalls.entries()) {
                if (call.state === 'ACTIVE' &&
                    call.nextMessageToSend === messageIndex) {
                    call.call.sendMessageWithContext({
                        callback: error => {
                            // Ignore error
                            this.handleChildWriteCompleted(callIndex);
                        },
                    }, message);
                }
            }
        }
        else {
            this.commitCallWithMostMessages();
            // commitCallWithMostMessages can fail if we are between ping attempts
            if (this.committedCallIndex === null) {
                return;
            }
            const call = this.underlyingCalls[this.committedCallIndex];
            bufferEntry.callback = context.callback;
            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {
                call.call.sendMessageWithContext({
                    callback: error => {
                        // Ignore error
                        this.handleChildWriteCompleted(this.committedCallIndex);
                    },
                }, message);
            }
        }
    }
    startRead() {
        this.trace('startRead called');
        this.readStarted = true;
        for (const underlyingCall of this.underlyingCalls) {
            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {
                underlyingCall.call.startRead();
            }
        }
    }
    halfClose() {
        this.trace('halfClose called');
        const halfCloseIndex = this.getNextBufferIndex();
        this.writeBuffer.push({
            entryType: 'HALF_CLOSE',
            allocated: false,
        });
        for (const call of this.underlyingCalls) {
            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&
                call.nextMessageToSend === halfCloseIndex) {
                call.nextMessageToSend += 1;
                call.call.halfClose();
            }
        }
    }
    setCredentials(newCredentials) {
        throw new Error('Method not implemented.');
    }
    getMethod() {
        return this.methodName;
    }
    getHost() {
        return this.host;
    }
}
exports.RetryingCall = RetryingCall;
//# sourceMappingURL=retrying-call.js.map{"version":3,"file":"retrying-call.js","sourceRoot":"","sources":["../../src/retrying-call.ts"],"names":[],"mappings":"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"}import { EventEmitter } from 'events';
import { Duplex, Readable, Writable } from 'stream';
import type { Deserialize, Serialize } from './make-client';
import { Metadata } from './metadata';
import type { ObjectReadable, ObjectWritable } from './object-stream';
import type { StatusObject, PartialStatusObject } from './call-interface';
import type { Deadline } from './deadline';
import type { ServerInterceptingCallInterface } from './server-interceptors';
export type ServerStatusResponse = Partial<StatusObject>;
export type ServerErrorResponse = ServerStatusResponse & Error;
export type ServerSurfaceCall = {
    cancelled: boolean;
    readonly metadata: Metadata;
    getPeer(): string;
    sendMetadata(responseMetadata: Metadata): void;
    getDeadline(): Deadline;
    getPath(): string;
    getHost(): string;
} & EventEmitter;
export type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {
    request: RequestType;
};
export type ServerReadableStream<RequestType, ResponseType> = ServerSurfaceCall & ObjectReadable<RequestType>;
export type ServerWritableStream<RequestType, ResponseType> = ServerSurfaceCall & ObjectWritable<ResponseType> & {
    request: RequestType;
    end: (metadata?: Metadata) => void;
};
export type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall & ObjectReadable<RequestType> & ObjectWritable<ResponseType> & {
    end: (metadata?: Metadata) => void;
};
export declare function serverErrorToStatus(error: ServerErrorResponse | ServerStatusResponse, overrideTrailers?: Metadata | undefined): PartialStatusObject;
export declare class ServerUnaryCallImpl<RequestType, ResponseType> extends EventEmitter implements ServerUnaryCall<RequestType, ResponseType> {
    private path;
    private call;
    metadata: Metadata;
    request: RequestType;
    cancelled: boolean;
    constructor(path: string, call: ServerInterceptingCallInterface, metadata: Metadata, request: RequestType);
    getPeer(): string;
    sendMetadata(responseMetadata: Metadata): void;
    getDeadline(): Deadline;
    getPath(): string;
    getHost(): string;
}
export declare class ServerReadableStreamImpl<RequestType, ResponseType> extends Readable implements ServerReadableStream<RequestType, ResponseType> {
    private path;
    private call;
    metadata: Metadata;
    cancelled: boolean;
    constructor(path: string, call: ServerInterceptingCallInterface, metadata: Metadata);
    _read(size: number): void;
    getPeer(): string;
    sendMetadata(responseMetadata: Metadata): void;
    getDeadline(): Deadline;
    getPath(): string;
    getHost(): string;
}
export declare class ServerWritableStreamImpl<RequestType, ResponseType> extends Writable implements ServerWritableStream<RequestType, ResponseType> {
    private path;
    private call;
    metadata: Metadata;
    request: RequestType;
    cancelled: boolean;
    private trailingMetadata;
    private pendingStatus;
    constructor(path: string, call: ServerInterceptingCallInterface, metadata: Metadata, request: RequestType);
    getPeer(): string;
    sendMetadata(responseMetadata: Metadata): void;
    getDeadline(): Deadline;
    getPath(): string;
    getHost(): string;
    _write(chunk: ResponseType, encoding: string, callback: (...args: any[]) => void): void;
    _final(callback: Function): void;
    end(metadata?: any): this;
}
export declare class ServerDuplexStreamImpl<RequestType, ResponseType> extends Duplex implements ServerDuplexStream<RequestType, ResponseType> {
    private path;
    private call;
    metadata: Metadata;
    cancelled: boolean;
    private trailingMetadata;
    private pendingStatus;
    constructor(path: string, call: ServerInterceptingCallInterface, metadata: Metadata);
    getPeer(): string;
    sendMetadata(responseMetadata: Metadata): void;
    getDeadline(): Deadline;
    getPath(): string;
    getHost(): string;
    _read(size: number): void;
    _write(chunk: ResponseType, encoding: string, callback: (...args: any[]) => void): void;
    _final(callback: Function): void;
    end(metadata?: any): this;
}
export type sendUnaryData<ResponseType> = (error: ServerErrorResponse | ServerStatusResponse | null, value?: ResponseType | null, trailer?: Metadata, flags?: number) => void;
export type handleUnaryCall<RequestType, ResponseType> = (call: ServerUnaryCall<RequestType, ResponseType>, callback: sendUnaryData<ResponseType>) => void;
export type handleClientStreamingCall<RequestType, ResponseType> = (call: ServerReadableStream<RequestType, ResponseType>, callback: sendUnaryData<ResponseType>) => void;
export type handleServerStreamingCall<RequestType, ResponseType> = (call: ServerWritableStream<RequestType, ResponseType>) => void;
export type handleBidiStreamingCall<RequestType, ResponseType> = (call: ServerDuplexStream<RequestType, ResponseType>) => void;
export type HandleCall<RequestType, ResponseType> = handleUnaryCall<RequestType, ResponseType> | handleClientStreamingCall<RequestType, ResponseType> | handleServerStreamingCall<RequestType, ResponseType> | handleBidiStreamingCall<RequestType, ResponseType>;
export interface UnaryHandler<RequestType, ResponseType> {
    func: handleUnaryCall<RequestType, ResponseType>;
    serialize: Serialize<ResponseType>;
    deserialize: Deserialize<RequestType>;
    type: 'unary';
    path: string;
}
export interface ClientStreamingHandler<RequestType, ResponseType> {
    func: handleClientStreamingCall<RequestType, ResponseType>;
    serialize: Serialize<ResponseType>;
    deserialize: Deserialize<RequestType>;
    type: 'clientStream';
    path: string;
}
export interface ServerStreamingHandler<RequestType, ResponseType> {
    func: handleServerStreamingCall<RequestType, ResponseType>;
    serialize: Serialize<ResponseType>;
    deserialize: Deserialize<RequestType>;
    type: 'serverStream';
    path: string;
}
export interface BidiStreamingHandler<RequestType, ResponseType> {
    func: handleBidiStreamingCall<RequestType, ResponseType>;
    serialize: Serialize<ResponseType>;
    deserialize: Deserialize<RequestType>;
    type: 'bidi';
    path: string;
}
export type Handler<RequestType, ResponseType> = UnaryHandler<RequestType, ResponseType> | ClientStreamingHandler<RequestType, ResponseType> | ServerStreamingHandler<RequestType, ResponseType> | BidiStreamingHandler<RequestType, ResponseType>;
export type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;
exports.serverErrorToStatus = serverErrorToStatus;
const events_1 = require("events");
const stream_1 = require("stream");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
function serverErrorToStatus(error, overrideTrailers) {
    var _a;
    const status = {
        code: constants_1.Status.UNKNOWN,
        details: 'message' in error ? error.message : 'Unknown Error',
        metadata: (_a = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a !== void 0 ? _a : null,
    };
    if ('code' in error &&
        typeof error.code === 'number' &&
        Number.isInteger(error.code)) {
        status.code = error.code;
        if ('details' in error && typeof error.details === 'string') {
            status.details = error.details;
        }
    }
    return status;
}
class ServerUnaryCallImpl extends events_1.EventEmitter {
    constructor(path, call, metadata, request) {
        super();
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
    getHost() {
        return this.call.getHost();
    }
}
exports.ServerUnaryCallImpl = ServerUnaryCallImpl;
class ServerReadableStreamImpl extends stream_1.Readable {
    constructor(path, call, metadata) {
        super({ objectMode: true });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.cancelled = false;
    }
    _read(size) {
        this.call.startRead();
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
    getHost() {
        return this.call.getHost();
    }
}
exports.ServerReadableStreamImpl = ServerReadableStreamImpl;
class ServerWritableStreamImpl extends stream_1.Writable {
    constructor(path, call, metadata, request) {
        super({ objectMode: true });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.pendingStatus = {
            code: constants_1.Status.OK,
            details: 'OK',
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on('error', err => {
            this.pendingStatus = serverErrorToStatus(err);
            this.end();
        });
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
    getHost() {
        return this.call.getHost();
    }
    _write(chunk, encoding, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        this.call.sendMessage(chunk, callback);
    }
    _final(callback) {
        var _a;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) {
        if (metadata) {
            this.trailingMetadata = metadata;
        }
        return super.end();
    }
}
exports.ServerWritableStreamImpl = ServerWritableStreamImpl;
class ServerDuplexStreamImpl extends stream_1.Duplex {
    constructor(path, call, metadata) {
        super({ objectMode: true });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.pendingStatus = {
            code: constants_1.Status.OK,
            details: 'OK',
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on('error', err => {
            this.pendingStatus = serverErrorToStatus(err);
            this.end();
        });
    }
    getPeer() {
        return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
        return this.call.getDeadline();
    }
    getPath() {
        return this.path;
    }
    getHost() {
        return this.call.getHost();
    }
    _read(size) {
        this.call.startRead();
    }
    _write(chunk, encoding, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        this.call.sendMessage(chunk, callback);
    }
    _final(callback) {
        var _a;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== void 0 ? _a : this.trailingMetadata }));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) {
        if (metadata) {
            this.trailingMetadata = metadata;
        }
        return super.end();
    }
}
exports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
//# sourceMappingURL=server-call.js.map{"version":3,"file":"server-call.js","sourceRoot":"","sources":["../../src/server-call.ts"],"names":[],"mappings":"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"}import { SecureServerOptions } from 'http2';
import { SecureContextOptions } from 'tls';
import { ServerInterceptor } from '.';
export interface KeyCertPair {
    private_key: Buffer;
    cert_chain: Buffer;
}
export interface SecureContextWatcher {
    (context: SecureContextOptions | null): void;
}
export declare abstract class ServerCredentials {
    private watchers;
    private latestContextOptions;
    _addWatcher(watcher: SecureContextWatcher): void;
    _removeWatcher(watcher: SecureContextWatcher): void;
    protected updateSecureContextOptions(options: SecureServerOptions | null): void;
    abstract _isSecure(): boolean;
    _getSettings(): SecureServerOptions | null;
    _getInterceptors(): ServerInterceptor[];
    abstract _equals(other: ServerCredentials): boolean;
    static createInsecure(): ServerCredentials;
    static createSsl(rootCerts: Buffer | null, keyCertPairs: KeyCertPair[], checkClientCertificate?: boolean): ServerCredentials;
}
export declare function createServerCredentialsWithInterceptors(credentials: ServerCredentials, interceptors: ServerInterceptor[]): ServerCredentials;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerCredentials = void 0;
exports.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;
const tls_helpers_1 = require("./tls-helpers");
class ServerCredentials {
    constructor() {
        this.watchers = new Set();
        this.latestContextOptions = null;
    }
    _addWatcher(watcher) {
        this.watchers.add(watcher);
    }
    _removeWatcher(watcher) {
        this.watchers.delete(watcher);
    }
    updateSecureContextOptions(options) {
        if (options) {
            this.latestContextOptions = options;
        }
        else {
            this.latestContextOptions = null;
        }
        for (const watcher of this.watchers) {
            watcher(this.latestContextOptions);
        }
    }
    _getSettings() {
        return this.latestContextOptions;
    }
    _getInterceptors() {
        return [];
    }
    static createInsecure() {
        return new InsecureServerCredentials();
    }
    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        var _a;
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
            throw new TypeError('rootCerts must be null or a Buffer');
        }
        if (!Array.isArray(keyCertPairs)) {
            throw new TypeError('keyCertPairs must be an array');
        }
        if (typeof checkClientCertificate !== 'boolean') {
            throw new TypeError('checkClientCertificate must be a boolean');
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
            const pair = keyCertPairs[i];
            if (pair === null || typeof pair !== 'object') {
                throw new TypeError(`keyCertPair[${i}] must be an object`);
            }
            if (!Buffer.isBuffer(pair.private_key)) {
                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
            }
            if (!Buffer.isBuffer(pair.cert_chain)) {
                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
            }
            cert.push(pair.cert_chain);
            key.push(pair.private_key);
        }
        return new SecureServerCredentials({
            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,
            cert,
            key,
            requestCert: checkClientCertificate,
            ciphers: tls_helpers_1.CIPHER_SUITES,
        });
    }
}
exports.ServerCredentials = ServerCredentials;
class InsecureServerCredentials extends ServerCredentials {
    _isSecure() {
        return false;
    }
    _getSettings() {
        return null;
    }
    _equals(other) {
        return other instanceof InsecureServerCredentials;
    }
}
class SecureServerCredentials extends ServerCredentials {
    constructor(options) {
        super();
        this.options = options;
    }
    _isSecure() {
        return true;
    }
    _getSettings() {
        return this.options;
    }
    /**
     * Checks equality by checking the options that are actually set by
     * createSsl.
     * @param other
     * @returns
     */
    _equals(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof SecureServerCredentials)) {
            return false;
        }
        // options.ca equality check
        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
            if (!this.options.ca.equals(other.options.ca)) {
                return false;
            }
        }
        else {
            if (this.options.ca !== other.options.ca) {
                return false;
            }
        }
        // options.cert equality check
        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
            if (this.options.cert.length !== other.options.cert.length) {
                return false;
            }
            for (let i = 0; i < this.options.cert.length; i++) {
                const thisCert = this.options.cert[i];
                const otherCert = other.options.cert[i];
                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
                    if (!thisCert.equals(otherCert)) {
                        return false;
                    }
                }
                else {
                    if (thisCert !== otherCert) {
                        return false;
                    }
                }
            }
        }
        else {
            if (this.options.cert !== other.options.cert) {
                return false;
            }
        }
        // options.key equality check
        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
            if (this.options.key.length !== other.options.key.length) {
                return false;
            }
            for (let i = 0; i < this.options.key.length; i++) {
                const thisKey = this.options.key[i];
                const otherKey = other.options.key[i];
                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
                    if (!thisKey.equals(otherKey)) {
                        return false;
                    }
                }
                else {
                    if (thisKey !== otherKey) {
                        return false;
                    }
                }
            }
        }
        else {
            if (this.options.key !== other.options.key) {
                return false;
            }
        }
        // options.requestCert equality check
        if (this.options.requestCert !== other.options.requestCert) {
            return false;
        }
        /* ciphers is derived from a value that is constant for the process, so no
         * equality check is needed. */
        return true;
    }
}
class InterceptorServerCredentials extends ServerCredentials {
    constructor(childCredentials, interceptors) {
        super();
        this.childCredentials = childCredentials;
        this.interceptors = interceptors;
    }
    _isSecure() {
        return this.childCredentials._isSecure();
    }
    _equals(other) {
        if (!(other instanceof InterceptorServerCredentials)) {
            return false;
        }
        if (!(this.childCredentials._equals(other.childCredentials))) {
            return false;
        }
        if (this.interceptors.length !== other.interceptors.length) {
            return false;
        }
        for (let i = 0; i < this.interceptors.length; i++) {
            if (this.interceptors[i] !== other.interceptors[i]) {
                return false;
            }
        }
        return true;
    }
    _getInterceptors() {
        return this.interceptors;
    }
    _addWatcher(watcher) {
        this.childCredentials._addWatcher(watcher);
    }
    _removeWatcher(watcher) {
        this.childCredentials._removeWatcher(watcher);
    }
}
function createServerCredentialsWithInterceptors(credentials, interceptors) {
    return new InterceptorServerCredentials(credentials, interceptors);
}
//# sourceMappingURL=server-credentials.js.map{"version":3,"file":"server-credentials.js","sourceRoot":"","sources":["../../src/server-credentials.ts"],"names":[],"mappings":"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"}import { PartialStatusObject } from './call-interface';
import { ServerMethodDefinition } from './make-client';
import { Metadata } from './metadata';
import { ChannelOptions } from './channel-options';
import { Handler } from './server-call';
import { Deadline } from './deadline';
import * as http2 from 'http2';
import { CallEventTracker } from './transport';
export interface ServerMetadataListener {
    (metadata: Metadata, next: (metadata: Metadata) => void): void;
}
export interface ServerMessageListener {
    (message: any, next: (message: any) => void): void;
}
export interface ServerHalfCloseListener {
    (next: () => void): void;
}
export interface ServerCancelListener {
    (): void;
}
export interface FullServerListener {
    onReceiveMetadata: ServerMetadataListener;
    onReceiveMessage: ServerMessageListener;
    onReceiveHalfClose: ServerHalfCloseListener;
    onCancel: ServerCancelListener;
}
export type ServerListener = Partial<FullServerListener>;
export declare class ServerListenerBuilder {
    private metadata;
    private message;
    private halfClose;
    private cancel;
    withOnReceiveMetadata(onReceiveMetadata: ServerMetadataListener): this;
    withOnReceiveMessage(onReceiveMessage: ServerMessageListener): this;
    withOnReceiveHalfClose(onReceiveHalfClose: ServerHalfCloseListener): this;
    withOnCancel(onCancel: ServerCancelListener): this;
    build(): ServerListener;
}
export interface InterceptingServerListener {
    onReceiveMetadata(metadata: Metadata): void;
    onReceiveMessage(message: any): void;
    onReceiveHalfClose(): void;
    onCancel(): void;
}
export declare function isInterceptingServerListener(listener: ServerListener | InterceptingServerListener): listener is InterceptingServerListener;
export interface StartResponder {
    (next: (listener?: ServerListener) => void): void;
}
export interface MetadataResponder {
    (metadata: Metadata, next: (metadata: Metadata) => void): void;
}
export interface MessageResponder {
    (message: any, next: (message: any) => void): void;
}
export interface StatusResponder {
    (status: PartialStatusObject, next: (status: PartialStatusObject) => void): void;
}
export interface FullResponder {
    start: StartResponder;
    sendMetadata: MetadataResponder;
    sendMessage: MessageResponder;
    sendStatus: StatusResponder;
}
export type Responder = Partial<FullResponder>;
export declare class ResponderBuilder {
    private start;
    private metadata;
    private message;
    private status;
    withStart(start: StartResponder): this;
    withSendMetadata(sendMetadata: MetadataResponder): this;
    withSendMessage(sendMessage: MessageResponder): this;
    withSendStatus(sendStatus: StatusResponder): this;
    build(): Responder;
}
export interface ServerInterceptingCallInterface {
    /**
     * Register the listener to handle inbound events.
     */
    start(listener: InterceptingServerListener): void;
    /**
     * Send response metadata.
     */
    sendMetadata(metadata: Metadata): void;
    /**
     * Send a response message.
     */
    sendMessage(message: any, callback: () => void): void;
    /**
     * End the call by sending this status.
     */
    sendStatus(status: PartialStatusObject): void;
    /**
     * Start a single read, eventually triggering either listener.onReceiveMessage or listener.onReceiveHalfClose.
     */
    startRead(): void;
    /**
     * Return the peer address of the client making the request, if known, or "unknown" otherwise
     */
    getPeer(): string;
    /**
     * Return the call deadline set by the client. The value is Infinity if there is no deadline.
     */
    getDeadline(): Deadline;
    /**
     * Return the host requested by the client in the ":authority" header.
     */
    getHost(): string;
}
export declare class ServerInterceptingCall implements ServerInterceptingCallInterface {
    private nextCall;
    private responder;
    private processingMetadata;
    private processingMessage;
    private pendingMessage;
    private pendingMessageCallback;
    private pendingStatus;
    constructor(nextCall: ServerInterceptingCallInterface, responder?: Responder);
    private processPendingMessage;
    private processPendingStatus;
    start(listener: InterceptingServerListener): void;
    sendMetadata(metadata: Metadata): void;
    sendMessage(message: any, callback: () => void): void;
    sendStatus(status: PartialStatusObject): void;
    startRead(): void;
    getPeer(): string;
    getDeadline(): Deadline;
    getHost(): string;
}
export interface ServerInterceptor {
    (methodDescriptor: ServerMethodDefinition<any, any>, call: ServerInterceptingCallInterface): ServerInterceptingCall;
}
export declare class BaseServerInterceptingCall implements ServerInterceptingCallInterface {
    private readonly stream;
    private readonly callEventTracker;
    private readonly handler;
    private listener;
    private metadata;
    private deadlineTimer;
    private deadline;
    private maxSendMessageSize;
    private maxReceiveMessageSize;
    private cancelled;
    private metadataSent;
    private wantTrailers;
    private cancelNotified;
    private incomingEncoding;
    private decoder;
    private readQueue;
    private isReadPending;
    private receivedHalfClose;
    private streamEnded;
    private host;
    constructor(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders, callEventTracker: CallEventTracker | null, handler: Handler<any, any>, options: ChannelOptions);
    private handleTimeoutHeader;
    private checkCancelled;
    private notifyOnCancel;
    /**
     * A server handler can start sending messages without explicitly sending
     * metadata. In that case, we need to send headers before sending any
     * messages. This function does that if necessary.
     */
    private maybeSendMetadata;
    /**
     * Serialize a message to a length-delimited byte string.
     * @param value
     * @returns
     */
    private serializeMessage;
    private decompressMessage;
    private decompressAndMaybePush;
    private maybePushNextMessage;
    private handleDataFrame;
    private handleEndEvent;
    start(listener: InterceptingServerListener): void;
    sendMetadata(metadata: Metadata): void;
    sendMessage(message: any, callback: () => void): void;
    sendStatus(status: PartialStatusObject): void;
    startRead(): void;
    getPeer(): string;
    getDeadline(): Deadline;
    getHost(): string;
}
export declare function getServerInterceptingCall(interceptors: ServerInterceptor[], stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders, callEventTracker: CallEventTracker | null, handler: Handler<any, any>, options: ChannelOptions): ServerInterceptingCallInterface;
"use strict";
/*
 * Copyright 2024 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = void 0;
exports.isInterceptingServerListener = isInterceptingServerListener;
exports.getServerInterceptingCall = getServerInterceptingCall;
const metadata_1 = require("./metadata");
const constants_1 = require("./constants");
const http2 = require("http2");
const error_1 = require("./error");
const zlib = require("zlib");
const stream_decoder_1 = require("./stream-decoder");
const logging = require("./logging");
const TRACER_NAME = 'server_call';
function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
class ServerListenerBuilder {
    constructor() {
        this.metadata = undefined;
        this.message = undefined;
        this.halfClose = undefined;
        this.cancel = undefined;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
    }
    withOnReceiveHalfClose(onReceiveHalfClose) {
        this.halfClose = onReceiveHalfClose;
        return this;
    }
    withOnCancel(onCancel) {
        this.cancel = onCancel;
        return this;
    }
    build() {
        return {
            onReceiveMetadata: this.metadata,
            onReceiveMessage: this.message,
            onReceiveHalfClose: this.halfClose,
            onCancel: this.cancel,
        };
    }
}
exports.ServerListenerBuilder = ServerListenerBuilder;
function isInterceptingServerListener(listener) {
    return (listener.onReceiveMetadata !== undefined &&
        listener.onReceiveMetadata.length === 1);
}
class InterceptingServerListenerImpl {
    constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        /**
         * Once the call is cancelled, ignore all other events.
         */
        this.cancelled = false;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.pendingMessage = null;
        this.processingMessage = false;
        this.hasPendingHalfClose = false;
    }
    processPendingMessage() {
        if (this.hasPendingMessage) {
            this.nextListener.onReceiveMessage(this.pendingMessage);
            this.pendingMessage = null;
            this.hasPendingMessage = false;
        }
    }
    processPendingHalfClose() {
        if (this.hasPendingHalfClose) {
            this.nextListener.onReceiveHalfClose();
            this.hasPendingHalfClose = false;
        }
    }
    onReceiveMetadata(metadata) {
        if (this.cancelled) {
            return;
        }
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, interceptedMetadata => {
            this.processingMetadata = false;
            if (this.cancelled) {
                return;
            }
            this.nextListener.onReceiveMetadata(interceptedMetadata);
            this.processPendingMessage();
            this.processPendingHalfClose();
        });
    }
    onReceiveMessage(message) {
        if (this.cancelled) {
            return;
        }
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, msg => {
            this.processingMessage = false;
            if (this.cancelled) {
                return;
            }
            if (this.processingMetadata) {
                this.pendingMessage = msg;
                this.hasPendingMessage = true;
            }
            else {
                this.nextListener.onReceiveMessage(msg);
                this.processPendingHalfClose();
            }
        });
    }
    onReceiveHalfClose() {
        if (this.cancelled) {
            return;
        }
        this.listener.onReceiveHalfClose(() => {
            if (this.cancelled) {
                return;
            }
            if (this.processingMetadata || this.processingMessage) {
                this.hasPendingHalfClose = true;
            }
            else {
                this.nextListener.onReceiveHalfClose();
            }
        });
    }
    onCancel() {
        this.cancelled = true;
        this.listener.onCancel();
        this.nextListener.onCancel();
    }
}
class ResponderBuilder {
    constructor() {
        this.start = undefined;
        this.metadata = undefined;
        this.message = undefined;
        this.status = undefined;
    }
    withStart(start) {
        this.start = start;
        return this;
    }
    withSendMetadata(sendMetadata) {
        this.metadata = sendMetadata;
        return this;
    }
    withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
    }
    withSendStatus(sendStatus) {
        this.status = sendStatus;
        return this;
    }
    build() {
        return {
            start: this.start,
            sendMetadata: this.metadata,
            sendMessage: this.message,
            sendStatus: this.status,
        };
    }
}
exports.ResponderBuilder = ResponderBuilder;
const defaultServerListener = {
    onReceiveMetadata: (metadata, next) => {
        next(metadata);
    },
    onReceiveMessage: (message, next) => {
        next(message);
    },
    onReceiveHalfClose: next => {
        next();
    },
    onCancel: () => { },
};
const defaultResponder = {
    start: next => {
        next();
    },
    sendMetadata: (metadata, next) => {
        next(metadata);
    },
    sendMessage: (message, next) => {
        next(message);
    },
    sendStatus: (status, next) => {
        next(status);
    },
};
class ServerInterceptingCall {
    constructor(nextCall, responder) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.processingMessage = false;
        this.pendingMessage = null;
        this.pendingMessageCallback = null;
        this.pendingStatus = null;
        this.responder = {
            start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a !== void 0 ? _a : defaultResponder.start,
            sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b !== void 0 ? _b : defaultResponder.sendMetadata,
            sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c !== void 0 ? _c : defaultResponder.sendMessage,
            sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus,
        };
    }
    processPendingMessage() {
        if (this.pendingMessageCallback) {
            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
            this.pendingMessage = null;
            this.pendingMessageCallback = null;
        }
    }
    processPendingStatus() {
        if (this.pendingStatus) {
            this.nextCall.sendStatus(this.pendingStatus);
            this.pendingStatus = null;
        }
    }
    start(listener) {
        this.responder.start(interceptedListener => {
            var _a, _b, _c, _d;
            const fullInterceptedListener = {
                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,
                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,
                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,
                onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel,
            };
            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
            this.nextCall.start(finalInterceptingListener);
        });
    }
    sendMetadata(metadata) {
        this.processingMetadata = true;
        this.responder.sendMetadata(metadata, interceptedMetadata => {
            this.processingMetadata = false;
            this.nextCall.sendMetadata(interceptedMetadata);
            this.processPendingMessage();
            this.processPendingStatus();
        });
    }
    sendMessage(message, callback) {
        this.processingMessage = true;
        this.responder.sendMessage(message, interceptedMessage => {
            this.processingMessage = false;
            if (this.processingMetadata) {
                this.pendingMessage = interceptedMessage;
                this.pendingMessageCallback = callback;
            }
            else {
                this.nextCall.sendMessage(interceptedMessage, callback);
            }
        });
    }
    sendStatus(status) {
        this.responder.sendStatus(status, interceptedStatus => {
            if (this.processingMetadata || this.processingMessage) {
                this.pendingStatus = interceptedStatus;
            }
            else {
                this.nextCall.sendStatus(interceptedStatus);
            }
        });
    }
    startRead() {
        this.nextCall.startRead();
    }
    getPeer() {
        return this.nextCall.getPeer();
    }
    getDeadline() {
        return this.nextCall.getDeadline();
    }
    getHost() {
        return this.nextCall.getHost();
    }
}
exports.ServerInterceptingCall = ServerInterceptingCall;
const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
const GRPC_ENCODING_HEADER = 'grpc-encoding';
const GRPC_MESSAGE_HEADER = 'grpc-message';
const GRPC_STATUS_HEADER = 'grpc-status';
const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
const DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
const deadlineUnitsToMs = {
    H: 3600000,
    M: 60000,
    S: 1000,
    m: 1,
    u: 0.001,
    n: 0.000001,
};
const defaultCompressionHeaders = {
    // TODO(cjihrig): Remove these encoding headers from the default response
    // once compression is integrated.
    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
    [GRPC_ENCODING_HEADER]: 'identity',
};
const defaultResponseHeaders = {
    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
};
const defaultResponseOptions = {
    waitForTrailers: true,
};
class BaseServerInterceptingCall {
    constructor(stream, headers, callEventTracker, handler, options) {
        var _a;
        this.stream = stream;
        this.callEventTracker = callEventTracker;
        this.handler = handler;
        this.listener = null;
        this.deadlineTimer = null;
        this.deadline = Infinity;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.cancelled = false;
        this.metadataSent = false;
        this.wantTrailers = false;
        this.cancelNotified = false;
        this.incomingEncoding = 'identity';
        this.readQueue = [];
        this.isReadPending = false;
        this.receivedHalfClose = false;
        this.streamEnded = false;
        this.stream.once('error', (err) => {
            /* We need an error handler to avoid uncaught error event exceptions, but
             * there is nothing we can reasonably do here. Any error event should
             * have a corresponding close event, which handles emitting the cancelled
             * event. And the stream is now in a bad state, so we can't reasonably
             * expect to be able to send an error over it. */
        });
        this.stream.once('close', () => {
            var _a;
            trace('Request to method ' +
                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
                ' stream closed with rstCode ' +
                this.stream.rstCode);
            if (this.callEventTracker && !this.streamEnded) {
                this.streamEnded = true;
                this.callEventTracker.onStreamEnd(false);
                this.callEventTracker.onCallEnd({
                    code: constants_1.Status.CANCELLED,
                    details: 'Stream closed before sending status',
                    metadata: null,
                });
            }
            this.notifyOnCancel();
        });
        this.stream.on('data', (data) => {
            this.handleDataFrame(data);
        });
        this.stream.pause();
        this.stream.on('end', () => {
            this.handleEndEvent();
        });
        if ('grpc.max_send_message_length' in options) {
            this.maxSendMessageSize = options['grpc.max_send_message_length'];
        }
        if ('grpc.max_receive_message_length' in options) {
            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
        }
        this.host = (_a = headers[':authority']) !== null && _a !== void 0 ? _a : headers.host;
        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        if (logging.isTracerEnabled(TRACER_NAME)) {
            trace('Request to ' +
                this.handler.path +
                ' received headers ' +
                JSON.stringify(metadata.toJSON()));
        }
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
            this.handleTimeoutHeader(timeoutHeader[0]);
        }
        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
        if (encodingHeader.length > 0) {
            this.incomingEncoding = encodingHeader[0];
        }
        // Remove several headers that should not be propagated to the application
        metadata.remove(GRPC_TIMEOUT_HEADER);
        metadata.remove(GRPC_ENCODING_HEADER);
        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        this.metadata = metadata;
    }
    handleTimeoutHeader(timeoutHeader) {
        const match = timeoutHeader.toString().match(DEADLINE_REGEX);
        if (match === null) {
            const status = {
                code: constants_1.Status.INTERNAL,
                details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
                metadata: null,
            };
            // Wait for the constructor to complete before sending the error.
            process.nextTick(() => {
                this.sendStatus(status);
            });
            return;
        }
        const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;
        const now = new Date();
        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
        this.deadlineTimer = setTimeout(() => {
            const status = {
                code: constants_1.Status.DEADLINE_EXCEEDED,
                details: 'Deadline exceeded',
                metadata: null,
            };
            this.sendStatus(status);
        }, timeout);
    }
    checkCancelled() {
        /* In some cases the stream can become destroyed before the close event
         * fires. That creates a race condition that this check works around */
        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
            this.notifyOnCancel();
            this.cancelled = true;
        }
        return this.cancelled;
    }
    notifyOnCancel() {
        if (this.cancelNotified) {
            return;
        }
        this.cancelNotified = true;
        this.cancelled = true;
        process.nextTick(() => {
            var _a;
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onCancel();
        });
        if (this.deadlineTimer) {
            clearTimeout(this.deadlineTimer);
        }
        // Flush incoming data frames
        this.stream.resume();
    }
    /**
     * A server handler can start sending messages without explicitly sending
     * metadata. In that case, we need to send headers before sending any
     * messages. This function does that if necessary.
     */
    maybeSendMetadata() {
        if (!this.metadataSent) {
            this.sendMetadata(new metadata_1.Metadata());
        }
    }
    /**
     * Serialize a message to a length-delimited byte string.
     * @param value
     * @returns
     */
    serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        /* Note: response compression is currently not supported, so this
         * compressed bit is always 0. */
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
    }
    decompressMessage(message, encoding) {
        const messageContents = message.subarray(5);
        if (encoding === 'identity') {
            return messageContents;
        }
        else if (encoding === 'deflate' || encoding === 'gzip') {
            let decompresser;
            if (encoding === 'deflate') {
                decompresser = zlib.createInflate();
            }
            else {
                decompresser = zlib.createGunzip();
            }
            return new Promise((resolve, reject) => {
                let totalLength = 0;
                const messageParts = [];
                decompresser.on('data', (chunk) => {
                    messageParts.push(chunk);
                    totalLength += chunk.byteLength;
                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {
                        decompresser.destroy();
                        reject({
                            code: constants_1.Status.RESOURCE_EXHAUSTED,
                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
                        });
                    }
                });
                decompresser.on('end', () => {
                    resolve(Buffer.concat(messageParts));
                });
                decompresser.write(messageContents);
                decompresser.end();
            });
        }
        else {
            return Promise.reject({
                code: constants_1.Status.UNIMPLEMENTED,
                details: `Received message compressed with unsupported encoding "${encoding}"`,
            });
        }
    }
    async decompressAndMaybePush(queueEntry) {
        if (queueEntry.type !== 'COMPRESSED') {
            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
        }
        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
        const compressedMessageEncoding = compressed
            ? this.incomingEncoding
            : 'identity';
        let decompressedMessage;
        try {
            decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
        }
        catch (err) {
            this.sendStatus(err);
            return;
        }
        try {
            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
        }
        catch (err) {
            this.sendStatus({
                code: constants_1.Status.INTERNAL,
                details: `Error deserializing request: ${err.message}`,
            });
            return;
        }
        queueEntry.type = 'READABLE';
        this.maybePushNextMessage();
    }
    maybePushNextMessage() {
        if (this.listener &&
            this.isReadPending &&
            this.readQueue.length > 0 &&
            this.readQueue[0].type !== 'COMPRESSED') {
            this.isReadPending = false;
            const nextQueueEntry = this.readQueue.shift();
            if (nextQueueEntry.type === 'READABLE') {
                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
            }
            else {
                // nextQueueEntry.type === 'HALF_CLOSE'
                this.listener.onReceiveHalfClose();
            }
        }
    }
    handleDataFrame(data) {
        var _a;
        if (this.checkCancelled()) {
            return;
        }
        trace('Request to ' +
            this.handler.path +
            ' received data frame of size ' +
            data.length);
        let rawMessages;
        try {
            rawMessages = this.decoder.write(data);
        }
        catch (e) {
            this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e.message });
            return;
        }
        for (const messageBytes of rawMessages) {
            this.stream.pause();
            const queueEntry = {
                type: 'COMPRESSED',
                compressedMessage: messageBytes,
                parsedMessage: null,
            };
            this.readQueue.push(queueEntry);
            this.decompressAndMaybePush(queueEntry);
            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageReceived();
        }
    }
    handleEndEvent() {
        this.readQueue.push({
            type: 'HALF_CLOSE',
            compressedMessage: null,
            parsedMessage: null,
        });
        this.receivedHalfClose = true;
        this.maybePushNextMessage();
    }
    start(listener) {
        trace('Request to ' + this.handler.path + ' start called');
        if (this.checkCancelled()) {
            return;
        }
        this.listener = listener;
        listener.onReceiveMetadata(this.metadata);
    }
    sendMetadata(metadata) {
        if (this.checkCancelled()) {
            return;
        }
        if (this.metadataSent) {
            return;
        }
        this.metadataSent = true;
        const custom = metadata ? metadata.toHttp2Headers() : null;
        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
        this.stream.respond(headers, defaultResponseOptions);
    }
    sendMessage(message, callback) {
        if (this.checkCancelled()) {
            return;
        }
        let response;
        try {
            response = this.serializeMessage(message);
        }
        catch (e) {
            this.sendStatus({
                code: constants_1.Status.INTERNAL,
                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,
                metadata: null,
            });
            return;
        }
        if (this.maxSendMessageSize !== -1 &&
            response.length - 5 > this.maxSendMessageSize) {
            this.sendStatus({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
                metadata: null,
            });
            return;
        }
        this.maybeSendMetadata();
        trace('Request to ' +
            this.handler.path +
            ' sent data frame of size ' +
            response.length);
        this.stream.write(response, error => {
            var _a;
            if (error) {
                this.sendStatus({
                    code: constants_1.Status.INTERNAL,
                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
                    metadata: null,
                });
                return;
            }
            (_a = this.callEventTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();
            callback();
        });
    }
    sendStatus(status) {
        var _a, _b;
        if (this.checkCancelled()) {
            return;
        }
        trace('Request to method ' +
            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
            ' ended with status code: ' +
            constants_1.Status[status.code] +
            ' details: ' +
            status.details);
        if (this.metadataSent) {
            if (!this.wantTrailers) {
                this.wantTrailers = true;
                this.stream.once('wantTrailers', () => {
                    var _a;
                    if (this.callEventTracker && !this.streamEnded) {
                        this.streamEnded = true;
                        this.callEventTracker.onStreamEnd(true);
                        this.callEventTracker.onCallEnd(status);
                    }
                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a = status.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());
                    this.stream.sendTrailers(trailersToSend);
                    this.notifyOnCancel();
                });
                this.stream.end();
            }
            else {
                this.notifyOnCancel();
            }
        }
        else {
            if (this.callEventTracker && !this.streamEnded) {
                this.streamEnded = true;
                this.callEventTracker.onStreamEnd(true);
                this.callEventTracker.onCallEnd(status);
            }
            // Trailers-only response
            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b = status.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());
            this.stream.respond(trailersToSend, { endStream: true });
            this.notifyOnCancel();
        }
    }
    startRead() {
        trace('Request to ' + this.handler.path + ' startRead called');
        if (this.checkCancelled()) {
            return;
        }
        this.isReadPending = true;
        if (this.readQueue.length === 0) {
            if (!this.receivedHalfClose) {
                this.stream.resume();
            }
        }
        else {
            this.maybePushNextMessage();
        }
    }
    getPeer() {
        var _a;
        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;
        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {
            if (socket.remotePort) {
                return `${socket.remoteAddress}:${socket.remotePort}`;
            }
            else {
                return socket.remoteAddress;
            }
        }
        else {
            return 'unknown';
        }
    }
    getDeadline() {
        return this.deadline;
    }
    getHost() {
        return this.host;
    }
}
exports.BaseServerInterceptingCall = BaseServerInterceptingCall;
function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
    const methodDefinition = {
        path: handler.path,
        requestStream: handler.type === 'clientStream' || handler.type === 'bidi',
        responseStream: handler.type === 'serverStream' || handler.type === 'bidi',
        requestDeserialize: handler.deserialize,
        responseSerialize: handler.serialize,
    };
    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
    return interceptors.reduce((call, interceptor) => {
        return interceptor(methodDefinition, call);
    }, baseCall);
}
//# sourceMappingURL=server-interceptors.js.map{"version":3,"file":"server-interceptors.js","sourceRoot":"","sources":["../../src/server-interceptors.ts"],"names":[],"mappings":"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"}import { Deserialize, Serialize, ServiceDefinition } from './make-client';
import { HandleCall } from './server-call';
import { ServerCredentials } from './server-credentials';
import { ChannelOptions } from './channel-options';
import { ServerRef } from './channelz';
import { ServerInterceptor } from './server-interceptors';
import { Duplex } from 'stream';
export type UntypedHandleCall = HandleCall<any, any>;
export interface UntypedServiceImplementation {
    [name: string]: UntypedHandleCall;
}
export interface ServerOptions extends ChannelOptions {
    interceptors?: ServerInterceptor[];
}
export interface ConnectionInjector {
    injectConnection(connection: Duplex): void;
    drain(graceTimeMs: number): void;
    destroy(): void;
}
export declare class Server {
    private boundPorts;
    private http2Servers;
    private sessionIdleTimeouts;
    private handlers;
    private sessions;
    /**
     * This field only exists to ensure that the start method throws an error if
     * it is called twice, as it did previously.
     */
    private started;
    private shutdown;
    private options;
    private serverAddressString;
    private readonly channelzEnabled;
    private channelzRef;
    private channelzTrace;
    private callTracker;
    private listenerChildrenTracker;
    private sessionChildrenTracker;
    private readonly maxConnectionAgeMs;
    private readonly maxConnectionAgeGraceMs;
    private readonly keepaliveTimeMs;
    private readonly keepaliveTimeoutMs;
    private readonly sessionIdleTimeout;
    private readonly interceptors;
    /**
     * Options that will be used to construct all Http2Server instances for this
     * Server.
     */
    private commonServerOptions;
    constructor(options?: ServerOptions);
    private getChannelzInfo;
    private getChannelzSessionInfo;
    private trace;
    private keepaliveTrace;
    addProtoService(): never;
    addService(service: ServiceDefinition, implementation: UntypedServiceImplementation): void;
    removeService(service: ServiceDefinition): void;
    bind(port: string, creds: ServerCredentials): never;
    private registerListenerToChannelz;
    private createHttp2Server;
    private bindOneAddress;
    private bindManyPorts;
    private bindAddressList;
    private resolvePort;
    private bindPort;
    private normalizePort;
    bindAsync(port: string, creds: ServerCredentials, callback: (error: Error | null, port: number) => void): void;
    private registerInjectorToChannelz;
    createConnectionInjector(credentials: ServerCredentials): ConnectionInjector;
    private closeServer;
    private closeSession;
    private completeUnbind;
    /**
     * Unbind a previously bound port, or cancel an in-progress bindAsync
     * operation. If port 0 was bound, only the actual bound port can be
     * unbound. For example, if bindAsync was called with "localhost:0" and the
     * bound port result was 54321, it can be unbound as "localhost:54321".
     * @param port
     */
    unbind(port: string): void;
    /**
     * Gracefully close all connections associated with a previously bound port.
     * After the grace time, forcefully close all remaining open connections.
     *
     * If port 0 was bound, only the actual bound port can be
     * drained. For example, if bindAsync was called with "localhost:0" and the
     * bound port result was 54321, it can be drained as "localhost:54321".
     * @param port
     * @param graceTimeMs
     * @returns
     */
    drain(port: string, graceTimeMs: number): void;
    forceShutdown(): void;
    register<RequestType, ResponseType>(name: string, handler: HandleCall<RequestType, ResponseType>, serialize: Serialize<ResponseType>, deserialize: Deserialize<RequestType>, type: string): boolean;
    unregister(name: string): boolean;
    /**
     * @deprecated No longer needed as of version 1.10.x
     */
    start(): void;
    tryShutdown(callback: (error?: Error) => void): void;
    addHttp2Port(): never;
    /**
     * Get the channelz reference object for this server. The returned value is
     * garbage if channelz is disabled for this server.
     * @returns
     */
    getChannelzRef(): ServerRef;
    private _verifyContentType;
    private _retrieveHandler;
    private _respondWithError;
    private _channelzHandler;
    private _streamHandler;
    private _runHandlerForCall;
    private _setupHandlers;
    private _sessionHandler;
    private _channelzSessionHandler;
    private enableIdleTimeout;
    private onIdleTimeout;
    private onStreamOpened;
    private onStreamClose;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const http2 = require("http2");
const util = require("util");
const constants_1 = require("./constants");
const server_call_1 = require("./server-call");
const server_credentials_1 = require("./server-credentials");
const resolver_1 = require("./resolver");
const logging = require("./logging");
const subchannel_address_1 = require("./subchannel-address");
const uri_parser_1 = require("./uri-parser");
const channelz_1 = require("./channelz");
const server_interceptors_1 = require("./server-interceptors");
const UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
const KEEPALIVE_TIMEOUT_MS = 20000;
const MAX_CONNECTION_IDLE_MS = ~(1 << 31);
const { HTTP2_HEADER_PATH } = http2.constants;
const TRACER_NAME = 'server';
const kMaxAge = Buffer.from('max_age');
function noop() { }
/**
 * Decorator to wrap a class method with util.deprecate
 * @param message The message to output if the deprecated method is called
 * @returns
 */
function deprecate(message) {
    return function (target, context) {
        return util.deprecate(target, message);
    };
}
function getUnimplementedStatusResponse(methodName) {
    return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`,
    };
}
function getDefaultHandler(handlerType, methodName) {
    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
    switch (handlerType) {
        case 'unary':
            return (call, callback) => {
                callback(unimplementedStatusResponse, null);
            };
        case 'clientStream':
            return (call, callback) => {
                callback(unimplementedStatusResponse, null);
            };
        case 'serverStream':
            return (call) => {
                call.emit('error', unimplementedStatusResponse);
            };
        case 'bidi':
            return (call) => {
                call.emit('error', unimplementedStatusResponse);
            };
        default:
            throw new Error(`Invalid handlerType ${handlerType}`);
    }
}
let Server = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _start_decorators;
    return _a = class Server {
            constructor(options) {
                var _b, _c, _d, _e, _f, _g;
                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());
                this.http2Servers = new Map();
                this.sessionIdleTimeouts = new Map();
                this.handlers = new Map();
                this.sessions = new Map();
                /**
                 * This field only exists to ensure that the start method throws an error if
                 * it is called twice, as it did previously.
                 */
                this.started = false;
                this.shutdown = false;
                this.serverAddressString = 'null';
                // Channelz Info
                this.channelzEnabled = true;
                this.options = options !== null && options !== void 0 ? options : {};
                if (this.options['grpc.enable_channelz'] === 0) {
                    this.channelzEnabled = false;
                    this.channelzTrace = new channelz_1.ChannelzTraceStub();
                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();
                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
                }
                else {
                    this.channelzTrace = new channelz_1.ChannelzTrace();
                    this.callTracker = new channelz_1.ChannelzCallTracker();
                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
                }
                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);
                this.channelzTrace.addTrace('CT_INFO', 'Server created');
                this.maxConnectionAgeMs =
                    (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;
                this.maxConnectionAgeGraceMs =
                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;
                this.keepaliveTimeMs =
                    (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;
                this.keepaliveTimeoutMs =
                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;
                this.sessionIdleTimeout =
                    (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;
                this.commonServerOptions = {
                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
                };
                if ('grpc-node.max_session_memory' in this.options) {
                    this.commonServerOptions.maxSessionMemory =
                        this.options['grpc-node.max_session_memory'];
                }
                else {
                    /* By default, set a very large max session memory limit, to effectively
                     * disable enforcement of the limit. Some testing indicates that Node's
                     * behavior degrades badly when this limit is reached, so we solve that
                     * by disabling the check entirely. */
                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
                }
                if ('grpc.max_concurrent_streams' in this.options) {
                    this.commonServerOptions.settings = {
                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
                    };
                }
                this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];
                this.trace('Server constructed');
            }
            getChannelzInfo() {
                return {
                    trace: this.channelzTrace,
                    callTracker: this.callTracker,
                    listenerChildren: this.listenerChildrenTracker.getChildLists(),
                    sessionChildren: this.sessionChildrenTracker.getChildLists(),
                };
            }
            getChannelzSessionInfo(session) {
                var _b, _c, _d;
                const sessionInfo = this.sessions.get(session);
                const sessionSocket = session.socket;
                const remoteAddress = sessionSocket.remoteAddress
                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
                    : null;
                const localAddress = sessionSocket.localAddress
                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
                    : null;
                let tlsInfo;
                if (session.encrypted) {
                    const tlsSocket = sessionSocket;
                    const cipherInfo = tlsSocket.getCipher();
                    const certificate = tlsSocket.getCertificate();
                    const peerCertificate = tlsSocket.getPeerCertificate();
                    tlsInfo = {
                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== void 0 ? _b : null,
                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
                        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
                        remoteCertificate: peerCertificate && 'raw' in peerCertificate
                            ? peerCertificate.raw
                            : null,
                    };
                }
                else {
                    tlsInfo = null;
                }
                const socketInfo = {
                    remoteAddress: remoteAddress,
                    localAddress: localAddress,
                    security: tlsInfo,
                    remoteName: null,
                    streamsStarted: sessionInfo.streamTracker.callsStarted,
                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
                    streamsFailed: sessionInfo.streamTracker.callsFailed,
                    messagesSent: sessionInfo.messagesSent,
                    messagesReceived: sessionInfo.messagesReceived,
                    keepAlivesSent: sessionInfo.keepAlivesSent,
                    lastLocalStreamCreatedTimestamp: null,
                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== void 0 ? _c : null,
                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null,
                };
                return socketInfo;
            }
            trace(text) {
                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);
            }
            keepaliveTrace(text) {
                logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);
            }
            addProtoService() {
                throw new Error('Not implemented. Use addService() instead');
            }
            addService(service, implementation) {
                if (service === null ||
                    typeof service !== 'object' ||
                    implementation === null ||
                    typeof implementation !== 'object') {
                    throw new Error('addService() requires two objects as arguments');
                }
                const serviceKeys = Object.keys(service);
                if (serviceKeys.length === 0) {
                    throw new Error('Cannot add an empty service to a server');
                }
                serviceKeys.forEach(name => {
                    const attrs = service[name];
                    let methodType;
                    if (attrs.requestStream) {
                        if (attrs.responseStream) {
                            methodType = 'bidi';
                        }
                        else {
                            methodType = 'clientStream';
                        }
                    }
                    else {
                        if (attrs.responseStream) {
                            methodType = 'serverStream';
                        }
                        else {
                            methodType = 'unary';
                        }
                    }
                    let implFn = implementation[name];
                    let impl;
                    if (implFn === undefined && typeof attrs.originalName === 'string') {
                        implFn = implementation[attrs.originalName];
                    }
                    if (implFn !== undefined) {
                        impl = implFn.bind(implementation);
                    }
                    else {
                        impl = getDefaultHandler(methodType, name);
                    }
                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
                    if (success === false) {
                        throw new Error(`Method handler for ${attrs.path} already provided.`);
                    }
                });
            }
            removeService(service) {
                if (service === null || typeof service !== 'object') {
                    throw new Error('removeService() requires object as argument');
                }
                const serviceKeys = Object.keys(service);
                serviceKeys.forEach(name => {
                    const attrs = service[name];
                    this.unregister(attrs.path);
                });
            }
            bind(port, creds) {
                throw new Error('Not implemented. Use bindAsync() instead');
            }
            registerListenerToChannelz(boundAddress) {
                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
                    return {
                        localAddress: boundAddress,
                        remoteAddress: null,
                        security: null,
                        remoteName: null,
                        streamsStarted: 0,
                        streamsSucceeded: 0,
                        streamsFailed: 0,
                        messagesSent: 0,
                        messagesReceived: 0,
                        keepAlivesSent: 0,
                        lastLocalStreamCreatedTimestamp: null,
                        lastRemoteStreamCreatedTimestamp: null,
                        lastMessageSentTimestamp: null,
                        lastMessageReceivedTimestamp: null,
                        localFlowControlWindow: null,
                        remoteFlowControlWindow: null,
                    };
                }, this.channelzEnabled);
            }
            createHttp2Server(credentials) {
                let http2Server;
                if (credentials._isSecure()) {
                    const credentialsSettings = credentials._getSettings();
                    const secureServerOptions = Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), credentialsSettings), { enableTrace: this.options['grpc-node.tls_enable_trace'] === 1 });
                    let areCredentialsValid = credentialsSettings !== null;
                    http2Server = http2.createSecureServer(secureServerOptions);
                    http2Server.on('connection', (socket) => {
                        if (!areCredentialsValid) {
                            socket.destroy();
                        }
                    });
                    http2Server.on('secureConnection', (socket) => {
                        /* These errors need to be handled by the user of Http2SecureServer,
                         * according to https://github.com/nodejs/node/issues/35824 */
                        socket.on('error', (e) => {
                            this.trace('An incoming TLS connection closed with error: ' + e.message);
                        });
                    });
                    const credsWatcher = options => {
                        if (options) {
                            http2Server.setSecureContext(options);
                        }
                        areCredentialsValid = options !== null;
                    };
                    credentials._addWatcher(credsWatcher);
                    http2Server.on('close', () => {
                        credentials._removeWatcher(credsWatcher);
                    });
                }
                else {
                    http2Server = http2.createServer(this.commonServerOptions);
                }
                http2Server.setTimeout(0, noop);
                this._setupHandlers(http2Server, credentials._getInterceptors());
                return http2Server;
            }
            bindOneAddress(address, boundPortObject) {
                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));
                const http2Server = this.createHttp2Server(boundPortObject.credentials);
                return new Promise((resolve, reject) => {
                    const onError = (err) => {
                        this.trace('Failed to bind ' +
                            (0, subchannel_address_1.subchannelAddressToString)(address) +
                            ' with error ' +
                            err.message);
                        resolve({
                            port: 'port' in address ? address.port : 1,
                            error: err.message,
                        });
                    };
                    http2Server.once('error', onError);
                    http2Server.listen(address, () => {
                        const boundAddress = http2Server.address();
                        let boundSubchannelAddress;
                        if (typeof boundAddress === 'string') {
                            boundSubchannelAddress = {
                                path: boundAddress,
                            };
                        }
                        else {
                            boundSubchannelAddress = {
                                host: boundAddress.address,
                                port: boundAddress.port,
                            };
                        }
                        const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);
                        this.listenerChildrenTracker.refChild(channelzRef);
                        this.http2Servers.set(http2Server, {
                            channelzRef: channelzRef,
                            sessions: new Set(),
                        });
                        boundPortObject.listeningServers.add(http2Server);
                        this.trace('Successfully bound ' +
                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
                        resolve({
                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,
                        });
                        http2Server.removeListener('error', onError);
                    });
                });
            }
            async bindManyPorts(addressList, boundPortObject) {
                if (addressList.length === 0) {
                    return {
                        count: 0,
                        port: 0,
                        errors: [],
                    };
                }
                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
                    /* If binding to port 0, first try to bind the first address, then bind
                     * the rest of the address list to the specific port that it binds. */
                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
                    if (firstAddressResult.error) {
                        /* If the first address fails to bind, try the same operation starting
                         * from the second item in the list. */
                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });
                    }
                    else {
                        const restAddresses = addressList
                            .slice(1)
                            .map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address)
                            ? { host: address.host, port: firstAddressResult.port }
                            : address);
                        const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));
                        const allResults = [firstAddressResult, ...restAddressResult];
                        return {
                            count: allResults.filter(result => result.error === undefined).length,
                            port: firstAddressResult.port,
                            errors: allResults
                                .filter(result => result.error)
                                .map(result => result.error),
                        };
                    }
                }
                else {
                    const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));
                    return {
                        count: allResults.filter(result => result.error === undefined).length,
                        port: allResults[0].port,
                        errors: allResults
                            .filter(result => result.error)
                            .map(result => result.error),
                    };
                }
            }
            async bindAddressList(addressList, boundPortObject) {
                const bindResult = await this.bindManyPorts(addressList, boundPortObject);
                if (bindResult.count > 0) {
                    if (bindResult.count < addressList.length) {
                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                    }
                    return bindResult.port;
                }
                else {
                    const errorString = `No address added out of total ${addressList.length} resolved`;
                    logging.log(constants_1.LogVerbosity.ERROR, errorString);
                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);
                }
            }
            resolvePort(port) {
                return new Promise((resolve, reject) => {
                    const resolverListener = {
                        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {
                            // We only want one resolution result. Discard all future results
                            resolverListener.onSuccessfulResolution = () => { };
                            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
                            if (addressList.length === 0) {
                                reject(new Error(`No addresses resolved for port ${port}`));
                                return;
                            }
                            resolve(addressList);
                        },
                        onError: error => {
                            reject(new Error(error.details));
                        },
                    };
                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
                    resolver.updateResolution();
                });
            }
            async bindPort(port, boundPortObject) {
                const addressList = await this.resolvePort(port);
                if (boundPortObject.cancelled) {
                    this.completeUnbind(boundPortObject);
                    throw new Error('bindAsync operation cancelled by unbind call');
                }
                const portNumber = await this.bindAddressList(addressList, boundPortObject);
                if (boundPortObject.cancelled) {
                    this.completeUnbind(boundPortObject);
                    throw new Error('bindAsync operation cancelled by unbind call');
                }
                return portNumber;
            }
            normalizePort(port) {
                const initialPortUri = (0, uri_parser_1.parseUri)(port);
                if (initialPortUri === null) {
                    throw new Error(`Could not parse port "${port}"`);
                }
                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
                if (portUri === null) {
                    throw new Error(`Could not get a default scheme for port "${port}"`);
                }
                return portUri;
            }
            bindAsync(port, creds, callback) {
                if (this.shutdown) {
                    throw new Error('bindAsync called after shutdown');
                }
                if (typeof port !== 'string') {
                    throw new TypeError('port must be a string');
                }
                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
                    throw new TypeError('creds must be a ServerCredentials object');
                }
                if (typeof callback !== 'function') {
                    throw new TypeError('callback must be a function');
                }
                this.trace('bindAsync port=' + port);
                const portUri = this.normalizePort(port);
                const deferredCallback = (error, port) => {
                    process.nextTick(() => callback(error, port));
                };
                /* First, if this port is already bound or that bind operation is in
                 * progress, use that result. */
                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
                if (boundPortObject) {
                    if (!creds._equals(boundPortObject.credentials)) {
                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
                        return;
                    }
                    /* If that operation has previously been cancelled by an unbind call,
                     * uncancel it. */
                    boundPortObject.cancelled = false;
                    if (boundPortObject.completionPromise) {
                        boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));
                    }
                    else {
                        deferredCallback(null, boundPortObject.portNumber);
                    }
                    return;
                }
                boundPortObject = {
                    mapKey: (0, uri_parser_1.uriToString)(portUri),
                    originalUri: portUri,
                    completionPromise: null,
                    cancelled: false,
                    portNumber: 0,
                    credentials: creds,
                    listeningServers: new Set(),
                };
                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
                const completionPromise = this.bindPort(portUri, boundPortObject);
                boundPortObject.completionPromise = completionPromise;
                /* If the port number is 0, defer populating the map entry until after the
                 * bind operation completes and we have a specific port number. Otherwise,
                 * populate it immediately. */
                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
                    completionPromise.then(portNum => {
                        const finalUri = {
                            scheme: portUri.scheme,
                            authority: portUri.authority,
                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),
                        };
                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
                        boundPortObject.completionPromise = null;
                        boundPortObject.portNumber = portNum;
                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
                        callback(null, portNum);
                    }, error => {
                        callback(error, 0);
                    });
                }
                else {
                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
                    completionPromise.then(portNum => {
                        boundPortObject.completionPromise = null;
                        boundPortObject.portNumber = portNum;
                        callback(null, portNum);
                    }, error => {
                        callback(error, 0);
                    });
                }
            }
            registerInjectorToChannelz() {
                return (0, channelz_1.registerChannelzSocket)('injector', () => {
                    return {
                        localAddress: null,
                        remoteAddress: null,
                        security: null,
                        remoteName: null,
                        streamsStarted: 0,
                        streamsSucceeded: 0,
                        streamsFailed: 0,
                        messagesSent: 0,
                        messagesReceived: 0,
                        keepAlivesSent: 0,
                        lastLocalStreamCreatedTimestamp: null,
                        lastRemoteStreamCreatedTimestamp: null,
                        lastMessageSentTimestamp: null,
                        lastMessageReceivedTimestamp: null,
                        localFlowControlWindow: null,
                        remoteFlowControlWindow: null,
                    };
                }, this.channelzEnabled);
            }
            createConnectionInjector(credentials) {
                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
                    throw new TypeError('creds must be a ServerCredentials object');
                }
                const server = this.createHttp2Server(credentials);
                const channelzRef = this.registerInjectorToChannelz();
                if (this.channelzEnabled) {
                    this.listenerChildrenTracker.refChild(channelzRef);
                }
                const sessionsSet = new Set();
                this.http2Servers.set(server, {
                    channelzRef: channelzRef,
                    sessions: sessionsSet
                });
                return {
                    injectConnection: (connection) => {
                        server.emit('connection', connection);
                    },
                    drain: (graceTimeMs) => {
                        var _b, _c;
                        for (const session of sessionsSet) {
                            this.closeSession(session);
                        }
                        (_c = (_b = setTimeout(() => {
                            for (const session of sessionsSet) {
                                session.destroy(http2.constants.NGHTTP2_CANCEL);
                            }
                        }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
                    },
                    destroy: () => {
                        this.closeServer(server);
                        for (const session of sessionsSet) {
                            this.closeSession(session);
                        }
                    }
                };
            }
            closeServer(server, callback) {
                this.trace('Closing server with address ' + JSON.stringify(server.address()));
                const serverInfo = this.http2Servers.get(server);
                server.close(() => {
                    if (serverInfo) {
                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
                    }
                    this.http2Servers.delete(server);
                    callback === null || callback === void 0 ? void 0 : callback();
                });
            }
            closeSession(session, callback) {
                var _b;
                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));
                const sessionInfo = this.sessions.get(session);
                const closeCallback = () => {
                    if (sessionInfo) {
                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
                    }
                    callback === null || callback === void 0 ? void 0 : callback();
                };
                if (session.closed) {
                    queueMicrotask(closeCallback);
                }
                else {
                    session.close(closeCallback);
                }
            }
            completeUnbind(boundPortObject) {
                for (const server of boundPortObject.listeningServers) {
                    const serverInfo = this.http2Servers.get(server);
                    this.closeServer(server, () => {
                        boundPortObject.listeningServers.delete(server);
                    });
                    if (serverInfo) {
                        for (const session of serverInfo.sessions) {
                            this.closeSession(session);
                        }
                    }
                }
                this.boundPorts.delete(boundPortObject.mapKey);
            }
            /**
             * Unbind a previously bound port, or cancel an in-progress bindAsync
             * operation. If port 0 was bound, only the actual bound port can be
             * unbound. For example, if bindAsync was called with "localhost:0" and the
             * bound port result was 54321, it can be unbound as "localhost:54321".
             * @param port
             */
            unbind(port) {
                this.trace('unbind port=' + port);
                const portUri = this.normalizePort(port);
                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
                    throw new Error('Cannot unbind port 0');
                }
                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
                if (boundPortObject) {
                    this.trace('unbinding ' +
                        boundPortObject.mapKey +
                        ' originally bound as ' +
                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
                    /* If the bind operation is pending, the cancelled flag will trigger
                     * the unbind operation later. */
                    if (boundPortObject.completionPromise) {
                        boundPortObject.cancelled = true;
                    }
                    else {
                        this.completeUnbind(boundPortObject);
                    }
                }
            }
            /**
             * Gracefully close all connections associated with a previously bound port.
             * After the grace time, forcefully close all remaining open connections.
             *
             * If port 0 was bound, only the actual bound port can be
             * drained. For example, if bindAsync was called with "localhost:0" and the
             * bound port result was 54321, it can be drained as "localhost:54321".
             * @param port
             * @param graceTimeMs
             * @returns
             */
            drain(port, graceTimeMs) {
                var _b, _c;
                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);
                const portUri = this.normalizePort(port);
                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
                    throw new Error('Cannot drain port 0');
                }
                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
                if (!boundPortObject) {
                    return;
                }
                const allSessions = new Set();
                for (const http2Server of boundPortObject.listeningServers) {
                    const serverEntry = this.http2Servers.get(http2Server);
                    if (serverEntry) {
                        for (const session of serverEntry.sessions) {
                            allSessions.add(session);
                            this.closeSession(session, () => {
                                allSessions.delete(session);
                            });
                        }
                    }
                }
                /* After the grace time ends, send another goaway to all remaining sessions
                 * with the CANCEL code. */
                (_c = (_b = setTimeout(() => {
                    for (const session of allSessions) {
                        session.destroy(http2.constants.NGHTTP2_CANCEL);
                    }
                }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
            }
            forceShutdown() {
                for (const boundPortObject of this.boundPorts.values()) {
                    boundPortObject.cancelled = true;
                }
                this.boundPorts.clear();
                // Close the server if it is still running.
                for (const server of this.http2Servers.keys()) {
                    this.closeServer(server);
                }
                // Always destroy any available sessions. It's possible that one or more
                // tryShutdown() calls are in progress. Don't wait on them to finish.
                this.sessions.forEach((channelzInfo, session) => {
                    this.closeSession(session);
                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
                    // recognize destroy(code) as a valid signature.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    session.destroy(http2.constants.NGHTTP2_CANCEL);
                });
                this.sessions.clear();
                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
                this.shutdown = true;
            }
            register(name, handler, serialize, deserialize, type) {
                if (this.handlers.has(name)) {
                    return false;
                }
                this.handlers.set(name, {
                    func: handler,
                    serialize,
                    deserialize,
                    type,
                    path: name,
                });
                return true;
            }
            unregister(name) {
                return this.handlers.delete(name);
            }
            /**
             * @deprecated No longer needed as of version 1.10.x
             */
            start() {
                if (this.http2Servers.size === 0 ||
                    [...this.http2Servers.keys()].every(server => !server.listening)) {
                    throw new Error('server must be bound in order to start');
                }
                if (this.started === true) {
                    throw new Error('server is already started');
                }
                this.started = true;
            }
            tryShutdown(callback) {
                var _b;
                const wrappedCallback = (error) => {
                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
                    callback(error);
                };
                let pendingChecks = 0;
                function maybeCallback() {
                    pendingChecks--;
                    if (pendingChecks === 0) {
                        wrappedCallback();
                    }
                }
                this.shutdown = true;
                for (const [serverKey, server] of this.http2Servers.entries()) {
                    pendingChecks++;
                    const serverString = server.channelzRef.name;
                    this.trace('Waiting for server ' + serverString + ' to close');
                    this.closeServer(serverKey, () => {
                        this.trace('Server ' + serverString + ' finished closing');
                        maybeCallback();
                    });
                    for (const session of server.sessions.keys()) {
                        pendingChecks++;
                        const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;
                        this.trace('Waiting for session ' + sessionString + ' to close');
                        this.closeSession(session, () => {
                            this.trace('Session ' + sessionString + ' finished closing');
                            maybeCallback();
                        });
                    }
                }
                if (pendingChecks === 0) {
                    wrappedCallback();
                }
            }
            addHttp2Port() {
                throw new Error('Not yet implemented');
            }
            /**
             * Get the channelz reference object for this server. The returned value is
             * garbage if channelz is disabled for this server.
             * @returns
             */
            getChannelzRef() {
                return this.channelzRef;
            }
            _verifyContentType(stream, headers) {
                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
                if (typeof contentType !== 'string' ||
                    !contentType.startsWith('application/grpc')) {
                    stream.respond({
                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
                    }, { endStream: true });
                    return false;
                }
                return true;
            }
            _retrieveHandler(path) {
                this.trace('Received call to method ' +
                    path +
                    ' at address ' +
                    this.serverAddressString);
                const handler = this.handlers.get(path);
                if (handler === undefined) {
                    this.trace('No handler registered for method ' +
                        path +
                        '. Sending UNIMPLEMENTED status.');
                    return null;
                }
                return handler;
            }
            _respondWithError(err, stream, channelzSessionInfo = null) {
                var _b, _c;
                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null && _b !== void 0 ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());
                stream.respond(trailersToSend, { endStream: true });
                this.callTracker.addCallFailed();
                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            }
            _channelzHandler(extraInterceptors, stream, headers) {
                // for handling idle timeout
                this.onStreamOpened(stream);
                const channelzSessionInfo = this.sessions.get(stream.session);
                this.callTracker.addCallStarted();
                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
                if (!this._verifyContentType(stream, headers)) {
                    this.callTracker.addCallFailed();
                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
                    return;
                }
                const path = headers[HTTP2_HEADER_PATH];
                const handler = this._retrieveHandler(path);
                if (!handler) {
                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);
                    return;
                }
                const callEventTracker = {
                    addMessageSent: () => {
                        if (channelzSessionInfo) {
                            channelzSessionInfo.messagesSent += 1;
                            channelzSessionInfo.lastMessageSentTimestamp = new Date();
                        }
                    },
                    addMessageReceived: () => {
                        if (channelzSessionInfo) {
                            channelzSessionInfo.messagesReceived += 1;
                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
                        }
                    },
                    onCallEnd: status => {
                        if (status.code === constants_1.Status.OK) {
                            this.callTracker.addCallSucceeded();
                        }
                        else {
                            this.callTracker.addCallFailed();
                        }
                    },
                    onStreamEnd: success => {
                        if (channelzSessionInfo) {
                            if (success) {
                                channelzSessionInfo.streamTracker.addCallSucceeded();
                            }
                            else {
                                channelzSessionInfo.streamTracker.addCallFailed();
                            }
                        }
                    },
                };
                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);
                if (!this._runHandlerForCall(call, handler)) {
                    this.callTracker.addCallFailed();
                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
                    call.sendStatus({
                        code: constants_1.Status.INTERNAL,
                        details: `Unknown handler type: ${handler.type}`,
                    });
                }
            }
            _streamHandler(extraInterceptors, stream, headers) {
                // for handling idle timeout
                this.onStreamOpened(stream);
                if (this._verifyContentType(stream, headers) !== true) {
                    return;
                }
                const path = headers[HTTP2_HEADER_PATH];
                const handler = this._retrieveHandler(path);
                if (!handler) {
                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);
                    return;
                }
                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);
                if (!this._runHandlerForCall(call, handler)) {
                    call.sendStatus({
                        code: constants_1.Status.INTERNAL,
                        details: `Unknown handler type: ${handler.type}`,
                    });
                }
            }
            _runHandlerForCall(call, handler) {
                const { type } = handler;
                if (type === 'unary') {
                    handleUnary(call, handler);
                }
                else if (type === 'clientStream') {
                    handleClientStreaming(call, handler);
                }
                else if (type === 'serverStream') {
                    handleServerStreaming(call, handler);
                }
                else if (type === 'bidi') {
                    handleBidiStreaming(call, handler);
                }
                else {
                    return false;
                }
                return true;
            }
            _setupHandlers(http2Server, extraInterceptors) {
                if (http2Server === null) {
                    return;
                }
                const serverAddress = http2Server.address();
                let serverAddressString = 'null';
                if (serverAddress) {
                    if (typeof serverAddress === 'string') {
                        serverAddressString = serverAddress;
                    }
                    else {
                        serverAddressString = serverAddress.address + ':' + serverAddress.port;
                    }
                }
                this.serverAddressString = serverAddressString;
                const handler = this.channelzEnabled
                    ? this._channelzHandler
                    : this._streamHandler;
                const sessionHandler = this.channelzEnabled
                    ? this._channelzSessionHandler(http2Server)
                    : this._sessionHandler(http2Server);
                http2Server.on('stream', handler.bind(this, extraInterceptors));
                http2Server.on('session', sessionHandler);
            }
            _sessionHandler(http2Server) {
                return (session) => {
                    var _b, _c;
                    (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);
                    let connectionAgeTimer = null;
                    let connectionAgeGraceTimer = null;
                    let keepaliveTimer = null;
                    let sessionClosedByServer = false;
                    const idleTimeoutObj = this.enableIdleTimeout(session);
                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
                        // Apply a random jitter within a +/-10% range
                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
                        connectionAgeTimer = setTimeout(() => {
                            var _b, _c;
                            sessionClosedByServer = true;
                            this.trace('Connection dropped by max connection age: ' +
                                ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));
                            try {
                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                            }
                            catch (e) {
                                // The goaway can't be sent because the session is already closed
                                session.destroy();
                                return;
                            }
                            session.close();
                            /* Allow a grace period after sending the GOAWAY before forcibly
                             * closing the connection. */
                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                                connectionAgeGraceTimer = setTimeout(() => {
                                    session.destroy();
                                }, this.maxConnectionAgeGraceMs);
                                (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);
                            }
                        }, this.maxConnectionAgeMs + jitter);
                        (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);
                    }
                    const clearKeepaliveTimeout = () => {
                        if (keepaliveTimer) {
                            clearTimeout(keepaliveTimer);
                            keepaliveTimer = null;
                        }
                    };
                    const canSendPing = () => {
                        return (!session.destroyed &&
                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
                            this.keepaliveTimeMs > 0);
                    };
                    /* eslint-disable-next-line prefer-const */
                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer
                    const maybeStartKeepalivePingTimer = () => {
                        var _b;
                        if (!canSendPing()) {
                            return;
                        }
                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
                        keepaliveTimer = setTimeout(() => {
                            clearKeepaliveTimeout();
                            sendPing();
                        }, this.keepaliveTimeMs);
                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);
                    };
                    sendPing = () => {
                        var _b;
                        if (!canSendPing()) {
                            return;
                        }
                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
                        let pingSendError = '';
                        try {
                            const pingSentSuccessfully = session.ping((err, duration, payload) => {
                                clearKeepaliveTimeout();
                                if (err) {
                                    this.keepaliveTrace('Ping failed with error: ' + err.message);
                                    sessionClosedByServer = true;
                                    session.close();
                                }
                                else {
                                    this.keepaliveTrace('Received ping response');
                                    maybeStartKeepalivePingTimer();
                                }
                            });
                            if (!pingSentSuccessfully) {
                                pingSendError = 'Ping returned false';
                            }
                        }
                        catch (e) {
                            // grpc/grpc-node#2139
                            pingSendError =
                                (e instanceof Error ? e.message : '') || 'Unknown error';
                        }
                        if (pingSendError) {
                            this.keepaliveTrace('Ping send failed: ' + pingSendError);
                            this.trace('Connection dropped due to ping send error: ' + pingSendError);
                            sessionClosedByServer = true;
                            session.close();
                            return;
                        }
                        keepaliveTimer = setTimeout(() => {
                            clearKeepaliveTimeout();
                            this.keepaliveTrace('Ping timeout passed without response');
                            this.trace('Connection dropped by keepalive timeout');
                            sessionClosedByServer = true;
                            session.close();
                        }, this.keepaliveTimeoutMs);
                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);
                    };
                    maybeStartKeepalivePingTimer();
                    session.on('close', () => {
                        var _b, _c;
                        if (!sessionClosedByServer) {
                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);
                        }
                        if (connectionAgeTimer) {
                            clearTimeout(connectionAgeTimer);
                        }
                        if (connectionAgeGraceTimer) {
                            clearTimeout(connectionAgeGraceTimer);
                        }
                        clearKeepaliveTimeout();
                        if (idleTimeoutObj !== null) {
                            clearTimeout(idleTimeoutObj.timeout);
                            this.sessionIdleTimeouts.delete(session);
                        }
                        (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);
                    });
                };
            }
            _channelzSessionHandler(http2Server) {
                return (session) => {
                    var _b, _c, _d, _e;
                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null && _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
                    const channelzSessionInfo = {
                        ref: channelzRef,
                        streamTracker: new channelz_1.ChannelzCallTracker(),
                        messagesSent: 0,
                        messagesReceived: 0,
                        keepAlivesSent: 0,
                        lastMessageSentTimestamp: null,
                        lastMessageReceivedTimestamp: null,
                    };
                    (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);
                    this.sessions.set(session, channelzSessionInfo);
                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);
                    this.trace('Connection established by client ' + clientAddress);
                    this.sessionChildrenTracker.refChild(channelzRef);
                    let connectionAgeTimer = null;
                    let connectionAgeGraceTimer = null;
                    let keepaliveTimeout = null;
                    let sessionClosedByServer = false;
                    const idleTimeoutObj = this.enableIdleTimeout(session);
                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
                        // Apply a random jitter within a +/-10% range
                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
                        connectionAgeTimer = setTimeout(() => {
                            var _b;
                            sessionClosedByServer = true;
                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);
                            try {
                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                            }
                            catch (e) {
                                // The goaway can't be sent because the session is already closed
                                session.destroy();
                                return;
                            }
                            session.close();
                            /* Allow a grace period after sending the GOAWAY before forcibly
                             * closing the connection. */
                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                                connectionAgeGraceTimer = setTimeout(() => {
                                    session.destroy();
                                }, this.maxConnectionAgeGraceMs);
                                (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);
                            }
                        }, this.maxConnectionAgeMs + jitter);
                        (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);
                    }
                    const clearKeepaliveTimeout = () => {
                        if (keepaliveTimeout) {
                            clearTimeout(keepaliveTimeout);
                            keepaliveTimeout = null;
                        }
                    };
                    const canSendPing = () => {
                        return (!session.destroyed &&
                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
                            this.keepaliveTimeMs > 0);
                    };
                    /* eslint-disable-next-line prefer-const */
                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer
                    const maybeStartKeepalivePingTimer = () => {
                        var _b;
                        if (!canSendPing()) {
                            return;
                        }
                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
                        keepaliveTimeout = setTimeout(() => {
                            clearKeepaliveTimeout();
                            sendPing();
                        }, this.keepaliveTimeMs);
                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);
                    };
                    sendPing = () => {
                        var _b;
                        if (!canSendPing()) {
                            return;
                        }
                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
                        let pingSendError = '';
                        try {
                            const pingSentSuccessfully = session.ping((err, duration, payload) => {
                                clearKeepaliveTimeout();
                                if (err) {
                                    this.keepaliveTrace('Ping failed with error: ' + err.message);
                                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +
                                        err.message +
                                        ' return in ' +
                                        duration);
                                    sessionClosedByServer = true;
                                    session.close();
                                }
                                else {
                                    this.keepaliveTrace('Received ping response');
                                    maybeStartKeepalivePingTimer();
                                }
                            });
                            if (!pingSentSuccessfully) {
                                pingSendError = 'Ping returned false';
                            }
                        }
                        catch (e) {
                            // grpc/grpc-node#2139
                            pingSendError =
                                (e instanceof Error ? e.message : '') || 'Unknown error';
                        }
                        if (pingSendError) {
                            this.keepaliveTrace('Ping send failed: ' + pingSendError);
                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);
                            sessionClosedByServer = true;
                            session.close();
                            return;
                        }
                        channelzSessionInfo.keepAlivesSent += 1;
                        keepaliveTimeout = setTimeout(() => {
                            clearKeepaliveTimeout();
                            this.keepaliveTrace('Ping timeout passed without response');
                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);
                            sessionClosedByServer = true;
                            session.close();
                        }, this.keepaliveTimeoutMs);
                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);
                    };
                    maybeStartKeepalivePingTimer();
                    session.on('close', () => {
                        var _b;
                        if (!sessionClosedByServer) {
                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);
                        }
                        this.sessionChildrenTracker.unrefChild(channelzRef);
                        (0, channelz_1.unregisterChannelzRef)(channelzRef);
                        if (connectionAgeTimer) {
                            clearTimeout(connectionAgeTimer);
                        }
                        if (connectionAgeGraceTimer) {
                            clearTimeout(connectionAgeGraceTimer);
                        }
                        clearKeepaliveTimeout();
                        if (idleTimeoutObj !== null) {
                            clearTimeout(idleTimeoutObj.timeout);
                            this.sessionIdleTimeouts.delete(session);
                        }
                        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);
                        this.sessions.delete(session);
                    });
                };
            }
            enableIdleTimeout(session) {
                var _b, _c;
                if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
                    return null;
                }
                const idleTimeoutObj = {
                    activeStreams: 0,
                    lastIdle: Date.now(),
                    onClose: this.onStreamClose.bind(this, session),
                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),
                };
                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
                this.sessionIdleTimeouts.set(session, idleTimeoutObj);
                const { socket } = session;
                this.trace('Enable idle timeout for ' +
                    socket.remoteAddress +
                    ':' +
                    socket.remotePort);
                return idleTimeoutObj;
            }
            onIdleTimeout(ctx, session) {
                const { socket } = session;
                const sessionInfo = ctx.sessionIdleTimeouts.get(session);
                // if it is called while we have activeStreams - timer will not be rescheduled
                // until last active stream is closed, then it will call .refresh() on the timer
                // important part is to not clearTimeout(timer) or it becomes unusable
                // for future refreshes
                if (sessionInfo !== undefined &&
                    sessionInfo.activeStreams === 0) {
                    if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
                        ctx.trace('Session idle timeout triggered for ' +
                            (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) +
                            ':' +
                            (socket === null || socket === void 0 ? void 0 : socket.remotePort) +
                            ' last idle at ' +
                            sessionInfo.lastIdle);
                        ctx.closeSession(session);
                    }
                    else {
                        sessionInfo.timeout.refresh();
                    }
                }
            }
            onStreamOpened(stream) {
                const session = stream.session;
                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
                if (idleTimeoutObj) {
                    idleTimeoutObj.activeStreams += 1;
                    stream.once('close', idleTimeoutObj.onClose);
                }
            }
            onStreamClose(session) {
                var _b, _c;
                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
                if (idleTimeoutObj) {
                    idleTimeoutObj.activeStreams -= 1;
                    if (idleTimeoutObj.activeStreams === 0) {
                        idleTimeoutObj.lastIdle = Date.now();
                        idleTimeoutObj.timeout.refresh();
                        this.trace('Session onStreamClose' +
                            ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) +
                            ':' +
                            ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) +
                            ' at ' +
                            idleTimeoutObj.lastIdle);
                    }
                }
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];
            __esDecorate(_a, null, _start_decorators, { kind: "method", name: "start", static: false, private: false, access: { has: obj => "start" in obj, get: obj => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Server = Server;
async function handleUnary(call, handler) {
    let stream;
    function respond(err, value, trailer, flags) {
        if (err) {
            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
            return;
        }
        call.sendMessage(value, () => {
            call.sendStatus({
                code: constants_1.Status.OK,
                details: 'OK',
                metadata: trailer !== null && trailer !== void 0 ? trailer : null,
            });
        });
    }
    let requestMetadata;
    let requestMessage = null;
    call.start({
        onReceiveMetadata(metadata) {
            requestMetadata = metadata;
            call.startRead();
        },
        onReceiveMessage(message) {
            if (requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received a second request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            requestMessage = message;
            call.startRead();
        },
        onReceiveHalfClose() {
            if (!requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received no request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
            try {
                handler.func(stream, respond);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
            }
        },
    });
}
function handleClientStreaming(call, handler) {
    let stream;
    function respond(err, value, trailer, flags) {
        if (err) {
            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
            return;
        }
        call.sendMessage(value, () => {
            call.sendStatus({
                code: constants_1.Status.OK,
                details: 'OK',
                metadata: trailer !== null && trailer !== void 0 ? trailer : null,
            });
        });
    }
    call.start({
        onReceiveMetadata(metadata) {
            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
            try {
                handler.func(stream, respond);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onReceiveMessage(message) {
            stream.push(message);
        },
        onReceiveHalfClose() {
            stream.push(null);
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
                stream.destroy();
            }
        },
    });
}
function handleServerStreaming(call, handler) {
    let stream;
    let requestMetadata;
    let requestMessage = null;
    call.start({
        onReceiveMetadata(metadata) {
            requestMetadata = metadata;
            call.startRead();
        },
        onReceiveMessage(message) {
            if (requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received a second request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            requestMessage = message;
            call.startRead();
        },
        onReceiveHalfClose() {
            if (!requestMessage) {
                call.sendStatus({
                    code: constants_1.Status.UNIMPLEMENTED,
                    details: `Received no request message for server streaming method ${handler.path}`,
                    metadata: null,
                });
                return;
            }
            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
            try {
                handler.func(stream);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
                stream.destroy();
            }
        },
    });
}
function handleBidiStreaming(call, handler) {
    let stream;
    call.start({
        onReceiveMetadata(metadata) {
            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
            try {
                handler.func(stream);
            }
            catch (err) {
                call.sendStatus({
                    code: constants_1.Status.UNKNOWN,
                    details: `Server method handler threw error ${err.message}`,
                    metadata: null,
                });
            }
        },
        onReceiveMessage(message) {
            stream.push(message);
        },
        onReceiveHalfClose() {
            stream.push(null);
        },
        onCancel() {
            if (stream) {
                stream.cancelled = true;
                stream.emit('cancelled', 'cancelled');
                stream.destroy();
            }
        },
    });
}
//# sourceMappingURL=server.js.map{"version":3,"file":"server.js","sourceRoot":"","sources":["../../src/server.ts"],"names":[],"mappings":"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"}import { Status } from './constants';
import { Duration } from './duration';
export interface MethodConfigName {
    service?: string;
    method?: string;
}
export interface RetryPolicy {
    maxAttempts: number;
    initialBackoff: string;
    maxBackoff: string;
    backoffMultiplier: number;
    retryableStatusCodes: (Status | string)[];
}
export interface HedgingPolicy {
    maxAttempts: number;
    hedgingDelay?: string;
    nonFatalStatusCodes?: (Status | string)[];
}
export interface MethodConfig {
    name: MethodConfigName[];
    waitForReady?: boolean;
    timeout?: Duration;
    maxRequestBytes?: number;
    maxResponseBytes?: number;
    retryPolicy?: RetryPolicy;
    hedgingPolicy?: HedgingPolicy;
}
export interface RetryThrottling {
    maxTokens: number;
    tokenRatio: number;
}
export interface LoadBalancingConfig {
    [key: string]: object;
}
export interface ServiceConfig {
    loadBalancingPolicy?: string;
    loadBalancingConfig: LoadBalancingConfig[];
    methodConfig: MethodConfig[];
    retryThrottling?: RetryThrottling;
}
export interface ServiceConfigCanaryConfig {
    clientLanguage?: string[];
    percentage?: number;
    clientHostname?: string[];
    serviceConfig: ServiceConfig;
}
export declare function validateRetryThrottling(obj: any): RetryThrottling;
export declare function validateServiceConfig(obj: any): ServiceConfig;
/**
 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
 * and select a service config with selection fields that all match this client. Most of these steps
 * can fail with an error; the caller must handle any errors thrown this way.
 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
 * @return The service configuration to use, given the percentage value, or null if the service config
 *     data has a valid format but none of the options match the current client.
 */
export declare function extractAndSelectServiceConfig(txtRecord: string[][], percentage: number): ServiceConfig | null;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRetryThrottling = validateRetryThrottling;
exports.validateServiceConfig = validateServiceConfig;
exports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
/* This file implements gRFC A2 and the service config spec:
 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
 * function here takes an object with unknown structure and returns its
 * specific object type if the input has the right structure, and throws an
 * error otherwise. */
/* The any type is purposely used here. All functions validate their input at
 * runtime */
/* eslint-disable @typescript-eslint/no-explicit-any */
const os = require("os");
const constants_1 = require("./constants");
/**
 * Recognizes a number with up to 9 digits after the decimal point, followed by
 * an "s", representing a number of seconds.
 */
const DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
/**
 * Client language name used for determining whether this client matches a
 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
 */
const CLIENT_LANGUAGE_STRING = 'node';
function validateName(obj) {
    // In this context, and unset field and '' are considered the same
    if ('service' in obj && obj.service !== '') {
        if (typeof obj.service !== 'string') {
            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
        }
        if ('method' in obj && obj.method !== '') {
            if (typeof obj.method !== 'string') {
                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
            }
            return {
                service: obj.service,
                method: obj.method,
            };
        }
        else {
            return {
                service: obj.service,
            };
        }
    }
    else {
        if ('method' in obj && obj.method !== undefined) {
            throw new Error(`Invalid method config name: method set with empty or unset service`);
        }
        return {};
    }
}
function validateRetryPolicy(obj) {
    if (!('maxAttempts' in obj) ||
        !Number.isInteger(obj.maxAttempts) ||
        obj.maxAttempts < 2) {
        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');
    }
    if (!('initialBackoff' in obj) ||
        typeof obj.initialBackoff !== 'string' ||
        !DURATION_REGEX.test(obj.initialBackoff)) {
        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s');
    }
    if (!('maxBackoff' in obj) ||
        typeof obj.maxBackoff !== 'string' ||
        !DURATION_REGEX.test(obj.maxBackoff)) {
        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s');
    }
    if (!('backoffMultiplier' in obj) ||
        typeof obj.backoffMultiplier !== 'number' ||
        obj.backoffMultiplier <= 0) {
        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');
    }
    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {
        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');
    }
    if (obj.retryableStatusCodes.length === 0) {
        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');
    }
    for (const value of obj.retryableStatusCodes) {
        if (typeof value === 'number') {
            if (!Object.values(constants_1.Status).includes(value)) {
                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');
            }
        }
        else if (typeof value === 'string') {
            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');
            }
        }
        else {
            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');
        }
    }
    return {
        maxAttempts: obj.maxAttempts,
        initialBackoff: obj.initialBackoff,
        maxBackoff: obj.maxBackoff,
        backoffMultiplier: obj.backoffMultiplier,
        retryableStatusCodes: obj.retryableStatusCodes,
    };
}
function validateHedgingPolicy(obj) {
    if (!('maxAttempts' in obj) ||
        !Number.isInteger(obj.maxAttempts) ||
        obj.maxAttempts < 2) {
        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');
    }
    if ('hedgingDelay' in obj &&
        (typeof obj.hedgingDelay !== 'string' ||
            !DURATION_REGEX.test(obj.hedgingDelay))) {
        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');
    }
    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {
        for (const value of obj.nonFatalStatusCodes) {
            if (typeof value === 'number') {
                if (!Object.values(constants_1.Status).includes(value)) {
                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not in status code range');
                }
            }
            else if (typeof value === 'string') {
                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not a status code name');
                }
            }
            else {
                throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number');
            }
        }
    }
    const result = {
        maxAttempts: obj.maxAttempts,
    };
    if (obj.hedgingDelay) {
        result.hedgingDelay = obj.hedgingDelay;
    }
    if (obj.nonFatalStatusCodes) {
        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
    }
    return result;
}
function validateMethodConfig(obj) {
    var _a;
    const result = {
        name: [],
    };
    if (!('name' in obj) || !Array.isArray(obj.name)) {
        throw new Error('Invalid method config: invalid name array');
    }
    for (const name of obj.name) {
        result.name.push(validateName(name));
    }
    if ('waitForReady' in obj) {
        if (typeof obj.waitForReady !== 'boolean') {
            throw new Error('Invalid method config: invalid waitForReady');
        }
        result.waitForReady = obj.waitForReady;
    }
    if ('timeout' in obj) {
        if (typeof obj.timeout === 'object') {
            if (!('seconds' in obj.timeout) ||
                !(typeof obj.timeout.seconds === 'number')) {
                throw new Error('Invalid method config: invalid timeout.seconds');
            }
            if (!('nanos' in obj.timeout) ||
                !(typeof obj.timeout.nanos === 'number')) {
                throw new Error('Invalid method config: invalid timeout.nanos');
            }
            result.timeout = obj.timeout;
        }
        else if (typeof obj.timeout === 'string' &&
            DURATION_REGEX.test(obj.timeout)) {
            const timeoutParts = obj.timeout
                .substring(0, obj.timeout.length - 1)
                .split('.');
            result.timeout = {
                seconds: timeoutParts[0] | 0,
                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,
            };
        }
        else {
            throw new Error('Invalid method config: invalid timeout');
        }
    }
    if ('maxRequestBytes' in obj) {
        if (typeof obj.maxRequestBytes !== 'number') {
            throw new Error('Invalid method config: invalid maxRequestBytes');
        }
        result.maxRequestBytes = obj.maxRequestBytes;
    }
    if ('maxResponseBytes' in obj) {
        if (typeof obj.maxResponseBytes !== 'number') {
            throw new Error('Invalid method config: invalid maxRequestBytes');
        }
        result.maxResponseBytes = obj.maxResponseBytes;
    }
    if ('retryPolicy' in obj) {
        if ('hedgingPolicy' in obj) {
            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');
        }
        else {
            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
        }
    }
    else if ('hedgingPolicy' in obj) {
        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
    }
    return result;
}
function validateRetryThrottling(obj) {
    if (!('maxTokens' in obj) ||
        typeof obj.maxTokens !== 'number' ||
        obj.maxTokens <= 0 ||
        obj.maxTokens > 1000) {
        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');
    }
    if (!('tokenRatio' in obj) ||
        typeof obj.tokenRatio !== 'number' ||
        obj.tokenRatio <= 0) {
        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');
    }
    return {
        maxTokens: +obj.maxTokens.toFixed(3),
        tokenRatio: +obj.tokenRatio.toFixed(3),
    };
}
function validateLoadBalancingConfig(obj) {
    if (!(typeof obj === 'object' && obj !== null)) {
        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
    }
    const keys = Object.keys(obj);
    if (keys.length > 1) {
        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);
    }
    if (keys.length === 0) {
        throw new Error('Invalid loadBalancingConfig: load balancing policy name required');
    }
    return {
        [keys[0]]: obj[keys[0]],
    };
}
function validateServiceConfig(obj) {
    const result = {
        loadBalancingConfig: [],
        methodConfig: [],
    };
    if ('loadBalancingPolicy' in obj) {
        if (typeof obj.loadBalancingPolicy === 'string') {
            result.loadBalancingPolicy = obj.loadBalancingPolicy;
        }
        else {
            throw new Error('Invalid service config: invalid loadBalancingPolicy');
        }
    }
    if ('loadBalancingConfig' in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
            for (const config of obj.loadBalancingConfig) {
                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));
            }
        }
        else {
            throw new Error('Invalid service config: invalid loadBalancingConfig');
        }
    }
    if ('methodConfig' in obj) {
        if (Array.isArray(obj.methodConfig)) {
            for (const methodConfig of obj.methodConfig) {
                result.methodConfig.push(validateMethodConfig(methodConfig));
            }
        }
    }
    if ('retryThrottling' in obj) {
        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
    }
    // Validate method name uniqueness
    const seenMethodNames = [];
    for (const methodConfig of result.methodConfig) {
        for (const name of methodConfig.name) {
            for (const seenName of seenMethodNames) {
                if (name.service === seenName.service &&
                    name.method === seenName.method) {
                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
                }
            }
            seenMethodNames.push(name);
        }
    }
    return result;
}
function validateCanaryConfig(obj) {
    if (!('serviceConfig' in obj)) {
        throw new Error('Invalid service config choice: missing service config');
    }
    const result = {
        serviceConfig: validateServiceConfig(obj.serviceConfig),
    };
    if ('clientLanguage' in obj) {
        if (Array.isArray(obj.clientLanguage)) {
            result.clientLanguage = [];
            for (const lang of obj.clientLanguage) {
                if (typeof lang === 'string') {
                    result.clientLanguage.push(lang);
                }
                else {
                    throw new Error('Invalid service config choice: invalid clientLanguage');
                }
            }
        }
        else {
            throw new Error('Invalid service config choice: invalid clientLanguage');
        }
    }
    if ('clientHostname' in obj) {
        if (Array.isArray(obj.clientHostname)) {
            result.clientHostname = [];
            for (const lang of obj.clientHostname) {
                if (typeof lang === 'string') {
                    result.clientHostname.push(lang);
                }
                else {
                    throw new Error('Invalid service config choice: invalid clientHostname');
                }
            }
        }
        else {
            throw new Error('Invalid service config choice: invalid clientHostname');
        }
    }
    if ('percentage' in obj) {
        if (typeof obj.percentage === 'number' &&
            0 <= obj.percentage &&
            obj.percentage <= 100) {
            result.percentage = obj.percentage;
        }
        else {
            throw new Error('Invalid service config choice: invalid percentage');
        }
    }
    // Validate that no unexpected fields are present
    const allowedFields = [
        'clientLanguage',
        'percentage',
        'clientHostname',
        'serviceConfig',
    ];
    for (const field in obj) {
        if (!allowedFields.includes(field)) {
            throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
    }
    return result;
}
function validateAndSelectCanaryConfig(obj, percentage) {
    if (!Array.isArray(obj)) {
        throw new Error('Invalid service config list');
    }
    for (const config of obj) {
        const validatedConfig = validateCanaryConfig(config);
        /* For each field, we check if it is present, then only discard the
         * config if the field value does not match the current client */
        if (typeof validatedConfig.percentage === 'number' &&
            percentage > validatedConfig.percentage) {
            continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
            let hostnameMatched = false;
            for (const hostname of validatedConfig.clientHostname) {
                if (hostname === os.hostname()) {
                    hostnameMatched = true;
                }
            }
            if (!hostnameMatched) {
                continue;
            }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
            let languageMatched = false;
            for (const language of validatedConfig.clientLanguage) {
                if (language === CLIENT_LANGUAGE_STRING) {
                    languageMatched = true;
                }
            }
            if (!languageMatched) {
                continue;
            }
        }
        return validatedConfig.serviceConfig;
    }
    throw new Error('No matching service config found');
}
/**
 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
 * and select a service config with selection fields that all match this client. Most of these steps
 * can fail with an error; the caller must handle any errors thrown this way.
 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
 * @return The service configuration to use, given the percentage value, or null if the service config
 *     data has a valid format but none of the options match the current client.
 */
function extractAndSelectServiceConfig(txtRecord, percentage) {
    for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith('grpc_config=')) {
            /* Treat the list of strings in this record as a single string and remove
             * "grpc_config=" from the beginning. The rest should be a JSON string */
            const recordString = record.join('').substring('grpc_config='.length);
            const recordJson = JSON.parse(recordString);
            return validateAndSelectCanaryConfig(recordJson, percentage);
        }
    }
    return null;
}
//# sourceMappingURL=service-config.js.map{"version":3,"file":"service-config.js","sourceRoot":"","sources":["../../src/service-config.ts"],"names":[],"mappings":"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"}import { StatusObject } from './call-interface';
import { Status } from './constants';
import { Metadata } from './metadata';
/**
 * A builder for gRPC status objects.
 */
export declare class StatusBuilder {
    private code;
    private details;
    private metadata;
    constructor();
    /**
     * Adds a status code to the builder.
     */
    withCode(code: Status): this;
    /**
     * Adds details to the builder.
     */
    withDetails(details: string): this;
    /**
     * Adds metadata to the builder.
     */
    withMetadata(metadata: Metadata): this;
    /**
     * Builds the status object.
     */
    build(): Partial<StatusObject>;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusBuilder = void 0;
/**
 * A builder for gRPC status objects.
 */
class StatusBuilder {
    constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
    }
    /**
     * Adds a status code to the builder.
     */
    withCode(code) {
        this.code = code;
        return this;
    }
    /**
     * Adds details to the builder.
     */
    withDetails(details) {
        this.details = details;
        return this;
    }
    /**
     * Adds metadata to the builder.
     */
    withMetadata(metadata) {
        this.metadata = metadata;
        return this;
    }
    /**
     * Builds the status object.
     */
    build() {
        const status = {};
        if (this.code !== null) {
            status.code = this.code;
        }
        if (this.details !== null) {
            status.details = this.details;
        }
        if (this.metadata !== null) {
            status.metadata = this.metadata;
        }
        return status;
    }
}
exports.StatusBuilder = StatusBuilder;
//# sourceMappingURL=status-builder.js.map{"version":3,"file":"status-builder.js","sourceRoot":"","sources":["../../src/status-builder.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAMH;;GAEG;AACH,MAAa,aAAa;IAKxB;QACE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAED;;OAEG;IACH,QAAQ,CAAC,IAAY;QACnB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACH,WAAW,CAAC,OAAe;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACH,YAAY,CAAC,QAAkB;QAC7B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACH,KAAK;QACH,MAAM,MAAM,GAA0B,EAAE,CAAC;QAEzC,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;YACvB,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,CAAC;QAED,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,EAAE,CAAC;YAC1B,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAChC,CAAC;QAED,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;YAC3B,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAClC,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAvDD,sCAuDC"}export declare class StreamDecoder {
    private maxReadMessageLength;
    private readState;
    private readCompressFlag;
    private readPartialSize;
    private readSizeRemaining;
    private readMessageSize;
    private readPartialMessage;
    private readMessageRemaining;
    constructor(maxReadMessageLength: number);
    write(data: Buffer): Buffer[];
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDecoder = void 0;
var ReadState;
(function (ReadState) {
    ReadState[ReadState["NO_DATA"] = 0] = "NO_DATA";
    ReadState[ReadState["READING_SIZE"] = 1] = "READING_SIZE";
    ReadState[ReadState["READING_MESSAGE"] = 2] = "READING_MESSAGE";
})(ReadState || (ReadState = {}));
class StreamDecoder {
    constructor(maxReadMessageLength) {
        this.maxReadMessageLength = maxReadMessageLength;
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
    }
    write(data) {
        let readHead = 0;
        let toRead;
        const result = [];
        while (readHead < data.length) {
            switch (this.readState) {
                case ReadState.NO_DATA:
                    this.readCompressFlag = data.slice(readHead, readHead + 1);
                    readHead += 1;
                    this.readState = ReadState.READING_SIZE;
                    this.readPartialSize.fill(0);
                    this.readSizeRemaining = 4;
                    this.readMessageSize = 0;
                    this.readMessageRemaining = 0;
                    this.readPartialMessage = [];
                    break;
                case ReadState.READING_SIZE:
                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);
                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
                    this.readSizeRemaining -= toRead;
                    readHead += toRead;
                    // readSizeRemaining >=0 here
                    if (this.readSizeRemaining === 0) {
                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
                        }
                        this.readMessageRemaining = this.readMessageSize;
                        if (this.readMessageRemaining > 0) {
                            this.readState = ReadState.READING_MESSAGE;
                        }
                        else {
                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                            this.readState = ReadState.NO_DATA;
                            result.push(message);
                        }
                    }
                    break;
                case ReadState.READING_MESSAGE:
                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);
                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
                    this.readMessageRemaining -= toRead;
                    readHead += toRead;
                    // readMessageRemaining >=0 here
                    if (this.readMessageRemaining === 0) {
                        // At this point, we have read a full message
                        const framedMessageBuffers = [
                            this.readCompressFlag,
                            this.readPartialSize,
                        ].concat(this.readPartialMessage);
                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                        this.readState = ReadState.NO_DATA;
                        result.push(framedMessage);
                    }
                    break;
                default:
                    throw new Error('Unexpected read state');
            }
        }
        return result;
    }
}
exports.StreamDecoder = StreamDecoder;
//# sourceMappingURL=stream-decoder.js.map{"version":3,"file":"stream-decoder.js","sourceRoot":"","sources":["../../src/stream-decoder.ts"],"names":[],"mappings":"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"}export interface TcpSubchannelAddress {
    port: number;
    host: string;
}
export interface IpcSubchannelAddress {
    path: string;
}
/**
 * This represents a single backend address to connect to. This interface is a
 * subset of net.SocketConnectOpts, i.e. the options described at
 * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener.
 * Those are in turn a subset of the options that can be passed to http2.connect.
 */
export type SubchannelAddress = TcpSubchannelAddress | IpcSubchannelAddress;
export declare function isTcpSubchannelAddress(address: SubchannelAddress): address is TcpSubchannelAddress;
export declare function subchannelAddressEqual(address1?: SubchannelAddress, address2?: SubchannelAddress): boolean;
export declare function subchannelAddressToString(address: SubchannelAddress): string;
export declare function stringToSubchannelAddress(addressString: string, port?: number): SubchannelAddress;
export interface Endpoint {
    addresses: SubchannelAddress[];
}
export declare function endpointEqual(endpoint1: Endpoint, endpoint2: Endpoint): boolean;
export declare function endpointToString(endpoint: Endpoint): string;
export declare function endpointHasAddress(endpoint: Endpoint, expectedAddress: SubchannelAddress): boolean;
export declare class EndpointMap<ValueType> {
    private map;
    get size(): number;
    getForSubchannelAddress(address: SubchannelAddress): ValueType | undefined;
    /**
     * Delete any entries in this map with keys that are not in endpoints
     * @param endpoints
     */
    deleteMissing(endpoints: Endpoint[]): ValueType[];
    get(endpoint: Endpoint): ValueType | undefined;
    set(endpoint: Endpoint, mapEntry: ValueType): void;
    delete(endpoint: Endpoint): void;
    has(endpoint: Endpoint): boolean;
    clear(): void;
    keys(): IterableIterator<Endpoint>;
    values(): IterableIterator<ValueType>;
    entries(): IterableIterator<[Endpoint, ValueType]>;
}
"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointMap = void 0;
exports.isTcpSubchannelAddress = isTcpSubchannelAddress;
exports.subchannelAddressEqual = subchannelAddressEqual;
exports.subchannelAddressToString = subchannelAddressToString;
exports.stringToSubchannelAddress = stringToSubchannelAddress;
exports.endpointEqual = endpointEqual;
exports.endpointToString = endpointToString;
exports.endpointHasAddress = endpointHasAddress;
const net_1 = require("net");
function isTcpSubchannelAddress(address) {
    return 'port' in address;
}
function subchannelAddressEqual(address1, address2) {
    if (!address1 && !address2) {
        return true;
    }
    if (!address1 || !address2) {
        return false;
    }
    if (isTcpSubchannelAddress(address1)) {
        return (isTcpSubchannelAddress(address2) &&
            address1.host === address2.host &&
            address1.port === address2.port);
    }
    else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
    }
}
function subchannelAddressToString(address) {
    if (isTcpSubchannelAddress(address)) {
        if ((0, net_1.isIPv6)(address.host)) {
            return '[' + address.host + ']:' + address.port;
        }
        else {
            return address.host + ':' + address.port;
        }
    }
    else {
        return address.path;
    }
}
const DEFAULT_PORT = 443;
function stringToSubchannelAddress(addressString, port) {
    if ((0, net_1.isIP)(addressString)) {
        return {
            host: addressString,
            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,
        };
    }
    else {
        return {
            path: addressString,
        };
    }
}
function endpointEqual(endpoint1, endpoint2) {
    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
    }
    for (let i = 0; i < endpoint1.addresses.length; i++) {
        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {
            return false;
        }
    }
    return true;
}
function endpointToString(endpoint) {
    return ('[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']');
}
function endpointHasAddress(endpoint, expectedAddress) {
    for (const address of endpoint.addresses) {
        if (subchannelAddressEqual(address, expectedAddress)) {
            return true;
        }
    }
    return false;
}
function endpointEqualUnordered(endpoint1, endpoint2) {
    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
    }
    for (const address1 of endpoint1.addresses) {
        let matchFound = false;
        for (const address2 of endpoint2.addresses) {
            if (subchannelAddressEqual(address1, address2)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
class EndpointMap {
    constructor() {
        this.map = new Set();
    }
    get size() {
        return this.map.size;
    }
    getForSubchannelAddress(address) {
        for (const entry of this.map) {
            if (endpointHasAddress(entry.key, address)) {
                return entry.value;
            }
        }
        return undefined;
    }
    /**
     * Delete any entries in this map with keys that are not in endpoints
     * @param endpoints
     */
    deleteMissing(endpoints) {
        const removedValues = [];
        for (const entry of this.map) {
            let foundEntry = false;
            for (const endpoint of endpoints) {
                if (endpointEqualUnordered(endpoint, entry.key)) {
                    foundEntry = true;
                }
            }
            if (!foundEntry) {
                removedValues.push(entry.value);
                this.map.delete(entry);
            }
        }
        return removedValues;
    }
    get(endpoint) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                return entry.value;
            }
        }
        return undefined;
    }
    set(endpoint, mapEntry) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                entry.value = mapEntry;
                return;
            }
        }
        this.map.add({ key: endpoint, value: mapEntry });
    }
    delete(endpoint) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                this.map.delete(entry);
                return;
            }
        }
    }
    has(endpoint) {
        for (const entry of this.map) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
                return true;
            }
        }
        return false;
    }
    clear() {
        this.map.clear();
    }
    *keys() {
        for (const entry of this.map) {
            yield entry.key;
        }
    }
    *values() {
        for (const entry of this.map) {
            yield entry.value;
        }
    }
    *entries() {
        for (const entry of this.map) {
            yield [entry.key, entry.value];
        }
    }
}
exports.EndpointMap = EndpointMap;
//# sourceMappingURL=subchannel-address.js.map{"version":3,"file":"subchannel-address.js","sourceRoot":"","sources":["../../src/subchannel-address.ts"],"names":[],"mappings":"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"}import * as http2 from 'http2';
import { Status } from './constants';
import { InterceptingListener, MessageContext, StatusObject } from './call-interface';
import { CallEventTracker, Transport } from './transport';
export interface SubchannelCall {
    cancelWithStatus(status: Status, details: string): void;
    getPeer(): string;
    sendMessageWithContext(context: MessageContext, message: Buffer): void;
    startRead(): void;
    halfClose(): void;
    getCallNumber(): number;
    getDeadlineInfo(): string[];
}
export interface StatusObjectWithRstCode extends StatusObject {
    rstCode?: number;
}
export interface SubchannelCallInterceptingListener extends InterceptingListener {
    onReceiveStatus(status: StatusObjectWithRstCode): void;
}
export declare class Http2SubchannelCall implements SubchannelCall {
    private readonly http2Stream;
    private readonly callEventTracker;
    private readonly listener;
    private readonly transport;
    private readonly callId;
    private decoder;
    private isReadFilterPending;
    private isPushPending;
    private canPush;
    /**
     * Indicates that an 'end' event has come from the http2 stream, so there
     * will be no more data events.
     */
    private readsClosed;
    private statusOutput;
    private unpushedReadMessages;
    private httpStatusCode;
    private finalStatus;
    private internalError;
    private serverEndedCall;
    constructor(http2Stream: http2.ClientHttp2Stream, callEventTracker: CallEventTracker, listener: SubchannelCallInterceptingListener, transport: Transport, callId: number);
    getDeadlineInfo(): string[];
    onDisconnect(): void;
    private outputStatus;
    private trace;
    /**
     * On first call, emits a 'status' event with the given StatusObject.
     * Subsequent calls are no-ops.
     * @param status The status of the call.
     */
    private endCall;
    private maybeOutputStatus;
    private push;
    private tryPush;
    private handleTrailers;
    private destroyHttp2Stream;
    cancelWithStatus(status: Status, details: string): void;
    getStatus(): StatusObject | null;
    getPeer(): string;
    getCallNumber(): number;
    startRead(): void;
    sendMessageWithContext(context: MessageContext, message: Buffer): void;
    halfClose(): void;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Http2SubchannelCall = void 0;
const http2 = require("http2");
const os = require("os");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const stream_decoder_1 = require("./stream-decoder");
const logging = require("./logging");
const constants_2 = require("./constants");
const TRACER_NAME = 'subchannel_call';
/**
 * Should do approximately the same thing as util.getSystemErrorName but the
 * TypeScript types don't have that function for some reason so I just made my
 * own.
 * @param errno
 */
function getSystemErrorName(errno) {
    for (const [name, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
            return name;
        }
    }
    return 'Unknown system error ' + errno;
}
function mapHttpStatusCode(code) {
    const details = `Received HTTP status code ${code}`;
    let mappedStatusCode;
    switch (code) {
        // TODO(murgatroid99): handle 100 and 101
        case 400:
            mappedStatusCode = constants_1.Status.INTERNAL;
            break;
        case 401:
            mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
            break;
        case 403:
            mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
            break;
        case 404:
            mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
            break;
        case 429:
        case 502:
        case 503:
        case 504:
            mappedStatusCode = constants_1.Status.UNAVAILABLE;
            break;
        default:
            mappedStatusCode = constants_1.Status.UNKNOWN;
    }
    return {
        code: mappedStatusCode,
        details: details,
        metadata: new metadata_1.Metadata()
    };
}
class Http2SubchannelCall {
    constructor(http2Stream, callEventTracker, listener, transport, callId) {
        var _a;
        this.http2Stream = http2Stream;
        this.callEventTracker = callEventTracker;
        this.listener = listener;
        this.transport = transport;
        this.callId = callId;
        this.isReadFilterPending = false;
        this.isPushPending = false;
        this.canPush = false;
        /**
         * Indicates that an 'end' event has come from the http2 stream, so there
         * will be no more data events.
         */
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        // This is populated (non-null) if and only if the call has ended
        this.finalStatus = null;
        this.internalError = null;
        this.serverEndedCall = false;
        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);
        http2Stream.on('response', (headers, flags) => {
            let headersString = '';
            for (const header of Object.keys(headers)) {
                headersString += '\t\t' + header + ': ' + headers[header] + '\n';
            }
            this.trace('Received server headers:\n' + headersString);
            this.httpStatusCode = headers[':status'];
            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
                this.handleTrailers(headers);
            }
            else {
                let metadata;
                try {
                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);
                }
                catch (error) {
                    this.endCall({
                        code: constants_1.Status.UNKNOWN,
                        details: error.message,
                        metadata: new metadata_1.Metadata(),
                    });
                    return;
                }
                this.listener.onReceiveMetadata(metadata);
            }
        });
        http2Stream.on('trailers', (headers) => {
            this.handleTrailers(headers);
        });
        http2Stream.on('data', (data) => {
            /* If the status has already been output, allow the http2 stream to
             * drain without processing the data. */
            if (this.statusOutput) {
                return;
            }
            this.trace('receive HTTP/2 data frame of length ' + data.length);
            let messages;
            try {
                messages = this.decoder.write(data);
            }
            catch (e) {
                this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);
                return;
            }
            for (const message of messages) {
                this.trace('parsed message of length ' + message.length);
                this.callEventTracker.addMessageReceived();
                this.tryPush(message);
            }
        });
        http2Stream.on('end', () => {
            this.readsClosed = true;
            this.maybeOutputStatus();
        });
        http2Stream.on('close', () => {
            this.serverEndedCall = true;
            /* Use process.next tick to ensure that this code happens after any
             * "error" event that may be emitted at about the same time, so that
             * we can bubble up the error message from that event. */
            process.nextTick(() => {
                var _a;
                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);
                /* If we have a final status with an OK status code, that means that
                 * we have received all of the messages and we have processed the
                 * trailers and the call completed successfully, so it doesn't matter
                 * how the stream ends after that */
                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                    return;
                }
                let code;
                let details = '';
                switch (http2Stream.rstCode) {
                    case http2.constants.NGHTTP2_NO_ERROR:
                        /* If we get a NO_ERROR code and we already have a status, the
                         * stream completed properly and we just haven't fully processed
                         * it yet */
                        if (this.finalStatus !== null) {
                            return;
                        }
                        if (this.httpStatusCode && this.httpStatusCode !== 200) {
                            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
                            code = mappedStatus.code;
                            details = mappedStatus.details;
                        }
                        else {
                            code = constants_1.Status.INTERNAL;
                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
                        }
                        break;
                    case http2.constants.NGHTTP2_REFUSED_STREAM:
                        code = constants_1.Status.UNAVAILABLE;
                        details = 'Stream refused by server';
                        break;
                    case http2.constants.NGHTTP2_CANCEL:
                        code = constants_1.Status.CANCELLED;
                        details = 'Call cancelled';
                        break;
                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                        code = constants_1.Status.RESOURCE_EXHAUSTED;
                        details = 'Bandwidth exhausted or memory limit exceeded';
                        break;
                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                        code = constants_1.Status.PERMISSION_DENIED;
                        details = 'Protocol not secure enough';
                        break;
                    case http2.constants.NGHTTP2_INTERNAL_ERROR:
                        code = constants_1.Status.INTERNAL;
                        if (this.internalError === null) {
                            /* This error code was previously handled in the default case, and
                             * there are several instances of it online, so I wanted to
                             * preserve the original error message so that people find existing
                             * information in searches, but also include the more recognizable
                             * "Internal server error" message. */
                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
                        }
                        else {
                            if (this.internalError.code === 'ECONNRESET' ||
                                this.internalError.code === 'ETIMEDOUT') {
                                code = constants_1.Status.UNAVAILABLE;
                                details = this.internalError.message;
                            }
                            else {
                                /* The "Received RST_STREAM with code ..." error is preserved
                                 * here for continuity with errors reported online, but the
                                 * error message at the end will probably be more relevant in
                                 * most cases. */
                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                            }
                        }
                        break;
                    default:
                        code = constants_1.Status.INTERNAL;
                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
                }
                // This is a no-op if trailers were received at all.
                // This is OK, because status codes emitted here correspond to more
                // catastrophic issues that prevent us from receiving trailers in the
                // first place.
                this.endCall({
                    code,
                    details,
                    metadata: new metadata_1.Metadata(),
                    rstCode: http2Stream.rstCode,
                });
            });
        });
        http2Stream.on('error', (err) => {
            /* We need an error handler here to stop "Uncaught Error" exceptions
             * from bubbling up. However, errors here should all correspond to
             * "close" events, where we will handle the error more granularly */
            /* Specifically looking for stream errors that were *not* constructed
             * from a RST_STREAM response here:
             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
             */
            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {
                this.trace('Node error event: message=' +
                    err.message +
                    ' code=' +
                    err.code +
                    ' errno=' +
                    getSystemErrorName(err.errno) +
                    ' syscall=' +
                    err.syscall);
                this.internalError = err;
            }
            this.callEventTracker.onStreamEnd(false);
        });
    }
    getDeadlineInfo() {
        return [`remote_addr=${this.getPeer()}`];
    }
    onDisconnect() {
        this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: 'Connection dropped',
            metadata: new metadata_1.Metadata(),
        });
    }
    outputStatus() {
        /* Precondition: this.finalStatus !== null */
        if (!this.statusOutput) {
            this.statusOutput = true;
            this.trace('ended with status: code=' +
                this.finalStatus.code +
                ' details="' +
                this.finalStatus.details +
                '"');
            this.callEventTracker.onCallEnd(this.finalStatus);
            /* We delay the actual action of bubbling up the status to insulate the
             * cleanup code in this class from any errors that may be thrown in the
             * upper layers as a result of bubbling up the status. In particular,
             * if the status is not OK, the "error" event may be emitted
             * synchronously at the top level, which will result in a thrown error if
             * the user does not handle that event. */
            process.nextTick(() => {
                this.listener.onReceiveStatus(this.finalStatus);
            });
            /* Leave the http2 stream in flowing state to drain incoming messages, to
             * ensure that the stream closure completes. The call stream already does
             * not push more messages after the status is output, so the messages go
             * nowhere either way. */
            this.http2Stream.resume();
        }
    }
    trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);
    }
    /**
     * On first call, emits a 'status' event with the given StatusObject.
     * Subsequent calls are no-ops.
     * @param status The status of the call.
     */
    endCall(status) {
        /* If the status is OK and a new status comes in (e.g. from a
         * deserialization failure), that new status takes priority */
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
            this.finalStatus = status;
            this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
    }
    maybeOutputStatus() {
        if (this.finalStatus !== null) {
            /* The combination check of readsClosed and that the two message buffer
             * arrays are empty checks that there all incoming data has been fully
             * processed */
            if (this.finalStatus.code !== constants_1.Status.OK ||
                (this.readsClosed &&
                    this.unpushedReadMessages.length === 0 &&
                    !this.isReadFilterPending &&
                    !this.isPushPending)) {
                this.outputStatus();
            }
        }
    }
    push(message) {
        this.trace('pushing to reader message of length ' +
            (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        this.isPushPending = true;
        process.nextTick(() => {
            this.isPushPending = false;
            /* If we have already output the status any later messages should be
             * ignored, and can cause out-of-order operation errors higher up in the
             * stack. Checking as late as possible here to avoid any race conditions.
             */
            if (this.statusOutput) {
                return;
            }
            this.listener.onReceiveMessage(message);
            this.maybeOutputStatus();
        });
    }
    tryPush(messageBytes) {
        if (this.canPush) {
            this.http2Stream.pause();
            this.push(messageBytes);
        }
        else {
            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);
            this.unpushedReadMessages.push(messageBytes);
        }
    }
    handleTrailers(headers) {
        this.serverEndedCall = true;
        this.callEventTracker.onStreamEnd(true);
        let headersString = '';
        for (const header of Object.keys(headers)) {
            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
        }
        this.trace('Received server trailers:\n' + headersString);
        let metadata;
        try {
            metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        }
        catch (e) {
            metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let status;
        if (typeof metadataMap['grpc-status'] === 'string') {
            const receivedStatus = Number(metadataMap['grpc-status']);
            this.trace('received status code ' + receivedStatus + ' from server');
            metadata.remove('grpc-status');
            let details = '';
            if (typeof metadataMap['grpc-message'] === 'string') {
                try {
                    details = decodeURI(metadataMap['grpc-message']);
                }
                catch (e) {
                    details = metadataMap['grpc-message'];
                }
                metadata.remove('grpc-message');
                this.trace('received status details string "' + details + '" from server');
            }
            status = {
                code: receivedStatus,
                details: details,
                metadata: metadata
            };
        }
        else if (this.httpStatusCode) {
            status = mapHttpStatusCode(this.httpStatusCode);
            status.metadata = metadata;
        }
        else {
            status = {
                code: constants_1.Status.UNKNOWN,
                details: 'No status information received',
                metadata: metadata
            };
        }
        // This is a no-op if the call was already ended when handling headers.
        this.endCall(status);
    }
    destroyHttp2Stream() {
        var _a;
        // The http2 stream could already have been destroyed if cancelWithStatus
        // is called in response to an internal http2 error.
        if (this.http2Stream.destroyed) {
            return;
        }
        /* If the server ended the call, sending an RST_STREAM is redundant, so we
         * just half close on the client side instead to finish closing the stream.
         */
        if (this.serverEndedCall) {
            this.http2Stream.end();
        }
        else {
            /* If the call has ended with an OK status, communicate that when closing
             * the stream, partly to avoid a situation in which we detect an error
             * RST_STREAM as a result after we have the status */
            let code;
            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                code = http2.constants.NGHTTP2_NO_ERROR;
            }
            else {
                code = http2.constants.NGHTTP2_CANCEL;
            }
            this.trace('close http2 stream with code ' + code);
            this.http2Stream.close(code);
        }
    }
    cancelWithStatus(status, details) {
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
    }
    getStatus() {
        return this.finalStatus;
    }
    getPeer() {
        return this.transport.getPeerName();
    }
    getCallNumber() {
        return this.callId;
    }
    startRead() {
        /* If the stream has ended with an error, we should not emit any more
         * messages and we should communicate that the stream has ended */
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
            this.readsClosed = true;
            this.maybeOutputStatus();
            return;
        }
        this.canPush = true;
        if (this.unpushedReadMessages.length > 0) {
            const nextMessage = this.unpushedReadMessages.shift();
            this.push(nextMessage);
            return;
        }
        /* Only resume reading from the http2Stream if we don't have any pending
         * messages to emit */
        this.http2Stream.resume();
    }
    sendMessageWithContext(context, message) {
        this.trace('write() called with message of length ' + message.length);
        const cb = (error) => {
            /* nextTick here ensures that no stream action can be taken in the call
             * stack of the write callback, in order to hopefully work around
             * https://github.com/nodejs/node/issues/49147 */
            process.nextTick(() => {
                var _a;
                let code = constants_1.Status.UNAVAILABLE;
                if ((error === null || error === void 0 ? void 0 : error.code) ===
                    'ERR_STREAM_WRITE_AFTER_END') {
                    code = constants_1.Status.INTERNAL;
                }
                if (error) {
                    this.cancelWithStatus(code, `Write error: ${error.message}`);
                }
                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
            });
        };
        this.trace('sending data chunk of length ' + message.length);
        this.callEventTracker.addMessageSent();
        try {
            this.http2Stream.write(message, cb);
        }
        catch (error) {
            this.endCall({
                code: constants_1.Status.UNAVAILABLE,
                details: `Write failed with error ${error.message}`,
                metadata: new metadata_1.Metadata(),
            });
        }
    }
    halfClose() {
        this.trace('end() called');
        this.trace('calling end() on HTTP/2 stream');
        this.http2Stream.end();
    }
}
exports.Http2SubchannelCall = Http2SubchannelCall;
//# sourceMappingURL=subchannel-call.js.map{"version":3,"file":"subchannel-call.js","sourceRoot":"","sources":["../../src/subchannel-call.ts"],"names":[],"mappings":"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"}import type { SubchannelRef } from './channelz';
import { ConnectivityState } from './connectivity-state';
import { Subchannel } from './subchannel';
export type ConnectivityStateListener = (subchannel: SubchannelInterface, previousState: ConnectivityState, newState: ConnectivityState, keepaliveTime: number, errorMessage?: string) => void;
export type HealthListener = (healthy: boolean) => void;
/**
 * This is an interface for load balancing policies to use to interact with
 * subchannels. This allows load balancing policies to wrap and unwrap
 * subchannels.
 *
 * Any load balancing policy that wraps subchannels must unwrap the subchannel
 * in the picker, so that other load balancing policies consistently have
 * access to their own wrapper objects.
 */
export interface SubchannelInterface {
    getConnectivityState(): ConnectivityState;
    addConnectivityStateListener(listener: ConnectivityStateListener): void;
    removeConnectivityStateListener(listener: ConnectivityStateListener): void;
    startConnecting(): void;
    getAddress(): string;
    throttleKeepalive(newKeepaliveTime: number): void;
    ref(): void;
    unref(): void;
    getChannelzRef(): SubchannelRef;
    isHealthy(): boolean;
    addHealthStateWatcher(listener: HealthListener): void;
    removeHealthStateWatcher(listener: HealthListener): void;
    /**
     * If this is a wrapper, return the wrapped subchannel, otherwise return this
     */
    getRealSubchannel(): Subchannel;
    /**
     * Returns true if this and other both proxy the same underlying subchannel.
     * Can be used instead of directly accessing getRealSubchannel to allow mocks
     * to avoid implementing getRealSubchannel
     */
    realSubchannelEquals(other: SubchannelInterface): boolean;
}
export declare abstract class BaseSubchannelWrapper implements SubchannelInterface {
    protected child: SubchannelInterface;
    private healthy;
    private healthListeners;
    constructor(child: SubchannelInterface);
    private updateHealthListeners;
    getConnectivityState(): ConnectivityState;
    addConnectivityStateListener(listener: ConnectivityStateListener): void;
    removeConnectivityStateListener(listener: ConnectivityStateListener): void;
    startConnecting(): void;
    getAddress(): string;
    throttleKeepalive(newKeepaliveTime: number): void;
    ref(): void;
    unref(): void;
    getChannelzRef(): SubchannelRef;
    isHealthy(): boolean;
    addHealthStateWatcher(listener: HealthListener): void;
    removeHealthStateWatcher(listener: HealthListener): void;
    protected setHealthy(healthy: boolean): void;
    getRealSubchannel(): Subchannel;
    realSubchannelEquals(other: SubchannelInterface): boolean;
}
"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSubchannelWrapper = void 0;
class BaseSubchannelWrapper {
    constructor(child) {
        this.child = child;
        this.healthy = true;
        this.healthListeners = new Set();
        child.addHealthStateWatcher(childHealthy => {
            /* A change to the child health state only affects this wrapper's overall
             * health state if this wrapper is reporting healthy. */
            if (this.healthy) {
                this.updateHealthListeners();
            }
        });
    }
    updateHealthListeners() {
        for (const listener of this.healthListeners) {
            listener(this.isHealthy());
        }
    }
    getConnectivityState() {
        return this.child.getConnectivityState();
    }
    addConnectivityStateListener(listener) {
        this.child.addConnectivityStateListener(listener);
    }
    removeConnectivityStateListener(listener) {
        this.child.removeConnectivityStateListener(listener);
    }
    startConnecting() {
        this.child.startConnecting();
    }
    getAddress() {
        return this.child.getAddress();
    }
    throttleKeepalive(newKeepaliveTime) {
        this.child.throttleKeepalive(newKeepaliveTime);
    }
    ref() {
        this.child.ref();
    }
    unref() {
        this.child.unref();
    }
    getChannelzRef() {
        return this.child.getChannelzRef();
    }
    isHealthy() {
        return this.healthy && this.child.isHealthy();
    }
    addHealthStateWatcher(listener) {
        this.healthListeners.add(listener);
    }
    removeHealthStateWatcher(listener) {
        this.healthListeners.delete(listener);
    }
    setHealthy(healthy) {
        if (healthy !== this.healthy) {
            this.healthy = healthy;
            /* A change to this wrapper's health state only affects the overall
             * reported health state if the child is healthy. */
            if (this.child.isHealthy()) {
                this.updateHealthListeners();
            }
        }
    }
    getRealSubchannel() {
        return this.child.getRealSubchannel();
    }
    realSubchannelEquals(other) {
        return this.getRealSubchannel() === other.getRealSubchannel();
    }
}
exports.BaseSubchannelWrapper = BaseSubchannelWrapper;
//# sourceMappingURL=subchannel-interface.js.map{"version":3,"file":"subchannel-interface.js","sourceRoot":"","sources":["../../src/subchannel-interface.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAkDH,MAAsB,qBAAqB;IAGzC,YAAsB,KAA0B;QAA1B,UAAK,GAAL,KAAK,CAAqB;QAFxC,YAAO,GAAG,IAAI,CAAC;QACf,oBAAe,GAAwB,IAAI,GAAG,EAAE,CAAC;QAEvD,KAAK,CAAC,qBAAqB,CAAC,YAAY,CAAC,EAAE;YACzC;oEACwD;YACxD,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;gBACjB,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC/B,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,qBAAqB;QAC3B,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YAC5C,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;QAC7B,CAAC;IACH,CAAC;IAED,oBAAoB;QAClB,OAAO,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE,CAAC;IAC3C,CAAC;IACD,4BAA4B,CAAC,QAAmC;QAC9D,IAAI,CAAC,KAAK,CAAC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;IACpD,CAAC;IACD,+BAA+B,CAAC,QAAmC;QACjE,IAAI,CAAC,KAAK,CAAC,+BAA+B,CAAC,QAAQ,CAAC,CAAC;IACvD,CAAC;IACD,eAAe;QACb,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;IAC/B,CAAC;IACD,UAAU;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;IACjC,CAAC;IACD,iBAAiB,CAAC,gBAAwB;QACxC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC;IACjD,CAAC;IACD,GAAG;QACD,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;IACnB,CAAC;IACD,KAAK;QACH,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;IACrB,CAAC;IACD,cAAc;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC;IACrC,CAAC;IACD,SAAS;QACP,OAAO,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC;IAChD,CAAC;IACD,qBAAqB,CAAC,QAAwB;QAC5C,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IACD,wBAAwB,CAAC,QAAwB;QAC/C,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACxC,CAAC;IACS,UAAU,CAAC,OAAgB;QACnC,IAAI,OAAO,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;YAC7B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;YACvB;gEACoD;YACpD,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,EAAE,CAAC;gBAC3B,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC/B,CAAC;QACH,CAAC;IACH,CAAC;IACD,iBAAiB;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC;IACxC,CAAC;IACD,oBAAoB,CAAC,KAA0B;QAC7C,OAAO,IAAI,CAAC,iBAAiB,EAAE,KAAK,KAAK,CAAC,iBAAiB,EAAE,CAAC;IAChE,CAAC;CACF;AAvED,sDAuEC"}import { ChannelOptions } from './channel-options';
import { Subchannel } from './subchannel';
import { SubchannelAddress } from './subchannel-address';
import { ChannelCredentials } from './channel-credentials';
import { GrpcUri } from './uri-parser';
export declare class SubchannelPool {
    private pool;
    /**
     * A timer of a task performing a periodic subchannel cleanup.
     */
    private cleanupTimer;
    /**
     * A pool of subchannels use for making connections. Subchannels with the
     * exact same parameters will be reused.
     */
    constructor();
    /**
     * Unrefs all unused subchannels and cancels the cleanup task if all
     * subchannels have been unrefed.
     */
    unrefUnusedSubchannels(): void;
    /**
     * Ensures that the cleanup task is spawned.
     */
    ensureCleanupTask(): void;
    /**
     * Get a subchannel if one already exists with exactly matching parameters.
     * Otherwise, create and save a subchannel with those parameters.
     * @param channelTarget
     * @param subchannelTarget
     * @param channelArguments
     * @param channelCredentials
     */
    getOrCreateSubchannel(channelTargetUri: GrpcUri, subchannelTarget: SubchannelAddress, channelArguments: ChannelOptions, channelCredentials: ChannelCredentials): Subchannel;
}
/**
 * Get either the global subchannel pool, or a new subchannel pool.
 * @param global
 */
export declare function getSubchannelPool(global: boolean): SubchannelPool;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubchannelPool = void 0;
exports.getSubchannelPool = getSubchannelPool;
const channel_options_1 = require("./channel-options");
const subchannel_1 = require("./subchannel");
const subchannel_address_1 = require("./subchannel-address");
const uri_parser_1 = require("./uri-parser");
const transport_1 = require("./transport");
// 10 seconds in milliseconds. This value is arbitrary.
/**
 * The amount of time in between checks for dropping subchannels that have no
 * other references
 */
const REF_CHECK_INTERVAL = 10000;
class SubchannelPool {
    /**
     * A pool of subchannels use for making connections. Subchannels with the
     * exact same parameters will be reused.
     */
    constructor() {
        this.pool = Object.create(null);
        /**
         * A timer of a task performing a periodic subchannel cleanup.
         */
        this.cleanupTimer = null;
    }
    /**
     * Unrefs all unused subchannels and cancels the cleanup task if all
     * subchannels have been unrefed.
     */
    unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        /* These objects are created with Object.create(null), so they do not
         * have a prototype, which means that for (... in ...) loops over them
         * do not need to be filtered */
        // eslint-disable-disable-next-line:forin
        for (const channelTarget in this.pool) {
            const subchannelObjArray = this.pool[channelTarget];
            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());
            if (refedSubchannels.length > 0) {
                allSubchannelsUnrefed = false;
            }
            /* For each subchannel in the pool, try to unref it if it has
             * exactly one ref (which is the ref from the pool itself). If that
             * does happen, remove the subchannel from the pool */
            this.pool[channelTarget] = refedSubchannels;
        }
        /* Currently we do not delete keys with empty values. If that results
         * in significant memory usage we should change it. */
        // Cancel the cleanup task if all subchannels have been unrefed.
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = null;
        }
    }
    /**
     * Ensures that the cleanup task is spawned.
     */
    ensureCleanupTask() {
        var _a, _b;
        if (this.cleanupTimer === null) {
            this.cleanupTimer = setInterval(() => {
                this.unrefUnusedSubchannels();
            }, REF_CHECK_INTERVAL);
            // Unref because this timer should not keep the event loop running.
            // Call unref only if it exists to address electron/electron#21162
            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
    }
    /**
     * Get a subchannel if one already exists with exactly matching parameters.
     * Otherwise, create and save a subchannel with those parameters.
     * @param channelTarget
     * @param subchannelTarget
     * @param channelArguments
     * @param channelCredentials
     */
    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
        if (channelTarget in this.pool) {
            const subchannelObjArray = this.pool[channelTarget];
            for (const subchannelObj of subchannelObjArray) {
                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&
                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&
                    channelCredentials._equals(subchannelObj.channelCredentials)) {
                    return subchannelObj.subchannel;
                }
            }
        }
        // If we get here, no matching subchannel was found
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
        if (!(channelTarget in this.pool)) {
            this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
            subchannelAddress: subchannelTarget,
            channelArguments,
            channelCredentials,
            subchannel,
        });
        subchannel.ref();
        return subchannel;
    }
}
exports.SubchannelPool = SubchannelPool;
const globalSubchannelPool = new SubchannelPool();
/**
 * Get either the global subchannel pool, or a new subchannel pool.
 * @param global
 */
function getSubchannelPool(global) {
    if (global) {
        return globalSubchannelPool;
    }
    else {
        return new SubchannelPool();
    }
}
//# sourceMappingURL=subchannel-pool.js.map{"version":3,"file":"subchannel-pool.js","sourceRoot":"","sources":["../../src/subchannel-pool.ts"],"names":[],"mappings":"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"}import { ChannelCredentials } from './channel-credentials';
import { Metadata } from './metadata';
import { ChannelOptions } from './channel-options';
import { ConnectivityState } from './connectivity-state';
import { GrpcUri } from './uri-parser';
import { SubchannelAddress } from './subchannel-address';
import { SubchannelRef } from './channelz';
import { ConnectivityStateListener, SubchannelInterface } from './subchannel-interface';
import { SubchannelCallInterceptingListener } from './subchannel-call';
import { SubchannelCall } from './subchannel-call';
import { SubchannelConnector } from './transport';
export declare class Subchannel {
    private channelTarget;
    private subchannelAddress;
    private options;
    private credentials;
    private connector;
    /**
     * The subchannel's current connectivity state. Invariant: `session` === `null`
     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
     */
    private connectivityState;
    /**
     * The underlying http2 session used to make requests.
     */
    private transport;
    /**
     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
     * CONNECTING instead of IDLE when the backoff timeout ends.
     */
    private continueConnecting;
    /**
     * A list of listener functions that will be called whenever the connectivity
     * state changes. Will be modified by `addConnectivityStateListener` and
     * `removeConnectivityStateListener`
     */
    private stateListeners;
    private backoffTimeout;
    private keepaliveTime;
    /**
     * Tracks channels and subchannel pools with references to this subchannel
     */
    private refcount;
    /**
     * A string representation of the subchannel address, for logging/tracing
     */
    private subchannelAddressString;
    private readonly channelzEnabled;
    private channelzRef;
    private channelzTrace;
    private callTracker;
    private childrenTracker;
    private streamTracker;
    /**
     * A class representing a connection to a single backend.
     * @param channelTarget The target string for the channel as a whole
     * @param subchannelAddress The address for the backend that this subchannel
     *     will connect to
     * @param options The channel options, plus any specific subchannel options
     *     for this subchannel
     * @param credentials The channel credentials used to establish this
     *     connection
     */
    constructor(channelTarget: GrpcUri, subchannelAddress: SubchannelAddress, options: ChannelOptions, credentials: ChannelCredentials, connector: SubchannelConnector);
    private getChannelzInfo;
    private trace;
    private refTrace;
    private handleBackoffTimer;
    /**
     * Start a backoff timer with the current nextBackoff timeout
     */
    private startBackoff;
    private stopBackoff;
    private startConnectingInternal;
    /**
     * Initiate a state transition from any element of oldStates to the new
     * state. If the current connectivityState is not in oldStates, do nothing.
     * @param oldStates The set of states to transition from
     * @param newState The state to transition to
     * @returns True if the state changed, false otherwise
     */
    private transitionToState;
    ref(): void;
    unref(): void;
    unrefIfOneRef(): boolean;
    createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener): SubchannelCall;
    /**
     * If the subchannel is currently IDLE, start connecting and switch to the
     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
     * the next time it would transition to IDLE, start connecting again instead.
     * Otherwise, do nothing.
     */
    startConnecting(): void;
    /**
     * Get the subchannel's current connectivity state.
     */
    getConnectivityState(): ConnectivityState;
    /**
     * Add a listener function to be called whenever the subchannel's
     * connectivity state changes.
     * @param listener
     */
    addConnectivityStateListener(listener: ConnectivityStateListener): void;
    /**
     * Remove a listener previously added with `addConnectivityStateListener`
     * @param listener A reference to a function previously passed to
     *     `addConnectivityStateListener`
     */
    removeConnectivityStateListener(listener: ConnectivityStateListener): void;
    /**
     * Reset the backoff timeout, and immediately start connecting if in backoff.
     */
    resetBackoff(): void;
    getAddress(): string;
    getChannelzRef(): SubchannelRef;
    isHealthy(): boolean;
    addHealthStateWatcher(listener: (healthy: boolean) => void): void;
    removeHealthStateWatcher(listener: (healthy: boolean) => void): void;
    getRealSubchannel(): this;
    realSubchannelEquals(other: SubchannelInterface): boolean;
    throttleKeepalive(newKeepaliveTime: number): void;
}
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subchannel = void 0;
const connectivity_state_1 = require("./connectivity-state");
const backoff_timeout_1 = require("./backoff-timeout");
const logging = require("./logging");
const constants_1 = require("./constants");
const uri_parser_1 = require("./uri-parser");
const subchannel_address_1 = require("./subchannel-address");
const channelz_1 = require("./channelz");
const TRACER_NAME = 'subchannel';
/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
 * have a constant for the max signed 32 bit integer, so this is a simple way
 * to calculate it */
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
class Subchannel {
    /**
     * A class representing a connection to a single backend.
     * @param channelTarget The target string for the channel as a whole
     * @param subchannelAddress The address for the backend that this subchannel
     *     will connect to
     * @param options The channel options, plus any specific subchannel options
     *     for this subchannel
     * @param credentials The channel credentials used to establish this
     *     connection
     */
    constructor(channelTarget, subchannelAddress, options, credentials, connector) {
        var _a;
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials;
        this.connector = connector;
        /**
         * The subchannel's current connectivity state. Invariant: `session` === `null`
         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
         */
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        /**
         * The underlying http2 session used to make requests.
         */
        this.transport = null;
        /**
         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
         * CONNECTING instead of IDLE when the backoff timeout ends.
         */
        this.continueConnecting = false;
        /**
         * A list of listener functions that will be called whenever the connectivity
         * state changes. Will be modified by `addConnectivityStateListener` and
         * `removeConnectivityStateListener`
         */
        this.stateListeners = new Set();
        /**
         * Tracks channels and subchannel pools with references to this subchannel
         */
        this.refcount = 0;
        // Channelz info
        this.channelzEnabled = true;
        const backoffOptions = {
            initialDelay: options['grpc.initial_reconnect_backoff_ms'],
            maxDelay: options['grpc.max_reconnect_backoff_ms'],
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
            this.handleBackoffTimer();
        }, backoffOptions);
        this.backoffTimeout.unref();
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;
        if (options['grpc.enable_channelz'] === 0) {
            this.channelzEnabled = false;
            this.channelzTrace = new channelz_1.ChannelzTraceStub();
            this.callTracker = new channelz_1.ChannelzCallTrackerStub();
            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
        }
        else {
            this.channelzTrace = new channelz_1.ChannelzTrace();
            this.callTracker = new channelz_1.ChannelzCallTracker();
            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
            this.streamTracker = new channelz_1.ChannelzCallTracker();
        }
        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');
        this.trace('Subchannel constructed with options ' +
            JSON.stringify(options, undefined, 2));
    }
    getChannelzInfo() {
        return {
            state: this.connectivityState,
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            children: this.childrenTracker.getChildLists(),
            target: this.subchannelAddressString,
        };
    }
    trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
            this.channelzRef.id +
            ') ' +
            this.subchannelAddressString +
            ' ' +
            text);
    }
    refTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +
            this.channelzRef.id +
            ') ' +
            this.subchannelAddressString +
            ' ' +
            text);
    }
    handleBackoffTimer() {
        if (this.continueConnecting) {
            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
        }
        else {
            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
        }
    }
    /**
     * Start a backoff timer with the current nextBackoff timeout
     */
    startBackoff() {
        this.backoffTimeout.runOnce();
    }
    stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
    }
    startConnectingInternal() {
        let options = this.options;
        if (options['grpc.keepalive_time_ms']) {
            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });
        }
        this.connector
            .connect(this.subchannelAddress, this.credentials, options)
            .then(transport => {
            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
                this.transport = transport;
                if (this.channelzEnabled) {
                    this.childrenTracker.refChild(transport.getChannelzRef());
                }
                transport.addDisconnectListener(tooManyPings => {
                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
                    if (tooManyPings && this.keepaliveTime > 0) {
                        this.keepaliveTime *= 2;
                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
                    }
                });
            }
            else {
                /* If we can't transition from CONNECTING to READY here, we will
                 * not be using this transport, so release its resources. */
                transport.shutdown();
            }
        }, error => {
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
        });
    }
    /**
     * Initiate a state transition from any element of oldStates to the new
     * state. If the current connectivityState is not in oldStates, do nothing.
     * @param oldStates The set of states to transition from
     * @param newState The state to transition to
     * @returns True if the state changed, false otherwise
     */
    transitionToState(oldStates, newState, errorMessage) {
        var _a, _b;
        if (oldStates.indexOf(this.connectivityState) === -1) {
            return false;
        }
        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
        }
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
            case connectivity_state_1.ConnectivityState.READY:
                this.stopBackoff();
                break;
            case connectivity_state_1.ConnectivityState.CONNECTING:
                this.startBackoff();
                this.startConnectingInternal();
                this.continueConnecting = false;
                break;
            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
                if (this.channelzEnabled && this.transport) {
                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
                }
                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();
                this.transport = null;
                /* If the backoff timer has already ended by the time we get to the
                 * TRANSIENT_FAILURE state, we want to immediately transition out of
                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */
                if (!this.backoffTimeout.isRunning()) {
                    process.nextTick(() => {
                        this.handleBackoffTimer();
                    });
                }
                break;
            case connectivity_state_1.ConnectivityState.IDLE:
                if (this.channelzEnabled && this.transport) {
                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
                }
                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();
                this.transport = null;
                break;
            default:
                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of this.stateListeners) {
            listener(this, previousState, newState, this.keepaliveTime, errorMessage);
        }
        return true;
    }
    ref() {
        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));
        this.refcount += 1;
    }
    unref() {
        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));
        this.refcount -= 1;
        if (this.refcount === 0) {
            this.channelzTrace.addTrace('CT_INFO', 'Shutting down');
            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
            process.nextTick(() => {
                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
            });
        }
    }
    unrefIfOneRef() {
        if (this.refcount === 1) {
            this.unref();
            return true;
        }
        return false;
    }
    createCall(metadata, host, method, listener) {
        if (!this.transport) {
            throw new Error('Cannot create call, subchannel not READY');
        }
        let statsTracker;
        if (this.channelzEnabled) {
            this.callTracker.addCallStarted();
            this.streamTracker.addCallStarted();
            statsTracker = {
                onCallEnd: status => {
                    if (status.code === constants_1.Status.OK) {
                        this.callTracker.addCallSucceeded();
                    }
                    else {
                        this.callTracker.addCallFailed();
                    }
                },
            };
        }
        else {
            statsTracker = {};
        }
        return this.transport.createCall(metadata, host, method, listener, statsTracker);
    }
    /**
     * If the subchannel is currently IDLE, start connecting and switch to the
     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
     * the next time it would transition to IDLE, start connecting again instead.
     * Otherwise, do nothing.
     */
    startConnecting() {
        process.nextTick(() => {
            /* First, try to transition from IDLE to connecting. If that doesn't happen
             * because the state is not currently IDLE, check if it is
             * TRANSIENT_FAILURE, and if so indicate that it should go back to
             * connecting after the backoff timer ends. Otherwise do nothing */
            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                    this.continueConnecting = true;
                }
            }
        });
    }
    /**
     * Get the subchannel's current connectivity state.
     */
    getConnectivityState() {
        return this.connectivityState;
    }
    /**
     * Add a listener function to be called whenever the subchannel's
     * connectivity state changes.
     * @param listener
     */
    addConnectivityStateListener(listener) {
        this.stateListeners.add(listener);
    }
    /**
     * Remove a listener previously added with `addConnectivityStateListener`
     * @param listener A reference to a function previously passed to
     *     `addConnectivityStateListener`
     */
    removeConnectivityStateListener(listener) {
        this.stateListeners.delete(listener);
    }
    /**
     * Reset the backoff timeout, and immediately start connecting if in backoff.
     */
    resetBackoff() {
        process.nextTick(() => {
            this.backoffTimeout.reset();
            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
        });
    }
    getAddress() {
        return this.subchannelAddressString;
    }
    getChannelzRef() {
        return this.channelzRef;
    }
    isHealthy() {
        return true;
    }
    addHealthStateWatcher(listener) {
        // Do nothing with the listener
    }
    removeHealthStateWatcher(listener) {
        // Do nothing with the listener
    }
    getRealSubchannel() {
        return this;
    }
    realSubchannelEquals(other) {
        return other.getRealSubchannel() === this;
    }
    throttleKeepalive(newKeepaliveTime) {
        if (newKeepaliveTime > this.keepaliveTime) {
            this.keepaliveTime = newKeepaliveTime;
        }
    }
}
exports.Subchannel = Subchannel;
//# sourceMappingURL=subchannel.js.map{"version":3,"file":"subchannel.js","sourceRoot":"","sources":["../../src/subchannel.ts"],"names":[],"mappings":"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"}export declare const CIPHER_SUITES: string | undefined;
export declare function getDefaultRootsData(): Buffer | null;
"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CIPHER_SUITES = void 0;
exports.getDefaultRootsData = getDefaultRootsData;
const fs = require("fs");
exports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
const DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
let defaultRootsData = null;
function getDefaultRootsData() {
    if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
    }
    return null;
}
//# sourceMappingURL=tls-helpers.js.map{"version":3,"file":"tls-helpers.js","sourceRoot":"","sources":["../../src/tls-helpers.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAWH,kDAQC;AAjBD,yBAAyB;AAEZ,QAAA,aAAa,GACxB,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC;AAErC,MAAM,uBAAuB,GAAG,OAAO,CAAC,GAAG,CAAC,gCAAgC,CAAC;AAE7E,IAAI,gBAAgB,GAAkB,IAAI,CAAC;AAE3C,SAAgB,mBAAmB;IACjC,IAAI,uBAAuB,EAAE,CAAC;QAC5B,IAAI,gBAAgB,KAAK,IAAI,EAAE,CAAC;YAC9B,gBAAgB,GAAG,EAAE,CAAC,YAAY,CAAC,uBAAuB,CAAC,CAAC;QAC9D,CAAC;QACD,OAAO,gBAAgB,CAAC;IAC1B,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC"}import * as http2 from 'http2';
import { PartialStatusObject } from './call-interface';
import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { SocketRef } from './channelz';
import { SubchannelAddress } from './subchannel-address';
import { GrpcUri } from './uri-parser';
import { Http2SubchannelCall, SubchannelCall, SubchannelCallInterceptingListener } from './subchannel-call';
import { Metadata } from './metadata';
export interface CallEventTracker {
    addMessageSent(): void;
    addMessageReceived(): void;
    onCallEnd(status: PartialStatusObject): void;
    onStreamEnd(success: boolean): void;
}
export interface TransportDisconnectListener {
    (tooManyPings: boolean): void;
}
export interface Transport {
    getChannelzRef(): SocketRef;
    getPeerName(): string;
    getOptions(): ChannelOptions;
    createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener, subchannelCallStatsTracker: Partial<CallEventTracker>): SubchannelCall;
    addDisconnectListener(listener: TransportDisconnectListener): void;
    shutdown(): void;
}
declare class Http2Transport implements Transport {
    private session;
    private options;
    /**
     * Name of the remote server, if it is not the same as the subchannel
     * address, i.e. if connecting through an HTTP CONNECT proxy.
     */
    private remoteName;
    /**
     * The amount of time in between sending pings
     */
    private readonly keepaliveTimeMs;
    /**
     * The amount of time to wait for an acknowledgement after sending a ping
     */
    private readonly keepaliveTimeoutMs;
    /**
     * Indicates whether keepalive pings should be sent without any active calls
     */
    private readonly keepaliveWithoutCalls;
    /**
     * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.
     */
    private keepaliveTimer;
    /**
     * Indicates that the keepalive timer ran out while there were no active
     * calls, and a ping should be sent the next time a call starts.
     */
    private pendingSendKeepalivePing;
    private userAgent;
    private activeCalls;
    private subchannelAddressString;
    private disconnectListeners;
    private disconnectHandled;
    private channelzRef;
    private readonly channelzEnabled;
    private streamTracker;
    private keepalivesSent;
    private messagesSent;
    private messagesReceived;
    private lastMessageSentTimestamp;
    private lastMessageReceivedTimestamp;
    constructor(session: http2.ClientHttp2Session, subchannelAddress: SubchannelAddress, options: ChannelOptions, 
    /**
     * Name of the remote server, if it is not the same as the subchannel
     * address, i.e. if connecting through an HTTP CONNECT proxy.
     */
    remoteName: string | null);
    private getChannelzInfo;
    private trace;
    private keepaliveTrace;
    private flowControlTrace;
    private internalsTrace;
    /**
     * Indicate to the owner of this object that this transport should no longer
     * be used. That happens if the connection drops, or if the server sends a
     * GOAWAY.
     * @param tooManyPings If true, this was triggered by a GOAWAY with data
     * indicating that the session was closed becaues the client sent too many
     * pings.
     * @returns
     */
    private reportDisconnectToOwner;
    /**
     * Handle connection drops, but not GOAWAYs.
     */
    private handleDisconnect;
    addDisconnectListener(listener: TransportDisconnectListener): void;
    private canSendPing;
    private maybeSendPing;
    /**
     * Starts the keepalive ping timer if appropriate. If the timer already ran
     * out while there were no active requests, instead send a ping immediately.
     * If the ping timer is already running or a ping is currently in flight,
     * instead do nothing and wait for them to resolve.
     */
    private maybeStartKeepalivePingTimer;
    /**
     * Clears whichever keepalive timeout is currently active, if any.
     */
    private clearKeepaliveTimeout;
    private removeActiveCall;
    private addActiveCall;
    createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener, subchannelCallStatsTracker: Partial<CallEventTracker>): Http2SubchannelCall;
    getChannelzRef(): SocketRef;
    getPeerName(): string;
    getOptions(): ChannelOptions;
    shutdown(): void;
}
export interface SubchannelConnector {
    connect(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions): Promise<Transport>;
    shutdown(): void;
}
export declare class Http2SubchannelConnector implements SubchannelConnector {
    private channelTarget;
    private session;
    private isShutdown;
    constructor(channelTarget: GrpcUri);
    private trace;
    private createSession;
    connect(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions): Promise<Http2Transport>;
    shutdown(): void;
}
export {};
"use strict";
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Http2SubchannelConnector = void 0;
const http2 = require("http2");
const tls_1 = require("tls");
const channelz_1 = require("./channelz");
const constants_1 = require("./constants");
const http_proxy_1 = require("./http_proxy");
const logging = require("./logging");
const resolver_1 = require("./resolver");
const subchannel_address_1 = require("./subchannel-address");
const uri_parser_1 = require("./uri-parser");
const net = require("net");
const subchannel_call_1 = require("./subchannel-call");
const call_number_1 = require("./call-number");
const TRACER_NAME = 'transport';
const FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';
const clientVersion = require('../../package.json').version;
const { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
const KEEPALIVE_TIMEOUT_MS = 20000;
const tooManyPingsData = Buffer.from('too_many_pings', 'ascii');
class Http2Transport {
    constructor(session, subchannelAddress, options, 
    /**
     * Name of the remote server, if it is not the same as the subchannel
     * address, i.e. if connecting through an HTTP CONNECT proxy.
     */
    remoteName) {
        this.session = session;
        this.options = options;
        this.remoteName = remoteName;
        /**
         * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.
         */
        this.keepaliveTimer = null;
        /**
         * Indicates that the keepalive timer ran out while there were no active
         * calls, and a ping should be sent the next time a call starts.
         */
        this.pendingSendKeepalivePing = false;
        this.activeCalls = new Set();
        this.disconnectListeners = [];
        this.disconnectHandled = false;
        this.channelzEnabled = true;
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
        /* Populate subchannelAddressString and channelzRef before doing anything
         * else, because they are used in the trace methods. */
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        if (options['grpc.enable_channelz'] === 0) {
            this.channelzEnabled = false;
            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
        }
        else {
            this.streamTracker = new channelz_1.ChannelzCallTracker();
        }
        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        // Build user-agent string.
        this.userAgent = [
            options['grpc.primary_user_agent'],
            `grpc-node-js/${clientVersion}`,
            options['grpc.secondary_user_agent'],
        ]
            .filter(e => e)
            .join(' '); // remove falsey values first
        if ('grpc.keepalive_time_ms' in options) {
            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];
        }
        else {
            this.keepaliveTimeMs = -1;
        }
        if ('grpc.keepalive_timeout_ms' in options) {
            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];
        }
        else {
            this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        }
        if ('grpc.keepalive_permit_without_calls' in options) {
            this.keepaliveWithoutCalls =
                options['grpc.keepalive_permit_without_calls'] === 1;
        }
        else {
            this.keepaliveWithoutCalls = false;
        }
        session.once('close', () => {
            this.trace('session closed');
            this.handleDisconnect();
        });
        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {
            let tooManyPings = false;
            /* See the last paragraph of
             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
                opaqueData &&
                opaqueData.equals(tooManyPingsData)) {
                tooManyPings = true;
            }
            this.trace('connection closed by GOAWAY with code ' +
                errorCode +
                ' and data ' +
                (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));
            this.reportDisconnectToOwner(tooManyPings);
        });
        session.once('error', error => {
            /* Do nothing here. Any error should also trigger a close event, which is
             * where we want to handle that.  */
            this.trace('connection closed with error ' + error.message);
        });
        if (logging.isTracerEnabled(TRACER_NAME)) {
            session.on('remoteSettings', (settings) => {
                this.trace('new settings received' +
                    (this.session !== session ? ' on the old connection' : '') +
                    ': ' +
                    JSON.stringify(settings));
            });
            session.on('localSettings', (settings) => {
                this.trace('local settings acknowledged by remote' +
                    (this.session !== session ? ' on the old connection' : '') +
                    ': ' +
                    JSON.stringify(settings));
            });
        }
        /* Start the keepalive timer last, because this can trigger trace logs,
         * which should only happen after everything else is set up. */
        if (this.keepaliveWithoutCalls) {
            this.maybeStartKeepalivePingTimer();
        }
    }
    getChannelzInfo() {
        var _a, _b, _c;
        const sessionSocket = this.session.socket;
        const remoteAddress = sessionSocket.remoteAddress
            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
            : null;
        const localAddress = sessionSocket.localAddress
            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
            : null;
        let tlsInfo;
        if (this.session.encrypted) {
            const tlsSocket = sessionSocket;
            const cipherInfo = tlsSocket.getCipher();
            const certificate = tlsSocket.getCertificate();
            const peerCertificate = tlsSocket.getPeerCertificate();
            tlsInfo = {
                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
                remoteCertificate: peerCertificate && 'raw' in peerCertificate
                    ? peerCertificate.raw
                    : null,
            };
        }
        else {
            tlsInfo = null;
        }
        const socketInfo = {
            remoteAddress: remoteAddress,
            localAddress: localAddress,
            security: tlsInfo,
            remoteName: this.remoteName,
            streamsStarted: this.streamTracker.callsStarted,
            streamsSucceeded: this.streamTracker.callsSucceeded,
            streamsFailed: this.streamTracker.callsFailed,
            messagesSent: this.messagesSent,
            messagesReceived: this.messagesReceived,
            keepAlivesSent: this.keepalivesSent,
            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
            lastRemoteStreamCreatedTimestamp: null,
            lastMessageSentTimestamp: this.lastMessageSentTimestamp,
            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,
        };
        return socketInfo;
    }
    trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
            this.channelzRef.id +
            ') ' +
            this.subchannelAddressString +
            ' ' +
            text);
    }
    keepaliveTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +
            this.channelzRef.id +
            ') ' +
            this.subchannelAddressString +
            ' ' +
            text);
    }
    flowControlTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +
            this.channelzRef.id +
            ') ' +
            this.subchannelAddressString +
            ' ' +
            text);
    }
    internalsTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +
            this.channelzRef.id +
            ') ' +
            this.subchannelAddressString +
            ' ' +
            text);
    }
    /**
     * Indicate to the owner of this object that this transport should no longer
     * be used. That happens if the connection drops, or if the server sends a
     * GOAWAY.
     * @param tooManyPings If true, this was triggered by a GOAWAY with data
     * indicating that the session was closed becaues the client sent too many
     * pings.
     * @returns
     */
    reportDisconnectToOwner(tooManyPings) {
        if (this.disconnectHandled) {
            return;
        }
        this.disconnectHandled = true;
        this.disconnectListeners.forEach(listener => listener(tooManyPings));
    }
    /**
     * Handle connection drops, but not GOAWAYs.
     */
    handleDisconnect() {
        this.clearKeepaliveTimeout();
        this.reportDisconnectToOwner(false);
        /* Give calls an event loop cycle to finish naturally before reporting the
         * disconnnection to them. */
        setImmediate(() => {
            for (const call of this.activeCalls) {
                call.onDisconnect();
            }
            this.session.destroy();
        });
    }
    addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
    }
    canSendPing() {
        return (!this.session.destroyed &&
            this.keepaliveTimeMs > 0 &&
            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));
    }
    maybeSendPing() {
        var _a, _b;
        if (!this.canSendPing()) {
            this.pendingSendKeepalivePing = true;
            return;
        }
        if (this.keepaliveTimer) {
            console.error('keepaliveTimeout is not null');
            return;
        }
        if (this.channelzEnabled) {
            this.keepalivesSent += 1;
        }
        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
        this.keepaliveTimer = setTimeout(() => {
            this.keepaliveTimer = null;
            this.keepaliveTrace('Ping timeout passed without response');
            this.handleDisconnect();
        }, this.keepaliveTimeoutMs);
        (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        let pingSendError = '';
        try {
            const pingSentSuccessfully = this.session.ping((err, duration, payload) => {
                this.clearKeepaliveTimeout();
                if (err) {
                    this.keepaliveTrace('Ping failed with error ' + err.message);
                    this.handleDisconnect();
                }
                else {
                    this.keepaliveTrace('Received ping response');
                    this.maybeStartKeepalivePingTimer();
                }
            });
            if (!pingSentSuccessfully) {
                pingSendError = 'Ping returned false';
            }
        }
        catch (e) {
            // grpc/grpc-node#2139
            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';
        }
        if (pingSendError) {
            this.keepaliveTrace('Ping send failed: ' + pingSendError);
            this.handleDisconnect();
        }
    }
    /**
     * Starts the keepalive ping timer if appropriate. If the timer already ran
     * out while there were no active requests, instead send a ping immediately.
     * If the ping timer is already running or a ping is currently in flight,
     * instead do nothing and wait for them to resolve.
     */
    maybeStartKeepalivePingTimer() {
        var _a, _b;
        if (!this.canSendPing()) {
            return;
        }
        if (this.pendingSendKeepalivePing) {
            this.pendingSendKeepalivePing = false;
            this.maybeSendPing();
        }
        else if (!this.keepaliveTimer) {
            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
            this.keepaliveTimer = setTimeout(() => {
                this.keepaliveTimer = null;
                this.maybeSendPing();
            }, this.keepaliveTimeMs);
            (_b = (_a = this.keepaliveTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        /* Otherwise, there is already either a keepalive timer or a ping pending,
         * wait for those to resolve. */
    }
    /**
     * Clears whichever keepalive timeout is currently active, if any.
     */
    clearKeepaliveTimeout() {
        if (this.keepaliveTimer) {
            clearTimeout(this.keepaliveTimer);
            this.keepaliveTimer = null;
        }
    }
    removeActiveCall(call) {
        this.activeCalls.delete(call);
        if (this.activeCalls.size === 0) {
            this.session.unref();
        }
    }
    addActiveCall(call) {
        this.activeCalls.add(call);
        if (this.activeCalls.size === 1) {
            this.session.ref();
            if (!this.keepaliveWithoutCalls) {
                this.maybeStartKeepalivePingTimer();
            }
        }
    }
    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = host;
        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
        headers[HTTP2_HEADER_METHOD] = 'POST';
        headers[HTTP2_HEADER_PATH] = method;
        headers[HTTP2_HEADER_TE] = 'trailers';
        // Set default 'user-agent' header if it's not explicitly set in the metadata
        if (!Object.keys(headers).some(key => key.toLowerCase() === HTTP2_HEADER_USER_AGENT)) {
            headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        }
        let http2Stream;
        /* In theory, if an error is thrown by session.request because session has
         * become unusable (e.g. because it has received a goaway), this subchannel
         * should soon see the corresponding close or goaway event anyway and leave
         * READY. But we have seen reports that this does not happen
         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
         * so for defense in depth, we just discard the session when we see an
         * error here.
         */
        try {
            http2Stream = this.session.request(headers);
        }
        catch (e) {
            this.handleDisconnect();
            throw e;
        }
        this.flowControlTrace('local window size: ' +
            this.session.state.localWindowSize +
            ' remote window size: ' +
            this.session.state.remoteWindowSize);
        this.internalsTrace('session.closed=' +
            this.session.closed +
            ' session.destroyed=' +
            this.session.destroyed +
            ' session.socket.destroyed=' +
            this.session.socket.destroyed);
        let eventTracker;
        // eslint-disable-next-line prefer-const
        let call;
        if (this.channelzEnabled) {
            this.streamTracker.addCallStarted();
            eventTracker = {
                addMessageSent: () => {
                    var _a;
                    this.messagesSent += 1;
                    this.lastMessageSentTimestamp = new Date();
                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
                },
                addMessageReceived: () => {
                    var _a;
                    this.messagesReceived += 1;
                    this.lastMessageReceivedTimestamp = new Date();
                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
                },
                onCallEnd: status => {
                    var _a;
                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);
                    this.removeActiveCall(call);
                },
                onStreamEnd: success => {
                    var _a;
                    if (success) {
                        this.streamTracker.addCallSucceeded();
                    }
                    else {
                        this.streamTracker.addCallFailed();
                    }
                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);
                },
            };
        }
        else {
            eventTracker = {
                addMessageSent: () => {
                    var _a;
                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
                },
                addMessageReceived: () => {
                    var _a;
                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
                },
                onCallEnd: status => {
                    var _a;
                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);
                    this.removeActiveCall(call);
                },
                onStreamEnd: success => {
                    var _a;
                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);
                },
            };
        }
        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
        this.addActiveCall(call);
        return call;
    }
    getChannelzRef() {
        return this.channelzRef;
    }
    getPeerName() {
        return this.subchannelAddressString;
    }
    getOptions() {
        return this.options;
    }
    shutdown() {
        this.session.close();
        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
    }
}
class Http2SubchannelConnector {
    constructor(channelTarget) {
        this.channelTarget = channelTarget;
        this.session = null;
        this.isShutdown = false;
    }
    trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);
    }
    createSession(address, credentials, options, proxyConnectionResult) {
        if (this.isShutdown) {
            return Promise.reject();
        }
        return new Promise((resolve, reject) => {
            var _a, _b, _c, _d;
            let remoteName;
            if (proxyConnectionResult.realTarget) {
                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
                this.trace('creating HTTP/2 session through proxy to ' +
                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
            }
            else {
                remoteName = null;
                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));
            }
            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
            let connectionOptions = credentials._getConnectionOptions() || {};
            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
            if ('grpc-node.max_session_memory' in options) {
                connectionOptions.maxSessionMemory =
                    options['grpc-node.max_session_memory'];
            }
            else {
                /* By default, set a very large max session memory limit, to effectively
                 * disable enforcement of the limit. Some testing indicates that Node's
                 * behavior degrades badly when this limit is reached, so we solve that
                 * by disabling the check entirely. */
                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
            }
            let addressScheme = 'http://';
            if ('secureContext' in connectionOptions) {
                addressScheme = 'https://';
                // If provided, the value of grpc.ssl_target_name_override should be used
                // to override the target hostname when checking server identity.
                // This option is used for testing only.
                if (options['grpc.ssl_target_name_override']) {
                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
                    const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== void 0 ? _b : tls_1.checkServerIdentity;
                    connectionOptions.checkServerI