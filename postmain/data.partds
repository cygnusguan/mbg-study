 @param {Function} [callback] - callback fired on unsuback
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 * @example client.unsubscribe('topic');
	 * @example client.unsubscribe('topic', console.log);
	 */
	public unsubscribe(topic: string | string[]): MqttClient
	public unsubscribe(
		topic: string | string[],
		opts?: IClientSubscribeOptions,
	): MqttClient
	public unsubscribe(
		topic: string | string[],
		callback?: PacketCallback,
	): MqttClient
	public unsubscribe(
		topic: string | string[],
		opts?: IClientSubscribeOptions,
		callback?: PacketCallback,
	): MqttClient
	public unsubscribe(
		topic: string | string[],
		opts?: IClientSubscribeOptions | PacketCallback,
		callback?: PacketCallback,
	): MqttClient {
		if (typeof topic === 'string') {
			topic = [topic]
		}

		if (typeof opts === 'function') {
			callback = opts
		}

		callback = callback || this.noop

		const invalidTopic = validations.validateTopics(topic)
		if (invalidTopic !== null) {
			setImmediate(callback, new Error(`Invalid topic ${invalidTopic}`))
			return this
		}

		if (this._checkDisconnecting(callback)) {
			return this
		}

		const unsubscribeProc = () => {
			const messageId = this._nextId()
			if (messageId === null) {
				this.log('No messageId left')
				return false
			}
			const packet: IUnsubscribePacket = {
				cmd: 'unsubscribe',
				// qos: 1,
				messageId,
				unsubscriptions: [],
			}

			if (typeof topic === 'string') {
				packet.unsubscriptions = [topic]
			} else if (Array.isArray(topic)) {
				packet.unsubscriptions = topic
			}

			if (this.options.resubscribe) {
				packet.unsubscriptions.forEach((topic2) => {
					delete this._resubscribeTopics[topic2]
				})
			}

			if (typeof opts === 'object' && opts.properties) {
				packet.properties = opts.properties
			}

			this.outgoing[packet.messageId] = {
				volatile: true,
				cb: callback,
			}

			this.log('unsubscribe: call _sendPacket')
			this._sendPacket(packet)

			return true
		}

		if (
			this._storeProcessing ||
			this._storeProcessingQueue.length > 0 ||
			!unsubscribeProc()
		) {
			this._storeProcessingQueue.push({
				invoke: unsubscribeProc,
				callback,
			})
		}

		return this
	}

	public unsubscribeAsync(
		topic: string | string[],
	): Promise<Packet | undefined>
	public unsubscribeAsync(
		topic: string | string[],
		opts?: IClientSubscribeOptions,
	): Promise<Packet | undefined>
	public unsubscribeAsync(
		topic: string | string[],
		opts?: IClientSubscribeOptions,
	): Promise<Packet | undefined> {
		return new Promise((resolve, reject) => {
			this.unsubscribe(topic, opts, (err, packet) => {
				if (err) {
					reject(err)
				} else {
					resolve(packet)
				}
			})
		})
	}

	/**
	 * end - close connection
	 *
	 * @returns {MqttClient} this - for chaining
	 * @param {Boolean} force - do not wait for all in-flight messages to be acked
	 * @param {Object} opts - added to the disconnect packet
	 * @param {Function} cb - called when the client has been closed
	 *
	 * @api public
	 */
	public end(cb?: DoneCallback): MqttClient
	public end(force?: boolean): MqttClient
	public end(opts?: Partial<IDisconnectPacket>, cb?: DoneCallback): MqttClient
	public end(force?: boolean, cb?: DoneCallback): MqttClient
	public end(
		force?: boolean,
		opts?: Partial<IDisconnectPacket>,
		cb?: DoneCallback,
	): MqttClient
	public end(
		force?: boolean | Partial<IDisconnectPacket> | DoneCallback,
		opts?: Partial<IDisconnectPacket> | DoneCallback,
		cb?: DoneCallback,
	): MqttClient {
		this.log('end :: (%s)', this.options.clientId)

		if (force == null || typeof force !== 'boolean') {
			cb = cb || (opts as DoneCallback)
			opts = force as Partial<IDisconnectPacket>
			force = false
		}

		if (typeof opts !== 'object') {
			cb = cb || opts
			opts = null
		}

		this.log('end :: cb? %s', !!cb)

		if (!cb || typeof cb !== 'function') {
			cb = this.noop
		}

		const closeStores = () => {
			this.log('end :: closeStores: closing incoming and outgoing stores')
			this.disconnected = true
			this.incomingStore.close((e1) => {
				this.outgoingStore.close((e2) => {
					this.log('end :: closeStores: emitting end')
					this.emit('end')
					if (cb) {
						const err = e1 || e2
						this.log(
							'end :: closeStores: invoking callback with args',
						)
						cb(err)
					}
				})
			})
			if (this._deferredReconnect) {
				this._deferredReconnect()
			}
		}

		const finish = () => {
			// defer closesStores of an I/O cycle,
			// just to make sure things are
			// ok for websockets
			this.log(
				'end :: (%s) :: finish :: calling _cleanUp with force %s',
				this.options.clientId,
				force,
			)
			this._cleanUp(
				<boolean>force,
				() => {
					this.log(
						'end :: finish :: calling process.nextTick on closeStores',
					)
					// const boundProcess = nextTick.bind(null, closeStores)
					nextTick(closeStores)
				},
				opts,
			)
		}

		if (this.disconnecting) {
			cb()
			return this
		}

		this._clearReconnect()

		this.disconnecting = true

		if (!force && Object.keys(this.outgoing).length > 0) {
			// wait 10ms, just to be sure we received all of it
			this.log(
				'end :: (%s) :: calling finish in 10ms once outgoing is empty',
				this.options.clientId,
			)
			this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))
		} else {
			this.log(
				'end :: (%s) :: immediately calling finish',
				this.options.clientId,
			)
			finish()
		}

		return this
	}

	public endAsync(): Promise<void>
	public endAsync(force?: boolean): Promise<void>
	public endAsync(opts?: Partial<IDisconnectPacket>): Promise<void>
	public endAsync(
		force?: boolean,
		opts?: Partial<IDisconnectPacket>,
	): Promise<void>
	public endAsync(
		force?: boolean | Partial<IDisconnectPacket>,
		opts?: Partial<IDisconnectPacket>,
	): Promise<void> {
		return new Promise((resolve, reject) => {
			this.end(force as boolean, opts, (err) => {
				if (err) {
					reject(err)
				} else {
					resolve()
				}
			})
		})
	}

	/**
	 * removeOutgoingMessage - remove a message in outgoing store
	 * the outgoing callback will be called withe Error('Message removed') if the message is removed
	 *
	 * @param {Number} messageId - messageId to remove message
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 *
	 * @example client.removeOutgoingMessage(client.getLastAllocated());
	 */
	public removeOutgoingMessage(messageId: number): MqttClient {
		if (this.outgoing[messageId]) {
			const { cb } = this.outgoing[messageId]
			this._removeOutgoingAndStoreMessage(messageId, () => {
				cb(new Error('Message removed'))
			})
		}
		return this
	}

	/**
	 * reconnect - connect again using the same options as connect()
	 *
	 * @param {Object} [opts] - optional reconnect options, includes:
	 *    {Store} incomingStore - a store for the incoming packets
	 *    {Store} outgoingStore - a store for the outgoing packets
	 *    if opts is not given, current stores are used
	 * @returns {MqttClient} this - for chaining
	 *
	 * @api public
	 */
	public reconnect(
		opts?: Pick<IClientOptions, 'incomingStore' | 'outgoingStore'>,
	): MqttClient {
		this.log('client reconnect')
		const f = () => {
			if (opts) {
				this.options.incomingStore = opts.incomingStore
				this.options.outgoingStore = opts.outgoingStore
			} else {
				this.options.incomingStore = null
				this.options.outgoingStore = null
			}
			this.incomingStore = this.options.incomingStore || new Store()
			this.outgoingStore = this.options.outgoingStore || new Store()
			this.disconnecting = false
			this.disconnected = false
			this._deferredReconnect = null
			this._reconnect()
		}

		if (this.disconnecting && !this.disconnected) {
			this._deferredReconnect = f
		} else {
			f()
		}
		return this
	}

	/**
	 * PRIVATE METHODS
	 * =====================
	 * */

	/**
	 * Flush all outgoing messages marked as `volatile` in `outgoing` queue. Volatile messages
	 * typically are subscription and unsubscription requests.
	 */
	private _flushVolatile() {
		if (this.outgoing) {
			this.log(
				'_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function',
			)
			Object.keys(this.outgoing).forEach((messageId) => {
				if (
					this.outgoing[messageId].volatile &&
					typeof this.outgoing[messageId].cb === 'function'
				) {
					this.outgoing[messageId].cb(new Error('Connection closed'))
					delete this.outgoing[messageId]
				}
			})
		}
	}

	/**
	 * Flush all outgoing messages
	 */
	private _flush() {
		if (this.outgoing) {
			this.log('_flush: queue exists? %b', !!this.outgoing)
			Object.keys(this.outgoing).forEach((messageId) => {
				if (typeof this.outgoing[messageId].cb === 'function') {
					this.outgoing[messageId].cb(new Error('Connection closed'))
					// This is suspicious.  Why do we only delete this if we have a callback?
					// If this is by-design, then adding no as callback would cause this to get deleted unintentionally.
					delete this.outgoing[messageId]
				}
			})
		}
	}

	private _removeTopicAliasAndRecoverTopicName(packet: IPublishPacket) {
		let alias: number | undefined

		if (packet.properties) {
			alias = packet.properties.topicAlias
		}

		let topic = packet.topic.toString()

		this.log(
			'_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o',
			alias,
			topic,
		)

		if (topic.length === 0) {
			// restore topic from alias
			if (typeof alias === 'undefined') {
				return new Error('Unregistered Topic Alias')
			}
			topic = this.topicAliasSend.getTopicByAlias(alias)
			if (typeof topic === 'undefined') {
				return new Error('Unregistered Topic Alias')
			}
			packet.topic = topic
		}
		if (alias) {
			delete packet.properties.topicAlias
		}
	}

	private _checkDisconnecting(callback?: GenericCallback<any>) {
		if (this.disconnecting) {
			if (callback && callback !== this.noop) {
				callback(new Error('client disconnecting'))
			} else {
				this.emit('error', new Error('client disconnecting'))
			}
		}
		return this.disconnecting
	}

	/**
	 * _reconnect - implement reconnection
	 * @api private
	 */
	private _reconnect() {
		this.log('_reconnect: emitting reconnect to client')
		this.emit('reconnect')
		if (this.connected) {
			this.end(() => {
				this.connect()
			})
			this.log('client already connected. disconnecting first.')
		} else {
			this.log('_reconnect: calling connect')
			this.connect()
		}
	}

	/**
	 * _setupReconnect - setup reconnect timer
	 */
	private _setupReconnect() {
		if (
			!this.disconnecting &&
			!this.reconnectTimer &&
			this.options.reconnectPeriod > 0
		) {
			if (!this.reconnecting) {
				this.log('_setupReconnect :: emit `offline` state')
				this.emit('offline')
				this.log('_setupReconnect :: set `reconnecting` to `true`')
				this.reconnecting = true
			}
			this.log(
				'_setupReconnect :: setting reconnectTimer for %d ms',
				this.options.reconnectPeriod,
			)
			this.reconnectTimer = setInterval(() => {
				this.log('reconnectTimer :: reconnect triggered!')
				this._reconnect()
			}, this.options.reconnectPeriod)
		} else {
			this.log('_setupReconnect :: doing nothing...')
		}
	}

	/**
	 * _clearReconnect - clear the reconnect timer
	 */
	private _clearReconnect() {
		this.log('_clearReconnect : clearing reconnect timer')
		if (this.reconnectTimer) {
			clearInterval(this.reconnectTimer)
			this.reconnectTimer = null
		}
	}

	/**
	 * _cleanUp - clean up on connection end
	 * @api private
	 */
	private _cleanUp(forced: boolean, done?: DoneCallback, opts = {}) {
		if (done) {
			this.log('_cleanUp :: done callback provided for on stream close')
			this.stream.on('close', done)
		}

		this.log('_cleanUp :: forced? %s', forced)
		if (forced) {
			if (this.options.reconnectPeriod === 0 && this.options.clean) {
				this._flush()
			}
			this.log(
				'_cleanUp :: (%s) :: destroying stream',
				this.options.clientId,
			)
			this.stream.destroy()
		} else {
			const packet: IDisconnectPacket = { cmd: 'disconnect', ...opts }
			this.log(
				'_cleanUp :: (%s) :: call _sendPacket with disconnect packet',
				this.options.clientId,
			)
			this._sendPacket(packet, () => {
				this.log(
					'_cleanUp :: (%s) :: destroying stream',
					this.options.clientId,
				)
				setImmediate(() => {
					this.stream.end(() => {
						this.log(
							'_cleanUp :: (%s) :: stream destroyed',
							this.options.clientId,
						)
						// once stream is closed the 'close' event will fire and that will
						// emit client `close` event and call `done` callback if done is provided
					})
				})
			})
		}

		if (!this.disconnecting) {
			this.log(
				'_cleanUp :: client not disconnecting. Clearing and resetting reconnect.',
			)
			this._clearReconnect()
			this._setupReconnect()
		}

		if (this.pingTimer !== null) {
			this.log('_cleanUp :: clearing pingTimer')
			this.pingTimer.clear()
			this.pingTimer = null
		}

		if (done && !this.connected) {
			this.log(
				'_cleanUp :: (%s) :: removing stream `done` callback `close` listener',
				this.options.clientId,
			)
			this.stream.removeListener('close', done)
			done()
		}
	}

	private _storeAndSend(
		packet: Packet,
		cb: DoneCallback,
		cbStorePut: DoneCallback,
	) {
		this.log(
			'storeAndSend :: store packet with cmd %s to outgoingStore',
			packet.cmd,
		)
		let storePacket = packet
		let err: Error | undefined
		if (storePacket.cmd === 'publish') {
			// The original packet is for sending.
			// The cloned storePacket is for storing to resend on reconnect.
			// Topic Alias must not be used after disconnected.
			storePacket = clone(packet)
			err = this._removeTopicAliasAndRecoverTopicName(
				storePacket as IPublishPacket,
			)
			if (err) {
				return cb && cb(err)
			}
		}
		this.outgoingStore.put(storePacket, (err2) => {
			if (err2) {
				return cb && cb(err2)
			}
			cbStorePut()
			this._writePacket(packet, cb)
		})
	}

	private _applyTopicAlias(packet: Packet) {
		if (this.options.protocolVersion === 5) {
			if (packet.cmd === 'publish') {
				let alias: number
				if (packet.properties) {
					alias = packet.properties.topicAlias
				}
				const topic = packet.topic.toString()
				if (this.topicAliasSend) {
					if (alias) {
						if (topic.length !== 0) {
							// register topic alias
							this.log(
								'applyTopicAlias :: register topic: %s - alias: %d',
								topic,
								alias,
							)
							if (!this.topicAliasSend.put(topic, alias)) {
								this.log(
									'applyTopicAlias :: error out of range. topic: %s - alias: %d',
									topic,
									alias,
								)
								return new Error(
									'Sending Topic Alias out of range',
								)
							}
						}
					} else if (topic.length !== 0) {
						if (this.options.autoAssignTopicAlias) {
							alias = this.topicAliasSend.getAliasByTopic(topic)
							if (alias) {
								packet.topic = ''
								packet.properties = {
									...packet.properties,
									topicAlias: alias,
								}
								this.log(
									'applyTopicAlias :: auto assign(use) topic: %s - alias: %d',
									topic,
									alias,
								)
							} else {
								alias = this.topicAliasSend.getLruAlias()
								this.topicAliasSend.put(topic, alias)
								packet.properties = {
									...packet.properties,
									topicAlias: alias,
								}
								this.log(
									'applyTopicAlias :: auto assign topic: %s - alias: %d',
									topic,
									alias,
								)
							}
						} else if (this.options.autoUseTopicAlias) {
							alias = this.topicAliasSend.getAliasByTopic(topic)
							if (alias) {
								packet.topic = ''
								packet.properties = {
									...packet.properties,
									topicAlias: alias,
								}
								this.log(
									'applyTopicAlias :: auto use topic: %s - alias: %d',
									topic,
									alias,
								)
							}
						}
					}
				} else if (alias) {
					this.log(
						'applyTopicAlias :: error out of range. topic: %s - alias: %d',
						topic,
						alias,
					)
					return new Error('Sending Topic Alias out of range')
				}
			}
		}
	}

	private _noop(err?: Error) {
		this.log('noop ::', err)
	}

	/** Writes the packet to stream and emits events */
	private _writePacket(packet: Packet, cb?: DoneCallback) {
		this.log('_writePacket :: packet: %O', packet)
		this.log('_writePacket :: emitting `packetsend`')

		this.emit('packetsend', packet)

		// When writing a packet, reschedule the ping timer
		this._shiftPingInterval()

		this.log('_writePacket :: writing to stream')
		const result = mqttPacket.writeToStream(
			packet,
			this.stream,
			this.options,
		)
		this.log('_writePacket :: writeToStream result %s', result)
		if (!result && cb && cb !== this.noop) {
			this.log(
				'_writePacket :: handle events on `drain` once through callback.',
			)
			this.stream.once('drain', cb)
		} else if (cb) {
			this.log('_writePacket :: invoking cb')
			cb()
		}
	}

	/**
	 * _sendPacket - send or queue a packet
	 * @param {Object} packet - packet options
	 * @param {Function} cb - callback when the packet is sent
	 * @param {Function} cbStorePut - called when message is put into outgoingStore
	 * @param {Boolean} noStore - send without put to the store
	 * @api private
	 */
	private _sendPacket(
		packet: Packet,
		cb?: DoneCallback,
		cbStorePut?: DoneCallback,
		noStore?: boolean,
	) {
		this.log('_sendPacket :: (%s) ::  start', this.options.clientId)
		cbStorePut = cbStorePut || this.noop
		cb = cb || this.noop

		const err = this._applyTopicAlias(packet)
		if (err) {
			cb(err)
			return
		}

		if (!this.connected) {
			// allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)
			if (packet.cmd === 'auth') {
				this._writePacket(packet, cb)
				return
			}

			this.log(
				'_sendPacket :: client not connected. Storing packet offline.',
			)
			this._storePacket(packet, cb, cbStorePut)
			return
		}

		// If "noStore" is true, the message is sent without being recorded in the store.
		// Messages that have not received puback or pubcomp remain in the store after disconnection
		// and are resent from the store upon reconnection.
		// For resend upon reconnection, "noStore" is set to true. This is because the message is already stored in the store.
		// This is to avoid interrupting other processes while recording to the store.
		if (noStore) {
			this._writePacket(packet, cb)
			return
		}

		switch (packet.cmd) {
			case 'publish':
				break
			case 'pubrel':
				this._storeAndSend(packet, cb, cbStorePut)
				return
			default:
				this._writePacket(packet, cb)
				return
		}

		switch (packet.qos) {
			case 2:
			case 1:
				this._storeAndSend(packet, cb, cbStorePut)
				break
			/**
			 * no need of case here since it will be caught by default
			 * and jshint comply that before default it must be a break
			 * anyway it will result in -1 evaluation
			 */
			case 0:
			/* falls through */
			default:
				this._writePacket(packet, cb)
				break
		}
		this.log('_sendPacket :: (%s) ::  end', this.options.clientId)
	}

	/**
	 * _storePacket - queue a packet
	 * @param {Object} packet - packet options
	 * @param {Function} cb - callback when the packet is sent
	 * @param {Function} cbStorePut - called when message is put into outgoingStore
	 * @api private
	 */
	private _storePacket(
		packet: Packet,
		cb: DoneCallback,
		cbStorePut: DoneCallback,
	) {
		this.log('_storePacket :: packet: %o', packet)
		this.log('_storePacket :: cb? %s', !!cb)
		cbStorePut = cbStorePut || this.noop

		let storePacket = packet
		if (storePacket.cmd === 'publish') {
			// The original packet is for sending.
			// The cloned storePacket is for storing to resend on reconnect.
			// Topic Alias must not be used after disconnected.
			storePacket = clone(packet)
			const err = this._removeTopicAliasAndRecoverTopicName(
				storePacket as IPublishPacket,
			)
			if (err) {
				return cb && cb(err)
			}
		}

		const qos = (storePacket as IPublishPacket).qos || 0
		// check that the packet is not a qos of 0, or that the command is not a publish
		if ((qos === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {
			this.queue.push({ packet: storePacket, cb })
		} else if (qos > 0) {
			cb = this.outgoing[storePacket.messageId]
				? this.outgoing[storePacket.messageId].cb
				: null
			this.outgoingStore.put(storePacket, (err) => {
				if (err) {
					return cb && cb(err)
				}
				cbStorePut()
			})
		} else if (cb) {
			cb(new Error('No connection to broker'))
		}
	}

	/**
	 * _setupPingTimer - setup the ping timer
	 *
	 * @api private
	 */
	private _setupPingTimer() {
		this.log(
			'_setupPingTimer :: keepalive %d (seconds)',
			this.options.keepalive,
		)

		if (!this.pingTimer && this.options.keepalive) {
			this.pingResp = true
			this.pingTimer = reInterval(() => {
				this._checkPing()
			}, this.options.keepalive * 1000)
		}
	}

	/**
	 * _shiftPingInterval - reschedule the ping interval
	 *
	 * @api private
	 */
	private _shiftPingInterval() {
		if (
			this.pingTimer &&
			this.options.keepalive &&
			this.options.reschedulePings
		) {
			this.pingTimer.reschedule(this.options.keepalive * 1000)
		}
	}

	/**
	 * _checkPing - check if a pingresp has come back, and ping the server again
	 *
	 * @api private
	 */
	private _checkPing() {
		this.log('_checkPing :: checking ping...')
		if (this.pingResp) {
			this.log(
				'_checkPing :: ping response received. Clearing flag and sending `pingreq`',
			)
			this.pingResp = false
			this._sendPacket({ cmd: 'pingreq' })
		} else {
			// do a forced cleanup since socket will be in bad shape
			this.log('_checkPing :: calling _cleanUp with force true')
			this._cleanUp(true)
		}
	}

	/**
	 * _resubscribe
	 * @api private
	 */
	private _resubscribe() {
		this.log('_resubscribe')
		const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)
		if (
			!this._firstConnection &&
			// Only resubscribe in case of clean connection or if the server does not have a stored session.
			// The Session Present flag is available since v3.1.1
			// https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349254
			(this.options.clean ||
				(this.options.protocolVersion >= 4 &&
					!this.connackPacket.sessionPresent)) &&
			_resubscribeTopicsKeys.length > 0
		) {
			if (this.options.resubscribe) {
				if (this.options.protocolVersion === 5) {
					this.log('_resubscribe: protocolVersion 5')
					for (
						let topicI = 0;
						topicI < _resubscribeTopicsKeys.length;
						topicI++
					) {
						const resubscribeTopic: ISubscriptionMap = {}
						resubscribeTopic[_resubscribeTopicsKeys[topicI]] =
							this._resubscribeTopics[
								_resubscribeTopicsKeys[topicI]
							]
						resubscribeTopic.resubscribe = true
						this.subscribe(resubscribeTopic, {
							properties:
								resubscribeTopic[_resubscribeTopicsKeys[topicI]]
									.properties,
						})
					}
				} else {
					this._resubscribeTopics.resubscribe = true
					this.subscribe(this._resubscribeTopics)
				}
			} else {
				this._resubscribeTopics = {}
			}
		}

		this._firstConnection = false
	}

	/**
	 * _onConnect
	 *
	 * @api private
	 */
	private _onConnect(packet: IConnackPacket) {
		if (this.disconnected) {
			this.emit('connect', packet)
			return
		}

		this.connackPacket = packet
		this.messageIdProvider.clear()
		this._setupPingTimer()

		this.connected = true

		/** check if there are packets in outgoing store and stream them */
		const startStreamProcess = () => {
			let outStore = this.outgoingStore.createStream()

			/** destroy the outgoing store stream */
			const remove = () => {
				outStore.destroy()
				outStore = null
				this._flushStoreProcessingQueue()
				clearStoreProcessing()
			}

			/** stop store processing and clear packets id processed */
			const clearStoreProcessing = () => {
				this._storeProcessing = false
				this._packetIdsDuringStoreProcessing = {}
			}

			this.once('close', remove)
			outStore.on('error', (err) => {
				clearStoreProcessing()
				this._flushStoreProcessingQueue()
				this.removeListener('close', remove)
				this.emit('error', err)
			})

			/** Read next packet in outgoing store and send it */
			const storeDeliver = () => {
				// edge case, we wrapped this twice
				if (!outStore) {
					return
				}

				const packet2 = outStore.read(1)

				let cb: PacketCallback

				if (!packet2) {
					// read when data is available in the future
					outStore.once('readable', storeDeliver)
					return
				}

				this._storeProcessing = true

				// Skip already processed store packets
				if (this._packetIdsDuringStoreProcessing[packet2.messageId]) {
					storeDeliver()
					return
				}

				// Avoid unnecessary stream read operations when disconnected
				if (!this.disconnecting && !this.reconnectTimer) {
					cb = this.outgoing[packet2.messageId]
						? this.outgoing[packet2.messageId].cb
						: null
					this.outgoing[packet2.messageId] = {
						volatile: false,
						cb(err, status) {
							// Ensure that the original callback passed in to publish gets invoked
							if (cb) {
								cb(err, status)
							}

							storeDeliver()
						},
					}
					this._packetIdsDuringStoreProcessing[packet2.messageId] =
						true
					if (this.messageIdProvider.register(packet2.messageId)) {
						this._sendPacket(packet2, undefined, undefined, true)
					} else {
						this.log(
							'messageId: %d has already used.',
							packet2.messageId,
						)
					}
				} else if (outStore.destroy) {
					outStore.destroy()
				}
			}

			outStore.on('end', () => {
				let allProcessed = true
				for (const id in this._packetIdsDuringStoreProcessing) {
					if (!this._packetIdsDuringStoreProcessing[id]) {
						allProcessed = false
						break
					}
				}
				if (allProcessed) {
					clearStoreProcessing()
					this.removeListener('close', remove)
					this._invokeAllStoreProcessingQueue()
					this.emit('connect', packet)
				} else {
					startStreamProcess()
				}
			})
			storeDeliver()
		}
		// start flowing
		startStreamProcess()
	}

	private _invokeStoreProcessingQueue() {
		// If _storeProcessing is true, the message is resending.
		// During resend, processing is skipped to prevent new messages from interrupting. #1635
		if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
			const f = this._storeProcessingQueue[0]
			if (f && f.invoke()) {
				this._storeProcessingQueue.shift()
				return true
			}
		}
		return false
	}

	private _invokeAllStoreProcessingQueue() {
		while (this._invokeStoreProcessingQueue()) {
			/* empty */
		}
	}

	private _flushStoreProcessingQueue() {
		for (const f of this._storeProcessingQueue) {
			if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'))
			if (f.callback) f.callback(new Error('Connection closed'))
		}
		this._storeProcessingQueue.splice(0)
	}

	/**
	 * _removeOutgoingAndStoreMessage
	 * @param {Number} messageId - messageId to remove message
	 * @param {Function} cb - called when the message removed
	 * @api private
	 */
	private _removeOutgoingAndStoreMessage(
		messageId: number,
		cb: PacketCallback,
	) {
		delete this.outgoing[messageId]
		this.outgoingStore.del({ messageId }, (err, packet) => {
			cb(err, packet)
			this.messageIdProvider.deallocate(messageId)
			this._invokeStoreProcessingQueue()
		})
	}
}
import { Buffer } from 'buffer'
import { Transform } from 'readable-stream'
import duplexify, { Duplexify } from 'duplexify'
import { StreamBuilder } from '../shared'
import MqttClient, { IClientOptions } from '../client'

let my: any
let proxy: Transform
let stream: Duplexify
let isInitialized = false

function buildProxy() {
	const _proxy = new Transform()
	_proxy._write = (chunk, encoding, next) => {
		my.sendSocketMessage({
			data: chunk.buffer,
			success() {
				next()
			},
			fail() {
				next(new Error())
			},
		})
	}
	_proxy._flush = (done) => {
		my.closeSocket({
			success() {
				done()
			},
		})
	}

	return _proxy
}

function setDefaultOpts(opts: IClientOptions) {
	if (!opts.hostname) {
		opts.hostname = 'localhost'
	}
	if (!opts.path) {
		opts.path = '/'
	}

	if (!opts.wsOptions) {
		opts.wsOptions = {}
	}
}

function buildUrl(opts: IClientOptions, client: MqttClient) {
	const protocol = opts.protocol === 'alis' ? 'wss' : 'ws'
	let url = `${protocol}://${opts.hostname}${opts.path}`
	if (opts.port && opts.port !== 80 && opts.port !== 443) {
		url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`
	}
	if (typeof opts.transformWsUrl === 'function') {
		url = opts.transformWsUrl(url, opts, client)
	}
	return url
}

function bindEventHandler() {
	if (isInitialized) return

	isInitialized = true

	my.onSocketOpen(() => {
		stream.setReadable(proxy)
		stream.setWritable(proxy)
		stream.emit('connect')
	})

	my.onSocketMessage((res) => {
		if (typeof res.data === 'string') {
			const buffer = Buffer.from(res.data, 'base64')
			proxy.push(buffer)
		} else {
			const reader = new FileReader()
			reader.addEventListener('load', () => {
				let data = reader.result

				if (data instanceof ArrayBuffer) data = Buffer.from(data)
				else data = Buffer.from(data, 'utf8')
				proxy.push(data)
			})
			reader.readAsArrayBuffer(res.data)
		}
	})

	my.onSocketClose(() => {
		stream.end()
		stream.destroy()
	})

	my.onSocketError((res) => {
		stream.destroy(res)
	})
}

const buildStream: StreamBuilder = (client, opts) => {
	opts.hostname = opts.hostname || opts.host

	if (!opts.hostname) {
		throw new Error('Could not determine host. Specify host manually.')
	}

	const websocketSubProtocol =
		opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
			? 'mqttv3.1'
			: 'mqtt'

	setDefaultOpts(opts)

	const url = buildUrl(opts, client)
	my = opts.my
	my.connectSocket({
		url,
		protocols: websocketSubProtocol,
	})

	proxy = buildProxy()
	stream = duplexify.obj()

	bindEventHandler()

	return stream
}

export default buildStream
/* eslint-disable @typescript-eslint/no-var-requires */
import _debug from 'debug'
import url from 'url'
import MqttClient, {
	IClientOptions,
	MqttClientEventCallbacks,
	MqttProtocol,
} from '../client'
import IS_BROWSER from '../is-browser'
import { StreamBuilder } from '../shared'

const debug = _debug('mqttjs')

const protocols: Record<string, StreamBuilder> = {}

if (!IS_BROWSER) {
	protocols.mqtt = require('./tcp').default
	protocols.tcp = require('./tcp').default
	protocols.ssl = require('./tls').default
	protocols.tls = protocols.ssl
	protocols.mqtts = require('./tls').default
} else {
	protocols.wx = require('./wx').default
	protocols.wxs = require('./wx').default

	protocols.ali = require('./ali').default
	protocols.alis = require('./ali').default
}

protocols.ws = require('./ws').default
protocols.wss = require('./ws').default

/**
 * Parse the auth attribute and merge username and password in the options object.
 *
 * @param {Object} [opts] option object
 */
function parseAuthOptions(opts: IClientOptions) {
	let matches: RegExpMatchArray | null
	if (opts.auth) {
		matches = opts.auth.match(/^(.+):(.+)$/)
		if (matches) {
			opts.username = matches[1]
			opts.password = matches[2]
		} else {
			opts.username = opts.auth
		}
	}
}

/**
 * connect - connect to an MQTT broker.
 */
function connect(brokerUrl: string): MqttClient
function connect(opts: IClientOptions): MqttClient
function connect(brokerUrl: string, opts?: IClientOptions): MqttClient
function connect(
	brokerUrl: string | IClientOptions,
	opts?: IClientOptions,
): MqttClient {
	debug('connecting to an MQTT broker...')
	if (typeof brokerUrl === 'object' && !opts) {
		opts = brokerUrl
		brokerUrl = ''
	}

	opts = opts || {}

	if (brokerUrl && typeof brokerUrl === 'string') {
		// eslint-disable-next-line
		const parsed = url.parse(brokerUrl, true)
		if (parsed.port != null) {
			// eslint-disable-next-line @typescript-eslint/ban-ts-comment
			// @ts-ignore
			parsed.port = Number(parsed.port)
		}

		opts = { ...parsed, ...opts } as IClientOptions

		if (opts.protocol === null) {
			throw new Error('Missing protocol')
		}

		opts.protocol = opts.protocol.replace(/:$/, '') as MqttProtocol
	}

	// merge in the auth options if supplied
	parseAuthOptions(opts)

	// support clientId passed in the query string of the url
	if (opts.query && typeof opts.query.clientId === 'string') {
		opts.clientId = opts.query.clientId
	}

	if (opts.cert && opts.key) {
		if (opts.protocol) {
			if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {
				switch (opts.protocol) {
					case 'mqtt':
						opts.protocol = 'mqtts'
						break
					case 'ws':
						opts.protocol = 'wss'
						break
					case 'wx':
						opts.protocol = 'wxs'
						break
					case 'ali':
						opts.protocol = 'alis'
						break
					default:
						throw new Error(
							`Unknown protocol for secure connection: "${opts.protocol}"!`,
						)
				}
			}
		} else {
			// A cert and key was provided, however no protocol was specified, so we will throw an error.
			throw new Error('Missing secure protocol key')
		}
	}

	if (!protocols[opts.protocol]) {
		const isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1
		opts.protocol = [
			'mqtt',
			'mqtts',
			'ws',
			'wss',
			'wx',
			'wxs',
			'ali',
			'alis',
		].filter((key, index) => {
			if (isSecure && index % 2 === 0) {
				// Skip insecure protocols when requesting a secure one.
				return false
			}
			return typeof protocols[key] === 'function'
		})[0] as MqttProtocol
	}

	if (opts.clean === false && !opts.clientId) {
		throw new Error('Missing clientId for unclean clients')
	}

	if (opts.protocol) {
		opts.defaultProtocol = opts.protocol
	}

	function wrapper(client: MqttClient) {
		if (opts.servers) {
			if (
				!client._reconnectCount ||
				client._reconnectCount === opts.servers.length
			) {
				client._reconnectCount = 0
			}

			opts.host = opts.servers[client._reconnectCount].host
			opts.port = opts.servers[client._reconnectCount].port
			opts.protocol = !opts.servers[client._reconnectCount].protocol
				? opts.defaultProtocol
				: opts.servers[client._reconnectCount].protocol
			opts.hostname = opts.host

			client._reconnectCount++
		}

		debug('calling streambuilder for', opts.protocol)
		return protocols[opts.protocol](client, opts)
	}
	const client = new MqttClient(wrapper, opts)
	client.on('error', () => {
		/* Automatically set up client error handling */
	})

	return client
}

function connectAsync(brokerUrl: string): Promise<MqttClient>
function connectAsync(opts: IClientOptions): Promise<MqttClient>
function connectAsync(
	brokerUrl: string,
	opts?: IClientOptions,
): Promise<MqttClient>
function connectAsync(
	brokerUrl: string | IClientOptions,
	opts?: IClientOptions,
	allowRetries = true,
): Promise<MqttClient> {
	return new Promise((resolve, reject) => {
		const client = connect(brokerUrl as string, opts)

		const promiseResolutionListeners: Partial<MqttClientEventCallbacks> = {
			connect: (connack) => {
				removePromiseResolutionListeners()
				resolve(client) // Resolve on connect
			},
			end: () => {
				removePromiseResolutionListeners()
				resolve(client) // Resolve on end
			},
			error: (err) => {
				removePromiseResolutionListeners()
				client.end()
				reject(err) // Reject on error
			},
		}

		// If retries are not allowed, reject on close
		if (allowRetries === false) {
			promiseResolutionListeners.close = () => {
				promiseResolutionListeners.error(
					new Error("Couldn't connect to server"),
				)
			}
		}

		// Remove listeners added to client by this promise
		function removePromiseResolutionListeners() {
			Object.keys(promiseResolutionListeners).forEach((eventName) => {
				client.off(
					eventName as keyof MqttClientEventCallbacks,
					promiseResolutionListeners[eventName],
				)
			})
		}

		// Add listeners to client
		Object.keys(promiseResolutionListeners).forEach((eventName) => {
			client.on(
				eventName as keyof MqttClientEventCallbacks,
				promiseResolutionListeners[eventName],
			)
		})
	})
}

export default connect
export { connectAsync }
import { StreamBuilder } from '../shared'

import net from 'net'
import _debug from 'debug'
import { Duplex } from 'readable-stream'

const debug = _debug('mqttjs:tcp')
/*
  variables port and host can be removed since
  you have all required information in opts object
*/
const buildStream: StreamBuilder = (client, opts) => {
	opts.port = opts.port || 1883
	opts.hostname = opts.hostname || opts.host || 'localhost'

	const { port } = opts
	const host = opts.hostname

	debug('port %d and host %s', port, host)
	return net.createConnection(port, host)
}

export default buildStream
import tls from 'tls'
import net from 'net'
import _debug from 'debug'
import { StreamBuilder } from '../shared'

const debug = _debug('mqttjs:tls')

const buildStream: StreamBuilder = (client, opts) => {
	opts.port = opts.port || 8883
	opts.host = opts.hostname || opts.host || 'localhost'

	if (net.isIP(opts.host) === 0) {
		opts.servername = opts.host
	}

	opts.rejectUnauthorized = opts.rejectUnauthorized !== false

	delete opts.path

	debug(
		'port %d host %s rejectUnauthorized %b',
		opts.port,
		opts.host,
		opts.rejectUnauthorized,
	)

	const connection = tls.connect(opts)
	connection.on('secureConnect', () => {
		if (opts.rejectUnauthorized && !connection.authorized) {
			connection.emit('error', new Error('TLS not authorized'))
		} else {
			connection.removeListener('error', handleTLSerrors)
		}
	})

	function handleTLSerrors(err: Error) {
		// How can I get verify this error is a tls error?
		if (opts.rejectUnauthorized) {
			client.emit('error', err)
		}

		// close this connection to match the behaviour of net
		// otherwise all we get is an error from the connection
		// and close event doesn't fire. This is a work around
		// to enable the reconnect code to work the same as with
		// net.createConnection
		connection.end()
	}

	connection.on('error', handleTLSerrors)
	return connection
}

export default buildStream
import { StreamBuilder } from '../shared'

import { Buffer } from 'buffer'
import WS, { ClientOptions } from 'ws'
import _debug from 'debug'
import duplexify from 'duplexify'
import { DuplexOptions, Transform } from 'readable-stream'
import IS_BROWSER from '../is-browser'
import MqttClient, { IClientOptions } from '../client'

const debug = _debug('mqttjs:ws')

const WSS_OPTIONS = [
	'rejectUnauthorized',
	'ca',
	'cert',
	'key',
	'pfx',
	'passphrase',
]

function buildUrl(opts: IClientOptions, client: MqttClient) {
	let url = `${opts.protocol}://${opts.hostname}:${opts.port}${opts.path}`
	if (typeof opts.transformWsUrl === 'function') {
		url = opts.transformWsUrl(url, opts, client)
	}
	return url
}

function setDefaultOpts(opts: IClientOptions) {
	const options = opts
	if (!opts.hostname) {
		options.hostname = 'localhost'
	}
	if (!opts.port) {
		if (opts.protocol === 'wss') {
			options.port = 443
		} else {
			options.port = 80
		}
	}
	if (!opts.path) {
		options.path = '/'
	}

	if (!opts.wsOptions) {
		options.wsOptions = {}
	}
	if (!IS_BROWSER && opts.protocol === 'wss') {
		// Add cert/key/ca etc options
		WSS_OPTIONS.forEach((prop) => {
			if (
				Object.prototype.hasOwnProperty.call(opts, prop) &&
				!Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)
			) {
				options.wsOptions[prop] = opts[prop]
			}
		})
	}

	return options
}

function setDefaultBrowserOpts(opts: IClientOptions) {
	const options = setDefaultOpts(opts)

	if (!options.hostname) {
		options.hostname = options.host
	}

	if (!options.hostname) {
		// Throwing an error in a Web Worker if no `hostname` is given, because we
		// can not determine the `hostname` automatically.  If connecting to
		// localhost, please supply the `hostname` as an argument.
		if (typeof document === 'undefined') {
			throw new Error('Could not determine host. Specify host manually.')
		}
		const parsed = new URL(document.URL)
		options.hostname = parsed.hostname

		if (!options.port) {
			options.port = Number(parsed.port)
		}
	}

	// objectMode should be defined for logic
	if (options.objectMode === undefined) {
		options.objectMode = !(
			options.binary === true || options.binary === undefined
		)
	}

	return options
}

function createWebSocket(
	client: MqttClient,
	url: string,
	opts: IClientOptions,
) {
	debug('createWebSocket')
	debug(`protocol: ${opts.protocolId} ${opts.protocolVersion}`)
	const websocketSubProtocol =
		opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
			? 'mqttv3.1'
			: 'mqtt'

	debug(
		`creating new Websocket for url: ${url} and protocol: ${websocketSubProtocol}`,
	)
	let socket: WS
	if (opts.createWebsocket) {
		socket = opts.createWebsocket(url, [websocketSubProtocol], opts)
	} else {
		socket = new WS(
			url,
			[websocketSubProtocol],
			opts.wsOptions as ClientOptions,
		)
	}
	return socket
}

function createBrowserWebSocket(client: MqttClient, opts: IClientOptions) {
	const websocketSubProtocol =
		opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
			? 'mqttv3.1'
			: 'mqtt'

	const url = buildUrl(opts, client)
	let socket: WebSocket
	if (opts.createWebsocket) {
		socket = opts.createWebsocket(url, [websocketSubProtocol], opts)
	} else {
		socket = new WebSocket(url, [websocketSubProtocol])
	}
	socket.binaryType = 'arraybuffer'
	return socket
}

const streamBuilder: StreamBuilder = (client, opts) => {
	debug('streamBuilder')
	const options = setDefaultOpts(opts)
	const url = buildUrl(options, client)
	const socket = createWebSocket(client, url, options)
	const webSocketStream = WS.createWebSocketStream(
		socket,
		options.wsOptions as DuplexOptions,
	)

	webSocketStream['url'] = url
	socket.on('close', () => {
		webSocketStream.destroy()
	})
	return webSocketStream
}

const browserStreamBuilder: StreamBuilder = (client, opts) => {
	debug('browserStreamBuilder')
	let stream
	const options = setDefaultBrowserOpts(opts)
	// sets the maximum socket buffer size before throttling
	const bufferSize = options.browserBufferSize || 1024 * 512

	const bufferTimeout = opts.browserBufferTimeout || 1000

	const coerceToBuffer = !opts.objectMode

	const socket = createBrowserWebSocket(client, opts)
	const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser)

	if (!opts.objectMode) {
		proxy._writev = writev
	}
	proxy.on('close', () => {
		socket.close()
	})

	const eventListenerSupport = typeof socket.addEventListener !== 'undefined'

	// was already open when passed in
	if (socket.readyState === socket.OPEN) {
		stream = proxy
	} else {
		stream = duplexify(undefined, undefined, opts)
		if (!opts.objectMode) {
			stream._writev = writev
		}

		if (eventListenerSupport) {
			socket.addEventListener('open', onOpen)
		} else {
			socket.onopen = onOpen
		}
	}

	stream.socket = socket

	if (eventListenerSupport) {
		socket.addEventListener('close', onClose)
		socket.addEventListener('error', onError)
		socket.addEventListener('message', onMessage)
	} else {
		socket.onclose = onClose
		socket.onerror = onError
		socket.onmessage = onMessage
	}

	// methods for browserStreamBuilder

	function buildProxy(pOptions: IClientOptions, socketWrite, socketEnd) {
		const _proxy = new Transform({
			objectMode: pOptions.objectMode,
		})

		_proxy._write = socketWrite
		_proxy._flush = socketEnd

		return _proxy
	}

	function onOpen() {
		stream.setReadable(proxy)
		stream.setWritable(proxy)
		stream.emit('connect')
	}

	function onClose() {
		stream.end()
		stream.destroy()
	}

	function onError(err: Event) {
		stream.destroy(err)
	}

	function onMessage(event: MessageEvent) {
		let { data } = event
		if (data instanceof ArrayBuffer) data = Buffer.from(data)
		else data = Buffer.from(data, 'utf8')
		proxy.push(data)
	}

	// this is to be enabled only if objectMode is false
	function writev(chunks: any, cb: (err?: Error) => void) {
		const buffers = new Array(chunks.length)
		for (let i = 0; i < chunks.length; i++) {
			if (typeof chunks[i].chunk === 'string') {
				buffers[i] = Buffer.from(chunks[i], 'utf8')
			} else {
				buffers[i] = chunks[i].chunk
			}
		}

		this._write(Buffer.concat(buffers), 'binary', cb)
	}

	function socketWriteBrowser(
		chunk: any,
		enc: string,
		next: (err?: Error) => void,
	) {
		if (socket.bufferedAmount > bufferSize) {
			// throttle data until buffered amount is reduced.
			setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
		}

		if (coerceToBuffer && typeof chunk === 'string') {
			chunk = Buffer.from(chunk, 'utf8')
		}

		try {
			socket.send(chunk)
		} catch (err) {
			return next(err)
		}

		next()
	}

	function socketEndBrowser(done) {
		socket.close()
		done()
	}

	// end methods for browserStreamBuilder

	return stream
}

export default IS_BROWSER ? browserStreamBuilder : streamBuilder
import { StreamBuilder } from '../shared'

import { Buffer } from 'buffer'
import { Transform } from 'readable-stream'
import duplexify, { Duplexify } from 'duplexify'
import MqttClient, { IClientOptions } from '../client'

/* global wx */
let socketTask: any
let proxy: Transform
let stream: Duplexify

function buildProxy() {
	const _proxy = new Transform()
	_proxy._write = (chunk, encoding, next) => {
		socketTask.send({
			data: chunk.buffer,
			success() {
				next()
			},
			fail(errMsg) {
				next(new Error(errMsg))
			},
		})
	}
	_proxy._flush = (done) => {
		socketTask.close({
			success() {
				done()
			},
		})
	}

	return _proxy
}

function setDefaultOpts(opts) {
	if (!opts.hostname) {
		opts.hostname = 'localhost'
	}
	if (!opts.path) {
		opts.path = '/'
	}

	if (!opts.wsOptions) {
		opts.wsOptions = {}
	}
}

function buildUrl(opts: IClientOptions, client: MqttClient) {
	const protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'
	let url = `${protocol}://${opts.hostname}${opts.path}`
	if (opts.port && opts.port !== 80 && opts.port !== 443) {
		url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`
	}
	if (typeof opts.transformWsUrl === 'function') {
		url = opts.transformWsUrl(url, opts, client)
	}
	return url
}

function bindEventHandler() {
	socketTask.onOpen(() => {
		stream.setReadable(proxy)
		stream.setWritable(proxy)
		stream.emit('connect')
	})

	socketTask.onMessage((res) => {
		let { data } = res

		if (data instanceof ArrayBuffer) data = Buffer.from(data)
		else data = Buffer.from(data, 'utf8')
		proxy.push(data)
	})

	socketTask.onClose(() => {
		stream.emit('close')
		stream.end()
		stream.destroy()
	})

	socketTask.onError((res) => {
		stream.destroy(new Error(res.errMsg))
	})
}

const buildStream: StreamBuilder = (client, opts) => {
	opts.hostname = opts.hostname || opts.host

	if (!opts.hostname) {
		throw new Error('Could not determine host. Specify host manually.')
	}

	const websocketSubProtocol =
		opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3
			? 'mqttv3.1'
			: 'mqtt'

	setDefaultOpts(opts)

	const url = buildUrl(opts, client)
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	socketTask = wx.connectSocket({
		url,
		protocols: [websocketSubProtocol],
	})

	proxy = buildProxy()
	stream = duplexify.obj()
	stream._destroy = (err, cb) => {
		socketTask.close({
			success() {
				if (cb) cb(err)
			},
		})
	}

	const destroyRef = stream.destroy
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	stream.destroy = () => {
		stream.destroy = destroyRef

		setTimeout(() => {
			socketTask.close({
				fail() {
					// eslint-disable-next-line @typescript-eslint/ban-ts-comment
					// @ts-ignore
					stream._destroy(new Error())
				},
			})
		}, 0)
	}

	bindEventHandler()

	return stream
}

export default buildStream
export interface IMessageIdProvider {
	/**
	 * Allocate the first vacant messageId. The messageId become occupied status.
	 * @return {Number} - The first vacant messageId. If all messageIds are occupied, return null.
	 */
	allocate(): number | null

	/**
	 * Get the last allocated messageId.
	 * @return {Number} - messageId.
	 */
	getLastAllocated(): number | null

	/**
	 * Register the messageId. The messageId become occupied status.
	 * If the messageId has already been occupied, then return false.
	 * @param {number} num - The messageId to request use.
	 * @return {boolean} - If `num` was not occupied, then return true, otherwise return false.
	 */
	register(num: number): boolean

	/**
	 * Deallocate the messageId. The messageId become vacant status.
	 * @param {Number} num - The messageId to deallocate. The messageId must be occupied status.
	 *                       In other words, the messageId must be allocated by allocate() or
	 *                       occupied by register().
	 */
	deallocate(num: number): void

	/**
	 * Clear all occupied messageIds.
	 * The all messageIds are set to vacant status.
	 */
	clear(): void
}

/**
 * DefaultMessageAllocator constructor
 * @constructor
 */
export default class DefaultMessageIdProvider implements IMessageIdProvider {
	private nextId: number

	constructor() {
		/**
		 * MessageIDs starting with 1
		 * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810
		 */
		this.nextId = Math.max(1, Math.floor(Math.random() * 65535))
	}

	/**
	 * allocate
	 *
	 * Get the next messageId.
	 * @return unsigned int
	 */
	allocate() {
		// id becomes current state of this.nextId and increments afterwards
		const id = this.nextId++
		// Ensure 16 bit unsigned int (max 65535, nextId got one higher)
		if (this.nextId === 65536) {
			this.nextId = 1
		}
		return id
	}

	/**
	 * getLastAllocated
	 * Get the last allocated messageId.
	 * @return unsigned int
	 */
	getLastAllocated() {
		return this.nextId === 1 ? 65535 : this.nextId - 1
	}

	/**
	 * register
	 * Register messageId. If success return true, otherwise return false.
	 * @param { unsigned int } - messageId to register,
	 * @return boolean
	 */
	register(messageId: number) {
		return true
	}

	/**
	 * deallocate
	 * Deallocate messageId.
	 * @param { unsigned int } - messageId to deallocate,
	 */
	deallocate(messageId: number) {}

	/**
	 * clear
	 * Deallocate all messageIds.
	 */
	clear() {}
}
// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND, ETIMEDOUT.

import { PacketHandler } from '../shared'

export const ReasonCodes = {
	0: '',
	1: 'Unacceptable protocol version',
	2: 'Identifier rejected',
	3: 'Server unavailable',
	4: 'Bad username or password',
	5: 'Not authorized',
	16: 'No matching subscribers',
	17: 'No subscription existed',
	128: 'Unspecified error',
	129: 'Malformed Packet',
	130: 'Protocol Error',
	131: 'Implementation specific error',
	132: 'Unsupported Protocol Version',
	133: 'Client Identifier not valid',
	134: 'Bad User Name or Password',
	135: 'Not authorized',
	136: 'Server unavailable',
	137: 'Server busy',
	138: 'Banned',
	139: 'Server shutting down',
	140: 'Bad authentication method',
	141: 'Keep Alive timeout',
	142: 'Session taken over',
	143: 'Topic Filter invalid',
	144: 'Topic Name invalid',
	145: 'Packet identifier in use',
	146: 'Packet Identifier not found',
	147: 'Receive Maximum exceeded',
	148: 'Topic Alias invalid',
	149: 'Packet too large',
	150: 'Message rate too high',
	151: 'Quota exceeded',
	152: 'Administrative action',
	153: 'Payload format invalid',
	154: 'Retain not supported',
	155: 'QoS not supported',
	156: 'Use another server',
	157: 'Server moved',
	158: 'Shared Subscriptions not supported',
	159: 'Connection rate exceeded',
	160: 'Maximum connect time',
	161: 'Subscription Identifiers not supported',
	162: 'Wildcard Subscriptions not supported',
}

const handleAck: PacketHandler = (client, packet) => {
	/* eslint no-fallthrough: "off" */
	const { messageId } = packet
	const type = packet.cmd
	let response = null
	const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null
	let err

	// Checking `!cb` happens to work, but it's not technically "correct".
	//
	// Why? client code assumes client "no callback" is the same as client "we're not
	// waiting for responses" (puback, pubrec, pubcomp, suback, or unsuback).
	//
	// It would be better to check `if (!client.outgoing[messageId])` here, but
	// there's no reason to change it and risk (another) regression.
	//
	// The only reason client code works is becaues code in MqttClient.publish,
	// MqttClinet.subscribe, and MqttClient.unsubscribe ensures client we will
	// have a callback even if the user doesn't pass one in.)
	if (!cb) {
		client.log('_handleAck :: Server sent an ack in error. Ignoring.')
		// Server sent an ack in error, ignore it.
		return
	}

	// Process
	client.log('_handleAck :: packet type', type)
	switch (type) {
		case 'pubcomp':
		// same thing as puback for QoS 2
		case 'puback': {
			const pubackRC = packet.reasonCode
			// Callback - we're done
			if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
				err = new Error(`Publish error: ${ReasonCodes[pubackRC]}`)
				err.code = pubackRC
				client['_removeOutgoingAndStoreMessage'](messageId, () => {
					cb(err, packet)
				})
			} else {
				client['_removeOutgoingAndStoreMessage'](messageId, cb)
			}

			break
		}
		case 'pubrec': {
			response = {
				cmd: 'pubrel',
				qos: 2,
				messageId,
			}
			const pubrecRC = packet.reasonCode

			if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
				err = new Error(`Publish error: ${ReasonCodes[pubrecRC]}`)
				err.code = pubrecRC
				client['_removeOutgoingAndStoreMessage'](messageId, () => {
					cb(err, packet)
				})
			} else {
				client['_sendPacket'](response)
			}
			break
		}
		case 'suback': {
			delete client.outgoing[messageId]
			client.messageIdProvider.deallocate(messageId)
			const granted = packet.granted as number[]
			for (let grantedI = 0; grantedI < granted.length; grantedI++) {
				if ((granted[grantedI] & 0x80) !== 0) {
					// suback with Failure status
					const topics = client.messageIdToTopic[messageId]
					if (topics) {
						topics.forEach((topic) => {
							delete client['_resubscribeTopics'][topic]
						})
					}
				}
			}
			delete client.messageIdToTopic[messageId]
			client['_invokeStoreProcessingQueue']()
			cb(null, packet)
			break
		}
		case 'unsuback': {
			delete client.outgoing[messageId]
			client.messageIdProvider.deallocate(messageId)
			client['_invokeStoreProcessingQueue']()
			cb(null)
			break
		}
		default:
			client.emit('error', new Error('unrecognized packet type'))
	}

	if (client.disconnecting && Object.keys(client.outgoing).length === 0) {
		client.emit('outgoingEmpty')
	}
}

export default handleAck
import { IAuthPacket } from 'mqtt-packet'
import { ErrorWithReasonCode, PacketHandler } from '../shared'
import { ReasonCodes } from './ack'

const handleAuth: PacketHandler = (
	client,
	packet: IAuthPacket & { returnCode: number },
) => {
	const { options } = client
	const version = options.protocolVersion
	const rc = version === 5 ? packet.reasonCode : packet.returnCode

	if (version !== 5) {
		const err = new ErrorWithReasonCode(
			`Protocol error: Auth packets are only supported in MQTT 5. Your version:${version}`,
			rc,
		)
		client.emit('error', err)
		return
	}

	client.handleAuth(
		packet,
		(err: ErrorWithReasonCode, packet2: IAuthPacket) => {
			if (err) {
				client.emit('error', err)
				return
			}

			if (rc === 24) {
				client.reconnecting = false
				client['_sendPacket'](packet2)
			} else {
				const error = new ErrorWithReasonCode(
					`Connection refused: ${ReasonCodes[rc]}`,
					rc,
				)
				client.emit('error', error)
			}
		},
	)
}

export default handleAuth
import { ReasonCodes } from './ack'
import TopicAliasSend from '../topic-alias-send'
import { ErrorWithReasonCode, PacketHandler } from '../shared'
import { IConnackPacket } from 'mqtt-packet'

const handleConnack: PacketHandler = (client, packet: IConnackPacket) => {
	client.log('_handleConnack')
	const { options } = client
	const version = options.protocolVersion
	const rc = version === 5 ? packet.reasonCode : packet.returnCode

	clearTimeout(client['connackTimer'])
	delete client['topicAliasSend']

	if (packet.properties) {
		if (packet.properties.topicAliasMaximum) {
			if (packet.properties.topicAliasMaximum > 0xffff) {
				client.emit(
					'error',
					new Error('topicAliasMaximum from broker is out of range'),
				)
				return
			}
			if (packet.properties.topicAliasMaximum > 0) {
				client['topicAliasSend'] = new TopicAliasSend(
					packet.properties.topicAliasMaximum,
				)
			}
		}
		if (packet.properties.serverKeepAlive && options.keepalive) {
			options.keepalive = packet.properties.serverKeepAlive
			client['_shiftPingInterval']()
		}
		if (packet.properties.maximumPacketSize) {
			if (!options.properties) {
				options.properties = {}
			}
			options.properties.maximumPacketSize =
				packet.properties.maximumPacketSize
		}
	}

	if (rc === 0) {
		client.reconnecting = false
		client['_onConnect'](packet)
	} else if (rc > 0) {
		const err = new ErrorWithReasonCode(
			`Connection refused: ${ReasonCodes[rc]}`,
			rc,
		)
		client.emit('error', err)
	}
}

export default handleConnack
import handlePublish from './publish'
import handleAuth from './auth'
import handleConnack from './connack'
import handleAck from './ack'
import handlePubrel from './pubrel'
import { PacketHandler } from '../shared'

const handle: PacketHandler = (client, packet, done) => {
	const { options } = client

	if (
		options.protocolVersion === 5 &&
		options.properties &&
		options.properties.maximumPacketSize &&
		options.properties.maximumPacketSize < packet.length
	) {
		client.emit('error', new Error(`exceeding packets size ${packet.cmd}`))
		client.end({
			reasonCode: 149,
			properties: { reasonString: 'Maximum packet size was exceeded' },
		})
		return client
	}
	client.log('_handlePacket :: emitting packetreceive')
	client.emit('packetreceive', packet)

	switch (packet.cmd) {
		case 'publish':
			handlePublish(client, packet, done)
			break
		case 'puback':
		case 'pubrec':
		case 'pubcomp':
		case 'suback':
		case 'unsuback':
			handleAck(client, packet)
			done()
			break
		case 'pubrel':
			handlePubrel(client, packet, done)
			break
		case 'connack':
			handleConnack(client, packet)
			done()
			break
		case 'auth':
			handleAuth(client, packet)
			done()
			break
		case 'pingresp':
			// this will be checked in _checkPing client method every keepalive interval
			client.pingResp = true
			done()
			break
		case 'disconnect':
			client.emit('disconnect', packet)
			done()
			break
		default:
			// TODO: unknown packet received. Should we emit an error?
			client.log('_handlePacket :: unknown command')
			done()
			break
	}
}

export default handle
import { IPublishPacket } from 'mqtt-packet'
import { PacketHandler } from '../shared'

const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]

/*
  those late 2 case should be rewrite to comply with coding style:

  case 1:
  case 0:
    // do not wait sending a puback
    // no callback passed
    if (1 === qos) {
      this._sendPacket({
        cmd: 'puback',
        messageId: messageId
      });
    }
    // emit the message event for both qos 1 and 0
    this.emit('message', topic, message, packet);
    this.handleMessage(packet, done);
    break;
  default:
    // do nothing but every switch mus have a default
    // log or throw an error about unknown qos
    break;

  for now i just suppressed the warnings
  */
const handlePublish: PacketHandler = (client, packet: IPublishPacket, done) => {
	client.log('handlePublish: packet %o', packet)
	done = typeof done !== 'undefined' ? done : client.noop
	let topic = packet.topic.toString()
	const message = packet.payload
	const { qos } = packet
	const { messageId } = packet
	const { options } = client
	if (client.options.protocolVersion === 5) {
		let alias: number
		if (packet.properties) {
			alias = packet.properties.topicAlias
		}
		if (typeof alias !== 'undefined') {
			if (topic.length === 0) {
				if (alias > 0 && alias <= 0xffff) {
					const gotTopic =
						client['topicAliasRecv'].getTopicByAlias(alias)
					if (gotTopic) {
						topic = gotTopic
						client.log(
							'handlePublish :: topic complemented by alias. topic: %s - alias: %d',
							topic,
							alias,
						)
					} else {
						client.log(
							'handlePublish :: unregistered topic alias. alias: %d',
							alias,
						)
						client.emit(
							'error',
							new Error('Received unregistered Topic Alias'),
						)
						return
					}
				} else {
					client.log(
						'handlePublish :: topic alias out of range. alias: %d',
						alias,
					)
					client.emit(
						'error',
						new Error('Received Topic Alias is out of range'),
					)
					return
				}
			} else if (client['topicAliasRecv'].put(topic, alias)) {
				client.log(
					'handlePublish :: registered topic: %s - alias: %d',
					topic,
					alias,
				)
			} else {
				client.log(
					'handlePublish :: topic alias out of range. alias: %d',
					alias,
				)
				client.emit(
					'error',
					new Error('Received Topic Alias is out of range'),
				)
				return
			}
		}
	}
	client.log('handlePublish: qos %d', qos)
	switch (qos) {
		case 2: {
			options.customHandleAcks(
				topic,
				message as Buffer,
				packet,
				(error, code) => {
					if (typeof error === 'number') {
						code = error
						error = null
					}
					if (error) {
						return client.emit('error', error as Error)
					}
					if (validReasonCodes.indexOf(code) === -1) {
						return client.emit(
							'error',
							new Error('Wrong reason code for pubrec'),
						)
					}
					if (code) {
						client['_sendPacket'](
							{ cmd: 'pubrec', messageId, reasonCode: code },
							done,
						)
					} else {
						client.incomingStore.put(packet, () => {
							client['_sendPacket'](
								{ cmd: 'pubrec', messageId },
								done,
							)
						})
					}
				},
			)
			break
		}
		case 1: {
			// emit the message event
			options.customHandleAcks(
				topic,
				message as Buffer,
				packet,
				(error, code) => {
					if (typeof error === 'number') {
						code = error
						error = null
					}
					if (error) {
						return client.emit('error', error as Error)
					}
					if (validReasonCodes.indexOf(code) === -1) {
						return client.emit(
							'error',
							new Error('Wrong reason code for puback'),
						)
					}
					if (!code) {
						client.emit('message', topic, message as Buffer, packet)
					}
					client.handleMessage(packet, (err) => {
						if (err) {
							return done && done(err)
						}
						client['_sendPacket'](
							{ cmd: 'puback', messageId, reasonCode: code },
							done,
						)
					})
				},
			)
			break
		}
		case 0:
			// emit the message event
			client.emit('message', topic, message as Buffer, packet)
			client.handleMessage(packet, done)
			break
		default:
			// do nothing
			client.log('handlePublish: unknown QoS. Doing nothing.')
			// log or throw an error about unknown qos
			break
	}
}

export default handlePublish
import { IPubcompPacket, IPublishPacket, IPubrelPacket } from 'mqtt-packet'
import { PacketHandler } from '../shared'

const handlePubrel: PacketHandler = (client, packet: IPubrelPacket, done) => {
	client.log('handling pubrel packet')
	const callback = typeof done !== 'undefined' ? done : client.noop
	const { messageId } = packet

	const comp: IPubcompPacket = { cmd: 'pubcomp', messageId }

	client.incomingStore.get(packet, (err, pub: IPublishPacket) => {
		if (!err) {
			client.emit('message', pub.topic, pub.payload as Buffer, pub)
			client.handleMessage(pub, (err2) => {
				if (err2) {
					return callback(err2)
				}
				client.incomingStore.del(pub, client.noop)
				client['_sendPacket'](comp, callback)
			})
		} else {
			client['_sendPacket'](comp, callback)
		}
	})
}

export default handlePubrel
const isBrowser =
	(typeof window !== 'undefined' && typeof window.document !== 'undefined') ||
	// eslint-disable-next-line no-restricted-globals
	(typeof self === 'object' &&
		// eslint-disable-next-line no-restricted-globals
		self.constructor &&
		// eslint-disable-next-line no-restricted-globals
		self.constructor.name === 'DedicatedWorkerGlobalScope') || // is web worker
	(typeof navigator !== 'undefined' && navigator.product === 'ReactNative') // while navigator.product is deprecated

export default isBrowser
import type { Packet } from 'mqtt-packet'
import type { Duplex } from 'stream'
import type MqttClient from './client'
import type { IClientOptions } from './client'

export type DoneCallback = (error?: Error) => void

export type GenericCallback<T> = (error?: Error, result?: T) => void

export type VoidCallback = () => void

export type IStream = Duplex

export type StreamBuilder = (
	client: MqttClient,
	opts?: IClientOptions,
) => IStream

export type Callback = () => void

export type PacketHandler = (
	client: MqttClient,
	packet: Packet,
	done?: DoneCallback,
) => void

export class ErrorWithReasonCode extends Error {
	public code: number

	public constructor(message: string, code: number) {
		super(message)
		this.code = code

		// We need to set the prototype explicitly
		Object.setPrototypeOf(this, ErrorWithReasonCode.prototype)
		Object.getPrototypeOf(this).name = 'ErrorWithReasonCode'
	}
}

// eslint-disable-next-line @typescript-eslint/ban-types
export type Constructor<T = {}> = new (...args: any[]) => T

export function applyMixin(
	target: Constructor,
	mixin: Constructor,
	includeConstructor = false,
): void {
	// Figure out the inheritance chain of the mixin
	const inheritanceChain: Constructor[] = [mixin]
	// eslint-disable-next-line no-constant-condition
	while (true) {
		const current = inheritanceChain[0]
		const base = Object.getPrototypeOf(current)
		if (base?.prototype) {
			inheritanceChain.unshift(base)
		} else {
			break
		}
	}
	for (const ctor of inheritanceChain) {
		for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {
			// Do not override the constructor
			if (includeConstructor || prop !== 'constructor') {
				Object.defineProperty(
					target.prototype,
					prop,
					Object.getOwnPropertyDescriptor(ctor.prototype, prop) ??
						Object.create(null),
				)
			}
		}
	}
}
/**
 * Module dependencies
 */
import { Readable } from 'readable-stream'
import { Packet } from 'mqtt-packet'
import { DoneCallback } from './shared'

const streamsOpts = { objectMode: true }
const defaultStoreOptions = {
	clean: true,
}

export interface IStoreOptions {
	/**
	 * true, clear _inflights at close
	 */
	clean?: boolean
}

export type PacketCallback = (error?: Error, packet?: Packet) => void

export interface IStore {
	/**
	 * Adds a packet to the store, a packet is
	 * anything that has a messageId property.
	 *
	 */
	put(packet: Packet, cb: DoneCallback): IStore

	/**
	 * Creates a stream with all the packets in the store
	 *
	 */
	createStream(): Readable

	/**
	 * deletes a packet from the store.
	 */
	del(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): IStore

	/**
	 * get a packet from the store.
	 */
	get(packet: Pick<Packet, 'messageId'>, cb: PacketCallback): IStore

	/**
	 * Close the store
	 */
	close(cb: DoneCallback): void
}

/**
 * In-memory implementation of the message store
 * This can actually be saved into files.
 *
 * @param {Object} [options] - store options
 */
export default class Store implements IStore {
	private options: IStoreOptions

	private _inflights: Map<number, Packet>

	constructor(options?: IStoreOptions) {
		this.options = options || {}

		// Defaults
		this.options = { ...defaultStoreOptions, ...options }

		this._inflights = new Map()
	}

	/**
	 * Adds a packet to the store, a packet is
	 * anything that has a messageId property.
	 *
	 */
	put(packet: Packet, cb: DoneCallback) {
		this._inflights.set(packet.messageId, packet)

		if (cb) {
			cb()
		}

		return this
	}

	/**
	 * Creates a stream with all the packets in the store
	 *
	 */
	createStream() {
		const stream = new Readable(streamsOpts)
		const values = []
		let destroyed = false
		let i = 0

		this._inflights.forEach((value, key) => {
			values.push(value)
		})

		stream._read = () => {
			if (!destroyed && i < values.length) {
				stream.push(values[i++])
			} else {
				stream.push(null)
			}
		}

		stream.destroy = (err) => {
			if (destroyed) {
				return
			}

			destroyed = true

			setTimeout(() => {
				stream.emit('close')
			}, 0)

			return stream
		}

		return stream
	}

	/**
	 * deletes a packet from the store.
	 */
	del(packet: Pick<Packet, 'messageId'>, cb: PacketCallback) {
		const toDelete = this._inflights.get(packet.messageId)
		if (toDelete) {
			this._inflights.delete(packet.messageId)
			cb(null, toDelete)
		} else if (cb) {
			cb(new Error('missing packet'))
		}

		return this
	}

	/**
	 * get a packet from the store.
	 */
	get(packet: Pick<Packet, 'messageId'>, cb: PacketCallback) {
		const storedPacket = this._inflights.get(packet.messageId)
		if (storedPacket) {
			cb(null, storedPacket)
		} else if (cb) {
			cb(new Error('missing packet'))
		}

		return this
	}

	/**
	 * Close the store
	 */
	close(cb: DoneCallback) {
		if (this.options.clean) {
			this._inflights = null
		}
		if (cb) {
			cb()
		}
	}
}
/**
 * Topic Alias receiving manager
 * This holds alias to topic map
 * @param {Number} [max] - topic alias maximum entries
 */
export default class TopicAliasRecv {
	private aliasToTopic: Record<number, string>

	public max: number

	public length: number

	constructor(max: number) {
		this.aliasToTopic = {}
		this.max = max
	}

	/**
	 * Insert or update topic - alias entry.
	 * @param {String} [topic] - topic
	 * @param {Number} [alias] - topic alias
	 * @returns {Boolean} - if success return true otherwise false
	 */
	put(topic: string, alias: number): boolean {
		if (alias === 0 || alias > this.max) {
			return false
		}
		this.aliasToTopic[alias] = topic
		this.length = Object.keys(this.aliasToTopic).length
		return true
	}

	/**
	 * Get topic by alias
	 * @param {String} [topic] - topic
	 * @returns {Number} - if mapped topic exists return topic alias, otherwise return undefined
	 */
	getTopicByAlias(alias: number): string {
		return this.aliasToTopic[alias]
	}

	/**
	 * Clear all entries
	 */
	clear() {
		this.aliasToTopic = {}
	}
}
/**
 * Module dependencies
 */
import LRUCache from 'lru-cache'
import { NumberAllocator } from 'number-allocator'

/**
 * Topic Alias sending manager
 * This holds both topic to alias and alias to topic map
 * @param {Number} [max] - topic alias maximum entries
 */
export default class TopicAliasSend {
	private aliasToTopic: LRUCache<number, string>

	private topicToAlias: Record<string, number>

	private max: number

	private numberAllocator: NumberAllocator

	public length: number

	constructor(max: number) {
		if (max > 0) {
			this.aliasToTopic = new LRUCache<number, string>({ max })
			this.topicToAlias = {}
			this.numberAllocator = new NumberAllocator(1, max)
			this.max = max
			this.length = 0
		}
	}

	/**
	 * Insert or update topic - alias entry.
	 * @param {String} [topic] - topic
	 * @param {Number} [alias] - topic alias
	 * @returns {Boolean} - if success return true otherwise false
	 */
	put(topic: string, alias: number): boolean {
		if (alias === 0 || alias > this.max) {
			return false
		}
		const entry = this.aliasToTopic.get(alias)
		if (entry) {
			delete this.topicToAlias[entry]
		}
		this.aliasToTopic.set(alias, topic)
		this.topicToAlias[topic] = alias
		this.numberAllocator.use(alias)
		this.length = this.aliasToTopic.size
		return true
	}

	/**
	 * Get topic by alias
	 * @param {Number} [alias] - topic alias
	 * @returns {String} - if mapped topic exists return topic, otherwise return undefined
	 */
	getTopicByAlias(alias: number): string {
		return this.aliasToTopic.get(alias)
	}

	/**
	 * Get topic by alias
	 * @param {String} [topic] - topic
	 * @returns {Number} - if mapped topic exists return topic alias, otherwise return undefined
	 */
	getAliasByTopic(topic: string): number | undefined {
		const alias = this.topicToAlias[topic]
		if (typeof alias !== 'undefined') {
			this.aliasToTopic.get(alias) // LRU update
		}
		return alias
	}

	/**
	 * Clear all entries
	 */
	clear() {
		this.aliasToTopic.clear()
		this.topicToAlias = {}
		this.numberAllocator.clear()
		this.length = 0
	}

	/**
	 * Get Least Recently Used (LRU) topic alias
	 * @returns {Number} - if vacant alias exists then return it, otherwise then return LRU alias
	 */
	getLruAlias(): number {
		const alias = this.numberAllocator.firstVacant()
		if (alias) return alias
		// get last alias (key) from LRU cache
		return [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1]
	}
}
import EventEmitter from 'events'
import { applyMixin } from './shared'

export type EventHandler =
	// Add more overloads as necessary
	| ((arg1: any, arg2: any, arg3: any, arg4: any) => void)
	| ((arg1: any, arg2: any, arg3: any) => void)
	| ((arg1: any, arg2: any) => void)
	| ((arg1: any) => void)
	| ((...args: any[]) => void)

export interface TypedEventEmitter<
	TEvents extends Record<keyof TEvents, EventHandler>,
> {
	on<TEvent extends keyof TEvents>(
		event: TEvent,
		callback: TEvents[TEvent],
	): this
	once<TEvent extends keyof TEvents>(
		event: TEvent,
		callback: TEvents[TEvent],
	): this
	prependListener<TEvent extends keyof TEvents>(
		event: TEvent,
		callback: TEvents[TEvent],
	): this
	prependOnceListener<TEvent extends keyof TEvents>(
		event: TEvent,
		callback: TEvents[TEvent],
	): this

	removeListener<TEvent extends keyof TEvents>(
		event: TEvent,
		callback: TEvents[TEvent],
	): this
	off<TEvent extends keyof TEvents>(
		event: TEvent,
		callback: TEvents[TEvent],
	): this

	removeAllListeners(event?: keyof TEvents): this

	emit<TEvent extends keyof TEvents>(
		event: TEvent,
		...args: Parameters<TEvents[TEvent]>
	): boolean

	setMaxListeners(n: number): this
	getMaxListeners(): number

	listeners<TEvent extends keyof TEvents>(
		eventName: TEvent,
	): TEvents[TEvent][]
	rawListeners<TEvent extends keyof TEvents>(
		eventName: TEvent,
	): TEvents[TEvent][]
	listenerCount<TEvent extends keyof TEvents>(
		event: TEvent,
		listener?: TEvents[TEvent],
	): number

	eventNames(): Array<keyof TEvents>
}

// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging
export class TypedEventEmitter<
	TEvents extends Record<keyof TEvents, EventHandler>,
> {}

// Make TypedEventEmitter inherit from EventEmitter without actually extending
applyMixin(TypedEventEmitter, EventEmitter)
import { NumberAllocator } from 'number-allocator'
import { IMessageIdProvider } from './default-message-id-provider'

/**
 * UniqueMessageAllocator constructor
 * @constructor
 */
export default class UniqueMessageIdProvider implements IMessageIdProvider {
	private numberAllocator: NumberAllocator

	private lastId: number

	constructor() {
		this.numberAllocator = new NumberAllocator(1, 65535)
	}

	/**
	 * allocate
	 *
	 * Get the next messageId.
	 * @return if messageId is fully allocated then return null,
	 *         otherwise return the smallest usable unsigned int messageId.
	 */
	allocate() {
		this.lastId = this.numberAllocator.alloc()
		return this.lastId
	}

	/**
	 * getLastAllocated
	 * Get the last allocated messageId.
	 * @return unsigned int
	 */
	getLastAllocated() {
		return this.lastId
	}

	/**
	 * register
	 * Register messageId. If success return true, otherwise return false.
	 * @param { unsigned int } - messageId to register,
	 * @return boolean
	 */
	register(messageId: number) {
		return this.numberAllocator.use(messageId) as boolean
	}

	/**
	 * deallocate
	 * Deallocate messageId.
	 * @param { unsigned int } - messageId to deallocate,
	 */
	deallocate(messageId: number) {
		this.numberAllocator.free(messageId)
	}

	/**
	 * clear
	 * Deallocate all messageIds.
	 */
	clear() {
		this.numberAllocator.clear()
	}
}
/**
 * Validate a topic to see if it's valid or not.
 * A topic is valid if it follow below rules:
 * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'
 * - Rule #2: Part `#` must be located at the end of the mailbox
 *
 * @param {String} topic - A topic
 * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.
 */
export function validateTopic(topic: string): boolean {
	const parts = topic.split('/')

	for (let i = 0; i < parts.length; i++) {
		if (parts[i] === '+') {
			continue
		}

		if (parts[i] === '#') {
			// for Rule #2
			return i === parts.length - 1
		}

		if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {
			return false
		}
	}

	return true
}

/**
 * Validate an array of topics to see if any of them is valid or not
 * @param {Array} topics - Array of topics
 * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one
 */
export function validateTopics(topics: string[]): string {
	if (topics.length === 0) {
		return 'empty_topic_list'
	}
	for (let i = 0; i < topics.length; i++) {
		if (!validateTopic(topics[i])) {
			return topics[i]
		}
	}
	return null
}
/*
 * Copyright (c) 2015-2015 MQTT.js contributors.
 * Copyright (c) 2011-2014 Adam Rudd.
 *
 * See LICENSE for more information
 */

import MqttClient from './lib/client'
import DefaultMessageIdProvider from './lib/default-message-id-provider'
import UniqueMessageIdProvider from './lib/unique-message-id-provider'
import Store, { IStore } from './lib/store'
import connect, { connectAsync } from './lib/connect'

export const Client = MqttClient
export {
	connect,
	connectAsync,
	MqttClient,
	Store,
	DefaultMessageIdProvider,
	UniqueMessageIdProvider,
	IStore,
}
export * from './lib/client'
export * from './lib/shared'
export { ReasonCodes } from './lib/handlers/ack'
'use strict'

// Keep this file as an alias for the full stream module.
module.exports = require('./stream').Duplex
'use strict'

// Keep this file as an alias for the full stream module.
module.exports = require('./stream').PassThrough
'use strict'

// Keep this file as an alias for the full stream module.
module.exports = require('./stream').Readable
'use strict'

// Keep this file as an alias for the full stream module.
module.exports = require('./stream').Transform
'use strict'

// Keep this file as an alias for the full stream module.
module.exports = require('./stream').Writable
'use strict'

const { SymbolDispose } = require('../../ours/primordials')
const { AbortError, codes } = require('../../ours/errors')
const { isNodeStream, isWebStream, kControllerErrorFunction } = require('./utils')
const eos = require('./end-of-stream')
const { ERR_INVALID_ARG_TYPE } = codes
let addAbortListener

// This method is inlined here for readable-stream
// It also does not allow for signal to not exist on the stream
// https://github.com/nodejs/node/pull/36061#discussion_r533718029
const validateAbortSignal = (signal, name) => {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
}
module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
  validateAbortSignal(signal, 'signal')
  if (!isNodeStream(stream) && !isWebStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
  }
  return module.exports.addAbortSignalNoValidate(signal, stream)
}
module.exports.addAbortSignalNoValidate = function (signal, stream) {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    return stream
  }
  const onAbort = isNodeStream(stream)
    ? () => {
        stream.destroy(
          new AbortError(undefined, {
            cause: signal.reason
          })
        )
      }
    : () => {
        stream[kControllerErrorFunction](
          new AbortError(undefined, {
            cause: signal.reason
          })
        )
      }
  if (signal.aborted) {
    onAbort()
  } else {
    addAbortListener = addAbortListener || require('../../ours/util').addAbortListener
    const disposable = addAbortListener(signal, onAbort)
    eos(stream, disposable[SymbolDispose])
  }
  return stream
}
'use strict'

const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')
const { Buffer } = require('buffer')
const { inspect } = require('../../ours/util')
module.exports = class BufferList {
  constructor() {
    this.head = null
    this.tail = null
    this.length = 0
  }
  push(v) {
    const entry = {
      data: v,
      next: null
    }
    if (this.length > 0) this.tail.next = entry
    else this.head = entry
    this.tail = entry
    ++this.length
  }
  unshift(v) {
    const entry = {
      data: v,
      next: this.head
    }
    if (this.length === 0) this.tail = entry
    this.head = entry
    ++this.length
  }
  shift() {
    if (this.length === 0) return
    const ret = this.head.data
    if (this.length === 1) this.head = this.tail = null
    else this.head = this.head.next
    --this.length
    return ret
  }
  clear() {
    this.head = this.tail = null
    this.length = 0
  }
  join(s) {
    if (this.length === 0) return ''
    let p = this.head
    let ret = '' + p.data
    while ((p = p.next) !== null) ret += s + p.data
    return ret
  }
  concat(n) {
    if (this.length === 0) return Buffer.alloc(0)
    const ret = Buffer.allocUnsafe(n >>> 0)
    let p = this.head
    let i = 0
    while (p) {
      TypedArrayPrototypeSet(ret, p.data, i)
      i += p.data.length
      p = p.next
    }
    return ret
  }

  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(n, hasStrings) {
    const data = this.head.data
    if (n < data.length) {
      // `slice` is the same for buffers and strings.
      const slice = data.slice(0, n)
      this.head.data = data.slice(n)
      return slice
    }
    if (n === data.length) {
      // First chunk is a perfect match.
      return this.shift()
    }
    // Result spans more than one buffer.
    return hasStrings ? this._getString(n) : this._getBuffer(n)
  }
  first() {
    return this.head.data
  }
  *[SymbolIterator]() {
    for (let p = this.head; p; p = p.next) {
      yield p.data
    }
  }

  // Consumes a specified amount of characters from the buffered data.
  _getString(n) {
    let ret = ''
    let p = this.head
    let c = 0
    do {
      const str = p.data
      if (n > str.length) {
        ret += str
        n -= str.length
      } else {
        if (n === str.length) {
          ret += str
          ++c
          if (p.next) this.head = p.next
          else this.head = this.tail = null
        } else {
          ret += StringPrototypeSlice(str, 0, n)
          this.head = p
          p.data = StringPrototypeSlice(str, n)
        }
        break
      }
      ++c
    } while ((p = p.next) !== null)
    this.length -= c
    return ret
  }

  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(n) {
    const ret = Buffer.allocUnsafe(n)
    const retLen = n
    let p = this.head
    let c = 0
    do {
      const buf = p.data
      if (n > buf.length) {
        TypedArrayPrototypeSet(ret, buf, retLen - n)
        n -= buf.length
      } else {
        if (n === buf.length) {
          TypedArrayPrototypeSet(ret, buf, retLen - n)
          ++c
          if (p.next) this.head = p.next
          else this.head = this.tail = null
        } else {
          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)
          this.head = p
          p.data = buf.slice(n)
        }
        break
      }
      ++c
    } while ((p = p.next) !== null)
    this.length -= c
    return ret
  }

  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for('nodejs.util.inspect.custom')](_, options) {
    return inspect(this, {
      ...options,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    })
  }
}
'use strict'

const { pipeline } = require('./pipeline')
const Duplex = require('./duplex')
const { destroyer } = require('./destroy')
const {
  isNodeStream,
  isReadable,
  isWritable,
  isWebStream,
  isTransformStream,
  isWritableStream,
  isReadableStream
} = require('./utils')
const {
  AbortError,
  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
} = require('../../ours/errors')
const eos = require('./end-of-stream')
module.exports = function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS('streams')
  }
  if (streams.length === 1) {
    return Duplex.from(streams[0])
  }
  const orgStreams = [...streams]
  if (typeof streams[0] === 'function') {
    streams[0] = Duplex.from(streams[0])
  }
  if (typeof streams[streams.length - 1] === 'function') {
    const idx = streams.length - 1
    streams[idx] = Duplex.from(streams[idx])
  }
  for (let n = 0; n < streams.length; ++n) {
    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
      // TODO(ronag): Add checks for non streams.
      continue
    }
    if (
      n < streams.length - 1 &&
      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))
    ) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')
    }
    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')
    }
  }
  let ondrain
  let onfinish
  let onreadable
  let onclose
  let d
  function onfinished(err) {
    const cb = onclose
    onclose = null
    if (cb) {
      cb(err)
    } else if (err) {
      d.destroy(err)
    } else if (!readable && !writable) {
      d.destroy()
    }
  }
  const head = streams[0]
  const tail = pipeline(streams, onfinished)
  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))
  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplex({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
    writable,
    readable
  })
  if (writable) {
    if (isNodeStream(head)) {
      d._write = function (chunk, encoding, callback) {
        if (head.write(chunk, encoding)) {
          callback()
        } else {
          ondrain = callback
        }
      }
      d._final = function (callback) {
        head.end()
        onfinish = callback
      }
      head.on('drain', function () {
        if (ondrain) {
          const cb = ondrain
          ondrain = null
          cb()
        }
      })
    } else if (isWebStream(head)) {
      const writable = isTransformStream(head) ? head.writable : head
      const writer = writable.getWriter()
      d._write = async function (chunk, encoding, callback) {
        try {
          await writer.ready
          writer.write(chunk).catch(() => {})
          callback()
        } catch (err) {
          callback(err)
        }
      }
      d._final = async function (callback) {
        try {
          await writer.ready
          writer.close().catch(() => {})
          onfinish = callback
        } catch (err) {
          callback(err)
        }
      }
    }
    const toRead = isTransformStream(tail) ? tail.readable : tail
    eos(toRead, () => {
      if (onfinish) {
        const cb = onfinish
        onfinish = null
        cb()
      }
    })
  }
  if (readable) {
    if (isNodeStream(tail)) {
      tail.on('readable', function () {
        if (onreadable) {
          const cb = onreadable
          onreadable = null
          cb()
        }
      })
      tail.on('end', function () {
        d.push(null)
      })
      d._read = function () {
        while (true) {
          const buf = tail.read()
          if (buf === null) {
            onreadable = d._read
            return
          }
          if (!d.push(buf)) {
            return
          }
        }
      }
    } else if (isWebStream(tail)) {
      const readable = isTransformStream(tail) ? tail.readable : tail
      const reader = readable.getReader()
      d._read = async function () {
        while (true) {
          try {
            const { value, done } = await reader.read()
            if (!d.push(value)) {
              return
            }
            if (done) {
              d.push(null)
              return
            }
          } catch {
            return
          }
        }
      }
    }
  }
  d._destroy = function (err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError()
    }
    onreadable = null
    ondrain = null
    onfinish = null
    if (onclose === null) {
      callback(err)
    } else {
      onclose = callback
      if (isNodeStream(tail)) {
        destroyer(tail, err)
      }
    }
  }
  return d
}
'use strict'

/* replacement start */

const process = require('process/')

/* replacement end */

const {
  aggregateTwoErrors,
  codes: { ERR_MULTIPLE_CALLBACK },
  AbortError
} = require('../../ours/errors')
const { Symbol } = require('../../ours/primordials')
const { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require('./utils')
const kDestroy = Symbol('kDestroy')
const kConstruct = Symbol('kConstruct')
function checkError(err, w, r) {
  if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err
    }
    if (r && !r.errored) {
      r.errored = err
    }
  }
}

// Backwards compat. cb() is undocumented and unused in core but
// unfortunately might be used by modules.
function destroy(err, cb) {
  const r = this._readableState
  const w = this._writableState
  // With duplex streams we use the writable side for state.
  const s = w || r
  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
    if (typeof cb === 'function') {
      cb()
    }
    return this
  }

  // We set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks
  checkError(err, w, r)
  if (w) {
    w.destroyed = true
  }
  if (r) {
    r.destroyed = true
  }

  // If still constructing then defer calling _destroy.
  if (!s.constructed) {
    this.once(kDestroy, function (er) {
      _destroy(this, aggregateTwoErrors(er, err), cb)
    })
  } else {
    _destroy(this, err, cb)
  }
  return this
}
function _destroy(self, err, cb) {
  let called = false
  function onDestroy(err) {
    if (called) {
      return
    }
    called = true
    const r = self._readableState
    const w = self._writableState
    checkError(err, w, r)
    if (w) {
      w.closed = true
    }
    if (r) {
      r.closed = true
    }
    if (typeof cb === 'function') {
      cb(err)
    }
    if (err) {
      process.nextTick(emitErrorCloseNT, self, err)
    } else {
      process.nextTick(emitCloseNT, self)
    }
  }
  try {
    self._destroy(err || null, onDestroy)
  } catch (err) {
    onDestroy(err)
  }
}
function emitErrorCloseNT(self, err) {
  emitErrorNT(self, err)
  emitCloseNT(self)
}
function emitCloseNT(self) {
  const r = self._readableState
  const w = self._writableState
  if (w) {
    w.closeEmitted = true
  }
  if (r) {
    r.closeEmitted = true
  }
  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {
    self.emit('close')
  }
}
function emitErrorNT(self, err) {
  const r = self._readableState
  const w = self._writableState
  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {
    return
  }
  if (w) {
    w.errorEmitted = true
  }
  if (r) {
    r.errorEmitted = true
  }
  self.emit('error', err)
}
function undestroy() {
  const r = this._readableState
  const w = this._writableState
  if (r) {
    r.constructed = true
    r.closed = false
    r.closeEmitted = false
    r.destroyed = false
    r.errored = null
    r.errorEmitted = false
    r.reading = false
    r.ended = r.readable === false
    r.endEmitted = r.readable === false
  }
  if (w) {
    w.constructed = true
    w.destroyed = false
    w.closed = false
    w.closeEmitted = false
    w.errored = null
    w.errorEmitted = false
    w.finalCalled = false
    w.prefinished = false
    w.ended = w.writable === false
    w.ending = w.writable === false
    w.finished = w.writable === false
  }
}
function errorOrDestroy(stream, err, sync) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  const r = stream._readableState
  const w = stream._writableState
  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
    return this
  }
  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))
    stream.destroy(err)
  else if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err
    }
    if (r && !r.errored) {
      r.errored = err
    }
    if (sync) {
      process.nextTick(emitErrorNT, stream, err)
    } else {
      emitErrorNT(stream, err)
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== 'function') {
    return
  }
  const r = stream._readableState
  const w = stream._writableState
  if (r) {
    r.constructed = false
  }
  if (w) {
    w.constructed = false
  }
  stream.once(kConstruct, cb)
  if (stream.listenerCount(kConstruct) > 1) {
    // Duplex
    return
  }
  process.nextTick(constructNT, stream)
}
function constructNT(stream) {
  let called = false
  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())
      return
    }
    called = true
    const r = stream._readableState
    const w = stream._writableState
    const s = w || r
    if (r) {
      r.constructed = true
    }
    if (w) {
      w.constructed = true
    }
    if (s.destroyed) {
      stream.emit(kDestroy, err)
    } else if (err) {
      errorOrDestroy(stream, err, true)
    } else {
      process.nextTick(emitConstructNT, stream)
    }
  }
  try {
    stream._construct((err) => {
      process.nextTick(onConstruct, err)
    })
  } catch (err) {
    process.nextTick(onConstruct, err)
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct)
}
function isRequest(stream) {
  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'
}
function emitCloseLegacy(stream) {
  stream.emit('close')
}
function emitErrorCloseLegacy(stream, err) {
  stream.emit('error', err)
  process.nextTick(emitCloseLegacy, stream)
}

// Normalize destroy for legacy.
function destroyer(stream, err) {
  if (!stream || isDestroyed(stream)) {
    return
  }
  if (!err && !isFinished(stream)) {
    err = new AbortError()
  }

  // TODO: Remove isRequest branches.
  if (isServerRequest(stream)) {
    stream.socket = null
    stream.destroy(err)
  } else if (isRequest(stream)) {
    stream.abort()
  } else if (isRequest(stream.req)) {
    stream.req.abort()
  } else if (typeof stream.destroy === 'function') {
    stream.destroy(err)
  } else if (typeof stream.close === 'function') {
    // TODO: Don't lose err?
    stream.close()
  } else if (err) {
    process.nextTick(emitErrorCloseLegacy, stream, err)
  } else {
    process.nextTick(emitCloseLegacy, stream)
  }
  if (!stream.destroyed) {
    stream[kIsDestroyed] = true
  }
}
module.exports = {
  construct,
  destroyer,
  destroy,
  undestroy,
  errorOrDestroy
}
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototype inheritance, this class
// prototypically inherits from Readable, and then parasitically from
// Writable.

'use strict'

const {
  ObjectDefineProperties,
  ObjectGetOwnPropertyDescriptor,
  ObjectKeys,
  ObjectSetPrototypeOf
} = require('../../ours/primordials')
module.exports = Duplex
const Readable = require('./readable')
const Writable = require('./writable')
ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)
ObjectSetPrototypeOf(Duplex, Readable)
{
  const keys = ObjectKeys(Writable.prototype)
  // Allow the keys array to be GC'ed.
  for (let i = 0; i < keys.length; i++) {
    const method = keys[i]
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options)
  Readable.call(this, options)
  Writable.call(this, options)
  if (options) {
    this.allowHalfOpen = options.allowHalfOpen !== false
    if (options.readable === false) {
      this._readableState.readable = false
      this._readableState.ended = true
      this._readableState.endEmitted = true
    }
    if (options.writable === false) {
      this._writableState.writable = false
      this._writableState.ending = true
      this._writableState.ended = true
      this._writableState.finished = true
    }
  } else {
    this.allowHalfOpen = true
  }
}
ObjectDefineProperties(Duplex.prototype, {
  writable: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')
  },
  writableHighWaterMark: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')
  },
  writableObjectMode: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')
  },
  writableBuffer: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')
  },
  writableLength: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')
  },
  writableFinished: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')
  },
  writableCorked: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')
  },
  writableEnded: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')
  },
  writableNeedDrain: {
    __proto__: null,
    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')
  },
  destroyed: {
    __proto__: null,
    get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false
      }
      return this._readableState.destroyed && this._writableState.destroyed
    },
    set(value) {
      // Backward compatibility, the user is explicitly
      // managing destroyed.
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value
        this._writableState.destroyed = value
      }
    }
  }
})
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Duplex.fromWeb = function (pair, options) {
  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)
}
Duplex.toWeb = function (duplex) {
  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)
}
let duplexify
Duplex.from = function (body) {
  if (!duplexify) {
    duplexify = require('./duplexify')
  }
  return duplexify(body, 'body')
}
/* replacement start */

const process = require('process/')

/* replacement end */

;('use strict')
const bufferModule = require('buffer')
const {
  isReadable,
  isWritable,
  isIterable,
  isNodeStream,
  isReadableNodeStream,
  isWritableNodeStream,
  isDuplexNodeStream,
  isReadableStream,
  isWritableStream
} = require('./utils')
const eos = require('./end-of-stream')
const {
  AbortError,
  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
} = require('../../ours/errors')
const { destroyer } = require('./destroy')
const Duplex = require('./duplex')
const Readable = require('./readable')
const Writable = require('./writable')
const { createDeferredPromise } = require('../../ours/util')
const from = require('./from')
const Blob = globalThis.Blob || bufferModule.Blob
const isBlob =
  typeof Blob !== 'undefined'
    ? function isBlob(b) {
        return b instanceof Blob
      }
    : function isBlob(b) {
        return false
      }
const AbortController = globalThis.AbortController || require('abort-controller').AbortController
const { FunctionPrototypeCall } = require('../../ours/primordials')

// This is needed for pre node 17.
class Duplexify extends Duplex {
  constructor(options) {
    super(options)

    // https://github.com/nodejs/node/pull/34385

    if ((options === null || options === undefined ? undefined : options.readable) === false) {
      this._readableState.readable = false
      this._readableState.ended = true
      this._readableState.endEmitted = true
    }
    if ((options === null || options === undefined ? undefined : options.writable) === false) {
      this._writableState.writable = false
      this._writableState.ending = true
      this._writableState.ended = true
      this._writableState.finished = true
    }
  }
}
module.exports = function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body
  }
  if (isReadableNodeStream(body)) {
    return _duplexify({
      readable: body
    })
  }
  if (isWritableNodeStream(body)) {
    return _duplexify({
      writable: body
    })
  }
  if (isNodeStream(body)) {
    return _duplexify({
      writable: false,
      readable: false
    })
  }
  if (isReadableStream(body)) {
    return _duplexify({
      readable: Readable.fromWeb(body)
    })
  }
  if (isWritableStream(body)) {
    return _duplexify({
      writable: Writable.fromWeb(body)
    })
  }
  if (typeof body === 'function') {
    const { value, write, final, destroy } = fromAsyncGen(body)
    if (isIterable(value)) {
      return from(Duplexify, value, {
        // TODO (ronag): highWaterMark?
        objectMode: true,
        write,
        final,
        destroy
      })
    }
    const then = value === null || value === undefined ? undefined : value.then
    if (typeof then === 'function') {
      let d
      const promise = FunctionPrototypeCall(
        then,
        value,
        (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)
          }
        },
        (err) => {
          destroyer(d, err)
        }
      )
      return (d = new Duplexify({
        // TODO (ronag): highWaterMark?
        objectMode: true,
        readable: false,
        write,
        final(cb) {
          final(async () => {
            try {
              await promise
              process.nextTick(cb, null)
            } catch (err) {
              process.nextTick(cb, err)
            }
          })
        },
        destroy
      }))
    }
    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)
  }
  if (isBlob(body)) {
    return duplexify(body.arrayBuffer())
  }
  if (isIterable(body)) {
    return from(Duplexify, body, {
      // TODO (ronag): highWaterMark?
      objectMode: true,
      writable: false
    })
  }
  if (
    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&
    isWritableStream(body === null || body === undefined ? undefined : body.writable)
  ) {
    return Duplexify.fromWeb(body)
  }
  if (
    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||
    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'
  ) {
    const readable =
      body !== null && body !== undefined && body.readable
        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)
          ? body === null || body === undefined
            ? undefined
            : body.readable
          : duplexify(body.readable)
        : undefined
    const writable =
      body !== null && body !== undefined && body.writable
        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)
          ? body === null || body === undefined
            ? undefined
            : body.writable
          : duplexify(body.writable)
        : undefined
    return _duplexify({
      readable,
      writable
    })
  }
  const then = body === null || body === undefined ? undefined : body.then
  if (typeof then === 'function') {
    let d
    FunctionPrototypeCall(
      then,
      body,
      (val) => {
        if (val != null) {
          d.push(val)
        }
        d.push(null)
      },
      (err) => {
        destroyer(d, err)
      }
    )
    return (d = new Duplexify({
      objectMode: true,
      writable: false,
      read() {}
    }))
  }
  throw new ERR_INVALID_ARG_TYPE(
    name,
    [
      'Blob',
      'ReadableStream',
      'WritableStream',
      'Stream',
      'Iterable',
      'AsyncIterable',
      'Function',
      '{ readable, writable } pair',
      'Promise'
    ],
    body
  )
}
function fromAsyncGen(fn) {
  let { promise, resolve } = createDeferredPromise()
  const ac = new AbortController()
  const signal = ac.signal
  const value = fn(
    (async function* () {
      while (true) {
        const _promise = promise
        promise = null
        const { chunk, done, cb } = await _promise
        process.nextTick(cb)
        if (done) return
        if (signal.aborted)
          throw new AbortError(undefined, {
            cause: signal.reason
          })
        ;({ promise, resolve } = createDeferredPromise())
        yield chunk
      }
    })(),
    {
      signal
    }
  )
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve
      resolve = null
      _resolve({
        chunk,
        done: false,
        cb
      })
    },
    final(cb) {
      const _resolve = resolve
      resolve = null
      _resolve({
        done: true,
        cb
      })
    },
    destroy(err, cb) {
      ac.abort()
      cb(err)
    }
  }
}
function _duplexify(pair) {
  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable
  const w = pair.writable
  let readable = !!isReadable(r)
  let writable = !!isWritable(w)
  let ondrain
  let onfinish
  let onreadable
  let onclose
  let d
  function onfinished(err) {
    const cb = onclose
    onclose = null
    if (cb) {
      cb(err)
    } else if (err) {
      d.destroy(err)
    }
  }

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplexify({
    // TODO (ronag): highWaterMark?
    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
    readable,
    writable
  })
  if (writable) {
    eos(w, (err) => {
      writable = false
      if (err) {
        destroyer(r, err)
      }
      onfinished(err)
    })
    d._write = function (chunk, encoding, callback) {
      if (w.write(chunk, encoding)) {
        callback()
      } else {
        ondrain = callback
      }
    }
    d._final = function (callback) {
      w.end()
      onfinish = callback
    }
    w.on('drain', function () {
      if (ondrain) {
        const cb = ondrain
        ondrain = null
        cb()
      }
    })
    w.on('finish', function () {
      if (onfinish) {
        const cb = onfinish
        onfinish = null
        cb()
      }
    })
  }
  if (readable) {
    eos(r, (err) => {
      readable = false
      if (err) {
        destroyer(r, err)
      }
      onfinished(err)
    })
    r.on('readable', function () {
      if (onreadable) {
        const cb = onreadable
        onreadable = null
        cb()
      }
    })
    r.on('end', function () {
      d.push(null)
    })
    d._read = function () {
      while (true) {
        const buf = r.read()
        if (buf === null) {
          onreadable = d._read
          return
        }
        if (!d.push(buf)) {
          return
        }
      }
    }
  }
  d._destroy = function (err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError()
    }
    onreadable = null
    ondrain = null
    onfinish = null
    if (onclose === null) {
      callback(err)
    } else {
      onclose = callback
      destroyer(w, err)
      destroyer(r, err)
    }
  }
  return d
}
/* replacement start */

const process = require('process/')

/* replacement end */
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

;('use strict')
const { AbortError, codes } = require('../../ours/errors')
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes
const { kEmptyObject, once } = require('../../ours/util')
const { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')
const { Promise, PromisePrototypeThen, SymbolDispose } = require('../../ours/primordials')
const {
  isClosed,
  isReadable,
  isReadableNodeStream,
  isReadableStream,
  isReadableFinished,
  isReadableErrored,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableFinished,
  isWritableErrored,
  isNodeStream,
  willEmitClose: _willEmitClose,
  kIsClosedPromise
} = require('./utils')
let addAbortListener
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function'
}
const nop = () => {}
function eos(stream, options, callback) {
  var _options$readable, _options$writable
  if (arguments.length === 2) {
    callback = options
    options = kEmptyObject
  } else if (options == null) {
    options = kEmptyObject
  } else {
    validateObject(options, 'options')
  }
  validateFunction(callback, 'callback')
  validateAbortSignal(options.signal, 'options.signal')
  callback = once(callback)
  if (isReadableStream(stream) || isWritableStream(stream)) {
    return eosWeb(stream, options, callback)
  }
  if (!isNodeStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
  }
  const readable =
    (_options$readable = options.readable) !== null && _options$readable !== undefined
      ? _options$readable
      : isReadableNodeStream(stream)
  const writable =
    (_options$writable = options.writable) !== null && _options$writable !== undefined
      ? _options$writable
      : isWritableNodeStream(stream)
  const wState = stream._writableState
  const rState = stream._readableState
  const onlegacyfinish = () => {
    if (!stream.writable) {
      onfinish()
    }
  }

  // TODO (ronag): Improve soft detection to include core modules and
  // common ecosystem modules that do properly emit 'close' but fail
  // this generic check.
  let willEmitClose =
    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable
  let writableFinished = isWritableFinished(stream, false)
  const onfinish = () => {
    writableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose && (!stream.readable || readable)) {
      return
    }
    if (!readable || readableFinished) {
      callback.call(stream)
    }
  }
  let readableFinished = isReadableFinished(stream, false)
  const onend = () => {
    readableFinished = true
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) {
      willEmitClose = false
    }
    if (willEmitClose && (!stream.writable || writable)) {
      return
    }
    if (!writable || writableFinished) {
      callback.call(stream)
    }
  }
  const onerror = (err) => {
    callback.call(stream, err)
  }
  let closed = isClosed(stream)
  const onclose = () => {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored)
    }
    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
    }
    callback.call(stream)
  }
  const onclosed = () => {
    closed = true
    const errored = isWritableErrored(stream) || isReadableErrored(stream)
    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored)
    }
    callback.call(stream)
  }
  const onrequest = () => {
    stream.req.on('finish', onfinish)
  }
  if (isRequest(stream)) {
    stream.on('complete', onfinish)
    if (!willEmitClose) {
      stream.on('abort', onclose)
    }
    if (stream.req) {
      onrequest()
    } else {
      stream.on('request', onrequest)
    }
  } else if (writable && !wState) {
    // legacy streams
    stream.on('end', onlegacyfinish)
    stream.on('close', onlegacyfinish)
  }

  // Not all streams will emit 'close' after 'aborted'.
  if (!willEmitClose && typeof stream.aborted === 'boolean') {
    stream.on('aborted', onclose)
  }
  stream.on('end', onend)
  stream.on('finish', onfinish)
  if (options.error !== false) {
    stream.on('error', onerror)
  }
  stream.on('close', onclose)
  if (closed) {
    process.nextTick(onclose)
  } else if (
    (wState !== null && wState !== undefined && wState.errorEmitted) ||
    (rState !== null && rState !== undefined && rState.errorEmitted)
  ) {
    if (!willEmitClose) {
      process.nextTick(onclosed)
    }
  } else if (
    !readable &&
    (!willEmitClose || isReadable(stream)) &&
    (writableFinished || isWritable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (
    !writable &&
    (!willEmitClose || isWritable(stream)) &&
    (readableFinished || isReadable(stream) === false)
  ) {
    process.nextTick(onclosed)
  } else if (rState && stream.req && stream.aborted) {
    process.nextTick(onclosed)
  }
  const cleanup = () => {
    callback = nop
    stream.removeListener('aborted', onclose)
    stream.removeListener('complete', onfinish)
    stream.removeListener('abort', onclose)
    stream.removeListener('request', onrequest)
    if (stream.req) stream.req.removeListener('finish', onfinish)
    stream.removeListener('end', onlegacyfinish)
    stream.removeListener('close', onlegacyfinish)
    stream.removeListener('finish', onfinish)
    stream.removeListener('end', onend)
    stream.removeListener('error', onerror)
    stream.removeListener('close', onclose)
  }
  if (options.signal && !closed) {
    const abort = () => {
      // Keep it because cleanup removes it.
      const endCallback = callback
      cleanup()
      endCallback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener
      const disposable = addAbortListener(options.signal, abort)
      const originalCallback = callback
      callback = once((...args) => {
        disposable[SymbolDispose]()
        originalCallback.apply(stream, args)
      })
    }
  }
  return cleanup
}
function eosWeb(stream, options, callback) {
  let isAborted = false
  let abort = nop
  if (options.signal) {
    abort = () => {
      isAborted = true
      callback.call(
        stream,
        new AbortError(undefined, {
          cause: options.signal.reason
        })
      )
    }
    if (options.signal.aborted) {
      process.nextTick(abort)
    } else {
      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener
      const disposable = addAbortListener(options.signal, abort)
      const originalCallback = callback
      callback = once((...args) => {
        disposable[SymbolDispose]()
        originalCallback.apply(stream, args)
      })
    }
  }
  const resolverFn = (...args) => {
    if (!isAborted) {
      process.nextTick(() => callback.apply(stream, args))
    }
  }
  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)
  return nop
}
function finished(stream, opts) {
  var _opts
  let autoCleanup = false
  if (opts === null) {
    opts = kEmptyObject
  }
  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
    validateBoolean(opts.cleanup, 'cleanup')
    autoCleanup = opts.cleanup
  }
  return new Promise((resolve, reject) => {
    const cleanup = eos(stream, opts, (err) => {
      if (autoCleanup) {
        cleanup()
      }
      if (err) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}
module.exports = eos
module.exports.finished = finished
'use strict'

/* replacement start */

const process = require('process/')

/* replacement end */

const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require('../../ours/primordials')
const { Buffer } = require('buffer')
const { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require('../../ours/errors').codes
function from(Readable, iterable, opts) {
  let iterator
  if (typeof iterable === 'string' || iterable instanceof Buffer) {
    return new Readable({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable)
        this.push(null)
      }
    })
  }
  let isAsync
  if (iterable && iterable[SymbolAsyncIterator]) {
    isAsync = true
    iterator = iterable[SymbolAsyncIterator]()
  } else if (iterable && iterable[SymbolIterator]) {
    isAsync = false
    iterator = iterable[SymbolIterator]()
  } else {
    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)
  }
  const readable = new Readable({
    objectMode: true,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...opts
  })

  // Flag to protect against _read
  // being called before last iteration completion.
  let reading = false
  readable._read = function () {
    if (!reading) {
      reading = true
      next()
    }
  }
  readable._destroy = function (error, cb) {
    PromisePrototypeThen(
      close(error),
      () => process.nextTick(cb, error),
      // nextTick is here in case cb throws
      (e) => process.nextTick(cb, e || error)
    )
  }
  async function close(error) {
    const hadError = error !== undefined && error !== null
    const hasThrow = typeof iterator.throw === 'function'
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error)
      await value
      if (done) {
        return
      }
    }
    if (typeof iterator.return === 'function') {
      const { value } = await iterator.return()
      await value
    }
  }
  async function next() {
    for (;;) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next()
        if (done) {
          readable.push(null)
        } else {
          const res = value && typeof value.then === 'function' ? await value : value
          if (res === null) {
            reading = false
            throw new ERR_STREAM_NULL_VALUES()
          } else if (readable.push(res)) {
            continue
          } else {
            reading = false
          }
        }
      } catch (err) {
        readable.destroy(err)
      }
      break
    }
  }
  return readable
}
module.exports = from
// LazyTransform is a special type of Transform stream that is lazily loaded.
// This is used for performance with bi-API-ship: when two APIs are available
// for the stream, one conventional and one non-conventional.
'use strict'

const { ObjectDefineProperties, ObjectDefineProperty, ObjectSetPrototypeOf } = require('../../ours/primordials')
const stream = require('../../stream')
const { getDefaultEncoding } = require('../crypto/util')
module.exports = LazyTransform
function LazyTransform(options) {
  this._options = options
}
ObjectSetPrototypeOf(LazyTransform.prototype, stream.Transform.prototype)
ObjectSetPrototypeOf(LazyTransform, stream.Transform)
function makeGetter(name) {
  return function () {
    stream.Transform.call(this, this._options)
    this._writableState.decodeStrings = false
    if (!this._options || !this._options.defaultEncoding) {
      this._writableState.defaultEncoding = getDefaultEncoding()
    }
    return this[name]
  }
}
function makeSetter(name) {
  return function (val) {
    ObjectDefineProperty(this, name, {
      __proto__: null,
      value: val,
      enumerable: true,
      configurable: true,
      writable: true
    })
  }
}
ObjectDefineProperties(LazyTransform.prototype, {
  _readableState: {
    __proto__: null,
    get: makeGetter('_readableState'),
    set: makeSetter('_readableState'),
    configurable: true,
    enumerable: true
  },
  _writableState: {
    __proto__: null,
    get: makeGetter('_writableState'),
    set: makeSetter('_writableState'),
    configurable: true,
    enumerable: true
  }
})
'use strict'

const { ArrayIsArray, ObjectSetPrototypeOf } = require('../../ours/primordials')
const { EventEmitter: EE } = require('events')
function Stream(opts) {
  EE.call(this, opts)
}
ObjectSetPrototypeOf(Stream.prototype, EE.prototype)
ObjectSetPrototypeOf(Stream, EE)
Stream.prototype.pipe = function (dest, options) {
  const source = this
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause()
    }
  }
  source.on('data', ondata)
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume()
    }
  }
  dest.on('drain', ondrain)

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend)
    source.on('close', onclose)
  }
  let didOnEnd = false
  function onend() {
    if (didOnEnd) return
    didOnEnd = true
    dest.end()
  }
  function onclose() {
    if (didOnEnd) return
    didOnEnd = true
    if (typeof dest.destroy === 'function') dest.destroy()
  }

  // Don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup()
    if (EE.listenerCount(this, 'error') === 0) {
      this.emit('error', er)
    }
  }
  prependListener(source, 'error', onerror)
  prependListener(dest, 'error', onerror)

  // Remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata)
    dest.removeListener('drain', ondrain)
    source.removeListener('end', onend)
    source.removeListener('close', onclose)
    source.removeListener('error', onerror)
    dest.removeListener('error', onerror)
    source.removeListener('end', cleanup)
    source.removeListener('close', cleanup)
    dest.removeListener('close', cleanup)
  }
  source.on('end', cleanup)
  source.on('close', cleanup)
  dest.on('close', cleanup)
  dest.emit('pipe', source)

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest
}
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)
  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)
  else emitter._events[event] = [fn, emitter._events[event]]
}
module.exports = {
  Stream,
  prependListener
}
'use strict'

const AbortController = globalThis.AbortController || require('abort-controller').AbortController
const {
  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
  AbortError
} = require('../../ours/errors')
const { validateAbortSignal, validateInteger, validateObject } = require('../validators')
const kWeakHandler = require('../../ours/primordials').Symbol('kWeak')
const kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation')
const { finished } = require('./end-of-stream')
const staticCompose = require('./compose')
const { addAbortSignalNoValidate } = require('./add-abort-signal')
const { isWritable, isNodeStream } = require('./utils')
const { deprecate } = require('../../ours/util')
const {
  ArrayPrototypePush,
  Boolean,
  MathFloor,
  Number,
  NumberIsNaN,
  Promise,
  PromiseReject,
  PromiseResolve,
  PromisePrototypeThen,
  Symbol
} = require('../../ours/primordials')
const kEmpty = Symbol('kEmpty')
const kEof = Symbol('kEof')
function compose(stream, options) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  if (isNodeStream(stream) && !isWritable(stream)) {
    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')
  }
  const composedStream = staticCompose(this, stream)
  if (options !== null && options !== undefined && options.signal) {
    // Not validating as we already validated before
    addAbortSignalNoValidate(options.signal, composedStream)
  }
  return composedStream
}
function map(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  let concurrency = 1
  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
    concurrency = MathFloor(options.concurrency)
  }
  let highWaterMark = concurrency - 1
  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
    highWaterMark = MathFloor(options.highWaterMark)
  }
  validateInteger(concurrency, 'options.concurrency', 1)
  validateInteger(highWaterMark, 'options.highWaterMark', 0)
  highWaterMark += concurrency
  return async function* map() {
    const signal = require('../../ours/util').AbortSignalAny(
      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)
    )
    const stream = this
    const queue = []
    const signalOpt = {
      signal
    }
    let next
    let resume
    let done = false
    let cnt = 0
    function onCatch() {
      done = true
      afterItemProcessed()
    }
    function afterItemProcessed() {
      cnt -= 1
      maybeResume()
    }
    function maybeResume() {
      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
        resume()
        resume = null
      }
    }
    async function pump() {
      try {
        for await (let val of stream) {
          if (done) {
            return
          }
          if (signal.aborted) {
            throw new AbortError()
          }
          try {
            val = fn(val, signalOpt)
            if (val === kEmpty) {
              continue
            }
            val = PromiseResolve(val)
          } catch (err) {
            val = PromiseReject(err)
          }
          cnt += 1
          PromisePrototypeThen(val, afterItemProcessed, onCatch)
          queue.push(val)
          if (next) {
            next()
            next = null
          }
          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
            await new Promise((resolve) => {
              resume = resolve
            })
          }
        }
        queue.push(kEof)
      } catch (err) {
        const val = PromiseReject(err)
        PromisePrototypeThen(val, afterItemProcessed, onCatch)
        queue.push(val)
      } finally {
        done = true
        if (next) {
          next()
          next = null
        }
      }
    }
    pump()
    try {
      while (true) {
        while (queue.length > 0) {
          const val = await queue[0]
          if (val === kEof) {
            return
          }
          if (signal.aborted) {
            throw new AbortError()
          }
          if (val !== kEmpty) {
            yield val
          }
          queue.shift()
          maybeResume()
        }
        await new Promise((resolve) => {
          next = resolve
        })
      }
    } finally {
      done = true
      if (resume) {
        resume()
        resume = null
      }
    }
  }.call(this)
}
function asIndexedPairs(options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  return async function* asIndexedPairs() {
    let index = 0
    for await (const val of this) {
      var _options$signal
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal = options.signal) !== null &&
        _options$signal !== undefined &&
        _options$signal.aborted
      ) {
        throw new AbortError({
          cause: options.signal.reason
        })
      }
      yield [index++, val]
    }
  }.call(this)
}
async function some(fn, options = undefined) {
  for await (const unused of filter.call(this, fn, options)) {
    return true
  }
  return false
}
async function every(fn, options = undefined) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws
  return !(await some.call(
    this,
    async (...args) => {
      return !(await fn(...args))
    },
    options
  ))
}
async function find(fn, options) {
  for await (const result of filter.call(this, fn, options)) {
    return result
  }
  return undefined
}
async function forEach(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  async function forEachFn(value, options) {
    await fn(value, options)
    return kEmpty
  }
  // eslint-disable-next-line no-unused-vars
  for await (const unused of map.call(this, forEachFn, options));
}
function filter(fn, options) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
  }
  async function filterFn(value, options) {
    if (await fn(value, options)) {
      return value
    }
    return kEmpty
  }
  return map.call(this, filterFn, options)
}

// Specific to provide better error to reduce since the argument is only
// missing if the stream has no items in it - but the code is still appropriate
class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
  constructor() {
    super('reduce')
    this.message = 'Reduce of an empty stream requires an initial value'
  }
}
async function reduce(reducer, initialValue, options) {
  var _options$signal2
  if (typeof reducer !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)
  }
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  let hasInitialValue = arguments.length > 1
  if (
    options !== null &&
    options !== undefined &&
    (_options$signal2 = options.signal) !== null &&
    _options$signal2 !== undefined &&
    _options$signal2.aborted
  ) {
    const err = new AbortError(undefined, {
      cause: options.signal.reason
    })
    this.once('error', () => {}) // The error is already propagated
    await finished(this.destroy(err))
    throw err
  }
  const ac = new AbortController()
  const signal = ac.signal
  if (options !== null && options !== undefined && options.signal) {
    const opts = {
      once: true,
      [kWeakHandler]: this,
      [kResistStopPropagation]: true
    }
    options.signal.addEventListener('abort', () => ac.abort(), opts)
  }
  let gotAnyItemFromStream = false
  try {
    for await (const value of this) {
      var _options$signal3
      gotAnyItemFromStream = true
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal3 = options.signal) !== null &&
        _options$signal3 !== undefined &&
        _options$signal3.aborted
      ) {
        throw new AbortError()
      }
      if (!hasInitialValue) {
        initialValue = value
        hasInitialValue = true
      } else {
        initialValue = await reducer(initialValue, value, {
          signal
        })
      }
    }
    if (!gotAnyItemFromStream && !hasInitialValue) {
      throw new ReduceAwareErrMissingArgs()
    }
  } finally {
    ac.abort()
  }
  return initialValue
}
async function toArray(options) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  const result = []
  for await (const val of this) {
    var _options$signal4
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal4 = options.signal) !== null &&
      _options$signal4 !== undefined &&
      _options$signal4.aborted
    ) {
      throw new AbortError(undefined, {
        cause: options.signal.reason
      })
    }
    ArrayPrototypePush(result, val)
  }
  return result
}
function flatMap(fn, options) {
  const values = map.call(this, fn, options)
  return async function* flatMap() {
    for await (const val of values) {
      yield* val
    }
  }.call(this)
}
function toIntegerOrInfinity(number) {
  // We coerce here to align with the spec
  // https://github.com/tc39/proposal-iterator-helpers/issues/169
  number = Number(number)
  if (NumberIsNaN(number)) {
    return 0
  }
  if (number < 0) {
    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)
  }
  return number
}
function drop(number, options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  number = toIntegerOrInfinity(number)
  return async function* drop() {
    var _options$signal5
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal5 = options.signal) !== null &&
      _options$signal5 !== undefined &&
      _options$signal5.aborted
    ) {
      throw new AbortError()
    }
    for await (const val of this) {
      var _options$signal6
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal6 = options.signal) !== null &&
        _options$signal6 !== undefined &&
        _options$signal6.aborted
      ) {
        throw new AbortError()
      }
      if (number-- <= 0) {
        yield val
      }
    }
  }.call(this)
}
function take(number, options = undefined) {
  if (options != null) {
    validateObject(options, 'options')
  }
  if ((options === null || options === undefined ? undefined : options.signal) != null) {
    validateAbortSignal(options.signal, 'options.signal')
  }
  number = toIntegerOrInfinity(number)
  return async function* take() {
    var _options$signal7
    if (
      options !== null &&
      options !== undefined &&
      (_options$signal7 = options.signal) !== null &&
      _options$signal7 !== undefined &&
      _options$signal7.aborted
    ) {
      throw new AbortError()
    }
    for await (const val of this) {
      var _options$signal8
      if (
        options !== null &&
        options !== undefined &&
        (_options$signal8 = options.signal) !== null &&
        _options$signal8 !== undefined &&
        _options$signal8.aborted
      ) {
        throw new AbortError()
      }
      if (number-- > 0) {
        yield val
      }

      // Don't get another item from iterator in case we reached the end
      if (number <= 0) {
        return
      }
    }
  }.call(this)
}
module.exports.streamReturningOperators = {
  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),
  drop,
  filter,
  flatMap,
  map,
  take,
  compose
}
module.exports.promiseReturningOperators = {
  every,
  forEach,
  reduce,
  toArray,
  some,
  find
}
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict'

const { ObjectSetPrototypeOf } = require('../../ours/primordials')
module.exports = PassThrough
const Transform = require('./transform')
ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)
ObjectSetPrototypeOf(PassThrough, Transform)
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options)
  Transform.call(this, options)
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk)
}
/* replacement start */

const process = require('process/')

/* replacement end */
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

;('use strict')
const { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = require('../../ours/primordials')
const eos = require('./end-of-stream')
const { once } = require('../../ours/util')
const destroyImpl = require('./destroy')
const Duplex = require('./duplex')
const {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_PREMATURE_CLOSE
  },
  AbortError
} = require('../../ours/errors')
const { validateFunction, validateAbortSignal } = require('../validators')
const {
  isIterable,
  isReadable,
  isReadableNodeStream,
  isNodeStream,
  isTransformStream,
  isWebStream,
  isReadableStream,
  isReadableFinished
} = require('./utils')
const AbortController = globalThis.AbortController || require('abort-controller').AbortController
let PassThrough
let Readable
let addAbortListener
function destroyer(stream, reading, writing) {
  let finished = false
  stream.on('close', () => {
    finished = true
  })
  const cleanup = eos(
    stream,
    {
      readable: reading,
      writable: writing
    },
    (err) => {
      finished = !err
    }
  )
  return {
    destroy: (err) => {
      if (finished) return
      finished = true
      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))
    },
    cleanup
  }
}
function popCallback(streams) {
  // Streams should never be an empty array. It should always contain at least
  // a single stream. Therefore optimize for the average case instead of
  // checking for length === 0 as well.
  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')
  return streams.pop()
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val
  } else if (isReadableNodeStream(val)) {
    // Legacy streams are not Iterable.
    return fromReadable(val)
  }
  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)
}
async function* fromReadable(val) {
  if (!Readable) {
    Readable = require('./readable')
  }
  yield* Readable.prototype[SymbolAsyncIterator].call(val)
}
async function pumpToNode(iterable, writable, finish, { end }) {
  let error
  let onresolve = null
  const resume = (err) => {
    if (err) {
      error = err
    }
    if (onresolve) {
      const callback = onresolve
      onresolve = null
      callback()
    }
  }
  const wait = () =>
    new Promise((resolve, reject) => {
      if (error) {
        reject(error)
      } else {
        onresolve = () => {
          if (error) {
            reject(error)
          } else {
            resolve()
          }
        }
      }
    })
  writable.on('drain', resume)
  const cleanup = eos(
    writable,
    {
      readable: false
    },
    resume
  )
  try {
    if (writable.writableNeedDrain) {
      await wait()
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait()
      }
    }
    if (end) {
      writable.end()
      await wait()
    }
    finish()
  } catch (err) {
    finish(error !== err ? aggregateTwoErrors(error, err) : err)
  } finally {
    cleanup()
    writable.off('drain', resume)
  }
}
async function pumpToWeb(readable, writable, finish, { end }) {
  if (isTransformStream(writable)) {
    writable = writable.writable
  }
  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure
  const writer = writable.getWriter()
  try {
    for await (const chunk of readable) {
      await writer.ready
      writer.write(chunk).catch(() => {})
    }
    await writer.ready
    if (end) {
      await writer.close()
    }
    finish()
  } catch (err) {
    try {
      await writer.abort(err)
      finish(err)
    } catch (err) {
      finish(err)
    }
  }
}
function pipeline(...streams) {
  return pipelineImpl(streams, once(popCallback(streams)))
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length === 1 && ArrayIsArray(streams[0])) {
    streams = streams[0]
  }
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams')
  }
  const ac = new AbortController()
  const signal = ac.signal
  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal

  // Need to cleanup event listeners if last stream is readable
  // https://github.com/nodejs/node/issues/35452
  const lastStreamCleanup = []
  validateAbortSignal(outerSignal, 'options.signal')
  function abort() {
    finishImpl(new AbortError())
  }
  addAbortListener = addAbortListener || require('../../ours/util').addAbortListener
  let disposable
  if (outerSignal) {
    disposable = addAbortListener(outerSignal, abort)
  }
  let error
  let value
  const destroys = []
  let finishCount = 0
  function finish(err) {
    finishImpl(err, --finishCount === 0)
  }
  function finishImpl(err, final) {
    var _disposable
    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
      error = err
    }
    if (!error && !final) {
      return
    }
    while (destroys.length) {
      destroys.shift()(error)
    }
    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()
    ac.abort()
    if (final) {
      if (!error) {
        lastStreamCleanup.forEach((fn) => fn())
      }
      process.nextTick(callback, error, value)
    }
  }
  let ret
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i]
    const reading = i < streams.length - 1
    const writing = i > 0
    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false
    const isLastStream = i === streams.length - 1
    if (isNodeStream(stream)) {
      if (end) {
        const { destroy, cleanup } = destroyer(stream, reading, writing)
        destroys.push(destroy)
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      }

      // Catch stream errors that occur after pipe/pump has completed.
      function onError(err) {
        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
          finish(err)
        }
      }
      stream.on('error', onError)
      if (isReadable(stream) && isLastStream) {
        lastStreamCleanup.push(() => {
          stream.removeListener('error', onError)
        })
      }
    }
    if (i === 0) {
      if (typeof stream === 'function') {
        ret = stream({
          signal
        })
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
        ret = stream
      } else {
        ret = Duplex.from(stream)
      }
    } else if (typeof stream === 'function') {
      if (isTransformStream(ret)) {
        var _ret
        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)
      } else {
        ret = makeAsyncIterable(ret)
      }
      ret = stream(ret, {
        signal
      })
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)
        }
      } else {
        var _ret2
        if (!PassThrough) {
          PassThrough = require('./passthrough')
        }

        // If the last argument to pipeline is not a stream
        // we must create a proxy stream so that pipeline(...)
        // always returns a stream which can be further
        // composed through `.pipe(stream)`.

        const pt = new PassThrough({
          objectMode: true
        })

        // Handle Promises/A+ spec, `then` could be a getter that throws on
        // second use.
        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then
        if (typeof then === 'function') {
          finishCount++
          then.call(
            ret,
            (val) => {
              value = val
              if (val != null) {
                pt.write(val)
              }
              if (end) {
                pt.end()
              }
              process.nextTick(finish)
            },
            (err) => {
              pt.destroy(err)
              process.nextTick(finish, err)
            }
          )
        } else if (isIterable(ret, true)) {
          finishCount++
          pumpToNode(ret, pt, finish, {
            end
          })
        } else if (isReadableStream(ret) || isTransformStream(ret)) {
          const toRead = ret.readable || ret
          finishCount++
          pumpToNode(toRead, pt, finish, {
            end
          })
        } else {
          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)
        }
        ret = pt
        const { destroy, cleanup } = destroyer(ret, false, true)
        destroys.push(destroy)
        if (isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        finishCount += 2
        const cleanup = pipe(ret, stream, finish, {
          end
        })
        if (isReadable(stream) && isLastStream) {
          lastStreamCleanup.push(cleanup)
        }
      } else if (isTransformStream(ret) || isReadableStream(ret)) {
        const toRead = ret.readable || ret
        finishCount++
        pumpToNode(toRead, stream, finish, {
          end
        })
      } else if (isIterable(ret)) {
        finishCount++
        pumpToNode(ret, stream, finish, {
          end
        })
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          'val',
          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
          ret
        )
      }
      ret = stream
    } else if (isWebStream(stream)) {
      if (isReadableNodeStream(ret)) {
        finishCount++
        pumpToWeb(makeAsyncIterable(ret), stream, finish, {
          end
        })
      } else if (isReadableStream(ret) || isIterable(ret)) {
        finishCount++
        pumpToWeb(ret, stream, finish, {
          end
        })
      } else if (isTransformStream(ret)) {
        finishCount++
        pumpToWeb(ret.readable, stream, finish, {
          end
        })
      } else {
        throw new ERR_INVALID_ARG_TYPE(
          'val',
          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
          ret
        )
      }
      ret = stream
    } else {
      ret = Duplex.from(stream)
    }
  }
  if (
    (signal !== null && signal !== undefined && signal.aborted) ||
    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
  ) {
    process.nextTick(abort)
  }
  return ret
}
function pipe(src, dst, finish, { end }) {
  let ended = false
  dst.on('close', () => {
    if (!ended) {
      // Finish if the destination closes before the source has completed.
      finish(new ERR_STREAM_PREMATURE_CLOSE())
    }
  })
  src.pipe(dst, {
    end: false
  }) // If end is true we already will have a listener to end dst.

  if (end) {
    // Compat. Before node v10.12.0 stdio used to throw an error so
    // pipe() did/does not end() stdio destinations.
    // Now they allow it but "secretly" don't close the underlying fd.

    function endFn() {
      ended = true
      dst.end()
    }
    if (isReadableFinished(src)) {
      // End the destination if the source has already ended.
      process.nextTick(endFn)
    } else {
      src.once('end', endFn)
    }
  } else {
    finish()
  }
  eos(
    src,
    {
      readable: true,
      writable: false
    },
    (err) => {
      const rState = src._readableState
      if (
        err &&
        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
        rState &&
        rState.ended &&
        !rState.errored &&
        !rState.errorEmitted
      ) {
        // Some readable streams will emit 'close' before 'end'. However, since
        // this is on the readable side 'end' should still be emitted if the
        // stream has been ended and no error emitted. This should be allowed in
        // favor of backwards compatibility. Since the stream is piped to a
        // destination this should not result in any observable difference.
        // We don't need to check if this is a writable premature close since
        // eos will only fail with premature close on the reading side for
        // duplex streams.
        src.once('end', finish).once('error', finish)
      } else {
        finish(err)
      }
    }
  )
  return eos(
    dst,
    {
      readable: false,
      writable: true
    },
    finish
  )
}
module.exports = {
  pipelineImpl,
  pipeline
}
/* replacement start */

const process = require('process/')

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

;('use strict')
const {
  ArrayPrototypeIndexOf,
  NumberIsInteger,
  NumberIsNaN,
  NumberParseInt,
  ObjectDefineProperties,
  ObjectKeys,
  ObjectSetPrototypeOf,
  Promise,
  SafeSet,
  SymbolAsyncDispose,
  SymbolAsyncIterator,
  Symbol
} = require('../../ours/primordials')
module.exports = Readable
Readable.ReadableState = ReadableState
const { EventEmitter: EE } = require('events')
const { Stream, prependListener } = require('./legacy')
const { Buffer } = require('buffer')
const { addAbortSignal } = require('./add-abort-signal')
const eos = require('./end-of-stream')
let debug = require('../../ours/util').debuglog('stream', (fn) => {
  debug = fn
})
const BufferList = require('./buffer_list')
const destroyImpl = require('./destroy')
const { getHighWaterMark, getDefaultHighWaterMark } = require('./state')
const {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_OUT_OF_RANGE,
    ERR_STREAM_PUSH_AFTER_EOF,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT
  },
  AbortError
} = require('../../ours/errors')
const { validateObject } = require('../validators')
const kPaused = Symbol('kPaused')
const { StringDecoder } = require('string_decoder')
const from = require('./from')
ObjectSetPrototypeOf(Readable.prototype, Stream.prototype)
ObjectSetPrototypeOf(Readable, Stream)
const nop = () => {}
const { errorOrDestroy } = destroyImpl
const kObjectMode = 1 << 0
const kEnded = 1 << 1
const kEndEmitted = 1 << 2
const kReading = 1 << 3
const kConstructed = 1 << 4
const kSync = 1 << 5
const kNeedReadable = 1 << 6
const kEmittedReadable = 1 << 7
const kReadableListening = 1 << 8
const kResumeScheduled = 1 << 9
const kErrorEmitted = 1 << 10
const kEmitClose = 1 << 11
const kAutoDestroy = 1 << 12
const kDestroyed = 1 << 13
const kClosed = 1 << 14
const kCloseEmitted = 1 << 15
const kMultiAwaitDrain = 1 << 16
const kReadingMore = 1 << 17
const kDataEmitted = 1 << 18

// TODO(benjamingr) it is likely slower to do it this way than with free functions
function makeBitMapDescriptor(bit) {
  return {
    enumerable: false,
    get() {
      return (this.state & bit) !== 0
    },
    set(value) {
      if (value) this.state |= bit
      else this.state &= ~bit
    }
  }
}
ObjectDefineProperties(ReadableState.prototype, {
  objectMode: makeBitMapDescriptor(kObjectMode),
  ended: makeBitMapDescriptor(kEnded),
  endEmitted: makeBitMapDescriptor(kEndEmitted),
  reading: makeBitMapDescriptor(kReading),
  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  constructed: makeBitMapDescriptor(kConstructed),
  // A flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  sync: makeBitMapDescriptor(kSync),
  // Whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  needReadable: makeBitMapDescriptor(kNeedReadable),
  emittedReadable: makeBitMapDescriptor(kEmittedReadable),
  readableListening: makeBitMapDescriptor(kReadableListening),
  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
  // True if the error was already emitted and should not be thrown again.
  errorEmitted: makeBitMapDescriptor(kErrorEmitted),
  emitClose: makeBitMapDescriptor(kEmitClose),
  autoDestroy: makeBitMapDescriptor(kAutoDestroy),
  // Has it been destroyed.
  destroyed: makeBitMapDescriptor(kDestroyed),
  // Indicates whether the stream has finished destroying.
  closed: makeBitMapDescriptor(kClosed),
  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  closeEmitted: makeBitMapDescriptor(kCloseEmitted),
  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
  // If true, a maybeReadMore has been scheduled.
  readingMore: makeBitMapDescriptor(kReadingMore),
  dataEmitted: makeBitMapDescriptor(kDataEmitted)
})
function ReadableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')

  // Bit map field to store ReadableState more effciently with 1 bit per field
  // instead of a V8 slot per field.
  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync
  // Object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away.
  if (options && options.objectMode) this.state |= kObjectMode
  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode

  // The point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = options
    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)
    : getDefaultHighWaterMark(false)

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift().
  this.buffer = new BufferList()
  this.length = 0
  this.pipes = []
  this.flowing = null
  this[kPaused] = null

  // Should close be emitted on destroy. Defaults to true.
  if (options && options.emitClose === false) this.state &= ~kEmitClose

  // Should .destroy() be called after 'end' (and potentially 'finish').
  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy

  // Indicates whether the stream has errored. When true no further
  // _read calls, 'data' or 'readable' events should occur. This is needed
  // since when autoDestroy is disabled we need a way to tell whether the
  // stream has failed.
  this.errored = null

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'

  // Ref the piped dest which we need a drain event on it
  // type: null | Writable | Set<Writable>.
  this.awaitDrainWriters = null
  this.decoder = null
  this.encoding = null
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding)
    this.encoding = options.encoding
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options)

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof require('./duplex')
  this._readableState = new ReadableState(options, this, isDuplex)
  if (options) {
    if (typeof options.read === 'function') this._read = options.read
    if (typeof options.destroy === 'function') this._destroy = options.destroy
    if (typeof options.construct === 'function') this._construct = options.construct
    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)
  }
  Stream.call(this, options)
  destroyImpl.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState)
    }
  })
}
Readable.prototype.destroy = destroyImpl.destroy
Readable.prototype._undestroy = destroyImpl.undestroy
Readable.prototype._destroy = function (err, cb) {
  cb(err)
}
Readable.prototype[EE.captureRejectionSymbol] = function (err) {
  this.destroy(err)
}
Readable.prototype[SymbolAsyncDispose] = function () {
  let error
  if (!this.destroyed) {
    error = this.readableEnded ? null : new AbortError()
    this.destroy(error)
  }
  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false)
}

// Unshift should *always* be something directly out of read().
Readable.prototype.unshift = function (chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true)
}
function readableAddChunk(stream, chunk, encoding, addToFront) {
  debug('readableAddChunk', chunk)
  const state = stream._readableState
  let err
  if ((state.state & kObjectMode) === 0) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          // When unshifting, if state.encoding is set, we have to save
          // the string in the BufferList with the state encoding.
          chunk = Buffer.from(chunk, encoding).toString(state.encoding)
        } else {
          chunk = Buffer.from(chunk, encoding)
          encoding = ''
        }
      }
    } else if (chunk instanceof Buffer) {
      encoding = ''
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk)
      encoding = ''
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
    }
  }
  if (err) {
    errorOrDestroy(stream, err)
  } else if (chunk === null) {
    state.state &= ~kReading
    onEofChunk(stream, state)
  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {
    if (addToFront) {
      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())
      else if (state.destroyed || state.errored) return false
      else addChunk(stream, state, chunk, true)
    } else if (state.ended) {
      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())
    } else if (state.destroyed || state.errored) {
      return false
    } else {
      state.state &= ~kReading
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk)
        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)
        else maybeReadMore(stream, state)
      } else {
        addChunk(stream, state, chunk, false)
      }
    }
  } else if (!addToFront) {
    state.state &= ~kReading
    maybeReadMore(stream, state)
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0)
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {
    // Use the guard to avoid creating `Set()` repeatedly
    // when we have multiple pipes.
    if ((state.state & kMultiAwaitDrain) !== 0) {
      state.awaitDrainWriters.clear()
    } else {
      state.awaitDrainWriters = null
    }
    state.dataEmitted = true
    stream.emit('data', chunk)
  } else {
    // Update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length
    if (addToFront) state.buffer.unshift(chunk)
    else state.buffer.push(chunk)
    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)
  }
  maybeReadMore(stream, state)
}
Readable.prototype.isPaused = function () {
  const state = this._readableState
  return state[kPaused] === true || state.flowing === false
}

// Backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  const decoder = new StringDecoder(enc)
  this._readableState.decoder = decoder
  // If setEncoding(null), decoder.encoding equals utf8.
  this._readableState.encoding = this._readableState.decoder.encoding
  const buffer = this._readableState.buffer
  // Iterate over current buffer to convert already stored Buffers:
  let content = ''
  for (const data of buffer) {
    content += decoder.write(data)
  }
  buffer.clear()
  if (content !== '') buffer.push(content)
  this._readableState.length = content.length
  return this
}

// Don't raise the hwm > 1GB.
const MAX_HWM = 0x40000000
function computeNewHighWaterMark(n) {
  if (n > MAX_HWM) {
    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts.
    n--
    n |= n >>> 1
    n |= n >>> 2
    n |= n >>> 4
    n |= n >>> 8
    n |= n >>> 16
    n++
  }
  return n
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || (state.length === 0 && state.ended)) return 0
  if ((state.state & kObjectMode) !== 0) return 1
  if (NumberIsNaN(n)) {
    // Only flow one buffer at a time.
    if (state.flowing && state.length) return state.buffer.first().length
    return state.length
  }
  if (n <= state.length) return n
  return state.ended ? state.length : 0
}

// You can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n)
  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
  // in this scenario, so we are doing it manually.
  if (n === undefined) {
    n = NaN
  } else if (!NumberIsInteger(n)) {
    n = NumberParseInt(n, 10)
  }
  const state = this._readableState
  const nOrig = n

  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)
  if (n !== 0) state.state &= ~kEmittedReadable

  // If we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (
    n === 0 &&
    state.needReadable &&
    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)
  ) {
    debug('read: emitReadable', state.length, state.ended)
    if (state.length === 0 && state.ended) endReadable(this)
    else emitReadable(this)
    return null
  }
  n = howMuchToRead(n, state)

  // If we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this)
    return null
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  let doRead = (state.state & kNeedReadable) !== 0
  debug('need readable', doRead)

  // If we currently have less than the highWaterMark, then also read some.
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true
    debug('length less than watermark', doRead)
  }

  // However, if we've ended, then there's no point, if we're already
  // reading, then it's unnecessary, if we're constructing we have to wait,
  // and if we're destroyed or errored, then it's not allowed,
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false
    debug('reading, ended or constructing', doRead)
  } else if (doRead) {
    debug('do read')
    state.state |= kReading | kSync
    // If the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.state |= kNeedReadable

    // Call internal read method
    try {
      this._read(state.highWaterMark)
    } catch (err) {
      errorOrDestroy(this, err)
    }
    state.state &= ~kSync

    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state)
  }
  let ret
  if (n > 0) ret = fromList(n, state)
  else ret = null
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark
    n = 0
  } else {
    state.length -= n
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear()
    } else {
      state.awaitDrainWriters = null
    }
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this)
  }
  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
    state.dataEmitted = true
    this.emit('data', ret)
  }
  return ret
}
function onEofChunk(stream, state) {
  debug('onEofChunk')
  if (state.ended) return
  if (state.decoder) {
    const chunk = state.decoder.end()
    if (chunk && chunk.length) {
      state.buffer.push(chunk)
      state.length += state.objectMode ? 1 : chunk.length
    }
  }
  state.ended = true
  if (state.sync) {
    // If we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call.
    emitReadable(stream)
  } else {
    // Emit 'readable' now to make sure it gets picked up.
    state.needReadable = false
    state.emittedReadable = true
    // We have to emit readable now that we are EOF. Modules
    // in the ecosystem (e.g. dicer) rely on this event being sync.
    emitReadable_(stream)
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  const state = stream._readableState
  debug('emitReadable', state.needReadable, state.emittedReadable)
  state.needReadable = false
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing)
    state.emittedReadable = true
    process.nextTick(emitReadable_, stream)
  }
}
function emitReadable_(stream) {
  const state = stream._readableState
  debug('emitReadable_', state.destroyed, state.length, state.ended)
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit('readable')
    state.emittedReadable = false
  }

  // The stream needs another readable event if:
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark
  flow(stream)
}

// At this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true
    process.nextTick(maybeReadMore_, stream, state)
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (
    !state.reading &&
    !state.ended &&
    (state.length < state.highWaterMark || (state.flowing && state.length === 0))
  ) {
    const len = state.length
    debug('maybeReadMore read 0')
    stream.read(0)
    if (len === state.length)
      // Didn't get any data, stop spinning.
      break
  }
  state.readingMore = false
}

// Abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')
}
Readable.prototype.pipe = function (dest, pipeOpts) {
  const src = this
  const state = this._readableState
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true
      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])
    }
  }
  state.pipes.push(dest)
  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr
  const endFn = doEnd ? onend : unpipe
  if (state.endEmitted) process.nextTick(endFn)
  else src.once('end', endFn)
  dest.on('unpipe', onunpipe)
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe')
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true
        cleanup()
      }
    }
  }
  function onend() {
    debug('onend')
    dest.end()
  }
  let ondrain
  let cleanedUp = false
  function cleanup() {
    debug('cleanup')
    // Cleanup event handlers once the pipe is broken.
    dest.removeListener('close', onclose)
    dest.removeListener('finish', onfinish)
    if (ondrain) {
      dest.removeListener('drain', ondrain)
    }
    dest.removeListener('error', onerror)
    dest.removeListener('unpipe', onunpipe)
    src.removeListener('end', onend)
    src.removeListener('end', unpipe)
    src.removeListener('data', ondata)
    cleanedUp = true

    // If the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()
  }
  function pause() {
    // If the user unpiped during `dest.write()`, it is possible
    // to get stuck in a permanently paused state if that write
    // also returned false.
    // => Check whether `dest` is still a piping destination.
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug('false write response, pause', 0)
        state.awaitDrainWriters = dest
        state.multiAwaitDrain = false
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug('false write response, pause', state.awaitDrainWriters.size)
        state.awaitDrainWriters.add(dest)
      }
      src.pause()
    }
    if (!ondrain) {
      // When the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      ondrain = pipeOnDrain(src, dest)
      dest.on('drain', ondrain)
    }
  }
  src.on('data', ondata)
  function ondata(chunk) {
    debug('ondata')
    const ret = dest.write(chunk)
    debug('dest.write', ret)
    if (ret === false) {
      pause()
    }
  }

  // If the dest has an error, then stop piping into it.
  // However, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er)
    unpipe()
    dest.removeListener('error', onerror)
    if (dest.listenerCount('error') === 0) {
      const s = dest._writableState || dest._readableState
      if (s && !s.errorEmitted) {
        // User incorrectly emitted 'error' directly on the stream.
        errorOrDestroy(dest, er)
      } else {
        dest.emit('error', er)
      }
    }
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror)

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish)
    unpipe()
  }
  dest.once('close', onclose)
  function onfinish() {
    debug('onfinish')
    dest.removeListener('close', onclose)
    unpipe()
  }
  dest.once('finish', onfinish)
  function unpipe() {
    debug('unpipe')
    src.unpipe(dest)
  }

  // Tell the dest that it's being piped to.
  dest.emit('pipe', src)

  // Start the flow if it hasn't been started already.

  if (dest.writableNeedDrain === true) {
    pause()
  } else if (!state.flowing) {
    debug('pipe resume')
    src.resume()
  }
  return dest
}
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState

    // `ondrain` will call directly,
    // `this` maybe not a reference to dest,
    // so we use the real dest here.
    if (state.awaitDrainWriters === dest) {
      debug('pipeOnDrain', 1)
      state.awaitDrainWriters = null
    } else if (state.multiAwaitDrain) {
      debug('pipeOnDrain', state.awaitDrainWriters.size)
      state.awaitDrainWriters.delete(dest)
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {
      src.resume()
    }
  }
}
Readable.prototype.unpipe = function (dest) {
  const state = this._readableState
  const unpipeInfo = {
    hasUnpiped: false
  }

  // If we're not piping anywhere, then do nothing.
  if (state.pipes.length === 0) return this
  if (!dest) {
    // remove all.
    const dests = state.pipes
    state.pipes = []
    this.pause()
    for (let i = 0; i < dests.length; i++)
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      })
    return this
  }

  // Try to find the right one.
  const index = ArrayPrototypeIndexOf(state.pipes, dest)
  if (index === -1) return this
  state.pipes.splice(index, 1)
  if (state.pipes.length === 0) this.pause()
  dest.emit('unpipe', this, unpipeInfo)
  return this
}

// Set up data events if they are asked for
// Ensure readable listeners eventually get something.
Readable.prototype.on = function (ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn)
  const state = this._readableState
  if (ev === 'data') {
    // Update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0

    // Try start flowing on next tick if stream isn't explicitly paused.
    if (state.flowing !== false) this.resume()
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true
      state.flowing = false
      state.emittedReadable = false
      debug('on readable', state.length, state.reading)
      if (state.length) {
        emitReadable(this)
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this)
      }
    }
  }
  return res
}
Readable.prototype.addListener = Readable.prototype.on
Readable.prototype.removeListener = function (ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn)
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this)
  }
  return res
}
Readable.prototype.off = Readable.prototype.removeListener
Readable.prototype.removeAllListeners = function (ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments)
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this)
  }
  return res
}
function updateReadableListening(self) {
  const state = self._readableState
  state.readableListening = self.listenerCount('readable') > 0
  if (state.resumeScheduled && state[kPaused] === false) {
    // Flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true

    // Crude way to check if we should resume.
  } else if (self.listenerCount('data') > 0) {
    self.resume()
  } else if (!state.readableListening) {
    state.flowing = null
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0')
  self.read(0)
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  const state = this._readableState
  if (!state.flowing) {
    debug('resume')
    // We flow only if there is no one listening
    // for readable, but we still have to call
    // resume().
    state.flowing = !state.readableListening
    resume(this, state)
  }
  state[kPaused] = false
  return this
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true
    process.nextTick(resume_, stream, state)
  }
}
function resume_(stream, state) {
  debug('resume', state.reading)
  if (!state.reading) {
    stream.read(0)
  }
  state.resumeScheduled = false
  stream.emit('resume')
  flow(stream)
  if (state.flowing && !state.reading) stream.read(0)
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing)
  if (this._readableState.flowing !== false) {
    debug('pause')
    this._readableState.flowing = false
    this.emit('pause')
  }
  this._readableState[kPaused] = true
  return this
}
function flow(stream) {
  const state = stream._readableState
  debug('flow', state.flowing)
  while (state.flowing && stream.read() !== null);
}

// Wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  let paused = false

  // TODO (ronag): Should this.destroy(err) emit
  // 'error' on the wrapped stream? Would require
  // a static factory method, e.g. Readable.wrap(stream).

  stream.on('data', (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true
      stream.pause()
    }
  })
  stream.on('end', () => {
    this.push(null)
  })
  stream.on('error', (err) => {
    errorOrDestroy(this, err)
  })
  stream.on('close', () => {
    this.destroy()
  })
  stream.on('destroy', () => {
    this.destroy()
  })
  this._read = () => {
    if (paused && stream.resume) {
      paused = false
      stream.resume()
    }
  }

  // Proxy all the other methods. Important when wrapping filters and duplexes.
  const streamKeys = ObjectKeys(stream)
  for (let j = 1; j < streamKeys.length; j++) {
    const i = streamKeys[j]
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = stream[i].bind(stream)
    }
  }
  return this
}
Readable.prototype[SymbolAsyncIterator] = function () {
  return streamToAsyncIterator(this)
}
Readable.prototype.iterator = function (options) {
  if (options !== undefined) {
    validateObject(options, 'options')
  }
  return streamToAsyncIterator(this, options)
}
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== 'function') {
    stream = Readable.wrap(stream, {
      objectMode: true
    })
  }
  const iter = createAsyncIterator(stream, options)
  iter.stream = stream
  return iter
}
async function* createAsyncIterator(stream, options) {
  let callback = nop
  function next(resolve) {
    if (this === stream) {
      callback()
      callback = nop
    } else {
      callback = resolve
    }
  }
  stream.on('readable', next)
  let error
  const cleanup = eos(
    stream,
    {
      writable: false
    },
    (err) => {
      error = err ? aggregateTwoErrors(error, err) : null
      callback()
      callback = nop
    }
  )
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read()
      if (chunk !== null) {
        yield chunk
      } else if (error) {
        throw error
      } else if (error === null) {
        return
      } else {
        await new Promise(next)
      }
    }
  } catch (err) {
    error = aggregateTwoErrors(error, err)
    throw error
  } finally {
    if (
      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&
      (error === undefined || stream._readableState.autoDestroy)
    ) {
      destroyImpl.destroyer(stream, null)
    } else {
      stream.off('readable', next)
      cleanup()
    }
  }
}

// Making it explicit these properties are not enumerable
// because otherwise some prototype manipulation in
// userland will fail.
ObjectDefineProperties(Readable.prototype, {
  readable: {
    __proto__: null,
    get() {
      const r = this._readableState
      // r.readable === false means that this is part of a Duplex stream
      // where the readable side was disabled upon construction.
      // Compat. The user might manually disable readable side through
      // deprecated setter.
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted
    },
    set(val) {
      // Backwards compat.
      if (this._readableState) {
        this._readableState.readable = !!val
      }
    }
  },
  readableDidRead: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.dataEmitted
    }
  },
  readableAborted: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return !!(
        this._readableState.readable !== false &&
        (this._readableState.destroyed || this._readableState.errored) &&
        !this._readableState.endEmitted
      )
    }
  },
  readableHighWaterMark: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.highWaterMark
    }
  },
  readableBuffer: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState && this._readableState.buffer
    }
  },
  readableFlowing: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return this._readableState.flowing
    },
    set: function (state) {
      if (this._readableState) {
        this._readableState.flowing = state
      }
    }
  },
  readableLength: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState.length
    }
  },
  readableObjectMode: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false
    }
  },
  readableEncoding: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null
    }
  },
  errored: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.errored : null
    }
  },
  closed: {
    __proto__: null,
    get() {
      return this._readableState ? this._readableState.closed : false
    }
  },
  destroyed: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.destroyed : false
    },
    set(value) {
      // We ignore the value if the stream
      // has not been initialized yet.
      if (!this._readableState) {
        return
      }

      // Backward compatibility, the user is explicitly
      // managing destroyed.
      this._readableState.destroyed = value
    }
  },
  readableEnded: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false
    }
  }
})
ObjectDefineProperties(ReadableState.prototype, {
  // Legacy getter for `pipesCount`.
  pipesCount: {
    __proto__: null,
    get() {
      return this.pipes.length
    }
  },
  // Legacy property for `paused`.
  paused: {
    __proto__: null,
    get() {
      return this[kPaused] !== false
    },
    set(value) {
      this[kPaused] = !!value
    }
  }
})

// Exposed for testing purposes only.
Readable._fromList = fromList

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered.
  if (state.length === 0) return null
  let ret
  if (state.objectMode) ret = state.buffer.shift()
  else if (!n || n >= state.length) {
    // Read it all, truncate the list.
    if (state.decoder) ret = state.buffer.join('')
    else if (state.buffer.length === 1) ret = state.buffer.first()
    else ret = state.buffer.concat(state.length)
    state.buffer.clear()
  } else {
    // read part of list.
    ret = state.buffer.consume(n, state.decoder)
  }
  return ret
}
function endReadable(stream) {
  const state = stream._readableState
  debug('endReadable', state.endEmitted)
  if (!state.endEmitted) {
    state.ended = true
    process.nextTick(endReadableNT, state, stream)
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length)

  // Check that we didn't get one last unshift.
  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true
    stream.emit('end')
    if (stream.writable && stream.allowHalfOpen === false) {
      process.nextTick(endWritableNT, stream)
    } else if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well.
      const wState = stream._writableState
      const autoDestroy =
        !wState ||
        (wState.autoDestroy &&
          // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false))
      if (autoDestroy) {
        stream.destroy()
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed
  if (writable) {
    stream.end()
  }
}
Readable.from = function (iterable, opts) {
  return from(Readable, iterable, opts)
}
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Readable.fromWeb = function (readableStream, options) {
  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)
}
Readable.toWeb = function (streamReadable, options) {
  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)
}
Readable.wrap = function (src, options) {
  var _ref, _src$readableObjectMo
  return new Readable({
    objectMode:
      (_ref =
        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined
          ? _src$readableObjectMo
          : src.objectMode) !== null && _ref !== undefined
        ? _ref
        : true,
    ...options,
    destroy(err, callback) {
      destroyImpl.destroyer(src, err)
      callback(err)
    }
  }).wrap(src)
}
'use strict'

const { MathFloor, NumberIsInteger } = require('../../ours/primordials')
const { validateInteger } = require('../validators')
const { ERR_INVALID_ARG_VALUE } = require('../../ours/errors').codes
let defaultHighWaterMarkBytes = 16 * 1024
let defaultHighWaterMarkObjectMode = 16
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes
}
function setDefaultHighWaterMark(objectMode, value) {
  validateInteger(value, 'value', 0)
  if (objectMode) {
    defaultHighWaterMarkObjectMode = value
  } else {
    defaultHighWaterMarkBytes = value
  }
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)
  if (hwm != null) {
    if (!NumberIsInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'
      throw new ERR_INVALID_ARG_VALUE(name, hwm)
    }
    return MathFloor(hwm)
  }

  // Default value
  return getDefaultHighWaterMark(state.objectMode)
}
module.exports = {
  getHighWaterMark,
  getDefaultHighWaterMark,
  setDefaultHighWaterMark
}
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict'

const { ObjectSetPrototypeOf, Symbol } = require('../../ours/primordials')
module.exports = Transform
const { ERR_METHOD_NOT_IMPLEMENTED } = require('../../ours/errors').codes
const Duplex = require('./duplex')
const { getHighWaterMark } = require('./state')
ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)
ObjectSetPrototypeOf(Transform, Duplex)
const kCallback = Symbol('kCallback')
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options)

  // TODO (ronag): This should preferably always be
  // applied but would be semver-major. Or even better;
  // make Transform a Readable with the Writable interface.
  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null
  if (readableHighWaterMark === 0) {
    // A Duplex will buffer both on the writable and readable side while
    // a Transform just wants to buffer hwm number of elements. To avoid
    // buffering twice we disable buffering on the writable side.
    options = {
      ...options,
      highWaterMark: null,
      readableHighWaterMark,
      // TODO (ronag): 0 is not optimal since we have
      // a "bug" where we check needDrain before calling _write and not after.
      // Refs: https://github.com/nodejs/node/pull/32887
      // Refs: https://github.com/nodejs/node/pull/35941
      writableHighWaterMark: options.writableHighWaterMark || 0
    }
  }
  Duplex.call(this, options)

  // We have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false
  this[kCallback] = null
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform
    if (typeof options.flush === 'function') this._flush = options.flush
  }

  // When the writable side finishes, then flush out anything remaining.
  // Backwards compat. Some Transform streams incorrectly implement _final
  // instead of or in addition to _flush. By using 'prefinish' instead of
  // implementing _final we continue supporting this unfortunate use case.
  this.on('prefinish', prefinish)
}
function final(cb) {
  if (typeof this._flush === 'function' && !this.destroyed) {
    this._flush((er, data) => {
      if (er) {
        if (cb) {
          cb(er)
        } else {
          this.destroy(er)
        }
        return
      }
      if (data != null) {
        this.push(data)
      }
      this.push(null)
      if (cb) {
        cb()
      }
    })
  } else {
    this.push(null)
    if (cb) {
      cb()
    }
  }
}
function prefinish() {
  if (this._final !== final) {
    final.call(this)
  }
}
Transform.prototype._final = final
Transform.prototype._transform = function (chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')
}
Transform.prototype._write = function (chunk, encoding, callback) {
  const rState = this._readableState
  const wState = this._writableState
  const length = rState.length
  this._transform(chunk, encoding, (err, val) => {
    if (err) {
      callback(err)
      return
    }
    if (val != null) {
      this.push(val)
    }
    if (
      wState.ended ||
      // Backwards compat.
      length === rState.length ||
      // Backwards compat.
      rState.length < rState.highWaterMark
    ) {
      callback()
    } else {
      this[kCallback] = callback
    }
  })
}
Transform.prototype._read = function () {
  if (this[kCallback]) {
    const callback = this[kCallback]
    this[kCallback] = null
    callback()
  }
}
'use strict'

const { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require('../../ours/primordials')

// We need to use SymbolFor to make these globally available
// for interopt with readable-stream, i.e. readable-stream
// and node core needs to be able to read/write private state
// from each other for proper interoperability.
const kIsDestroyed = SymbolFor('nodejs.stream.destroyed')
const kIsErrored = SymbolFor('nodejs.stream.errored')
const kIsReadable = SymbolFor('nodejs.stream.readable')
const kIsWritable = SymbolFor('nodejs.stream.writable')
const kIsDisturbed = SymbolFor('nodejs.stream.disturbed')
const kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')
const kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')
function isReadableNodeStream(obj, strict = false) {
  var _obj$_readableState
  return !!(
    (
      obj &&
      typeof obj.pipe === 'function' &&
      typeof obj.on === 'function' &&
      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&
      (!obj._writableState ||
        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined
          ? undefined
          : _obj$_readableState.readable) !== false) &&
      // Duplex
      (!obj._writableState || obj._readableState)
    ) // Writable has .pipe.
  )
}

function isWritableNodeStream(obj) {
  var _obj$_writableState
  return !!(
    (
      obj &&
      typeof obj.write === 'function' &&
      typeof obj.on === 'function' &&
      (!obj._readableState ||
        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined
          ? undefined
          : _obj$_writableState.writable) !== false)
    ) // Duplex
  )
}

function isDuplexNodeStream(obj) {
  return !!(
    obj &&
    typeof obj.pipe === 'function' &&
    obj._readableState &&
    typeof obj.on === 'function' &&
    typeof obj.write === 'function'
  )
}
function isNodeStream(obj) {
  return (
    obj &&
    (obj._readableState ||
      obj._writableState ||
      (typeof obj.write === 'function' && typeof obj.on === 'function') ||
      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))
  )
}
function isReadableStream(obj) {
  return !!(
    obj &&
    !isNodeStream(obj) &&
    typeof obj.pipeThrough === 'function' &&
    typeof obj.getReader === 'function' &&
    typeof obj.cancel === 'function'
  )
}
function isWritableStream(obj) {
  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')
}
function isTransformStream(obj) {
  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')
}
function isWebStream(obj) {
  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)
}
function isIterable(obj, isAsync) {
  if (obj == null) return false
  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'
  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'
  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'
}
function isDestroyed(stream) {
  if (!isNodeStream(stream)) return null
  const wState = stream._writableState
  const rState = stream._readableState
  const state = wState || rState
  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))
}

// Have been end():d.
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream)) return null
  if (stream.writableEnded === true) return true
  const wState = stream._writableState
  if (wState !== null && wState !== undefined && wState.errored) return false
  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null
  return wState.ended
}

// Have emitted 'finish'.
function isWritableFinished(stream, strict) {
  if (!isWritableNodeStream(stream)) return null
  if (stream.writableFinished === true) return true
  const wState = stream._writableState
  if (wState !== null && wState !== undefined && wState.errored) return false
  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null
  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))
}

// Have been push(null):d.
function isReadableEnded(stream) {
  if (!isReadableNodeStream(stream)) return null
  if (stream.readableEnded === true) return true
  const rState = stream._readableState
  if (!rState || rState.errored) return false
  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null
  return rState.ended
}

// Have emitted 'end'.
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream)) return null
  const rState = stream._readableState
  if (rState !== null && rState !== undefined && rState.errored) return false
  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null
  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))
}
function isReadable(stream) {
  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]
  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null
  if (isDestroyed(stream)) return false
  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)
}
function isWritable(stream) {
  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]
  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null
  if (isDestroyed(stream)) return false
  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)
}
function isFinished(stream, opts) {
  if (!isNodeStream(stream)) {
    return null
  }
  if (isDestroyed(stream)) {
    return true
  }
  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
    return false
  }
  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
    return false
  }
  return true
}
function isWritableErrored(stream) {
  var _stream$_writableStat, _stream$_writableStat2
  if (!isNodeStream(stream)) {
    return null
  }
  if (stream.writableErrored) {
    return stream.writableErrored
  }
  return (_stream$_writableStat =
    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined
      ? undefined
      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined
    ? _stream$_writableStat
    : null
}
function isReadableErrored(stream) {
  var _stream$_readableStat, _stream$_readableStat2
  if (!isNodeStream(stream)) {
    return null
  }
  if (stream.readableErrored) {
    return stream.readableErrored
  }
  return (_stream$_readableStat =
    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined
      ? undefined
      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined
    ? _stream$_readableStat
    : null
}
function isClosed(stream) {
  if (!isNodeStream(stream)) {
    return null
  }
  if (typeof stream.closed === 'boolean') {
    return stream.closed
  }
  const wState = stream._writableState
  const rState = stream._readableState
  if (
    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||
    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'
  ) {
    return (
      (wState === null || wState === undefined ? undefined : wState.closed) ||
      (rState === null || rState === undefined ? undefined : rState.closed)
    )
  }
  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {
    return stream._closed
  }
  return null
}
function isOutgoingMessage(stream) {
  return (
    typeof stream._closed === 'boolean' &&
    typeof stream._defaultKeepAlive === 'boolean' &&
    typeof stream._removedConnection === 'boolean' &&
    typeof stream._removedContLen === 'boolean'
  )
}
function isServerResponse(stream) {
  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)
}
function isServerRequest(stream) {
  var _stream$req
  return (
    typeof stream._consuming === 'boolean' &&
    typeof stream._dumped === 'boolean' &&
    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===
      undefined
  )
}
function willEmitClose(stream) {
  if (!isNodeStream(stream)) return null
  const wState = stream._writableState
  const rState = stream._readableState
  const state = wState || rState
  return (
    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)
  )
}
function isDisturbed(stream) {
  var _stream$kIsDisturbed
  return !!(
    stream &&
    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined
      ? _stream$kIsDisturbed
      : stream.readableDidRead || stream.readableAborted)
  )
}
function isErrored(stream) {
  var _ref,
    _ref2,
    _ref3,
    _ref4,
    _ref5,
    _stream$kIsErrored,
    _stream$_readableStat3,
    _stream$_writableStat3,
    _stream$_readableStat4,
    _stream$_writableStat4
  return !!(
    stream &&
    ((_ref =
      (_ref2 =
        (_ref3 =
          (_ref4 =
            (_ref5 =
              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined
                ? _stream$kIsErrored
                : stream.readableErrored) !== null && _ref5 !== undefined
              ? _ref5
              : stream.writableErrored) !== null && _ref4 !== undefined
            ? _ref4
            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined
            ? undefined
            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined
          ? _ref3
          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined
          ? undefined
          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined
        ? _ref2
        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined
        ? undefined
        : _stream$_readableStat4.errored) !== null && _ref !== undefined
      ? _ref
      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined
      ? undefined
      : _stream$_writableStat4.errored)
  )
}
module.exports = {
  isDestroyed,
  kIsDestroyed,
  isDisturbed,
  kIsDisturbed,
  isErrored,
  kIsErrored,
  isReadable,
  kIsReadable,
  kIsClosedPromise,
  kControllerErrorFunction,
  kIsWritable,
  isClosed,
  isDuplexNodeStream,
  isFinished,
  isIterable,
  isReadableNodeStream,
  isReadableStream,
  isReadableEnded,
  isReadableFinished,
  isReadableErrored,
  isNodeStream,
  isWebStream,
  isWritable,
  isWritableNodeStream,
  isWritableStream,
  isWritableEnded,
  isWritableFinished,
  isWritableErrored,
  isServerRequest,
  isServerResponse,
  willEmitClose,
  isTransformStream
}
/* replacement start */

const process = require('process/')

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

;('use strict')
const {
  ArrayPrototypeSlice,
  Error,
  FunctionPrototypeSymbolHasInstance,
  ObjectDefineProperty,
  ObjectDefineProperties,
  ObjectSetPrototypeOf,
  StringPrototypeToLowerCase,
  Symbol,
  SymbolHasInstance
} = require('../../ours/primordials')
module.exports = Writable
Writable.WritableState = WritableState
const { EventEmitter: EE } = require('events')
const Stream = require('./legacy').Stream
const { Buffer } = require('buffer')
const destroyImpl = require('./destroy')
const { addAbortSignal } = require('./add-abort-signal')
const { getHighWaterMark, getDefaultHighWaterMark } = require('./state')
const {
  ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED,
  ERR_STREAM_ALREADY_FINISHED,
  ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING
} = require('../../ours/errors').codes
const { errorOrDestroy } = destroyImpl
ObjectSetPrototypeOf(Writable.prototype, Stream.prototype)
ObjectSetPrototypeOf(Writable, Stream)
function nop() {}
const kOnFinished = Symbol('kOnFinished')
function WritableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')

  // Object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!(options && options.objectMode)
  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)

  // The point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write().
  this.highWaterMark = options
    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)
    : getDefaultHighWaterMark(false)

  // if _final has been called.
  this.finalCalled = false

  // drain event flag.
  this.needDrain = false
  // At the start of calling end()
  this.ending = false
  // When end() has been called, and returned.
  this.ended = false
  // When 'finish' is emitted.
  this.finished = false

  // Has it been destroyed
  this.destroyed = false

  // Should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  const noDecode = !!(options && options.decodeStrings === false)
  this.decodeStrings = !noDecode

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'

  // Not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0

  // A flag to see when we're in the middle of a write.
  this.writing = false

  // When true all writes will be buffered until .uncork() call.
  this.corked = 0

  // A flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true

  // A flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false

  // The callback that's passed to _write(chunk, cb).
  this.onwrite = onwrite.bind(undefined, stream)

  // The callback that the user supplies to write(chunk, encoding, cb).
  this.writecb = null

  // The amount that is being written when _write is called.
  this.writelen = 0

  // Storage for data passed to the afterWrite() callback in case of
  // synchronous _write() completion.
  this.afterWriteTickInfo = null
  resetBuffer(this)

  // Number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted.
  this.pendingcb = 0

  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  this.constructed = true

  // Emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams.
  this.prefinished = false

  // True if the error was already emitted and should not be thrown again.
  this.errorEmitted = false

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = !options || options.emitClose !== false

  // Should .destroy() be called after 'finish' (and potentially 'end').
  this.autoDestroy = !options || options.autoDestroy !== false

  // Indicates whether the stream has errored. When true all write() calls
  // should return false. This is needed since when autoDestroy
  // is disabled we need a way to tell whether the stream has failed.
  this.errored = null

  // Indicates whether the stream has finished destroying.
  this.closed = false

  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  this.closeEmitted = false
  this[kOnFinished] = []
}
function resetBuffer(state) {
  state.buffered = []
  state.bufferedIndex = 0
  state.allBuffers = true
  state.allNoop = true
}
WritableState.prototype.getBuffer = function getBuffer() {
  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)
}
ObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {
  __proto__: null,
  get() {
    return this.buffered.length - this.bufferedIndex
  }
})
function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof require('./duplex')
  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)
  this._writableState = new WritableState(options, this, isDuplex)
  if (options) {
    if (typeof options.write === 'function') this._write = options.write
    if (typeof options.writev === 'function') this._writev = options.writev
    if (typeof options.destroy === 'function') this._destroy = options.destroy
    if (typeof options.final === 'function') this._final = options.final
    if (typeof options.construct === 'function') this._construct = options.construct
    if (options.signal) addAbortSignal(options.signal, this)
  }
  Stream.call(this, options)
  destroyImpl.construct(this, () => {
    const state = this._writableState
    if (!state.writing) {
      clearBuffer(this, state)
    }
    finishMaybe(this, state)
  })
}
ObjectDefineProperty(Writable, SymbolHasInstance, {
  __proto__: null,
  value: function (object) {
    if (FunctionPrototypeSymbolHasInstance(this, object)) return true
    if (this !== Writable) return false
    return object && object._writableState instanceof WritableState
  }
})

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())
}
function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState
  if (typeof encoding === 'function') {
    cb = encoding
    encoding = state.defaultEncoding
  } else {
    if (!encoding) encoding = state.defaultEncoding
    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
    if (typeof cb !== 'function') cb = nop
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES()
  } else if (!state.objectMode) {
    if (typeof chunk === 'string') {
      if (state.decodeStrings !== false) {
        chunk = Buffer.from(chunk, encoding)
        encoding = 'buffer'
      }
    } else if (chunk instanceof Buffer) {
      encoding = 'buffer'
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk)
      encoding = 'buffer'
    } else {
      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
    }
  }
  let err
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END()
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('write')
  }
  if (err) {
    process.nextTick(cb, err)
    errorOrDestroy(stream, err, true)
    return err
  }
  state.pendingcb++
  return writeOrBuffer(stream, state, chunk, encoding, cb)
}
Writable.prototype.write = function (chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true
}
Writable.prototype.cork = function () {
  this._writableState.corked++
}
Writable.prototype.uncork = function () {
  const state = this._writableState
  if (state.corked) {
    state.corked--
    if (!state.writing) clearBuffer(this, state)
  }
}
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)
  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
  this._writableState.defaultEncoding = encoding
  return this
}

// If we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length
  state.length += len

  // stream._write resets state.length
  const ret = state.length < state.highWaterMark
  // We must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({
      chunk,
      encoding,
      callback
    })
    if (state.allBuffers && encoding !== 'buffer') {
      state.allBuffers = false
    }
    if (state.allNoop && callback !== nop) {
      state.allNoop = false
    }
  } else {
    state.writelen = len
    state.writecb = callback
    state.writing = true
    state.sync = true
    stream._write(chunk, encoding, state.onwrite)
    state.sync = false
  }

  // Return false if errored or destroyed in order to break
  // any synchronous while(stream.write(data)) loops.
  return ret && !state.errored && !state.destroyed
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len
  state.writecb = cb
  state.writing = true
  state.sync = true
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))
  else if (writev) stream._writev(chunk, state.onwrite)
  else stream._write(chunk, encoding, state.onwrite)
  state.sync = false
}
function onwriteError(stream, state, er, cb) {
  --state.pendingcb
  cb(er)
  // Ensure callbacks are invoked even when autoDestroy is
  // not enabled. Passing `er` here doesn't make sense since
  // it's related to one specific write, not to the buffered
  // writes.
  errorBuffer(state)
  // This can emit error, but error must always follow cb.
  errorOrDestroy(stream, er)
}
function onwrite(stream, er) {
  const state = stream._writableState
  const sync = state.sync
  const cb = state.writecb
  if (typeof cb !== 'function') {
    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())
    return
  }
  state.writing = false
  state.writecb = null
  state.length -= state.writelen
  state.writelen = 0
  if (er) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    er.stack // eslint-disable-line no-unused-expressions

    if (!state.errored) {
      state.errored = er
    }

    // In case of duplex streams we need to notify the readable side of the
    // error.
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er
    }
    if (sync) {
      process.nextTick(onwriteError, stream, state, er, cb)
    } else {
      onwriteError(stream, state, er, cb)
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state)
    }
    if (sync) {
      // It is a common case that the callback passed to .write() is always
      // the same. In that case, we do not schedule a new nextTick(), but
      // rather just increase a counter, to improve performance and avoid
      // memory allocations.
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++
      } else {
        state.afterWriteTickInfo = {
          count: 1,
          cb,
          stream,
          state
        }
        process.nextTick(afterWriteTick, state.afterWriteTickInfo)
      }
    } else {
      afterWrite(stream, state, 1, cb)
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null
  return afterWrite(stream, state, count, cb)
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain
  if (needDrain) {
    state.needDrain = false
    stream.emit('drain')
  }
  while (count-- > 0) {
    state.pendingcb--
    cb()
  }
  if (state.destroyed) {
    errorBuffer(state)
  }
  finishMaybe(stream, state)
}

// If there's something in the buffer waiting, then invoke callbacks.
function errorBuffer(state) {
  if (state.writing) {
    return
  }
  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
    var _state$errored
    const { chunk, callback } = state.buffered[n]
    const len = state.objectMode ? 1 : chunk.length
    state.length -= len
    callback(
      (_state$errored = state.errored) !== null && _state$errored !== undefined
        ? _state$errored
        : new ERR_STREAM_DESTROYED('write')
    )
  }
  const onfinishCallbacks = state[kOnFinished].splice(0)
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    var _state$errored2
    onfinishCallbacks[i](
      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined
        ? _state$errored2
        : new ERR_STREAM_DESTROYED('end')
    )
  }
  resetBuffer(state)
}

// If there's something in the buffer waiting, then process it.
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return
  }
  const { buffered, bufferedIndex, objectMode } = state
  const bufferedLength = buffered.length - bufferedIndex
  if (!bufferedLength) {
    return
  }
  let i = bufferedIndex
  state.bufferProcessing = true
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1
    const callback = state.allNoop
      ? nop
      : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err)
          }
        }
    // Make a copy of `buffered` if it's going to be used by `callback` above,
    // since `doWrite` will mutate the array.
    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)
    chunks.allBuffers = state.allBuffers
    doWrite(stream, state, true, state.length, chunks, '', callback)
    resetBuffer(state)
  } else {
    do {
      const { chunk, encoding, callback } = buffered[i]
      buffered[i++] = null
      const len = objectMode ? 1 : chunk.length
      doWrite(stream, state, false, len, chunk, encoding, callback)
    } while (i < buffered.length && !state.writing)
    if (i === buffered.length) {
      resetBuffer(state)
    } else if (i > 256) {
      buffered.splice(0, i)
      state.bufferedIndex = 0
    } else {
      state.bufferedIndex = i
    }
  }
  state.bufferProcessing = false
}
Writable.prototype._write = function (chunk, encoding, cb) {
  if (this._writev) {
    this._writev(
      [
        {
          chunk,
          encoding
        }
      ],
      cb
    )
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')
  }
}
Writable.prototype._writev = null
Writable.prototype.end = function (chunk, encoding, cb) {
  const state = this._writableState
  if (typeof chunk === 'function') {
    cb = chunk
    chunk = null
    encoding = null
  } else if (typeof encoding === 'function') {
    cb = encoding
    encoding = null
  }
  let err
  if (chunk !== null && chunk !== undefined) {
    const ret = _write(this, chunk, encoding)
    if (ret instanceof Error) {
      err = ret
    }
  }

  // .end() fully uncorks.
  if (state.corked) {
    state.corked = 1
    this.uncork()
  }
  if (err) {
    // Do nothing...
  } else if (!state.errored && !state.ending) {
    // This is forgiving in terms of unnecessary calls to end() and can hide
    // logic errors. However, usually such errors are harmless and causing a
    // hard error can be disproportionately destructive. It is not always
    // trivial for the user to determine whether end() needs to be called
    // or not.

    state.ending = true
    finishMaybe(this, state, true)
    state.ended = true
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED('end')
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('end')
  }
  if (typeof cb === 'function') {
    if (err || state.finished) {
      process.nextTick(cb, err)
    } else {
      state[kOnFinished].push(cb)
    }
  }
  return this
}
function needFinish(state) {
  return (
    state.ending &&
    !state.destroyed &&
    state.constructed &&
    state.length === 0 &&
    !state.errored &&
    state.buffered.length === 0 &&
    !state.finished &&
    !state.writing &&
    !state.errorEmitted &&
    !state.closeEmitted
  )
}
function callFinal(stream, state) {
  let called = false
  function onFinish(err) {
    if (called) {
      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())
      return
    }
    called = true
    state.pendingcb--
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0)
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err)
      }
      errorOrDestroy(stream, err, state.sync)
    } else if (needFinish(state)) {
      state.prefinished = true
      stream.emit('prefinish')
      // Backwards compat. Don't check state.sync here.
      // Some streams assume 'finish' will be emitted
      // asynchronously relative to _final callback.
      state.pendingcb++
      process.nextTick(finish, stream, state)
    }
  }
  state.sync = true
  state.pendingcb++
  try {
    stream._final(onFinish)
  } catch (err) {
    onFinish(err)
  }
  state.sync = false
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.finalCalled = true
      callFinal(stream, state)
    } else {
      state.prefinished = true
      stream.emit('prefinish')
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state)
    if (state.pendingcb === 0) {
      if (sync) {
        state.pendingcb++
        process.nextTick(
          (stream, state) => {
            if (needFinish(state)) {
              finish(stream, state)
            } else {
              state.pendingcb--
            }
          },
          stream,
          state
        )
      } else if (needFinish(state)) {
        state.pendingcb++
        finish(stream, state)
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--
  state.finished = true
  const onfinishCallbacks = state[kOnFinished].splice(0)
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]()
  }
  stream.emit('finish')
  if (state.autoDestroy) {
    // In case of duplex streams we need a way to detect
    // if the readable side is ready for autoDestroy as well.
    const rState = stream._readableState
    const autoDestroy =
      !rState ||
      (rState.autoDestroy &&
        // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false))
    if (autoDestroy) {
      stream.destroy()
    }
  }
}
ObjectDefineProperties(Writable.prototype, {
  closed: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.closed : false
    }
  },
  destroyed: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.destroyed : false
    },
    set(value) {
      // Backward compatibility, the user is explicitly managing destroyed.
      if (this._writableState) {
        this._writableState.destroyed = value
      }
    }
  },
  writable: {
    __proto__: null,
    get() {
      const w = this._writableState
      // w.writable === false means that this is part of a Duplex stream
      // where the writable side was disabled upon construction.
      // Compat. The user might manually disable writable side through
      // deprecated setter.
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended
    },
    set(val) {
      // Backwards compatible.
      if (this._writableState) {
        this._writableState.writable = !!val
      }
    }
  },
  writableFinished: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.finished : false
    }
  },
  writableObjectMode: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.objectMode : false
    }
  },
  writableBuffer: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.getBuffer()
    }
  },
  writableEnded: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.ending : false
    }
  },
  writableNeedDrain: {
    __proto__: null,
    get() {
      const wState = this._writableState
      if (!wState) return false
      return !wState.destroyed && !wState.ending && wState.needDrain
    }
  },
  writableHighWaterMark: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.highWaterMark
    }
  },
  writableCorked: {
    __proto__: null,
    get() {
      return this._writableState ? this._writableState.corked : 0
    }
  },
  writableLength: {
    __proto__: null,
    get() {
      return this._writableState && this._writableState.length
    }
  },
  errored: {
    __proto__: null,
    enumerable: false,
    get() {
      return this._writableState ? this._writableState.errored : null
    }
  },
  writableAborted: {
    __proto__: null,
    enumerable: false,
    get: function () {
      return !!(
        this._writableState.writable !== false &&
        (this._writableState.destroyed || this._writableState.errored) &&
        !this._writableState.finished
      )
    }
  }
})
const destroy = destroyImpl.destroy
Writable.prototype.destroy = function (err, cb) {
  const state = this._writableState

  // Invoke pending callbacks.
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    process.nextTick(errorBuffer, state)
  }
  destroy.call(this, err, cb)
  return this
}
Writable.prototype._undestroy = destroyImpl.undestroy
Writable.prototype._destroy = function (err, cb) {
  cb(err)
}
Writable.prototype[EE.captureRejectionSymbol] = function (err) {
  this.destroy(err)
}
let webStreamsAdapters

// Lazy to avoid circular references
function lazyWebStreams() {
  if (webStreamsAdapters === undefined) webStreamsAdapters = {}
  return webStreamsAdapters
}
Writable.fromWeb = function (writableStream, options) {
  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)
}
Writable.toWeb = function (streamWritable) {
  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)
}
/* eslint jsdoc/require-jsdoc: "error" */

'use strict'

const {
  ArrayIsArray,
  ArrayPrototypeIncludes,
  ArrayPrototypeJoin,
  ArrayPrototypeMap,
  NumberIsInteger,
  NumberIsNaN,
  NumberMAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER,
  NumberParseInt,
  ObjectPrototypeHasOwnProperty,
  RegExpPrototypeExec,
  String,
  StringPrototypeToUpperCase,
  StringPrototypeTrim
} = require('../ours/primordials')
const {
  hideStackFrames,
  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
} = require('../ours/errors')
const { normalizeEncoding } = require('../ours/util')
const { isAsyncFunction, isArrayBufferView } = require('../ours/util').types
const signals = {}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isInt32(value) {
  return value === (value | 0)
}

/**
 * @param {*} value
 * @returns {boolean}
 */
function isUint32(value) {
  return value === value >>> 0
}
const octalReg = /^[0-7]+$/
const modeDesc = 'must be a 32-bit unsigned integer or an octal string'

/**
 * Parse and validate values that will be converted into mode_t (the S_*
 * constants). Only valid numbers and octal strings are allowed. They could be
 * converted to 32-bit unsigned integers or non-negative signed integers in the
 * C++ land, but any value higher than 0o777 will result in platform-specific
 * behaviors.
 * @param {*} value Values to be validated
 * @param {string} name Name of the argument
 * @param {number} [def] If specified, will be returned for invalid values
 * @returns {number}
 */
function parseFileMode(value, name, def) {
  if (typeof value === 'undefined') {
    value = def
  }
  if (typeof value === 'string') {
    if (RegExpPrototypeExec(octalReg, value) === null) {
      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)
    }
    value = NumberParseInt(value, 8)
  }
  validateUint32(value, name)
  return value
}

/**
 * @callback validateInteger
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateInteger} */
const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
})

/**
 * @callback validateInt32
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateInt32} */
const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
  // The defaults for min and max correspond to the limits of 32-bit integers.
  if (typeof value !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
  if (!NumberIsInteger(value)) {
    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  }
  if (value < min || value > max) {
    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
  }
})

/**
 * @callback validateUint32
 * @param {*} value
 * @param {string} name
 * @param {number|boolean} [positive=false]
 * @returns {asserts value is number}
 */

/** @type {validateUint32} */
const validateUint32 = hideStackFrames((value, name, positive = false) => {
  if (typeof value !== 'number') {
    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
  if (!NumberIsInteger(value)) {
    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
  }
  const min = positive ? 1 : 0
  // 2 ** 32 === 4294967296
  const max = 4294967295
  if (value < min || value > max) {
    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
  }
})

/**
 * @callback validateString
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is string}
 */

/** @type {validateString} */
function validateString(value, name) {
  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)
}

/**
 * @callback validateNumber
 * @param {*} value
 * @param {string} name
 * @param {number} [min]
 * @param {number} [max]
 * @returns {asserts value is number}
 */

/** @type {validateNumber} */
function validateNumber(value, name, min = undefined, max) {
  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
  if (
    (min != null && value < min) ||
    (max != null && value > max) ||
    ((min != null || max != null) && NumberIsNaN(value))
  ) {
    throw new ERR_OUT_OF_RANGE(
      name,
      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
      value
    )
  }
}

/**
 * @callback validateOneOf
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} oneOf
 */

/** @type {validateOneOf} */
const validateOneOf = hideStackFrames((value, name, oneOf) => {
  if (!ArrayPrototypeIncludes(oneOf, value)) {
    const allowed = ArrayPrototypeJoin(
      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),
      ', '
    )
    const reason = 'must be one of: ' + allowed
    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
  }
})

/**
 * @callback validateBoolean
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is boolean}
 */

/** @type {validateBoolean} */
function validateBoolean(value, name) {
  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)
}

/**
 * @param {any} options
 * @param {string} key
 * @param {boolean} defaultValue
 * @returns {boolean}
 */
function getOwnPropertyValueOrDefault(options, key, defaultValue) {
  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]
}

/**
 * @callback validateObject
 * @param {*} value
 * @param {string} name
 * @param {{
 *   allowArray?: boolean,
 *   allowFunction?: boolean,
 *   nullable?: boolean
 * }} [options]
 */

/** @type {validateObject} */
const validateObject = hideStackFrames((value, name, options = null) => {
  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)
  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)
  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)
  if (
    (!nullable && value === null) ||
    (!allowArray && ArrayIsArray(value)) ||
    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))
  ) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)
  }
})

/**
 * @callback validateDictionary - We are using the Web IDL Standard definition
 *                                of "dictionary" here, which means any value
 *                                whose Type is either Undefined, Null, or
 *                                Object (which includes functions).
 * @param {*} value
 * @param {string} name
 * @see https://webidl.spec.whatwg.org/#es-dictionary
 * @see https://tc39.es/ecma262/#table-typeof-operator-results
 */

/** @type {validateDictionary} */
const validateDictionary = hideStackFrames((value, name) => {
  if (value != null && typeof value !== 'object' && typeof value !== 'function') {
    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)
  }
})

/**
 * @callback validateArray
 * @param {*} value
 * @param {string} name
 * @param {number} [minLength]
 * @returns {asserts value is any[]}
 */

/** @type {validateArray} */
const validateArray = hideStackFrames((value, name, minLength = 0) => {
  if (!ArrayIsArray(value)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`
    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
  }
})

/**
 * @callback validateStringArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is string[]}
 */

/** @type {validateStringArray} */
function validateStringArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    validateString(value[i], `${name}[${i}]`)
  }
}

/**
 * @callback validateBooleanArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is boolean[]}
 */

/** @type {validateBooleanArray} */
function validateBooleanArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    validateBoolean(value[i], `${name}[${i}]`)
  }
}

/**
 * @callback validateAbortSignalArray
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is AbortSignal[]}
 */

/** @type {validateAbortSignalArray} */
function validateAbortSignalArray(value, name) {
  validateArray(value, name)
  for (let i = 0; i < value.length; i++) {
    const signal = value[i]
    const indexedName = `${name}[${i}]`
    if (signal == null) {
      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)
    }
    validateAbortSignal(signal, indexedName)
  }
}

/**
 * @param {*} signal
 * @param {string} [name='signal']
 * @returns {asserts signal is keyof signals}
 */
function validateSignalName(signal, name = 'signal') {
  validateString(signal, name)
  if (signals[signal] === undefined) {
    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')
    }
    throw new ERR_UNKNOWN_SIGNAL(signal)
  }
}

/**
 * @callback validateBuffer
 * @param {*} buffer
 * @param {string} [name='buffer']
 * @returns {asserts buffer is ArrayBufferView}
 */

/** @type {validateBuffer} */
const validateBuffer = hideStackFrames((buffer, name = 'buffer') => {
  if (!isArrayBufferView(buffer)) {
    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)
  }
})

/**
 * @param {string} data
 * @param {string} encoding
 */
function validateEncoding(data, encoding) {
  const normalizedEncoding = normalizeEncoding(encoding)
  const length = data.length
  if (normalizedEncoding === 'hex' && length % 2 !== 0) {
    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)
  }
}

/**
 * Check that the port number is not NaN when coerced to a number,
 * is an integer and that it falls within the legal range of port numbers.
 * @param {*} port
 * @param {string} [name='Port']
 * @param {boolean} [allowZero=true]
 * @returns {number}
 */
function validatePort(port, name = 'Port', allowZero = true) {
  if (
    (typeof port !== 'number' && typeof port !== 'string') ||
    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||
    +port !== +port >>> 0 ||
    port > 0xffff ||
    (port === 0 && !allowZero)
  ) {
    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)
  }
  return port | 0
}

/**
 * @callback validateAbortSignal
 * @param {*} signal
 * @param {string} name
 */

/** @type {validateAbortSignal} */
const validateAbortSignal = hideStackFrames((signal, name) => {
  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
})

/**
 * @callback validateFunction
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is Function}
 */

/** @type {validateFunction} */
const validateFunction = hideStackFrames((value, name) => {
  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
})

/**
 * @callback validatePlainFunction
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is Function}
 */

/** @type {validatePlainFunction} */
const validatePlainFunction = hideStackFrames((value, name) => {
  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
})

/**
 * @callback validateUndefined
 * @param {*} value
 * @param {string} name
 * @returns {asserts value is undefined}
 */

/** @type {validateUndefined} */
const validateUndefined = hideStackFrames((value, name) => {
  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)
})

/**
 * @template T
 * @param {T} value
 * @param {string} name
 * @param {T[]} union
 */
function validateUnion(value, name, union) {
  if (!ArrayPrototypeIncludes(union, value)) {
    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)
  }
}

/*
  The rules for the Link header field are described here:
  https://www.rfc-editor.org/rfc/rfc8288.html#section-3

  This regex validates any string surrounded by angle brackets
  (not necessarily a valid URI reference) followed by zero or more
  link-params separated by semicolons.
*/
const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/

/**
 * @param {any} value
 * @param {string} name
 */
function validateLinkHeaderFormat(value, name) {
  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {
    throw new ERR_INVALID_ARG_VALUE(
      name,
      value,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    )
  }
}

/**
 * @param {any} hints
 * @return {string}
 */
function validateLinkHeaderValue(hints) {
  if (typeof hints === 'string') {
    validateLinkHeaderFormat(hints, 'hints')
    return hints
  } else if (ArrayIsArray(hints)) {
    const hintsLength = hints.length
    let result = ''
    if (hintsLength === 0) {
      return result
    }
    for (let i = 0; i < hintsLength; i++) {
      const link = hints[i]
      validateLinkHeaderFormat(link, 'hints')
      result += link
      if (i !== hintsLength - 1) {
        result += ', '
      }
    }
    return result
  }
  throw new ERR_INVALID_ARG_VALUE(
    'hints',
    hints,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  )
}
module.exports = {
  isInt32,
  isUint32,
  parseFileMode,
  validateArray,
  validateStringArray,
  validateBooleanArray,
  validateAbortSignalArray,
  validateBoolean,
  validateBuffer,
  validateDictionary,
  validateEncoding,
  validateFunction,
  validateInt32,
  validateInteger,
  validateNumber,
  validateObject,
  validateOneOf,
  validatePlainFunction,
  validatePort,
  validateSignalName,
  validateString,
  validateUint32,
  validateUndefined,
  validateUnion,
  validateAbortSignal,
  validateLinkHeaderValue
}
'use strict'

const CustomStream = require('../stream')
const promises = require('../stream/promises')
const originalDestroy = CustomStream.Readable.destroy
module.exports = CustomStream.Readable

// Explicit export naming is needed for ESM
module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer
module.exports._isUint8Array = CustomStream._isUint8Array
module.exports.isDisturbed = CustomStream.isDisturbed
module.exports.isErrored = CustomStream.isErrored
module.exports.isReadable = CustomStream.isReadable
module.exports.Readable = CustomStream.Readable
module.exports.Writable = CustomStream.Writable
module.exports.Duplex = CustomStream.Duplex
module.exports.Transform = CustomStream.Transform
module.exports.PassThrough = CustomStream.PassThrough
module.exports.addAbortSignal = CustomStream.addAbortSignal
module.exports.finished = CustomStream.finished
module.exports.destroy = CustomStream.destroy
module.exports.destroy = originalDestroy
module.exports.pipeline = CustomStream.pipeline
module.exports.compose = CustomStream.compose
Object.defineProperty(CustomStream, 'promises', {
  configurable: true,
  enumerable: true,
  get() {
    return promises
  }
})
module.exports.Stream = CustomStream.Stream

// Allow default importing
module.exports.default = module.exports
'use strict'

const { format, inspect, AggregateError: CustomAggregateError } = require('./util')

/*
  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at

  https://github.com/nodejs/node/blob/master/lib/internal/errors.js

  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)
  with the upstream file.
*/

const AggregateError = globalThis.AggregateError || CustomAggregateError
const kIsNodeError = Symbol('kIsNodeError')
const kTypes = [
  'string',
  'function',
  'number',
  'object',
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  'Function',
  'Object',
  'boolean',
  'bigint',
  'symbol'
]
const classRegExp = /^([A-Z][a-z0-9]*)+$/
const nodeInternalPrefix = '__node_internal_'
const codes = {}
function assert(value, message) {
  if (!value) {
    throw new codes.ERR_INTERNAL_ASSERTION(message)
  }
}

// Only use this for integers! Decimal numbers do not work with this function.
function addNumericalSeparator(val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}
function getMessage(key, msg, args) {
  if (typeof msg === 'function') {
    assert(
      msg.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
    )
    return msg(...args)
  }
  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length
  assert(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  )
  if (args.length === 0) {
    return msg
  }
  return format(msg, ...args)
}
function E(code, message, Base) {
  if (!Base) {
    Base = Error
  }
  class NodeError extends Base {
    constructor(...args) {
      super(getMessage(code, message, args))
    }
    toString() {
      return `${this.name} [${code}]: ${this.message}`
    }
  }
  Object.defineProperties(NodeError.prototype, {
    name: {
      value: Base.name,
      writable: true,
      enumerable: false,
      configurable: true
    },
    toString: {
      value() {
        return `${this.name} [${code}]: ${this.message}`
      },
      writable: true,
      enumerable: false,
      configurable: true
    }
  })
  NodeError.prototype.code = code
  NodeError.prototype[kIsNodeError] = true
  codes[code] = NodeError
}
function hideStackFrames(fn) {
  // We rename the functions that will be hidden to cut off the stacktrace
  // at the outermost one
  const hidden = nodeInternalPrefix + fn.name
  Object.defineProperty(fn, 'name', {
    value: hidden
  })
  return fn
}
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      // If `outerError` is already an `AggregateError`.
      outerError.errors.push(innerError)
      return outerError
    }
    const err = new AggregateError([outerError, innerError], outerError.message)
    err.code = outerError.code
    return err
  }
  return innerError || outerError
}
class AbortError extends Error {
  constructor(message = 'The operation was aborted', options = undefined) {
    if (options !== undefined && typeof options !== 'object') {
      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)
    }
    super(message, options)
    this.code = 'ABORT_ERR'
    this.name = 'AbortError'
  }
}
E('ERR_ASSERTION', '%s', Error)
E(
  'ERR_INVALID_ARG_TYPE',
  (name, expected, actual) => {
    assert(typeof name === 'string', "'name' must be a string")
    if (!Array.isArray(expected)) {
      expected = [expected]
    }
    let msg = 'The '
    if (name.endsWith(' argument')) {
      // For cases like 'first argument'
      msg += `${name} `
    } else {
      msg += `"${name}" ${name.includes('.') ? 'property' : 'argument'} `
    }
    msg += 'must be '
    const types = []
    const instances = []
    const other = []
    for (const value of expected) {
      assert(typeof value === 'string', 'All expected entries have to be of type string')
      if (kTypes.includes(value)) {
        types.push(value.toLowerCase())
      } else if (classRegExp.test(value)) {
        instances.push(value)
      } else {
        assert(value !== 'object', 'The value "object" should be written as "Object"')
        other.push(value)
      }
    }

    // Special handle `object` in case other instances are allowed to outline
    // the differences between each other.
    if (instances.length > 0) {
      const pos = types.indexOf('object')
      if (pos !== -1) {
        types.splice(types, pos, 1)
        instances.push('Object')
      }
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`
          break
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`
          break
        default: {
          const last = types.pop()
          msg += `one of type ${types.join(', ')}, or ${last}`
        }
      }
      if (instances.length > 0 || other.length > 0) {
        msg += ' or '
      }
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`
          break
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`
          break
        default: {
          const last = instances.pop()
          msg += `an instance of ${instances.join(', ')}, or ${last}`
        }
      }
      if (other.length > 0) {
        msg += ' or '
      }
    }
    switch (other.length) {
      case 0:
        break
      case 1:
        if (other[0].toLowerCase() !== other[0]) {
          msg += 'an '
        }
        msg += `${other[0]}`
        break
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`
        break
      default: {
        const last = other.pop()
        msg += `one of ${other.join(', ')}, or ${last}`
      }
    }
    if (actual == null) {
      msg += `. Received ${actual}`
    } else if (typeof actual === 'function' && actual.name) {
      msg += `. Received function ${actual.name}`
    } else if (typeof actual === 'object') {
      var _actual$constructor
      if (
        (_actual$constructor = actual.constructor) !== null &&
        _actual$constructor !== undefined &&
        _actual$constructor.name
      ) {
        msg += `. Received an instance of ${actual.constructor.name}`
      } else {
        const inspected = inspect(actual, {
          depth: -1
        })
        msg += `. Received ${inspected}`
      }
    } else {
      let inspected = inspect(actual, {
        colors: false
      })
      if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`
      }
      msg += `. Received type ${typeof actual} (${inspected})`
    }
    return msg
  },
  TypeError
)
E(
  'ERR_INVALID_ARG_VALUE',
  (name, value, reason = 'is invalid') => {
    let inspected = inspect(value)
    if (inspected.length > 128) {
      inspected = inspected.slice(0, 128) + '...'
    }
    const type = name.includes('.') ? 'property' : 'argument'
    return `The ${type} '${name}' ${reason}. Received ${inspected}`
  },
  TypeError
)
E(
  'ERR_INVALID_RETURN_VALUE',
  (input, name, value) => {
    var _value$constructor
    const type =
      value !== null &&
      value !== undefined &&
      (_value$constructor = value.constructor) !== null &&
      _value$constructor !== undefined &&
      _value$constructor.name
        ? `instance of ${value.constructor.name}`
        : `type ${typeof value}`
    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`
  },
  TypeError
)
E(
  'ERR_MISSING_ARGS',
  (...args) => {
    assert(args.length > 0, 'At least one arg needs to be specified')
    let msg
    const len = args.length
    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(' or ')
    switch (len) {
      case 1:
        msg += `The ${args[0]} argument`
        break
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`
        break
      default:
        {
          const last = args.pop()
          msg += `The ${args.join(', ')}, and ${last} arguments`
        }
        break
    }
    return `${msg} must be specified`
  },
  TypeError
)
E(
  'ERR_OUT_OF_RANGE',
  (str, range, input) => {
    assert(range, 'Missing "range" argument')
    let received
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    } else {
      received = inspect(input)
    }
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`
  },
  RangeError
)
E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)
E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)
E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)
E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)
E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)
E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)
E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)
E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)
E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)
E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)
E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)
module.exports = {
  AbortError,
  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
  hideStackFrames,
  codes
}
'use strict'

const Stream = require('stream')
if (Stream && process.env.READABLE_STREAM === 'disable') {
  const promises = Stream.promises

  // Explicit export naming is needed for ESM
  module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer
  module.exports._isUint8Array = Stream._isUint8Array
  module.exports.isDisturbed = Stream.isDisturbed
  module.exports.isErrored = Stream.isErrored
  module.exports.isReadable = Stream.isReadable
  module.exports.Readable = Stream.Readable
  module.exports.Writable = Stream.Writable
  module.exports.Duplex = Stream.Duplex
  module.exports.Transform = Stream.Transform
  module.exports.PassThrough = Stream.PassThrough
  module.exports.addAbortSignal = Stream.addAbortSignal
  module.exports.finished = Stream.finished
  module.exports.destroy = Stream.destroy
  module.exports.pipeline = Stream.pipeline
  module.exports.compose = Stream.compose
  Object.defineProperty(Stream, 'promises', {
    configurable: true,
    enumerable: true,
    get() {
      return promises
    }
  })
  module.exports.Stream = Stream.Stream
} else {
  const CustomStream = require('../stream')
  const promises = require('../stream/promises')
  const originalDestroy = CustomStream.Readable.destroy
  module.exports = CustomStream.Readable

  // Explicit export naming is needed for ESM
  module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer
  module.exports._isUint8Array = CustomStream._isUint8Array
  module.exports.isDisturbed = CustomStream.isDisturbed
  module.exports.isErrored = CustomStream.isErrored
  module.exports.isReadable = CustomStream.isReadable
  module.exports.Readable = CustomStream.Readable
  module.exports.Writable = CustomStream.Writable
  module.exports.Duplex = CustomStream.Duplex
  module.exports.Transform = CustomStream.Transform
  module.exports.PassThrough = CustomStream.PassThrough
  module.exports.addAbortSignal = CustomStream.addAbortSignal
  module.exports.finished = CustomStream.finished
  module.exports.destroy = CustomStream.destroy
  module.exports.destroy = originalDestroy
  module.exports.pipeline = CustomStream.pipeline
  module.exports.compose = CustomStream.compose
  Object.defineProperty(CustomStream, 'promises', {
    configurable: true,
    enumerable: true,
    get() {
      return promises
    }
  })
  module.exports.Stream = CustomStream.Stream
}

// Allow default importing
module.exports.default = module.exports
'use strict'

/*
  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at

  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js

  Don't try to replace with the original file and keep it up to date with the upstream file.
*/
module.exports = {
  ArrayIsArray(self) {
    return Array.isArray(self)
  },
  ArrayPrototypeIncludes(self, el) {
    return self.includes(el)
  },
  ArrayPrototypeIndexOf(self, el) {
    return self.indexOf(el)
  },
  ArrayPrototypeJoin(self, sep) {
    return self.join(sep)
  },
  ArrayPrototypeMap(self, fn) {
    return self.map(fn)
  },
  ArrayPrototypePop(self, el) {
    return self.pop(el)
  },
  ArrayPrototypePush(self, el) {
    return self.push(el)
  },
  ArrayPrototypeSlice(self, start, end) {
    return self.slice(start, end)
  },
  Error,
  FunctionPrototypeCall(fn, thisArgs, ...args) {
    return fn.call(thisArgs, ...args)
  },
  FunctionPrototypeSymbolHasInstance(self, instance) {
    return Function.prototype[Symbol.hasInstance].call(self, instance)
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(self, props) {
    return Object.defineProperties(self, props)
  },
  ObjectDefineProperty(self, name, prop) {
    return Object.defineProperty(self, name, prop)
  },
  ObjectGetOwnPropertyDescriptor(self, name) {
    return Object.getOwnPropertyDescriptor(self, name)
  },
  ObjectKeys(obj) {
    return Object.keys(obj)
  },
  ObjectSetPrototypeOf(target, proto) {
    return Object.setPrototypeOf(target, proto)
  },
  Promise,
  PromisePrototypeCatch(self, fn) {
    return self.catch(fn)
  },
  PromisePrototypeThen(self, thenFn, catchFn) {
    return self.then(thenFn, catchFn)
  },
  PromiseReject(err) {
    return Promise.reject(err)
  },
  PromiseResolve(val) {
    return Promise.resolve(val)
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(self, value) {
    return self.test(value)
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(self, start, end) {
    return self.slice(start, end)
  },
  StringPrototypeToLowerCase(self) {
    return self.toLowerCase()
  },
  StringPrototypeToUpperCase(self) {
    return self.toUpperCase()
  },
  StringPrototypeTrim(self) {
    return self.trim()
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),
  TypedArrayPrototypeSet(self, buf, len) {
    return self.set(buf, len)
  },
  Boolean: Boolean,
  Uint8Array
}
'use strict'

const bufferModule = require('buffer')
const { kResistStopPropagation, SymbolDispose } = require('./primordials')
const AbortSignal = globalThis.AbortSignal || require('abort-controller').AbortSignal
const AbortController = globalThis.AbortController || require('abort-controller').AbortController
const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor
const Blob = globalThis.Blob || bufferModule.Blob
/* eslint-disable indent */
const isBlob =
  typeof Blob !== 'undefined'
    ? function isBlob(b) {
        // eslint-disable-next-line indent
        return b instanceof Blob
      }
    : function isBlob(b) {
        return false
      }
/* eslint-enable indent */

const validateAbortSignal = (signal, name) => {
  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
  }
}
const validateFunction = (value, name) => {
  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
}

// This is a simplified version of AggregateError
class AggregateError extends Error {
  constructor(errors) {
    if (!Array.isArray(errors)) {
      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)
    }
    let message = ''
    for (let i = 0; i < errors.length; i++) {
      message += `    ${errors[i].stack}\n`
    }
    super(message)
    this.name = 'AggregateError'
    this.errors = errors
  }
}
module.exports = {
  AggregateError,
  kEmptyObject: Object.freeze({}),
  once(callback) {
    let called = false
    return function (...args) {
      if (called) {
        return
      }
      called = true
      callback.apply(this, args)
    }
  },
  createDeferredPromise: function () {
    let resolve
    let reject

    // eslint-disable-next-line promise/param-names
    const promise = new Promise((res, rej) => {
      resolve = res
      reject = rej
    })
    return {
      promise,
      resolve,
      reject
    }
  },
  promisify(fn) {
    return new Promise((resolve, reject) => {
      fn((err, ...args) => {
        if (err) {
          return reject(err)
        }
        return resolve(...args)
      })
    })
  },
  debuglog() {
    return function () {}
  },
  format(format, ...args) {
    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args
    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {
      const replacement = args.shift()
      if (type === 'f') {
        return replacement.toFixed(6)
      } else if (type === 'j') {
        return JSON.stringify(replacement)
      } else if (type === 's' && typeof replacement === 'object') {
        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''
        return `${ctor} {}`.trim()
      } else {
        return replacement.toString()
      }
    })
  },
  inspect(value) {
    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options
    switch (typeof value) {
      case 'string':
        if (value.includes("'")) {
          if (!value.includes('"')) {
            return `"${value}"`
          } else if (!value.includes('`') && !value.includes('${')) {
            return `\`${value}\``
          }
        }
        return `'${value}'`
      case 'number':
        if (isNaN(value)) {
          return 'NaN'
        } else if (Object.is(value, -0)) {
          return String(value)
        }
        return value
      case 'bigint':
        return `${String(value)}n`
      case 'boolean':
      case 'undefined':
        return String(value)
      case 'object':
        return '{}'
    }
  },
  types: {
    isAsyncFunction(fn) {
      return fn instanceof AsyncFunction
    },
    isArrayBufferView(arr) {
      return ArrayBuffer.isView(arr)
    }
  },
  isBlob,
  deprecate(fn, message) {
    return fn
  },
  addAbortListener:
    require('events').addAbortListener ||
    function addAbortListener(signal, listener) {
      if (signal === undefined) {
        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)
      }
      validateAbortSignal(signal, 'signal')
      validateFunction(listener, 'listener')
      let removeEventListener
      if (signal.aborted) {
        queueMicrotask(() => listener())
      } else {
        signal.addEventListener('abort', listener, {
          __proto__: null,
          once: true,
          [kResistStopPropagation]: true
        })
        removeEventListener = () => {
          signal.removeEventListener('abort', listener)
        }
      }
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener
          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined
            ? undefined
            : _removeEventListener()
        }
      }
    },
  AbortSignalAny:
    AbortSignal.any ||
    function AbortSignalAny(signals) {
      // Fast path if there is only one signal.
      if (signals.length === 1) {
        return signals[0]
      }
      const ac = new AbortController()
      const abort = () => ac.abort()
      signals.forEach((signal) => {
        validateAbortSignal(signal, 'signals')
        signal.addEventListener('abort', abort, {
          once: true
        })
      })
      ac.signal.addEventListener(
        'abort',
        () => {
          signals.forEach((signal) => signal.removeEventListener('abort', abort))
        },
        {
          once: true
        }
      )
      return ac.signal
    }
}
module.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')
/* replacement start */

const { Buffer } = require('buffer')

/* replacement end */
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

;('use strict')
const { ObjectDefineProperty, ObjectKeys, ReflectApply } = require('./ours/primordials')
const {
  promisify: { custom: customPromisify }
} = require('./ours/util')
const { streamReturningOperators, promiseReturningOperators } = require('./internal/streams/operators')
const {
  codes: { ERR_ILLEGAL_CONSTRUCTOR }
} = require('./ours/errors')
const compose = require('./internal/streams/compose')
const { setDefaultHighWaterMark, getDefaultHighWaterMark } = require('./internal/streams/state')
const { pipeline } = require('./internal/streams/pipeline')
const { destroyer } = require('./internal/streams/destroy')
const eos = require('./internal/streams/end-of-stream')
const internalBuffer = {}
const promises = require('./stream/promises')
const utils = require('./internal/streams/utils')
const Stream = (module.exports = require('./internal/streams/legacy').Stream)
Stream.isDestroyed = utils.isDestroyed
Stream.isDisturbed = utils.isDisturbed
Stream.isErrored = utils.isErrored
Stream.isReadable = utils.isReadable
Stream.isWritable = utils.isWritable
Stream.Readable = require('./internal/streams/readable')
for (const key of ObjectKeys(streamReturningOperators)) {
  const op = streamReturningOperators[key]
  function fn(...args) {
    if (new.target) {
      throw ERR_ILLEGAL_CONSTRUCTOR()
    }
    return Stream.Readable.from(ReflectApply(op, this, args))
  }
  ObjectDefineProperty(fn, 'name', {
    __proto__: null,
    value: op.name
  })
  ObjectDefineProperty(fn, 'length', {
    __proto__: null,
    value: op.length
  })
  ObjectDefineProperty(Stream.Readable.prototype, key, {
    __proto__: null,
    value: fn,
    enumerable: false,
    configurable: true,
    writable: true
  })
}
for (const key of ObjectKeys(promiseReturningOperators)) {
  const op = promiseReturningOperators[key]
  function fn(...args) {
    if (new.target) {
      throw ERR_ILLEGAL_CONSTRUCTOR()
    }
    return ReflectApply(op, this, args)
  }
  ObjectDefineProperty(fn, 'name', {
    __proto__: null,
    value: op.name
  })
  ObjectDefineProperty(fn, 'length', {
    __proto__: null,
    value: op.length
  })
  ObjectDefineProperty(Stream.Readable.prototype, key, {
    __proto__: null,
    value: fn,
    enumerable: false,
    configurable: true,
    writable: true
  })
}
Stream.Writable = require('./internal/streams/writable')
Stream.Duplex = require('./internal/streams/duplex')
Stream.Transform = require('./internal/streams/transform')
Stream.PassThrough = require('./internal/streams/passthrough')
Stream.pipeline = pipeline
const { addAbortSignal } = require('./internal/streams/add-abort-signal')
Stream.addAbortSignal = addAbortSignal
Stream.finished = eos
Stream.destroy = destroyer
Stream.compose = compose
Stream.setDefaultHighWaterMark = setDefaultHighWaterMark
Stream.getDefaultHighWaterMark = getDefaultHighWaterMark
ObjectDefineProperty(Stream, 'promises', {
  __proto__: null,
  configurable: true,
  enumerable: true,
  get() {
    return promises
  }
})
ObjectDefineProperty(pipeline, customPromisify, {
  __proto__: null,
  enumerable: true,
  get() {
    return promises.pipeline
  }
})
ObjectDefineProperty(eos, customPromisify, {
  __proto__: null,
  enumerable: true,
  get() {
    return promises.finished
  }
})

// Backwards-compat with node 0.4.x
Stream.Stream = Stream
Stream._isUint8Array = function isUint8Array(value) {
  return value instanceof Uint8Array
}
Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
}
'use strict'

const { ArrayPrototypePop, Promise } = require('../ours/primordials')
const { isIterable, isNodeStream, isWebStream } = require('../internal/streams/utils')
const { pipelineImpl: pl } = require('../internal/streams/pipeline')
const { finished } = require('../internal/streams/end-of-stream')
require('../../lib/stream.js')
function pipeline(...streams) {
  return new Promise((resolve, reject) => {
    let signal
    let end
    const lastArg = streams[streams.length - 1]
    if (
      lastArg &&
      typeof lastArg === 'object' &&
      !isNodeStream(lastArg) &&
      !isIterable(lastArg) &&
      !isWebStream(lastArg)
    ) {
      const options = ArrayPrototypePop(streams)
      signal = options.signal
      end = options.end
    }
    pl(
      streams,
      (err, value) => {
        if (err) {
          reject(err)
        } else {
          resolve(value)
        }
      },
      {
        signal,
        end
      }
    )
  })
}
module.exports = {
  finished,
  pipeline
}
Node.js is licensed for use as follows:

"""
Copyright Node.js contributors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

This license applies to parts of Node.js originating from the
https://github.com/joyent/node repository:

"""
Copyright Joyent, Inc. and other Node contributors. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""
{
  "name": "readable-stream",
  "version": "4.5.2",
  "description": "Node.js Streams, a user-land copy of the stream library from Node.js",
  "homepage": "https://github.com/nodejs/readable-stream",
  "license": "MIT",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://choosealicense.com/licenses/mit/"
    }
  ],
  "keywords": [
    "readable",
    "stream",
    "pipe"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/nodejs/readable-stream"
  },
  "bugs": {
    "url": "https://github.com/nodejs/readable-stream/issues"
  },
  "main": "lib/ours/index.js",
  "files": [
    "lib",
    "LICENSE",
    "README.md"
  ],
  "browser": {
    "util": "./lib/ours/util.js",
    "./lib/ours/index.js": "./lib/ours/browser.js"
  },
  "scripts": {
    "build": "node build/build.mjs",
    "postbuild": "prettier -w lib test",
    "test": "tap --rcfile=./tap.yml test/parallel/test-*.js test/ours/test-*.js",
    "test:prepare": "node test/browser/runner-prepare.mjs",
    "test:browsers": "node test/browser/runner-browser.mjs",
    "test:bundlers": "node test/browser/runner-node.mjs",
    "test:readable-stream-only": "node readable-stream-test/runner-prepare.mjs",
    "coverage": "c8 -c ./c8.json tap --rcfile=./tap.yml test/parallel/test-*.js test/ours/test-*.js",
    "format": "prettier -w src lib test",
    "lint": "eslint src"
  },
  "dependencies": {
    "abort-controller": "^3.0.0",
    "buffer": "^6.0.3",
    "events": "^3.3.0",
    "process": "^0.11.10",
    "string_decoder": "^1.3.0"
  },
  "devDependencies": {
    "@babel/core": "^7.17.10",
    "@babel/plugin-proposal-nullish-coalescing-operator": "^7.16.7",
    "@babel/plugin-proposal-optional-chaining": "^7.16.7",
    "@rollup/plugin-commonjs": "^22.0.0",
    "@rollup/plugin-inject": "^4.0.4",
    "@rollup/plugin-node-resolve": "^13.3.0",
    "@sinonjs/fake-timers": "^9.1.2",
    "browserify": "^17.0.0",
    "c8": "^7.11.2",
    "esbuild": "^0.19.9",
    "esbuild-plugin-alias": "^0.2.1",
    "eslint": "^8.15.0",
    "eslint-config-standard": "^17.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-n": "^15.2.0",
    "eslint-plugin-promise": "^6.0.0",
    "playwright": "^1.21.1",
    "prettier": "^2.6.2",
    "rollup": "^2.72.1",
    "rollup-plugin-polyfill-node": "^0.9.0",
    "tap": "^16.2.0",
    "tap-mocha-reporter": "^5.0.3",
    "tape": "^5.5.3",
    "tar": "^6.1.11",
    "undici": "^5.1.1",
    "webpack": "^5.72.1",
    "webpack-cli": "^4.9.2"
  },
  "engines": {
    "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
  }
}
# readable-stream

**_Node.js core streams for userland_**

[![npm status](https://img.shields.io/npm/v/readable-stream.svg)](https://npm.im/readable-stream)
[![node](https://img.shields.io/node/v/readable-stream.svg)](https://www.npmjs.org/package/readable-stream)
[![Node.js Build](https://github.com/nodejs/readable-stream/workflows/Node.js/badge.svg)](https://github.com/nodejs/readable-stream/actions?query=workflow%3ANode.js)
[![Browsers Build](https://github.com/nodejs/readable-stream/workflows/Browsers/badge.svg)](https://github.com/nodejs/readable-stream/actions?query=workflow%3ABrowsers)

```bash
npm install readable-stream
```

This package is a mirror of the streams implementations in Node.js 18.19.0.

Full documentation may be found on the [Node.js website](https://nodejs.org/dist/v18.19.0/docs/api/stream.html).

If you want to guarantee a stable streams base, regardless of what version of
Node you, or the users of your libraries are using, use **readable-stream** _only_ and avoid the _"stream"_ module in Node-core, for background see [this blogpost](http://r.va.gg/2014/06/why-i-dont-use-nodes-core-stream-module.html).

As of version 2.0.0 **readable-stream** uses semantic versioning.

## Version 4.x.x

v4.x.x of `readable-stream` is a cut from Node 18. This version supports Node 12, 14, 16 and 18, as well as evergreen browsers.
The breaking changes introduced by v4 are composed of the combined breaking changes in:
* [Node v12](https://nodejs.org/en/blog/release/v12.0.0/)
* [Node v13](https://nodejs.org/en/blog/release/v13.0.0/)
* [Node v14](https://nodejs.org/en/blog/release/v14.0.0/)
* [Node v15](https://nodejs.org/en/blog/release/v15.0.0/)
* [Node v16](https://nodejs.org/en/blog/release/v16.0.0/)
* [Node v17](https://nodejs.org/en/blog/release/v17.0.0/)
* [Node v18](https://nodejs.org/en/blog/release/v18.0.0/)

This also includes _many_ new features.

## Version 3.x.x

v3.x.x of `readable-stream` is a cut from Node 10. This version supports Node 6, 8, and 10, as well as evergreen browsers, IE 11 and latest Safari. The breaking changes introduced by v3 are composed by the combined breaking changes in [Node v9](https://nodejs.org/en/blog/release/v9.0.0/) and [Node v10](https://nodejs.org/en/blog/release/v10.0.0/), as follows:

1. Error codes: https://github.com/nodejs/node/pull/13310,
   https://github.com/nodejs/node/pull/13291,
   https://github.com/nodejs/node/pull/16589,
   https://github.com/nodejs/node/pull/15042,
   https://github.com/nodejs/node/pull/15665,
   https://github.com/nodejs/readable-stream/pull/344
2. 'readable' have precedence over flowing
   https://github.com/nodejs/node/pull/18994
3. make virtual methods errors consistent
   https://github.com/nodejs/node/pull/18813
4. updated streams error handling
   https://github.com/nodejs/node/pull/18438
5. writable.end should return this.
   https://github.com/nodejs/node/pull/18780
6. readable continues to read when push('')
   https://github.com/nodejs/node/pull/18211
7. add custom inspect to BufferList
   https://github.com/nodejs/node/pull/17907
8. always defer 'readable' with nextTick
   https://github.com/nodejs/node/pull/17979

## Version 2.x.x

v2.x.x of `readable-stream` is a cut of the stream module from Node 8 (there have been no semver-major changes from Node 4 to 8). This version supports all Node.js versions from 0.8, as well as evergreen browsers and IE 10 & 11.

# Usage

You can swap your `require('stream')` with `require('readable-stream')`
without any changes, if you are just using one of the main classes and
functions.

```js
const {
  Readable,
  Writable,
  Transform,
  Duplex,
  pipeline,
  finished
} = require('readable-stream')
```

Note that `require('stream')` will return `Stream`, while
`require('readable-stream')` will return `Readable`. We discourage using
whatever is exported directly, but rather use one of the properties as
shown in the example above.

## Usage In Browsers

You will need a bundler like [`browserify`](https://github.com/browserify/browserify#readme), [`webpack`](https://webpack.js.org/), [`parcel`](https://github.com/parcel-bundler/parcel#readme) or similar. Polyfills are no longer required since version 4.2.0.

# Streams Working Group

`readable-stream` is maintained by the Streams Working Group, which
oversees the development and maintenance of the Streams API within
Node.js. The responsibilities of the Streams Working Group include:

- Addressing stream issues on the Node.js issue tracker.
- Authoring and editing stream documentation within the Node.js project.
- Reviewing changes to stream subclasses within the Node.js project.
- Redirecting changes to streams from the Node.js project to this
  project.
- Assisting in the implementation of stream providers within Node.js.
- Recommending versions of `readable-stream` to be included in Node.js.
- Messaging about the future of streams to give the community advance
  notice of changes.

<a name="members"></a>

## Team Members

- **Mathias Buus** ([@mafintosh](https://github.com/mafintosh)) &lt;mathiasbuus@gmail.com&gt;
- **Matteo Collina** ([@mcollina](https://github.com/mcollina)) &lt;matteo.collina@gmail.com&gt;
  - Release GPG key: 3ABC01543F22DD2239285CDD818674489FBC127E
- **Robert Nagy** ([@ronag](https://github.com/ronag)) &lt;ronagy@icloud.com&gt;
- **Vincent Weevers** ([@vweevers](https://github.com/vweevers)) &lt;mail@vincentweevers.nl&gt;
{
  "name": "@postman/runtime.mqtt-client",
  "version": "0.3.1",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/main/packages/clients/mqtt-client#readme",
  "license": "UNLICENSED",
  "description": "A simple MQTT client for Node.js",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "mqtt": "5.1.4",
    "postman-ws": "7.4.5-postman.1",
    "@postman/runtime.mqtt-utils": "0.2.3"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^*"
  },
  "devDependencies": {
    "@types/lodash": "^4.14.194",
    "@types/node": "^20.0.0",
    "@types/ws": "8.5.13"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# mqtt-client

A simple MQTT client for Node.js
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": ["lodash", "node"],
	},
	"references": [{ "path": "../../utilities/mqtt-utils" }, { "path": "../../core/core" }]
}
import { SecureContextOptions } from '@postman/runtime.core';
import { AgentPublishOptions, AgentSubscribeOptions, Packet } from '@postman/runtime.mqtt-utils';
import type mqtt from 'mqtt';
import type { IDisconnectPacket } from 'mqtt-packet';
export interface MQTTAgent {
    connect(options: ConnectOptions): MQTTConnection | Promise<MQTTConnection>;
}
export interface MQTTConnection {
    publish(topic: string, message: string | Uint8Array, options: AgentPublishOptions): void;
    subscribe(topic: string, options: AgentSubscribeOptions): void | Promise<void>;
    unsubscribe(topic: string): void | Promise<void>;
    disconnect(force?: boolean, options?: Partial<mqtt.IDisconnectPacket>): void | Promise<void>;
    isConnected(): boolean;
    on(eventName: 'incoming-packet', listener: (response: Packet) => void): this;
    on(eventName: 'outgoing-packet', listener: (response: Packet) => void): this;
    on(eventName: 'mqtt-error', listener: (response: mqtt.ErrorWithReasonCode, errorPacket?: Partial<IDisconnectPacket>) => void): this;
    on(eventName: 'error', listener: (err: Error) => void): this;
    on(eventName: 'reconnect', listener: (count: number) => void): this;
    on(eventName: 'close', listener: () => void): this;
}
export interface ConnectOptions {
    url: string;
    tlsOptions: TLSOptions | null;
    mqttOptions: MQTTClientOptions | null;
}
export interface MQTTClientOptions {
    clientId?: string;
    version?: 4 | 5;
    cleanSession?: boolean;
    keepAlive?: number;
    autoReconnect?: boolean;
    properties?: {
        sessionExpiryInterval?: number;
        receiveMaximum?: number;
        maximumPacketSize?: number;
        userProperties?: Array<{
            key: string;
            value: string;
        }>;
    };
    lastWill?: {
        payload?: string;
        topic?: string;
        qos?: number;
        retain?: boolean;
        properties?: {
            payloadFormatIndicator?: boolean;
            messageExpiryInterval?: number;
            willDelayInterval?: number;
            responseTopic?: string;
            correlationData?: string;
            contentType?: string;
            userProperties?: Array<{
                key: string;
                value: string;
            }>;
        };
    };
    username?: string;
    password?: string;
}
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: SecureContextOptions;
}
export type { SecureContextOptions };
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=agent.js.map{"version":3,"file":"agent.js","sourceRoot":"","sources":["../src/agent.ts"],"names":[],"mappings":""}import { FromSchema } from 'json-schema-to-ts';
import { Event } from '@postman/runtime.core';
import { MqttMessage, SubscriptionMessage } from '@postman/runtime.mqtt-utils';
declare const definition: {
    connected: {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly packet: {
                    readonly type: "object";
                    readonly required: ["cmd", "sessionPresent"];
                    readonly properties: {
                        readonly cmd: {
                            readonly type: "string";
                            readonly enum: readonly ["connack"];
                        };
                        readonly messageId: {
                            readonly type: "number";
                        };
                        readonly dup: {
                            readonly type: "boolean";
                        };
                        readonly length: {
                            readonly type: "number";
                        };
                        readonly returnCode: {
                            readonly type: "number";
                        };
                        readonly reasonCode: {
                            readonly type: "number";
                        };
                        readonly sessionPresent: {
                            readonly type: "boolean";
                        };
                        readonly properties: {
                            readonly type: "object";
                            readonly properties: {
                                readonly sessionExpiryInterval: {
                                    readonly type: "number";
                                };
                                readonly receiveMaximum: {
                                    readonly type: "number";
                                };
                                readonly maximumQoS: {
                                    readonly type: "number";
                                };
                                readonly retainAvailable: {
                                    readonly type: "boolean";
                                };
                                readonly maximumPacketSize: {
                                    readonly type: "number";
                                };
                                readonly assignedClientIdentifier: {
                                    readonly type: "string";
                                };
                                readonly topicAliasMaximum: {
                                    readonly type: "number";
                                };
                                readonly reasonString: {
                                    readonly type: "string";
                                };
                                readonly userProperties: {
                                    readonly type: "object";
                                    readonly additionalProperties: {
                                        readonly oneOf: [{
                                            readonly type: "string";
                                        }, {
                                            readonly type: "array";
                                            readonly items: /*elided*/ any;
                                        }];
                                    };
                                };
                                readonly wildcardSubscriptionAvailable: {
                                    readonly type: "boolean";
                                };
                                readonly subscriptionIdentifiersAvailable: {
                                    readonly type: "boolean";
                                };
                                readonly sharedSubscriptionAvailable: {
                                    readonly type: "boolean";
                                };
                                readonly serverKeepAlive: {
                                    readonly type: "number";
                                };
                                readonly responseInformation: {
                                    readonly type: "string";
                                };
                                readonly serverReference: {
                                    readonly type: "string";
                                };
                                readonly authenticationMethod: {
                                    readonly type: "string";
                                };
                                readonly authenticationData: {
                                    readonly type: "string";
                                    readonly format: "binary";
                                };
                            };
                            readonly additionalProperties: false;
                        };
                    };
                    readonly additionalProperties: false;
                };
                readonly url: {
                    readonly type: "string";
                };
                readonly connected: {
                    readonly type: "boolean";
                };
            };
            readonly additionalProperties: false;
        };
    };
    error: {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly error: {
                    readonly type: "string";
                };
            };
            readonly additionalProperties: false;
        };
    };
    'outgoing-packet': {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly packet: {
                    readonly oneOf: [{
                        readonly type: "object";
                        readonly required: ["cmd"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly enum: readonly ["puback", "pubcomp", "pubrel", "pubrec"];
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly reasonCode: {
                                readonly type: "number";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "qos", "topic", "payload"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "publish";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly qos: {
                                readonly type: "number";
                                readonly enum: readonly [0, 1, 2];
                            };
                            readonly dup: {
                                readonly type: "boolean";
                            };
                            readonly retain: {
                                readonly type: "boolean";
                            };
                            readonly topic: {
                                readonly type: "string";
                            };
                            readonly payload: {
                                readonly type: "string";
                            };
                            readonly message: {
                                readonly oneOf: [{
                                    readonly type: "string";
                                }, {
                                    readonly type: "number";
                                }, {
                                    readonly type: "object";
                                    readonly additionalProperties: true;
                                }];
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "granted"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "suback";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                            readonly granted: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly properties: {
                                        readonly topic: {
                                            readonly type: "string";
                                        };
                                        readonly qos: {
                                            readonly type: "number";
                                        };
                                    };
                                    readonly required: ["topic"];
                                };
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "granted"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "unsuback";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                            readonly granted: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly properties: {
                                        readonly topic: {
                                            readonly type: "string";
                                        };
                                    };
                                    readonly required: ["topic"];
                                };
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "unsubscriptions"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "unsubscribe";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly dup: {
                                readonly type: "boolean";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                            readonly unsubscriptions: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "string";
                                };
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "subscriptions"];
                        readonly additionalProperties: false;
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "subscribe";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly subscriptions: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly additionalProperties: false;
                                    readonly required: ["topic", "qos"];
                                    readonly properties: {
                                        readonly topic: {
                                            readonly type: "string";
                                        };
                                        readonly qos: {
                                            readonly type: "number";
                                            readonly enum: readonly [0, 1, 2];
                                        };
                                        readonly nl: {
                                            readonly type: "boolean";
                                        };
                                        readonly rap: {
                                            readonly type: "boolean";
                                        };
                                        readonly rh: {
                                            readonly type: "number";
                                        };
                                    };
                                };
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                        };
                    }];
                };
            };
            readonly additionalProperties: false;
        };
    };
    'incoming-packet': {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly packet: {
                    readonly oneOf: [{
                        readonly type: "object";
                        readonly required: ["cmd"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly enum: readonly ["puback", "pubcomp", "pubrel", "pubrec"];
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly reasonCode: {
                                readonly type: "number";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                        };
                        readonly additionalProperties: false;
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "qos", "topic", "payload"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "publish";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly qos: {
                                readonly type: "number";
                                readonly enum: readonly [0, 1, 2];
                            };
                            readonly dup: {
                                readonly type: "boolean";
                            };
                            readonly retain: {
                                readonly type: "boolean";
                            };
                            readonly topic: {
                                readonly type: "string";
                            };
                            readonly payload: {
                                readonly type: "string";
                            };
                            readonly message: {
                                readonly oneOf: [{
                                    readonly type: "string";
                                }, {
                                    readonly type: "number";
                                }, {
                                    readonly type: "object";
                                    readonly additionalProperties: true;
                                }];
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                        };
                        readonly additionalProperties: false;
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "granted"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "suback";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                            readonly granted: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly properties: {
                                        readonly topic: {
                                            readonly type: "string";
                                        };
                                        readonly qos: {
                                            readonly type: "number";
                                        };
                                    };
                                    readonly required: ["topic"];
                                };
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "granted"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "unsuback";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                            readonly granted: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly properties: {
                                        readonly topic: {
                                            readonly type: "string";
                                        };
                                    };
                                    readonly required: ["topic"];
                                };
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "unsubscriptions"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "unsubscribe";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly dup: {
                                readonly type: "boolean";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                            readonly unsubscriptions: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "string";
                                };
                            };
                        };
                    }, {
                        readonly type: "object";
                        readonly required: ["cmd", "subscriptions"];
                        readonly properties: {
                            readonly cmd: {
                                readonly type: "string";
                                readonly const: "subscribe";
                            };
                            readonly messageId: {
                                readonly type: "number";
                            };
                            readonly length: {
                                readonly type: "number";
                            };
                            readonly subscriptions: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly required: ["topic", "qos"];
                                    readonly properties: {
                                        readonly topic: {
                                            readonly type: "string";
                                        };
                                        readonly qos: {
                                            readonly type: "number";
                                            readonly enum: readonly [0, 1, 2];
                                        };
                                        readonly nl: {
                                            readonly type: "boolean";
                                        };
                                        readonly rap: {
                                            readonly type: "boolean";
                                        };
                                        readonly rh: {
                                            readonly type: "number";
                                        };
                                    };
                                };
                            };
                            readonly properties: {
                                readonly type: "object";
                                readonly properties: {
                                    readonly reasonString: {
                                        readonly type: "string";
                                    };
                                    readonly userProperties: {
                                        readonly type: "object";
                                        readonly additionalProperties: {
                                            readonly oneOf: [/*elided*/ any, /*elided*/ any];
                                        };
                                    };
                                };
                            };
                        };
                    }];
                };
                readonly contentType: {
                    readonly type: "string";
                };
            };
            readonly additionalProperties: false;
        };
    };
    'transport:ws:connected': {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly handshakeRequest: {
                    readonly type: "object";
                    readonly required: ["method", "headers"];
                    readonly properties: {
                        readonly method: {
                            readonly type: "string";
                            readonly enum: readonly ["GET", "CONNECT"];
                        };
                        readonly headers: {
                            readonly type: "array";
                            readonly items: {
                                readonly type: "object";
                                readonly required: ["key", "value"];
                                readonly properties: {
                                    readonly key: {
                                        readonly type: "string";
                                    };
                                    readonly value: {
                                        readonly type: "string";
                                    };
                                };
                                readonly additionalProperties: false;
                            };
                        };
                    };
                    readonly additionalProperties: false;
                };
                readonly handshakeResponse: {
                    readonly type: "object";
                    readonly required: ["statusCode", "statusMessage", "headers"];
                    readonly properties: {
                        readonly statusCode: {
                            readonly type: "integer";
                            readonly minimum: 100;
                            readonly maximum: 599;
                        };
                        readonly statusMessage: {
                            readonly type: "string";
                        };
                        readonly headers: {
                            readonly type: "array";
                            readonly items: {
                                readonly type: "object";
                                readonly required: ["key", "value"];
                                readonly properties: {
                                    readonly key: {
                                        readonly type: "string";
                                    };
                                    readonly value: {
                                        readonly type: "string";
                                    };
                                };
                                readonly additionalProperties: false;
                            };
                        };
                    };
                    readonly additionalProperties: false;
                };
            };
            readonly additionalProperties: false;
        };
    };
    'transport:ws:disconnected': {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly code: {
                    readonly type: "integer";
                    readonly minimum: 1000;
                    readonly maximum: 4999;
                };
                readonly reason: {
                    readonly type: "string";
                };
            };
            readonly additionalProperties: false;
        };
    };
    'transport:ws:error': {
        schema: {
            readonly type: "object";
            readonly required: ["error"];
            readonly properties: {
                readonly error: {
                    readonly type: "object";
                    readonly required: ["message"];
                    readonly properties: {
                        readonly message: {
                            readonly type: "string";
                        };
                    };
                    readonly additionalProperties: false;
                };
                readonly handshakeRequest: {
                    readonly type: "object";
                    readonly required: ["method", "headers"];
                    readonly properties: {
                        readonly method: {
                            readonly type: "string";
                            readonly enum: readonly ["GET", "CONNECT"];
                        };
                        readonly headers: {
                            readonly type: "array";
                            readonly items: {
                                readonly type: "object";
                                readonly required: ["key", "value"];
                                readonly properties: {
                                    readonly key: {
                                        readonly type: "string";
                                    };
                                    readonly value: {
                                        readonly type: "string";
                                    };
                                };
                                readonly additionalProperties: false;
                            };
                        };
                    };
                    readonly additionalProperties: false;
                };
                readonly handshakeResponse: {
                    readonly type: "object";
                    readonly required: ["statusCode", "statusMessage", "headers"];
                    readonly properties: {
                        readonly statusCode: {
                            readonly type: "integer";
                            readonly minimum: 100;
                            readonly maximum: 599;
                        };
                        readonly statusMessage: {
                            readonly type: "string";
                        };
                        readonly headers: {
                            readonly type: "array";
                            readonly items: {
                                readonly type: "object";
                                readonly required: ["key", "value"];
                                readonly properties: {
                                    readonly key: {
                                        readonly type: "string";
                                    };
                                    readonly value: {
                                        readonly type: "string";
                                    };
                                };
                                readonly additionalProperties: false;
                            };
                        };
                    };
                    readonly additionalProperties: false;
                };
            };
            readonly additionalProperties: false;
        };
    };
    disconnected: {
        schema: {
            readonly type: "object";
            readonly properties: {
                readonly message: {
                    readonly type: "string";
                };
                readonly packet: {
                    readonly type: "object";
                    readonly properties: {
                        readonly cmd: {
                            readonly type: "string";
                            readonly enum: readonly ["disconnect"];
                        };
                        readonly reasonCode: {
                            readonly type: "number";
                        };
                        readonly properties: {
                            readonly type: "object";
                            readonly properties: {
                                readonly sessionExpiryInterval: {
                                    readonly type: "number";
                                };
                                readonly reasonString: {
                                    readonly type: "string";
                                };
                                readonly userProperties: {
                                    readonly type: "object";
                                    readonly additionalProperties: {
                                        readonly oneOf: [{
                                            readonly type: "string";
                                        }, {
                                            readonly type: "array";
                                            readonly items: /*elided*/ any;
                                        }];
                                    };
                                };
                                readonly serverReference: {
                                    readonly type: "string";
                                };
                            };
                            readonly additionalProperties: false;
                        };
                    };
                    readonly required: ["cmd"];
                    readonly additionalProperties: false;
                };
            };
            readonly additionalProperties: false;
        };
    };
    reconnecting: {
        schema: {
            readonly type: "object";
            readonly additionalProperties: false;
        };
    };
    aborted: {
        schema: {
            readonly type: "object";
            readonly additionalProperties: false;
        };
    };
};
export type Connected = Event<'connected', FromSchema<(typeof definition)['connected']['schema']>>;
export type Error = Event<'error', FromSchema<(typeof definition)['error']['schema']>>;
export type OutgoingPacket = Event<'outgoing-packet', FromSchema<(typeof definition)['outgoing-packet']['schema']>>;
export type IncomingPacket = Event<'incoming-packet', FromSchema<(typeof definition)['incoming-packet']['schema']>>;
export type TransportWSConnected = Event<'transport:ws:connected', FromSchema<(typeof definition)['transport:ws:connected']['schema']>>;
export type TransportWSError = Event<'transport:ws:error', FromSchema<(typeof definition)['transport:ws:error']['schema']>>;
export type TransportWSDisconnected = Event<'transport:ws:disconnected', FromSchema<(typeof definition)['transport:ws:disconnected']['schema']>>;
export type Disconnected = Event<'disconnected', FromSchema<(typeof definition)['disconnected']['schema']>>;
export type Reconnecting = Event<'reconnecting', FromSchema<(typeof definition)['reconnecting']['schema']>>;
export type Aborted = Event<'aborted', FromSchema<(typeof definition)['aborted']['schema']>>;
export type Publish = Event<'publish', MqttMessage>;
export type Subscribe = Event<'subscribe', SubscriptionMessage>;
export type Unsubscribe = Event<'unsubscribe', {
    topic: string;
}>;
export type Disconnect = Event<'disconnect'>;
export type Cancel = Event<'cancel'>;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
// TODO: this JSON schema is not currently being used at runtime
const definition = (0, json_schema_to_ts_1.asConst)({
    connected: {
        schema: {
            type: 'object',
            properties: {
                packet: {
                    type: 'object',
                    required: ['cmd', 'sessionPresent'],
                    properties: {
                        cmd: {
                            type: 'string',
                            enum: ['connack'],
                        },
                        messageId: {
                            type: 'number',
                        },
                        dup: {
                            type: 'boolean',
                        },
                        length: {
                            type: 'number',
                        },
                        returnCode: {
                            type: 'number',
                        },
                        reasonCode: {
                            type: 'number',
                        },
                        sessionPresent: {
                            type: 'boolean',
                        },
                        properties: {
                            type: 'object',
                            properties: {
                                sessionExpiryInterval: {
                                    type: 'number',
                                },
                                receiveMaximum: {
                                    type: 'number',
                                },
                                maximumQoS: {
                                    type: 'number',
                                },
                                retainAvailable: {
                                    type: 'boolean',
                                },
                                maximumPacketSize: {
                                    type: 'number',
                                },
                                assignedClientIdentifier: {
                                    type: 'string',
                                },
                                topicAliasMaximum: {
                                    type: 'number',
                                },
                                reasonString: {
                                    type: 'string',
                                },
                                userProperties: {
                                    type: 'object',
                                    additionalProperties: {
                                        oneOf: [
                                            {
                                                type: 'string',
                                            },
                                            {
                                                type: 'array',
                                                items: {
                                                    type: 'string',
                                                },
                                            },
                                        ],
                                    },
                                },
                                wildcardSubscriptionAvailable: {
                                    type: 'boolean',
                                },
                                subscriptionIdentifiersAvailable: {
                                    type: 'boolean',
                                },
                                sharedSubscriptionAvailable: {
                                    type: 'boolean',
                                },
                                serverKeepAlive: {
                                    type: 'number',
                                },
                                responseInformation: {
                                    type: 'string',
                                },
                                serverReference: {
                                    type: 'string',
                                },
                                authenticationMethod: {
                                    type: 'string',
                                },
                                authenticationData: {
                                    type: 'string',
                                    format: 'binary',
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    additionalProperties: false,
                },
                url: {
                    type: 'string',
                },
                connected: {
                    type: 'boolean',
                },
            },
            additionalProperties: false,
        },
    },
    error: {
        schema: {
            type: 'object',
            properties: {
                error: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'outgoing-packet': {
        schema: {
            type: 'object',
            properties: {
                packet: {
                    oneOf: [
                        {
                            type: 'object',
                            required: ['cmd'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    enum: ['puback', 'pubcomp', 'pubrel', 'pubrec'],
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                reasonCode: {
                                    type: 'number',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'qos', 'topic', 'payload'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'publish',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                qos: {
                                    type: 'number',
                                    enum: [0, 1, 2],
                                },
                                dup: {
                                    type: 'boolean',
                                },
                                retain: {
                                    type: 'boolean',
                                },
                                topic: {
                                    type: 'string',
                                },
                                payload: {
                                    type: 'string',
                                },
                                message: {
                                    oneOf: [
                                        {
                                            type: 'string',
                                        },
                                        {
                                            type: 'number',
                                        },
                                        {
                                            type: 'object',
                                            additionalProperties: true,
                                        },
                                    ],
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'granted'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'suback',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                                granted: {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        properties: {
                                            topic: {
                                                type: 'string',
                                            },
                                            qos: {
                                                type: 'number',
                                            },
                                        },
                                        required: ['topic'],
                                    },
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'granted'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'unsuback',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                                granted: {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        properties: {
                                            topic: {
                                                type: 'string',
                                            },
                                        },
                                        required: ['topic'],
                                    },
                                },
                                length: {
                                    type: 'number',
                                },
                                messageId: {
                                    type: 'number',
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'unsubscriptions'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'unsubscribe',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                dup: {
                                    type: 'boolean',
                                },
                                length: {
                                    type: 'number',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                                unsubscriptions: {
                                    type: 'array',
                                    items: {
                                        type: 'string',
                                    },
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'subscriptions'],
                            additionalProperties: false,
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'subscribe',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                subscriptions: {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        additionalProperties: false,
                                        required: ['topic', 'qos'],
                                        properties: {
                                            topic: {
                                                type: 'string',
                                            },
                                            qos: {
                                                type: 'number',
                                                enum: [0, 1, 2],
                                            },
                                            nl: {
                                                type: 'boolean',
                                            },
                                            rap: {
                                                type: 'boolean',
                                            },
                                            rh: {
                                                type: 'number',
                                            },
                                        },
                                    },
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    ],
                },
            },
            additionalProperties: false,
        },
    },
    'incoming-packet': {
        schema: {
            type: 'object',
            properties: {
                packet: {
                    oneOf: [
                        {
                            type: 'object',
                            required: ['cmd'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    enum: ['puback', 'pubcomp', 'pubrel', 'pubrec'],
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                reasonCode: {
                                    type: 'number',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                            },
                            additionalProperties: false,
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'qos', 'topic', 'payload'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'publish',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                qos: {
                                    type: 'number',
                                    enum: [0, 1, 2],
                                },
                                dup: {
                                    type: 'boolean',
                                },
                                retain: {
                                    type: 'boolean',
                                },
                                topic: {
                                    type: 'string',
                                },
                                payload: {
                                    type: 'string',
                                },
                                message: {
                                    oneOf: [
                                        {
                                            type: 'string',
                                        },
                                        {
                                            type: 'number',
                                        },
                                        {
                                            type: 'object',
                                            additionalProperties: true,
                                        },
                                    ],
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                            },
                            additionalProperties: false,
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'granted'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'suback',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                                granted: {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        properties: {
                                            topic: {
                                                type: 'string',
                                            },
                                            qos: {
                                                type: 'number',
                                            },
                                        },
                                        required: ['topic'],
                                    },
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'granted'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'unsuback',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                                granted: {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        properties: {
                                            topic: {
                                                type: 'string',
                                            },
                                        },
                                        required: ['topic'],
                                    },
                                },
                                length: {
                                    type: 'number',
                                },
                                messageId: {
                                    type: 'number',
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'unsubscriptions'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'unsubscribe',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                dup: {
                                    type: 'boolean',
                                },
                                length: {
                                    type: 'number',
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                                unsubscriptions: {
                                    type: 'array',
                                    items: {
                                        type: 'string',
                                    },
                                },
                            },
                        },
                        {
                            type: 'object',
                            required: ['cmd', 'subscriptions'],
                            properties: {
                                cmd: {
                                    type: 'string',
                                    const: 'subscribe',
                                },
                                messageId: {
                                    type: 'number',
                                },
                                length: {
                                    type: 'number',
                                },
                                subscriptions: {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        required: ['topic', 'qos'],
                                        properties: {
                                            topic: {
                                                type: 'string',
                                            },
                                            qos: {
                                                type: 'number',
                                                enum: [0, 1, 2],
                                            },
                                            nl: {
                                                type: 'boolean',
                                            },
                                            rap: {
                                                type: 'boolean',
                                            },
                                            rh: {
                                                type: 'number',
                                            },
                                        },
                                    },
                                },
                                properties: {
                                    type: 'object',
                                    properties: {
                                        reasonString: {
                                            type: 'string',
                                        },
                                        userProperties: {
                                            type: 'object',
                                            additionalProperties: {
                                                oneOf: [
                                                    {
                                                        type: 'string',
                                                    },
                                                    {
                                                        type: 'array',
                                                        items: {
                                                            type: 'string',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    ],
                },
                contentType: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'transport:ws:connected': {
        schema: {
            type: 'object',
            properties: {
                handshakeRequest: {
                    type: 'object',
                    required: ['method', 'headers'],
                    properties: {
                        method: {
                            type: 'string',
                            enum: ['GET', 'CONNECT'],
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
                handshakeResponse: {
                    type: 'object',
                    required: ['statusCode', 'statusMessage', 'headers'],
                    properties: {
                        statusCode: {
                            type: 'integer',
                            minimum: 100,
                            maximum: 599,
                        },
                        statusMessage: {
                            type: 'string',
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    'transport:ws:disconnected': {
        schema: {
            type: 'object',
            properties: {
                code: {
                    type: 'integer',
                    minimum: 1000,
                    maximum: 4999,
                },
                reason: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'transport:ws:error': {
        schema: {
            type: 'object',
            required: ['error'],
            properties: {
                error: {
                    type: 'object',
                    required: ['message'],
                    properties: {
                        message: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeRequest: {
                    type: 'object',
                    required: ['method', 'headers'],
                    properties: {
                        method: {
                            type: 'string',
                            enum: ['GET', 'CONNECT'],
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
                handshakeResponse: {
                    type: 'object',
                    required: ['statusCode', 'statusMessage', 'headers'],
                    properties: {
                        statusCode: {
                            type: 'integer',
                            minimum: 100,
                            maximum: 599,
                        },
                        statusMessage: {
                            type: 'string',
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    disconnected: {
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                },
                packet: {
                    type: 'object',
                    properties: {
                        cmd: {
                            type: 'string',
                            enum: ['disconnect'],
                        },
                        reasonCode: {
                            type: 'number',
                        },
                        properties: {
                            type: 'object',
                            properties: {
                                sessionExpiryInterval: {
                                    type: 'number',
                                },
                                reasonString: {
                                    type: 'string',
                                },
                                userProperties: {
                                    type: 'object',
                                    additionalProperties: {
                                        oneOf: [
                                            {
                                                type: 'string',
                                            },
                                            {
                                                type: 'array',
                                                items: {
                                                    type: 'string',
                                                },
                                            },
                                        ],
                                    },
                                },
                                serverReference: {
                                    type: 'string',
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                    required: ['cmd'],
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    reconnecting: {
        schema: {
            type: 'object',
            additionalProperties: false,
        },
    },
    aborted: {
        schema: {
            type: 'object',
            additionalProperties: false,
        },
    },
});
//# sourceMappingURL=events.js.map{"version":3,"file":"events.js","sourceRoot":"","sources":["../src/events.ts"],"names":[],"mappings":"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"}import MQTTRequest from '.';
declare const _default: (item: import("@postman/runtime.core").Item.OfType<MQTTRequest>, agent: import("./agent").MQTTAgent, context: import("@postman/runtime.core").RuntimeContext) => Promise<void>;
export default _default;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = require("@postman/runtime.core");
const runtime_mqtt_utils_1 = require("@postman/runtime.mqtt-utils");
const runtime_protocol_utils_1 = require("@postman/runtime.protocol-utils");
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
exports.default = (async function handler(item, agent, context) {
    const settings = item.payload.settings || {};
    const { variables } = context;
    const { isTLS } = (0, runtime_mqtt_utils_1.parseURL)(item.payload.url);
    const { auth } = item.extensions;
    const tlsOptions = isTLS ?
        {
            rejectUnauthorized: Boolean(settings.strictSSL),
            secureContext: typeof context.secureContext === 'function' ?
                await context.secureContext(item.payload.url)
                : context.secureContext,
        }
        : null;
    const mqttOptions = {
        clientId: item.payload.clientId,
        version: item.payload.version,
        cleanSession: settings.cleanSession,
        keepAlive: settings.keepAlive,
        autoReconnect: settings.autoReconnect,
        properties: item.payload.properties,
    };
    // TODO: Handle with the auth extension
    if (auth && auth.type === 'basic' && auth.basic) {
        auth.basic.forEach((auth) => {
            if (auth.key === 'username' &&
                auth.value !== undefined &&
                typeof auth.value === 'string') {
                mqttOptions.username = auth.value;
            }
            else if (auth.key === 'password' &&
                auth.value !== undefined &&
                typeof auth.value === 'string') {
                mqttOptions.password = auth.value;
            }
        });
    }
    if (item.payload.lastWill?.topic != undefined &&
        item.payload.lastWill?.topic != '') {
        mqttOptions.lastWill = item.payload.lastWill;
    }
    const connection = await agent.connect({
        url: item.payload.url,
        tlsOptions: tlsOptions,
        mqttOptions,
    });
    const events = runtime_core_1.EventChannel.specific(context.events);
    const subscriptionMap = new Map();
    const unsubscriptionMap = new Map();
    // MQTT 5 brokers can send a disconnect packet to the client.
    // This flag tracks if the disconnect event is handled by the client or needs to be emitted on close.
    let receivedDisconnect = false;
    const onSubscribe = (event) => {
        const { name: topic, subscribe, ...options } = event.payload;
        let resolvedTopic = topic;
        let resolvedOptions = options;
        if (variables) {
            resolvedTopic = variables.replaceIn(topic);
            resolvedOptions = variables.replaceIn(options);
        }
        connection.subscribe(resolvedTopic, resolvedOptions);
    };
    const onUnsubscribe = (event) => {
        const topic = event.payload.topic;
        let resolvedTopic = topic;
        if (variables) {
            resolvedTopic = variables.replaceIn(topic);
        }
        try {
            connection.unsubscribe(resolvedTopic);
        }
        catch (err) {
            let message = '';
            if (typeof err === 'string') {
                message = err;
            }
            else if (err instanceof Error) {
                message = err.message;
            }
            events.emit('error', {
                error: `Unable to unsubscribe from topic - ${topic}: ${message}`,
            });
        }
    };
    const onPublish = (event) => {
        const { topic, payload, type, ...options } = event.payload;
        let resolvedPayload = payload;
        let resolvedTopic = topic;
        let resolvedOptions = options;
        if (variables) {
            resolvedPayload = variables.replaceIn(payload);
            resolvedTopic = variables.replaceIn(topic);
            resolvedOptions = variables.replaceIn(options);
        }
        try {
            if (type === 'json') {
                const json = `${resolvedPayload}`;
                resolvedPayload = (0, strip_json_comments_1.default)(json);
            }
            else if (type === 'hex' || type === 'base64') {
                resolvedPayload = (0, runtime_protocol_utils_1.binaryStringToUint8Array)(resolvedPayload, type);
            }
            connection.publish(resolvedTopic, resolvedPayload, resolvedOptions);
        }
        catch (error) {
            events.emit('error', {
                error: `Unable to publish message. Error: ${error}`,
            });
        }
    };
    const onDisconnect = () => {
        connection.disconnect();
    };
    return new Promise((resolve) => {
        const onDone = () => {
            connection.disconnect();
            events
                .off('subscribe', onSubscribe)
                .off('unsubscribe', onUnsubscribe)
                .off('publish', onPublish)
                .off('disconnect', onDisconnect);
            resolve();
        };
        events
            .on('subscribe', onSubscribe)
            .on('unsubscribe', onUnsubscribe)
            .on('publish', onPublish)
            .on('disconnect', onDisconnect)
            .onCleanup(onDone);
        connection
            .on('incoming-packet', async (packet) => {
            if (packet.cmd === 'connack') {
                const { properties, ...remainingPacket } = packet;
                const processedPacket = remainingPacket;
                if (properties) {
                    const { authenticationData, ...remainingProperties } = properties;
                    processedPacket.properties = remainingProperties;
                    if (authenticationData) {
                        processedPacket.properties.authenticationData =
                            authenticationData.toString('utf8');
                    }
                }
                events.emit('connected', {
                    url: item.payload.url,
                    packet: processedPacket,
                    connected: true,
                });
                item.payload.topics?.forEach((topic) => {
                    if (!topic.subscribe) {
                        return;
                    }
                    connection.subscribe(topic.name, { qos: topic.qos ?? 0 });
                });
                return;
            }
            if (packet.cmd === 'publish') {
                // Check if the packet has a content type.
                const contentType = await (0, runtime_mqtt_utils_1.getContentType)(packet);
                const { payload, properties, ...remainingPacket } = packet;
                const newPacket = {
                    ...remainingPacket,
                    // @ts-ignore - this should be sent as a buffer but json schema doesn't support it?
                    payload,
                };
                if (packet.properties && newPacket) {
                    const { correlationData, ...properties } = packet.properties;
                    newPacket.properties = properties;
                    if (correlationData) {
                        newPacket.properties.correlationData =
                            correlationData.toString('utf8');
                    }
                }
                events.emit('incoming-packet', {
                    packet: newPacket,
                    contentType,
                });
                return;
            }
            if (packet.cmd === 'suback') {
                // Check if the packet has a subscription map entry.
                if (!packet.messageId || !subscriptionMap.has(packet.messageId)) {
                    return;
                }
                const subscriptions = subscriptionMap.get(packet.messageId);
                // Update the packet with the topic names
                if (!subscriptions)
                    return;
                const grantedTopic = subscriptions.map((subscription, index) => {
                    return { topic: subscription.topic, qos: packet.granted[index] };
                });
                events.emit('incoming-packet', {
                    packet: { ...packet, granted: grantedTopic },
                });
                subscriptionMap.delete(packet.messageId);
                return;
            }
            if (packet.cmd === 'unsuback') {
                if (!packet.messageId || !unsubscriptionMap.has(packet.messageId)) {
                    return;
                }
                const unsubscriptions = unsubscriptionMap.get(packet.messageId);
                if (!unsubscriptions)
                    return;
                let ungrantedTopic = [];
                unsubscriptions.forEach((topic) => {
                    // MQTT.js doesn't seem to return a reason code for unsuback packets that can be used to check for errors.
                    ungrantedTopic = [{ topic }];
                });
                events.emit('incoming-packet', {
                    packet: { ...packet, granted: ungrantedTopic },
                });
                unsubscriptionMap.delete(packet.messageId);
                return;
            }
            if (packet.cmd === 'puback' ||
                packet.cmd === 'pubrel' ||
                packet.cmd === 'pubrec' ||
                packet.cmd === 'pubcomp') {
                events.emit('incoming-packet', { packet });
                return;
            }
            if (packet.cmd === 'disconnect') {
                if (packet.reasonCode && packet.reasonCode <= 25) {
                    events.emit('disconnected', {
                        packet,
                        message: packet.reasonCode === 0 || packet.reasonCode === 4 ?
                            'Disconnected from broker.'
                            : undefined,
                    });
                    receivedDisconnect = true;
                }
                // There was an error on disconnect. This is handled by the error handler
                return;
            }
            if (packet.cmd === 'pingreq' ||
                packet.cmd === 'pingresp' ||
                packet.cmd === 'auth') {
                // Adding this non function block to indicate explicitly that these packets are not handled.
                return;
            }
        })
            .on('outgoing-packet', async (packet) => {
            if (packet.cmd === 'publish') {
                // Check if the packet has a content type.
                const contentType = await (0, runtime_mqtt_utils_1.getContentType)(packet);
                events.emit('outgoing-packet', {
                    packet: {
                        ...packet,
                        // @ts-ignore can be buffer but this isn't supported by jsonschema?
                        payload: packet.payload,
                    },
                    contentType,
                });
                return;
            }
            if (!packet.messageId)
                return;
            if (packet.cmd === 'subscribe') {
                subscriptionMap.set(packet.messageId, packet.subscriptions);
                events.emit('outgoing-packet', { packet });
                return;
            }
            if (packet.cmd === 'unsubscribe') {
                unsubscriptionMap.set(packet.messageId, packet.unsubscriptions);
                return;
            }
        })
            .on('mqtt-error', (err, errorPacket) => {
            events.emit('error', { error: `An error occurred: ${err.message}` });
            if (errorPacket) {
                connection.disconnect(true, errorPacket);
            }
        })
            .on('error', (err) => {
            events.emit('error', { error: `An error occurred: ${err.message}` });
            connection.disconnect();
        })
            .on('reconnect', () => {
            events.emit('reconnecting', { message: 'Reconnecting to the broker.' });
        })
            .on('close', () => {
            if (!receivedDisconnect) {
                events.emit('disconnected', {
                    message: 'Disconnected from broker.',
                });
            }
            onDone();
        });
    });
});
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":"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"}import { FromSchema } from 'json-schema-to-ts';
import { ItemType } from '@postman/runtime.core';
import Documentation from '@postman/runtime.documentation';
import Variables from '@postman/runtime.variables';
import Auth from '@postman/runtime.auth';
import { MQTTAgent } from './agent';
import * as MQTTEvents from './events';
export * as MQTTEvents from './events';
export * from './agent';
declare const definition: {
    name: "mqtt-request";
    summary: "MQTT Request";
    schema: {
        readonly type: "object";
        readonly required: ["url"];
        readonly properties: {
            readonly url: {
                readonly type: "string";
            };
            readonly clientId: {
                readonly type: "string";
            };
            readonly version: {
                readonly type: "integer";
                readonly enum: readonly [4, 5];
            };
            readonly topics: {
                readonly type: "array";
                readonly items: {
                    readonly type: "object";
                    readonly required: ["name"];
                    readonly properties: {
                        readonly name: {
                            readonly type: "string";
                        };
                        readonly qos: {
                            readonly type: "integer";
                            readonly enum: readonly [0, 1, 2];
                        };
                        readonly subscribe: {
                            readonly type: "boolean";
                        };
                        readonly description: {
                            readonly type: "string";
                        };
                    };
                };
            };
            readonly lastWill: {
                readonly type: "object";
                readonly properties: {
                    readonly payload: {
                        readonly type: "string";
                    };
                    readonly topic: {
                        readonly type: "string";
                    };
                    readonly qos: {
                        readonly type: "integer";
                        readonly enum: readonly [0, 1, 2];
                    };
                    readonly retain: {
                        readonly type: "boolean";
                    };
                    readonly type: {
                        readonly type: "string";
                        readonly enum: readonly ["text", "json", "hex", "base64"];
                    };
                    readonly properties: {
                        readonly type: "object";
                        readonly properties: {
                            readonly payloadFormatIndicator: {
                                readonly type: "boolean";
                            };
                            readonly messageExpiryInterval: {
                                readonly type: "integer";
                                readonly minimum: 0;
                            };
                            readonly willDelayInterval: {
                                readonly type: "integer";
                                readonly minimum: 0;
                            };
                            readonly responseTopic: {
                                readonly type: "string";
                            };
                            readonly correlationData: {
                                readonly type: "string";
                            };
                            readonly contentType: {
                                readonly type: "string";
                            };
                            readonly userProperties: {
                                readonly type: "array";
                                readonly items: {
                                    readonly type: "object";
                                    readonly required: ["key", "value"];
                                    readonly properties: {
                                        readonly key: {
                                            readonly type: "string";
                                        };
                                        readonly value: {
                                            readonly type: "string";
                                        };
                                    };
                                    readonly additionalProperties: false;
                                };
                            };
                        };
                        readonly additionalProperties: false;
                    };
                };
            };
            readonly properties: {
                readonly type: "object";
                readonly properties: {
                    readonly sessionExpiryInterval: {
                        readonly type: "integer";
                        readonly minimum: 0;
                    };
                    readonly receiveMaximum: {
                        readonly type: "integer";
                        readonly minimum: 0;
                    };
                    readonly maximumPacketSize: {
                        readonly type: "integer";
                        readonly minimum: 0;
                    };
                    readonly userProperties: {
                        readonly type: "array";
                        readonly items: {
                            readonly type: "object";
                            readonly required: ["key", "value"];
                            readonly properties: {
                                readonly key: {
                                    readonly type: "string";
                                };
                                readonly value: {
                                    readonly type: "string";
                                };
                                readonly description: {
                                    readonly type: "string";
                                };
                                readonly disabled: {
                                    readonly type: "boolean";
                                };
                            };
                            readonly additionalProperties: false;
                        };
                    };
                };
            };
            readonly settings: {
                readonly type: "object";
                readonly properties: {
                    readonly cleanSession: {
                        readonly type: "boolean";
                    };
                    readonly keepAlive: {
                        readonly type: "integer";
                        readonly minimum: 0;
                    };
                    readonly autoReconnect: {
                        readonly type: "boolean";
                    };
                    readonly connectionTimeout: {
                        readonly type: "integer";
                        readonly minimum: 0;
                    };
                    readonly strictSSL: {
                        readonly type: "boolean";
                    };
                };
                readonly additionalProperties: false;
            };
        };
        readonly additionalProperties: false;
    };
    constraints: [{
        constraint: "allow-child-types";
        allowed: ["mqtt-message"];
    }, {
        constraint: "allow-extensions";
        allowed: ["auth", "documentation", "variables"];
    }];
};
declare namespace MQTTRequest {
    type Payload = FromSchema<typeof definition.schema>;
    type Extensions = Documentation | Variables | Auth;
    type Config = MQTTAgent;
    type SentEvents = MQTTEvents.Publish | MQTTEvents.Subscribe | MQTTEvents.Unsubscribe | MQTTEvents.Disconnect | MQTTEvents.Cancel;
    type ReceivedEvents = MQTTEvents.Connected | MQTTEvents.OutgoingPacket | MQTTEvents.IncomingPacket | MQTTEvents.Error | MQTTEvents.TransportWSConnected | MQTTEvents.TransportWSDisconnected | MQTTEvents.TransportWSError | MQTTEvents.Disconnected | MQTTEvents.Reconnecting | MQTTEvents.Aborted;
    const use: () => ItemType.Specific<{
        properties?: {
            [x: string]: unknown;
            sessionExpiryInterval?: number | undefined;
            receiveMaximum?: number | undefined;
            maximumPacketSize?: number | undefined;
            userProperties?: {
                description?: string | undefined;
                disabled?: boolean | undefined;
                key: string;
                value: string;
            }[] | undefined;
        } | undefined;
        clientId?: string | undefined;
        version?: 4 | 5 | undefined;
        topics?: {
            [x: string]: unknown;
            description?: string | undefined;
            qos?: 0 | 2 | 1 | undefined;
            subscribe?: boolean | undefined;
            name: string;
        }[] | undefined;
        lastWill?: {
            [x: string]: unknown;
            properties?: {
                userProperties?: {
                    key: string;
                    value: string;
                }[] | undefined;
                contentType?: string | undefined;
                payloadFormatIndicator?: boolean | undefined;
                messageExpiryInterval?: number | undefined;
                willDelayInterval?: number | undefined;
                responseTopic?: string | undefined;
                correlationData?: string | undefined;
            } | undefined;
            type?: "text" | "json" | "hex" | "base64" | undefined;
            qos?: 0 | 2 | 1 | undefined;
            topic?: string | undefined;
            payload?: string | undefined;
            retain?: boolean | undefined;
        } | undefined;
        settings?: {
            cleanSession?: boolean | undefined;
            keepAlive?: number | undefined;
            autoReconnect?: boolean | undefined;
            connectionTimeout?: number | undefined;
            strictSSL?: boolean | undefined;
        } | undefined;
        url: string;
    }, Extensions, MQTTAgent, SentEvents, ReceivedEvents>;
}
type MQTTRequest = ItemType.Specific<MQTTRequest.Payload, MQTTRequest.Extensions, MQTTRequest.Config, MQTTRequest.SentEvents, MQTTRequest.ReceivedEvents>;
export default MQTTRequest;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MQTTEvents = void 0;
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const runtime_documentation_1 = __importDefault(require("@postman/runtime.documentation"));
const runtime_variables_1 = __importDefault(require("@postman/runtime.variables"));
const handler_1 = __importDefault(require("./handler"));
exports.MQTTEvents = __importStar(require("./events"));
__exportStar(require("./agent"), exports);
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'mqtt-request',
    summary: 'MQTT Request',
    schema: {
        type: 'object',
        required: ['url'],
        properties: {
            url: {
                type: 'string',
            },
            clientId: {
                type: 'string',
            },
            version: {
                type: 'integer',
                enum: [4, 5],
            },
            topics: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['name'],
                    properties: {
                        name: {
                            type: 'string',
                        },
                        qos: {
                            type: 'integer',
                            enum: [0, 1, 2],
                        },
                        subscribe: {
                            type: 'boolean',
                        },
                        description: {
                            type: 'string',
                        },
                    },
                },
            },
            lastWill: {
                type: 'object',
                properties: {
                    payload: {
                        type: 'string',
                    },
                    topic: {
                        type: 'string',
                    },
                    qos: {
                        type: 'integer',
                        enum: [0, 1, 2],
                    },
                    retain: {
                        type: 'boolean',
                    },
                    type: {
                        type: 'string',
                        enum: ['text', 'json', 'hex', 'base64'],
                    },
                    properties: {
                        type: 'object',
                        properties: {
                            payloadFormatIndicator: {
                                type: 'boolean',
                            },
                            messageExpiryInterval: {
                                type: 'integer',
                                minimum: 0,
                            },
                            willDelayInterval: {
                                type: 'integer',
                                minimum: 0,
                            },
                            responseTopic: {
                                type: 'string',
                            },
                            correlationData: {
                                type: 'string',
                            },
                            contentType: {
                                type: 'string',
                            },
                            userProperties: {
                                type: 'array',
                                items: {
                                    type: 'object',
                                    required: ['key', 'value'],
                                    properties: {
                                        key: {
                                            type: 'string',
                                        },
                                        value: {
                                            type: 'string',
                                        },
                                    },
                                    additionalProperties: false,
                                },
                            },
                        },
                        additionalProperties: false,
                    },
                },
            },
            properties: {
                type: 'object',
                properties: {
                    sessionExpiryInterval: {
                        type: 'integer',
                        minimum: 0,
                    },
                    receiveMaximum: {
                        type: 'integer',
                        minimum: 0,
                    },
                    maximumPacketSize: {
                        type: 'integer',
                        minimum: 0,
                    },
                    userProperties: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: ['key', 'value'],
                            properties: {
                                key: {
                                    type: 'string',
                                },
                                value: {
                                    type: 'string',
                                },
                                description: {
                                    type: 'string',
                                },
                                disabled: {
                                    type: 'boolean',
                                },
                            },
                            additionalProperties: false,
                        },
                    },
                },
            },
            settings: {
                type: 'object',
                properties: {
                    cleanSession: {
                        type: 'boolean',
                    },
                    keepAlive: {
                        type: 'integer',
                        minimum: 0,
                    },
                    autoReconnect: {
                        type: 'boolean',
                    },
                    connectionTimeout: {
                        type: 'integer',
                        minimum: 0,
                    },
                    strictSSL: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
            },
        },
        additionalProperties: false,
    },
    constraints: [
        {
            constraint: 'allow-child-types',
            allowed: ['mqtt-message'],
        },
        {
            constraint: 'allow-extensions',
            allowed: ['auth', 'documentation', 'variables'],
        },
    ],
});
const extensions = [
    runtime_documentation_1.default.use().implement({}),
    runtime_variables_1.default.use().implement({
        replaceInFields: [
            'payload.url',
            'payload.clientId',
            'payload.properties',
            'payload.settings',
            'payload.lastWill',
            'payload.topics',
            'extensions.auth',
        ],
    }),
];
//TODO: Add handler
var MQTTRequest;
(function (MQTTRequest) {
    MQTTRequest.use = runtime_core_1.ItemType.define(definition, extensions, handler_1.default);
})(MQTTRequest || (MQTTRequest = {}));
exports.default = MQTTRequest;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}{
  "name": "@postman/runtime.mqtt-request",
  "version": "0.4.1",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/item-types/mqtt-request#readme",
  "license": "UNLICENSED",
  "description": "The Postman ItemType: 'mqtt-request'",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "js-base64": "^3.7.5",
    "json-schema-to-ts": "~2.7.2",
    "strip-json-comments": "^3.1.1",
    "ws": "^8.16.0"
  },
  "peerDependencies": {
    "@postman/runtime.auth": "^*",
    "@postman/runtime.core": "^*",
    "@postman/runtime.documentation": "^*",
    "@postman/runtime.mqtt-utils": "^*",
    "@postman/runtime.schema": "^*",
    "@postman/runtime.variables": "^*",
    "@postman/runtime.protocol-utils": "^*"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "mqtt": "^5.1.4",
    "mqtt-packet": "^9.0.0",
    "@postman/runtime.event-channel": "0.2.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest",
    "coverage": "vitest run --coverage"
  }
}# ItemType: `mqtt-request`

This package defines the Postman ItemType: `mqtt-request`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../../core/core" },
		{ "path": "../../extensions/auth" },
		{ "path": "../../extensions/documentation" },
		{ "path": "../../extensions/schema" },
		{ "path": "../../utilities/mqtt-utils" },
		{ "path": "../../extensions/variables" },
		{ "path": "../../utilities/protocol-utils"}
	]
}
interface IGetContentType {
    payload: string | ArrayBuffer | Buffer;
    properties?: {
        payloadFormatIndicator?: boolean;
    };
}
export declare function getContentType(packet: IGetContentType): Promise<string>;
/**
 * A function to check if a payload has non-printable ASCII characters and should be displayed as binary.
 */
export declare function hasNonPrintableCharacters(payload: String | ArrayBuffer | Buffer): boolean;
export {};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContentType = getContentType;
exports.hasNonPrintableCharacters = hasNonPrintableCharacters;
const file_type_1 = __importDefault(require("file-type"));
async function getContentType(packet) {
    const { payload, properties = undefined } = packet;
    if (properties) {
        // Not using content type from properties because it could be any string.
        const { payloadFormatIndicator = undefined } = properties;
        if (payloadFormatIndicator === true) {
            return 'text/plain';
        }
    }
    let contentType;
    let payloadString = payload;
    if (typeof payloadString !== 'string') {
        try {
            const fileType = await file_type_1.default.fromBuffer(payloadString);
            contentType = fileType?.mime;
            if (contentType) {
                return contentType;
            }
            else if (hasNonPrintableCharacters(payload)) {
                return 'application/octet-stream';
            }
            else {
                payloadString = payload.toString('utf8');
            }
        }
        catch {
            // Something didn't work so we're defaulting the content-type. We should have a logger that is isomorphic
            return 'application/octet-stream';
        }
    }
    contentType =
        isMessageObject(payloadString) ? 'application/json' : 'text/plain';
    return contentType;
}
/**
 * Check if value is non-null + non-Array object
 */
function isObject(value) {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
}
/**
 * Checks if a value is a JSON object.
 */
function isMessageObject(value) {
    let parsed;
    try {
        parsed = JSON.parse(value);
    }
    catch (_) {
        return false;
    }
    if (!isObject(parsed))
        return false;
    return true;
}
/**
 * A function to check if a payload has non-printable ASCII characters and should be displayed as binary.
 */
function hasNonPrintableCharacters(payload) {
    if (typeof payload === 'string') {
        return /[\u0000-\u0009\u000B-\u000C\u000E-\u001F\u007F-\u009F\uFFFD]/.test(payload);
    }
    else {
        const uint8Array = new Uint8Array(payload);
        return uint8Array.some((byte) => {
            // ASCII values for line breaks are 10 (LF) and 13 (CR)
            if (byte === 10 || byte === 13) {
                return false;
            }
            return byte < 32 || byte > 126;
        });
    }
}
//# sourceMappingURL=content-type.js.map{"version":3,"file":"content-type.js","sourceRoot":"","sources":["../src/content-type.ts"],"names":[],"mappings":";;;;;AASA,wCAqCC;AA2BD,8DAiBC;AA1FD,0DAAiC;AAS1B,KAAK,UAAU,cAAc,CAAC,MAAuB;IAC3D,MAAM,EAAE,OAAO,EAAE,UAAU,GAAG,SAAS,EAAE,GAAG,MAAM,CAAC;IAEnD,IAAI,UAAU,EAAE,CAAC;QAChB,yEAAyE;QACzE,MAAM,EAAE,sBAAsB,GAAG,SAAS,EAAE,GAAG,UAAU,CAAC;QAE1D,IAAI,sBAAsB,KAAK,IAAI,EAAE,CAAC;YACrC,OAAO,YAAY,CAAC;QACrB,CAAC;IACF,CAAC;IAED,IAAI,WAAW,CAAC;IAChB,IAAI,aAAa,GAAG,OAAO,CAAC;IAE5B,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE,CAAC;QACvC,IAAI,CAAC;YACJ,MAAM,QAAQ,GAAG,MAAM,mBAAQ,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;YAC1D,WAAW,GAAG,QAAQ,EAAE,IAAI,CAAC;YAE7B,IAAI,WAAW,EAAE,CAAC;gBACjB,OAAO,WAAW,CAAC;YACpB,CAAC;iBAAM,IAAI,yBAAyB,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC/C,OAAO,0BAA0B,CAAC;YACnC,CAAC;iBAAM,CAAC;gBACP,aAAa,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC1C,CAAC;QACF,CAAC;QAAC,MAAM,CAAC;YACR,yGAAyG;YACzG,OAAO,0BAA0B,CAAC;QACnC,CAAC;IACF,CAAC;IAED,WAAW;QACV,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC,YAAY,CAAC;IAEpE,OAAO,WAAW,CAAC;AACpB,CAAC;AAED;;GAEG;AACH,SAAS,QAAQ,CAAC,KAAU;IAC3B,OAAO,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAC7E,CAAC;AAED;;GAEG;AACH,SAAS,eAAe,CAAC,KAAa;IACrC,IAAI,MAAM,CAAC;IACX,IAAI,CAAC;QACJ,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IAC5B,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;QAAE,OAAO,KAAK,CAAC;IACpC,OAAO,IAAI,CAAC;AACb,CAAC;AAED;;GAEG;AACH,SAAgB,yBAAyB,CACxC,OAAsC;IAEtC,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QACjC,OAAO,8DAA8D,CAAC,IAAI,CACzE,OAAO,CACP,CAAC;IACH,CAAC;SAAM,CAAC;QACP,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,OAA+B,CAAC,CAAC;QACnE,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;YAC/B,uDAAuD;YACvD,IAAI,IAAI,KAAK,EAAE,IAAI,IAAI,KAAK,EAAE,EAAE,CAAC;gBAChC,OAAO,KAAK,CAAC;YACd,CAAC;YACD,OAAO,IAAI,GAAG,EAAE,IAAI,IAAI,GAAG,GAAG,CAAC;QAChC,CAAC,CAAC,CAAC;IACJ,CAAC;AACF,CAAC"}import type { IConnackPacket, IDisconnectPacket, IPublishPacket, ISubackPacket, IUnsubackPacket, IPubackPacket, IPubrelPacket, IPubrecPacket, IPubcompPacket, ISubscribePacket, IUnsubscribePacket, IPingrespPacket, IPingreqPacket, IAuthPacket } from 'mqtt-packet';
import { MessageProperties, QoS, SubscriptionMessage } from './mqtt-message';
export interface SubackPacket extends Omit<ISubackPacket, 'granted'> {
    granted: number[];
}
export declare type Packet = SubackPacket | IUnsubackPacket | IPublishPacket | IDisconnectPacket | IConnackPacket | IPubackPacket | IPubrelPacket | IPubrecPacket | IPubcompPacket | ISubscribePacket | IUnsubscribePacket | IPingrespPacket | IAuthPacket | IPingreqPacket;
export interface AgentPublishOptions {
    qos?: QoS;
    retain?: boolean;
    dup?: boolean;
    properties?: MessageProperties;
}
export interface AgentSubscribeOptions extends Omit<SubscriptionMessage, 'name' | 'subscribe'> {
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=mqtt-events.js.map{"version":3,"file":"mqtt-events.js","sourceRoot":"","sources":["../../src/data/mqtt-events.ts"],"names":[],"mappings":""}export declare enum MQTTMessageBodyType {
    TEXT = "text",
    BINARY = "binary",
    JSON = "json",
    POSTMAN_JSON = "postman_json",
    BASE64 = "base64",
    HEX = "hex"
}
export interface UserProperties {
    key: string;
    value: string | number | boolean;
    disabled?: boolean;
    description?: string;
}
export type QoS = 0 | 1 | 2;
export interface MessageProperties {
    payloadFormatIndicator?: boolean;
    messageExpiryInterval?: number;
    topicAlias?: number;
    responseTopic?: string;
    correlationData?: string;
    subscriptionIdentifier?: number;
    contentType?: string;
    userProperties?: Omit<UserProperties, 'disabled' | 'description'>[];
}
export interface MqttMessage {
    payload: string;
    topic: string;
    type: MQTTMessageBodyType.TEXT | MQTTMessageBodyType.JSON | MQTTMessageBodyType.HEX | MQTTMessageBodyType.BASE64;
    qos: QoS;
    retain: boolean;
    properties?: MessageProperties;
}
export interface SubscriptionMessage {
    name: string;
    qos: QoS;
    subscribe: boolean;
    settings?: {
        noLocal?: boolean;
        retainAsPublished?: boolean;
        retainHandling?: 0 | 1 | 2;
        subscriptionIdentifier?: number;
    };
    userProperties?: Omit<UserProperties, 'disabled' | 'description'>[];
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MQTTMessageBodyType = void 0;
var MQTTMessageBodyType;
(function (MQTTMessageBodyType) {
    MQTTMessageBodyType["TEXT"] = "text";
    MQTTMessageBodyType["BINARY"] = "binary";
    MQTTMessageBodyType["JSON"] = "json";
    MQTTMessageBodyType["POSTMAN_JSON"] = "postman_json";
    MQTTMessageBodyType["BASE64"] = "base64";
    MQTTMessageBodyType["HEX"] = "hex";
})(MQTTMessageBodyType || (exports.MQTTMessageBodyType = MQTTMessageBodyType = {}));
//# sourceMappingURL=mqtt-message.js.map{"version":3,"file":"mqtt-message.js","sourceRoot":"","sources":["../../src/data/mqtt-message.ts"],"names":[],"mappings":";;;AAAA,IAAY,mBAOX;AAPD,WAAY,mBAAmB;IAC9B,oCAAa,CAAA;IACb,wCAAiB,CAAA;IACjB,oCAAa,CAAA;IACb,oDAA6B,CAAA;IAC7B,wCAAiB,CAAA;IACjB,kCAAW,CAAA;AACZ,CAAC,EAPW,mBAAmB,mCAAnB,mBAAmB,QAO9B"}export type { ParsedURL } from './parse-url';
export type { Packet, AgentPublishOptions, AgentSubscribeOptions, SubackPacket, } from './data/mqtt-events';
export type { UserProperties, QoS, MessageProperties, MqttMessage, SubscriptionMessage } from './data/mqtt-message';
export { parseURL } from './parse-url';
export { getContentType, hasNonPrintableCharacters } from './content-type';
export { MQTTMessageBodyType } from './data/mqtt-message';
export { parsePacket } from './remove-null';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePacket = exports.MQTTMessageBodyType = exports.hasNonPrintableCharacters = exports.getContentType = exports.parseURL = void 0;
var parse_url_1 = require("./parse-url");
Object.defineProperty(exports, "parseURL", { enumerable: true, get: function () { return parse_url_1.parseURL; } });
var content_type_1 = require("./content-type");
Object.defineProperty(exports, "getContentType", { enumerable: true, get: function () { return content_type_1.getContentType; } });
Object.defineProperty(exports, "hasNonPrintableCharacters", { enumerable: true, get: function () { return content_type_1.hasNonPrintableCharacters; } });
var mqtt_message_1 = require("./data/mqtt-message");
Object.defineProperty(exports, "MQTTMessageBodyType", { enumerable: true, get: function () { return mqtt_message_1.MQTTMessageBodyType; } });
var remove_null_1 = require("./remove-null");
Object.defineProperty(exports, "parsePacket", { enumerable: true, get: function () { return remove_null_1.parsePacket; } });
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;AAeA,yCAAuC;AAA9B,qGAAA,QAAQ,OAAA;AACjB,+CAA2E;AAAlE,8GAAA,cAAc,OAAA;AAAE,yHAAA,yBAAyB,OAAA;AAClD,oDAA0D;AAAjD,mHAAA,mBAAmB,OAAA;AAC5B,6CAA4C;AAAnC,0GAAA,WAAW,OAAA"}export type ParsedURL = {
    protocol: 'mqtt' | 'mqtts' | 'ws' | 'wss' | 'wxs' | 'alis' | 'tcp' | 'ssl';
    url: string;
    port?: string;
    host: string;
    pathname: string;
    isTLS: boolean;
};
export declare function parseURL(str: string): {
    protocol: ParsedURL["protocol"];
    host: string;
    port: string;
    url: string;
    pathname: string;
    isTLS: boolean;
};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseURL = parseURL;
/*
    Parses a string URL and validates that it is appropriate for MQTT or MQTT over WebSockets.
*/
function parseURL(str) {
    str = String(str); // For non-TypeScript applications
    // Test if the string doesn't start with a protocol
    if (!/^[a-z0-9+.-]+:\/\//i.test(str)) {
        str = `mqtt://${str}`; // Default protocol
    }
    let url;
    try {
        url = new URL(str);
    }
    catch (_) {
        throw new Error(`Invalid URL "${str}"`);
    }
    if (!url.host && !url.port && !url.pathname) {
        throw new Error(`Invalid URL "${str}"`);
    }
    const validProtocols = [
        'mqtt:',
        'mqtts:',
        'ws:',
        'wss:',
        'wxs:',
        'alis:',
        'tcp:',
        'ssl:',
    ];
    if (!validProtocols.includes(url.protocol)) {
        throw new Error(`Invalid protocol "${url.protocol}//", try "mqtt://" instead`);
    }
    const { port } = url;
    const secureProtocols = ['mqtts:', 'wss:', 'wxs:', 'alis:', 'ssl:'];
    return {
        protocol: url.protocol.replace(/:$/, ''),
        host: url.hostname,
        port: port,
        url: url.href,
        pathname: url.pathname,
        isTLS: secureProtocols.includes(url.protocol),
    };
}
//# sourceMappingURL=parse-url.js.map{"version":3,"file":"parse-url.js","sourceRoot":"","sources":["../src/parse-url.ts"],"names":[],"mappings":";;AAaA,4BAgDC;AApDD;;EAEE;AAEF,SAAgB,QAAQ,CAAC,GAAW;IACnC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,kCAAkC;IAErD,mDAAmD;IACnD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACtC,GAAG,GAAG,UAAU,GAAG,EAAE,CAAC,CAAC,mBAAmB;IAC3C,CAAC;IAED,IAAI,GAAG,CAAC;IAER,IAAI,CAAC;QACJ,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,cAAc,GAAG;QACtB,OAAO;QACP,QAAQ;QACR,KAAK;QACL,MAAM;QACN,MAAM;QACN,OAAO;QACP,MAAM;QACN,MAAM;KACN,CAAC;IAEF,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC5C,MAAM,IAAI,KAAK,CACd,qBAAqB,GAAG,CAAC,QAAQ,4BAA4B,CAC7D,CAAC;IACH,CAAC;IAED,MAAM,EAAE,IAAI,EAAE,GAAG,GAAG,CAAC;IACrB,MAAM,eAAe,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IAEpE,OAAO;QACN,QAAQ,EAAE,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAA0B;QACjE,IAAI,EAAE,GAAG,CAAC,QAAQ;QAClB,IAAI,EAAE,IAAI;QACV,GAAG,EAAE,GAAG,CAAC,IAAI;QACb,QAAQ,EAAE,GAAG,CAAC,QAAQ;QACtB,KAAK,EAAE,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC;KAC7C,CAAC;AACH,CAAC"}import type { Packet } from 'mqtt-packet';
/**
 * A function to remove null and extra properties from a packet. So the packets match their documentation.
 * https://github.com/mqttjs/mqtt-packet
 */
export declare function parsePacket(obj: Packet): Partial<import("mqtt-packet").IConnackPacket> | Partial<import("mqtt-packet").ISubackPacket> | Partial<import("mqtt-packet").IUnsubackPacket> | Partial<import("mqtt-packet").IPubackPacket | import("mqtt-packet").IPubrelPacket | import("mqtt-packet").IPubrecPacket | import("mqtt-packet").IPubcompPacket> | Partial<import("mqtt-packet").IPublishPacket> | Partial<import("mqtt-packet").IDisconnectPacket> | Partial<import("mqtt-packet").ISubscribePacket | import("mqtt-packet").IUnsubscribePacket | import("mqtt-packet").IPingrespPacket | import("mqtt-packet").IAuthPacket | import("mqtt-packet").IPingreqPacket | import("mqtt-packet").IConnectPacket>;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePacket = parsePacket;
const lodash_1 = require("lodash");
/**
 * A function to remove null and extra properties from a packet. So the packets match their documentation.
 * https://github.com/mqttjs/mqtt-packet
 */
function parsePacket(obj) {
    const { cmd } = obj;
    switch (cmd) {
        case 'connack':
            const connackFields = new Set([
                'cmd',
                'returnCode',
                'reasonCode',
                'sessionPresent',
                'properties',
                'length',
            ]);
            return (0, lodash_1.pickBy)(obj, (value, key) => value !== null && value !== undefined && connackFields.has(key));
        case 'suback':
            const subackFields = new Set([
                'cmd',
                'messageId',
                'granted',
                'properties',
                'length',
            ]);
            return (0, lodash_1.pickBy)(obj, (value, key) => value !== null && value !== undefined && subackFields.has(key));
        case 'unsuback':
            const unsubackFields = new Set([
                'cmd',
                'messageId',
                'properties',
                'length',
            ]);
            return (0, lodash_1.pickBy)(obj, (value, key) => value !== null && value !== undefined && unsubackFields.has(key));
        case 'puback':
        case 'pubrec':
        case 'pubrel':
        case 'pubcomp':
            const pubackFields = new Set([
                'cmd',
                'messageId',
                'reasonCode',
                'properties',
                'length',
            ]);
            return (0, lodash_1.pickBy)(obj, (value, key) => value !== null && value !== undefined && pubackFields.has(key));
        case 'publish':
            const publishFields = new Set([
                'cmd',
                'topic',
                'payload',
                'qos',
                'retain',
                'dup',
                'length',
                'properties',
                'messageId',
            ]);
            return (0, lodash_1.pickBy)(obj, (value, key) => value !== null && value !== undefined && publishFields.has(key));
        case 'disconnect':
            const disconnectFields = new Set(['cmd', 'reasonCode', 'properties']);
            return (0, lodash_1.pickBy)(obj, (value, key) => value !== null && value !== undefined && disconnectFields.has(key));
        default:
            return (0, lodash_1.pickBy)(obj, (value) => value !== null && value !== undefined);
    }
}
//# sourceMappingURL=remove-null.js.map{"version":3,"file":"remove-null.js","sourceRoot":"","sources":["../src/remove-null.ts"],"names":[],"mappings":";;AAOA,kCAyFC;AA/FD,mCAAgC;AAEhC;;;GAGG;AACH,SAAgB,WAAW,CAAC,GAAW;IACtC,MAAM,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC;IAEpB,QAAQ,GAAG,EAAE,CAAC;QACb,KAAK,SAAS;YACb,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC;gBAC7B,KAAK;gBACL,YAAY;gBACZ,YAAY;gBACZ,gBAAgB;gBAChB,YAAY;gBACZ,QAAQ;aACR,CAAC,CAAC;YACH,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,GAAW,EAAE,EAAE,CAC/B,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAChE,CAAC;QACH,KAAK,QAAQ;YACZ,MAAM,YAAY,GAAG,IAAI,GAAG,CAAC;gBAC5B,KAAK;gBACL,WAAW;gBACX,SAAS;gBACT,YAAY;gBACZ,QAAQ;aACR,CAAC,CAAC;YACH,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,GAAW,EAAE,EAAE,CAC/B,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAC/D,CAAC;QACH,KAAK,UAAU;YACd,MAAM,cAAc,GAAG,IAAI,GAAG,CAAC;gBAC9B,KAAK;gBACL,WAAW;gBACX,YAAY;gBACZ,QAAQ;aACR,CAAC,CAAC;YACH,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,GAAW,EAAE,EAAE,CAC/B,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,CACjE,CAAC;QACH,KAAK,QAAQ,CAAC;QACd,KAAK,QAAQ,CAAC;QACd,KAAK,QAAQ,CAAC;QACd,KAAK,SAAS;YACb,MAAM,YAAY,GAAG,IAAI,GAAG,CAAC;gBAC5B,KAAK;gBACL,WAAW;gBACX,YAAY;gBACZ,YAAY;gBACZ,QAAQ;aACR,CAAC,CAAC;YACH,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,GAAW,EAAE,EAAE,CAC/B,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAC/D,CAAC;QACH,KAAK,SAAS;YACb,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC;gBAC7B,KAAK;gBACL,OAAO;gBACP,SAAS;gBACT,KAAK;gBACL,QAAQ;gBACR,KAAK;gBACL,QAAQ;gBACR,YAAY;gBACZ,WAAW;aACX,CAAC,CAAC;YACH,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,GAAW,EAAE,EAAE,CAC/B,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAChE,CAAC;QACH,KAAK,YAAY;YAChB,MAAM,gBAAgB,GAAG,IAAI,GAAG,CAAC,CAAC,KAAK,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC,CAAC;YACtE,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,GAAW,EAAE,EAAE,CAC/B,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,CACnE,CAAC;QACH;YACC,OAAO,IAAA,eAAM,EACZ,GAAG,EACH,CAAC,KAAc,EAAE,EAAE,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CACzD,CAAC;IACJ,CAAC;AACF,CAAC"}{
  "name": "@postman/runtime.mqtt-utils",
  "version": "0.2.3",
  "license": "UNLICENSED",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/utilities/mqtt-utils#readme",
  "description": "Utilities for working with MQTT",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "devDependencies": {
    "@types/lodash": "^4.14.168",
    "@types/node": "^20.0.0",
    "mqtt-packet": "^9.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "dependencies": {
    "file-type": "^16.5.4",
    "lodash": "^4.17.21"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# mqtt-utils

This package contains utilities for working with MQTT.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": ["node"],
		
	}
}
export declare function binaryStringToUint8Array(str: string, encoding: 'hex' | 'base64'): Uint8Array;
export declare function uint8ArrayToString(message: Uint8Array): string;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.binaryStringToUint8Array = binaryStringToUint8Array;
exports.uint8ArrayToString = uint8ArrayToString;
const message_types_1 = require("./message-types");
const validators_1 = require("./validators");
function binaryStringToUint8Array(str, encoding) {
    if (encoding === message_types_1.MessageSubType.BASE64) {
        const binaryString = str
            .split(/\r?\n/)
            .map((line) => line.replace(/\s+/g, ''))
            .filter(Boolean)
            .map(validators_1.validateBase64)
            .map((line) => atob(line))
            .join('');
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }
    if (encoding === message_types_1.MessageSubType.HEX) {
        const cleanedString = str.replace(/\s+/g, '');
        (0, validators_1.validateHexadecimal)(cleanedString);
        const length = cleanedString.length;
        const uint8Array = new Uint8Array(length / 2);
        for (let i = 0; i < length; i += 2) {
            uint8Array[i / 2] = parseInt(cleanedString.substring(i, i + 2), 16);
        }
        return uint8Array;
    }
    throw new TypeError(`Unrecognized binary format: ${encoding}`);
}
function uint8ArrayToString(message) {
    let str = '';
    for (let i = 0; i < message.length; i++) {
        str += String.fromCharCode(message[i]);
    }
    return str;
}
//# sourceMappingURL=binary-utils.js.map{"version":3,"file":"binary-utils.js","sourceRoot":"","sources":["../src/binary-utils.ts"],"names":[],"mappings":";;AAGA,4DAqCC;AAED,gDAQC;AAlDD,mDAAiD;AACjD,6CAAmE;AAEnE,SAAgB,wBAAwB,CACvC,GAAW,EACX,QAA0B;IAE1B,IAAI,QAAQ,KAAK,8BAAc,CAAC,MAAM,EAAE,CAAC;QACxC,MAAM,YAAY,GAAG,GAAG;aACtB,KAAK,CAAC,OAAO,CAAC;aACd,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;aACvC,MAAM,CAAC,OAAO,CAAC;aACf,GAAG,CAAC,2BAAc,CAAC;aACnB,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACzB,IAAI,CAAC,EAAE,CAAC,CAAC;QAEX,MAAM,GAAG,GAAG,YAAY,CAAC,MAAM,CAAC;QAChC,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;QAElC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;YAC9B,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACvC,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,QAAQ,KAAK,8BAAc,CAAC,GAAG,EAAE,CAAC;QACrC,MAAM,aAAa,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC9C,IAAA,gCAAmB,EAAC,aAAa,CAAC,CAAC;QACnC,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;QACpC,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAE9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;YACpC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACrE,CAAC;QAED,OAAO,UAAU,CAAC;IACnB,CAAC;IAED,MAAM,IAAI,SAAS,CAAC,+BAA+B,QAAQ,EAAE,CAAC,CAAC;AAChE,CAAC;AAED,SAAgB,kBAAkB,CAAC,OAAmB;IACrD,IAAI,GAAG,GAAG,EAAE,CAAC;IAEb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACzC,GAAG,IAAI,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC"}export { binaryStringToUint8Array, uint8ArrayToString } from './binary-utils';
export { MessageType, MessageSubType, MIME_TYPE_MAP } from './message-types';
export { validateBase64, validateHexadecimal, isJSON } from './validators';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isJSON = exports.validateHexadecimal = exports.validateBase64 = exports.MIME_TYPE_MAP = exports.MessageSubType = exports.MessageType = exports.uint8ArrayToString = exports.binaryStringToUint8Array = void 0;
var binary_utils_1 = require("./binary-utils");
Object.defineProperty(exports, "binaryStringToUint8Array", { enumerable: true, get: function () { return binary_utils_1.binaryStringToUint8Array; } });
Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function () { return binary_utils_1.uint8ArrayToString; } });
var message_types_1 = require("./message-types");
Object.defineProperty(exports, "MessageType", { enumerable: true, get: function () { return message_types_1.MessageType; } });
Object.defineProperty(exports, "MessageSubType", { enumerable: true, get: function () { return message_types_1.MessageSubType; } });
Object.defineProperty(exports, "MIME_TYPE_MAP", { enumerable: true, get: function () { return message_types_1.MIME_TYPE_MAP; } });
var validators_1 = require("./validators");
Object.defineProperty(exports, "validateBase64", { enumerable: true, get: function () { return validators_1.validateBase64; } });
Object.defineProperty(exports, "validateHexadecimal", { enumerable: true, get: function () { return validators_1.validateHexadecimal; } });
Object.defineProperty(exports, "isJSON", { enumerable: true, get: function () { return validators_1.isJSON; } });
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;AAAA,+CAA8E;AAArE,wHAAA,wBAAwB,OAAA;AAAE,kHAAA,kBAAkB,OAAA;AACrD,iDAA6E;AAApE,4GAAA,WAAW,OAAA;AAAE,+GAAA,cAAc,OAAA;AAAE,8GAAA,aAAa,OAAA;AACnD,2CAA2E;AAAlE,4GAAA,cAAc,OAAA;AAAE,iHAAA,mBAAmB,OAAA;AAAE,oGAAA,MAAM,OAAA"}export declare enum MessageType {
    TEXT = "text",
    POSTMAN_JSON = "postman_json",
    JSON = "json",
    XML = "xml",
    HTML = "html",
    BINARY = "binary"
}
export declare enum MessageSubType {
    BASE64 = "base64",
    HEX = "hex"
}
export declare const MIME_TYPE_MAP: Record<MessageType, string>;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MIME_TYPE_MAP = exports.MessageSubType = exports.MessageType = void 0;
var MessageType;
(function (MessageType) {
    MessageType["TEXT"] = "text";
    MessageType["POSTMAN_JSON"] = "postman_json";
    MessageType["JSON"] = "json";
    MessageType["XML"] = "xml";
    MessageType["HTML"] = "html";
    MessageType["BINARY"] = "binary";
})(MessageType || (exports.MessageType = MessageType = {}));
var MessageSubType;
(function (MessageSubType) {
    MessageSubType["BASE64"] = "base64";
    MessageSubType["HEX"] = "hex";
})(MessageSubType || (exports.MessageSubType = MessageSubType = {}));
exports.MIME_TYPE_MAP = {
    [MessageType.TEXT]: 'text/plain',
    [MessageType.HTML]: 'text/html',
    [MessageType.POSTMAN_JSON]: 'application/json',
    [MessageType.JSON]: 'application/json',
    [MessageType.XML]: 'application/xml',
    [MessageType.BINARY]: 'application/octet-stream',
};
//# sourceMappingURL=message-types.js.map{"version":3,"file":"message-types.js","sourceRoot":"","sources":["../src/message-types.ts"],"names":[],"mappings":";;;AAAA,IAAY,WAOX;AAPD,WAAY,WAAW;IACtB,4BAAa,CAAA;IACb,4CAA6B,CAAA;IAC7B,4BAAa,CAAA;IACb,0BAAW,CAAA;IACX,4BAAa,CAAA;IACb,gCAAiB,CAAA;AAClB,CAAC,EAPW,WAAW,2BAAX,WAAW,QAOtB;AAED,IAAY,cAGX;AAHD,WAAY,cAAc;IACzB,mCAAiB,CAAA;IACjB,6BAAW,CAAA;AACZ,CAAC,EAHW,cAAc,8BAAd,cAAc,QAGzB;AAEY,QAAA,aAAa,GAAgC;IACzD,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,YAAY;IAChC,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,WAAW;IAC/B,CAAC,WAAW,CAAC,YAAY,CAAC,EAAE,kBAAkB;IAC9C,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,kBAAkB;IACtC,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE,iBAAiB;IACpC,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,0BAA0B;CAChD,CAAC"}export declare function validateHexadecimal(str: string): string;
export declare function validateBase64(str: string): string;
/**
 * Helper function to detect whether a give value is JSON or not
 *
 * @note This function only determines whether a given value is
 * JSON on best-effort basis and thus might result in false positives
 *
 * @param {String} value
 * @returns {Boolean}
 */
export declare function isJSON(value: string): boolean;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateHexadecimal = validateHexadecimal;
exports.validateBase64 = validateBase64;
exports.isJSON = isJSON;
function validateHexadecimal(str) {
    if (!/^([a-fA-F\d]{2})*$/.test(str)) {
        throw new SyntaxError('Invalid Hexadecimal');
    }
    return str;
}
function validateBase64(str) {
    if (!/^([a-zA-Z\d+/]{4})*([a-zA-Z\d+/]{3}=|[a-zA-Z\d+/]{2}==)?$/.test(str)) {
        throw new SyntaxError('Invalid Base64');
    }
    return str;
}
/**
 * Helper function to detect whether a give value is JSON or not
 *
 * @note This function only determines whether a given value is
 * JSON on best-effort basis and thus might result in false positives
 *
 * @param {String} value
 * @returns {Boolean}
 */
function isJSON(value) {
    value = value.trim();
    switch (value.charAt(0) + value.charAt(value.length - 1)) {
        case '[]':
        case '{}':
        case '0}': // socket.io open prefix
        case '4]': // socket.io message prefix
            return true;
        default:
            return false;
    }
}
//# sourceMappingURL=validators.js.map{"version":3,"file":"validators.js","sourceRoot":"","sources":["../src/validators.ts"],"names":[],"mappings":";;AAAA,kDAMC;AAED,wCAMC;AAWD,wBAYC;AArCD,SAAgB,mBAAmB,CAAC,GAAW;IAC9C,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACrC,MAAM,IAAI,WAAW,CAAC,qBAAqB,CAAC,CAAC;IAC9C,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAgB,cAAc,CAAC,GAAW;IACzC,IAAI,CAAC,2DAA2D,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QAC5E,MAAM,IAAI,WAAW,CAAC,gBAAgB,CAAC,CAAC;IACzC,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC;AAED;;;;;;;;GAQG;AACH,SAAgB,MAAM,CAAC,KAAa;IACnC,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;IAErB,QAAQ,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC;QAC1D,KAAK,IAAI,CAAC;QACV,KAAK,IAAI,CAAC;QACV,KAAK,IAAI,CAAC,CAAC,wBAAwB;QACnC,KAAK,IAAI,EAAE,2BAA2B;YACrC,OAAO,IAAI,CAAC;QACb;YACC,OAAO,KAAK,CAAC;IACf,CAAC;AACF,CAAC"}{
  "name": "@postman/runtime.protocol-utils",
  "version": "0.0.1",
  "license": "UNLICENSED",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/utilities/protocol-utils#readme",
  "description": "Utilities shared across multiple protocols",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "devDependencies": {
    "@types/node": "^20.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "dependencies": {},
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# protocol-utils

This package contains utilities for working with multiple protocols.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": ["node"],
		
	}
}
import { Client as RPCClient } from '@postman/runtime.runtime-rpc';
import { type IpcRenderer } from 'electron';
export interface ElectronClientOptions {
    ipc?: IpcRenderer;
    channel?: string;
}
export declare class Client extends RPCClient {
    private readonly _ipcChannel;
    constructor(options?: ElectronClientOptions);
    get channel(): string;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const runtime_runtime_rpc_1 = require("@postman/runtime.runtime-rpc");
const electron_1 = require("electron");
const deferred_1 = require("./deferred");
const channels = new Map();
const CONNECTION_TIMEOUT = 1000 * 10;
class Client extends runtime_runtime_rpc_1.Client {
    constructor(options = {}) {
        const { ipc = electron_1.ipcRenderer, channel = '@postman/runtime' } = options;
        super(async (controller) => {
            const sessionId = await connect(ipc, channel, controller);
            const { sessions } = channels.get(channel);
            return {
                send: (data) => {
                    ipc.send(channel, { op: 'message', sessionId, data });
                },
                close: () => {
                    ipc.send(channel, { op: 'disconnect', sessionId });
                    disconnect(ipc, channel, sessionId);
                },
                isOpen() {
                    return sessions.has(sessionId);
                },
            };
        });
        this._ipcChannel = channel;
    }
    get channel() {
        return this._ipcChannel;
    }
}
exports.Client = Client;
function createIPCListener(ipc, channel, sessions) {
    return (_event, msg) => {
        if (msg == null) {
            return;
        }
        const { op, sessionId } = msg;
        if (typeof op !== 'string' || typeof sessionId !== 'string') {
            return;
        }
        if (op === 'connect') {
            const session = sessions.get(sessionId);
            if (session && session.handshake) {
                if (msg.error == null) {
                    session.handshake.resolve();
                    session.handshake = null;
                }
                else {
                    session.handshake.reject(msg.error);
                    session.handshake = null;
                }
            }
        }
        else if (op === 'disconnect') {
            const session = sessions.get(sessionId);
            if (session && !session.handshake) {
                disconnect(ipc, channel, sessionId);
            }
        }
        else if (op === 'message') {
            const session = sessions.get(sessionId);
            if (session && !session.handshake) {
                session.controller.receive(msg.data);
            }
        }
    };
}
// Creates a session and connects to the server over the specified IPC channel.
// Electron IPC has no concept of a "connection", so we create a pseudo-
// "connection" via a simple handshake where we pass a unique ID to the server
// and wait for a confirmation message. The concept of a "connection" is
// important because multiple clients can be used simultaneously.
async function connect(ipc, channel, controller) {
    const channelScope = getChannelScope(ipc, channel);
    const sessionId = `${Date.now()}|${Math.random()}`;
    const handshake = (0, deferred_1.createDeferrred)(CONNECTION_TIMEOUT);
    const session = { controller, handshake };
    channelScope.sessions.set(sessionId, session);
    ipc.send(channel, { op: 'connect', sessionId });
    try {
        await handshake.promise;
    }
    catch (err) {
        disconnect(ipc, channel, sessionId);
        throw err;
    }
    return sessionId;
}
// Deletes a session from the specified IPC channel and destroys the session.
// If the session is the IPC channel's last associated session, the ChannelScope
// is also destroyed.
function disconnect(ipc, channel, sessionId) {
    const channelScope = channels.get(channel);
    if (channelScope) {
        const { sessions } = channelScope;
        const session = sessions.get(sessionId);
        if (session) {
            sessions.delete(sessionId);
            if (!sessions.size) {
                ipc.removeListener(channel, channelScope.listener);
                channels.delete(channel);
            }
            session.controller.destroy();
        }
    }
}
// Returns the ChannelScope for the specified IPC channel. The ChannelScope is
// created if it does not yet exist.
function getChannelScope(ipc, channel) {
    let channelScope = channels.get(channel);
    if (!channelScope) {
        const sessions = new Map();
        const listener = createIPCListener(ipc, channel, sessions);
        channelScope = { listener, sessions };
        ipc.on(channel, listener);
        channels.set(channel, channelScope);
    }
    return channelScope;
}
//# sourceMappingURL=browser.js.map{"version":3,"file":"browser.js","sourceRoot":"","sources":["../src/browser.ts"],"names":[],"mappings":";;;AAAA,sEAA+E;AAC/E,uCAAgF;AAChF,yCAAuD;AAOvD,MAAM,QAAQ,GAA8B,IAAI,GAAG,EAAE,CAAC;AACtD,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAE,CAAC;AAErC,MAAa,MAAO,SAAQ,4BAAS;IAGpC,YAAY,UAAiC,EAAE;QAC9C,MAAM,EAAE,GAAG,GAAG,sBAAW,EAAE,OAAO,GAAG,kBAAkB,EAAE,GAAG,OAAO,CAAC;QAEpE,KAAK,CAAC,KAAK,EAAE,UAAsB,EAAE,EAAE;YACtC,MAAM,SAAS,GAAG,MAAM,OAAO,CAAC,GAAG,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;YAC1D,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAE,CAAC;YAE5C,OAAO;gBACN,IAAI,EAAE,CAAC,IAAgB,EAAE,EAAE;oBAC1B,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;gBACvD,CAAC;gBACD,KAAK,EAAE,GAAG,EAAE;oBACX,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,EAAE,YAAY,EAAE,SAAS,EAAE,CAAC,CAAC;oBACnD,UAAU,CAAC,GAAG,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;gBACrC,CAAC;gBACD,MAAM;oBACL,OAAO,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAChC,CAAC;aACD,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC;IAC5B,CAAC;IAED,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,WAAW,CAAC;IACzB,CAAC;CACD;AA9BD,wBA8BC;AAED,SAAS,iBAAiB,CACzB,GAAgB,EAChB,OAAe,EACf,QAA8B;IAE9B,OAAO,CAAC,MAAwB,EAAE,GAAQ,EAAQ,EAAE;QACnD,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;YACjB,OAAO;QACR,CAAC;QAED,MAAM,EAAE,EAAE,EAAE,SAAS,EAAE,GAAG,GAAG,CAAC;QAC9B,IAAI,OAAO,EAAE,KAAK,QAAQ,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,CAAC;YAC7D,OAAO;QACR,CAAC;QAED,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;YACtB,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACxC,IAAI,OAAO,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;gBAClC,IAAI,GAAG,CAAC,KAAK,IAAI,IAAI,EAAE,CAAC;oBACvB,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;oBAC5B,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;gBAC1B,CAAC;qBAAM,CAAC;oBACP,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBACpC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;gBAC1B,CAAC;YACF,CAAC;QACF,CAAC;aAAM,IAAI,EAAE,KAAK,YAAY,EAAE,CAAC;YAChC,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACxC,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;gBACnC,UAAU,CAAC,GAAG,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;YACrC,CAAC;QACF,CAAC;aAAM,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;YAC7B,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACxC,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;gBACnC,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACtC,CAAC;QACF,CAAC;IACF,CAAC,CAAC;AACH,CAAC;AAED,+EAA+E;AAC/E,wEAAwE;AACxE,8EAA8E;AAC9E,wEAAwE;AACxE,iEAAiE;AACjE,KAAK,UAAU,OAAO,CACrB,GAAgB,EAChB,OAAe,EACf,UAAsB;IAEtB,MAAM,YAAY,GAAG,eAAe,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;IACnD,MAAM,SAAS,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC;IACnD,MAAM,SAAS,GAAG,IAAA,0BAAe,EAAC,kBAAkB,CAAC,CAAC;IACtD,MAAM,OAAO,GAAG,EAAE,UAAU,EAAE,SAAS,EAAE,CAAC;IAE1C,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;IAC9C,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC,CAAC;IAEhD,IAAI,CAAC;QACJ,MAAM,SAAS,CAAC,OAAO,CAAC;IACzB,CAAC;IAAC,OAAO,GAAY,EAAE,CAAC;QACvB,UAAU,CAAC,GAAG,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;QACpC,MAAM,GAAG,CAAC;IACX,CAAC;IAED,OAAO,SAAS,CAAC;AAClB,CAAC;AAED,6EAA6E;AAC7E,gFAAgF;AAChF,qBAAqB;AACrB,SAAS,UAAU,CAAC,GAAgB,EAAE,OAAe,EAAE,SAAiB;IACvE,MAAM,YAAY,GAAG,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAC3C,IAAI,YAAY,EAAE,CAAC;QAClB,MAAM,EAAE,QAAQ,EAAE,GAAG,YAAY,CAAC;QAClC,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACxC,IAAI,OAAO,EAAE,CAAC;YACb,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YAC3B,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;gBACpB,GAAG,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,CAAC,QAAQ,CAAC,CAAC;gBACnD,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAC1B,CAAC;YACD,OAAO,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;QAC9B,CAAC;IACF,CAAC;AACF,CAAC;AAED,8EAA8E;AAC9E,oCAAoC;AACpC,SAAS,eAAe,CAAC,GAAgB,EAAE,OAAe;IACzD,IAAI,YAAY,GAAG,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACzC,IAAI,CAAC,YAAY,EAAE,CAAC;QACnB,MAAM,QAAQ,GAAyB,IAAI,GAAG,EAAE,CAAC;QACjD,MAAM,QAAQ,GAAG,iBAAiB,CAAC,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC3D,YAAY,GAAG,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;QACtC,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC1B,QAAQ,CAAC,GAAG,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;IACrC,CAAC;IACD,OAAO,YAAY,CAAC;AACrB,CAAC"}export interface Deferred {
    promise: Promise<void>;
    resolve(): void;
    reject(err: any): void;
}
export declare function createDeferrred(timeout: number): Deferred;
"use strict";
/*
    Deferred is a typical exploded Promise, but it automaticlaly gets rejected
    after the specified timeout.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeferrred = void 0;
function createDeferrred(timeout) {
    let resolvePromise;
    let rejectPromise;
    const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
    });
    const timer = setTimeout(() => {
        rejectPromise(new Error('Operation timed out'));
    }, timeout);
    return {
        promise,
        resolve() {
            clearTimeout(timer);
            resolvePromise();
        },
        reject(err) {
            clearTimeout(timer);
            rejectPromise(err);
        },
    };
}
exports.createDeferrred = createDeferrred;
//# sourceMappingURL=deferred.js.map{"version":3,"file":"deferred.js","sourceRoot":"","sources":["../src/deferred.ts"],"names":[],"mappings":";AAAA;;;EAGE;;;AAQF,SAAgB,eAAe,CAAC,OAAe;IAC9C,IAAI,cAAwC,CAAC;IAC7C,IAAI,aAA+C,CAAC;IACpD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrD,cAAc,GAAG,OAAO,CAAC;QACzB,aAAa,GAAG,MAAM,CAAC;IACxB,CAAC,CAAC,CAAC;IAEH,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE;QAC7B,aAAc,CAAC,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC,CAAC;IAClD,CAAC,EAAE,OAAO,CAAC,CAAC;IAEZ,OAAO;QACN,OAAO;QACP,OAAO;YACN,YAAY,CAAC,KAAK,CAAC,CAAC;YACpB,cAAe,EAAE,CAAC;QACnB,CAAC;QACD,MAAM,CAAC,GAAQ;YACd,YAAY,CAAC,KAAK,CAAC,CAAC;YACpB,aAAc,CAAC,GAAG,CAAC,CAAC;QACrB,CAAC;KACD,CAAC;AACH,CAAC;AAvBD,0CAuBC"}import { type IpcMain } from 'electron';
import { MethodHandler } from '@postman/runtime.runtime-rpc';
export { MethodHandler, MethodContext, SessionData } from '@postman/runtime.runtime-rpc';
export interface ElectronOptions {
    ipc?: IpcMain;
    channel?: string;
}
export declare class Server {
    private _closed;
    private readonly _ipc;
    private readonly _ipcChannel;
    private readonly _ipcListener;
    private readonly _rpcSessions;
    private readonly _rpcServer;
    constructor(rpcMethods: Record<string, MethodHandler>, options?: ElectronOptions);
    close(): void;
    get channel(): string;
    get size(): number;
    get closed(): boolean;
    private static createIPCListener;
    private static registerSession;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const electron_1 = require("electron");
const runtime_runtime_rpc_1 = require("@postman/runtime.runtime-rpc"); // prettier-ignore
class Server {
    constructor(rpcMethods, options = {}) {
        const { ipc = electron_1.ipcMain, channel = '@postman/runtime' } = options;
        this._closed = false;
        this._ipc = ipc;
        this._ipcChannel = channel;
        this._ipcListener = Server.createIPCListener(this);
        this._rpcSessions = new Map();
        this._rpcServer = new runtime_runtime_rpc_1.Server(rpcMethods);
        this._ipc.on(this._ipcChannel, this._ipcListener);
    }
    close() {
        if (!this._closed) {
            this._closed = true;
            this._ipc.removeListener(this._ipcChannel, this._ipcListener);
            this._rpcServer.shutdown();
        }
    }
    get channel() {
        return this._ipcChannel;
    }
    get size() {
        return this._rpcServer.size;
    }
    get closed() {
        return this._closed;
    }
    static createIPCListener(server) {
        return (event, msg) => {
            if (msg == null) {
                return;
            }
            const { op, sessionId } = msg;
            if (typeof op !== 'string' || typeof sessionId !== 'string') {
                return;
            }
            if (op === 'connect') {
                const send = event.reply.bind(event, server._ipcChannel);
                Server.registerSession(server, sessionId, send).then(() => {
                    send({ op: 'connect', sessionId });
                }, (error) => {
                    send({ op: 'connect', sessionId, error });
                });
            }
            else if (op === 'disconnect') {
                const controller = server._rpcSessions.get(sessionId);
                if (controller) {
                    server._rpcSessions.delete(sessionId);
                    controller.destroy();
                }
            }
            else if (op === 'message') {
                const controller = server._rpcSessions.get(sessionId);
                if (controller) {
                    controller.receive(msg.data);
                }
            }
        };
    }
    static async registerSession(server, sessionId, send) {
        await server._rpcServer.newSession((controller) => {
            if (server._rpcSessions.has(sessionId)) {
                throw new Error('Session ID already in use');
            }
            server._rpcSessions.set(sessionId, controller);
            return {
                send(data) {
                    send({ op: 'message', sessionId, data });
                },
                close() {
                    send({ op: 'disconnect', sessionId });
                    server._rpcSessions.delete(sessionId);
                    controller.destroy();
                },
                isOpen() {
                    return server._rpcSessions.has(sessionId);
                },
            };
        });
    }
}
exports.Server = Server;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}{
  "name": "@postman/runtime.runtime-rpc-electron",
  "version": "0.2.0",
  "license": "UNLICENSED",
  "description": "An Electron-specific (IPC) implementation of the Runtime-RPC protocol",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/rpc/runtime-rpc-electron#readme",
  "exports": {
    "node": "./dist/index.js",
    "browser": "./dist/browser.js"
  },
  "types": "dist/index.d.ts",
  "dependencies": {
    "@postman/runtime.runtime-rpc": "^0.2.0"
  },
  "peerDependencies": {
    "electron": ">=18.0.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# runtime-rpc-electron

This package contains an Electron-specific (IPC) implementation of the [Runtime-RPC protocol](../runtime-rpc/), for communicating between Electron's renderer and main processes.

This package exposes the `Client` and `Server` classes for browser-like environments and Node.js respectively.

## Example

Client:

```ts
import { createRemoteRuntime } from '@postman/runtime'
import { Client } from '@postman/runtime.runtime-rpc-electron';
import { ipcRenderer } from 'electron';

function connect(ipc = ipcRenderer) {
  const client = new Client({ ipc });
  const runtime = createRemoteRuntime({ client });

  // ...
}
```

Server:

```ts
import { Server } from '@postman/runtime.runtime-rpc-electron';
import { ServerMethods } from '@postman/runtime';
import { ipcMain } from 'electron';

function connect(ipc = ipcMain) {
  const server = new Server(ServerMethods, { ipc });
}
```
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": [],
		"skipLibCheck": true
	},
	"references": [{ "path": "../runtime-rpc" }]
}
import { EventEmitter, type RuntimeEvent } from '@postman/runtime.core';
import { type RPCMessage } from './message';
export type MessageEvent = RuntimeEvent<'message', RPCMessage>;
export type ErrorEvent = RuntimeEvent<'error', unknown>;
export type CloseEvent = RuntimeEvent<'close'>;
export type ConnectionEvent = MessageEvent | ErrorEvent | CloseEvent;
export declare abstract class Connection extends EventEmitter<ConnectionEvent> {
    id: string;
    abstract send(message: RPCMessage): void;
    close(): void;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const runtime_core_1 = require("@postman/runtime.core");
const uuid_1 = require("uuid");
class Connection extends runtime_core_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.id = (0, uuid_1.v4)();
    }
    close() { }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map{"version":3,"file":"connection.js","sourceRoot":"","sources":["../src/connection.ts"],"names":[],"mappings":";;;AAAA,wDAAwE;AAExE,+BAAkC;AAOlC,MAAsB,UAAW,SAAQ,2BAA6B;IAAtE;;QACC,OAAE,GAAG,IAAA,SAAI,GAAE,CAAC;IAIb,CAAC;IADA,KAAK,KAAU,CAAC;CAChB;AALD,gCAKC"}import { Initializer } from './types';
export default function createClientSession(initializer: Initializer, options?: {
    timeout?: number;
}): Promise<ClientSession>;
export interface ClientSession {
    invoke<T = any>(methodName: string, params?: object, abortSignal?: AbortSignal): Promise<T>;
    close(): void;
    isOpen(): boolean;
    onClose(fn: () => void): void;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parse_message_1 = __importDefault(require("./parse-message"));
const proxy_remote_1 = __importStar(require("./proxy-remote"));
const incrementor_1 = __importDefault(require("./incrementor"));
const msgpack_1 = __importDefault(require("./msgpack"));
const timer_1 = __importDefault(require("./timer"));
const CONNECTION_TIMEOUT = 1000 * 15;
const NOOP = () => { };
async function createClientSession(initializer, options = {}) {
    const { timeout = CONNECTION_TIMEOUT } = options;
    let state = State.OPENING;
    let isIdle = false;
    let parseError = null;
    let onClose = NOOP;
    const requests = new Map();
    const proxies = new Map();
    // Initialize the underlying connection, and allow the underlying transport
    // layer to receive Runtime-RPC messages and to destroy this ClientSession.
    const connection = await initializer({
        receive(rawMsg) {
            if (state !== State.OPEN)
                return;
            timer.reset(); // The connection is okay
            let msg;
            try {
                msg = (0, parse_message_1.default)(rawMsg, requests, proxies);
            }
            catch (err) {
                parseError = err;
                terminateConnection('PROTOCOL_VIOLATION');
                return;
            }
            if (msg) {
                handlers[msg.op](msg);
            }
        },
        destroy(cause = null) {
            if (state === State.CLOSED)
                return;
            if (state === State.OPENING) {
                state = State.CLOSED;
                return;
            }
            state = State.CLOSED;
            let err;
            if (requests.size || proxies.size) {
                err = new Error('Runtime-RPC disconnected');
                if (parseError !== null || cause !== null) {
                    err.cause = parseError || cause;
                }
            }
            // Abort any pending requests.
            for (const [requestId, request] of requests) {
                requests.delete(requestId);
                request.cleanup();
                request.reject(err);
            }
            // Disconnect all proxies.
            for (const [pid, { proxy }] of proxies) {
                proxies.delete(pid);
                proxy.disconnect(err);
            }
            // Clean up resources.
            timer.stop();
            onClose();
        },
    });
    if (state !== State.OPENING || !connection.isOpen()) {
        throw new Error('Connection was closed before being opened');
    }
    state = State.OPEN;
    updateIdleness();
    const incrementor = new incrementor_1.default();
    const timer = new timer_1.default(timeout, () => {
        terminateConnection('TIMEOUT');
    });
    function sendMessage(msg) {
        if (state === State.OPEN) {
            connection.send(msgpack_1.default.encode(msg));
        }
    }
    function terminateConnection(reason) {
        if (state === State.OPEN) {
            state = State.CLOSING;
            connection.close(reason);
        }
    }
    // The session is considered idle if there are no pending requests or open
    // proxy objects. Some implementations may be interested in knowing if the
    // session is idle (for example, to keep the process alive in Node.js).
    function updateIdleness() {
        const idleness = !requests.size && !proxies.size;
        if (isIdle !== idleness) {
            isIdle = idleness;
            if (idleness) {
                connection.onIdle?.();
            }
            else {
                connection.onActive?.();
            }
        }
    }
    // This sends a request to the server to invoke a top-level RPC method.
    function invokeRPCMethod(methodName, data = {}, abortSignal) {
        return new Promise((resolve, reject) => {
            abortSignal?.throwIfAborted();
            // Sanitize inputs, for non-TypeScript applications.
            methodName = String(methodName);
            data = Object.assign({}, data);
            const requestId = incrementor.next();
            const request = { resolve, reject, cleanup: NOOP };
            sendMessage({ op: 'req', id: requestId, method: methodName, data });
            requests.set(requestId, request);
            if (abortSignal) {
                const onAbort = () => {
                    if (requests.delete(requestId)) {
                        request.cleanup();
                        request.reject(abortSignal.reason);
                        updateIdleness();
                        sendMessage({ op: 'cancel', id: requestId });
                    }
                };
                abortSignal.addEventListener('abort', onAbort);
                request.cleanup = () => {
                    abortSignal.removeEventListener('abort', onAbort);
                };
            }
            updateIdleness();
        });
    }
    // This sets up a response payload so that (if a proxy is being received)
    // the proxy is registered with the session, assigned to the given "pid",
    // and returned to the user as a ProxyRemote object.
    function prepareProxy({ remote, ...data }) {
        if (remote == null) {
            return data;
        }
        const pid = remote;
        const proxyRequests = new Set();
        const proxy = new proxy_remote_1.default(proxy_remote_1.INTERNAL, {
            connected() {
                return proxies.has(pid);
            },
            disconnect(err) {
                if (proxies.delete(pid)) {
                    sendMessage(withError({ op: 'pclose', pid }, err));
                }
                for (const requestId of proxyRequests) {
                    const request = requests.get(requestId);
                    if (request) {
                        requests.delete(requestId);
                        request.cleanup();
                        request.reject(new Error('Runtime-RPC proxy object was closed'));
                    }
                }
                updateIdleness();
            },
            call(method, ...data) {
                return new Promise((resolve, reject) => {
                    if (!proxies.has(pid)) {
                        throw new Error('Runtime-RPC proxy object is closed');
                    }
                    const requestId = incrementor.next();
                    const request = { resolve, reject, cleanup: NOOP };
                    sendMessage({ op: 'preq', pid, id: requestId, method, data });
                    requests.set(requestId, request);
                    proxyRequests.add(requestId);
                    request.cleanup = () => proxyRequests.delete(requestId);
                    updateIdleness();
                });
            },
        });
        proxies.set(pid, { proxy, requests: proxyRequests });
        return { ...data, remote: proxy };
    }
    function discardProxy({ remote }) {
        if (remote != null) {
            sendMessage({ op: 'pclose', pid: remote });
        }
    }
    // These handlers are used to react to messages received from the client.
    const handlers = {
        req() {
            terminateConnection('PROTOCOL_VIOLATION');
        },
        res(msg) {
            const request = requests.get(msg.id);
            if (request) {
                requests.delete(msg.id);
                request.cleanup();
                if ('data' in msg) {
                    request.resolve(prepareProxy(msg.data));
                }
                else {
                    request.reject(msg.error);
                }
                updateIdleness();
            }
            else if ('data' in msg) {
                discardProxy(msg.data);
            }
        },
        preq() {
            terminateConnection('PROTOCOL_VIOLATION');
        },
        pres(msg) {
            const request = requests.get(msg.id);
            if (request) {
                requests.delete(msg.id);
                request.cleanup();
                if ('data' in msg) {
                    request.resolve(msg.data);
                }
                else {
                    request.reject(msg.error);
                }
                updateIdleness();
            }
        },
        pevent({ pid, event, data }) {
            const proxyInfo = proxies.get(pid);
            if (proxyInfo) {
                proxyInfo.proxy.events.emit(event, ...data);
            }
        },
        pclose({ pid, error }) {
            const proxyInfo = proxies.get(pid);
            if (proxyInfo) {
                proxies.delete(pid);
                proxyInfo.proxy.disconnect(error);
                updateIdleness();
            }
        },
        cancel() {
            terminateConnection('PROTOCOL_VIOLATION');
        },
        hi() {
            sendMessage({ op: 'hi' });
        },
    };
    return {
        invoke: invokeRPCMethod,
        close: () => terminateConnection('NORMAL'),
        isOpen: () => state === State.OPEN && connection.isOpen(),
        onClose: (fn) => {
            onClose = fn;
        },
    };
}
exports.default = createClientSession;
var State;
(function (State) {
    State[State["OPENING"] = 0] = "OPENING";
    State[State["OPEN"] = 1] = "OPEN";
    State[State["CLOSING"] = 2] = "CLOSING";
    State[State["CLOSED"] = 3] = "CLOSED";
})(State || (State = {}));
// This ensures the type-safety of "pclose" for non-TypeScript applications.
function withError(msg, err) {
    if (err != null) {
        if (err instanceof Error) {
            msg.error = err;
        }
        else {
            msg.error = new Error(String(err));
        }
    }
    return msg;
}
//# sourceMappingURL=create-client-session.js.map{"version":3,"file":"create-client-session.js","sourceRoot":"","sources":["../src/create-client-session.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,oEAAwD;AACxD,+DAAuD;AACvD,gEAAwC;AACxC,wDAAgC;AAChC,oDAA4B;AAE5B,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAE,CAAC;AACrC,MAAM,IAAI,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC;AAEP,KAAK,UAAU,mBAAmB,CAChD,WAAwB,EACxB,UAAgC,EAAE;IAElC,MAAM,EAAE,OAAO,GAAG,kBAAkB,EAAE,GAAG,OAAO,CAAC;IAEjD,IAAI,KAAK,GAAU,KAAK,CAAC,OAAO,CAAC;IACjC,IAAI,MAAM,GAAY,KAAK,CAAC;IAC5B,IAAI,UAAU,GAAiB,IAAI,CAAC;IACpC,IAAI,OAAO,GAAe,IAAI,CAAC;IAC/B,MAAM,QAAQ,GAAyB,IAAI,GAAG,EAAE,CAAC;IACjD,MAAM,OAAO,GAA2B,IAAI,GAAG,EAAE,CAAC;IAElD,2EAA2E;IAC3E,2EAA2E;IAC3E,MAAM,UAAU,GAAG,MAAM,WAAW,CAAC;QACpC,OAAO,CAAC,MAAkB;YACzB,IAAI,KAAK,KAAK,KAAK,CAAC,IAAI;gBAAE,OAAO;YACjC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,yBAAyB;YAExC,IAAI,GAAmB,CAAC;YACxB,IAAI,CAAC;gBACJ,GAAG,GAAG,IAAA,uBAAY,EAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAC/C,CAAC;YAAC,OAAO,GAAQ,EAAE,CAAC;gBACnB,UAAU,GAAG,GAAG,CAAC;gBACjB,mBAAmB,CAAC,oBAAoB,CAAC,CAAC;gBAC1C,OAAO;YACR,CAAC;YAED,IAAI,GAAG,EAAE,CAAC;gBACT,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAU,CAAC,CAAC;YAC9B,CAAC;QACF,CAAC;QACD,OAAO,CAAC,QAAsB,IAAI;YACjC,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM;gBAAE,OAAO;YACnC,IAAI,KAAK,KAAK,KAAK,CAAC,OAAO,EAAE,CAAC;gBAC7B,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC;gBACrB,OAAO;YACR,CAAC;YAED,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC;YAErB,IAAI,GAAsB,CAAC;YAC3B,IAAI,QAAQ,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;gBACnC,GAAG,GAAG,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;gBAC5C,IAAI,UAAU,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;oBAC1C,GAAW,CAAC,KAAK,GAAG,UAAU,IAAI,KAAK,CAAC;gBAC1C,CAAC;YACF,CAAC;YAED,8BAA8B;YAC9B,KAAK,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,IAAI,QAAQ,EAAE,CAAC;gBAC7C,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;gBAC3B,OAAO,CAAC,OAAO,EAAE,CAAC;gBAClB,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACrB,CAAC;YAED,0BAA0B;YAC1B,KAAK,MAAM,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,CAAC,IAAI,OAAO,EAAE,CAAC;gBACxC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACpB,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACvB,CAAC;YAED,sBAAsB;YACtB,KAAK,CAAC,IAAI,EAAE,CAAC;YACb,OAAO,EAAE,CAAC;QACX,CAAC;KACD,CAAC,CAAC;IAEH,IAAI,KAAK,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC;QACrD,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;IAC9D,CAAC;IAED,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;IACnB,cAAc,EAAE,CAAC;IAEjB,MAAM,WAAW,GAAG,IAAI,qBAAW,EAAE,CAAC;IACtC,MAAM,KAAK,GAAG,IAAI,eAAK,CAAC,OAAO,EAAE,GAAG,EAAE;QACrC,mBAAmB,CAAC,SAAS,CAAC,CAAC;IAChC,CAAC,CAAC,CAAC;IAEH,SAAS,WAAW,CAAC,GAAY;QAChC,IAAI,KAAK,KAAK,KAAK,CAAC,IAAI,EAAE,CAAC;YAC1B,UAAU,CAAC,IAAI,CAAC,iBAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QACtC,CAAC;IACF,CAAC;IAED,SAAS,mBAAmB,CAAC,MAAmB;QAC/C,IAAI,KAAK,KAAK,KAAK,CAAC,IAAI,EAAE,CAAC;YAC1B,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC;YACtB,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAC1B,CAAC;IACF,CAAC;IAED,0EAA0E;IAC1E,0EAA0E;IAC1E,uEAAuE;IACvE,SAAS,cAAc;QACtB,MAAM,QAAQ,GAAG,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;QACjD,IAAI,MAAM,KAAK,QAAQ,EAAE,CAAC;YACzB,MAAM,GAAG,QAAQ,CAAC;YAClB,IAAI,QAAQ,EAAE,CAAC;gBACd,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC;YACvB,CAAC;iBAAM,CAAC;gBACP,UAAU,CAAC,QAAQ,EAAE,EAAE,CAAC;YACzB,CAAC;QACF,CAAC;IACF,CAAC;IAED,uEAAuE;IACvE,SAAS,eAAe,CACvB,UAAkB,EAClB,OAAgC,EAAE,EAClC,WAAyB;QAEzB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACtC,WAAW,EAAE,cAAc,EAAE,CAAC;YAE9B,oDAAoD;YACpD,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;YAChC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;YAE/B,MAAM,SAAS,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC;YACrC,MAAM,OAAO,GAAY,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;YAC5D,WAAW,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;YACpE,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;YAEjC,IAAI,WAAW,EAAE,CAAC;gBACjB,MAAM,OAAO,GAAG,GAAG,EAAE;oBACpB,IAAI,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;wBAChC,OAAO,CAAC,OAAO,EAAE,CAAC;wBAClB,OAAO,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;wBACnC,cAAc,EAAE,CAAC;wBACjB,WAAW,CAAC,EAAE,EAAE,EAAE,QAAQ,EAAE,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;oBAC9C,CAAC;gBACF,CAAC,CAAC;gBAEF,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBAC/C,OAAO,CAAC,OAAO,GAAG,GAAG,EAAE;oBACtB,WAAW,CAAC,mBAAmB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBACnD,CAAC,CAAC;YACH,CAAC;YAED,cAAc,EAAE,CAAC;QAClB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,yEAAyE;IACzE,yEAAyE;IACzE,oDAAoD;IACpD,SAAS,YAAY,CAAC,EACrB,MAAM,EACN,GAAG,IAAI,EACkB;QACzB,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;YACpB,OAAO,IAAI,CAAC;QACb,CAAC;QAED,MAAM,GAAG,GAAG,MAAgB,CAAC;QAC7B,MAAM,aAAa,GAAgB,IAAI,GAAG,EAAE,CAAC;QAC7C,MAAM,KAAK,GAAG,IAAI,sBAAW,CAAC,uBAAQ,EAAE;YACvC,SAAS;gBACR,OAAO,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACzB,CAAC;YACD,UAAU,CAAC,GAAsB;gBAChC,IAAI,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC;oBACzB,WAAW,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,QAAQ,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;gBACpD,CAAC;gBACD,KAAK,MAAM,SAAS,IAAI,aAAa,EAAE,CAAC;oBACvC,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBACxC,IAAI,OAAO,EAAE,CAAC;wBACb,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;wBAC3B,OAAO,CAAC,OAAO,EAAE,CAAC;wBAClB,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC,CAAC;oBAClE,CAAC;gBACF,CAAC;gBACD,cAAc,EAAE,CAAC;YAClB,CAAC;YACD,IAAI,CAAC,MAAc,EAAE,GAAG,IAAW;gBAClC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;oBACtC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;wBACvB,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;oBACvD,CAAC;oBAED,MAAM,SAAS,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC;oBACrC,MAAM,OAAO,GAAY,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;oBAC5D,WAAW,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;oBAC9D,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;oBACjC,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBAC7B,OAAO,CAAC,OAAO,GAAG,GAAG,EAAE,CAAC,aAAa,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;oBACxD,cAAc,EAAE,CAAC;gBAClB,CAAC,CAAC,CAAC;YACJ,CAAC;SACD,CAAC,CAAC;QAEH,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,EAAE,CAAC,CAAC;QACrD,OAAO,EAAE,GAAG,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC;IACnC,CAAC;IAED,SAAS,YAAY,CAAC,EAAE,MAAM,EAA2B;QACxD,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;YACpB,WAAW,CAAC,EAAE,EAAE,EAAE,QAAQ,EAAE,GAAG,EAAE,MAAgB,EAAE,CAAC,CAAC;QACtD,CAAC;IACF,CAAC;IAED,yEAAyE;IACzE,MAAM,QAAQ,GAA8C;QAC3D,GAAG;YACF,mBAAmB,CAAC,oBAAoB,CAAC,CAAC;QAC3C,CAAC;QACD,GAAG,CAAC,GAA4B;YAC/B,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACrC,IAAI,OAAO,EAAE,CAAC;gBACb,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBACxB,OAAO,CAAC,OAAO,EAAE,CAAC;gBAClB,IAAI,MAAM,IAAI,GAAG,EAAE,CAAC;oBACnB,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;gBACzC,CAAC;qBAAM,CAAC;oBACP,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC3B,CAAC;gBACD,cAAc,EAAE,CAAC;YAClB,CAAC;iBAAM,IAAI,MAAM,IAAI,GAAG,EAAE,CAAC;gBAC1B,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACxB,CAAC;QACF,CAAC;QACD,IAAI;YACH,mBAAmB,CAAC,oBAAoB,CAAC,CAAC;QAC3C,CAAC;QACD,IAAI,CAAC,GAA6B;YACjC,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACrC,IAAI,OAAO,EAAE,CAAC;gBACb,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBACxB,OAAO,CAAC,OAAO,EAAE,CAAC;gBAClB,IAAI,MAAM,IAAI,GAAG,EAAE,CAAC;oBACnB,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC3B,CAAC;qBAAM,CAAC;oBACP,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC3B,CAAC;gBACD,cAAc,EAAE,CAAC;YAClB,CAAC;QACF,CAAC;QACD,MAAM,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAA8B;YACtD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,SAAS,EAAE,CAAC;gBACf,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC;YAC7C,CAAC;QACF,CAAC;QACD,MAAM,CAAC,EAAE,GAAG,EAAE,KAAK,EAA8B;YAChD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,SAAS,EAAE,CAAC;gBACf,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACpB,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;gBAClC,cAAc,EAAE,CAAC;YAClB,CAAC;QACF,CAAC;QACD,MAAM;YACL,mBAAmB,CAAC,oBAAoB,CAAC,CAAC;QAC3C,CAAC;QACD,EAAE;YACD,WAAW,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC;QAC3B,CAAC;KACD,CAAC;IAEF,OAAO;QACN,MAAM,EAAE,eAAe;QACvB,KAAK,EAAE,GAAG,EAAE,CAAC,mBAAmB,CAAC,QAAQ,CAAC;QAC1C,MAAM,EAAE,GAAG,EAAE,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,IAAI,UAAU,CAAC,MAAM,EAAE;QACzD,OAAO,EAAE,CAAC,EAAc,EAAE,EAAE;YAC3B,OAAO,GAAG,EAAE,CAAC;QACd,CAAC;KACD,CAAC;AACH,CAAC;AA/QD,sCA+QC;AAaD,IAAK,KAKJ;AALD,WAAK,KAAK;IACT,uCAAO,CAAA;IACP,iCAAI,CAAA;IACJ,uCAAO,CAAA;IACP,qCAAM,CAAA;AACP,CAAC,EALI,KAAK,KAAL,KAAK,QAKT;AAaD,4EAA4E;AAC5E,SAAS,SAAS,CAAC,GAA+B,EAAE,GAAY;IAC/D,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;QACjB,IAAI,GAAG,YAAY,KAAK,EAAE,CAAC;YAC1B,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC;QACjB,CAAC;aAAM,CAAC;YACP,GAAG,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IACD,OAAO,GAAG,CAAC;AACZ,CAAC"}import { Initializer, MethodHandler } from './types';
export default function createServerSession(initializer: Initializer, rpcMethods: Record<string, MethodHandler>, options?: {
    heartbeat?: {
        interval?: number;
        tries?: number;
    };
}): Promise<ServerSession>;
export interface ServerSession {
    close(): void;
    onClose(fn: () => void): void;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parse_message_1 = __importDefault(require("./parse-message"));
const proxy_result_1 = __importStar(require("./proxy-result"));
const incrementor_1 = __importDefault(require("./incrementor"));
const heartbeat_1 = __importDefault(require("./heartbeat"));
const msgpack_1 = __importDefault(require("./msgpack"));
const HEARTBEAT_INTERVAL = 1000 * 3;
const HEARTBEAT_TRIES = 3;
const NOOP = () => { };
async function createServerSession(initializer, rpcMethods, options = {}) {
    const { interval: heartbeatInterval = HEARTBEAT_INTERVAL, tries: heartbeatTries = HEARTBEAT_TRIES, } = options?.heartbeat ?? {};
    let state = State.OPENING;
    let onClose = NOOP;
    const requests = new Map();
    const proxies = new Map();
    // Initialize the underlying connection, and allow the underlying transport
    // layer to receive Runtime-RPC messages and to destroy this ServerSession.
    const connection = await initializer({
        receive(rawMsg) {
            if (state !== State.OPEN)
                return;
            if (requests.size || proxies.size) {
                heartbeat.reset(); // The connection is not idle
            }
            let msg;
            try {
                msg = (0, parse_message_1.default)(rawMsg, requests, proxies);
            }
            catch (_) {
                terminateConnection('PROTOCOL_VIOLATION');
                return;
            }
            if (msg) {
                handlers[msg.op](msg);
            }
        },
        destroy() {
            if (state === State.CLOSED)
                return;
            if (state === State.OPENING) {
                state = State.CLOSED;
                return;
            }
            state = State.CLOSED;
            // Abort any pending requests.
            for (const [requestId, request] of requests) {
                requests.delete(requestId);
                request.cleanup();
                request.abortController.abort();
            }
            // Disconnect all proxies.
            for (const [pid, { proxy }] of proxies) {
                proxies.delete(pid);
                proxy.disconnect();
            }
            // Clean up resources.
            heartbeat.stop();
            onClose();
        },
    });
    if (state !== State.OPENING || !connection.isOpen()) {
        throw new Error('Connection was closed before being opened');
    }
    state = State.OPEN;
    const session = {};
    const incrementor = new incrementor_1.default();
    const heartbeat = new heartbeat_1.default(heartbeatInterval, heartbeatTries, (isHeartbeatFailure) => {
        if (isHeartbeatFailure) {
            terminateConnection('TIMEOUT');
        }
        else {
            sendMessage({ op: 'hi' });
        }
    });
    function sendMessage(msg) {
        if (state === State.OPEN) {
            connection.send(msgpack_1.default.encode(msg));
        }
    }
    function terminateConnection(reason) {
        if (state === State.OPEN) {
            state = State.CLOSING;
            connection.close(reason);
        }
    }
    // This invokes a top-level RPC method that the client requested.
    function invokeRPCMethod(requestId, methodName, data, ctx) {
        new Promise((resolve) => {
            resolve((rpcMethods[methodName] || methodNotFound)(data, ctx));
        })
            .then((returnValue) => {
            const request = requests.get(requestId);
            if (request) {
                requests.delete(requestId);
                request.cleanup();
                const data = prepareProxy(Object.assign({}, returnValue));
                sendMessage({ op: 'res', id: requestId, data });
            }
            else {
                discardProxy(Object.assign({}, returnValue));
            }
        })
            .catch((err) => {
            const request = requests.get(requestId);
            if (request) {
                requests.delete(requestId);
                request.cleanup();
                const error = err instanceof Error ? err : new Error(String(err));
                sendMessage({ op: 'res', id: requestId, error });
            }
        });
    }
    // This invokes a method on a proxy that was previously sent to the client.
    function invokeProxyMethod(requestId, methodName, data, proxyInfo) {
        new Promise((resolve) => {
            resolve(proxyInfo.proxy.target[methodName](...data));
        })
            .then((data) => {
            const request = requests.get(requestId);
            if (request) {
                requests.delete(requestId);
                request.cleanup();
                sendMessage({ op: 'pres', id: requestId, data });
            }
        })
            .catch((err) => {
            const request = requests.get(requestId);
            if (request) {
                requests.delete(requestId);
                request.cleanup();
                const error = err instanceof Error ? err : new Error(String(err));
                sendMessage({ op: 'pres', id: requestId, error });
            }
        });
    }
    // This sets up a response payload so that (if a proxy is being sent) the
    // proxy is registered with the session, assigned a unique "pid", and set up
    // to forward events to the client (if it looks like an EventEmitter).
    function prepareProxy({ remote, ...data }) {
        if (remote == null) {
            return data;
        }
        const pid = incrementor.next();
        const proxyRequests = new Set();
        const proxy = remote instanceof proxy_result_1.default ? remote : new proxy_result_1.default(remote);
        const { target } = proxy;
        const { emit } = target;
        if (typeof emit === 'function') {
            target.addListener('error', NOOP);
            target.emit = (event, ...data) => {
                sendMessage({ op: 'pevent', pid, event, data });
                return emit.call(target, event, ...data);
            };
        }
        proxy_result_1.default[proxy_result_1.ATTACH](proxy, {
            connected() {
                return proxies.has(pid);
            },
            disconnect(err) {
                if (proxies.delete(pid)) {
                    sendMessage(withError({ op: 'pclose', pid }, err));
                }
                if (typeof emit === 'function') {
                    target.emit = emit;
                    target.removeListener('error', NOOP);
                }
                for (const requestId of proxyRequests) {
                    const request = requests.get(requestId);
                    if (request) {
                        requests.delete(requestId);
                        request.cleanup();
                        request.abortController.abort();
                    }
                }
            },
        });
        proxies.set(pid, { proxy, requests: proxyRequests });
        return { ...data, remote: pid };
    }
    function discardProxy({ remote }) {
        if (remote instanceof proxy_result_1.default) {
            remote.disconnect();
        }
    }
    // These handlers are used to react to messages received from the client.
    const handlers = {
        req({ id, method, data }) {
            const abortController = new AbortController();
            const request = { abortController, cleanup: NOOP };
            const ctx = { signal: abortController.signal, session };
            requests.set(id, request);
            invokeRPCMethod(id, method, data, ctx);
            heartbeat.reset(); // The connection is not idle
        },
        res() {
            terminateConnection('PROTOCOL_VIOLATION');
        },
        preq({ pid, id, method, data }) {
            const proxyInfo = proxies.get(pid);
            if (proxyInfo) {
                const abortController = new AbortController();
                const request = { abortController, cleanup: NOOP };
                requests.set(id, request);
                proxyInfo.requests.add(id);
                request.cleanup = () => proxyInfo.requests.delete(id);
                invokeProxyMethod(id, method, data, proxyInfo);
                heartbeat.reset(); // The connection is not idle
            }
        },
        pres() {
            terminateConnection('PROTOCOL_VIOLATION');
        },
        pevent() {
            terminateConnection('PROTOCOL_VIOLATION');
        },
        pclose({ pid, error }) {
            const proxyInfo = proxies.get(pid);
            if (proxyInfo) {
                proxies.delete(pid);
                proxyInfo.proxy.disconnect(error);
            }
        },
        cancel({ id }) {
            const request = requests.get(id);
            if (request) {
                requests.delete(id);
                request.cleanup();
                request.abortController.abort();
            }
        },
        hi() {
            // No-op
        },
    };
    return {
        close: () => terminateConnection('NORMAL'),
        onClose: (fn) => {
            onClose = fn;
        },
    };
}
exports.default = createServerSession;
var State;
(function (State) {
    State[State["OPENING"] = 0] = "OPENING";
    State[State["OPEN"] = 1] = "OPEN";
    State[State["CLOSING"] = 2] = "CLOSING";
    State[State["CLOSED"] = 3] = "CLOSED";
})(State || (State = {}));
function methodNotFound() {
    throw new Error('Method not found');
}
// This ensures the type-safety of "pclose" for non-TypeScript applications.
function withError(msg, err) {
    if (err != null) {
        if (err instanceof Error) {
            msg.error = err;
        }
        else {
            msg.error = new Error(String(err));
        }
    }
    return msg;
}
//# sourceMappingURL=create-server-session.js.map{"version":3,"file":"create-server-session.js","sourceRoot":"","sources":["../src/create-server-session.ts"],"names":[],"mappings":"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"}export declare const EVENTS: unique symbol;
export type EventListener = (...args: any[]) => void;
export default class EventEmitter {
    private [EVENTS];
    emit(event: string, ...args: any[]): boolean;
    addListener(event: string, listener: EventListener): this;
    removeListener(event: string, listener: EventListener): this;
    on(event: string, listener: EventListener): this;
    off(event: string, listener: EventListener): this;
}
"use strict";
/*
    This class implements a subset of the Node.js EventEmitter.
*/
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVENTS = void 0;
exports.EVENTS = Symbol('events');
class EventEmitter {
    constructor() {
        this[_a] = new Map();
    }
    emit(event, ...args) {
        const listeners = this[exports.EVENTS].get(event);
        if (listeners) {
            for (const listener of listeners.slice()) {
                listener.apply(this, args);
            }
            return true;
        }
        return false;
    }
    addListener(event, listener) {
        let listeners = this[exports.EVENTS].get(event);
        if (!listeners) {
            listeners = [];
            this[exports.EVENTS].set(event, listeners);
        }
        listeners.push(listener);
        return this;
    }
    removeListener(event, listener) {
        let listeners = this[exports.EVENTS].get(event);
        if (listeners) {
            for (let i = 0; i < listeners.length; ++i) {
                if (listeners[i] === listener) {
                    if (listeners.length > 1) {
                        listeners.splice(i, 1);
                    }
                    else {
                        this[exports.EVENTS].delete(event);
                    }
                    break;
                }
            }
        }
        return this;
    }
    on(event, listener) {
        return this.addListener(event, listener);
    }
    off(event, listener) {
        return this.removeListener(event, listener);
    }
}
_a = exports.EVENTS;
exports.default = EventEmitter;
//# sourceMappingURL=event-emitter.js.map{"version":3,"file":"event-emitter.js","sourceRoot":"","sources":["../src/event-emitter.ts"],"names":[],"mappings":";AAAA;;EAEE;;;;AAEW,QAAA,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAGvC,MAAqB,YAAY;IAAjC;QACS,QAAQ,GAAiC,IAAI,GAAG,EAAE,CAAC;IA+C5D,CAAC;IA7CA,IAAI,CAAC,KAAa,EAAE,GAAG,IAAW;QACjC,MAAM,SAAS,GAAG,IAAI,CAAC,cAAM,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC1C,IAAI,SAAS,EAAE,CAAC;YACf,KAAK,MAAM,QAAQ,IAAI,SAAS,CAAC,KAAK,EAAE,EAAE,CAAC;gBAC1C,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAC5B,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAED,WAAW,CAAC,KAAa,EAAE,QAAuB;QACjD,IAAI,SAAS,GAAG,IAAI,CAAC,cAAM,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACxC,IAAI,CAAC,SAAS,EAAE,CAAC;YAChB,SAAS,GAAG,EAAE,CAAC;YACf,IAAI,CAAC,cAAM,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;QACpC,CAAC;QACD,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC;IACb,CAAC;IAED,cAAc,CAAC,KAAa,EAAE,QAAuB;QACpD,IAAI,SAAS,GAAG,IAAI,CAAC,cAAM,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACxC,IAAI,SAAS,EAAE,CAAC;YACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;gBAC3C,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE,CAAC;oBAC/B,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC1B,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACxB,CAAC;yBAAM,CAAC;wBACP,IAAI,CAAC,cAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBAC5B,CAAC;oBACD,MAAM;gBACP,CAAC;YACF,CAAC;QACF,CAAC;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IAED,EAAE,CAAC,KAAa,EAAE,QAAuB;QACxC,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAED,GAAG,CAAC,KAAa,EAAE,QAAuB;QACzC,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC7C,CAAC;CACD;KA/CS,cAAM;kBADK,YAAY"}export default class Heartbeat {
    private countdown;
    private timer;
    constructor(interval: number, tries: number, callback: (failure: boolean) => void);
    reset(): void;
    stop(): void;
}
"use strict";
/*
    Starts a new heartbeat. The callback will be invoked at regular intervals
    with `false` passed as the only argument, until the number of consecutive
    calls exceeds the `tries` argument, at which point the callback will be
    invoked one last time with `true` passed as the argument, which indicates a
    heartbeat failure.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class Heartbeat {
    constructor(interval, tries, callback) {
        this.countdown = 0;
        if (interval === 0)
            return;
        this.timer = setInterval(() => {
            if (++this.countdown > tries) {
                clearInterval(this.timer);
                callback(true);
            }
            else {
                callback(false);
            }
        }, interval);
    }
    // Invoke this when activity occurs to reset the heartbeat.
    reset() {
        this.countdown = 0;
    }
    // Abort the heartbeat and clean up.
    stop() {
        clearInterval(this.timer);
    }
}
exports.default = Heartbeat;
//# sourceMappingURL=heartbeat.js.map{"version":3,"file":"heartbeat.js","sourceRoot":"","sources":["../src/heartbeat.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,MAAqB,SAAS;IAI7B,YACC,QAAgB,EAChB,KAAa,EACb,QAAoC;QAEpC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;QAEnB,IAAI,QAAQ,KAAK,CAAC;YAAE,OAAO;QAE3B,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,GAAG,EAAE;YAC7B,IAAI,EAAE,IAAI,CAAC,SAAS,GAAG,KAAK,EAAE,CAAC;gBAC9B,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC1B,QAAQ,CAAC,IAAI,CAAC,CAAC;YAChB,CAAC;iBAAM,CAAC;gBACP,QAAQ,CAAC,KAAK,CAAC,CAAC;YACjB,CAAC;QACF,CAAC,EAAE,QAAQ,CAAC,CAAC;IACd,CAAC;IAED,2DAA2D;IAC3D,KAAK;QACJ,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;IACpB,CAAC;IAED,oCAAoC;IACpC,IAAI;QACH,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC3B,CAAC;CACD;AAhCD,4BAgCC"}export default class Incrementor {
    private nextId;
    next(): number;
}
"use strict";
/*
    A simple class that generates incrementing positive 32-bit unsigned
    integers, wrapping back to 1 when necessary.
*/
Object.defineProperty(exports, "__esModule", { value: true });
class Incrementor {
    constructor() {
        this.nextId = 1;
    }
    next() {
        const id = this.nextId;
        this.nextId = (id + 1) >>> 0 || 1;
        return id;
    }
}
exports.default = Incrementor;
//# sourceMappingURL=incrementor.js.map{"version":3,"file":"incrementor.js","sourceRoot":"","sources":["../src/incrementor.ts"],"names":[],"mappings":";AAAA;;;EAGE;;AAEF,MAAqB,WAAW;IAAhC;QACS,WAAM,GAAW,CAAC,CAAC;IAO5B,CAAC;IALA,IAAI;QACH,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClC,OAAO,EAAE,CAAC;IACX,CAAC;CACD;AARD,8BAQC"}import { Initializer, MethodHandler } from './types';
export { default as EventEmitter } from './event-emitter';
export { default as ProxyState } from './proxy-state';
export { default as ProxyResult } from './proxy-result';
export { default as ProxyRemote, ProxyObject } from './proxy-remote';
export * from './types';
export declare class Client {
    private readonly _sessions;
    private readonly _getSession;
    private _lastCancellation;
    constructor(initializer: Initializer, options?: {
        timeout?: number;
    });
    invoke<T = any>(methodName: string, params?: object, abortSignal?: AbortSignal): Promise<T>;
    cancel(): void;
}
export declare class Server {
    protected options: {
        heartbeat?: {
            interval?: number;
            tries?: number;
        };
    };
    private readonly _rpcMethods;
    private readonly _sessions;
    private _lastShutdown;
    constructor(rpcMethods: Record<string, MethodHandler>, options?: {
        heartbeat?: {
            interval?: number;
            tries?: number;
        };
    });
    newSession(initializer: Initializer): Promise<void>;
    shutdown(): void;
    get size(): number;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = exports.Client = exports.ProxyRemote = exports.ProxyResult = exports.ProxyState = exports.EventEmitter = void 0;
const create_client_session_1 = __importDefault(require("./create-client-session"));
const create_server_session_1 = __importDefault(require("./create-server-session"));
var event_emitter_1 = require("./event-emitter");
Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: function () { return __importDefault(event_emitter_1).default; } });
var proxy_state_1 = require("./proxy-state");
Object.defineProperty(exports, "ProxyState", { enumerable: true, get: function () { return __importDefault(proxy_state_1).default; } });
var proxy_result_1 = require("./proxy-result");
Object.defineProperty(exports, "ProxyResult", { enumerable: true, get: function () { return __importDefault(proxy_result_1).default; } });
var proxy_remote_1 = require("./proxy-remote");
Object.defineProperty(exports, "ProxyRemote", { enumerable: true, get: function () { return __importDefault(proxy_remote_1).default; } });
__exportStar(require("./types"), exports);
class Client {
    constructor(initializer, options = {}) {
        this._sessions = new Set();
        this._lastCancellation = Symbol();
        const registerSession = (session) => {
            this._sessions.add(session);
            session.onClose(() => this._sessions.delete(session));
        };
        let currentSession = null;
        const getSession = async () => {
            // If the current session is still open, re-use it.
            const promise = currentSession; // Save variable before "await"
            if (promise) {
                const session = await promise;
                if (session.isOpen())
                    return session;
            }
            // If the current session is not open (or there is no session), we
            // create a new one. Note that this if-statement protects against a
            // race condition where multiple calls to getSession() are made
            // concurrently and they both want to create new sessions (but we
            // should only create one new session at a time).
            if (currentSession === promise) {
                currentSession = (0, create_client_session_1.default)(initializer, options);
                currentSession.then(registerSession);
                currentSession.catch(() => { }); // Suppress "unhandledRejection"
            }
            return currentSession;
        };
        // This is the same as getSession() above, except it respects calls to
        // client.cancel() that may occur while creating a new session.
        this._getSession = async () => {
            const symbol = this._lastCancellation;
            const session = await getSession();
            if (symbol !== this._lastCancellation) {
                session.close();
                throw new Error('Runtime-RPC disconnected');
            }
            return session;
        };
    }
    // Grabs an available session and invokes a remote RPC method.
    async invoke(methodName, params, abortSignal) {
        const session = await this._getSession();
        return session.invoke(methodName, params, abortSignal);
    }
    // Closes all open sessions, cancelling all current requests.
    cancel() {
        this._lastCancellation = Symbol();
        for (const session of this._sessions) {
            session.close();
        }
    }
}
exports.Client = Client;
class Server {
    constructor(rpcMethods, options = {}) {
        this.options = options;
        this._sessions = new Set();
        this._lastShutdown = Symbol();
        this._rpcMethods = Object.assign(Object.create(null), rpcMethods);
    }
    // Adds a new session (connection) to the server.
    async newSession(initializer) {
        const symbol = this._lastShutdown;
        const session = await (0, create_server_session_1.default)(initializer, this._rpcMethods, this.options);
        if (symbol !== this._lastShutdown) {
            // If the server was shutdown while creating this session, close it.
            session.close();
        }
        else {
            this._sessions.add(session);
            session.onClose(() => this._sessions.delete(session));
        }
    }
    // Closes all open sessions, cancelling all current requests.
    shutdown() {
        this._lastShutdown = Symbol();
        for (const session of this._sessions) {
            session.close();
        }
    }
    get size() {
        return this._sessions.size;
    }
}
exports.Server = Server;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}import { z } from 'zod';
export declare const RPCId: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
export type RPCId = z.infer<typeof RPCId>;
export declare const RPCData: z.ZodRecord<z.ZodString, z.ZodUnknown>;
export type RPCData = z.infer<typeof RPCData>;
export declare const RPCRequest: z.ZodObject<{
    op: z.ZodLiteral<"req">;
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    method: z.ZodString;
    data: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "req";
    id: string | number;
    method: string;
    data?: Record<string, unknown> | null | undefined;
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "req";
    id: string | number;
    method: string;
    data?: Record<string, unknown> | null | undefined;
    context?: Record<string, unknown> | null | undefined;
}>;
export type RPCRequest = z.infer<typeof RPCRequest>;
export declare const RPCResponse: z.ZodObject<{
    op: z.ZodLiteral<"res">;
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    data: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
    error: z.ZodUnknown;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "res";
    id: string | number;
    data?: Record<string, unknown> | null | undefined;
    error?: unknown;
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "res";
    id: string | number;
    data?: Record<string, unknown> | null | undefined;
    error?: unknown;
    context?: Record<string, unknown> | null | undefined;
}>;
export type RPCResponse = z.infer<typeof RPCResponse>;
export declare const RPCCancel: z.ZodObject<{
    op: z.ZodLiteral<"cancel">;
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "cancel";
    id: string | number;
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "cancel";
    id: string | number;
    context?: Record<string, unknown> | null | undefined;
}>;
export type RPCCancel = z.infer<typeof RPCCancel>;
export declare const RPCHeartbeat: z.ZodObject<{
    op: z.ZodLiteral<"hi">;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "hi";
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "hi";
    context?: Record<string, unknown> | null | undefined;
}>;
export type RPCHeartbeat = z.infer<typeof RPCHeartbeat>;
export declare const RPCMessage: z.ZodDiscriminatedUnion<"op", [z.ZodObject<{
    op: z.ZodLiteral<"req">;
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    method: z.ZodString;
    data: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "req";
    id: string | number;
    method: string;
    data?: Record<string, unknown> | null | undefined;
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "req";
    id: string | number;
    method: string;
    data?: Record<string, unknown> | null | undefined;
    context?: Record<string, unknown> | null | undefined;
}>, z.ZodObject<{
    op: z.ZodLiteral<"res">;
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    data: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
    error: z.ZodUnknown;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "res";
    id: string | number;
    data?: Record<string, unknown> | null | undefined;
    error?: unknown;
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "res";
    id: string | number;
    data?: Record<string, unknown> | null | undefined;
    error?: unknown;
    context?: Record<string, unknown> | null | undefined;
}>, z.ZodObject<{
    op: z.ZodLiteral<"cancel">;
    id: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "cancel";
    id: string | number;
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "cancel";
    id: string | number;
    context?: Record<string, unknown> | null | undefined;
}>, z.ZodObject<{
    op: z.ZodLiteral<"hi">;
    context: z.ZodNullable<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>>;
}, "strip", z.ZodTypeAny, {
    op: "hi";
    context?: Record<string, unknown> | null | undefined;
}, {
    op: "hi";
    context?: Record<string, unknown> | null | undefined;
}>]> & {
    encode(message: RPCMessage): Uint8Array;
    decode(data: ArrayBuffer | Uint8Array): RPCMessage;
};
export type RPCMessage = RPCRequest | RPCResponse | RPCCancel | RPCHeartbeat;
export declare const messages: {
    request(id: RPCId, method: string, data?: RPCData): RPCRequest;
    success(id: RPCId, data?: RPCData | null): RPCResponse;
    failure(id: RPCId, error: unknown): RPCResponse;
    cancel(id: RPCId): RPCCancel;
    heartbeat(): RPCHeartbeat;
};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.messages = exports.RPCMessage = exports.RPCHeartbeat = exports.RPCCancel = exports.RPCResponse = exports.RPCRequest = exports.RPCData = exports.RPCId = void 0;
const zod_1 = require("zod");
const msgpack_1 = __importDefault(require("./msgpack"));
exports.RPCId = zod_1.z.union([zod_1.z.string(), zod_1.z.number()]);
exports.RPCData = zod_1.z.record(zod_1.z.string(), zod_1.z.unknown());
exports.RPCRequest = zod_1.z.object({
    op: zod_1.z.literal('req'),
    id: exports.RPCId,
    method: zod_1.z.string(),
    data: exports.RPCData.optional().nullable(),
    context: exports.RPCData.optional().nullable(),
});
exports.RPCResponse = zod_1.z.object({
    op: zod_1.z.literal('res'),
    id: exports.RPCId,
    data: exports.RPCData.optional().nullable(),
    error: zod_1.z.unknown(),
    context: exports.RPCData.optional().nullable(),
});
exports.RPCCancel = zod_1.z.object({
    op: zod_1.z.literal('cancel'),
    id: exports.RPCId,
    context: exports.RPCData.optional().nullable(),
});
exports.RPCHeartbeat = zod_1.z.object({
    op: zod_1.z.literal('hi'),
    context: exports.RPCData.optional().nullable(),
});
exports.RPCMessage = Object.assign(zod_1.z.discriminatedUnion('op', [exports.RPCRequest, exports.RPCResponse, exports.RPCCancel, exports.RPCHeartbeat]), {
    encode(message) {
        return msgpack_1.default.encode(message);
    },
    decode(data) {
        if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data);
        }
        if (!(data instanceof Uint8Array)) {
            throw new TypeError('Expected ArrayBuffer or Uint8Array');
        }
        const message = msgpack_1.default.decode(data);
        return exports.RPCMessage.parse(message);
    },
});
exports.messages = {
    request(id, method, data) {
        return { op: 'req', id, method, data };
    },
    success(id, data) {
        return { op: 'res', id, data };
    },
    failure(id, error) {
        return { op: 'res', id, error };
    },
    cancel(id) {
        return { op: 'cancel', id };
    },
    heartbeat() {
        return { op: 'hi' };
    },
};
//# sourceMappingURL=message.js.map{"version":3,"file":"message.js","sourceRoot":"","sources":["../src/message.ts"],"names":[],"mappings":"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"}declare const _default: {
    encode(data: unknown): Uint8Array;
    decode(buffer: Uint8Array): unknown;
};
export default _default;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tiny_msgpack_1 = require("tiny-msgpack");
const codec = new tiny_msgpack_1.Codec().register(1, Error, encodeError, decodeError);
function encodeError(err) {
    return (0, tiny_msgpack_1.encode)(Object.assign({ message: err.message }, err), codec);
}
function decodeError(buffer) {
    const format = buffer[0];
    if ((format & 0xf0) !== 0x80 && format !== 0xde && format !== 0xdf) {
        throw new Error('Invalid Error type received (not a Map)');
    }
    const obj = (0, tiny_msgpack_1.decode)(buffer, codec);
    if (obj.message === undefined) {
        throw new Error('Invalid Error type received (no "message" key)');
    }
    if (typeof obj.message !== 'string') {
        throw new Error('Invalid Error type received (non-string "message")');
    }
    return Object.assign(new Error(obj.message), obj);
}
exports.default = {
    encode(data) {
        return (0, tiny_msgpack_1.encode)(data, codec);
    },
    decode(buffer) {
        return (0, tiny_msgpack_1.decode)(buffer, codec);
    },
};
//# sourceMappingURL=msgpack.js.map{"version":3,"file":"msgpack.js","sourceRoot":"","sources":["../src/msgpack.ts"],"names":[],"mappings":";;AAAA,+CAA2E;AAE3E,MAAM,KAAK,GAAG,IAAI,oBAAK,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;AAEvE,SAAS,WAAW,CAAC,GAAU;IAC9B,OAAO,IAAA,qBAAO,EAAC,MAAM,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,GAAG,CAAC,OAAO,EAAE,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;AACrE,CAAC;AAED,SAAS,WAAW,CAAC,MAAkB;IACtC,MAAM,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACzB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;QACpE,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;IAC5D,CAAC;IAED,MAAM,GAAG,GAAQ,IAAA,qBAAO,EAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IACxC,IAAI,GAAG,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;QAC/B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;IACnE,CAAC;IACD,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;QACrC,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;IACvE,CAAC;IAED,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC;AACnD,CAAC;AAED,kBAAe;IACd,MAAM,CAAC,IAAa;QACnB,OAAO,IAAA,qBAAO,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC7B,CAAC;IACD,MAAM,CAAC,MAAkB;QACxB,OAAO,IAAA,qBAAO,EAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC/B,CAAC;CACD,CAAC"}export { type MessageEvent, type ErrorEvent, type CloseEvent, Connection as UpdatedConnection, } from './connection';
export { default as msgpack } from './msgpack';
export { type RPC, type RPCMethod, rpc } from './rpc';
export { type RPCData, type RPCId, type RPCMessage, messages } from './message';
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.messages = exports.rpc = exports.msgpack = exports.UpdatedConnection = void 0;
var connection_1 = require("./connection");
Object.defineProperty(exports, "UpdatedConnection", { enumerable: true, get: function () { return connection_1.Connection; } });
var msgpack_1 = require("./msgpack");
Object.defineProperty(exports, "msgpack", { enumerable: true, get: function () { return __importDefault(msgpack_1).default; } });
var rpc_1 = require("./rpc");
Object.defineProperty(exports, "rpc", { enumerable: true, get: function () { return rpc_1.rpc; } });
var message_1 = require("./message");
Object.defineProperty(exports, "messages", { enumerable: true, get: function () { return message_1.messages; } });
//# sourceMappingURL=next.js.map{"version":3,"file":"next.js","sourceRoot":"","sources":["../src/next.ts"],"names":[],"mappings":";;;;;;AAAA,2CAKsB;AADrB,+GAAA,UAAU,OAAqB;AAEhC,qCAA+C;AAAtC,mHAAA,OAAO,OAAW;AAC3B,6BAAsD;AAAnB,0FAAA,GAAG,OAAA;AACtC,qCAAgF;AAA5B,mGAAA,QAAQ,OAAA"}export default function parseMessage(buffer: Uint8Array, requests: Map<number, unknown>, proxies: Map<number, unknown>): Message | null;
export type Message = {
    op: 'req';
    id: number;
    method: string;
    data: Record<string, unknown>;
} | {
    op: 'res';
    id: number;
    data: Record<string, unknown>;
} | {
    op: 'res';
    id: number;
    error: Error;
} | {
    op: 'preq';
    pid: number;
    id: number;
    method: string;
    data: unknown[];
} | {
    op: 'pres';
    id: number;
    data: unknown;
} | {
    op: 'pres';
    id: number;
    error: Error;
} | {
    op: 'pevent';
    pid: number;
    event: string;
    data: unknown[];
} | {
    op: 'pclose';
    pid: number;
    error?: Error;
} | {
    op: 'cancel';
    id: number;
} | {
    op: 'hi';
};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const msgpack_1 = __importDefault(require("./msgpack"));
/*
    This parses a serialized Runtime-RPC message, and ensures it is valid.
*/
function parseMessage(buffer, requests, proxies) {
    // Runtime type-check for non-TypeScript applications.
    if (!(buffer instanceof Uint8Array)) {
        throw new TypeError('Expected message to be a Uint8Array');
    }
    let msg;
    try {
        msg = msgpack_1.default.decode(buffer);
    }
    catch (err) {
        throw new Error(`Received invalid MessagePack: ${err.message}`);
    }
    if (!isValidMessage(msg)) {
        throw new Error('Received invalid Runtime-RPC message');
    }
    if (!isRecognizedMessage(msg)) {
        return null;
    }
    // Ensure there are no duplicate IDs sent to the same session.
    if (msg.op === 'req' || msg.op === 'preq') {
        if (requests.has(msg.id)) {
            throw new Error('Received duplicate request ID');
        }
    }
    else if (msg.op === 'res') {
        if ('data' in msg) {
            const pid = msg.data?.remote;
            if (pid !== undefined) {
                if (!Number.isInteger(pid)) {
                    throw new Error('Received non-integer proxy ID');
                }
                if (proxies.has(pid)) {
                    throw new Error('Received duplicate proxy ID');
                }
            }
        }
    }
    return msg;
}
exports.default = parseMessage;
function isValidMessage(msg) {
    if (!isPlainObject(msg))
        return false;
    if (typeof msg.op !== 'string')
        return false;
    switch (msg.op) {
        case 'req':
            if (!Number.isInteger(msg.id))
                return false;
            if (typeof msg.method !== 'string')
                return false;
            if (!isPlainObject(msg.data))
                return false;
            return true;
        case 'res':
            if (!Number.isInteger(msg.id))
                return false;
            if ('data' in msg) {
                if ('error' in msg)
                    return false;
                if (!isPlainObject(msg.data))
                    return false;
            }
            else {
                if (!('error' in msg))
                    return false;
                if (!(msg.error instanceof Error))
                    return false;
            }
            return true;
        case 'preq':
            if (!Number.isInteger(msg.pid))
                return false;
            if (!Number.isInteger(msg.id))
                return false;
            if (typeof msg.method !== 'string')
                return false;
            if (!Array.isArray(msg.data))
                return false;
            return true;
        case 'pres':
            if (!Number.isInteger(msg.id))
                return false;
            if ('data' in msg) {
                if ('error' in msg)
                    return false;
            }
            else {
                if (!('error' in msg))
                    return false;
                if (!(msg.error instanceof Error))
                    return false;
            }
            return true;
        case 'pevent':
            if (!Number.isInteger(msg.pid))
                return false;
            if (typeof msg.event !== 'string')
                return false;
            if (!Array.isArray(msg.data))
                return false;
            return true;
        case 'pclose':
            if (!Number.isInteger(msg.pid))
                return false;
            if ('error' in msg && !(msg.error instanceof Error))
                return false;
            return true;
        case 'cancel':
            if (!Number.isInteger(msg.id))
                return false;
            return true;
        default:
            return true;
    }
}
function isRecognizedMessage(msg) {
    switch (msg.op) {
        case 'req':
        case 'res':
        case 'preq':
        case 'pres':
        case 'pevent':
        case 'pclose':
        case 'cancel':
        case 'hi':
            return true;
        default:
            return false;
    }
}
const plainObjectProto = Object.getPrototypeOf({});
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null)
        return false;
    const proto = Object.getPrototypeOf(value);
    return proto === null || proto === plainObjectProto;
}
//# sourceMappingURL=parse-message.js.map{"version":3,"file":"parse-message.js","sourceRoot":"","sources":["../src/parse-message.ts"],"names":[],"mappings":"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"}import ProxyState from './proxy-state';
import EventEmitter from './event-emitter';
export declare const INTERNAL: unique symbol;
export default class ProxyRemote extends ProxyState {
    private readonly _hooks;
    private readonly _events;
    constructor(internal: Symbol, hooks: ProxyHooks);
    get events(): EventEmitter;
    call<T = any>(method: string, ...data: any[]): Promise<T>;
    toProxy<T extends {}>(unidirectionalMethods?: ReadonlyArray<keyof T>, bidirectionalMethods?: ReadonlyArray<keyof T>): ProxyObject<T>;
    protected _connected(): boolean;
    protected _disconnect(err: Error | undefined): void;
}
export interface ProxyHooks {
    connected(): boolean;
    disconnect(err: Error | undefined): void;
    call<T = any>(method: string, ...data: any[]): Promise<T>;
}
export type ProxyObject<T extends {}> = T & EventEmitter & {
    remote: ProxyRemote;
};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.INTERNAL = void 0;
const proxy_state_1 = __importDefault(require("./proxy-state"));
const event_emitter_1 = __importDefault(require("./event-emitter"));
exports.INTERNAL = Symbol();
/*
    ProxyRemote is used by clients to represent a remote (proxied) object sent
    by the server. The client can use it to access the remote object as long as
    it remains connected. For convenience, it can be converted to an actual
    JavaScript Proxy, which is also an EventEmitter.
*/
class ProxyRemote extends proxy_state_1.default {
    constructor(internal, hooks) {
        if (internal !== exports.INTERNAL) {
            throw new TypeError('Illegal construction');
        }
        super();
        this._hooks = hooks;
        this._events = new event_emitter_1.default();
    }
    get events() {
        return this._events;
    }
    call(method, ...data) {
        return this._hooks.call(method, ...data);
    }
    toProxy(unidirectionalMethods = [], bidirectionalMethods = []) {
        const methods = new Map();
        const methodNames = new Set([
            ...unidirectionalMethods,
            ...bidirectionalMethods,
        ]);
        return new Proxy(Object.freeze({}), {
            get: (_, property) => {
                if (property === 'remote') {
                    return this;
                }
                if (property in this._events) {
                    return this._events[property];
                }
                if (typeof property === 'string' && methodNames.has(property)) {
                    let fn = methods.get(property);
                    if (!fn) {
                        fn = this.call.bind(this, property);
                        if (unidirectionalMethods.includes(property)) {
                            fn = ignoreReturnvalue(fn, this);
                        }
                        methods.set(property, fn);
                    }
                    return fn;
                }
                return undefined;
            },
        });
    }
    _connected() {
        return this._hooks.connected();
    }
    _disconnect(err) {
        this._hooks.disconnect(err);
    }
}
exports.default = ProxyRemote;
// Some proxied methods are more convenient if they are treated like one-way
// events, where there is no return value and we don't care about disconnection.
// This wraps a given function to provide that behavior.
function ignoreReturnvalue(fn, proxy) {
    return (...data) => {
        if (!proxy.connected)
            return;
        fn(...data).catch(() => { });
    };
}
//# sourceMappingURL=proxy-remote.js.map{"version":3,"file":"proxy-remote.js","sourceRoot":"","sources":["../src/proxy-remote.ts"],"names":[],"mappings":";;;;;;AAAA,gEAAuC;AACvC,oEAA2C;AAE9B,QAAA,QAAQ,GAAG,MAAM,EAAE,CAAC;AAEjC;;;;;EAKE;AAEF,MAAqB,WAAY,SAAQ,qBAAU;IAIlD,YAAY,QAAgB,EAAE,KAAiB;QAC9C,IAAI,QAAQ,KAAK,gBAAQ,EAAE,CAAC;YAC3B,MAAM,IAAI,SAAS,CAAC,sBAAsB,CAAC,CAAC;QAC7C,CAAC;QAED,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,OAAO,GAAG,IAAI,uBAAY,EAAE,CAAC;IACnC,CAAC;IAED,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED,IAAI,CAAU,MAAc,EAAE,GAAG,IAAW;QAC3C,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAI,MAAM,EAAE,GAAG,IAAI,CAAC,CAAC;IAC7C,CAAC;IAED,OAAO,CACN,wBAAgD,EAAE,EAClD,uBAA+C,EAAE;QAEjD,MAAM,OAAO,GAAyC,IAAI,GAAG,EAAE,CAAC;QAChE,MAAM,WAAW,GAAiB,IAAI,GAAG,CAAC;YACzC,GAAG,qBAAqB;YACxB,GAAG,oBAAoB;SACvB,CAAC,CAAC;QAEH,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;YACnC,GAAG,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE;gBACpB,IAAI,QAAQ,KAAK,QAAQ,EAAE,CAAC;oBAC3B,OAAO,IAAI,CAAC;gBACb,CAAC;gBACD,IAAI,QAAQ,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;oBAC9B,OAAQ,IAAI,CAAC,OAAe,CAAC,QAAQ,CAAC,CAAC;gBACxC,CAAC;gBACD,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,WAAW,CAAC,GAAG,CAAC,QAAe,CAAC,EAAE,CAAC;oBACtE,IAAI,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBAC/B,IAAI,CAAC,EAAE,EAAE,CAAC;wBACT,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;wBACpC,IAAI,qBAAqB,CAAC,QAAQ,CAAC,QAAe,CAAC,EAAE,CAAC;4BACrD,EAAE,GAAG,iBAAiB,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;wBAClC,CAAC;wBACD,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBAC3B,CAAC;oBACD,OAAO,EAAE,CAAC;gBACX,CAAC;gBACD,OAAO,SAAS,CAAC;YAClB,CAAC;SACD,CAAmB,CAAC;IACtB,CAAC;IAES,UAAU;QACnB,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;IAChC,CAAC;IAES,WAAW,CAAC,GAAsB;QAC3C,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;CACD;AA/DD,8BA+DC;AAED,4EAA4E;AAC5E,gFAAgF;AAChF,wDAAwD;AACxD,SAAS,iBAAiB,CACzB,EAAoC,EACpC,KAAiB;IAEjB,OAAO,CAAC,GAAG,IAAW,EAAE,EAAE;QACzB,IAAI,CAAC,KAAK,CAAC,SAAS;YAAE,OAAO;QAC7B,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;IAC7B,CAAC,CAAC;AACH,CAAC"}import ProxyState from './proxy-state';
export declare const ATTACH: unique symbol;
export default class ProxyResult<T extends {}> extends ProxyState {
    private _hooks;
    private readonly _target;
    constructor(target: T);
    get target(): T;
    protected _connected(): boolean;
    protected _disconnect(err: Error | undefined): void;
    static [ATTACH]<T extends {}>(proxy: ProxyResult<T>, hooks: ProxyHooks): void;
}
export interface ProxyHooks {
    connected(): boolean;
    disconnect(err: Error | undefined): void;
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ATTACH = void 0;
const proxy_state_1 = __importDefault(require("./proxy-state"));
exports.ATTACH = Symbol();
/*
    ProxyResult is used by servers to wrap an arbitrary object and send it to
    the client as a proxy. After being sent, the client can continue to access
    the proxy remotely as long as it remains connected.
*/
class ProxyResult extends proxy_state_1.default {
    constructor(target) {
        if (target == null) {
            throw new TypeError('ProxyResult cannot wrap null or undefined');
        }
        super();
        this._hooks = null;
        this._target = target;
    }
    get target() {
        return this._target;
    }
    _connected() {
        return this._hooks?.connected() ?? false;
    }
    _disconnect(err) {
        this._hooks?.disconnect(err);
    }
    static [exports.ATTACH](proxy, hooks) {
        if (proxy._hooks) {
            throw new TypeError('Cannot send the same ProxyResult twice');
        }
        if (proxy._closed) {
            hooks.disconnect(proxy._error);
        }
        else {
            proxy._hooks = hooks;
        }
    }
}
exports.default = ProxyResult;
//# sourceMappingURL=proxy-result.js.map{"version":3,"file":"proxy-result.js","sourceRoot":"","sources":["../src/proxy-result.ts"],"names":[],"mappings":";;;;;;AAAA,gEAAuC;AAE1B,QAAA,MAAM,GAAG,MAAM,EAAE,CAAC;AAE/B;;;;EAIE;AAEF,MAAqB,WAA0B,SAAQ,qBAAU;IAIhE,YAAY,MAAS;QACpB,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;YACpB,MAAM,IAAI,SAAS,CAAC,2CAA2C,CAAC,CAAC;QAClE,CAAC;QACD,KAAK,EAAE,CAAC;QAPD,WAAM,GAAsB,IAAI,CAAC;QAQxC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACvB,CAAC;IAED,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAES,UAAU;QACnB,OAAO,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,KAAK,CAAC;IAC1C,CAAC;IAES,WAAW,CAAC,GAAsB;QAC3C,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC;IAED,MAAM,CAAC,CAAC,cAAM,CAAC,CAAe,KAAqB,EAAE,KAAiB;QACrE,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;YAClB,MAAM,IAAI,SAAS,CAAC,wCAAwC,CAAC,CAAC;QAC/D,CAAC;QACD,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;YACnB,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAChC,CAAC;aAAM,CAAC;YACP,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC;QACtB,CAAC;IACF,CAAC;CACD;AAlCD,8BAkCC"}export default abstract class ProxyState {
    private readonly _cleanupCallbacks;
    protected _closed: boolean;
    protected _error: Error | undefined;
    protected abstract _connected(): boolean;
    protected abstract _disconnect(err: Error | undefined): void;
    onCleanup(fn: (err?: Error | undefined) => void): void;
    offCleanup(fn: (err?: Error | undefined) => void): void;
    disconnect(err?: Error | undefined): void;
    get connected(): boolean;
}
"use strict";
/*
    ProxyState is the interface used by both clients and servers to inspect
    whether a "proxy object" is connected, to disconnect the proxy object when
    desired, and to register callbacks for when the proxy object disconnects.
*/
Object.defineProperty(exports, "__esModule", { value: true });
class ProxyState {
    constructor() {
        this._cleanupCallbacks = [];
        this._closed = false;
        this._error = undefined;
    }
    onCleanup(fn) {
        if (!this._closed) {
            this._cleanupCallbacks.push(fn);
        }
        else {
            Promise.resolve(this._error).then(fn);
        }
    }
    offCleanup(fn) {
        const arr = this._cleanupCallbacks;
        for (let i = 0; i < arr.length; ++i) {
            if (arr[i] === fn) {
                arr.splice(i, 1);
                break;
            }
        }
    }
    disconnect(err) {
        if (!this._closed) {
            this._closed = true;
            this._error = err;
            this._disconnect(err);
            while (this._cleanupCallbacks.length) {
                // Handle cleanup callbacks in their own event loop ticks.
                Promise.resolve(err).then(this._cleanupCallbacks.shift());
            }
        }
    }
    get connected() {
        return !this._closed && this._connected();
    }
}
exports.default = ProxyState;
//# sourceMappingURL=proxy-state.js.map{"version":3,"file":"proxy-state.js","sourceRoot":"","sources":["../src/proxy-state.ts"],"names":[],"mappings":";AAAA;;;;EAIE;;AAEF,MAA8B,UAAU;IAAxC;QACkB,sBAAiB,GAAyC,EAAE,CAAC;QACpE,YAAO,GAAY,KAAK,CAAC;QACzB,WAAM,GAAsB,SAAS,CAAC;IAsCjD,CAAC;IAlCA,SAAS,CAAC,EAAqC;QAC9C,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACjC,CAAC;aAAM,CAAC;YACP,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACvC,CAAC;IACF,CAAC;IAED,UAAU,CAAC,EAAqC;QAC/C,MAAM,GAAG,GAAG,IAAI,CAAC,iBAAiB,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;YACrC,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC;gBACnB,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACjB,MAAM;YACP,CAAC;QACF,CAAC;IACF,CAAC;IAED,UAAU,CAAC,GAAuB;QACjC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;YAClB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YAEtB,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC;gBACtC,0DAA0D;gBAC1D,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC,CAAC;YAC3D,CAAC;QACF,CAAC;IACF,CAAC;IAED,IAAI,SAAS;QACZ,OAAO,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;IAC3C,CAAC;CACD;AAzCD,6BAyCC"}/// <reference lib="dom" />
import { Connection } from './connection';
import { RPCData, RPCId } from './message';
export type RPC<API = Record<string, RPCCall>> = API & {
    $client: Client;
};
export type RPCCall = (data?: RPCData, options?: {
    signal?: AbortSignal;
}) => Promise<RPCData | undefined>;
export type RPCMethod = (data: RPCData | null | undefined, options: {
    signal: AbortSignal;
}) => undefined | null | RPCData | PromiseLike<undefined | null | RPCData>;
/**
 * Create an RPC proxy interface with the given connection
 *
 * @example
 * ```ts
 * import { rpc } from '...';
 *
 * interface API {
 *   sayHello(data: { name: string }): Promise<{ greeting: string }>;
 * }
 *
 * const connection = ...
 * const api = rpc<API>(connection);
 *
 * const { greeting } = await api.sayHello({ name: '...' });
 * ```
 * @param {Connection} connection
 */
export declare function rpc<RemoteAPI = Record<string, RPCCall>>(connection: Connection): RPC<RemoteAPI>;
export declare class Client {
    #private;
    readonly connection: Connection;
    constructor(connection: Connection);
    call(method: string, data: RPCData | undefined, options?: {
        signal?: AbortSignal;
    }): Promise<RPCData | null | undefined>;
    cancel(id: RPCId, reason: Error): void;
}
export declare class Server {
    #private;
    readonly connection: Connection;
    readonly methods: Record<string, RPCMethod>;
    constructor(connection: Connection, methods: Record<string, RPCMethod>);
    call(id: RPCId, method: string, data?: RPCData | null): void;
    cancel(id: RPCId): void;
    close(): void;
}
"use strict";
/// <Reference lib="DOM" />
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Client_calls, _Client_incrementor, _Server_calls;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = exports.Client = exports.rpc = void 0;
const incrementor_1 = __importDefault(require("./incrementor"));
const message_1 = require("./message");
/**
 * Create an RPC proxy interface with the given connection
 *
 * @example
 * ```ts
 * import { rpc } from '...';
 *
 * interface API {
 *   sayHello(data: { name: string }): Promise<{ greeting: string }>;
 * }
 *
 * const connection = ...
 * const api = rpc<API>(connection);
 *
 * const { greeting } = await api.sayHello({ name: '...' });
 * ```
 * @param {Connection} connection
 */
function rpc(connection) {
    const client = new Client(connection);
    return new Proxy(client, {
        get(target, property) {
            if (property === '$client') {
                return client;
            }
            return (data, options) => {
                return target.call(String(property), data, options);
            };
        },
    });
}
exports.rpc = rpc;
class Client {
    constructor(connection) {
        this.connection = connection;
        _Client_calls.set(this, new Map());
        _Client_incrementor.set(this, new incrementor_1.default());
        connection.on('message', ({ detail: message }) => {
            if (message.op === 'res') {
                const remote = __classPrivateFieldGet(this, _Client_calls, "f").get(message.id);
                if (!remote)
                    return;
                __classPrivateFieldGet(this, _Client_calls, "f").delete(message.id);
                remote.cleanup();
                if ('error' in message) {
                    remote.reject(message.error);
                }
                else {
                    remote.resolve(message.data);
                }
            }
        });
        connection.on('close', () => {
            for (const id of __classPrivateFieldGet(this, _Client_calls, "f").keys()) {
                this.cancel(id, new Error('Connection closed'));
            }
        });
    }
    async call(method, data, options = {}) {
        const { signal } = options;
        return new Promise((resolve, reject) => {
            signal?.throwIfAborted();
            const id = __classPrivateFieldGet(this, _Client_incrementor, "f").next();
            const request = message_1.messages.request(id, method, data);
            const abort = () => {
                this.cancel(id, signal.reason);
                this.connection.send(message_1.messages.cancel(id));
            };
            signal?.addEventListener('abort', abort);
            const cleanup = () => {
                signal?.removeEventListener('abort', abort);
            };
            __classPrivateFieldGet(this, _Client_calls, "f").set(id, { resolve, reject, cleanup });
            this.connection.send(request);
        });
    }
    cancel(id, reason) {
        const call = __classPrivateFieldGet(this, _Client_calls, "f").get(id);
        if (!call)
            return;
        __classPrivateFieldGet(this, _Client_calls, "f").delete(id);
        call.cleanup();
        call.reject(reason);
    }
}
exports.Client = Client;
_Client_calls = new WeakMap(), _Client_incrementor = new WeakMap();
class Server {
    constructor(connection, methods) {
        this.connection = connection;
        this.methods = methods;
        _Server_calls.set(this, new Map());
        connection.on('message', ({ detail: message }) => {
            if (message.op === 'req') {
                const { id, method, data } = message;
                this.call(id, method, data);
            }
            else if (message.op === 'cancel') {
                __classPrivateFieldGet(this, _Server_calls, "f").get(message.id)?.controller.abort();
            }
        });
        connection.on('close', () => {
            for (const id of __classPrivateFieldGet(this, _Server_calls, "f").keys()) {
                this.cancel(id);
            }
        });
    }
    call(id, method, data) {
        if (__classPrivateFieldGet(this, _Server_calls, "f").has(id)) {
            // TODO send error message about re-used id
            return;
        }
        if (!(method in this.methods)) {
            this.connection.send(message_1.messages.failure(id, new Error(`Unknown method "${method}"`)));
            return;
        }
        const controller = new AbortController();
        __classPrivateFieldGet(this, _Server_calls, "f").set(id, { controller });
        (async () => {
            const result = await this.methods[method](data, {
                signal: controller.signal,
            });
            // The only cases where a method has been aborted are cancellation
            // from the connection closing (error or close).
            //
            // Rely on other side to cancel requests on close
            // (can't send failure messages anyways, the connection is closed)
            if (!controller.signal.aborted) {
                this.connection.send(message_1.messages.success(id, result));
            }
        })()
            .catch((error) => {
            if (!controller.signal.aborted) {
                this.connection.send(message_1.messages.failure(id, error));
            }
        })
            .finally(() => {
            __classPrivateFieldGet(this, _Server_calls, "f").delete(id);
        });
    }
    cancel(id) {
        const call = __classPrivateFieldGet(this, _Server_calls, "f").get(id);
        if (!call)
            return;
        __classPrivateFieldGet(this, _Server_calls, "f").delete(id);
        call.controller.abort();
    }
    close() {
        this.connection.close();
    }
}
exports.Server = Server;
_Server_calls = new WeakMap();
//# sourceMappingURL=rpc.js.map{"version":3,"file":"rpc.js","sourceRoot":"","sources":["../src/rpc.ts"],"names":[],"mappings":";AAAA,2BAA2B;;;;;;;;;;;;AAE3B,gEAAwC;AAExC,uCAAqD;AAgBrD;;;;;;;;;;;;;;;;;GAiBG;AACH,SAAgB,GAAG,CAClB,UAAsB;IAEtB,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC;IAEtC,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE;QACxB,GAAG,CAAC,MAAM,EAAE,QAAQ;YACnB,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;gBAC5B,OAAO,MAAM,CAAC;YACf,CAAC;YAED,OAAO,CAAC,IAAa,EAAE,OAAkC,EAAE,EAAE;gBAC5D,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;YACrD,CAAC,CAAC;QACH,CAAC;KACD,CAA8B,CAAC;AACjC,CAAC;AAhBD,kBAgBC;AAKD,MAAa,MAAM;IAWlB,YAAqB,UAAsB;QAAtB,eAAU,GAAV,UAAU,CAAY;QAV3C,wBAAS,IAAI,GAAG,EAOb,EAAC;QACJ,8BAAe,IAAI,qBAAW,EAAE,EAAC;QAGhC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE;YAChD,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK,EAAE,CAAC;gBAC1B,MAAM,MAAM,GAAG,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;gBAC3C,IAAI,CAAC,MAAM;oBAAE,OAAO;gBAEpB,uBAAA,IAAI,qBAAO,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;gBAC/B,MAAM,CAAC,OAAO,EAAE,CAAC;gBACjB,IAAI,OAAO,IAAI,OAAO,EAAE,CAAC;oBACxB,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBAC9B,CAAC;qBAAM,CAAC;oBACP,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAC9B,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;YAC3B,KAAK,MAAM,EAAE,IAAI,uBAAA,IAAI,qBAAO,CAAC,IAAI,EAAE,EAAE,CAAC;gBACrC,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC,CAAC;YACjD,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,IAAI,CACT,MAAc,EACd,IAAyB,EACzB,UAAoC,EAAE;QAEtC,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAE3B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACtC,MAAM,EAAE,cAAc,EAAE,CAAC;YAEzB,MAAM,EAAE,GAAG,uBAAA,IAAI,2BAAa,CAAC,IAAI,EAAE,CAAC;YACpC,MAAM,OAAO,GAAG,kBAAQ,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YAEnD,MAAM,KAAK,GAAG,GAAG,EAAE;gBAClB,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,MAAO,CAAC,MAAM,CAAC,CAAC;gBAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,kBAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3C,CAAC,CAAC;YAEF,MAAM,EAAE,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;YACzC,MAAM,OAAO,GAAG,GAAG,EAAE;gBACpB,MAAM,EAAE,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;YAC7C,CAAC,CAAC;YAEF,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAAC;YAElD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,EAAS,EAAE,MAAa;QAC9B,MAAM,IAAI,GAAG,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACjC,IAAI,CAAC,IAAI;YAAE,OAAO;QAElB,uBAAA,IAAI,qBAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QACvB,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACrB,CAAC;CACD;AAvED,wBAuEC;;AAED,MAAa,MAAM;IAGlB,YACU,UAAsB,EACtB,OAAkC;QADlC,eAAU,GAAV,UAAU,CAAY;QACtB,YAAO,GAAP,OAAO,CAA2B;QAJ5C,wBAAS,IAAI,GAAG,EAA0C,EAAC;QAM1D,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE;YAChD,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK,EAAE,CAAC;gBAC1B,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;gBACrC,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YAC7B,CAAC;iBAAM,IAAI,OAAO,CAAC,EAAE,KAAK,QAAQ,EAAE,CAAC;gBACpC,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,KAAK,EAAE,CAAC;YACjD,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;YAC3B,KAAK,MAAM,EAAE,IAAI,uBAAA,IAAI,qBAAO,CAAC,IAAI,EAAE,EAAE,CAAC;gBACrC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACjB,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,EAAS,EAAE,MAAc,EAAE,IAAqB;QACpD,IAAI,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;YACzB,2CAA2C;YAC3C,OAAO;QACR,CAAC;QAED,IAAI,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;YAC/B,IAAI,CAAC,UAAU,CAAC,IAAI,CACnB,kBAAQ,CAAC,OAAO,CAAC,EAAE,EAAE,IAAI,KAAK,CAAC,mBAAmB,MAAM,GAAG,CAAC,CAAC,CAC7D,CAAC;YACF,OAAO;QACR,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,eAAe,EAAE,CAAC;QACzC,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;QAEpC,CAAC,KAAK,IAAI,EAAE;YACX,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE;gBAC/C,MAAM,EAAE,UAAU,CAAC,MAAM;aACzB,CAAC,CAAC;YAEH,kEAAkE;YAClE,gDAAgD;YAChD,EAAE;YACF,iDAAiD;YACjD,kEAAkE;YAClE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;gBAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,kBAAQ,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC;YACpD,CAAC;QACF,CAAC,CAAC,EAAE;aACF,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YAChB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;gBAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,kBAAQ,CAAC,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;YACnD,CAAC;QACF,CAAC,CAAC;aACD,OAAO,CAAC,GAAG,EAAE;YACb,uBAAA,IAAI,qBAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QACxB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,MAAM,CAAC,EAAS;QACf,MAAM,IAAI,GAAG,uBAAA,IAAI,qBAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACjC,IAAI,CAAC,IAAI;YAAE,OAAO;QAElB,uBAAA,IAAI,qBAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;IAED,KAAK;QACJ,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;CACD;AA1ED,wBA0EC"}"use strict";
//# sourceMappingURL=server.js.map{"version":3,"file":"server.js","sourceRoot":"","sources":["../src/server.ts"],"names":[],"mappings":""}export default class Timer {
    private readonly duration;
    private readonly callback;
    private timer;
    constructor(duration: number, callback: () => void);
    reset(): void;
    stop(): void;
}
"use strict";
/*
    A simple timer that can be conveniently reset or stopped.
    In Node.js, the timer will not prevent the process from exiting.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class Timer {
    constructor(duration, callback) {
        this.duration = duration;
        this.callback = callback;
        if (duration === 0)
            return;
        this.timer = setTimeout(callback, duration);
        unref(this.timer);
    }
    reset() {
        clearTimeout(this.timer);
        if (this.duration === 0)
            return;
        this.timer = setTimeout(this.callback, this.duration);
        unref(this.timer);
    }
    stop() {
        clearTimeout(this.timer);
    }
}
exports.default = Timer;
function unref(timer) {
    if (typeof timer?.unref === 'function') {
        timer.unref();
    }
}
//# sourceMappingURL=timer.js.map{"version":3,"file":"timer.js","sourceRoot":"","sources":["../src/timer.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAEH,MAAqB,KAAK;IAGzB,YACkB,QAAgB,EAChB,QAAoB;QADpB,aAAQ,GAAR,QAAQ,CAAQ;QAChB,aAAQ,GAAR,QAAQ,CAAY;QAErC,IAAI,QAAQ,KAAK,CAAC;YAAE,OAAO;QAE3B,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC5C,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACnB,CAAC;IAED,KAAK;QACJ,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEzB,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC;YAAE,OAAO;QAEhC,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtD,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACnB,CAAC;IAED,IAAI;QACH,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;CACD;AAzBD,wBAyBC;AAED,SAAS,KAAK,CAAC,KAAU;IACxB,IAAI,OAAO,KAAK,EAAE,KAAK,KAAK,UAAU,EAAE,CAAC;QACxC,KAAK,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;AACF,CAAC"}export type CloseReason = 'NORMAL' | 'TIMEOUT' | 'PROTOCOL_VIOLATION';
export type SessionData = Record<string | symbol | number, any>;
export interface Initializer {
    (controller: Controller): Connection | Promise<Connection>;
}
export interface Controller {
    receive(message: Uint8Array): void;
    destroy(err?: Error | null | undefined): void;
}
export interface Connection {
    send(message: Uint8Array): void;
    close(reason: CloseReason): void;
    isOpen(): boolean;
    onActive?(): void;
    onIdle?(): void;
}
export interface MethodHandler<T extends Record<string, any> = Record<string, any>> {
    (data: T, ctx: MethodContext): void | Record<string, any> | Promise<void | Record<string, any>>;
}
export interface MethodContext {
    signal: AbortSignal;
    session: SessionData;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":""}{
  "name": "@postman/runtime.runtime-rpc",
  "version": "0.2.0",
  "license": "UNLICENSED",
  "description": "A generic (transport-agnostic) implementation of the Runtime-RPC protocol",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/rpc/runtime-rpc#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "tiny-msgpack": "^2.2.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# runtime-rpc

This package contains a generic (transport-agnostic) implementation of the Runtime-RPC protocol. The Runtime-RPC protocol is used to connect clients with remote runtime servers.

The novel feature of Runtime-RPC is that you can send an arbitrary object from the server to the client, and then the client can actually invoke methods on that object (which execute on the server, asynchronously), as well as receive events that are emitted on the object. In other words, you can model objects within any programming language and then operate them remotely, from a completely unrelated programming enrivonment. Runtime-RPC is specifically designed to efficiently handle event-based architecture (which also enables efficient streaming), and thus this implementation provides built-in support for modelling a Node.js-style [EventEmitter](https://nodejs.org/api/events.html#class-eventemitter).

A complete specification for the Runtime-RPC protocol can be found [here](./docs/spec.md). Note that you don't really need to read the specification unless you plan on creating your own implementation of the protocol (perhaps in different programming language), which this package already provides.

## Usage

Runtime-RPC is a transport-agnostic protocol, and this package does not contain integration with any specific transport layer. In order to use Runtime-RPC in your application, you need to use a wrapper around this package for a specific transport layer of your choosing (e.g., WebSockets, IPC, etc.).

**This package requires a JavaScript environment that supports [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal), which includes Node.js v16.x.x or later, or any modern browser.**
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	}
}
import { FromSchema } from 'json-schema-to-ts';
import { Extension } from '@postman/runtime.core';
export interface PluginConfiguration {
}
declare const definition: {
    name: "schema";
    summary: "An associated schema";
    schema: {
        readonly type: "object";
        readonly oneOf: [{
            readonly required: ["source"];
            readonly properties: {
                readonly source: {
                    readonly type: "string";
                    readonly const: "none";
                };
            };
            readonly additionalProperties: false;
        }, {
            readonly required: ["source"];
            readonly properties: {
                readonly source: {
                    readonly type: "string";
                    readonly const: "auto";
                };
            };
            readonly additionalProperties: false;
        }, {
            readonly required: ["source", "apiId", "versionId"];
            readonly properties: {
                readonly source: {
                    readonly type: "string";
                    readonly const: "api";
                };
                readonly apiId: {
                    readonly type: "string";
                };
                readonly versionId: {
                    readonly type: "string";
                };
                readonly releaseId: {
                    readonly type: "string";
                };
            };
            readonly additionalProperties: false;
        }];
    };
};
declare namespace Schema {
    type Name = typeof definition.name;
    type Data = FromSchema<typeof definition.schema>;
    type Config = PluginConfiguration;
    const use: () => Extension.Specific<"schema", {
        source: "none";
    } | {
        source: "auto";
    } | {
        releaseId?: string | undefined;
        source: "api";
        apiId: string;
        versionId: string;
    }, PluginConfiguration>;
}
type Schema = Extension.Specific<Schema.Name, Schema.Data, Schema.Config>;
export default Schema;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'schema',
    summary: 'An associated schema',
    schema: {
        type: 'object',
        oneOf: [
            {
                required: ['source'],
                properties: {
                    source: {
                        type: 'string',
                        const: 'none',
                    },
                },
                additionalProperties: false,
            },
            {
                required: ['source'],
                properties: {
                    source: {
                        type: 'string',
                        const: 'auto',
                    },
                },
                additionalProperties: false,
            },
            {
                required: ['source', 'apiId', 'versionId'],
                properties: {
                    source: {
                        type: 'string',
                        const: 'api',
                    },
                    apiId: {
                        type: 'string',
                    },
                    versionId: {
                        type: 'string',
                    },
                    releaseId: {
                        type: 'string',
                    },
                },
                additionalProperties: false,
            },
        ],
    },
});
var Schema;
(function (Schema) {
    Schema.use = runtime_core_1.Extension.define(definition);
})(Schema || (Schema = {}));
exports.default = Schema;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAAA,yDAAoE;AACpE,wDAAkD;AAIlD,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,QAAQ;IACd,OAAO,EAAE,sBAAsB;IAC/B,MAAM,EAAE;QACP,IAAI,EAAE,QAAQ;QACd,KAAK,EAAE;YACN;gBACC,QAAQ,EAAE,CAAC,QAAQ,CAAC;gBACpB,UAAU,EAAE;oBACX,MAAM,EAAE;wBACP,IAAI,EAAE,QAAQ;wBACd,KAAK,EAAE,MAAM;qBACb;iBACD;gBACD,oBAAoB,EAAE,KAAK;aAC3B;YACD;gBACC,QAAQ,EAAE,CAAC,QAAQ,CAAC;gBACpB,UAAU,EAAE;oBACX,MAAM,EAAE;wBACP,IAAI,EAAE,QAAQ;wBACd,KAAK,EAAE,MAAM;qBACb;iBACD;gBACD,oBAAoB,EAAE,KAAK;aAC3B;YACD;gBACC,QAAQ,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,WAAW,CAAC;gBAC1C,UAAU,EAAE;oBACX,MAAM,EAAE;wBACP,IAAI,EAAE,QAAQ;wBACd,KAAK,EAAE,KAAK;qBACZ;oBACD,KAAK,EAAE;wBACN,IAAI,EAAE,QAAQ;qBACd;oBACD,SAAS,EAAE;wBACV,IAAI,EAAE,QAAQ;qBACd;oBACD,SAAS,EAAE;wBACV,IAAI,EAAE,QAAQ;qBACd;iBACD;gBACD,oBAAoB,EAAE,KAAK;aAC3B;SACD;KAC6B;CAC/B,CAAC,CAAC;AAEH,IAAU,MAAM,CAKf;AALD,WAAU,MAAM;IAIF,UAAG,GAAG,wBAAS,CAAC,MAAM,CAAqB,UAAU,CAAC,CAAC;AACrE,CAAC,EALS,MAAM,KAAN,MAAM,QAKf;AAGD,kBAAe,MAAM,CAAC"}{
  "name": "@postman/runtime.schema",
  "version": "0.1.13",
  "license": "UNLICENSED",
  "description": "The Postman ItemType extension: 'schema'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/extensions/schema#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "json-schema-to-ts": "~2.7.2"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Extension: `schema`

This package defines the Postman ItemType extension: `schema`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [{ "path": "../../core/core" }]
}
/// <reference types="node" />
/// <reference types="node" />
import { Agent } from 'http';
declare const HTTPAgent_base: {
    new (...args: any[]): {
        createConnection(...args: any): any;
        on(event: "request-meta", listener: (request: import("../connection-events").HTTPRequest) => void): any;
        on(event: "response-meta", listener: (response: import("../connection-events").HTTPResponse) => void): any;
        emit(event: "request-meta", payload: import("../connection-events").HTTPRequest): boolean;
        emit(event: "response-meta", payload: import("../connection-events").HTTPResponse): boolean;
        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        once(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        off(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol | undefined): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol, listener?: Function | undefined): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        eventNames(): (string | symbol)[];
    };
} & typeof Agent;
export declare class HTTPAgent extends HTTPAgent_base {
}
export {};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPAgent = void 0;
const http_1 = require("http");
const RequestResponseEmitterMixin_1 = __importDefault(require("./RequestResponseEmitterMixin"));
class HTTPAgent extends (0, RequestResponseEmitterMixin_1.default)(http_1.Agent) {
}
exports.HTTPAgent = HTTPAgent;
//# sourceMappingURL=HTTPAgent.js.map{"version":3,"file":"HTTPAgent.js","sourceRoot":"","sources":["../../src/agents/HTTPAgent.ts"],"names":[],"mappings":";;;;;;AAAA,+BAA6B;AAC7B,gGAAwE;AAExE,MAAa,SAAU,SAAQ,IAAA,qCAA2B,EAAC,YAAK,CAAC;CAAG;AAApE,8BAAoE"}/// <reference types="node" />
/// <reference types="node" />
import { Agent } from 'https';
declare const HTTPSAgent_base: {
    new (...args: any[]): {
        createConnection(...args: any): any;
        on(event: "request-meta", listener: (request: import("../connection-events").HTTPRequest) => void): any;
        on(event: "response-meta", listener: (response: import("../connection-events").HTTPResponse) => void): any;
        emit(event: "request-meta", payload: import("../connection-events").HTTPRequest): boolean;
        emit(event: "response-meta", payload: import("../connection-events").HTTPResponse): boolean;
        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        once(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        off(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol | undefined): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol, listener?: Function | undefined): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        eventNames(): (string | symbol)[];
    };
} & typeof Agent;
export declare class HTTPSAgent extends HTTPSAgent_base {
}
export {};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPSAgent = void 0;
const https_1 = require("https");
const RequestResponseEmitterMixin_1 = __importDefault(require("./RequestResponseEmitterMixin"));
class HTTPSAgent extends (0, RequestResponseEmitterMixin_1.default)(https_1.Agent) {
}
exports.HTTPSAgent = HTTPSAgent;
//# sourceMappingURL=HTTPSAgent.js.map{"version":3,"file":"HTTPSAgent.js","sourceRoot":"","sources":["../../src/agents/HTTPSAgent.ts"],"names":[],"mappings":";;;;;;AAAA,iCAA8B;AAC9B,gGAAwE;AAExE,MAAa,UAAW,SAAQ,IAAA,qCAA2B,EAAC,aAAK,CAAC;CAAG;AAArE,gCAAqE"}/// <reference types="node" />
import { EventEmitter } from 'node:events';
import { HTTPRequest, HTTPResponse } from '../connection-events';
type Constructor<T> = new (...args: any[]) => T;
interface MixinClass extends EventEmitter {
    on(event: 'request-meta', listener: (request: HTTPRequest) => void): this;
    emit(event: 'request-meta', payload: HTTPRequest): boolean;
    on(event: 'response-meta', listener: (response: HTTPResponse) => void): this;
    emit(event: 'response-meta', payload: HTTPResponse): boolean;
}
export default function RequestResponseEmitterMixin<T extends Constructor<MixinClass>>(Superclass: T): {
    new (...args: any[]): {
        createConnection(...args: any): any;
        on(event: "request-meta", listener: (request: HTTPRequest) => void): any;
        on(event: "response-meta", listener: (response: HTTPResponse) => void): any;
        emit(event: "request-meta", payload: HTTPRequest): boolean;
        emit(event: "response-meta", payload: HTTPResponse): boolean;
        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        once(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        off(eventName: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol | undefined): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol, listener?: Function | undefined): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): any;
        eventNames(): (string | symbol)[];
    };
} & T;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
function RequestResponseEmitterMixin(Superclass) {
    return class extends Superclass {
        createConnection(...args) {
            // @ts-ignore Ignore the error caused due to ill-defined types for agents
            const socket = super.createConnection(...args);
            socket.on('lookup', () => {
                const req = socket._httpMessage;
                const request = {
                    method: req.method,
                    href: `${req.agent.protocol}//${req.host}${req.path}`,
                    headers: Object.entries(JSON.parse(JSON.stringify(req.getHeaders()))).map(([key, value]) => ({ key, value: value.toString() })),
                    httpVersion: '1.1',
                };
                this.emit('request-meta', request);
            });
            socket.once('data', (chunk) => {
                const res = chunk.toString(), [_, httpVersion, statusCode, statusMessage = ''] = /^HTTP\/(\d.\d) (\d{3})( .*)?/.exec(res) || [];
                if (statusCode) {
                    const response = {
                        statusCode: parseInt(statusCode),
                        statusMessage: statusMessage.substring(1),
                        headers: (0, utils_1.parseHeaders)(res),
                        httpVersion: httpVersion,
                    };
                    this.emit('response-meta', response);
                }
            });
            return socket;
        }
    };
}
exports.default = RequestResponseEmitterMixin;
//# sourceMappingURL=RequestResponseEmitterMixin.js.map{"version":3,"file":"RequestResponseEmitterMixin.js","sourceRoot":"","sources":["../../src/agents/RequestResponseEmitterMixin.ts"],"names":[],"mappings":";;AACA,oCAAwC;AAaxC,SAAwB,2BAA2B,CAEjD,UAAa;IACd,OAAO,KAAM,SAAQ,UAAU;QAC9B,gBAAgB,CAAC,GAAG,IAAS;YAC5B,yEAAyE;YACzE,MAAM,MAAM,GAAG,KAAK,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC,CAAC;YAC/C,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE;gBACxB,MAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC;gBAEhC,MAAM,OAAO,GAAgB;oBAC5B,MAAM,EAAE,GAAG,CAAC,MAAM;oBAClB,IAAI,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,EAAE;oBACrD,OAAO,EAAE,MAAM,CAAC,OAAO,CACtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAG1C,CACD,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBAC3D,WAAW,EAAE,KAAK;iBAClB,CAAC;gBACF,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;YACpC,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,KAAa,EAAE,EAAE;gBACrC,MAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,EAAE,EAC3B,CAAC,CAAC,EAAE,WAAW,EAAE,UAAU,EAAE,aAAa,GAAG,EAAE,CAAC,GAC/C,8BAA8B,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;gBAEjD,IAAI,UAAU,EAAE,CAAC;oBAChB,MAAM,QAAQ,GAAiB;wBAC9B,UAAU,EAAE,QAAQ,CAAC,UAAU,CAAC;wBAChC,aAAa,EAAE,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC;wBACzC,OAAO,EAAE,IAAA,oBAAY,EAAC,GAAG,CAAC;wBAC1B,WAAW,EAAE,WAAW;qBACxB,CAAC;oBACF,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;gBACtC,CAAC;YACF,CAAC,CAAC,CAAC;YACH,OAAO,MAAM,CAAC;QACf,CAAC;KACD,CAAC;AACH,CAAC;AAzCD,8CAyCC"}export interface HTTPRequest {
    method: 'GET' | 'CONNECT';
    href: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface HTTPResponse {
    statusCode: number;
    statusMessage: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface ConnectionEndEvent {
    reason?: string;
    aborted: boolean;
}
export interface ErrorEvent {
    error: {
        message: string;
    };
    handshakeRequest?: HTTPRequest;
    handshakeResponse?: HTTPResponse;
}
export interface MessageEvent {
    messages: Array<{
        arg: string;
        argType: 'string' | 'object';
    } | {
        arg: Uint8Array;
        argType: 'binary';
    }>;
    eventName: string;
}
export interface OpenEvent {
    request?: HTTPRequest;
    response?: HTTPResponse;
}
export interface ReconnectEvent {
    attempt: number;
    timeout: number;
}
export interface CloseEvent {
    reason: string;
}
export interface SubscribeEvent {
    event: string;
}
export interface UnsubscribeEvent {
    event: string;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=connection-events.js.map{"version":3,"file":"connection-events.js","sourceRoot":"","sources":["../src/connection-events.ts"],"names":[],"mappings":""}/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import type tls from 'tls';
import { type Socket } from 'socket.io-client-v4';
import * as EventTypes from './connection-events';
export interface ClientOptions {
    url: string | URL;
    clientVersion: '2' | '3' | '4';
    tlsOptions?: TLSOptions;
    headers?: Record<string, string>;
    connectOptions?: {
        handshakeTimeout?: number;
        handshakePath?: string;
    };
    reconnectOptions?: {
        retryCount?: number;
        retryDelay?: number;
    };
}
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: tls.SecureContext | tls.SecureContextOptions;
}
type WithDeepRequired<T, K extends keyof T> = T & {
    [P in K]-?: Required<T[P]>;
};
export declare class Connection extends EventEmitter {
    protected url: URL;
    protected connectionOptions: WithDeepRequired<ClientOptions, 'reconnectOptions'>;
    private reconnectCount;
    private isConnectionAborted;
    protected client: Socket;
    private request?;
    private response?;
    private subscriptions;
    private reconnectTimeoutHandle?;
    constructor(connectionOptions: ClientOptions);
    private createClient;
    private open;
    private createRequestAgent;
    private reconnect;
    private messageHandlerFactory;
    publish(event: string, messages: Array<unknown>, opts?: {
        acknowledgement: boolean;
    }): void;
    subscribe(event: string): void;
    unsubscribe(event: string): void;
    disconnect(): void;
    private onConnectHandler;
    private onDisconnectHandler;
    private onErrorHandler;
}
export interface Connection {
    emit(event: 'error', payload: EventTypes.ErrorEvent): boolean;
    on(event: 'error', listener: (this: Connection, arg: EventTypes.ErrorEvent) => void): this;
    addListener(event: 'error', listener: (this: Connection, arg: EventTypes.ErrorEvent) => void): this;
    once(event: 'error', listener: (this: Connection, arg: EventTypes.ErrorEvent) => void): this;
    emit(event: 'end', payload: EventTypes.ConnectionEndEvent): boolean;
    on(event: 'end', listener: (this: Connection, arg: EventTypes.ConnectionEndEvent) => void): this;
    addListener(event: 'end', listener: (this: Connection, arg: EventTypes.ConnectionEndEvent) => void): this;
    once(event: 'end', listener: (this: Connection, arg: EventTypes.ConnectionEndEvent) => void): this;
    emit(event: 'open', payload: EventTypes.OpenEvent): boolean;
    on(event: 'open', listener: (this: Connection, arg: EventTypes.OpenEvent) => void): this;
    addListener(event: 'open', listener: (this: Connection, arg: EventTypes.OpenEvent) => void): this;
    once(event: 'open', listener: (this: Connection, arg: EventTypes.OpenEvent) => void): this;
    emit(event: 'close', payload: EventTypes.CloseEvent): boolean;
    on(event: 'close', listener: (this: Connection, arg: EventTypes.CloseEvent) => void): this;
    addListener(event: 'close', listener: (this: Connection, arg: EventTypes.CloseEvent) => void): this;
    once(event: 'close', listener: (this: Connection, arg: EventTypes.CloseEvent) => void): this;
    emit(event: 'message', payload: EventTypes.MessageEvent): boolean;
    on(event: 'message', listener: (this: Connection, arg: EventTypes.MessageEvent) => void): this;
    addListener(event: 'message', listener: (this: Connection, arg: EventTypes.MessageEvent) => void): this;
    once(event: 'message', listener: (this: Connection, arg: EventTypes.MessageEvent) => void): this;
    emit(event: 'reconnect', payload: EventTypes.ReconnectEvent): boolean;
    on(event: 'reconnect', listener: (this: Connection, arg: EventTypes.ReconnectEvent) => void): this;
    addListener(event: 'reconnect', listener: (this: Connection, arg: EventTypes.ReconnectEvent) => void): this;
    once(event: 'reconnect', listener: (this: Connection, arg: EventTypes.ReconnectEvent) => void): this;
    emit(event: 'subscribed', payload: EventTypes.SubscribeEvent): boolean;
    on(event: 'subscribed', listener: (this: Connection, arg: EventTypes.SubscribeEvent) => void): this;
    addListener(event: 'subscribed', listener: (this: Connection, arg: EventTypes.SubscribeEvent) => void): this;
    once(event: 'subscribed', listener: (this: Connection, arg: EventTypes.SubscribeEvent) => void): this;
    emit(event: 'unsubscribed', payload: EventTypes.UnsubscribeEvent): boolean;
    on(event: 'unsubscribed', listener: (this: Connection, arg: EventTypes.UnsubscribeEvent) => void): this;
    addListener(event: 'unsubscribed', listener: (this: Connection, arg: EventTypes.UnsubscribeEvent) => void): this;
    once(event: 'unsubscribed', listener: (this: Connection, arg: EventTypes.UnsubscribeEvent) => void): this;
}
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const events_1 = require("events");
const HTTPAgent_1 = require("./agents/HTTPAgent");
const HTTPSAgent_1 = require("./agents/HTTPSAgent");
const utils_1 = require("./utils");
const socket_io_client_factory_1 = require("./socket-io-client-factory");
class Connection extends events_1.EventEmitter {
    constructor(connectionOptions) {
        super();
        this.reconnectCount = -1;
        this.isConnectionAborted = false;
        this.subscriptions = new Set();
        this.onConnectHandler = this.onConnectHandler.bind(this);
        this.onDisconnectHandler = this.onDisconnectHandler.bind(this);
        this.onErrorHandler = this.onErrorHandler.bind(this);
        // Replace connection options with defaults whereever necessary
        this.connectionOptions = {
            ...connectionOptions,
            reconnectOptions: {
                retryCount: connectionOptions.reconnectOptions?.retryCount ?? 0,
                retryDelay: connectionOptions.reconnectOptions?.retryDelay ?? 0,
            },
        };
        try {
            this.open();
        }
        catch (err) {
            const error = err;
            this.emit('error', { error: { message: error.message } });
            this.emit('end', { aborted: this.isConnectionAborted });
            return;
        }
    }
    createClient() {
        const agent = this.createRequestAgent();
        const url = this.url.href;
        const options = {
            extraHeaders: this.connectionOptions.headers,
            path: this.connectionOptions?.connectOptions?.handshakePath,
            timeout: this.connectionOptions?.connectOptions?.handshakeTimeout,
            agent,
            forceNew: true,
            transports: ['websocket'],
            autoConnect: false,
            reconnection: false,
        };
        return socket_io_client_factory_1.SocketIOClientFactory.getClient(this.connectionOptions.clientVersion)(url, options);
    }
    open() {
        try {
            if (typeof this.connectionOptions.url === 'string') {
                this.url = (0, utils_1.parseUrl)(this.connectionOptions.url);
            }
            else {
                this.url = (0, utils_1.parseUrl)(this.connectionOptions.url.href);
            }
        }
        catch (err) {
            const error = err;
            this.emit('error', { error: { message: error?.message } });
            this.emit('end', { aborted: this.isConnectionAborted });
            return;
        }
        this.client = this.createClient();
        this.client
            .on('connect', this.onConnectHandler)
            .on('disconnect', this.onDisconnectHandler)
            .on('connect_error', this.onErrorHandler)
            .on('error', this.onErrorHandler);
        this.client.connect();
    }
    createRequestAgent() {
        const { protocol } = this.url;
        const isSecure = protocol === 'https:' || protocol === 'wss:';
        const options = isSecure ?
            {
                rejectUnauthorized: Boolean(this.connectionOptions?.tlsOptions?.rejectUnauthorized),
                ...this.connectionOptions.tlsOptions?.secureContext,
            }
            : {};
        const AgentClass = isSecure ? HTTPSAgent_1.HTTPSAgent : HTTPAgent_1.HTTPAgent;
        const agent = new AgentClass(options);
        agent.on('request-meta', (request) => (this.request = request));
        agent.on('response-meta', (response) => (this.response = response));
        return agent;
    }
    reconnect(reason) {
        this.client.removeAllListeners();
        if (this.reconnectCount >= this.connectionOptions.reconnectOptions.retryCount) {
            this.emit('end', { aborted: this.isConnectionAborted, reason });
            return;
        }
        // Clearing the timeout just to be safe. Most likely any existing timeout would have been executed at this point.
        clearTimeout(this.reconnectTimeoutHandle);
        this.reconnectTimeoutHandle = setTimeout(() => {
            this.open();
        }, this.connectionOptions.reconnectOptions.retryDelay);
        this.emit('reconnect', {
            attempt: ++this.reconnectCount,
            timeout: this.connectionOptions.reconnectOptions.retryDelay,
        });
    }
    messageHandlerFactory(eventName) {
        return (...args) => {
            const messages = args.map((arg) => {
                if (typeof arg === 'string') {
                    return { arg, argType: 'string' };
                }
                if (Buffer.isBuffer(arg)) {
                    const message = arg.buffer.slice(arg.byteOffset, arg.byteOffset + arg.byteLength);
                    return { arg: new Uint8Array(message), argType: 'binary' };
                }
                if (ArrayBuffer.isView(arg)) {
                    return {
                        arg: new Uint8Array(arg.buffer, arg.byteOffset, arg.byteLength),
                        argType: 'binary',
                    };
                }
                return { arg: JSON.stringify(arg), argType: 'object' };
            });
            this.emit('message', { messages, eventName });
        };
    }
    publish(event, messages, opts) {
        const finalMessages = messages.concat(Boolean(opts?.acknowledgement) ? [this.messageHandlerFactory(event)] : []);
        this.client.emit(event, ...finalMessages);
    }
    subscribe(event) {
        if (this.subscriptions.has(event)) {
            // We don't want to subscribe to the same event multiple times,
            // since that will lead to duplicate messages event to be fired
            // for the same subscriptions due to different handlers being
            // attached to the same event.
            return;
        }
        this.client.on(event, this.messageHandlerFactory(event));
        this.subscriptions.add(event);
        // While this can be a synthetic event, there is no way for the consumer to know if the topics were resubscribed after a reconnect, hence emitting the event from the client
        this.emit('subscribed', { event });
    }
    unsubscribe(event) {
        if (!this.subscriptions.has(event)) {
            return;
        }
        this.client.removeAllListeners(event);
        this.subscriptions.delete(event);
        // While this event can be a synthetic event, this is added for consistency since the client is emitting subscribe events
        this.emit('unsubscribed', { event });
    }
    disconnect() {
        if (!this.client.connected) {
            // This disconnect might be received in the middle of a reconnect attempt, thus clear the timeout to avoid reconnection
            clearTimeout(this.reconnectTimeoutHandle);
            this.isConnectionAborted = true;
            this.emit('end', { aborted: this.isConnectionAborted });
        }
        this.subscriptions.clear();
        this.client.disconnect();
    }
    // region: Client Event Handlers
    // These exist separately to allow for easier testing
    onConnectHandler() {
        this.emit('open', { request: this.request, response: this.response });
        // Subscribe to previous subscriptions if connected after a disconnect
        // We can simply iterate over the topics in subscriptions since it will be empty for the first time connection
        for (const event of this.subscriptions) {
            this.client.on(event, this.messageHandlerFactory(event));
            this.emit('subscribed', { event: event });
        }
        this.reconnectCount = 0;
        this.request = this.response = undefined;
    }
    onDisconnectHandler(reason) {
        if (this.reconnectCount === 0) {
            this.emit('close', { reason });
        }
        // Only try to reconnect if:
        // 1. It was not disconnected manually
        // 2. The connection was not aborted
        // 3. Connected at least once
        if (reason === 'io client disconnect' ||
            this.isConnectionAborted ||
            this.reconnectCount === -1) {
            this.emit('end', { aborted: this.isConnectionAborted, reason });
            return;
        }
        this.reconnect(reason);
    }
    onErrorHandler(error) {
        // If connection was aborted, absorb the error
        if (this.isConnectionAborted) {
            return;
        }
        // Emit error only for the final reconnect attempt
        if (this.reconnectCount > 0 &&
            this.reconnectCount < this.connectionOptions.reconnectOptions.retryCount) {
            return this.reconnect();
        }
        this.emit('error', {
            error: {
                message: (0, utils_1.serializeErrorMessage)(error, this.connectionOptions.clientVersion),
            },
            handshakeRequest: this.request,
            handshakeResponse: this.response,
        });
        this.emit('end', { aborted: this.isConnectionAborted });
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map{"version":3,"file":"connection.js","sourceRoot":"","sources":["../src/connection.ts"],"names":[],"mappings":"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"}import { Connection, type ClientOptions } from './connection';
export declare function connect(options: ClientOptions): Connection;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
const connection_1 = require("./connection");
function connect(options) {
    return new connection_1.Connection(options);
}
exports.connect = connect;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;AAAA,6CAA8D;AAE9D,SAAgB,OAAO,CAAC,OAAsB;IAC7C,OAAO,IAAI,uBAAU,CAAC,OAAO,CAAC,CAAC;AAChC,CAAC;AAFD,0BAEC"}import { io as io_v4 } from 'socket.io-client-v4';
export declare class SocketIOClientFactory {
    static getClient(version: '2' | '3' | '4'): typeof io_v4;
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketIOClientFactory = void 0;
// @ts-ignore Ignore the error caused due to absent type defs for socket.io-client-v2
const socket_io_client_v2_1 = __importDefault(require("socket.io-client-v2"));
const socket_io_client_v4_1 = require("socket.io-client-v4");
class SocketIOClientFactory {
    static getClient(version) {
        if (version === '2') {
            return socket_io_client_v2_1.default;
        }
        return socket_io_client_v4_1.io;
    }
}
exports.SocketIOClientFactory = SocketIOClientFactory;
//# sourceMappingURL=socket-io-client-factory.js.map{"version":3,"file":"socket-io-client-factory.js","sourceRoot":"","sources":["../src/socket-io-client-factory.ts"],"names":[],"mappings":";;;;;;AAAA,qFAAqF;AACrF,8EAAwC;AACxC,6DAAkD;AAElD,MAAa,qBAAqB;IACjC,MAAM,CAAC,SAAS,CAAC,OAAwB;QACxC,IAAI,OAAO,KAAK,GAAG,EAAE,CAAC;YACrB,OAAO,6BAAK,CAAC;QACd,CAAC;QACD,OAAO,wBAAK,CAAC;IACd,CAAC;CACD;AAPD,sDAOC"}/// <reference types="node" />
export declare function parseUrl(str: string): URL;
type Header = {
    key: string;
    value: string;
};
export declare function parseHeaders(headerString: string): Header[];
export declare function serializeErrorMessage(error: any, clientVersion: string): string;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeErrorMessage = exports.parseHeaders = exports.parseUrl = void 0;
function parseUrl(str) {
    str = String(str); // For non-TypeScript applications
    // Test if the string doesn't start with a protocol
    if (!/^[a-z0-9+.-]+:\/\//i.test(str)) {
        str = `ws://${str}`; // Default protocol
    }
    const url = new URL(str);
    if (!url.host && !url.port && !url.pathname) {
        throw new Error('Invalid URL');
    }
    const validProtocols = ['ws:', 'wss:', 'http:', 'https:'];
    if (!validProtocols.includes(url.protocol)) {
        throw new Error('Invalid URL');
    }
    return url;
}
exports.parseUrl = parseUrl;
function parseHeaders(headerString) {
    let arr = headerString.split('\r\n'), headers = [];
    for (let i = 1, ii = arr.length - 2; i < ii; i++) {
        const splitIndex = arr[i].indexOf(':');
        headers.push({
            key: arr[i].slice(0, splitIndex),
            value: arr[i].slice(splitIndex + 2),
        });
    }
    return headers;
}
exports.parseHeaders = parseHeaders;
function serializeErrorMessage(error, clientVersion) {
    if (String(error?.message).includes('v2.x with a v3.x')) {
        return `It seems you are trying to reach a Socket.IO server in v2.x with a v${clientVersion}.x client. Switch the client version from request settings.`;
    }
    return error?.description?.error?.message ?? error?.message;
}
exports.serializeErrorMessage = serializeErrorMessage;
//# sourceMappingURL=utils.js.map{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,SAAgB,QAAQ,CAAC,GAAW;IACnC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,kCAAkC;IAErD,mDAAmD;IACnD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACtC,GAAG,GAAG,QAAQ,GAAG,EAAE,CAAC,CAAC,mBAAmB;IACzC,CAAC;IAED,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IAEzB,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;IAChC,CAAC;IAED,MAAM,cAAc,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;IAE1D,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC5C,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;IAChC,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC;AArBD,4BAqBC;AAOD,SAAgB,YAAY,CAAC,YAAoB;IAChD,IAAI,GAAG,GAAG,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,EACnC,OAAO,GAAG,EAAE,CAAC;IAEd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;QAClD,MAAM,UAAU,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAEvC,OAAO,CAAC,IAAI,CAAC;YACZ,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC;YAChC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC;SACnC,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,OAAO,CAAC;AAChB,CAAC;AAdD,oCAcC;AAED,SAAgB,qBAAqB,CACpC,KAAU,EACV,aAAqB;IAErB,IAAI,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,kBAAkB,CAAC,EAAE,CAAC;QACzD,OAAO,uEAAuE,aAAa,6DAA6D,CAAC;IAC1J,CAAC;IAED,OAAO,KAAK,EAAE,WAAW,EAAE,KAAK,EAAE,OAAO,IAAI,KAAK,EAAE,OAAO,CAAC;AAC7D,CAAC;AATD,sDASC"}{
  "name": "@postman/runtime.socket.io-client",
  "version": "0.1.3",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/main/packages/clients/socket-io-client#readme",
  "license": "UNLICENSED",
  "description": "A simple Socket.io client for Node.js",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "socket.io-client-v2": "npm:socket.io-client@2.5.0",
    "socket.io-client-v4": "npm:socket.io-client@4.7.5"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^*"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest",
    "coverage": "vitest --coverage"
  }
}# Socket.io-client

A simple Socket.io client for Node.js
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": ["node"]
	},
	"references": [
		{ "path": "../../core/core" }
	]
}
import { ConnectionEndEvent, ErrorEvent, CloseEvent, ReconnectEvent, OpenEvent, MessageEvent } from './connection-events';
import type { SecureContextOptions } from '@postman/runtime.core';
export interface SocketIOAgent {
    connect(options: ConnectionOptions): SocketIOConnection | Promise<SocketIOConnection>;
}
export interface SocketIOConnection {
    publish(eventName: string, payload: Array<unknown>, opts?: {
        acknowledgement: boolean;
    }): void;
    subscribe(eventName: string): void;
    unsubscribe(eventName: string): void;
    disconnect(code?: number, reason?: string): void;
    on(eventName: 'close', listener: (event: CloseEvent) => void): this;
    on(eventName: 'end', listener: (event: ConnectionEndEvent) => void): this;
    on(eventName: 'error', listener: (event: ErrorEvent) => void): this;
    on(eventName: 'message', listener: (event: MessageEvent) => void): this;
    on(eventName: 'reconnect', listener: (event: ReconnectEvent) => void): this;
    on(eventName: 'open', listener: (event: OpenEvent) => void): this;
    on(eventName: 'subscribed', listener: (event: {
        event: string;
    }) => void): this;
    on(eventName: 'unsubscribed', listener: (event: {
        event: string;
    }) => void): this;
}
export interface ConnectionOptions {
    url: string | URL;
    clientVersion: '2' | '3' | '4';
    connectOptions?: {
        handshakeTimeout?: number;
        handshakePath?: string;
    };
    reconnectOptions?: {
        retryCount?: number;
        retryDelay?: number;
    };
    tlsOptions?: TLSOptions;
    headers: Record<string, string>;
}
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: SecureContextOptions;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=agent.js.map{"version":3,"file":"agent.js","sourceRoot":"","sources":["../src/agent.ts"],"names":[],"mappings":""}export interface HTTPRequest {
    method: 'GET' | 'CONNECT';
    href: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface HTTPResponse {
    statusCode: number;
    statusMessage: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface ConnectionEndEvent {
    reason?: string;
    aborted: boolean;
}
export interface ErrorEvent {
    error: {
        message: string;
    };
    handshakeRequest?: HTTPRequest;
    handshakeResponse?: HTTPResponse;
}
export interface MessageEvent {
    messages: Array<{
        arg: string;
        argType: 'string' | 'object';
    } | {
        arg: Uint8Array;
        argType: 'binary';
    }>;
    eventName: string;
}
export interface OpenEvent {
    request?: HTTPRequest;
    response?: HTTPResponse;
}
export interface ReconnectEvent {
    attempt: number;
    timeout: number;
}
export interface CloseEvent {
    reason: string;
}
export interface SubscribeEvent {
    event: string;
}
export interface UnsubscribeEvent {
    event: string;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=connection-events.js.map{"version":3,"file":"connection-events.js","sourceRoot":"","sources":["../src/connection-events.ts"],"names":[],"mappings":""}import { FromSchema } from 'json-schema-to-ts';
import { Event } from '@postman/runtime.core';
import { MessageType, MessageSubType } from '@postman/runtime.protocol-utils';
declare const definition: {
    connected: {
        schema: {
            type: "object";
            properties: {
                handshakeRequest: {
                    type: "object";
                    required: ["method", "headers", "url"];
                    properties: {
                        method: {
                            type: "string";
                            enum: ["GET", "CONNECT"];
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                        url: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                handshakeResponse: {
                    type: "object";
                    required: ["statusCode", "statusMessage", "headers"];
                    properties: {
                        statusCode: {
                            type: "integer";
                            minimum: 100;
                            maximum: 599;
                        };
                        statusMessage: {
                            type: "string";
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                    };
                    additionalProperties: false;
                };
            };
            additionalProperties: false;
        };
    };
    disconnected: {
        schema: {
            type: "object";
            properties: {
                code: {
                    type: "integer";
                    minimum: 1000;
                    maximum: 4999;
                };
                reason: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
    error: {
        schema: {
            type: "object";
            required: ["error"];
            properties: {
                error: {
                    type: "object";
                    required: ["message"];
                    properties: {
                        message: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                handshakeRequest: {
                    type: "object";
                    required: ["method", "headers", "url"];
                    properties: {
                        method: {
                            type: "string";
                            enum: ["GET", "CONNECT"];
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                        url: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                handshakeResponse: {
                    type: "object";
                    required: ["statusCode", "statusMessage", "headers"];
                    properties: {
                        statusCode: {
                            type: "integer";
                            minimum: 100;
                            maximum: 599;
                        };
                        statusMessage: {
                            type: "string";
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                    };
                    additionalProperties: false;
                };
            };
            additionalProperties: false;
        };
    };
    reconnecting: {
        schema: {
            type: "object";
            additionalProperties: false;
        };
    };
    aborted: {
        schema: {
            type: "object";
            additionalProperties: false;
        };
    };
    'sent-message': {
        schema: {
            type: "object";
            required: ["data", "eventName"];
            properties: {
                data: {
                    type: "object";
                    required: ["type", "payload"];
                    properties: {
                        type: {
                            type: "string";
                        };
                        payload: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                eventName: {
                    type: "string";
                };
                mimeType: {
                    type: "string";
                };
                size: {
                    type: "integer";
                    minimum: 0;
                };
                fileExtension: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
    'received-message': {
        schema: {
            type: "object";
            required: ["data", "eventName"];
            properties: {
                data: {
                    type: "object";
                    required: ["type", "payload"];
                    properties: {
                        type: {
                            type: "string";
                        };
                        payload: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                eventName: {
                    type: "string";
                };
                mimeType: {
                    type: "string";
                };
                size: {
                    type: "integer";
                    minimum: 0;
                };
                fileExtension: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
    'subscribe-event': {
        schema: {
            type: "object";
            required: ["eventName"];
            properties: {
                eventName: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
    'unsubscribe-event': {
        schema: {
            type: "object";
            required: ["eventName"];
            properties: {
                eventName: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
};
export type Connected = Event<'connected', FromSchema<(typeof definition)['connected']['schema']>>;
export type Error = Event<'error', FromSchema<(typeof definition)['error']['schema']>>;
export type Disconnected = Event<'disconnected', FromSchema<(typeof definition)['disconnected']['schema']>>;
export type Reconnecting = Event<'reconnecting', FromSchema<(typeof definition)['reconnecting']['schema']>>;
export type Aborted = Event<'aborted', FromSchema<(typeof definition)['aborted']['schema']>>;
export type SentMessage = Event<'sent-message', FromSchema<(typeof definition)['sent-message']['schema']>>;
export type ReceivedMessage = Event<'received-message', FromSchema<(typeof definition)['received-message']['schema']>>;
export type SubscribeEvent = Event<'subscribe-event', FromSchema<(typeof definition)['subscribe-event']['schema']>>;
export type UnsubscribeEvent = Event<'unsubscribe-event', FromSchema<(typeof definition)['unsubscribe-event']['schema']>>;
export type Subscribe = Event<'subscribe', {
    eventName: string;
}>;
export type Unsubscribe = Event<'unsubscribe', {
    eventName: string;
}>;
type PublishPayload = {
    message: string;
    type: Exclude<MessageType, MessageType.BINARY>;
} | {
    message: string;
    type: MessageType.BINARY;
    subType: MessageSubType;
};
export type Publish = Event<'publish', {
    payload: PublishPayload[];
    eventName: string;
    acknowledgement?: boolean;
}>;
export type Disconnect = Event<'disconnect', {}>;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const definition = (0, json_schema_to_ts_1.asConst)({
    connected: {
        schema: {
            type: 'object',
            properties: {
                handshakeRequest: {
                    type: 'object',
                    required: ['method', 'headers', 'url'],
                    properties: {
                        method: {
                            type: 'string',
                            enum: ['GET', 'CONNECT'],
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                        url: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeResponse: {
                    type: 'object',
                    required: ['statusCode', 'statusMessage', 'headers'],
                    properties: {
                        statusCode: {
                            type: 'integer',
                            minimum: 100,
                            maximum: 599,
                        },
                        statusMessage: {
                            type: 'string',
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    disconnected: {
        schema: {
            type: 'object',
            properties: {
                code: {
                    type: 'integer',
                    minimum: 1000,
                    maximum: 4999,
                },
                reason: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    error: {
        schema: {
            type: 'object',
            required: ['error'],
            properties: {
                error: {
                    type: 'object',
                    required: ['message'],
                    properties: {
                        message: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeRequest: {
                    type: 'object',
                    required: ['method', 'headers', 'url'],
                    properties: {
                        method: {
                            type: 'string',
                            enum: ['GET', 'CONNECT'],
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                        url: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeResponse: {
                    type: 'object',
                    required: ['statusCode', 'statusMessage', 'headers'],
                    properties: {
                        statusCode: {
                            type: 'integer',
                            minimum: 100,
                            maximum: 599,
                        },
                        statusMessage: {
                            type: 'string',
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    reconnecting: {
        schema: {
            type: 'object',
            additionalProperties: false,
        },
    },
    aborted: {
        schema: {
            type: 'object',
            additionalProperties: false,
        },
    },
    'sent-message': {
        schema: {
            type: 'object',
            required: ['data', 'eventName'],
            properties: {
                data: {
                    type: 'object',
                    required: ['type', 'payload'],
                    properties: {
                        type: {
                            type: 'string',
                        },
                        payload: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                eventName: {
                    type: 'string',
                },
                mimeType: {
                    type: 'string',
                },
                size: {
                    type: 'integer',
                    minimum: 0,
                },
                fileExtension: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'received-message': {
        schema: {
            type: 'object',
            required: ['data', 'eventName'],
            properties: {
                data: {
                    type: 'object',
                    required: ['type', 'payload'],
                    properties: {
                        type: {
                            type: 'string',
                        },
                        payload: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                eventName: {
                    type: 'string',
                },
                mimeType: {
                    type: 'string',
                },
                size: {
                    type: 'integer',
                    minimum: 0,
                },
                fileExtension: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'subscribe-event': {
        schema: {
            type: 'object',
            required: ['eventName'],
            properties: {
                eventName: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'unsubscribe-event': {
        schema: {
            type: 'object',
            required: ['eventName'],
            properties: {
                eventName: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
});
//# sourceMappingURL=events.js.map{"version":3,"file":"events.js","sourceRoot":"","sources":["../src/events.ts"],"names":[],"mappings":"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"}import SocketIORequest from '.';
declare const _default: (item: import("@postman/runtime.core").Item.OfType<SocketIORequest>, agent: import("./agent").SocketIOAgent, context: import("@postman/runtime.core").RuntimeContext) => Promise<void>;
export default _default;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = require("@postman/runtime.core");
const runtime_protocol_utils_1 = require("@postman/runtime.protocol-utils");
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const file_type_1 = __importDefault(require("file-type"));
const parse_message_1 = require("./utils/parse-message");
const data_transformers_1 = require("./utils/data-transformers");
const parse_url_1 = require("./utils/parse-url");
const uuid_1 = require("uuid");
exports.default = (async function handler(item, agent, context) {
    if (!item.payload.url) {
        throw new Error('URL is required');
    }
    const url = (0, parse_url_1.parseUrl)(item.payload.url);
    const { variables } = context;
    const settings = {
        clientVersion: item.payload.settings?.version ?? '3',
        connectOptions: {
            handshakeTimeout: item.payload.settings?.handshakeTimeout,
            handshakePath: item.payload.settings?.path ?? '/socket.io',
        },
        reconnectOptions: {
            retryCount: item.payload.settings?.retryCount ?? 0,
            retryDelay: item.payload.settings?.retryDelay ?? 5000,
        },
    };
    const headers = (0, data_transformers_1.transformKVItemToObject)(item.payload.headers || []);
    const tlsOptions = url.isTLS ?
        {
            rejectUnauthorized: Boolean(item.payload.settings?.strictSSL),
            secureContext: typeof context.secureContext === 'function' ?
                await context.secureContext(item.payload.url)
                : context.secureContext,
        }
        : {};
    const connection = await agent.connect({
        url: url.url,
        headers,
        ...settings,
        tlsOptions,
    });
    const events = runtime_core_1.EventChannel.specific(context.events);
    const encoder = new TextEncoder();
    const subscriptions = new Set();
    const onPublish = (event) => {
        const eventName = event.payload.eventName;
        const messages = [];
        const consumerMessages = [];
        let totalSize = 0;
        event.payload.payload.forEach((message, index) => {
            let payload = message.message;
            if (variables) {
                payload = variables.replaceIn(payload);
            }
            if (message.type === runtime_protocol_utils_1.MessageType.POSTMAN_JSON) {
                payload = (0, strip_json_comments_1.default)(payload, { whitespace: false });
                payload = JSON.parse(payload);
            }
            else if (message.type === runtime_protocol_utils_1.MessageType.BINARY) {
                payload = (0, runtime_protocol_utils_1.binaryStringToUint8Array)(payload, message.subType);
            }
            messages.push(payload);
            consumerMessages.push({
                id: (0, uuid_1.v4)(),
                name: (0, parse_message_1.getArgumentName)(index),
                value: payload instanceof Uint8Array ? (0, runtime_protocol_utils_1.uint8ArrayToString)(payload)
                    : message.type === runtime_protocol_utils_1.MessageType.POSTMAN_JSON ? JSON.stringify(payload)
                        : payload,
                meta: {
                    mimeType: runtime_protocol_utils_1.MIME_TYPE_MAP[message.type],
                    size: payload instanceof Uint8Array ?
                        payload.byteLength
                        : encoder.encode(message.type === runtime_protocol_utils_1.MessageType.POSTMAN_JSON ?
                            JSON.stringify(payload)
                            : payload).byteLength,
                },
            });
            totalSize += consumerMessages.at(-1).meta.size;
        });
        connection.publish(eventName, messages, {
            acknowledgement: Boolean(event.payload.acknowledgement),
        });
        events.emit('sent-message', {
            data: { payload: JSON.stringify(consumerMessages), type: 'Array' },
            size: totalSize,
            eventName,
        });
    };
    const onSubscribe = (event) => {
        if (subscriptions.has(event.payload.eventName)) {
            return;
        }
        connection.subscribe(event.payload.eventName);
    };
    const onUnsubscribe = (event) => {
        if (!subscriptions.has(event.payload.eventName)) {
            return;
        }
        connection.unsubscribe(event.payload.eventName);
    };
    const onDisconnect = () => {
        connection.disconnect();
    };
    let isEndEventReceived = false;
    return new Promise((resolve) => {
        const onDone = () => {
            events
                .off('disconnect', onDisconnect)
                .off('publish', onPublish)
                .off('subscribe', onSubscribe)
                .off('unsubscribe', onUnsubscribe);
            if (!isEndEventReceived) {
                connection.disconnect();
            }
            resolve();
        };
        events
            .on('publish', onPublish)
            .on('subscribe', onSubscribe)
            .on('unsubscribe', onUnsubscribe)
            .on('disconnect', onDisconnect)
            .onCleanup(onDone);
        connection
            .on('open', ({ request, response }) => {
            const payload = {};
            if (request) {
                const { href, httpVersion, ...rest } = request;
                payload.handshakeRequest = { url: href, ...rest };
            }
            if (response) {
                const { httpVersion, ...rest } = response;
                payload.handshakeResponse = rest;
            }
            events.emit('connected', payload);
            item.payload.events?.forEach(({ name, subscribeOnConnect }) => {
                if (!subscribeOnConnect) {
                    return;
                }
                connection.subscribe(name);
            });
        })
            .on('reconnect', () => {
            events.emit('reconnecting', {});
        })
            .on('error', ({ handshakeRequest: request, handshakeResponse: response, error }) => {
            const payload = {
                error: { message: error.message },
            };
            if (request) {
                const { href, httpVersion, ...rest } = request;
                payload.handshakeRequest = { url: href, ...rest };
            }
            if (response) {
                const { httpVersion, ...rest } = response;
                payload.handshakeResponse = rest;
            }
            events.emit('error', payload);
        })
            .on('subscribed', ({ event }) => {
            events.emit('subscribe-event', { eventName: event });
            subscriptions.add(event);
        })
            .on('unsubscribed', ({ event }) => {
            events.emit('unsubscribe-event', { eventName: event });
            subscriptions.delete(event);
        })
            .on('message', async (event) => {
            const eventName = event.eventName;
            let totalSize = 0;
            const messages = await Promise.all(event.messages.map(async (message, index) => {
                const meta = {
                    mimeType: 'text/plain',
                    size: 0,
                    fileExtension: 'txt',
                };
                if (message.argType === 'string' || message.argType === 'object') {
                    meta.size = encoder.encode(message.arg).byteLength;
                    totalSize += meta.size;
                    if (message.argType === 'object') {
                        meta.mimeType = 'application/json';
                    }
                    return {
                        id: (0, uuid_1.v4)(),
                        name: (0, parse_message_1.getArgumentName)(index),
                        value: message.arg,
                        meta,
                    };
                }
                meta.size = message.arg.byteLength;
                totalSize += meta.size;
                try {
                    const result = await file_type_1.default.fromBuffer(message.arg);
                    meta.mimeType = result?.mime || 'application/octet-stream';
                    meta.fileExtension = result?.ext || 'bin';
                }
                catch (err) {
                    meta.mimeType = 'application/octet-stream';
                    meta.fileExtension = 'bin';
                }
                finally {
                    return {
                        id: (0, uuid_1.v4)(),
                        name: (0, parse_message_1.getArgumentName)(index),
                        value: (0, runtime_protocol_utils_1.uint8ArrayToString)(message.arg),
                        meta,
                    };
                }
            }));
            events.emit('received-message', {
                data: { payload: JSON.stringify(messages), type: 'Array' },
                size: totalSize,
                eventName,
            });
        })
            .on('end', ({ reason, aborted }) => {
            isEndEventReceived = true;
            if (aborted) {
                events.emit('aborted', {});
            }
            else {
                events.emit('disconnected', { reason });
            }
            onDone();
        });
    });
});
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":"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"}import { FromSchema } from 'json-schema-to-ts';
import { ItemType } from '@postman/runtime.core';
import Documentation from '@postman/runtime.documentation';
import Variables from '@postman/runtime.variables';
import * as SocketIOEvents from './events';
import { SocketIOAgent } from './agent';
export * as SocketIOEvents from './events';
export * from './agent';
declare const definition: {
    name: "ws-socketio-request";
    summary: "Socket.IO Request";
    schema: {
        type: "object";
        properties: {
            url: {
                type: "string";
            };
            headers: {
                type: "array";
                items: {
                    type: "object";
                    required: ["key", "value"];
                    properties: {
                        key: {
                            type: "string";
                        };
                        value: {
                            type: "string";
                        };
                        description: {
                            type: "string";
                        };
                        disabled: {
                            type: "boolean";
                        };
                    };
                    additionalProperties: false;
                };
            };
            queryParams: {
                type: "array";
                items: {
                    type: "object";
                    required: ["key", "value"];
                    properties: {
                        key: {
                            type: ["string", "null"];
                        };
                        value: {
                            type: ["string", "null"];
                        };
                        description: {
                            type: "string";
                        };
                        disabled: {
                            type: "boolean";
                        };
                    };
                    additionalProperties: false;
                };
            };
            settings: {
                type: "object";
                properties: {
                    version: {
                        type: "string";
                        enum: ["2", "3", "4"];
                    };
                    path: {
                        type: "string";
                    };
                    handshakeTimeout: {
                        type: "integer";
                        minimum: 0;
                    };
                    retryCount: {
                        type: "integer";
                        minimum: 0;
                    };
                    retryDelay: {
                        type: "integer";
                        minimum: 0;
                    };
                    strictSSL: {
                        type: "boolean";
                    };
                };
                additionalProperties: false;
            };
            events: {
                type: "array";
                items: {
                    type: "object";
                    required: ["name"];
                    properties: {
                        name: {
                            type: "string";
                        };
                        description: {
                            type: "string";
                        };
                        subscribeOnConnect: {
                            type: "boolean";
                        };
                    };
                    additionalProperties: false;
                };
            };
        };
        additionalProperties: false;
    };
    constraints: [{
        constraint: "allow-child-types";
        allowed: ["ws-socketio-message"];
    }, {
        constraint: "allow-extensions";
        allowed: ["documentation", "variables"];
    }];
};
declare namespace SocketIORequest {
    type Payload = FromSchema<typeof definition.schema>;
    type Extensions = Documentation | Variables;
    type Config = SocketIOAgent;
    type SentEvents = SocketIOEvents.Publish | SocketIOEvents.Disconnect | SocketIOEvents.Subscribe | SocketIOEvents.Unsubscribe;
    type ReceivedEvents = SocketIOEvents.Connected | SocketIOEvents.Error | SocketIOEvents.SentMessage | SocketIOEvents.ReceivedMessage | SocketIOEvents.Disconnected | SocketIOEvents.Reconnecting | SocketIOEvents.SubscribeEvent | SocketIOEvents.UnsubscribeEvent | SocketIOEvents.Aborted;
    const use: () => ItemType.Specific<{
        headers?: {
            description?: string | undefined;
            disabled?: boolean | undefined;
            key: string;
            value: string;
        }[] | undefined;
        url?: string | undefined;
        queryParams?: {
            description?: string | undefined;
            disabled?: boolean | undefined;
            key: string | null;
            value: string | null;
        }[] | undefined;
        settings?: {
            version?: "2" | "3" | "4" | undefined;
            path?: string | undefined;
            handshakeTimeout?: number | undefined;
            retryCount?: number | undefined;
            retryDelay?: number | undefined;
            strictSSL?: boolean | undefined;
        } | undefined;
        events?: {
            description?: string | undefined;
            subscribeOnConnect?: boolean | undefined;
            name: string;
        }[] | undefined;
    }, Extensions, SocketIOAgent, SentEvents, ReceivedEvents>;
}
type SocketIORequest = ItemType.Specific<SocketIORequest.Payload, SocketIORequest.Extensions, SocketIORequest.Config, SocketIORequest.SentEvents, SocketIORequest.ReceivedEvents>;
export default SocketIORequest;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketIOEvents = void 0;
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const runtime_documentation_1 = __importDefault(require("@postman/runtime.documentation"));
const runtime_variables_1 = __importDefault(require("@postman/runtime.variables"));
const handler_1 = __importDefault(require("./handler"));
exports.SocketIOEvents = __importStar(require("./events"));
__exportStar(require("./agent"), exports);
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'ws-socketio-request',
    summary: 'Socket.IO Request',
    schema: {
        type: 'object',
        properties: {
            url: {
                type: 'string',
            },
            headers: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: 'string',
                        },
                        value: {
                            type: 'string',
                        },
                        description: {
                            type: 'string',
                        },
                        disabled: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
            queryParams: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: ['string', 'null'],
                        },
                        value: {
                            type: ['string', 'null'],
                        },
                        description: {
                            type: 'string',
                        },
                        disabled: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
            settings: {
                type: 'object',
                properties: {
                    version: {
                        type: 'string',
                        enum: ['2', '3', '4'],
                    },
                    path: {
                        type: 'string',
                    },
                    handshakeTimeout: {
                        type: 'integer',
                        minimum: 0,
                    },
                    retryCount: {
                        type: 'integer',
                        minimum: 0,
                    },
                    retryDelay: {
                        type: 'integer',
                        minimum: 0,
                    },
                    strictSSL: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
            },
            events: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['name'],
                    properties: {
                        name: {
                            type: 'string',
                        },
                        description: {
                            type: 'string',
                        },
                        subscribeOnConnect: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
        },
        additionalProperties: false,
    },
    constraints: [
        {
            constraint: 'allow-child-types',
            allowed: ['ws-socketio-message'],
        },
        {
            constraint: 'allow-extensions',
            allowed: ['documentation', 'variables'],
        },
    ],
});
const extensions = [
    runtime_documentation_1.default.use().implement({}),
    runtime_variables_1.default.use().implement({
        replaceInFields: [
            'payload.url',
            'payload.headers',
            'payload.queryParams',
            'payload.events',
            'payload.settings',
        ],
    }),
];
var SocketIORequest;
(function (SocketIORequest) {
    SocketIORequest.use = runtime_core_1.ItemType.define(definition, extensions, handler_1.default);
})(SocketIORequest || (SocketIORequest = {}));
exports.default = SocketIORequest;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}export interface KeyValueItem {
    key?: string | null;
    value?: string | null;
    disabled?: boolean;
}
export declare function transformKVItemToObject(items: KeyValueItem[]): Record<string, string>;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformKVItemToObject = transformKVItemToObject;
function transformKVItemToObject(items) {
    if (!items || items.length === 0)
        return {};
    return items.reduce((acc, { key, value, disabled }) => {
        if (key === null ||
            value === null ||
            Boolean(disabled) ||
            key === undefined ||
            value === undefined)
            return acc;
        acc[key] = value;
        return acc;
    }, {});
}
//# sourceMappingURL=data-transformers.js.map{"version":3,"file":"data-transformers.js","sourceRoot":"","sources":["../../src/utils/data-transformers.ts"],"names":[],"mappings":";;AAMA,0DAoBC;AApBD,SAAgB,uBAAuB,CACtC,KAAqB;IAErB,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IAE5C,OAAO,KAAK,CAAC,MAAM,CAClB,CAAC,GAA2B,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,EAAE;QACzD,IACC,GAAG,KAAK,IAAI;YACZ,KAAK,KAAK,IAAI;YACd,OAAO,CAAC,QAAQ,CAAC;YACjB,GAAG,KAAK,SAAS;YACjB,KAAK,KAAK,SAAS;YAEnB,OAAO,GAAG,CAAC;QACZ,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACjB,OAAO,GAAG,CAAC;IACZ,CAAC,EACD,EAAE,CACF,CAAC;AACH,CAAC"}export declare function getArgumentName(index: number): string;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getArgumentName = getArgumentName;
function getArgumentName(index) {
    return `Arg ${index + 1}`;
}
//# sourceMappingURL=parse-message.js.map{"version":3,"file":"parse-message.js","sourceRoot":"","sources":["../../src/utils/parse-message.ts"],"names":[],"mappings":";;AAAA,0CAEC;AAFD,SAAgB,eAAe,CAAC,KAAa;IAC5C,OAAO,OAAO,KAAK,GAAG,CAAC,EAAE,CAAC;AAC3B,CAAC"}export type ParsedURL = {
    protocol: 'ws' | 'wss';
    url: string;
    port?: string;
    host: string;
    pathname: string;
    isTLS: boolean;
};
export declare function parseUrl(str: string): ParsedURL;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUrl = parseUrl;
function parseUrl(str) {
    str = String(str); // For non-TypeScript applications
    // Test if the string doesn't start with a protocol
    if (!/^[a-z0-9+.-]+:\/\//i.test(str)) {
        str = `ws://${str}`; // Default protocol
    }
    let url;
    try {
        url = new URL(str);
    }
    catch (_) {
        throw new Error(`Invalid URL "${str}"`);
    }
    if (!url.host && !url.port && !url.pathname) {
        throw new Error(`Invalid URL "${str}"`);
    }
    const validProtocols = ['ws:', 'wss:', 'http:', 'https:'];
    if (!validProtocols.includes(url.protocol)) {
        throw new Error(`Invalid protocol "${url.protocol}//", try "ws://" instead`);
    }
    const { port } = url;
    return {
        protocol: url.protocol.replace(/:$/, ''),
        host: url.hostname,
        port: port,
        url: url.href,
        pathname: url.pathname,
        isTLS: url.protocol === 'wss:',
    };
}
//# sourceMappingURL=parse-url.js.map{"version":3,"file":"parse-url.js","sourceRoot":"","sources":["../../src/utils/parse-url.ts"],"names":[],"mappings":";;AASA,4BAqCC;AArCD,SAAgB,QAAQ,CAAC,GAAW;IACnC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,kCAAkC;IAErD,mDAAmD;IACnD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACtC,GAAG,GAAG,QAAQ,GAAG,EAAE,CAAC,CAAC,mBAAmB;IACzC,CAAC;IAED,IAAI,GAAQ,CAAC;IAEb,IAAI,CAAC;QACJ,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,cAAc,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;IAE1D,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC5C,MAAM,IAAI,KAAK,CACd,qBAAqB,GAAG,CAAC,QAAQ,0BAA0B,CAC3D,CAAC;IACH,CAAC;IACD,MAAM,EAAE,IAAI,EAAE,GAAG,GAAG,CAAC;IAErB,OAAO;QACN,QAAQ,EAAE,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAA0B;QACjE,IAAI,EAAE,GAAG,CAAC,QAAQ;QAClB,IAAI,EAAE,IAAI;QACV,GAAG,EAAE,GAAG,CAAC,IAAI;QACb,QAAQ,EAAE,GAAG,CAAC,QAAQ;QACtB,KAAK,EAAE,GAAG,CAAC,QAAQ,KAAK,MAAM;KAC9B,CAAC;AACH,CAAC"}#!/usr/bin/env node
require('../uuid-bin');
# Changelog

All notable changes to this project will be documented in this file. See [standard-version](https://github.com/conventional-changelog/standard-version) for commit guidelines.

### [8.3.2](https://github.com/uuidjs/uuid/compare/v8.3.1...v8.3.2) (2020-12-08)

### Bug Fixes

- lazy load getRandomValues ([#537](https://github.com/uuidjs/uuid/issues/537)) ([16c8f6d](https://github.com/uuidjs/uuid/commit/16c8f6df2f6b09b4d6235602d6a591188320a82e)), closes [#536](https://github.com/uuidjs/uuid/issues/536)

### [8.3.1](https://github.com/uuidjs/uuid/compare/v8.3.0...v8.3.1) (2020-10-04)

### Bug Fixes

- support expo>=39.0.0 ([#515](https://github.com/uuidjs/uuid/issues/515)) ([c65a0f3](https://github.com/uuidjs/uuid/commit/c65a0f3fa73b901959d638d1e3591dfacdbed867)), closes [#375](https://github.com/uuidjs/uuid/issues/375)

## [8.3.0](https://github.com/uuidjs/uuid/compare/v8.2.0...v8.3.0) (2020-07-27)

### Features

- add parse/stringify/validate/version/NIL APIs ([#479](https://github.com/uuidjs/uuid/issues/479)) ([0e6c10b](https://github.com/uuidjs/uuid/commit/0e6c10ba1bf9517796ff23c052fc0468eedfd5f4)), closes [#475](https://github.com/uuidjs/uuid/issues/475) [#478](https://github.com/uuidjs/uuid/issues/478) [#480](https://github.com/uuidjs/uuid/issues/480) [#481](https://github.com/uuidjs/uuid/issues/481) [#180](https://github.com/uuidjs/uuid/issues/180)

## [8.2.0](https://github.com/uuidjs/uuid/compare/v8.1.0...v8.2.0) (2020-06-23)

### Features

- improve performance of v1 string representation ([#453](https://github.com/uuidjs/uuid/issues/453)) ([0ee0b67](https://github.com/uuidjs/uuid/commit/0ee0b67c37846529c66089880414d29f3ae132d5))
- remove deprecated v4 string parameter ([#454](https://github.com/uuidjs/uuid/issues/454)) ([88ce3ca](https://github.com/uuidjs/uuid/commit/88ce3ca0ba046f60856de62c7ce03f7ba98ba46c)), closes [#437](https://github.com/uuidjs/uuid/issues/437)
- support jspm ([#473](https://github.com/uuidjs/uuid/issues/473)) ([e9f2587](https://github.com/uuidjs/uuid/commit/e9f2587a92575cac31bc1d4ae944e17c09756659))

### Bug Fixes

- prepare package exports for webpack 5 ([#468](https://github.com/uuidjs/uuid/issues/468)) ([8d6e6a5](https://github.com/uuidjs/uuid/commit/8d6e6a5f8965ca9575eb4d92e99a43435f4a58a8))

## [8.1.0](https://github.com/uuidjs/uuid/compare/v8.0.0...v8.1.0) (2020-05-20)

### Features

- improve v4 performance by reusing random number array ([#435](https://github.com/uuidjs/uuid/issues/435)) ([bf4af0d](https://github.com/uuidjs/uuid/commit/bf4af0d711b4d2ed03d1f74fd12ad0baa87dc79d))
- optimize V8 performance of bytesToUuid ([#434](https://github.com/uuidjs/uuid/issues/434)) ([e156415](https://github.com/uuidjs/uuid/commit/e156415448ec1af2351fa0b6660cfb22581971f2))

### Bug Fixes

- export package.json required by react-native and bundlers ([#449](https://github.com/uuidjs/uuid/issues/449)) ([be1c8fe](https://github.com/uuidjs/uuid/commit/be1c8fe9a3206c358e0059b52fafd7213aa48a52)), closes [ai/nanoevents#44](https://github.com/ai/nanoevents/issues/44#issuecomment-602010343) [#444](https://github.com/uuidjs/uuid/issues/444)

## [8.0.0](https://github.com/uuidjs/uuid/compare/v7.0.3...v8.0.0) (2020-04-29)

### ⚠ BREAKING CHANGES

- For native ECMAScript Module (ESM) usage in Node.js only named exports are exposed, there is no more default export.

  ```diff
  -import uuid from 'uuid';
  -console.log(uuid.v4()); // -> 'cd6c3b08-0adc-4f4b-a6ef-36087a1c9869'
  +import { v4 as uuidv4 } from 'uuid';
  +uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
  ```

- Deep requiring specific algorithms of this library like `require('uuid/v4')`, which has been deprecated in `uuid@7`, is no longer supported.

  Instead use the named exports that this module exports.

  For ECMAScript Modules (ESM):

  ```diff
  -import uuidv4 from 'uuid/v4';
  +import { v4 as uuidv4 } from 'uuid';
  uuidv4();
  ```

  For CommonJS:

  ```diff
  -const uuidv4 = require('uuid/v4');
  +const { v4: uuidv4 } = require('uuid');
  uuidv4();
  ```

### Features

- native Node.js ES Modules (wrapper approach) ([#423](https://github.com/uuidjs/uuid/issues/423)) ([2d9f590](https://github.com/uuidjs/uuid/commit/2d9f590ad9701d692625c07ed62f0a0f91227991)), closes [#245](https://github.com/uuidjs/uuid/issues/245) [#419](https://github.com/uuidjs/uuid/issues/419) [#342](https://github.com/uuidjs/uuid/issues/342)
- remove deep requires ([#426](https://github.com/uuidjs/uuid/issues/426)) ([daf72b8](https://github.com/uuidjs/uuid/commit/daf72b84ceb20272a81bb5fbddb05dd95922cbba))

### Bug Fixes

- add CommonJS syntax example to README quickstart section ([#417](https://github.com/uuidjs/uuid/issues/417)) ([e0ec840](https://github.com/uuidjs/uuid/commit/e0ec8402c7ad44b7ef0453036c612f5db513fda0))

### [7.0.3](https://github.com/uuidjs/uuid/compare/v7.0.2...v7.0.3) (2020-03-31)

### Bug Fixes

- make deep require deprecation warning work in browsers ([#409](https://github.com/uuidjs/uuid/issues/409)) ([4b71107](https://github.com/uuidjs/uuid/commit/4b71107d8c0d2ef56861ede6403fc9dc35a1e6bf)), closes [#408](https://github.com/uuidjs/uuid/issues/408)

### [7.0.2](https://github.com/uuidjs/uuid/compare/v7.0.1...v7.0.2) (2020-03-04)

### Bug Fixes

- make access to msCrypto consistent ([#393](https://github.com/uuidjs/uuid/issues/393)) ([8bf2a20](https://github.com/uuidjs/uuid/commit/8bf2a20f3565df743da7215eebdbada9d2df118c))
- simplify link in deprecation warning ([#391](https://github.com/uuidjs/uuid/issues/391)) ([bb2c8e4](https://github.com/uuidjs/uuid/commit/bb2c8e4e9f4c5f9c1eaaf3ea59710c633cd90cb7))
- update links to match content in readme ([#386](https://github.com/uuidjs/uuid/issues/386)) ([44f2f86](https://github.com/uuidjs/uuid/commit/44f2f86e9d2bbf14ee5f0f00f72a3db1292666d4))

### [7.0.1](https://github.com/uuidjs/uuid/compare/v7.0.0...v7.0.1) (2020-02-25)

### Bug Fixes

- clean up esm builds for node and browser ([#383](https://github.com/uuidjs/uuid/issues/383)) ([59e6a49](https://github.com/uuidjs/uuid/commit/59e6a49e7ce7b3e8fb0f3ee52b9daae72af467dc))
- provide browser versions independent from module system ([#380](https://github.com/uuidjs/uuid/issues/380)) ([4344a22](https://github.com/uuidjs/uuid/commit/4344a22e7aed33be8627eeaaf05360f256a21753)), closes [#378](https://github.com/uuidjs/uuid/issues/378)

## [7.0.0](https://github.com/uuidjs/uuid/compare/v3.4.0...v7.0.0) (2020-02-24)

### ⚠ BREAKING CHANGES

- The default export, which used to be the v4() method but which was already discouraged in v3.x of this library, has been removed.
- Explicitly note that deep imports of the different uuid version functions are deprecated and no longer encouraged and that ECMAScript module named imports should be used instead. Emit a deprecation warning for people who deep-require the different algorithm variants.
- Remove builtin support for insecure random number generators in the browser. Users who want that will have to supply their own random number generator function.
- Remove support for generating v3 and v5 UUIDs in Node.js<4.x
- Convert code base to ECMAScript Modules (ESM) and release CommonJS build for node and ESM build for browser bundlers.

### Features

- add UMD build to npm package ([#357](https://github.com/uuidjs/uuid/issues/357)) ([4e75adf](https://github.com/uuidjs/uuid/commit/4e75adf435196f28e3fbbe0185d654b5ded7ca2c)), closes [#345](https://github.com/uuidjs/uuid/issues/345)
- add various es module and CommonJS examples ([b238510](https://github.com/uuidjs/uuid/commit/b238510bf352463521f74bab175a3af9b7a42555))
- ensure that docs are up-to-date in CI ([ee5e77d](https://github.com/uuidjs/uuid/commit/ee5e77db547474f5a8f23d6c857a6d399209986b))
- hybrid CommonJS & ECMAScript modules build ([a3f078f](https://github.com/uuidjs/uuid/commit/a3f078faa0baff69ab41aed08e041f8f9c8993d0))
- remove insecure fallback random number generator ([3a5842b](https://github.com/uuidjs/uuid/commit/3a5842b141a6e5de0ae338f391661e6b84b167c9)), closes [#173](https://github.com/uuidjs/uuid/issues/173)
- remove support for pre Node.js v4 Buffer API ([#356](https://github.com/uuidjs/uuid/issues/356)) ([b59b5c5](https://github.com/uuidjs/uuid/commit/b59b5c5ecad271c5453f1a156f011671f6d35627))
- rename repository to github:uuidjs/uuid ([#351](https://github.com/uuidjs/uuid/issues/351)) ([c37a518](https://github.com/uuidjs/uuid/commit/c37a518e367ac4b6d0aa62dba1bc6ce9e85020f7)), closes [#338](https://github.com/uuidjs/uuid/issues/338)

### Bug Fixes

- add deep-require proxies for local testing and adjust tests ([#365](https://github.com/uuidjs/uuid/issues/365)) ([7fedc79](https://github.com/uuidjs/uuid/commit/7fedc79ac8fda4bfd1c566c7f05ef4ac13b2db48))
- add note about removal of default export ([#372](https://github.com/uuidjs/uuid/issues/372)) ([12749b7](https://github.com/uuidjs/uuid/commit/12749b700eb49db8a9759fd306d8be05dbfbd58c)), closes [#370](https://github.com/uuidjs/uuid/issues/370)
- deprecated deep requiring of the different algorithm versions ([#361](https://github.com/uuidjs/uuid/issues/361)) ([c0bdf15](https://github.com/uuidjs/uuid/commit/c0bdf15e417639b1aeb0b247b2fb11f7a0a26b23))

## [3.4.0](https://github.com/uuidjs/uuid/compare/v3.3.3...v3.4.0) (2020-01-16)

### Features

- rename repository to github:uuidjs/uuid ([#351](https://github.com/uuidjs/uuid/issues/351)) ([e2d7314](https://github.com/uuidjs/uuid/commit/e2d7314)), closes [#338](https://github.com/uuidjs/uuid/issues/338)

## [3.3.3](https://github.com/uuidjs/uuid/compare/v3.3.2...v3.3.3) (2019-08-19)

### Bug Fixes

- no longer run ci tests on node v4
- upgrade dependencies

## [3.3.2](https://github.com/uuidjs/uuid/compare/v3.3.1...v3.3.2) (2018-06-28)

### Bug Fixes

- typo ([305d877](https://github.com/uuidjs/uuid/commit/305d877))

## [3.3.1](https://github.com/uuidjs/uuid/compare/v3.3.0...v3.3.1) (2018-06-28)

### Bug Fixes

- fix [#284](https://github.com/uuidjs/uuid/issues/284) by setting function name in try-catch ([f2a60f2](https://github.com/uuidjs/uuid/commit/f2a60f2))

# [3.3.0](https://github.com/uuidjs/uuid/compare/v3.2.1...v3.3.0) (2018-06-22)

### Bug Fixes

- assignment to readonly property to allow running in strict mode ([#270](https://github.com/uuidjs/uuid/issues/270)) ([d062fdc](https://github.com/uuidjs/uuid/commit/d062fdc))
- fix [#229](https://github.com/uuidjs/uuid/issues/229) ([c9684d4](https://github.com/uuidjs/uuid/commit/c9684d4))
- Get correct version of IE11 crypto ([#274](https://github.com/uuidjs/uuid/issues/274)) ([153d331](https://github.com/uuidjs/uuid/commit/153d331))
- mem issue when generating uuid ([#267](https://github.com/uuidjs/uuid/issues/267)) ([c47702c](https://github.com/uuidjs/uuid/commit/c47702c))

### Features

- enforce Conventional Commit style commit messages ([#282](https://github.com/uuidjs/uuid/issues/282)) ([cc9a182](https://github.com/uuidjs/uuid/commit/cc9a182))

## [3.2.1](https://github.com/uuidjs/uuid/compare/v3.2.0...v3.2.1) (2018-01-16)

### Bug Fixes

- use msCrypto if available. Fixes [#241](https://github.com/uuidjs/uuid/issues/241) ([#247](https://github.com/uuidjs/uuid/issues/247)) ([1fef18b](https://github.com/uuidjs/uuid/commit/1fef18b))

# [3.2.0](https://github.com/uuidjs/uuid/compare/v3.1.0...v3.2.0) (2018-01-16)

### Bug Fixes

- remove mistakenly added typescript dependency, rollback version (standard-version will auto-increment) ([09fa824](https://github.com/uuidjs/uuid/commit/09fa824))
- use msCrypto if available. Fixes [#241](https://github.com/uuidjs/uuid/issues/241) ([#247](https://github.com/uuidjs/uuid/issues/247)) ([1fef18b](https://github.com/uuidjs/uuid/commit/1fef18b))

### Features

- Add v3 Support ([#217](https://github.com/uuidjs/uuid/issues/217)) ([d94f726](https://github.com/uuidjs/uuid/commit/d94f726))

# [3.1.0](https://github.com/uuidjs/uuid/compare/v3.1.0...v3.0.1) (2017-06-17)

### Bug Fixes

- (fix) Add .npmignore file to exclude test/ and other non-essential files from packing. (#183)
- Fix typo (#178)
- Simple typo fix (#165)

### Features

- v5 support in CLI (#197)
- V5 support (#188)

# 3.0.1 (2016-11-28)

- split uuid versions into separate files

# 3.0.0 (2016-11-17)

- remove .parse and .unparse

# 2.0.0

- Removed uuid.BufferClass

# 1.4.0

- Improved module context detection
- Removed public RNG functions

# 1.3.2

- Improve tests and handling of v1() options (Issue #24)
- Expose RNG option to allow for perf testing with different generators

# 1.3.0

- Support for version 1 ids, thanks to [@ctavan](https://github.com/ctavan)!
- Support for node.js crypto API
- De-emphasizing performance in favor of a) cryptographic quality PRNGs where available and b) more manageable code
# Contributing

Please feel free to file GitHub Issues or propose Pull Requests. We're always happy to discuss improvements to this library!

## Testing

```shell
npm test
```

## Releasing

Releases are supposed to be done from master, version bumping is automated through [`standard-version`](https://github.com/conventional-changelog/standard-version):

```shell
npm run release -- --dry-run  # verify output manually
npm run release               # follow the instructions from the output of this command
```
#!/usr/bin/env node
require('../uuid-bin');
export { default as v1 } from './v1.js';
export { default as v3 } from './v3.js';
export { default as v4 } from './v4.js';
export { default as v5 } from './v5.js';
export { default as NIL } from './nil.js';
export { default as version } from './version.js';
export { default as validate } from './validate.js';
export { default as stringify } from './stringify.js';
export { default as parse } from './parse.js';/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

export default md5;export default '00000000-0000-0000-0000-000000000000';import validate from './validate.js';

function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

export default parse;export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
export default function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

export default sha1;import validate from './validate.js';
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

export default stringify;import rng from './rng.js';
import stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || stringify(b);
}

export default v1;import v35 from './v35.js';
import md5 from './md5.js';
var v3 = v35('v3', 0x30, md5);
export default v3;import stringify from './stringify.js';
import parse from './parse.js';

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

export var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
export var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
export default function (name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = parse(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return stringify(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}import rng from './rng.js';
import stringify from './stringify.js';

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

export default v4;import v35 from './v35.js';
import sha1 from './sha1.js';
var v5 = v35('v5', 0x50, sha1);
export default v5;import REGEX from './regex.js';

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

export default validate;import validate from './validate.js';

function version(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

export default version;export { default as v1 } from './v1.js';
export { default as v3 } from './v3.js';
export { default as v4 } from './v4.js';
export { default as v5 } from './v5.js';
export { default as NIL } from './nil.js';
export { default as version } from './version.js';
export { default as validate } from './validate.js';
export { default as stringify } from './stringify.js';
export { default as parse } from './parse.js';import crypto from 'crypto';

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto.createHash('md5').update(bytes).digest();
}

export default md5;export default '00000000-0000-0000-0000-000000000000';import validate from './validate.js';

function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

export default parse;export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;import crypto from 'crypto';
const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
export default function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}import crypto from 'crypto';

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto.createHash('sha1').update(bytes).digest();
}

export default sha1;import validate from './validate.js';
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

export default stringify;import rng from './rng.js';
import stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || stringify(b);
}

export default v1;import v35 from './v35.js';
import md5 from './md5.js';
const v3 = v35('v3', 0x30, md5);
export default v3;import stringify from './stringify.js';
import parse from './parse.js';

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

export const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
export const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
export default function (name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = parse(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return stringify(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}import rng from './rng.js';
import stringify from './stringify.js';

function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

export default v4;import v35 from './v35.js';
import sha1 from './sha1.js';
const v5 = v35('v5', 0x50, sha1);
export default v5;import REGEX from './regex.js';

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

export default validate;import validate from './validate.js';

function version(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

export default version;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;

var _crypto = _interopRequireDefault(require("crypto"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self).uuid={})}(this,(function(r){"use strict";var e,n=new Uint8Array(16);function t(){if(!e&&!(e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(n)}var o=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function a(r){return"string"==typeof r&&o.test(r)}for(var i,u,f=[],s=0;s<256;++s)f.push((s+256).toString(16).substr(1));function c(r){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=(f[r[e+0]]+f[r[e+1]]+f[r[e+2]]+f[r[e+3]]+"-"+f[r[e+4]]+f[r[e+5]]+"-"+f[r[e+6]]+f[r[e+7]]+"-"+f[r[e+8]]+f[r[e+9]]+"-"+f[r[e+10]]+f[r[e+11]]+f[r[e+12]]+f[r[e+13]]+f[r[e+14]]+f[r[e+15]]).toLowerCase();if(!a(n))throw TypeError("Stringified UUID is invalid");return n}var l=0,d=0;function v(r){if(!a(r))throw TypeError("Invalid UUID");var e,n=new Uint8Array(16);return n[0]=(e=parseInt(r.slice(0,8),16))>>>24,n[1]=e>>>16&255,n[2]=e>>>8&255,n[3]=255&e,n[4]=(e=parseInt(r.slice(9,13),16))>>>8,n[5]=255&e,n[6]=(e=parseInt(r.slice(14,18),16))>>>8,n[7]=255&e,n[8]=(e=parseInt(r.slice(19,23),16))>>>8,n[9]=255&e,n[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,n[11]=e/4294967296&255,n[12]=e>>>24&255,n[13]=e>>>16&255,n[14]=e>>>8&255,n[15]=255&e,n}function p(r,e,n){function t(r,t,o,a){if("string"==typeof r&&(r=function(r){r=unescape(encodeURIComponent(r));for(var e=[],n=0;n<r.length;++n)e.push(r.charCodeAt(n));return e}(r)),"string"==typeof t&&(t=v(t)),16!==t.length)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var i=new Uint8Array(16+r.length);if(i.set(t),i.set(r,t.length),(i=n(i))[6]=15&i[6]|e,i[8]=63&i[8]|128,o){a=a||0;for(var u=0;u<16;++u)o[a+u]=i[u];return o}return c(i)}try{t.name=r}catch(r){}return t.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",t.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",t}function h(r){return 14+(r+64>>>9<<4)+1}function y(r,e){var n=(65535&r)+(65535&e);return(r>>16)+(e>>16)+(n>>16)<<16|65535&n}function g(r,e,n,t,o,a){return y((i=y(y(e,r),y(t,a)))<<(u=o)|i>>>32-u,n);var i,u}function m(r,e,n,t,o,a,i){return g(e&n|~e&t,r,e,o,a,i)}function w(r,e,n,t,o,a,i){return g(e&t|n&~t,r,e,o,a,i)}function b(r,e,n,t,o,a,i){return g(e^n^t,r,e,o,a,i)}function A(r,e,n,t,o,a,i){return g(n^(e|~t),r,e,o,a,i)}var U=p("v3",48,(function(r){if("string"==typeof r){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var n=0;n<e.length;++n)r[n]=e.charCodeAt(n)}return function(r){for(var e=[],n=32*r.length,t="0123456789abcdef",o=0;o<n;o+=8){var a=r[o>>5]>>>o%32&255,i=parseInt(t.charAt(a>>>4&15)+t.charAt(15&a),16);e.push(i)}return e}(function(r,e){r[e>>5]|=128<<e%32,r[h(e)-1]=e;for(var n=1732584193,t=-271733879,o=-1732584194,a=271733878,i=0;i<r.length;i+=16){var u=n,f=t,s=o,c=a;n=m(n,t,o,a,r[i],7,-680876936),a=m(a,n,t,o,r[i+1],12,-389564586),o=m(o,a,n,t,r[i+2],17,606105819),t=m(t,o,a,n,r[i+3],22,-1044525330),n=m(n,t,o,a,r[i+4],7,-176418897),a=m(a,n,t,o,r[i+5],12,1200080426),o=m(o,a,n,t,r[i+6],17,-1473231341),t=m(t,o,a,n,r[i+7],22,-45705983),n=m(n,t,o,a,r[i+8],7,1770035416),a=m(a,n,t,o,r[i+9],12,-1958414417),o=m(o,a,n,t,r[i+10],17,-42063),t=m(t,o,a,n,r[i+11],22,-1990404162),n=m(n,t,o,a,r[i+12],7,1804603682),a=m(a,n,t,o,r[i+13],12,-40341101),o=m(o,a,n,t,r[i+14],17,-1502002290),n=w(n,t=m(t,o,a,n,r[i+15],22,1236535329),o,a,r[i+1],5,-165796510),a=w(a,n,t,o,r[i+6],9,-1069501632),o=w(o,a,n,t,r[i+11],14,643717713),t=w(t,o,a,n,r[i],20,-373897302),n=w(n,t,o,a,r[i+5],5,-701558691),a=w(a,n,t,o,r[i+10],9,38016083),o=w(o,a,n,t,r[i+15],14,-660478335),t=w(t,o,a,n,r[i+4],20,-405537848),n=w(n,t,o,a,r[i+9],5,568446438),a=w(a,n,t,o,r[i+14],9,-1019803690),o=w(o,a,n,t,r[i+3],14,-187363961),t=w(t,o,a,n,r[i+8],20,1163531501),n=w(n,t,o,a,r[i+13],5,-1444681467),a=w(a,n,t,o,r[i+2],9,-51403784),o=w(o,a,n,t,r[i+7],14,1735328473),n=b(n,t=w(t,o,a,n,r[i+12],20,-1926607734),o,a,r[i+5],4,-378558),a=b(a,n,t,o,r[i+8],11,-2022574463),o=b(o,a,n,t,r[i+11],16,1839030562),t=b(t,o,a,n,r[i+14],23,-35309556),n=b(n,t,o,a,r[i+1],4,-1530992060),a=b(a,n,t,o,r[i+4],11,1272893353),o=b(o,a,n,t,r[i+7],16,-155497632),t=b(t,o,a,n,r[i+10],23,-1094730640),n=b(n,t,o,a,r[i+13],4,681279174),a=b(a,n,t,o,r[i],11,-358537222),o=b(o,a,n,t,r[i+3],16,-722521979),t=b(t,o,a,n,r[i+6],23,76029189),n=b(n,t,o,a,r[i+9],4,-640364487),a=b(a,n,t,o,r[i+12],11,-421815835),o=b(o,a,n,t,r[i+15],16,530742520),n=A(n,t=b(t,o,a,n,r[i+2],23,-995338651),o,a,r[i],6,-198630844),a=A(a,n,t,o,r[i+7],10,1126891415),o=A(o,a,n,t,r[i+14],15,-1416354905),t=A(t,o,a,n,r[i+5],21,-57434055),n=A(n,t,o,a,r[i+12],6,1700485571),a=A(a,n,t,o,r[i+3],10,-1894986606),o=A(o,a,n,t,r[i+10],15,-1051523),t=A(t,o,a,n,r[i+1],21,-2054922799),n=A(n,t,o,a,r[i+8],6,1873313359),a=A(a,n,t,o,r[i+15],10,-30611744),o=A(o,a,n,t,r[i+6],15,-1560198380),t=A(t,o,a,n,r[i+13],21,1309151649),n=A(n,t,o,a,r[i+4],6,-145523070),a=A(a,n,t,o,r[i+11],10,-1120210379),o=A(o,a,n,t,r[i+2],15,718787259),t=A(t,o,a,n,r[i+9],21,-343485551),n=y(n,u),t=y(t,f),o=y(o,s),a=y(a,c)}return[n,t,o,a]}(function(r){if(0===r.length)return[];for(var e=8*r.length,n=new Uint32Array(h(e)),t=0;t<e;t+=8)n[t>>5]|=(255&r[t/8])<<t%32;return n}(r),8*r.length))}));function I(r,e,n,t){switch(r){case 0:return e&n^~e&t;case 1:return e^n^t;case 2:return e&n^e&t^n&t;case 3:return e^n^t}}function C(r,e){return r<<e|r>>>32-e}var R=p("v5",80,(function(r){var e=[1518500249,1859775393,2400959708,3395469782],n=[1732584193,4023233417,2562383102,271733878,3285377520];if("string"==typeof r){var t=unescape(encodeURIComponent(r));r=[];for(var o=0;o<t.length;++o)r.push(t.charCodeAt(o))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var a=r.length/4+2,i=Math.ceil(a/16),u=new Array(i),f=0;f<i;++f){for(var s=new Uint32Array(16),c=0;c<16;++c)s[c]=r[64*f+4*c]<<24|r[64*f+4*c+1]<<16|r[64*f+4*c+2]<<8|r[64*f+4*c+3];u[f]=s}u[i-1][14]=8*(r.length-1)/Math.pow(2,32),u[i-1][14]=Math.floor(u[i-1][14]),u[i-1][15]=8*(r.length-1)&4294967295;for(var l=0;l<i;++l){for(var d=new Uint32Array(80),v=0;v<16;++v)d[v]=u[l][v];for(var p=16;p<80;++p)d[p]=C(d[p-3]^d[p-8]^d[p-14]^d[p-16],1);for(var h=n[0],y=n[1],g=n[2],m=n[3],w=n[4],b=0;b<80;++b){var A=Math.floor(b/20),U=C(h,5)+I(A,y,g,m)+w+e[A]+d[b]>>>0;w=m,m=g,g=C(y,30)>>>0,y=h,h=U}n[0]=n[0]+h>>>0,n[1]=n[1]+y>>>0,n[2]=n[2]+g>>>0,n[3]=n[3]+m>>>0,n[4]=n[4]+w>>>0}return[n[0]>>24&255,n[0]>>16&255,n[0]>>8&255,255&n[0],n[1]>>24&255,n[1]>>16&255,n[1]>>8&255,255&n[1],n[2]>>24&255,n[2]>>16&255,n[2]>>8&255,255&n[2],n[3]>>24&255,n[3]>>16&255,n[3]>>8&255,255&n[3],n[4]>>24&255,n[4]>>16&255,n[4]>>8&255,255&n[4]]}));r.NIL="00000000-0000-0000-0000-000000000000",r.parse=v,r.stringify=c,r.v1=function(r,e,n){var o=e&&n||0,a=e||new Array(16),f=(r=r||{}).node||i,s=void 0!==r.clockseq?r.clockseq:u;if(null==f||null==s){var v=r.random||(r.rng||t)();null==f&&(f=i=[1|v[0],v[1],v[2],v[3],v[4],v[5]]),null==s&&(s=u=16383&(v[6]<<8|v[7]))}var p=void 0!==r.msecs?r.msecs:Date.now(),h=void 0!==r.nsecs?r.nsecs:d+1,y=p-l+(h-d)/1e4;if(y<0&&void 0===r.clockseq&&(s=s+1&16383),(y<0||p>l)&&void 0===r.nsecs&&(h=0),h>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");l=p,d=h,u=s;var g=(1e4*(268435455&(p+=122192928e5))+h)%4294967296;a[o++]=g>>>24&255,a[o++]=g>>>16&255,a[o++]=g>>>8&255,a[o++]=255&g;var m=p/4294967296*1e4&268435455;a[o++]=m>>>8&255,a[o++]=255&m,a[o++]=m>>>24&15|16,a[o++]=m>>>16&255,a[o++]=s>>>8|128,a[o++]=255&s;for(var w=0;w<6;++w)a[o+w]=f[w];return e||c(a)},r.v3=U,r.v4=function(r,e,n){var o=(r=r||{}).random||(r.rng||t)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,e){n=n||0;for(var a=0;a<16;++a)e[n+a]=o[a];return e}return c(o)},r.v5=R,r.validate=a,r.version=function(r){if(!a(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)},Object.defineProperty(r,"__esModule",{value:!0})}));!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).uuidNIL=n()}(this,(function(){"use strict";return"00000000-0000-0000-0000-000000000000"}));!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).uuidParse=n()}(this,(function(){"use strict";var e=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;return function(n){if(!function(n){return"string"==typeof n&&e.test(n)}(n))throw TypeError("Invalid UUID");var t,i=new Uint8Array(16);return i[0]=(t=parseInt(n.slice(0,8),16))>>>24,i[1]=t>>>16&255,i[2]=t>>>8&255,i[3]=255&t,i[4]=(t=parseInt(n.slice(9,13),16))>>>8,i[5]=255&t,i[6]=(t=parseInt(n.slice(14,18),16))>>>8,i[7]=255&t,i[8]=(t=parseInt(n.slice(19,23),16))>>>8,i[9]=255&t,i[10]=(t=parseInt(n.slice(24,36),16))/1099511627776&255,i[11]=t/4294967296&255,i[12]=t>>>24&255,i[13]=t>>>16&255,i[14]=t>>>8&255,i[15]=255&t,i}}));!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).uuidStringify=t()}(this,(function(){"use strict";var e=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function t(t){return"string"==typeof t&&e.test(t)}for(var i=[],n=0;n<256;++n)i.push((n+256).toString(16).substr(1));return function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=(i[e[n+0]]+i[e[n+1]]+i[e[n+2]]+i[e[n+3]]+"-"+i[e[n+4]]+i[e[n+5]]+"-"+i[e[n+6]]+i[e[n+7]]+"-"+i[e[n+8]]+i[e[n+9]]+"-"+i[e[n+10]]+i[e[n+11]]+i[e[n+12]]+i[e[n+13]]+i[e[n+14]]+i[e[n+15]]).toLowerCase();if(!t(f))throw TypeError("Stringified UUID is invalid");return f}}));!function(e,o){"object"==typeof exports&&"undefined"!=typeof module?module.exports=o():"function"==typeof define&&define.amd?define(o):(e="undefined"!=typeof globalThis?globalThis:e||self).uuidv1=o()}(this,(function(){"use strict";var e,o=new Uint8Array(16);function t(){if(!e&&!(e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(o)}var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function r(e){return"string"==typeof e&&n.test(e)}for(var i,u,s=[],a=0;a<256;++a)s.push((a+256).toString(16).substr(1));var d=0,f=0;return function(e,o,n){var a=o&&n||0,c=o||new Array(16),l=(e=e||{}).node||i,p=void 0!==e.clockseq?e.clockseq:u;if(null==l||null==p){var v=e.random||(e.rng||t)();null==l&&(l=i=[1|v[0],v[1],v[2],v[3],v[4],v[5]]),null==p&&(p=u=16383&(v[6]<<8|v[7]))}var y=void 0!==e.msecs?e.msecs:Date.now(),m=void 0!==e.nsecs?e.nsecs:f+1,g=y-d+(m-f)/1e4;if(g<0&&void 0===e.clockseq&&(p=p+1&16383),(g<0||y>d)&&void 0===e.nsecs&&(m=0),m>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");d=y,f=m,u=p;var h=(1e4*(268435455&(y+=122192928e5))+m)%4294967296;c[a++]=h>>>24&255,c[a++]=h>>>16&255,c[a++]=h>>>8&255,c[a++]=255&h;var w=y/4294967296*1e4&268435455;c[a++]=w>>>8&255,c[a++]=255&w,c[a++]=w>>>24&15|16,c[a++]=w>>>16&255,c[a++]=p>>>8|128,c[a++]=255&p;for(var b=0;b<6;++b)c[a+b]=l[b];return o||function(e){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=(s[e[o+0]]+s[e[o+1]]+s[e[o+2]]+s[e[o+3]]+"-"+s[e[o+4]]+s[e[o+5]]+"-"+s[e[o+6]]+s[e[o+7]]+"-"+s[e[o+8]]+s[e[o+9]]+"-"+s[e[o+10]]+s[e[o+11]]+s[e[o+12]]+s[e[o+13]]+s[e[o+14]]+s[e[o+15]]).toLowerCase();if(!r(t))throw TypeError("Stringified UUID is invalid");return t}(c)}}));!function(n,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(n="undefined"!=typeof globalThis?globalThis:n||self).uuidv3=r()}(this,(function(){"use strict";var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function r(r){return"string"==typeof r&&n.test(r)}for(var e=[],t=0;t<256;++t)e.push((t+256).toString(16).substr(1));function i(n){return 14+(n+64>>>9<<4)+1}function o(n,r){var e=(65535&n)+(65535&r);return(n>>16)+(r>>16)+(e>>16)<<16|65535&e}function a(n,r,e,t,i,a){return o((f=o(o(r,n),o(t,a)))<<(u=i)|f>>>32-u,e);var f,u}function f(n,r,e,t,i,o,f){return a(r&e|~r&t,n,r,i,o,f)}function u(n,r,e,t,i,o,f){return a(r&t|e&~t,n,r,i,o,f)}function c(n,r,e,t,i,o,f){return a(r^e^t,n,r,i,o,f)}function s(n,r,e,t,i,o,f){return a(e^(r|~t),n,r,i,o,f)}return function(n,t,i){function o(n,o,a,f){if("string"==typeof n&&(n=function(n){n=unescape(encodeURIComponent(n));for(var r=[],e=0;e<n.length;++e)r.push(n.charCodeAt(e));return r}(n)),"string"==typeof o&&(o=function(n){if(!r(n))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(n.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=255&e,t[4]=(e=parseInt(n.slice(9,13),16))>>>8,t[5]=255&e,t[6]=(e=parseInt(n.slice(14,18),16))>>>8,t[7]=255&e,t[8]=(e=parseInt(n.slice(19,23),16))>>>8,t[9]=255&e,t[10]=(e=parseInt(n.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=255&e,t}(o)),16!==o.length)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var u=new Uint8Array(16+n.length);if(u.set(o),u.set(n,o.length),(u=i(u))[6]=15&u[6]|t,u[8]=63&u[8]|128,a){f=f||0;for(var c=0;c<16;++c)a[f+c]=u[c];return a}return function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=(e[n[t+0]]+e[n[t+1]]+e[n[t+2]]+e[n[t+3]]+"-"+e[n[t+4]]+e[n[t+5]]+"-"+e[n[t+6]]+e[n[t+7]]+"-"+e[n[t+8]]+e[n[t+9]]+"-"+e[n[t+10]]+e[n[t+11]]+e[n[t+12]]+e[n[t+13]]+e[n[t+14]]+e[n[t+15]]).toLowerCase();if(!r(i))throw TypeError("Stringified UUID is invalid");return i}(u)}try{o.name=n}catch(n){}return o.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",o.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",o}("v3",48,(function(n){if("string"==typeof n){var r=unescape(encodeURIComponent(n));n=new Uint8Array(r.length);for(var e=0;e<r.length;++e)n[e]=r.charCodeAt(e)}return function(n){for(var r=[],e=32*n.length,t="0123456789abcdef",i=0;i<e;i+=8){var o=n[i>>5]>>>i%32&255,a=parseInt(t.charAt(o>>>4&15)+t.charAt(15&o),16);r.push(a)}return r}(function(n,r){n[r>>5]|=128<<r%32,n[i(r)-1]=r;for(var e=1732584193,t=-271733879,a=-1732584194,l=271733878,d=0;d<n.length;d+=16){var p=e,h=t,v=a,g=l;e=f(e,t,a,l,n[d],7,-680876936),l=f(l,e,t,a,n[d+1],12,-389564586),a=f(a,l,e,t,n[d+2],17,606105819),t=f(t,a,l,e,n[d+3],22,-1044525330),e=f(e,t,a,l,n[d+4],7,-176418897),l=f(l,e,t,a,n[d+5],12,1200080426),a=f(a,l,e,t,n[d+6],17,-1473231341),t=f(t,a,l,e,n[d+7],22,-45705983),e=f(e,t,a,l,n[d+8],7,1770035416),l=f(l,e,t,a,n[d+9],12,-1958414417),a=f(a,l,e,t,n[d+10],17,-42063),t=f(t,a,l,e,n[d+11],22,-1990404162),e=f(e,t,a,l,n[d+12],7,1804603682),l=f(l,e,t,a,n[d+13],12,-40341101),a=f(a,l,e,t,n[d+14],17,-1502002290),e=u(e,t=f(t,a,l,e,n[d+15],22,1236535329),a,l,n[d+1],5,-165796510),l=u(l,e,t,a,n[d+6],9,-1069501632),a=u(a,l,e,t,n[d+11],14,643717713),t=u(t,a,l,e,n[d],20,-373897302),e=u(e,t,a,l,n[d+5],5,-701558691),l=u(l,e,t,a,n[d+10],9,38016083),a=u(a,l,e,t,n[d+15],14,-660478335),t=u(t,a,l,e,n[d+4],20,-405537848),e=u(e,t,a,l,n[d+9],5,568446438),l=u(l,e,t,a,n[d+14],9,-1019803690),a=u(a,l,e,t,n[d+3],14,-187363961),t=u(t,a,l,e,n[d+8],20,1163531501),e=u(e,t,a,l,n[d+13],5,-1444681467),l=u(l,e,t,a,n[d+2],9,-51403784),a=u(a,l,e,t,n[d+7],14,1735328473),e=c(e,t=u(t,a,l,e,n[d+12],20,-1926607734),a,l,n[d+5],4,-378558),l=c(l,e,t,a,n[d+8],11,-2022574463),a=c(a,l,e,t,n[d+11],16,1839030562),t=c(t,a,l,e,n[d+14],23,-35309556),e=c(e,t,a,l,n[d+1],4,-1530992060),l=c(l,e,t,a,n[d+4],11,1272893353),a=c(a,l,e,t,n[d+7],16,-155497632),t=c(t,a,l,e,n[d+10],23,-1094730640),e=c(e,t,a,l,n[d+13],4,681279174),l=c(l,e,t,a,n[d],11,-358537222),a=c(a,l,e,t,n[d+3],16,-722521979),t=c(t,a,l,e,n[d+6],23,76029189),e=c(e,t,a,l,n[d+9],4,-640364487),l=c(l,e,t,a,n[d+12],11,-421815835),a=c(a,l,e,t,n[d+15],16,530742520),e=s(e,t=c(t,a,l,e,n[d+2],23,-995338651),a,l,n[d],6,-198630844),l=s(l,e,t,a,n[d+7],10,1126891415),a=s(a,l,e,t,n[d+14],15,-1416354905),t=s(t,a,l,e,n[d+5],21,-57434055),e=s(e,t,a,l,n[d+12],6,1700485571),l=s(l,e,t,a,n[d+3],10,-1894986606),a=s(a,l,e,t,n[d+10],15,-1051523),t=s(t,a,l,e,n[d+1],21,-2054922799),e=s(e,t,a,l,n[d+8],6,1873313359),l=s(l,e,t,a,n[d+15],10,-30611744),a=s(a,l,e,t,n[d+6],15,-1560198380),t=s(t,a,l,e,n[d+13],21,1309151649),e=s(e,t,a,l,n[d+4],6,-145523070),l=s(l,e,t,a,n[d+11],10,-1120210379),a=s(a,l,e,t,n[d+2],15,718787259),t=s(t,a,l,e,n[d+9],21,-343485551),e=o(e,p),t=o(t,h),a=o(a,v),l=o(l,g)}return[e,t,a,l]}(function(n){if(0===n.length)return[];for(var r=8*n.length,e=new Uint32Array(i(r)),t=0;t<r;t+=8)e[t>>5]|=(255&n[t/8])<<t%32;return e}(n),8*n.length))}))}));!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).uuidv4=e()}(this,(function(){"use strict";var t,e=new Uint8Array(16);function o(){if(!t&&!(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function r(t){return"string"==typeof t&&n.test(t)}for(var i=[],u=0;u<256;++u)i.push((u+256).toString(16).substr(1));return function(t,e,n){var u=(t=t||{}).random||(t.rng||o)();if(u[6]=15&u[6]|64,u[8]=63&u[8]|128,e){n=n||0;for(var f=0;f<16;++f)e[n+f]=u[f];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=(i[t[e+0]]+i[t[e+1]]+i[t[e+2]]+i[t[e+3]]+"-"+i[t[e+4]]+i[t[e+5]]+"-"+i[t[e+6]]+i[t[e+7]]+"-"+i[t[e+8]]+i[t[e+9]]+"-"+i[t[e+10]]+i[t[e+11]]+i[t[e+12]]+i[t[e+13]]+i[t[e+14]]+i[t[e+15]]).toLowerCase();if(!r(o))throw TypeError("Stringified UUID is invalid");return o}(u)}}));!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(r="undefined"!=typeof globalThis?globalThis:r||self).uuidv5=e()}(this,(function(){"use strict";var r=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function e(e){return"string"==typeof e&&r.test(e)}for(var t=[],n=0;n<256;++n)t.push((n+256).toString(16).substr(1));function a(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function o(r,e){return r<<e|r>>>32-e}return function(r,n,a){function o(r,o,i,f){if("string"==typeof r&&(r=function(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}(r)),"string"==typeof o&&(o=function(r){if(!e(r))throw TypeError("Invalid UUID");var t,n=new Uint8Array(16);return n[0]=(t=parseInt(r.slice(0,8),16))>>>24,n[1]=t>>>16&255,n[2]=t>>>8&255,n[3]=255&t,n[4]=(t=parseInt(r.slice(9,13),16))>>>8,n[5]=255&t,n[6]=(t=parseInt(r.slice(14,18),16))>>>8,n[7]=255&t,n[8]=(t=parseInt(r.slice(19,23),16))>>>8,n[9]=255&t,n[10]=(t=parseInt(r.slice(24,36),16))/1099511627776&255,n[11]=t/4294967296&255,n[12]=t>>>24&255,n[13]=t>>>16&255,n[14]=t>>>8&255,n[15]=255&t,n}(o)),16!==o.length)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var s=new Uint8Array(16+r.length);if(s.set(o),s.set(r,o.length),(s=a(s))[6]=15&s[6]|n,s[8]=63&s[8]|128,i){f=f||0;for(var u=0;u<16;++u)i[f+u]=s[u];return i}return function(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=(t[r[n+0]]+t[r[n+1]]+t[r[n+2]]+t[r[n+3]]+"-"+t[r[n+4]]+t[r[n+5]]+"-"+t[r[n+6]]+t[r[n+7]]+"-"+t[r[n+8]]+t[r[n+9]]+"-"+t[r[n+10]]+t[r[n+11]]+t[r[n+12]]+t[r[n+13]]+t[r[n+14]]+t[r[n+15]]).toLowerCase();if(!e(a))throw TypeError("Stringified UUID is invalid");return a}(s)}try{o.name=r}catch(r){}return o.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",o.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",o}("v5",80,(function(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if("string"==typeof r){var n=unescape(encodeURIComponent(r));r=[];for(var i=0;i<n.length;++i)r.push(n.charCodeAt(i))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var f=r.length/4+2,s=Math.ceil(f/16),u=new Array(s),c=0;c<s;++c){for(var l=new Uint32Array(16),p=0;p<16;++p)l[p]=r[64*c+4*p]<<24|r[64*c+4*p+1]<<16|r[64*c+4*p+2]<<8|r[64*c+4*p+3];u[c]=l}u[s-1][14]=8*(r.length-1)/Math.pow(2,32),u[s-1][14]=Math.floor(u[s-1][14]),u[s-1][15]=8*(r.length-1)&4294967295;for(var d=0;d<s;++d){for(var h=new Uint32Array(80),v=0;v<16;++v)h[v]=u[d][v];for(var y=16;y<80;++y)h[y]=o(h[y-3]^h[y-8]^h[y-14]^h[y-16],1);for(var g=t[0],b=t[1],w=t[2],U=t[3],A=t[4],I=0;I<80;++I){var m=Math.floor(I/20),C=o(g,5)+a(m,b,w,U)+A+e[m]+h[I]>>>0;A=U,U=w,w=o(b,30)>>>0,b=g,g=C}t[0]=t[0]+g>>>0,t[1]=t[1]+b>>>0,t[2]=t[2]+w>>>0,t[3]=t[3]+U>>>0,t[4]=t[4]+A>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,255&t[0],t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,255&t[1],t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,255&t[2],t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,255&t[3],t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,255&t[4]]}))}));!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).uuidValidate=t()}(this,(function(){"use strict";var e=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;return function(t){return"string"==typeof t&&e.test(t)}}));!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).uuidVersion=t()}(this,(function(){"use strict";var e=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;return function(t){if(!function(t){return"string"==typeof t&&e.test(t)}(t))throw TypeError("Invalid UUID");return parseInt(t.substr(14,1),16)}}));"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function usage() {
  console.log('Usage:');
  console.log('  uuid');
  console.log('  uuid v1');
  console.log('  uuid v3 <name> <namespace uuid>');
  console.log('  uuid v4');
  console.log('  uuid v5 <name> <namespace uuid>');
  console.log('  uuid --help');
  console.log('\nNote: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs defined by RFC4122');
}

const args = process.argv.slice(2);

if (args.indexOf('--help') >= 0) {
  usage();
  process.exit(0);
}

const version = args.shift() || 'v4';

switch (version) {
  case 'v1':
    console.log((0, _v.default)());
    break;

  case 'v3':
    {
      const name = args.shift();
      let namespace = args.shift();
      (0, _assert.default)(name != null, 'v3 name not specified');
      (0, _assert.default)(namespace != null, 'v3 namespace not specified');

      if (namespace === 'URL') {
        namespace = _v2.default.URL;
      }

      if (namespace === 'DNS') {
        namespace = _v2.default.DNS;
      }

      console.log((0, _v2.default)(name, namespace));
      break;
    }

  case 'v4':
    console.log((0, _v3.default)());
    break;

  case 'v5':
    {
      const name = args.shift();
      let namespace = args.shift();
      (0, _assert.default)(name != null, 'v5 name not specified');
      (0, _assert.default)(namespace != null, 'v5 namespace not specified');

      if (namespace === 'URL') {
        namespace = _v4.default.URL;
      }

      if (namespace === 'DNS') {
        namespace = _v4.default.DNS;
      }

      console.log((0, _v4.default)(name, namespace));
      break;
    }

  default:
    usage();
    process.exit(1);
}"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;The MIT License (MIT)

Copyright (c) 2010-2020 Robert Kieffer and other contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{
  "name": "uuid",
  "version": "8.3.2",
  "description": "RFC4122 (v1, v4, and v5) UUIDs",
  "commitlint": {
    "extends": [
      "@commitlint/config-conventional"
    ]
  },
  "keywords": [
    "uuid",
    "guid",
    "rfc4122"
  ],
  "license": "MIT",
  "bin": {
    "uuid": "./dist/bin/uuid"
  },
  "sideEffects": false,
  "main": "./dist/index.js",
  "exports": {
    ".": {
      "node": {
        "module": "./dist/esm-node/index.js",
        "require": "./dist/index.js",
        "import": "./wrapper.mjs"
      },
      "default": "./dist/esm-browser/index.js"
    },
    "./package.json": "./package.json"
  },
  "module": "./dist/esm-node/index.js",
  "browser": {
    "./dist/md5.js": "./dist/md5-browser.js",
    "./dist/rng.js": "./dist/rng-browser.js",
    "./dist/sha1.js": "./dist/sha1-browser.js",
    "./dist/esm-node/index.js": "./dist/esm-browser/index.js"
  },
  "files": [
    "CHANGELOG.md",
    "CONTRIBUTING.md",
    "LICENSE.md",
    "README.md",
    "dist",
    "wrapper.mjs"
  ],
  "devDependencies": {
    "@babel/cli": "7.11.6",
    "@babel/core": "7.11.6",
    "@babel/preset-env": "7.11.5",
    "@commitlint/cli": "11.0.0",
    "@commitlint/config-conventional": "11.0.0",
    "@rollup/plugin-node-resolve": "9.0.0",
    "babel-eslint": "10.1.0",
    "bundlewatch": "0.3.1",
    "eslint": "7.10.0",
    "eslint-config-prettier": "6.12.0",
    "eslint-config-standard": "14.1.1",
    "eslint-plugin-import": "2.22.1",
    "eslint-plugin-node": "11.1.0",
    "eslint-plugin-prettier": "3.1.4",
    "eslint-plugin-promise": "4.2.1",
    "eslint-plugin-standard": "4.0.1",
    "husky": "4.3.0",
    "jest": "25.5.4",
    "lint-staged": "10.4.0",
    "npm-run-all": "4.1.5",
    "optional-dev-dependency": "2.0.1",
    "prettier": "2.1.2",
    "random-seed": "0.3.0",
    "rollup": "2.28.2",
    "rollup-plugin-terser": "7.0.2",
    "runmd": "1.3.2",
    "standard-version": "9.0.0"
  },
  "optionalDevDependencies": {
    "@wdio/browserstack-service": "6.4.0",
    "@wdio/cli": "6.4.0",
    "@wdio/jasmine-framework": "6.4.0",
    "@wdio/local-runner": "6.4.0",
    "@wdio/spec-reporter": "6.4.0",
    "@wdio/static-server-service": "6.4.0",
    "@wdio/sync": "6.4.0"
  },
  "scripts": {
    "examples:browser:webpack:build": "cd examples/browser-webpack && npm install && npm run build",
    "examples:browser:rollup:build": "cd examples/browser-rollup && npm install && npm run build",
    "examples:node:commonjs:test": "cd examples/node-commonjs && npm install && npm test",
    "examples:node:esmodules:test": "cd examples/node-esmodules && npm install && npm test",
    "lint": "npm run eslint:check && npm run prettier:check",
    "eslint:check": "eslint src/ test/ examples/ *.js",
    "eslint:fix": "eslint --fix src/ test/ examples/ *.js",
    "pretest": "[ -n $CI ] || npm run build",
    "test": "BABEL_ENV=commonjs node --throw-deprecation node_modules/.bin/jest test/unit/",
    "pretest:browser": "optional-dev-dependency && npm run build && npm-run-all --parallel examples:browser:**",
    "test:browser": "wdio run ./wdio.conf.js",
    "pretest:node": "npm run build",
    "test:node": "npm-run-all --parallel examples:node:**",
    "test:pack": "./scripts/testpack.sh",
    "pretest:benchmark": "npm run build",
    "test:benchmark": "cd examples/benchmark && npm install && npm test",
    "prettier:check": "prettier --ignore-path .prettierignore --check '**/*.{js,jsx,json,md}'",
    "prettier:fix": "prettier --ignore-path .prettierignore --write '**/*.{js,jsx,json,md}'",
    "bundlewatch": "npm run pretest:browser && bundlewatch --config bundlewatch.config.json",
    "md": "runmd --watch --output=README.md README_js.md",
    "docs": "( node --version | grep -q 'v12' ) && ( npm run build && runmd --output=README.md README_js.md )",
    "docs:diff": "npm run docs && git diff --quiet README.md",
    "build": "./scripts/build.sh",
    "prepack": "npm run build",
    "release": "standard-version --no-verify"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/uuidjs/uuid.git"
  },
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{js,jsx,json,md}": [
      "prettier --write"
    ],
    "*.{js,jsx}": [
      "eslint --fix"
    ]
  },
  "standard-version": {
    "scripts": {
      "postchangelog": "prettier --write CHANGELOG.md"
    }
  }
}
<!--
  -- This file is auto-generated from README_js.md. Changes should be made there.
  -->

# uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Browser](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ABrowser)

For the creation of [RFC4122](http://www.ietf.org/rfc/rfc4122.txt) UUIDs

- **Complete** - Support for RFC4122 version 1, 3, 4, and 5 UUIDs
- **Cross-platform** - Support for ...
  - CommonJS, [ECMAScript Modules](#ecmascript-modules) and [CDN builds](#cdn-builds)
  - Node 8, 10, 12, 14
  - Chrome, Safari, Firefox, Edge, IE 11 browsers
  - Webpack and rollup.js module bundlers
  - [React Native / Expo](#react-native--expo)
- **Secure** - Cryptographically-strong random values
- **Small** - Zero-dependency, small footprint, plays nice with "tree shaking" packagers
- **CLI** - Includes the [`uuid` command line](#command-line) utility

**Upgrading from `uuid@3.x`?** Your code is probably okay, but check out [Upgrading From `uuid@3.x`](#upgrading-from-uuid3x) for details.

## Quickstart

To create a random UUID...

**1. Install**

```shell
npm install uuid
```

**2. Create a UUID** (ES6 module syntax)

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

... or using CommonJS syntax:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

For timestamp UUIDs, namespace UUIDs, and other options read on ...

## API Summary

|  |  |  |
| --- | --- | --- |
| [`uuid.NIL`](#uuidnil) | The nil UUID string (all zeros) | New in `uuid@8.3` |
| [`uuid.parse()`](#uuidparsestr) | Convert UUID string to array of bytes | New in `uuid@8.3` |
| [`uuid.stringify()`](#uuidstringifyarr-offset) | Convert array of bytes to UUID string | New in `uuid@8.3` |
| [`uuid.v1()`](#uuidv1options-buffer-offset) | Create a version 1 (timestamp) UUID |  |
| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | Create a version 3 (namespace w/ MD5) UUID |  |
| [`uuid.v4()`](#uuidv4options-buffer-offset) | Create a version 4 (random) UUID |  |
| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | Create a version 5 (namespace w/ SHA-1) UUID |  |
| [`uuid.validate()`](#uuidvalidatestr) | Test a string to see if it is a valid UUID | New in `uuid@8.3` |
| [`uuid.version()`](#uuidversionstr) | Detect RFC version of a UUID | New in `uuid@8.3` |

## API

### uuid.NIL

The nil UUID string (all zeros).

Example:

```javascript
import { NIL as NIL_UUID } from 'uuid';

NIL_UUID; // ⇨ '00000000-0000-0000-0000-000000000000'
```

### uuid.parse(str)

Convert UUID string to array of bytes

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | A valid UUID `String`                    |
| _returns_ | `Uint8Array[16]`                         |
| _throws_  | `TypeError` if `str` is not a valid UUID |

Note: Ordering of values in the byte arrays used by `parse()` and `stringify()` follows the left &Rarr; right order of hex-pairs in UUID strings. As shown in the example below.

Example:

```javascript
import { parse as uuidParse } from 'uuid';

// Parse a UUID
const bytes = uuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b');

// Convert to hex strings to show byte order (for documentation purposes)
[...bytes].map((v) => v.toString(16).padStart(2, '0')); // ⇨ 
  // [
  //   '6e', 'c0', 'bd', '7f',
  //   '11', 'c0', '43', 'da',
  //   '97', '5e', '2a', '8a',
  //   'd9', 'eb', 'ae', '0b'
  // ]
```

### uuid.stringify(arr[, offset])

Convert array of bytes to UUID string

|                |                                                                              |
| -------------- | ---------------------------------------------------------------------------- |
| `arr`          | `Array`-like collection of 16 values (starting from `offset`) between 0-255. |
| [`offset` = 0] | `Number` Starting index in the Array                                         |
| _returns_      | `String`                                                                     |
| _throws_       | `TypeError` if a valid UUID string cannot be generated                       |

Note: Ordering of values in the byte arrays used by `parse()` and `stringify()` follows the left &Rarr; right order of hex-pairs in UUID strings. As shown in the example below.

Example:

```javascript
import { stringify as uuidStringify } from 'uuid';

const uuidBytes = [
  0x6e,
  0xc0,
  0xbd,
  0x7f,
  0x11,
  0xc0,
  0x43,
  0xda,
  0x97,
  0x5e,
  0x2a,
  0x8a,
  0xd9,
  0xeb,
  0xae,
  0x0b,
];

uuidStringify(uuidBytes); // ⇨ '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'
```

### uuid.v1([options[, buffer[, offset]]])

Create an RFC version 1 (timestamp) UUID

|  |  |
| --- | --- |
| [`options`] | `Object` with one or more of the following properties: |
| [`options.node` ] | RFC "node" field as an `Array[6]` of byte values (per 4.1.6) |
| [`options.clockseq`] | RFC "clock sequence" as a `Number` between 0 - 0x3fff |
| [`options.msecs`] | RFC "timestamp" field (`Number` of milliseconds, unix epoch) |
| [`options.nsecs`] | RFC "timestamp" field (`Number` of nanseconds to add to `msecs`, should be 0-10,000) |
| [`options.random`] | `Array` of 16 random bytes (0-255) |
| [`options.rng`] | Alternative to `options.random`, a `Function` that returns an `Array` of 16 random bytes (0-255) |
| [`buffer`] | `Array \| Buffer` If specified, uuid will be written here in byte-form, starting at `offset` |
| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |
| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |
| _throws_ | `Error` if more than 10M UUIDs/sec are requested |

Note: The default [node id](https://tools.ietf.org/html/rfc4122#section-4.1.6) (the last 12 digits in the UUID) is generated once, randomly, on process startup, and then remains unchanged for the duration of the process.

Note: `options.random` and `options.rng` are only meaningful on the very first call to `v1()`, where they may be passed to initialize the internal `node` and `clockseq` fields.

Example:

```javascript
import { v1 as uuidv1 } from 'uuid';

uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

Example using `options`:

```javascript
import { v1 as uuidv1 } from 'uuid';

const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678,
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'
```

### uuid.v3(name, namespace[, buffer[, offset]])

Create an RFC version 3 (namespace w/ MD5) UUID

API is identical to `v5()`, but uses "v3" instead.

&#x26a0;&#xfe0f; Note: Per the RFC, "_If backward compatibility is not an issue, SHA-1 [Version 5] is preferred_."

### uuid.v4([options[, buffer[, offset]]])

Create an RFC version 4 (random) UUID

|  |  |
| --- | --- |
| [`options`] | `Object` with one or more of the following properties: |
| [`options.random`] | `Array` of 16 random bytes (0-255) |
| [`options.rng`] | Alternative to `options.random`, a `Function` that returns an `Array` of 16 random bytes (0-255) |
| [`buffer`] | `Array \| Buffer` If specified, uuid will be written here in byte-form, starting at `offset` |
| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |
| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |

Example:

```javascript
import { v4 as uuidv4 } from 'uuid';

uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Example using predefined `random` values:

```javascript
import { v4 as uuidv4 } from 'uuid';

const v4options = {
  random: [
    0x10,
    0x91,
    0x56,
    0xbe,
    0xc4,
    0xfb,
    0xc1,
    0xea,
    0x71,
    0xb4,
    0xef,
    0xe1,
    0x67,
    0x1c,
    0x58,
    0x36,
  ],
};
uuidv4(v4options); // ⇨ '109156be-c4fb-41ea-b1b4-efe1671c5836'
```

### uuid.v5(name, namespace[, buffer[, offset]])

Create an RFC version 5 (namespace w/ SHA-1) UUID

|  |  |
| --- | --- |
| `name` | `String \| Array` |
| `namespace` | `String \| Array[16]` Namespace UUID |
| [`buffer`] | `Array \| Buffer` If specified, uuid will be written here in byte-form, starting at `offset` |
| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |
| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |

Note: The RFC `DNS` and `URL` namespaces are available as `v5.DNS` and `v5.URL`.

Example with custom namespace:

```javascript
import { v5 as uuidv5 } from 'uuid';

// Define a custom namespace.  Readers, create your own using something like
// https://www.uuidgenerator.net/
const MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

uuidv5('Hello, World!', MY_NAMESPACE); // ⇨ '630eb68f-e0fa-5ecc-887a-7c7a62614681'
```

Example with RFC `URL` namespace:

```javascript
import { v5 as uuidv5 } from 'uuid';

uuidv5('https://www.w3.org/', uuidv5.URL); // ⇨ 'c106a26a-21bb-5538-8bf2-57095d1976c1'
```

### uuid.validate(str)

Test a string to see if it is a valid UUID

|           |                                                     |
| --------- | --------------------------------------------------- |
| `str`     | `String` to validate                                |
| _returns_ | `true` if string is a valid UUID, `false` otherwise |

Example:

```javascript
import { validate as uuidValidate } from 'uuid';

uuidValidate('not a UUID'); // ⇨ false
uuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ true
```

Using `validate` and `version` together it is possible to do per-version validation, e.g. validate for only v4 UUIds.

```javascript
import { version as uuidVersion } from 'uuid';
import { validate as uuidValidate } from 'uuid';

function uuidValidateV4(uuid) {
  return uuidValidate(uuid) && uuidVersion(uuid) === 4;
}

const v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';
const v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';

uuidValidateV4(v4Uuid); // ⇨ true
uuidValidateV4(v1Uuid); // ⇨ false
```

### uuid.version(str)

Detect RFC version of a UUID

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | A valid UUID `String`                    |
| _returns_ | `Number` The RFC version of the UUID     |
| _throws_  | `TypeError` if `str` is not a valid UUID |

Example:

```javascript
import { version as uuidVersion } from 'uuid';

uuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // ⇨ 1
uuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ 4
```

## Command Line

UUIDs can be generated from the command line using `uuid`.

```shell
$ uuid
ddeb27fb-d9a0-4624-be4d-4615062daed4
```

The default is to generate version 4 UUIDS, however the other versions are supported. Type `uuid --help` for details:

```shell
$ uuid --help

Usage:
  uuid
  uuid v1
  uuid v3 <name> <namespace uuid>
  uuid v4
  uuid v5 <name> <namespace uuid>
  uuid --help

Note: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs
defined by RFC4122
```

## ECMAScript Modules

This library comes with [ECMAScript Modules](https://www.ecma-international.org/ecma-262/6.0/#sec-modules) (ESM) support for Node.js versions that support it ([example](./examples/node-esmodules/)) as well as bundlers like [rollup.js](https://rollupjs.org/guide/en/#tree-shaking) ([example](./examples/browser-rollup/)) and [webpack](https://webpack.js.org/guides/tree-shaking/) ([example](./examples/browser-webpack/)) (targeting both, Node.js and browser environments).

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

To run the examples you must first create a dist build of this library in the module root:

```shell
npm run build
```

## CDN Builds

### ECMAScript Modules

To load this module directly into modern browsers that [support loading ECMAScript Modules](https://caniuse.com/#feat=es6-module) you can make use of [jspm](https://jspm.org/):

```html
<script type="module">
  import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
  console.log(uuidv4()); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
</script>
```

### UMD

To load this module directly into older browsers you can use the [UMD (Universal Module Definition)](https://github.com/umdjs/umd) builds from any of the following CDNs:

**Using [UNPKG](https://unpkg.com/uuid@latest/dist/umd/)**:

```html
<script src="https://unpkg.com/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Using [jsDelivr](https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/)**:

```html
<script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Using [cdnjs](https://cdnjs.com/libraries/uuid)**:

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
```

These CDNs all provide the same [`uuidv4()`](#uuidv4options-buffer-offset) method:

```html
<script>
  uuidv4(); // ⇨ '55af1e37-0734-46d8-b070-a1e42e4fc392'
</script>
```

Methods for the other algorithms ([`uuidv1()`](#uuidv1options-buffer-offset), [`uuidv3()`](#uuidv3name-namespace-buffer-offset) and [`uuidv5()`](#uuidv5name-namespace-buffer-offset)) are available from the files `uuidv1.min.js`, `uuidv3.min.js` and `uuidv5.min.js` respectively.

## "getRandomValues() not supported"

This error occurs in environments where the standard [`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) API is not supported. This issue can be resolved by adding an appropriate polyfill:

### React Native / Expo

1. Install [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme)
1. Import it _before_ `uuid`. Since `uuid` might also appear as a transitive dependency of some other imports it's safest to just import `react-native-get-random-values` as the very first thing in your entry point:

```javascript
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
```

Note: If you are using Expo, you must be using at least `react-native-get-random-values@1.5.0` and `expo@39.0.0`.

### Web Workers / Service Workers (Edge <= 18)

[In Edge <= 18, Web Crypto is not supported in Web Workers or Service Workers](https://caniuse.com/#feat=cryptography) and we are not aware of a polyfill (let us know if you find one, please).

## Upgrading From `uuid@7.x`

### Only Named Exports Supported When Using with Node.js ESM

`uuid@7.x` did not come with native ECMAScript Module (ESM) support for Node.js. Importing it in Node.js ESM consequently imported the CommonJS source with a default export. This library now comes with true Node.js ESM support and only provides named exports.

Instead of doing:

```javascript
import uuid from 'uuid';
uuid.v4();
```

you will now have to use the named exports:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

### Deep Requires No Longer Supported

Deep requires like `require('uuid/v4')` [which have been deprecated in `uuid@7.x`](#deep-requires-now-deprecated) are no longer supported.

## Upgrading From `uuid@3.x`

"_Wait... what happened to `uuid@4.x` - `uuid@6.x`?!?_"

In order to avoid confusion with RFC [version 4](#uuidv4options-buffer-offset) and [version 5](#uuidv5name-namespace-buffer-offset) UUIDs, and a possible [version 6](http://gh.peabody.io/uuidv6/), releases 4 thru 6 of this module have been skipped.

### Deep Requires Now Deprecated

`uuid@3.x` encouraged the use of deep requires to minimize the bundle size of browser builds:

```javascript
const uuidv4 = require('uuid/v4'); // <== NOW DEPRECATED!
uuidv4();
```

As of `uuid@7.x` this library now provides ECMAScript modules builds, which allow packagers like Webpack and Rollup to do "tree-shaking" to remove dead code. Instead, use the `import` syntax:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

... or for CommonJS:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4();
```

### Default Export Removed

`uuid@3.x` was exporting the Version 4 UUID method as a default export:

```javascript
const uuid = require('uuid'); // <== REMOVED!
```

This usage pattern was already discouraged in `uuid@3.x` and has been removed in `uuid@7.x`.

----
Markdown generated from [README_js.md](README_js.md) by [![RunMD Logo](http://i.imgur.com/h0FVyzU.png)](https://github.com/broofa/runmd)import uuid from './dist/index.js';
export const v1 = uuid.v1;
export const v3 = uuid.v3;
export const v4 = uuid.v4;
export const v5 = uuid.v5;
export const NIL = uuid.NIL;
export const version = uuid.version;
export const validate = uuid.validate;
export const stringify = uuid.stringify;
export const parse = uuid.parse;
{
  "name": "@postman/runtime.socket.io-request",
  "version": "0.1.6",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/item-types/socketio-request#readme",
  "license": "UNLICENSED",
  "description": "The Postman ItemType: 'socket-io-request'",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "file-type": "^16.5.4",
    "json-schema-to-ts": "~2.7.2",
    "strip-json-comments": "^3.1.1",
    "uuid": "8.3.2"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^*",
    "@postman/runtime.documentation": "^*",
    "@postman/runtime.variables": "^*",
    "@postman/runtime.protocol-utils": "^*"
  },
  "devDependencies": {
    "@types/uuid": "^9.0.8",
    "@postman/runtime.event-channel": "^0.2.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest",
    "coverage": "vitest --coverage"
  }
}# ItemType: `socketio-request`

This package defines the Postman ItemType: `ws-socket-request`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../../core/core" },
		{ "path": "../../extensions/documentation" },
		{ "path": "../../extensions/variables" },
		{ "path": "../../utilities/protocol-utils"}
	]
}
export { default as Variables } from './variables';
export { VariableScope } from './variable-scope';
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableScope = exports.Variables = void 0;
var variables_1 = require("./variables");
Object.defineProperty(exports, "Variables", { enumerable: true, get: function () { return __importDefault(variables_1).default; } });
var variable_scope_1 = require("./variable-scope");
Object.defineProperty(exports, "VariableScope", { enumerable: true, get: function () { return variable_scope_1.VariableScope; } });
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;AAAA,yCAAmD;AAA1C,uHAAA,OAAO,OAAa;AAC7B,mDAAiD;AAAxC,+GAAA,aAAa,OAAA"}declare class VariableScope {
    private name?;
    private values;
    private references;
    constructor(definition?: VariableScope.Definition);
    has(name: string): boolean;
    get<T = any>(name: string): T | undefined;
    set<T = any>(name: string, value: T): void;
    unset(name: string): void;
    put(values: VariableScope.Values): void;
    clear(): void;
    toObject(): Record<string, any>;
    toJSON(): VariableScope.Definition;
}
declare namespace VariableScope {
    type Values = Array<{
        key: string;
        value: any;
        disabled?: boolean;
    }>;
    type Definition = {
        name?: string;
        values: Values;
    };
}
export { VariableScope };
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableScope = void 0;
const lodash_1 = require("lodash");
/*
    A VariableScope is a simple container for key-value pairs.
*/
class VariableScope {
    constructor(definition = { values: [] }) {
        this.name = definition.name;
        this.put(definition.values);
    }
    has(name) {
        return name in this.references;
    }
    get(name) {
        return this.references[name];
    }
    set(name, value) {
        if (this.has(name)) {
            for (let i = this.values.length - 1; i >= 0; i--) {
                if (this.values[i].key === name) {
                    this.values[i].value = value;
                    break;
                }
            }
        }
        else {
            this.values.push({ key: name, value });
        }
        this.references[name] = value;
    }
    unset(name) {
        this.values = this.values.filter((value) => value.key !== name);
        delete this.references[name];
    }
    put(values) {
        this.values =
            Array.isArray(values) ?
                (0, lodash_1.cloneDeep)(values.filter((v) => typeof v.key === 'string' && !v.disabled))
                : [];
        this.references = this.values.reduce((acc, v) => {
            acc[v.key] = v.value;
            return acc;
        }, Object.create(null));
    }
    clear() {
        this.values = [];
        this.references = Object.create(null);
    }
    toObject() {
        return (0, lodash_1.cloneDeep)(this.references);
    }
    toJSON() {
        return {
            name: this.name,
            values: (0, lodash_1.cloneDeep)(this.values),
        };
    }
}
exports.VariableScope = VariableScope;
//# sourceMappingURL=variable-scope.js.map{"version":3,"file":"variable-scope.js","sourceRoot":"","sources":["../src/variable-scope.ts"],"names":[],"mappings":";;;AAAA,mCAAmC;AACnC;;EAEE;AACF,MAAM,aAAa;IAKlB,YAAY,aAAuC,EAAE,MAAM,EAAE,EAAE,EAAE;QAChE,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;QAC5B,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAC7B,CAAC;IAED,GAAG,CAAC,IAAY;QACf,OAAO,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC;IAChC,CAAC;IAED,GAAG,CAAU,IAAY;QACxB,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAED,GAAG,CAAU,IAAY,EAAE,KAAQ;QAClC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;YACpB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBAClD,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,IAAI,EAAE,CAAC;oBACjC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC;oBAC7B,MAAM;gBACP,CAAC;YACF,CAAC;QACF,CAAC;aAAM,CAAC;YACP,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;QACxC,CAAC;QAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;IAC/B,CAAC;IAED,KAAK,CAAC,IAAY;QACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC;QAChE,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAED,GAAG,CAAC,MAA4B;QAC/B,IAAI,CAAC,MAAM;YACV,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;gBACtB,IAAA,kBAAS,EACR,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,GAAG,KAAK,QAAQ,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAC9D;gBACF,CAAC,CAAC,EAAE,CAAC;QACN,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,GAAwB,EAAE,CAAC,EAAE,EAAE;YACpE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;YACrB,OAAO,GAAG,CAAC;QACZ,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IACzB,CAAC;IAED,KAAK;QACJ,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACvC,CAAC;IAED,QAAQ;QACP,OAAO,IAAA,kBAAS,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACnC,CAAC;IAED,MAAM;QACL,OAAO;YACN,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,MAAM,EAAE,IAAA,kBAAS,EAAC,IAAI,CAAC,MAAM,CAAC;SAC9B,CAAC;IACH,CAAC;CACD;AAcQ,sCAAa"}import { VariableScope } from './variable-scope';
export default class Variables {
    private readonly scopes;
    constructor(...scopes: ReadonlyArray<VariableScope>);
    has(name: string): boolean;
    get<T = any>(name: string): T | undefined;
    set<T = any>(name: string, value: T): void;
    unset(name: string): void;
    clear(): void;
    toObject(): Record<string, any>;
    replaceIn<T = any>(template: T): T;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
    The Variables class provides access to multiple VariableScopes, such that
    the first scope has the highest priority, and the last scope has the lowest
    priority. Mutation methods such as set(), unset(), and clear() only affect
    the first scope, which is typically used for "local" variables.
*/
class Variables {
    constructor(...scopes) {
        this.scopes = [...scopes];
    }
    has(name) {
        for (const scope of this.scopes) {
            if (scope.has(name))
                return true;
        }
        return false;
    }
    get(name) {
        for (const scope of this.scopes) {
            if (scope.has(name))
                return scope.get(name);
        }
        return undefined;
    }
    set(name, value) {
        const firstScope = this.scopes[0];
        if (firstScope) {
            firstScope.set(name, value);
        }
    }
    unset(name) {
        const firstScope = this.scopes[0];
        if (firstScope) {
            firstScope.unset(name);
        }
    }
    clear() {
        const firstScope = this.scopes[0];
        if (firstScope) {
            firstScope.clear();
        }
    }
    toObject() {
        const objs = this.scopes.map((scope) => scope.toObject()).reverse();
        return Object.assign({}, ...objs);
    }
    // This method is modeled after:
    // https://github.com/postmanlabs/postman-collection/blob/d9bea02202a6e845b37b8cbf456054d8adb1e66f/lib/collection/variable-scope.js#L302
    replaceIn(template) {
        if (Array.isArray(template)) {
            return template.map((x) => this.replaceIn(x));
        }
        if (isPlainObject(template)) {
            const obj = {};
            for (const [key, value] of Object.entries(template)) {
                obj[key] = this.replaceIn(value);
            }
            return obj;
        }
        if (typeof template === 'string' && template !== '') {
            return replaceVariables(template, this);
        }
        return template;
    }
}
exports.default = Variables;
/*
    Variable replacement is an iterative/recursive procedure, so variable values
    may reference other variables. An arbitrary iteration limit is enforced to
    prevent infinite loops.
*/
const VARIABLES_REGEX = /\{\{([^{}]*?)}}/g;
const MAX_ITERATIONS = 19;
function replaceVariables(template, variables) {
    let didReplace = false;
    let iterations = 0;
    const replacer = (match, token) => {
        let result = variables.get(token);
        if (typeof result === 'function') {
            result = result();
        }
        if (result != null && typeof result.toString === 'function') {
            result = result.toString();
        }
        switch (typeof result) {
            case 'string':
                didReplace = true;
                return result;
            case 'number':
            case 'bigint':
            case 'boolean':
                didReplace = true;
                return String(result);
            default:
                // Other types are ignored:
                // https://github.com/postmanlabs/postman-collection/blob/d9bea02202a6e845b37b8cbf456054d8adb1e66f/lib/superstring/index.js#L230
                return match;
        }
    };
    do {
        didReplace = false;
        template = template.replace(VARIABLES_REGEX, replacer);
    } while (didReplace && ++iterations < MAX_ITERATIONS);
    return template;
}
function isPlainObject(value) {
    if (typeof value === 'object' && value !== null) {
        const proto = Object.getPrototypeOf(value);
        if (proto === null) {
            return true;
        }
        if (Object.getPrototypeOf(proto) === null &&
            {}.hasOwnProperty.call(proto, 'hasOwnProperty')) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=variables.js.map{"version":3,"file":"variables.js","sourceRoot":"","sources":["../src/variables.ts"],"names":[],"mappings":"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"}{
  "name": "@postman/runtime.variable-scope",
  "version": "0.2.0",
  "license": "UNLICENSED",
  "description": "Manage and resolve variables using multiple scopes",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/core/variable-scope#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "dependencies": {
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "@types/lodash": "^4.14.194"
  },
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# variable-scope

This package provides a consistent way to represent variables from multiple sources and use them to resolve interpolated values.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	}
}
import Variables from '.';
declare const _default: (itemType: import("@postman/runtime.core/dist/item-type").default.WithExtension<Variables>, context: import("@postman/runtime.core").RuntimeContext) => {
    onBefore(item: import("@postman/runtime.core/dist/item").default.WithExtension<Variables>): Promise<void>;
};
export default _default;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (function handler(itemType, context) {
    const { config } = itemType.getExtension('variables');
    const { replaceInFields } = config;
    function replace(obj, key) {
        obj[key] = context.variables.replaceIn(obj[key]);
    }
    return {
        async onBefore(item) {
            const keyPaths = replaceInFields
                .map((str) => str.replace(/^\./, '').split('.'))
                .filter((keyPath) => keyPath.length);
            for (const keyPath of keyPaths) {
                const lastKey = keyPath.pop();
                keyPath
                    .reduce((arr, key) => arr.flatMap(mapKeys(get, key)).filter(isNotNull), [item])
                    .forEach(mapKeys(replace, lastKey));
            }
        },
    };
});
// Calls the given function for each matching key within the given object.
// A given key of "*" represents all keys within an object, and a given key of
// "[]" represents all indexes within an array. All other keys are interpreted
// literally. The result of each function call is returned within an array.
function mapKeys(fn, key) {
    return (obj) => {
        if (key === '[]') {
            if (Array.isArray(obj)) {
                return obj.map((_, i, arr) => fn(arr, i));
            }
        }
        else if (key === '*') {
            if (!Array.isArray(obj)) {
                return Object.keys(obj).map((realKey) => fn(obj, realKey));
            }
        }
        else {
            if ({}.hasOwnProperty.call(obj, key)) {
                return [fn(obj, key)];
            }
        }
        return [];
    };
}
function isNotNull(value) {
    return value != null;
}
function get(obj, key) {
    return obj[key];
}
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":";;AAGA,kBAAe,CAAC,SAAS,OAAO,CAAC,QAAQ,EAAE,OAAO;IACjD,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;IACtD,MAAM,EAAE,eAAe,EAAE,GAAG,MAAM,CAAC;IAEnC,SAAS,OAAO,CAAC,GAAO,EAAE,GAAoB;QAC5C,GAAe,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,SAAS,CAAE,GAAe,CAAC,GAAG,CAAC,CAAC,CAAC;IAC5E,CAAC;IAED,OAAO;QACN,KAAK,CAAC,QAAQ,CAAC,IAAI;YAClB,MAAM,QAAQ,GAAG,eAAe;iBAC9B,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBAC/C,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAEtC,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAChC,MAAM,OAAO,GAAG,OAAO,CAAC,GAAG,EAAG,CAAC;gBAE/B,OAAO;qBACL,MAAM,CACN,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,EAC9D,CAAC,IAAU,CAAC,CACZ;qBACA,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;YACtC,CAAC;QACF,CAAC;KACD,CAAC;AACH,CAAwC,CAAC,CAAC;AAE1C,0EAA0E;AAC1E,8EAA8E;AAC9E,8EAA8E;AAC9E,2EAA2E;AAC3E,SAAS,OAAO,CACf,EAA8C,EAC9C,GAAoB;IAEpB,OAAO,CAAC,GAAO,EAAa,EAAE;QAC7B,IAAI,GAAG,KAAK,IAAI,EAAE,CAAC;YAClB,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;gBACxB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YAC3C,CAAC;QACF,CAAC;aAAM,IAAI,GAAG,KAAK,GAAG,EAAE,CAAC;YACxB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;gBACzB,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC;YAC5D,CAAC;QACF,CAAC;aAAM,CAAC;YACP,IAAI,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC;gBACtC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YACvB,CAAC;QACF,CAAC;QACD,OAAO,EAAE,CAAC;IACX,CAAC,CAAC;AACH,CAAC;AAED,SAAS,SAAS,CAAC,KAAc;IAChC,OAAO,KAAK,IAAI,IAAI,CAAC;AACtB,CAAC;AAED,SAAS,GAAG,CAAC,GAAO,EAAE,GAAoB;IACzC,OAAQ,GAAe,CAAC,GAAG,CAAC,CAAC;AAC9B,CAAC"}import { FromSchema } from 'json-schema-to-ts';
import { Extension } from '@postman/runtime.core';
export interface PluginConfiguration {
    replaceInFields: ReadonlyArray<string>;
}
declare const definition: {
    name: "variables";
    summary: "Customize your requests with variables";
    schema: {
        readonly type: "object";
        readonly additionalProperties: false;
    };
};
declare namespace Variables {
    type Name = typeof definition.name;
    type Data = FromSchema<typeof definition.schema>;
    type Config = PluginConfiguration;
    const use: () => Extension.Specific<"variables", {}, PluginConfiguration>;
}
type Variables = Extension.Specific<Variables.Name, Variables.Data, Variables.Config>;
export default Variables;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const handler_1 = __importDefault(require("./handler"));
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'variables',
    summary: 'Customize your requests with variables',
    schema: {
        type: 'object',
        additionalProperties: false,
    },
});
var Variables;
(function (Variables) {
    Variables.use = runtime_core_1.Extension.define(definition, handler_1.default);
})(Variables || (Variables = {}));
exports.default = Variables;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;AAAA,yDAAoE;AACpE,wDAAkD;AAClD,wDAAgC;AAMhC,MAAM,UAAU,GAAG,IAAA,2BAAO,EAAC;IAC1B,IAAI,EAAE,WAAW;IACjB,OAAO,EAAE,wCAAwC;IACjD,MAAM,EAAE;QACP,IAAI,EAAE,QAAQ;QACd,oBAAoB,EAAE,KAAK;KACG;CAC/B,CAAC,CAAC;AAEH,IAAU,SAAS,CAKlB;AALD,WAAU,SAAS;IAIL,aAAG,GAAG,wBAAS,CAAC,MAAM,CAAqB,UAAU,EAAE,iBAAO,CAAC,CAAC;AAC9E,CAAC,EALS,SAAS,KAAT,SAAS,QAKlB;AAOD,kBAAe,SAAS,CAAC"}{
  "name": "@postman/runtime.variables",
  "version": "0.1.13",
  "license": "UNLICENSED",
  "description": "The Postman ItemType extension: 'variables'",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/extensions/variables#readme",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "json-schema-to-ts": "~2.7.2"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^0.4.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Extension: `variables`

This package defines the Postman ItemType extension: `variables`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [{ "path": "../../core/core" }]
}
export interface HTTPRequest {
    method: 'GET' | 'CONNECT';
    href: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface HTTPResponse {
    statusCode: number;
    statusMessage: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface ConnectionEndEvent {
    code?: number;
    reason?: string;
    aborted: boolean;
}
export interface ErrorEvent {
    error: {
        message: string;
    };
    handshakeRequest?: HTTPRequest;
    handshakeResponse?: HTTPResponse;
}
export interface MessageEvent {
    message: string | Uint8Array;
}
export interface OpenEvent {
    request?: HTTPRequest;
    response?: HTTPResponse;
}
export interface ReconnectEvent {
    attempt: number;
    timeout: number;
}
export interface UpgradeEvent {
    request?: HTTPRequest;
    response?: HTTPResponse;
}
export interface CloseEvent {
    aborted?: boolean;
    code: number;
    reason: string;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=connection-events.js.map{"version":3,"file":"connection-events.js","sourceRoot":"","sources":["../src/connection-events.ts"],"names":[],"mappings":""}/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import type tls from 'tls';
import type * as EventTypes from './connection-events';
export interface ClientOptions {
    url: string | URL;
    connectOptions?: {
        handshakeTimeout?: number;
        maxPayload?: number;
        followRedirects?: boolean;
    };
    reconnectOptions?: {
        retryCount?: number;
        retryDelay?: number;
    };
    protocols?: string | string[];
    tlsOptions?: TLSOptions;
    headers?: Record<string, string>;
}
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: tls.SecureContext | tls.SecureContextOptions;
}
export interface Connection {
    emit(event: 'error', payload: EventTypes.ErrorEvent): boolean;
    on(event: 'error', listener: (this: Connection, arg: EventTypes.ErrorEvent) => void): this;
    addListener(event: 'error', listener: (this: Connection, arg: EventTypes.ErrorEvent) => void): this;
    once(event: 'error', listener: (this: Connection, arg: EventTypes.ErrorEvent) => void): this;
    emit(event: 'end', payload: EventTypes.ConnectionEndEvent): boolean;
    on(event: 'end', listener: (this: Connection, arg: EventTypes.ConnectionEndEvent) => void): this;
    addListener(event: 'end', listener: (this: Connection, arg: EventTypes.ConnectionEndEvent) => void): this;
    once(event: 'end', listener: (this: Connection, arg: EventTypes.ConnectionEndEvent) => void): this;
    emit(event: 'upgrade', payload: EventTypes.UpgradeEvent): boolean;
    on(event: 'upgrade', listener: (this: Connection, arg: EventTypes.UpgradeEvent) => void): this;
    addListener(event: 'upgrade', listener: (this: Connection, arg: EventTypes.UpgradeEvent) => void): this;
    once(event: 'upgrade', listener: (this: Connection, arg: EventTypes.UpgradeEvent) => void): this;
    emit(event: 'open', payload: EventTypes.OpenEvent): boolean;
    on(event: 'open', listener: (this: Connection, arg: EventTypes.OpenEvent) => void): this;
    addListener(event: 'open', listener: (this: Connection, arg: EventTypes.OpenEvent) => void): this;
    once(event: 'open', listener: (this: Connection, arg: EventTypes.OpenEvent) => void): this;
    emit(event: 'close', payload: EventTypes.CloseEvent): boolean;
    on(event: 'close', listener: (this: Connection, arg: EventTypes.CloseEvent) => void): this;
    addListener(event: 'close', listener: (this: Connection, arg: EventTypes.CloseEvent) => void): this;
    once(event: 'close', listener: (this: Connection, arg: EventTypes.CloseEvent) => void): this;
    emit(event: 'message', payload: EventTypes.MessageEvent): boolean;
    on(event: 'message', listener: (this: Connection, arg: EventTypes.MessageEvent) => void): this;
    addListener(event: 'message', listener: (this: Connection, arg: EventTypes.MessageEvent) => void): this;
    once(event: 'message', listener: (this: Connection, arg: EventTypes.MessageEvent) => void): this;
    emit(event: 'reconnect', payload: EventTypes.ReconnectEvent): boolean;
    on(event: 'reconnect', listener: (this: Connection, arg: EventTypes.ReconnectEvent) => void): this;
    addListener(event: 'reconnect', listener: (this: Connection, arg: EventTypes.ReconnectEvent) => void): this;
    once(event: 'reconnect', listener: (this: Connection, arg: EventTypes.ReconnectEvent) => void): this;
}
export declare class Connection extends EventEmitter {
    private client;
    private reconnectCount;
    private connectionOptions;
    private isConnectionAborted;
    constructor(connectionOptions: ClientOptions);
    private open;
    send(message: string | Uint8Array): void;
    private extractRequestResponseFromClient;
    private reconnect;
    close(code?: number, reason?: string): void;
}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const events_1 = require("events");
const postman_ws_1 = __importDefault(require("postman-ws"));
const utils_1 = require("./utils");
class Connection extends events_1.EventEmitter {
    constructor(connectionOptions) {
        super();
        this.reconnectCount = -1;
        this.isConnectionAborted = false;
        this.connectionOptions = connectionOptions;
        try {
            this.open();
        }
        catch (e) {
            const error = e;
            this.emit('error', { error: { message: error.message } });
            this.emit('end', { aborted: this.isConnectionAborted });
            return;
        }
    }
    open() {
        const options = {
            headers: this.connectionOptions.headers,
            maxPayload: this.connectionOptions.connectOptions?.maxPayload,
            handshakeTimeout: this.connectionOptions?.connectOptions?.handshakeTimeout,
            followRedirects: this.connectionOptions.connectOptions?.followRedirects,
            rejectUnauthorized: this.connectionOptions?.tlsOptions?.rejectUnauthorized,
            ...this.connectionOptions?.tlsOptions?.secureContext,
        };
        const url = typeof this.connectionOptions.url === 'string' ?
            this.connectionOptions.url
            : this.connectionOptions.url.href;
        if (!(0, utils_1.isValidUrl)(url)) {
            throw new Error('Invalid URL');
        }
        this.client = new postman_ws_1.default(url, this.connectionOptions.protocols, options);
        this.client
            .on('upgrade', () => {
            if (!this.client._debug) {
                this.emit('upgrade', {});
                return;
            }
            const { request, response } = this.extractRequestResponseFromClient();
            this.emit('upgrade', { request, response });
            return;
        })
            .on('open', () => {
            this.reconnectCount = 0;
            const { request, response } = this.extractRequestResponseFromClient(true);
            this.emit('open', { request, response });
        })
            .on('close', (code, reason) => {
            if (this.reconnectCount === 0) {
                this.emit('close', { code, reason });
            }
            if (code == 1000 ||
                this.isConnectionAborted ||
                this.reconnectCount === -1) {
                this.emit('end', { code, reason, aborted: this.isConnectionAborted });
                return;
            }
            this.reconnect(code, reason);
        })
            .on('message', (message) => {
            if (typeof message === 'string') {
                this.emit('message', { message });
                return;
            }
            // If message is an array of buffers, combine them into a single buffer
            if (Array.isArray(message) && message.every(Buffer.isBuffer)) {
                message = Buffer.concat(message);
            }
            if (Buffer.isBuffer(message)) {
                message = message.buffer.slice(message.byteOffset, message.byteOffset + message.byteLength);
                message = new Uint8Array(message);
            }
            this.emit('message', { message: new Uint8Array(message) });
        })
            .on('error', (error) => {
            // If connection was aborted, absorb the error
            if (this.isConnectionAborted) {
                return;
            }
            // Emit error only for the final reconnect attempt
            if (this.reconnectCount > 0 &&
                this.reconnectCount <
                    (this.connectionOptions?.reconnectOptions?.retryCount ?? 0)) {
                return;
            }
            const { request, response } = this.extractRequestResponseFromClient(true);
            this.emit('error', {
                error: { message: error.message },
                handshakeRequest: request,
                handshakeResponse: response,
            });
            return;
        });
    }
    send(message) {
        this.client.send(message);
    }
    extractRequestResponseFromClient(clearDebug = false) {
        if (!this.client._debug?.length) {
            return {};
        }
        const request = this.client._debug[0].request;
        const response = this.client._debug[this.client._debug.length - 1].response;
        if (clearDebug) {
            this.client._debug = [];
        }
        return { request, response };
    }
    reconnect(code, reason) {
        this.client.removeAllListeners();
        if (this.reconnectCount >=
            (this.connectionOptions?.reconnectOptions?.retryCount ?? 0)) {
            this.emit('end', { code, reason, aborted: this.isConnectionAborted });
            // If we have reached the maximum number of retries, don't reconnect;
            return;
        }
        setTimeout(() => {
            this.open();
        }, this.connectionOptions?.reconnectOptions?.retryDelay ?? 0);
        this.emit('reconnect', {
            attempt: ++this.reconnectCount,
            timeout: this.connectionOptions?.reconnectOptions?.retryDelay ?? 0,
        });
    }
    close(code = 1000, reason = '') {
        // Defaulting to 1000 (Normal Closure) and reason to empty string since
        // `postman-ws` tries to build an incorrect close frame and errors out
        // if nothing is passed.
        // Mark connection as aborted if it's closed in non-open state
        // Refer: https://github.com/websockets/ws/blob/7.4.4/lib/websocket.js#L26
        if (this.client.readyState !== 1) {
            this.isConnectionAborted = true;
        }
        this.client.close(code, reason);
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map{"version":3,"file":"connection.js","sourceRoot":"","sources":["../src/connection.ts"],"names":[],"mappings":";;;;;;AAAA,mCAAsC;AACtC,4DAAmC;AAGnC,mCAAqC;AA6DrC,MAAa,UAAW,SAAQ,qBAAY;IAM3C,YAAY,iBAAgC;QAC3C,KAAK,EAAE,CAAC;QALD,mBAAc,GAAW,CAAC,CAAC,CAAC;QAE5B,wBAAmB,GAAG,KAAK,CAAC;QAInC,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAE3C,IAAI,CAAC;YACJ,IAAI,CAAC,IAAI,EAAE,CAAC;QACb,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YACjB,MAAM,KAAK,GAAU,CAAC,CAAC;YACvB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;YAC1D,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;YACxD,OAAO;QACR,CAAC;IACF,CAAC;IAEO,IAAI;QACX,MAAM,OAAO,GAAG;YACf,OAAO,EAAE,IAAI,CAAC,iBAAiB,CAAC,OAAO;YACvC,UAAU,EAAE,IAAI,CAAC,iBAAiB,CAAC,cAAc,EAAE,UAAU;YAC7D,gBAAgB,EACf,IAAI,CAAC,iBAAiB,EAAE,cAAc,EAAE,gBAAgB;YACzD,eAAe,EAAE,IAAI,CAAC,iBAAiB,CAAC,cAAc,EAAE,eAAe;YACvE,kBAAkB,EACjB,IAAI,CAAC,iBAAiB,EAAE,UAAU,EAAE,kBAAkB;YACvD,GAAG,IAAI,CAAC,iBAAiB,EAAE,UAAU,EAAE,aAAa;SACpD,CAAC;QAEF,MAAM,GAAG,GACR,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,KAAK,QAAQ,CAAC,CAAC;YAC/C,IAAI,CAAC,iBAAiB,CAAC,GAAG;YAC3B,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC;QAEnC,IAAI,CAAC,IAAA,kBAAU,EAAC,GAAG,CAAC,EAAE,CAAC;YACtB,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;QAChC,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,oBAAS,CAAC,GAAG,EAAE,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAE5E,IAAI,CAAC,MAAM;aACT,EAAE,CAAC,SAAS,EAAE,GAAG,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;gBACzB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;gBACzB,OAAO;YACR,CAAC;YAED,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,gCAAgC,EAAE,CAAC;YAEtE,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;YAE5C,OAAO;QACR,CAAC,CAAC;aACD,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE;YAChB,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;YAExB,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAC1B,IAAI,CAAC,gCAAgC,CAAC,IAAI,CAAC,CAAC;YAE7C,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;QAC1C,CAAC,CAAC;aACD,EAAE,CAAC,OAAO,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE;YAC7B,IAAI,IAAI,CAAC,cAAc,KAAK,CAAC,EAAE,CAAC;gBAC/B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;YACtC,CAAC;YAED,IACC,IAAI,IAAI,IAAI;gBACZ,IAAI,CAAC,mBAAmB;gBACxB,IAAI,CAAC,cAAc,KAAK,CAAC,CAAC,EACzB,CAAC;gBACF,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;gBACtE,OAAO;YACR,CAAC;YAED,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC9B,CAAC,CAAC;aACD,EAAE,CAAC,SAAS,EAAE,CAAC,OAAO,EAAE,EAAE;YAC1B,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;gBACjC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;gBAClC,OAAO;YACR,CAAC;YAED,uEAAuE;YACvE,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC9D,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAClC,CAAC;YAED,IAAI,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC9B,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAC7B,OAAO,CAAC,UAAU,EAClB,OAAO,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CACvC,CAAC;gBACF,OAAO,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC;YACnC,CAAC;YAED,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,OAAO,EAAE,IAAI,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAC5D,CAAC,CAAC;aACD,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE;YACtB,8CAA8C;YAC9C,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAC9B,OAAO;YACR,CAAC;YAED,kDAAkD;YAClD,IACC,IAAI,CAAC,cAAc,GAAG,CAAC;gBACvB,IAAI,CAAC,cAAc;oBAClB,CAAC,IAAI,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,UAAU,IAAI,CAAC,CAAC,EAC3D,CAAC;gBACF,OAAO;YACR,CAAC;YAED,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAC1B,IAAI,CAAC,gCAAgC,CAAC,IAAI,CAAC,CAAC;YAE7C,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBAClB,KAAK,EAAE,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE;gBACjC,gBAAgB,EAAE,OAAO;gBACzB,iBAAiB,EAAE,QAAQ;aAC3B,CAAC,CAAC;YAEH,OAAO;QACR,CAAC,CAAC,CAAC;IACL,CAAC;IAED,IAAI,CAAC,OAA4B;QAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC3B,CAAC;IAEO,gCAAgC,CAAC,UAAU,GAAG,KAAK;QAC1D,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC;YACjC,OAAO,EAAE,CAAC;QACX,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QAC9C,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC;QAE5E,IAAI,UAAU,EAAE,CAAC;YAChB,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE,CAAC;QACzB,CAAC;QAED,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;IAC9B,CAAC;IAEO,SAAS,CAAC,IAAY,EAAE,MAAc;QAC7C,IAAI,CAAC,MAAM,CAAC,kBAAkB,EAAE,CAAC;QAEjC,IACC,IAAI,CAAC,cAAc;YACnB,CAAC,IAAI,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,UAAU,IAAI,CAAC,CAAC,EAC1D,CAAC;YACF,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;YACtE,qEAAqE;YACrE,OAAO;QACR,CAAC;QAED,UAAU,CAAC,GAAG,EAAE;YACf,IAAI,CAAC,IAAI,EAAE,CAAC;QACb,CAAC,EAAE,IAAI,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,UAAU,IAAI,CAAC,CAAC,CAAC;QAE9D,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACtB,OAAO,EAAE,EAAE,IAAI,CAAC,cAAc;YAC9B,OAAO,EAAE,IAAI,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,UAAU,IAAI,CAAC;SAClE,CAAC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,OAAe,IAAI,EAAE,SAAiB,EAAE;QAC7C,uEAAuE;QACvE,sEAAsE;QACtE,wBAAwB;QAExB,8DAA8D;QAC9D,0EAA0E;QAC1E,IAAI,IAAI,CAAC,MAAM,CAAC,UAAU,KAAK,CAAC,EAAE,CAAC;YAClC,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QACjC,CAAC;QAED,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IACjC,CAAC;CACD;AAvLD,gCAuLC"}import { Connection, type ClientOptions } from './connection';
export * from './connection';
export declare function connect(options: ClientOptions): Connection;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
const connection_1 = require("./connection");
__exportStar(require("./connection"), exports);
function connect(options) {
    return new connection_1.Connection(options);
}
exports.connect = connect;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,6CAA8D;AAE9D,+CAA6B;AAE7B,SAAgB,OAAO,CAAC,OAAsB;IAC7C,OAAO,IAAI,uBAAU,CAAC,OAAO,CAAC,CAAC;AAChC,CAAC;AAFD,0BAEC"}export declare function isValidUrl(str: string): boolean;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidUrl = void 0;
function isValidUrl(str) {
    str = String(str); // For non-TypeScript applications
    // Test if the string doesn't start with a protocol
    if (!/^[a-z0-9+.-]+:\/\//i.test(str)) {
        str = `ws://${str}`; // Default protocol
    }
    let url;
    try {
        url = new URL(str);
    }
    catch (_) {
        return false;
    }
    if (!url.host && !url.port && !url.pathname) {
        return false;
    }
    const validProtocols = ['ws:', 'wss:'];
    if (!validProtocols.includes(url.protocol)) {
        return false;
    }
    return true;
}
exports.isValidUrl = isValidUrl;
//# sourceMappingURL=utils.js.map{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;;AAAA,SAAgB,UAAU,CAAC,GAAW;IACrC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,kCAAkC;IAErD,mDAAmD;IACnD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACtC,GAAG,GAAG,QAAQ,GAAG,EAAE,CAAC,CAAC,mBAAmB;IACzC,CAAC;IAED,IAAI,GAAG,CAAC;IAER,IAAI,CAAC;QACJ,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC7C,OAAO,KAAK,CAAC;IACd,CAAC;IAED,MAAM,cAAc,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAEvC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC5C,OAAO,KAAK,CAAC;IACd,CAAC;IAED,OAAO,IAAI,CAAC;AACb,CAAC;AA3BD,gCA2BC"}{
  "name": "@postman/runtime.websocket-client",
  "version": "0.1.0",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/main/packages/clients/websocket-client#readme",
  "license": "UNLICENSED",
  "description": "A simple websocket client for Node.js",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "postman-ws": "7.4.5-postman.1"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/ws": "7.4.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest",
    "coverage": "vitest --coverage"
  }
}# WebSocket-client

A simple WebSocket client for Node.js
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": ["node"]
	}
}
import { ConnectionEndEvent, ErrorEvent, CloseEvent, ReconnectEvent, OpenEvent, UpgradeEvent, MessageEvent } from './connection-events';
import type { SecureContextOptions } from '@postman/runtime.core';
export interface WebsocketAgent {
    connect(options: ConnectionOptions): WebsocketConnection | Promise<WebsocketConnection>;
}
export interface WebsocketConnection {
    send(payload: string | Uint8Array): void;
    close(code?: number, reason?: string): void;
    on(eventName: 'close', listener: (event: CloseEvent) => void): this;
    on(eventName: 'end', listener: (event: ConnectionEndEvent) => void): this;
    on(eventName: 'error', listener: (event: ErrorEvent) => void): this;
    on(eventName: 'message', listener: (event: MessageEvent) => void): this;
    on(eventName: 'reconnect', listener: (event: ReconnectEvent) => void): this;
    on(eventName: 'upgrade', listener: (event: UpgradeEvent) => void): this;
    on(eventName: 'open', listener: (event: OpenEvent) => void): this;
}
export interface ConnectionOptions {
    url: string | URL;
    connectOptions?: {
        handshakeTimeout?: number;
        maxPayload?: number;
        followRedirects?: boolean;
    };
    reconnectOptions?: {
        retryCount?: number;
        retryDelay?: number;
    };
    protocols?: string | string[];
    tlsOptions?: TLSOptions;
    headers: Record<string, string>;
}
export interface TLSOptions {
    rejectUnauthorized?: boolean;
    secureContext?: SecureContextOptions;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=agent.js.map{"version":3,"file":"agent.js","sourceRoot":"","sources":["../src/agent.ts"],"names":[],"mappings":""}export interface HTTPRequest {
    method: 'GET' | 'CONNECT';
    href: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface HTTPResponse {
    statusCode: number;
    statusMessage: string;
    headers: Array<{
        key: string;
        value: string;
    }>;
    httpVersion: string;
}
export interface ConnectionEndEvent {
    code?: number;
    reason?: string;
    aborted: boolean;
}
export interface ErrorEvent {
    error: {
        message: string;
    };
    handshakeRequest?: HTTPRequest;
    handshakeResponse?: HTTPResponse;
}
export interface MessageEvent {
    message: string | Uint8Array;
}
export interface OpenEvent {
    request?: HTTPRequest;
    response?: HTTPResponse;
}
export interface ReconnectEvent {
    attempt: number;
    timeout: number;
}
export interface UpgradeEvent {
    request?: HTTPRequest;
    response?: HTTPResponse;
}
export interface CloseEvent {
    aborted?: boolean;
    code: number;
    reason: string;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=connection-events.js.map{"version":3,"file":"connection-events.js","sourceRoot":"","sources":["../src/connection-events.ts"],"names":[],"mappings":""}import { FromSchema } from 'json-schema-to-ts';
import { Event } from '@postman/runtime.core';
import { MessageType, MessageSubType } from '@postman/runtime.protocol-utils';
declare const definition: {
    connected: {
        schema: {
            type: "object";
            properties: {
                handshakeRequest: {
                    type: "object";
                    required: ["method", "headers", "url"];
                    properties: {
                        method: {
                            type: "string";
                            enum: ["GET", "CONNECT"];
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                        url: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                handshakeResponse: {
                    type: "object";
                    required: ["statusCode", "statusMessage", "headers"];
                    properties: {
                        statusCode: {
                            type: "integer";
                            minimum: 100;
                            maximum: 599;
                        };
                        statusMessage: {
                            type: "string";
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                    };
                    additionalProperties: false;
                };
            };
            additionalProperties: false;
        };
    };
    disconnected: {
        schema: {
            type: "object";
            properties: {
                code: {
                    type: "integer";
                    minimum: 1000;
                    maximum: 4999;
                };
                reason: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
    error: {
        schema: {
            type: "object";
            required: ["error"];
            properties: {
                error: {
                    type: "object";
                    required: ["message"];
                    properties: {
                        message: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                handshakeRequest: {
                    type: "object";
                    required: ["method", "headers", "url"];
                    properties: {
                        method: {
                            type: "string";
                            enum: ["GET", "CONNECT"];
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                        url: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                handshakeResponse: {
                    type: "object";
                    required: ["statusCode", "statusMessage", "headers"];
                    properties: {
                        statusCode: {
                            type: "integer";
                            minimum: 100;
                            maximum: 599;
                        };
                        statusMessage: {
                            type: "string";
                        };
                        headers: {
                            type: "array";
                            items: {
                                type: "object";
                                required: ["key", "value"];
                                properties: {
                                    key: {
                                        type: "string";
                                    };
                                    value: {
                                        type: "string";
                                    };
                                };
                                additionalProperties: false;
                            };
                        };
                    };
                    additionalProperties: false;
                };
            };
            additionalProperties: false;
        };
    };
    reconnecting: {
        schema: {
            type: "object";
            additionalProperties: false;
        };
    };
    aborted: {
        schema: {
            type: "object";
            additionalProperties: false;
        };
    };
    'sent-message': {
        schema: {
            type: "object";
            required: ["data"];
            properties: {
                data: {
                    type: "object";
                    required: ["type", "payload"];
                    properties: {
                        type: {
                            type: "string";
                        };
                        payload: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                mimeType: {
                    type: "string";
                };
                size: {
                    type: "integer";
                    minimum: 0;
                };
                fileExtension: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
    'received-message': {
        schema: {
            type: "object";
            required: ["data"];
            properties: {
                data: {
                    type: "object";
                    required: ["type", "payload"];
                    properties: {
                        type: {
                            type: "string";
                        };
                        payload: {
                            type: "string";
                        };
                    };
                    additionalProperties: false;
                };
                mimeType: {
                    type: "string";
                };
                size: {
                    type: "integer";
                    minimum: 0;
                };
                fileExtension: {
                    type: "string";
                };
            };
            additionalProperties: false;
        };
    };
};
export type Connected = Event<'connected', FromSchema<(typeof definition)['connected']['schema']>>;
export type Error = Event<'error', FromSchema<(typeof definition)['error']['schema']>>;
export type Disconnected = Event<'disconnected', FromSchema<(typeof definition)['disconnected']['schema']>>;
export type Reconnecting = Event<'reconnecting', FromSchema<(typeof definition)['reconnecting']['schema']>>;
export type Aborted = Event<'aborted', FromSchema<(typeof definition)['aborted']['schema']>>;
export type SentMessage = Event<'sent-message', FromSchema<(typeof definition)['sent-message']['schema']>>;
export type ReceivedMessage = Event<'received-message', FromSchema<(typeof definition)['received-message']['schema']>>;
export type Publish = Event<'publish', {
    payload: string;
    messageType: Exclude<MessageType, MessageType.BINARY>;
} | {
    payload: string;
    messageType: MessageType.BINARY;
    messageSubType: MessageSubType;
}>;
export type Close = Event<'close', {
    code?: number;
    reason?: string;
}>;
export {};
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_ts_1 = require("json-schema-to-ts");
const definition = (0, json_schema_to_ts_1.asConst)({
    connected: {
        schema: {
            type: 'object',
            properties: {
                handshakeRequest: {
                    type: 'object',
                    required: ['method', 'headers', 'url'],
                    properties: {
                        method: {
                            type: 'string',
                            enum: ['GET', 'CONNECT'],
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                        url: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeResponse: {
                    type: 'object',
                    required: ['statusCode', 'statusMessage', 'headers'],
                    properties: {
                        statusCode: {
                            type: 'integer',
                            minimum: 100,
                            maximum: 599,
                        },
                        statusMessage: {
                            type: 'string',
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    disconnected: {
        schema: {
            type: 'object',
            properties: {
                code: {
                    type: 'integer',
                    minimum: 1000,
                    maximum: 4999,
                },
                reason: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    error: {
        schema: {
            type: 'object',
            required: ['error'],
            properties: {
                error: {
                    type: 'object',
                    required: ['message'],
                    properties: {
                        message: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeRequest: {
                    type: 'object',
                    required: ['method', 'headers', 'url'],
                    properties: {
                        method: {
                            type: 'string',
                            enum: ['GET', 'CONNECT'],
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                        url: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                handshakeResponse: {
                    type: 'object',
                    required: ['statusCode', 'statusMessage', 'headers'],
                    properties: {
                        statusCode: {
                            type: 'integer',
                            minimum: 100,
                            maximum: 599,
                        },
                        statusMessage: {
                            type: 'string',
                        },
                        headers: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['key', 'value'],
                                properties: {
                                    key: {
                                        type: 'string',
                                    },
                                    value: {
                                        type: 'string',
                                    },
                                },
                                additionalProperties: false,
                            },
                        },
                    },
                    additionalProperties: false,
                },
            },
            additionalProperties: false,
        },
    },
    reconnecting: {
        schema: {
            type: 'object',
            additionalProperties: false,
        },
    },
    aborted: {
        schema: {
            type: 'object',
            additionalProperties: false,
        },
    },
    'sent-message': {
        schema: {
            type: 'object',
            required: ['data'],
            properties: {
                data: {
                    type: 'object',
                    required: ['type', 'payload'],
                    properties: {
                        type: {
                            type: 'string',
                        },
                        payload: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                mimeType: {
                    type: 'string',
                },
                size: {
                    type: 'integer',
                    minimum: 0,
                },
                fileExtension: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
    'received-message': {
        schema: {
            type: 'object',
            required: ['data'],
            properties: {
                data: {
                    type: 'object',
                    required: ['type', 'payload'],
                    properties: {
                        type: {
                            type: 'string',
                        },
                        payload: {
                            type: 'string',
                        },
                    },
                    additionalProperties: false,
                },
                mimeType: {
                    type: 'string',
                },
                size: {
                    type: 'integer',
                    minimum: 0,
                },
                fileExtension: {
                    type: 'string',
                },
            },
            additionalProperties: false,
        },
    },
});
//# sourceMappingURL=events.js.map{"version":3,"file":"events.js","sourceRoot":"","sources":["../src/events.ts"],"names":[],"mappings":"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"}import WebsocketRequest from '.';
declare const _default: (item: import("@postman/runtime.core").Item.OfType<WebsocketRequest>, agent: import("./agent").WebsocketAgent, context: import("@postman/runtime.core").RuntimeContext) => Promise<void>;
export default _default;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = require("@postman/runtime.core");
const runtime_protocol_utils_1 = require("@postman/runtime.protocol-utils");
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const file_type_1 = __importDefault(require("file-type"));
const data_transformers_1 = require("./utils/data-transformers");
const parse_url_1 = require("./utils/parse-url");
exports.default = (async function handler(item, agent, context) {
    if (!item.payload.url) {
        throw new Error('URL is required');
    }
    const url = (0, parse_url_1.parseUrl)(item.payload.url);
    const { variables } = context;
    const settings = {
        connectOptions: {
            handshakeTimeout: item.payload.settings?.handshakeTimeout ?? 0,
            maxPayload: (item.payload.settings?.maxPayload ?? 10) * 1024 * 1024,
            followRedirects: true,
        },
        reconnectOptions: {
            retryCount: item.payload.settings?.retryCount ?? 0,
            retryDelay: item.payload.settings?.retryDelay ?? 5000,
        },
    };
    const headers = (0, data_transformers_1.transformKVItemToObject)(item.payload.headers || []);
    const protocols = (0, data_transformers_1.prepareProtocols)(headers);
    const tlsOptions = url.isTLS ?
        {
            rejectUnauthorized: Boolean(item.payload.settings?.strictSSL),
            secureContext: typeof context.secureContext === 'function' ?
                await context.secureContext(item.payload.url)
                : context.secureContext,
        }
        : {};
    const connection = await agent.connect({
        url: url.url,
        headers,
        protocols,
        ...settings,
        tlsOptions,
    });
    const events = runtime_core_1.EventChannel.specific(context.events);
    const encoder = new TextEncoder();
    const onPublish = (event) => {
        let payload = event.payload.payload;
        if (variables) {
            payload = variables.replaceIn(payload);
        }
        if (event.payload.messageType === runtime_protocol_utils_1.MessageType.POSTMAN_JSON) {
            payload = (0, strip_json_comments_1.default)(payload, { whitespace: false });
        }
        else if (event.payload.messageType === runtime_protocol_utils_1.MessageType.BINARY) {
            payload = (0, runtime_protocol_utils_1.binaryStringToUint8Array)(payload, event.payload.messageSubType);
        }
        const mimeType = runtime_protocol_utils_1.MIME_TYPE_MAP[event.payload.messageType];
        connection.send(payload);
        // Generate synthetic sent message event
        let sentPayload;
        let messageType;
        let payloadSize;
        if (typeof payload === 'string') {
            sentPayload = payload;
            payloadSize = encoder.encode(payload).byteLength;
            messageType = 'String';
        }
        else {
            sentPayload = (0, runtime_protocol_utils_1.uint8ArrayToString)(payload);
            payloadSize = payload.byteLength;
            messageType = 'Uint8Array';
        }
        events.emit('sent-message', {
            data: { payload: sentPayload, type: messageType },
            mimeType,
            size: payloadSize,
        });
    };
    const onClose = (event) => {
        connection.close(event.payload.code, event.payload.reason);
    };
    return new Promise((resolve) => {
        const onDone = () => {
            connection.close();
            events.off('close', onClose).off('publish', onPublish);
            resolve();
        };
        events.on('publish', onPublish).on('close', onClose).onCleanup(onDone);
        connection
            .on('open', ({ request, response }) => {
            const payload = {};
            if (request) {
                const { href, httpVersion, ...rest } = request;
                payload.handshakeRequest = { url: href, ...rest };
            }
            if (response) {
                const { httpVersion, ...rest } = response;
                payload.handshakeResponse = rest;
            }
            events.emit('connected', payload);
        })
            .on('reconnect', () => {
            events.emit('reconnecting', {});
        })
            .on('error', ({ handshakeRequest: request, handshakeResponse: response, error }) => {
            const payload = {
                error: { message: error.message },
            };
            if (request) {
                const { href, httpVersion, ...rest } = request;
                payload.handshakeRequest = { url: href, ...rest };
            }
            if (response) {
                const { httpVersion, ...rest } = response;
                payload.handshakeResponse = rest;
            }
            events.emit('error', payload);
        })
            .on('end', ({ code, reason, aborted }) => {
            if (aborted) {
                events.emit('aborted', {});
            }
            else {
                events.emit('disconnected', { code, reason });
            }
            onDone();
        })
            .on('message', async (event) => {
            const meta = {
                mimeType: 'text/plain',
                size: 0,
                fileExtension: '',
            };
            if (typeof event.message === 'string') {
                meta.size = encoder.encode(event.message).byteLength;
                (0, runtime_protocol_utils_1.isJSON)(event.message) && (meta.mimeType = 'application/json');
                events.emit('received-message', {
                    data: {
                        payload: event.message,
                        type: 'String',
                    },
                    ...meta,
                });
                return;
            }
            else {
                meta.size = event.message.byteLength;
                try {
                    const result = await file_type_1.default.fromBuffer(event.message);
                    meta.mimeType = result?.mime || 'application/octet-stream';
                    meta.fileExtension = result?.ext || 'bin';
                }
                catch (err) {
                    meta.mimeType = 'application/octet-stream';
                    meta.fileExtension = 'bin';
                }
                finally {
                    events.emit('received-message', {
                        data: {
                            payload: (0, runtime_protocol_utils_1.uint8ArrayToString)(event.message),
                            type: 'Uint8Array',
                        },
                        ...meta,
                    });
                }
            }
        });
    });
});
//# sourceMappingURL=handler.js.map{"version":3,"file":"handler.js","sourceRoot":"","sources":["../src/handler.ts"],"names":[],"mappings":";;;;;AACA,wDAA+D;AAC/D,4EAMyC;AAEzC,8EAAoD;AAEpD,0DAAiC;AACjC,iEAGmC;AACnC,iDAA6C;AAE7C,mBAAgB,KAAK,UAAU,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO;IAC1D,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACpC,CAAC;IAED,MAAM,GAAG,GAAG,IAAA,oBAAQ,EAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACvC,MAAM,EAAE,SAAS,EAAE,GAAG,OAAO,CAAC;IAC9B,MAAM,QAAQ,GAAG;QAChB,cAAc,EAAE;YACf,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,gBAAgB,IAAI,CAAC;YAC9D,UAAU,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,UAAU,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,IAAI;YACnE,eAAe,EAAE,IAAI;SACrB;QACD,gBAAgB,EAAE;YACjB,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,UAAU,IAAI,CAAC;YAClD,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,UAAU,IAAI,IAAI;SACrD;KACD,CAAC;IAEF,MAAM,OAAO,GAAG,IAAA,2CAAuB,EAAC,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;IACpE,MAAM,SAAS,GAAG,IAAA,oCAAgB,EAAC,OAAO,CAAC,CAAC;IAE5C,MAAM,UAAU,GACf,GAAG,CAAC,KAAK,CAAC,CAAC;QACV;YACC,kBAAkB,EAAE,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAS,CAAC;YAC7D,aAAa,EACZ,OAAO,OAAO,CAAC,aAAa,KAAK,UAAU,CAAC,CAAC;gBAC5C,MAAM,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,GAAI,CAAC;gBAC/C,CAAC,CAAC,OAAO,CAAC,aAAa;SACxB;QACF,CAAC,CAAC,EAAE,CAAC;IAEN,MAAM,UAAU,GAAG,MAAM,KAAK,CAAC,OAAO,CAAC;QACtC,GAAG,EAAE,GAAG,CAAC,GAAG;QACZ,OAAO;QACP,SAAS;QACT,GAAG,QAAQ;QACX,UAAU;KACV,CAAC,CAAC;IAEH,MAAM,MAAM,GAAG,2BAAY,CAAC,QAAQ,CAGlC,OAAO,CAAC,MAAM,CAAC,CAAC;IAElB,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;IAElC,MAAM,SAAS,GAAG,CAAC,KAAc,EAAE,EAAE;QACpC,IAAI,OAAO,GAAwB,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;QACzD,IAAI,SAAS,EAAE,CAAC;YACf,OAAO,GAAG,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QACxC,CAAC;QACD,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,KAAK,oCAAW,CAAC,YAAY,EAAE,CAAC;YAC5D,OAAO,GAAG,IAAA,6BAAiB,EAAC,OAAO,EAAE,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;QAC7D,CAAC;aAAM,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,KAAK,oCAAW,CAAC,MAAM,EAAE,CAAC;YAC7D,OAAO,GAAG,IAAA,iDAAwB,EAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;QAC3E,CAAC;QACD,MAAM,QAAQ,GAAG,sCAAa,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAE1D,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEzB,wCAAwC;QACxC,IAAI,WAAW,CAAC;QAChB,IAAI,WAAW,CAAC;QAChB,IAAI,WAAW,CAAC;QAEhB,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;YACjC,WAAW,GAAG,OAAO,CAAC;YACtB,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC;YACjD,WAAW,GAAG,QAAQ,CAAC;QACxB,CAAC;aAAM,CAAC;YACP,WAAW,GAAG,IAAA,2CAAkB,EAAC,OAAO,CAAC,CAAC;YAC1C,WAAW,GAAG,OAAO,CAAC,UAAU,CAAC;YACjC,WAAW,GAAG,YAAY,CAAC;QAC5B,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE;YAC3B,IAAI,EAAE,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE;YACjD,QAAQ;YACR,IAAI,EAAE,WAAW;SACjB,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,MAAM,OAAO,GAAG,CAAC,KAAY,EAAE,EAAE;QAChC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAC5D,CAAC,CAAC;IAEF,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;QACpC,MAAM,MAAM,GAAG,GAAG,EAAE;YACnB,UAAU,CAAC,KAAK,EAAE,CAAC;YACnB,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;YAEvD,OAAO,EAAE,CAAC;QACX,CAAC,CAAC;QAEF,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QAEvE,UAAU;aACR,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE;YACrC,MAAM,OAAO,GAAyB,EAAE,CAAC;YACzC,IAAI,OAAO,EAAE,CAAC;gBACb,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;gBAC/C,OAAO,CAAC,gBAAgB,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,EAAE,CAAC;YACnD,CAAC;YACD,IAAI,QAAQ,EAAE,CAAC;gBACd,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,EAAE,GAAG,QAAQ,CAAC;gBAC1C,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAClC,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QACnC,CAAC,CAAC;aACD,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;YACrB,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;QACjC,CAAC,CAAC;aACD,EAAE,CACF,OAAO,EACP,CAAC,EAAE,gBAAgB,EAAE,OAAO,EAAE,iBAAiB,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE;YACrE,MAAM,OAAO,GAAqB;gBACjC,KAAK,EAAE,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE;aACjC,CAAC;YACF,IAAI,OAAO,EAAE,CAAC;gBACb,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;gBAC/C,OAAO,CAAC,gBAAgB,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,EAAE,CAAC;YACnD,CAAC;YACD,IAAI,QAAQ,EAAE,CAAC;gBACd,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,EAAE,GAAG,QAAQ,CAAC;gBAC1C,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC;YAClC,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAC/B,CAAC,CACD;aACA,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE;YACxC,IAAI,OAAO,EAAE,CAAC;gBACb,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;YAC5B,CAAC;iBAAM,CAAC;gBACP,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;YAC/C,CAAC;YACD,MAAM,EAAE,CAAC;QACV,CAAC,CAAC;aACD,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE;YAC9B,MAAM,IAAI,GAAG;gBACZ,QAAQ,EAAE,YAAY;gBACtB,IAAI,EAAE,CAAC;gBACP,aAAa,EAAE,EAAE;aACjB,CAAC;YACF,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;gBACvC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC;gBACrD,IAAA,+BAAM,EAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,kBAAkB,CAAC,CAAC;gBAC9D,MAAM,CAAC,IAAI,CAAC,kBAAkB,EAAE;oBAC/B,IAAI,EAAE;wBACL,OAAO,EAAE,KAAK,CAAC,OAAO;wBACtB,IAAI,EAAE,QAAQ;qBACd;oBACD,GAAG,IAAI;iBACP,CAAC,CAAC;gBACH,OAAO;YACR,CAAC;iBAAM,CAAC;gBACP,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC;gBACrC,IAAI,CAAC;oBACJ,MAAM,MAAM,GAAG,MAAM,mBAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBACxD,IAAI,CAAC,QAAQ,GAAG,MAAM,EAAE,IAAI,IAAI,0BAA0B,CAAC;oBAC3D,IAAI,CAAC,aAAa,GAAG,MAAM,EAAE,GAAG,IAAI,KAAK,CAAC;gBAC3C,CAAC;gBAAC,OAAO,GAAG,EAAE,CAAC;oBACd,IAAI,CAAC,QAAQ,GAAG,0BAA0B,CAAC;oBAC3C,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;gBAC5B,CAAC;wBAAS,CAAC;oBACV,MAAM,CAAC,IAAI,CAAC,kBAAkB,EAAE;wBAC/B,IAAI,EAAE;4BACL,OAAO,EAAE,IAAA,2CAAkB,EAAC,KAAK,CAAC,OAAO,CAAC;4BAC1C,IAAI,EAAE,YAAY;yBAClB;wBACD,GAAG,IAAI;qBACP,CAAC,CAAC;gBACJ,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACJ,CAA+C,EAAC"}import { FromSchema } from 'json-schema-to-ts';
import { ItemType } from '@postman/runtime.core';
import Documentation from '@postman/runtime.documentation';
import Variables from '@postman/runtime.variables';
import * as WebsocketEvents from './events';
import { WebsocketAgent } from './agent';
export * as WebsocketEvents from './events';
export * from './agent';
declare const definition: {
    name: "ws-raw-request";
    summary: "Raw WebSocket Request";
    schema: {
        type: "object";
        properties: {
            url: {
                type: "string";
            };
            headers: {
                type: "array";
                items: {
                    type: "object";
                    required: ["key", "value"];
                    properties: {
                        key: {
                            type: "string";
                        };
                        value: {
                            type: "string";
                        };
                        description: {
                            type: "string";
                        };
                        disabled: {
                            type: "boolean";
                        };
                    };
                    additionalProperties: false;
                };
            };
            queryParams: {
                type: "array";
                items: {
                    type: "object";
                    required: ["key", "value"];
                    properties: {
                        key: {
                            type: ["string", "null"];
                        };
                        value: {
                            type: ["string", "null"];
                        };
                        description: {
                            type: "string";
                        };
                        disabled: {
                            type: "boolean";
                        };
                    };
                    additionalProperties: false;
                };
            };
            settings: {
                type: "object";
                properties: {
                    handshakeTimeout: {
                        type: "integer";
                        minimum: 0;
                    };
                    retryCount: {
                        type: "integer";
                        minimum: 0;
                    };
                    maxPayload: {
                        type: "number";
                        minimum: 0;
                    };
                    retryDelay: {
                        type: "integer";
                        minimum: 0;
                    };
                    strictSSL: {
                        type: "boolean";
                    };
                };
                additionalProperties: false;
            };
        };
        additionalProperties: false;
    };
    constraints: [{
        constraint: "allow-child-types";
        allowed: ["ws-raw-message"];
    }, {
        constraint: "allow-extensions";
        allowed: ["documentation", "variables"];
    }];
};
declare namespace WebsocketRequest {
    type Payload = FromSchema<typeof definition.schema>;
    type Extensions = Documentation | Variables;
    type Config = WebsocketAgent;
    type SentEvents = WebsocketEvents.Publish | WebsocketEvents.Close;
    type ReceivedEvents = WebsocketEvents.Connected | WebsocketEvents.Error | WebsocketEvents.SentMessage | WebsocketEvents.ReceivedMessage | WebsocketEvents.Disconnected | WebsocketEvents.Reconnecting | WebsocketEvents.Aborted;
    const use: () => ItemType.Specific<{
        headers?: {
            description?: string | undefined;
            disabled?: boolean | undefined;
            key: string;
            value: string;
        }[] | undefined;
        url?: string | undefined;
        queryParams?: {
            description?: string | undefined;
            disabled?: boolean | undefined;
            key: string | null;
            value: string | null;
        }[] | undefined;
        settings?: {
            handshakeTimeout?: number | undefined;
            retryCount?: number | undefined;
            maxPayload?: number | undefined;
            retryDelay?: number | undefined;
            strictSSL?: boolean | undefined;
        } | undefined;
    }, Extensions, WebsocketAgent, SentEvents, ReceivedEvents>;
}
type WebsocketRequest = ItemType.Specific<WebsocketRequest.Payload, WebsocketRequest.Extensions, WebsocketRequest.Config, WebsocketRequest.SentEvents, WebsocketRequest.ReceivedEvents>;
export default WebsocketRequest;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketEvents = void 0;
const json_schema_to_ts_1 = require("json-schema-to-ts");
const runtime_core_1 = require("@postman/runtime.core");
const runtime_documentation_1 = __importDefault(require("@postman/runtime.documentation"));
const runtime_variables_1 = __importDefault(require("@postman/runtime.variables"));
const handler_1 = __importDefault(require("./handler"));
exports.WebsocketEvents = __importStar(require("./events"));
__exportStar(require("./agent"), exports);
const definition = (0, json_schema_to_ts_1.asConst)({
    name: 'ws-raw-request',
    summary: 'Raw WebSocket Request',
    schema: {
        type: 'object',
        properties: {
            url: {
                type: 'string',
            },
            headers: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: 'string',
                        },
                        value: {
                            type: 'string',
                        },
                        description: {
                            type: 'string',
                        },
                        disabled: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
            queryParams: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['key', 'value'],
                    properties: {
                        key: {
                            type: ['string', 'null'],
                        },
                        value: {
                            type: ['string', 'null'],
                        },
                        description: {
                            type: 'string',
                        },
                        disabled: {
                            type: 'boolean',
                        },
                    },
                    additionalProperties: false,
                },
            },
            settings: {
                type: 'object',
                properties: {
                    handshakeTimeout: {
                        type: 'integer',
                        minimum: 0,
                    },
                    retryCount: {
                        type: 'integer',
                        minimum: 0,
                    },
                    maxPayload: {
                        type: 'number',
                        minimum: 0,
                    },
                    retryDelay: {
                        type: 'integer',
                        minimum: 0,
                    },
                    strictSSL: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
            },
        },
        additionalProperties: false,
    },
    constraints: [
        {
            constraint: 'allow-child-types',
            allowed: ['ws-raw-message'],
        },
        {
            constraint: 'allow-extensions',
            allowed: ['documentation', 'variables'],
        },
    ],
});
const extensions = [
    runtime_documentation_1.default.use().implement({}),
    runtime_variables_1.default.use().implement({
        replaceInFields: [
            'payload.url',
            'payload.headers',
            'payload.queryParams',
            'extensions.auth',
        ],
    }),
];
var WebsocketRequest;
(function (WebsocketRequest) {
    WebsocketRequest.use = runtime_core_1.ItemType.define(definition, extensions, handler_1.default);
})(WebsocketRequest || (WebsocketRequest = {}));
exports.default = WebsocketRequest;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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"}export interface KeyValueItem {
    key?: string | null;
    value?: string | null;
    disabled?: boolean;
}
export declare function transformKVItemToObject(items: KeyValueItem[]): Record<string, string>;
export declare function prepareProtocols(headers: Record<string, string>): string | undefined;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformKVItemToObject = transformKVItemToObject;
exports.prepareProtocols = prepareProtocols;
function transformKVItemToObject(items) {
    if (!items || items.length === 0)
        return {};
    return items.reduce((acc, { key, value, disabled }) => {
        if (key === null ||
            value === null ||
            Boolean(disabled) ||
            key === undefined ||
            value === undefined)
            return acc;
        acc[key] = value;
        return acc;
    }, {});
}
function prepareProtocols(headers) {
    const headerKeys = Object.keys(headers);
    for (let i = headerKeys.length - 1; i >= 0; i--) {
        if (headerKeys[i].toLowerCase() === 'sec-websocket-protocol') {
            return headers[headerKeys[i]];
        }
    }
    return;
}
//# sourceMappingURL=data-transformers.js.map{"version":3,"file":"data-transformers.js","sourceRoot":"","sources":["../../src/utils/data-transformers.ts"],"names":[],"mappings":";;AAMA,0DAoBC;AAED,4CAWC;AAjCD,SAAgB,uBAAuB,CACtC,KAAqB;IAErB,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IAE5C,OAAO,KAAK,CAAC,MAAM,CAClB,CAAC,GAA2B,EAAE,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,EAAE;QACzD,IACC,GAAG,KAAK,IAAI;YACZ,KAAK,KAAK,IAAI;YACd,OAAO,CAAC,QAAQ,CAAC;YACjB,GAAG,KAAK,SAAS;YACjB,KAAK,KAAK,SAAS;YAEnB,OAAO,GAAG,CAAC;QACZ,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACjB,OAAO,GAAG,CAAC;IACZ,CAAC,EACD,EAAE,CACF,CAAC;AACH,CAAC;AAED,SAAgB,gBAAgB,CAC/B,OAA+B;IAE/B,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAExC,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QACjD,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,KAAK,wBAAwB,EAAE,CAAC;YAC9D,OAAO,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/B,CAAC;IACF,CAAC;IACD,OAAO;AACR,CAAC"}export type ParsedURL = {
    protocol: 'ws' | 'wss';
    url: string;
    port?: string;
    host: string;
    pathname: string;
    isTLS: boolean;
};
export declare function parseUrl(str: string): ParsedURL;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUrl = parseUrl;
function parseUrl(str) {
    str = String(str); // For non-TypeScript applications
    // Test if the string doesn't start with a protocol
    if (!/^[a-z0-9+.-]+:\/\//i.test(str)) {
        str = `ws://${str}`; // Default protocol
    }
    let url;
    try {
        url = new URL(str);
    }
    catch (_) {
        throw new Error(`Invalid URL "${str}"`);
    }
    if (!url.host && !url.port && !url.pathname) {
        throw new Error(`Invalid URL "${str}"`);
    }
    const validProtocols = ['ws:', 'wss:'];
    if (!validProtocols.includes(url.protocol)) {
        throw new Error(`Invalid protocol "${url.protocol}//", try "ws://" instead`);
    }
    const { port } = url;
    return {
        protocol: url.protocol.replace(/:$/, ''),
        host: url.hostname,
        port: port,
        url: url.href,
        pathname: url.pathname,
        isTLS: url.protocol === 'wss:',
    };
}
//# sourceMappingURL=parse-url.js.map{"version":3,"file":"parse-url.js","sourceRoot":"","sources":["../../src/utils/parse-url.ts"],"names":[],"mappings":";;AASA,4BAqCC;AArCD,SAAgB,QAAQ,CAAC,GAAW;IACnC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,kCAAkC;IAErD,mDAAmD;IACnD,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACtC,GAAG,GAAG,QAAQ,GAAG,EAAE,CAAC,CAAC,mBAAmB;IACzC,CAAC;IAED,IAAI,GAAQ,CAAC;IAEb,IAAI,CAAC;QACJ,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC;QACZ,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,cAAc,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAEvC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC5C,MAAM,IAAI,KAAK,CACd,qBAAqB,GAAG,CAAC,QAAQ,0BAA0B,CAC3D,CAAC;IACH,CAAC;IACD,MAAM,EAAE,IAAI,EAAE,GAAG,GAAG,CAAC;IAErB,OAAO;QACN,QAAQ,EAAE,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAA0B;QACjE,IAAI,EAAE,GAAG,CAAC,QAAQ;QAClB,IAAI,EAAE,IAAI;QACV,GAAG,EAAE,GAAG,CAAC,IAAI;QACb,QAAQ,EAAE,GAAG,CAAC,QAAQ;QACtB,KAAK,EAAE,GAAG,CAAC,QAAQ,KAAK,MAAM;KAC9B,CAAC;AACH,CAAC"}{
  "name": "@postman/runtime.websocket-request",
  "version": "0.1.6",
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/item-types/websocket-request#readme",
  "license": "UNLICENSED",
  "description": "The Postman ItemType: 'websocket-request'",
  "exports": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "dependencies": {
    "js-base64": "^3.7.5",
    "json-schema-to-ts": "~2.7.2",
    "strip-json-comments": "^3.1.1",
    "file-type": "^16.5.4"
  },
  "peerDependencies": {
    "@postman/runtime.core": "^*",
    "@postman/runtime.documentation": "^*",
    "@postman/runtime.variables": "^*",
    "@postman/runtime.protocol-utils": "^*"
  },
  "devDependencies": {
    "@postman/runtime.event-channel": "0.2.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest",
    "coverage": "vitest run --coverage"
  }
}# ItemType: `websocket-request`

This package defines the Postman ItemType: `ws-raw-request`.
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../../core/core" },
		{ "path": "../../extensions/documentation" },
		{ "path": "../../extensions/variables" },
		{ "path": "../../utilities/protocol-utils"}
	]
}
export { createRemoteRuntime, RemoteRuntimeConfig } from './remote-runtime';
export { default as CompleteRuntime } from './complete-runtime';
export * from '@postman/runtime.core';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompleteRuntime = exports.createRemoteRuntime = void 0;
var remote_runtime_1 = require("./remote-runtime");
Object.defineProperty(exports, "createRemoteRuntime", { enumerable: true, get: function () { return remote_runtime_1.createRemoteRuntime; } });
var complete_runtime_1 = require("./complete-runtime");
Object.defineProperty(exports, "CompleteRuntime", { enumerable: true, get: function () { return __importDefault(complete_runtime_1).default; } });
__exportStar(require("@postman/runtime.core"), exports);
//# sourceMappingURL=browser.js.map{"version":3,"file":"browser.js","sourceRoot":"","sources":["../src/browser.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,mDAA4E;AAAnE,qHAAA,mBAAmB,OAAA;AAC5B,uDAAgE;AAAvD,oIAAA,OAAO,OAAmB;AACnC,wDAAsC"}import { Item, ItemType, ItemTree, Run, Runtime, RuntimeOptions } from '@postman/runtime.core';
export default class CompleteRuntime extends Runtime {
    execItem<Y extends ItemType = ItemType>(item: Item.OfType<Y>, options?: CompleteRuntimeOptions): Run;
    execTree(tree: ItemTree, options?: CompleteRuntimeOptions): Run;
}
export interface CompleteRuntimeOptions extends RuntimeOptions {
    /**
     * If true, the runtime will stop execution on seeing the
     * first error from the item's or extension's execution and
     * no further events will be emitted.
     */
    stopOnError?: boolean;
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = require("@postman/runtime.core");
/*
    CompleteRuntime is a subclass of Runtime that implements higher-level
    functionality compared to the core Runtime. While the core Runtime only
    provides fundamental behaviors via a minimal API, CompleteRuntime is
    designed to expose all potentially desirable behaviors as plug-and-play
    options. It is inspired by the giant "options" object accepted by the
    "postman-runtime": <https://github.com/postmanlabs/postman-runtime#options>.
*/
class CompleteRuntime extends runtime_core_1.Runtime {
    execItem(item, options) {
        const run = super.execItem(item, options);
        cancelOnError(run, options?.stopOnError);
        return run;
    }
    execTree(tree, options) {
        const run = super.execTree(tree, options);
        cancelOnError(run, options?.stopOnError);
        return run;
    }
}
exports.default = CompleteRuntime;
function cancelOnError(run, stopOnError) {
    if (!stopOnError)
        return;
    run.events.onAll((event) => {
        if (event.payload?.[runtime_core_1.STOP_RUN]) {
            // Cancel run in the next tick to allow
            // the queued event handlers to finish.
            Promise.resolve().then(() => run.cancel());
        }
    });
}
//# sourceMappingURL=complete-runtime.js.map{"version":3,"file":"complete-runtime.js","sourceRoot":"","sources":["../src/complete-runtime.ts"],"names":[],"mappings":";;AAAA,wDAQ+B;AAE/B;;;;;;;EAOE;AAEF,MAAqB,eAAgB,SAAQ,sBAAO;IAC1C,QAAQ,CAChB,IAAoB,EACpB,OAAgC;QAEhC,MAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC1C,aAAa,CAAC,GAAG,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;QAEzC,OAAO,GAAG,CAAC;IACZ,CAAC;IAEQ,QAAQ,CAAC,IAAc,EAAE,OAAgC;QACjE,MAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC1C,aAAa,CAAC,GAAG,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;QAEzC,OAAO,GAAG,CAAC;IACZ,CAAC;CACD;AAjBD,kCAiBC;AAED,SAAS,aAAa,CAAC,GAAQ,EAAE,WAAqB;IACrD,IAAI,CAAC,WAAW;QAAE,OAAO;IAEzB,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;QAC1B,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC,uBAAQ,CAAC,EAAE,CAAC;YAC/B,uCAAuC;YACvC,uCAAuC;YACvC,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;QAC5C,CAAC;IACF,CAAC,CAAC,CAAC;AACJ,CAAC"}export { createRemoteRuntime, RemoteRuntimeConfig } from './remote-runtime';
export { createRuntime, RuntimeConfig } from './runtime';
export { ServerMethods } from './server-methods';
export { default as CompleteRuntime, CompleteRuntimeOptions, } from './complete-runtime';
export * from '@postman/runtime.core';
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompleteRuntime = exports.ServerMethods = exports.createRuntime = exports.createRemoteRuntime = void 0;
var remote_runtime_1 = require("./remote-runtime");
Object.defineProperty(exports, "createRemoteRuntime", { enumerable: true, get: function () { return remote_runtime_1.createRemoteRuntime; } });
var runtime_1 = require("./runtime");
Object.defineProperty(exports, "createRuntime", { enumerable: true, get: function () { return runtime_1.createRuntime; } });
var server_methods_1 = require("./server-methods");
Object.defineProperty(exports, "ServerMethods", { enumerable: true, get: function () { return server_methods_1.ServerMethods; } });
var complete_runtime_1 = require("./complete-runtime");
Object.defineProperty(exports, "CompleteRuntime", { enumerable: true, get: function () { return __importDefault(complete_runtime_1).default; } });
__exportStar(require("@postman/runtime.core"), exports);
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,mDAA4E;AAAnE,qHAAA,mBAAmB,OAAA;AAC5B,qCAAyD;AAAhD,wGAAA,aAAa,OAAA;AACtB,mDAAiD;AAAxC,+GAAA,aAAa,OAAA;AACtB,uDAG4B;AAF3B,oIAAA,OAAO,OAAmB;AAG3B,wDAAsC"}import { Client } from '@postman/runtime.runtime-rpc';
import { GRPCAgent } from '@postman/runtime.grpc-request';
import CompleteRuntime from './complete-runtime';
export interface RemoteRuntimeConfig {
    client: Client;
    grpcRequest?: {
        resolveSchema?: GRPCAgent['resolveSchema'];
    };
}
export declare function createRemoteRuntime({ client, ...config }: RemoteRuntimeConfig): CompleteRuntime;
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRemoteRuntime = createRemoteRuntime;
const runtime_folder_1 = __importDefault(require("@postman/runtime.folder"));
const runtime_collection_1 = __importDefault(require("@postman/runtime.collection"));
const runtime_grpc_request_1 = __importDefault(require("@postman/runtime.grpc-request"));
const runtime_mqtt_request_1 = __importDefault(require("@postman/runtime.mqtt-request"));
const complete_runtime_1 = __importDefault(require("./complete-runtime"));
const runtime_websocket_request_1 = __importDefault(require("@postman/runtime.websocket-request"));
const runtime_socket_io_request_1 = __importDefault(require("@postman/runtime.socket.io-request"));
function createRemoteRuntime({ client, ...config }) {
    const runtime = new complete_runtime_1.default();
    runtime.registerType(runtime_folder_1.default.use());
    runtime.registerType(runtime_collection_1.default.use());
    runtime.registerExecutableType(runtime_grpc_request_1.default.use().implement({
        async invoke(options) {
            const { remote } = await client.invoke('grpc-request.invoke', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['end', 'cancel'], ['write']);
        },
        resolveSchema: config.grpcRequest?.resolveSchema || (() => { }),
    }));
    runtime.registerExecutableType(runtime_mqtt_request_1.default.use().implement({
        async connect(options) {
            const { remote } = await client.invoke('mqtt-request.connect', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['disconnect', 'cancel', 'publish', 'subscribe', 'unsubscribe'], []);
        },
    }));
    runtime.registerExecutableType(runtime_websocket_request_1.default.use().implement({
        async connect(options) {
            const { remote } = await client.invoke('websocket-request.connect', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['close', 'send'], []);
        },
    }));
    runtime.registerExecutableType(runtime_socket_io_request_1.default.use().implement({
        async connect(options) {
            const { remote } = await client.invoke('socketio-request.connect', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['disconnect', 'publish', 'subscribe', 'unsubscribe'], []);
        },
    }));
    return runtime;
}
//# sourceMappingURL=remote-runtime.js.map{"version":3,"file":"remote-runtime.js","sourceRoot":"","sources":["../src/remote-runtime.ts"],"names":[],"mappings":"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"}import { GRPCAgent } from '@postman/runtime.grpc-request';
import CompleteRuntime from './complete-runtime';
export { ServerMethods } from './server-methods';
export interface RuntimeConfig {
    grpcRequest?: {
        resolveSchema?: GRPCAgent['resolveSchema'];
    };
}
export declare function createRuntime(config?: RuntimeConfig): CompleteRuntime;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerMethods = void 0;
exports.createRuntime = createRuntime;
const runtime_folder_1 = __importDefault(require("@postman/runtime.folder"));
const runtime_collection_1 = __importDefault(require("@postman/runtime.collection"));
const GRPCClient = __importStar(require("@postman/runtime.grpc-client"));
const MQTTClient = __importStar(require("@postman/runtime.mqtt-client"));
const SocketIOClient = __importStar(require("@postman/runtime.socket.io-client"));
const WebsocketClient = __importStar(require("@postman/runtime.websocket-client"));
const runtime_grpc_request_1 = __importDefault(require("@postman/runtime.grpc-request"));
const complete_runtime_1 = __importDefault(require("./complete-runtime"));
const runtime_mqtt_request_1 = __importDefault(require("@postman/runtime.mqtt-request"));
const runtime_socket_io_request_1 = __importDefault(require("@postman/runtime.socket.io-request"));
const runtime_websocket_request_1 = __importDefault(require("@postman/runtime.websocket-request"));
var server_methods_1 = require("./server-methods");
Object.defineProperty(exports, "ServerMethods", { enumerable: true, get: function () { return server_methods_1.ServerMethods; } });
function createRuntime(config) {
    const runtime = new complete_runtime_1.default();
    runtime.registerType(runtime_folder_1.default.use());
    runtime.registerType(runtime_collection_1.default.use());
    runtime.registerExecutableType(runtime_grpc_request_1.default.use().implement({
        invoke: (options) => GRPCClient.invoke(options),
        resolveSchema: config?.grpcRequest?.resolveSchema || (() => { }),
    }));
    runtime.registerExecutableType(runtime_mqtt_request_1.default.use().implement({
        connect: (options) => MQTTClient.connect(options),
    }));
    runtime.registerExecutableType(runtime_websocket_request_1.default.use().implement({
        connect: (options) => WebsocketClient.connect(options),
    }));
    runtime.registerExecutableType(runtime_socket_io_request_1.default.use().implement({
        connect: (options) => SocketIOClient.connect(options),
    }));
    return runtime;
}
//# sourceMappingURL=runtime.js.map{"version":3,"file":"runtime.js","sourceRoot":"","sources":["../src/runtime.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,sCA+BC;AAtDD,6EAA6C;AAC7C,qFAAqD;AACrD,yEAA2D;AAC3D,yEAA2D;AAC3D,kFAAoE;AACpE,mFAAqE;AACrE,yFAAuE;AACvE,0EAAiD;AACjD,yFAAwD;AACxD,mGAAiE;AACjE,mGAAkE;AAClE,mDAAiD;AAAxC,+GAAA,aAAa,OAAA;AAYtB,SAAgB,aAAa,CAAC,MAAsB;IACnD,MAAM,OAAO,GAAG,IAAI,0BAAe,EAAE,CAAC;IACtC,OAAO,CAAC,YAAY,CAAC,wBAAM,CAAC,GAAG,EAAE,CAAC,CAAC;IACnC,OAAO,CAAC,YAAY,CAAC,4BAAU,CAAC,GAAG,EAAE,CAAC,CAAC;IAEvC,OAAO,CAAC,sBAAsB,CAC7B,8BAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC;QAC3B,MAAM,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC;QAC/C,aAAa,EAAE,MAAM,EAAE,WAAW,EAAE,aAAa,IAAI,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC;KAC/D,CAAC,CACF,CAAC;IAEF,OAAO,CAAC,sBAAsB,CAC7B,8BAAW,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC;QAC3B,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC;KACjD,CAAC,CACF,CAAC;IAEF,OAAO,CAAC,sBAAsB,CAC7B,mCAAgB,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC;QAChC,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC;KACtD,CAAC,CACF,CAAC;IAEF,OAAO,CAAC,sBAAsB,CAC7B,mCAAe,CAAC,GAAG,EAAE,CAAC,SAAS,CAAC;QAC/B,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC;KACrD,CAAC,CACF,CAAC;IAEF,OAAO,OAAO,CAAC;AAChB,CAAC"}import { MethodHandler } from '@postman/runtime.runtime-rpc';
export declare const ServerMethods: Record<string, MethodHandler>;
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerMethods = void 0;
const runtime_runtime_rpc_1 = require("@postman/runtime.runtime-rpc");
const GRPCClient = __importStar(require("@postman/runtime.grpc-client"));
const MQTTClient = __importStar(require("@postman/runtime.mqtt-client"));
const SocketIOClient = __importStar(require("@postman/runtime.socket.io-client"));
const WebsocketClient = __importStar(require("@postman/runtime.websocket-client"));
/*
    This file defines the standard RPC methods supported by Runtime servers.
*/
exports.ServerMethods = {
    'grpc-request.invoke': async (options) => {
        const invocation = GRPCClient.invoke(options);
        const remote = new runtime_runtime_rpc_1.ProxyResult(invocation);
        invocation.on('status', () => remote.disconnect());
        remote.onCleanup(() => invocation.cancel());
        return { remote };
    },
    'mqtt-request.connect': async (options) => {
        const connection = MQTTClient.connect(options);
        const remote = new runtime_runtime_rpc_1.ProxyResult(connection);
        connection.on('close', () => remote.disconnect());
        remote.onCleanup(() => connection.disconnect());
        return { remote };
    },
    'websocket-request.connect': async (options) => {
        const connection = WebsocketClient.connect(options);
        const remote = new runtime_runtime_rpc_1.ProxyResult(connection);
        connection.on('end', () => remote.disconnect());
        remote.onCleanup(() => connection.close());
        return { remote };
    },
    'socketio-request.connect': async (options) => {
        const connection = SocketIOClient.connect(options);
        const remote = new runtime_runtime_rpc_1.ProxyResult(connection);
        connection.on('end', () => remote.disconnect());
        remote.onCleanup(() => connection.disconnect());
        return { remote };
    },
};
//# sourceMappingURL=server-methods.js.map{"version":3,"file":"server-methods.js","sourceRoot":"","sources":["../src/server-methods.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sEAA0E;AAC1E,yEAA2D;AAC3D,yEAA2D;AAC3D,kFAAoE;AACpE,mFAAqE;AACrE;;EAEE;AAEW,QAAA,aAAa,GAAkC;IAC3D,qBAAqB,EAAE,KAAK,EAAE,OAAY,EAAE,EAAE;QAC7C,MAAM,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,iCAAW,CAAC,UAAU,CAAC,CAAC;QAC3C,UAAU,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QACnD,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,CAAC;QAC5C,OAAO,EAAE,MAAM,EAAE,CAAC;IACnB,CAAC;IAED,sBAAsB,EAAE,KAAK,EAAE,OAAY,EAAE,EAAE;QAC9C,MAAM,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAC/C,MAAM,MAAM,GAAG,IAAI,iCAAW,CAAC,UAAU,CAAC,CAAC;QAC3C,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QAClD,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC;QAChD,OAAO,EAAE,MAAM,EAAE,CAAC;IACnB,CAAC;IAED,2BAA2B,EAAE,KAAK,EAAE,OAAY,EAAE,EAAE;QACnD,MAAM,UAAU,GAAG,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QACpD,MAAM,MAAM,GAAG,IAAI,iCAAW,CAAC,UAAU,CAAC,CAAC;QAC3C,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QAChD,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;QAC3C,OAAO,EAAE,MAAM,EAAE,CAAC;IACnB,CAAC;IAED,0BAA0B,EAAE,KAAK,EAAE,OAAY,EAAE,EAAE;QAClD,MAAM,UAAU,GAAG,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QACnD,MAAM,MAAM,GAAG,IAAI,iCAAW,CAAC,UAAU,CAAC,CAAC;QAC3C,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QAChD,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC;QAChD,OAAO,EAAE,MAAM,EAAE,CAAC;IACnB,CAAC;CACD,CAAC"}{
  "name": "@postman/runtime",
  "version": "0.4.14",
  "license": "UNLICENSED",
  "description": "A complete Runtime that contains all ItemTypes supported by Postman",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/postmanlabs/unified-runtime-monorepo.git"
  },
  "publishConfig": {
    "access": "restricted"
  },
  "homepage": "https://github.com/postmanlabs/unified-runtime-monorepo/tree/master/packages/core/runtime#readme",
  "exports": {
    "node": "./dist/index.js",
    "browser": "./dist/browser.js",
    "types": "./dist/index.d.ts"
  },
  "types": "./dist/index.d.ts",
  "dependencies": {
    "@postman/runtime.documentation": "^0.1.13",
    "@postman/runtime.auth": "^0.1.13",
    "@postman/runtime.folder": "^0.1.13",
    "@postman/runtime.core": "^0.4.0",
    "@postman/runtime.grpc-request": "^0.2.10",
    "@postman/runtime.grpc-client": "^0.2.5",
    "@postman/runtime.runtime-rpc": "^0.2.0",
    "@postman/runtime.schema": "^0.1.13",
    "@postman/runtime.mqtt-client": "^0.3.1",
    "@postman/runtime.protocol-utils": "^0.0.1",
    "@postman/runtime.events": "^0.2.0",
    "@postman/runtime.collection": "^0.1.13",
    "@postman/runtime.socket.io-request": "^0.1.6",
    "@postman/runtime.websocket-client": "^0.1.0",
    "@postman/runtime.variables": "^0.1.13",
    "@postman/runtime.socket.io-client": "^0.1.3",
    "@postman/runtime.websocket-request": "^0.1.6",
    "@postman/runtime.mqtt-request": "^0.4.1"
  },
  "devDependencies": {
    "@postman/test-servers": "^0.0.0"
  },
  "files": [
    "*.js",
    "*.json",
    "dist"
  ],
  "scripts": {
    "build": "tsc --build",
    "clean": "rm -rf node_modules dist tsconfig.tsbuildinfo package-lock.json",
    "format": "prettier --write src test",
    "test": "vitest"
  }
}# Runtime

This package provides a complete `Runtime`, allowing you to validate and execute Items (and trees of Items) for all ItemTypes supported by Postman.

See [@postman/runtime.core](../core) for more information about the `Runtime` class.

## Node.js usage

```js
import { createRuntime } from '@postman/runtime';

const runtime = createRuntime();
const run = runtime.execItem(myGrpcItem);

for await (const event of run) {
	console.log(event);
}
```

## Browser usage

In the browser, you'll need a RuntimeRPC client to connect to a Runtime server. The RuntimeRPC connection is usually over [WebSockets](../../runtime-rpc/runtime-rpc-ws) or [Electron IPC](../../runtime-rpc/runtime-rpc-electron).

```js
import { createRemoteRuntime } from '@postman/runtime';
import { Client as ElectronClient } from '@postman/runtime.runtime-rpc-electron';
import { Client as WebSocketClient } from '@postman/runtime.runtime-rpc-ws';

let client;
if (/\belectron\//i.test(navigator.userAgent)) {
	client = new ElectronClient('my-ipc-channel-name');
} else {
	client = new WebSocketClient('ws://my-websocket-server.com');
}

const runtime = createRemoteRuntime({ client });
const run = runtime.execItem(myGrpcItem);

for await (const event of run) {
	console.log(event);
}
```

## Setting up a Runtime server over WebSockets

```js
import { Server } from '@postman/runtime.runtime-rpc-ws';
import { ServerMethods } from '@postman/runtime';

const runtimeServer = new Server({ port }, ServerMethods);

runtimeServer.whenListening().then(() => {
  console.log(`listening on port ${runtimeServer.address().port}`);
});
```

## Setting up a Runtime server over Electron IPC

```js
import { Server } from '@postman/runtime.runtime-rpc-electron';
import { ServerMethods } from '@postman/runtime';

const runtimeServer = new Server('my-ipc-channel-name', ServerMethods);
```
{
	"extends": "../../../tsconfig.base.json",
	"include": ["./src/**/*"],
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist",
		"types": []
	},
	"references": [
		{ "path": "../../clients/grpc-client" },
		{ "path": "../../clients/mqtt-client" },
		{ "path": "../../clients/websocket-client" },
		{ "path": "../../clients/socket-io-client"},
		{ "path": "../../core/core" },
		{ "path": "../../extensions/auth" },
		{ "path": "../../extensions/documentation" },
		{ "path": "../../extensions/events" },
		{ "path": "../../extensions/schema" },
		{ "path": "../../extensions/variables" },
		{ "path": "../../item-types/collection" },
		{ "path": "../../item-types/folder" },
		{ "path": "../../item-types/grpc-request" },
		{ "path": "../../item-types/mqtt-request" },
		{ "path": "../../item-types/socket-io-request" },
		{ "path": "../../item-types/websocket-request" },
		{ "path": "../../rpc/runtime-rpc" }
	]
}
/*!
 * Copyright (c) 2015-2020, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const punycode = require("punycode/");
const urlParse = require("url-parse");
const pubsuffix = require("./pubsuffix-psl");
const Store = require("./store").Store;
const MemoryCookieStore = require("./memstore").MemoryCookieStore;
const pathMatch = require("./pathMatch").pathMatch;
const validators = require("./validators.js");
const VERSION = require("./version");
const { fromCallback } = require("universalify");
const { getCustomInspectSymbol } = require("./utilHelper");

// From RFC6265 S4.1.1
// note that it excludes \x3B ";"
const COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;

const CONTROL_CHARS = /[\x00-\x1F]/;

// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
// the "relaxed" mode, see:
// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
const TERMINATORS = ["\n", "\r", "\0"];

// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
// Note ';' is \x3B
const PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

// date-time parsing constants (RFC6265 S5.1.1)

const DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

const MONTH_TO_NUM = {
  jan: 0,
  feb: 1,
  mar: 2,
  apr: 3,
  may: 4,
  jun: 5,
  jul: 6,
  aug: 7,
  sep: 8,
  oct: 9,
  nov: 10,
  dec: 11
};

const MAX_TIME = 2147483647000; // 31-bit max
const MIN_TIME = 0; // 31-bit min
const SAME_SITE_CONTEXT_VAL_ERR =
  'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';

function checkSameSiteContext(value) {
  validators.validate(validators.isNonEmptyString(value), value);
  const context = String(value).toLowerCase();
  if (context === "none" || context === "lax" || context === "strict") {
    return context;
  } else {
    return null;
  }
}

const PrefixSecurityEnum = Object.freeze({
  SILENT: "silent",
  STRICT: "strict",
  DISABLED: "unsafe-disabled"
});

// Dumped from ip-regex@4.0.0, with the following changes:
// * all capturing groups converted to non-capturing -- "(?:)"
// * support for IPv6 Scoped Literal ("%eth1") removed
// * lowercase hexadecimal only
const IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
const IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`
  .replace(/\s*\/\/.*$/gm, "")
  .replace(/\n/g, "")
  .trim();
const IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);

/*
 * Parses a Natural number (i.e., non-negative integer) with either the
 *    <min>*<max>DIGIT ( non-digit *OCTET )
 * or
 *    <min>*<max>DIGIT
 * grammar (RFC6265 S5.1.1).
 *
 * The "trailingOK" boolean controls if the grammar accepts a
 * "( non-digit *OCTET )" trailer.
 */
function parseDigits(token, minDigits, maxDigits, trailingOK) {
  let count = 0;
  while (count < token.length) {
    const c = token.charCodeAt(count);
    // "non-digit = %x00-2F / %x3A-FF"
    if (c <= 0x2f || c >= 0x3a) {
      break;
    }
    count++;
  }

  // constrain to a minimum and maximum number of digits.
  if (count < minDigits || count > maxDigits) {
    return null;
  }

  if (!trailingOK && count != token.length) {
    return null;
  }

  return parseInt(token.substr(0, count), 10);
}

function parseTime(token) {
  const parts = token.split(":");
  const result = [0, 0, 0];

  /* RF6256 S5.1.1:
   *      time            = hms-time ( non-digit *OCTET )
   *      hms-time        = time-field ":" time-field ":" time-field
   *      time-field      = 1*2DIGIT
   */

  if (parts.length !== 3) {
    return null;
  }

  for (let i = 0; i < 3; i++) {
    // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
    // followed by "( non-digit *OCTET )" so therefore the last time-field can
    // have a trailer
    const trailingOK = i == 2;
    const num = parseDigits(parts[i], 1, 2, trailingOK);
    if (num === null) {
      return null;
    }
    result[i] = num;
  }

  return result;
}

function parseMonth(token) {
  token = String(token)
    .substr(0, 3)
    .toLowerCase();
  const num = MONTH_TO_NUM[token];
  return num >= 0 ? num : null;
}

/*
 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
 */
function parseDate(str) {
  if (!str) {
    return;
  }

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  const tokens = str.split(DATE_DELIM);
  if (!tokens) {
    return;
  }

  let hour = null;
  let minute = null;
  let second = null;
  let dayOfMonth = null;
  let month = null;
  let year = null;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].trim();
    if (!token.length) {
      continue;
    }

    let result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (second === null) {
      result = parseTime(token);
      if (result) {
        hour = result[0];
        minute = result[1];
        second = result[2];
        continue;
      }
    }

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (dayOfMonth === null) {
      // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 1, 2, true);
      if (result !== null) {
        dayOfMonth = result;
        continue;
      }
    }

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (month === null) {
      result = parseMonth(token);
      if (result !== null) {
        month = result;
        continue;
      }
    }

    /* 2.4. If the found-year flag is not set and the date-token matches the
     * year production, set the found-year flag and set the year-value to the
     * number denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (year === null) {
      // "year = 2*4DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 2, 4, true);
      if (result !== null) {
        year = result;
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (year >= 70 && year <= 99) {
          year += 1900;
        } else if (year >= 0 && year <= 69) {
          year += 2000;
        }
      }
    }
  }

  /* RFC 6265 S5.1.1
   * "5. Abort these steps and fail to parse the cookie-date if:
   *     *  at least one of the found-day-of-month, found-month, found-
   *        year, or found-time flags is not set,
   *     *  the day-of-month-value is less than 1 or greater than 31,
   *     *  the year-value is less than 1601,
   *     *  the hour-value is greater than 23,
   *     *  the minute-value is greater than 59, or
   *     *  the second-value is greater than 59.
   *     (Note that leap seconds cannot be represented in this syntax.)"
   *
   * So, in order as above:
   */
  if (
    dayOfMonth === null ||
    month === null ||
    year === null ||
    second === null ||
    dayOfMonth < 1 ||
    dayOfMonth > 31 ||
    year < 1601 ||
    hour > 23 ||
    minute > 59 ||
    second > 59
  ) {
    return;
  }

  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}

function formatDate(date) {
  validators.validate(validators.isDate(date), date);
  return date.toUTCString();
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str) {
  if (str == null) {
    return null;
  }
  str = str.trim().replace(/^\./, ""); // S4.1.2.3 & S5.2.3: ignore leading .

  if (IP_V6_REGEX_OBJECT.test(str)) {
    str = str.replace("[", "").replace("]", "");
  }

  // convert to IDN if any non-ASCII characters
  if (punycode && /[^\u0001-\u007f]/.test(str)) {
    str = punycode.toASCII(str);
  }

  return str.toLowerCase();
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) {
    return null;
  }
  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  /*
   * S5.1.3:
   * "A string domain-matches a given domain string if at least one of the
   * following conditions hold:"
   *
   * " o The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point)"
   */
  if (str == domStr) {
    return true;
  }

  /* " o All of the following [three] conditions hold:" */

  /* "* The domain string is a suffix of the string" */
  const idx = str.lastIndexOf(domStr);
  if (idx <= 0) {
    return false; // it's a non-match (-1) or prefix (0)
  }

  // next, check it's a proper suffix
  // e.g., "a.b.c".indexOf("b.c") === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx) {
    return false; // it's not a suffix
  }

  /* "  * The last character of the string that is not included in the
   * domain string is a %x2E (".") character." */
  if (str.substr(idx - 1, 1) !== ".") {
    return false; // doesn't align on "."
  }

  /* "  * The string is a host name (i.e., not an IP address)." */
  if (IP_REGEX_LOWERCASE.test(str)) {
    return false; // it's an IP address
  }

  return true;
}

// RFC6265 S5.1.4 Paths and Path-Match

/*
 * "The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:"
 *
 * Assumption: the path (and not query part or absolute uri) is passed in.
 */
function defaultPath(path) {
  // "2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
  if (!path || path.substr(0, 1) !== "/") {
    return "/";
  }

  // "3. If the uri-path contains no more than one %x2F ("/") character, output
  // %x2F ("/") and skip the remaining step."
  if (path === "/") {
    return path;
  }

  const rightSlash = path.lastIndexOf("/");
  if (rightSlash === 0) {
    return "/";
  }

  // "4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F ("/")."
  return path.slice(0, rightSlash);
}

function trimTerminator(str) {
  if (validators.isEmptyString(str)) return str;
  for (let t = 0; t < TERMINATORS.length; t++) {
    const terminatorIdx = str.indexOf(TERMINATORS[t]);
    if (terminatorIdx !== -1) {
      str = str.substr(0, terminatorIdx);
    }
  }

  return str;
}

function parseCookiePair(cookiePair, looseMode) {
  cookiePair = trimTerminator(cookiePair);
  validators.validate(validators.isString(cookiePair), cookiePair);

  let firstEq = cookiePair.indexOf("=");
  if (looseMode) {
    if (firstEq === 0) {
      // '=' is immediately at start
      cookiePair = cookiePair.substr(1);
      firstEq = cookiePair.indexOf("="); // might still need to split on '='
    }
  } else {
    // non-loose mode
    if (firstEq <= 0) {
      // no '=' or is at start
      return; // needs to have non-empty "cookie-name"
    }
  }

  let cookieName, cookieValue;
  if (firstEq <= 0) {
    cookieName = "";
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.substr(0, firstEq).trim();
    cookieValue = cookiePair.substr(firstEq + 1).trim();
  }

  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    return;
  }

  const c = new Cookie();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}

function parse(str, options) {
  if (!options || typeof options !== "object") {
    options = {};
  }

  if (validators.isEmptyString(str) || !validators.isString(str)) {
    return null;
  }

  str = str.trim();

  // We use a regex to parse the "name-value-pair" part of S5.2
  const firstSemi = str.indexOf(";"); // S5.2 step 1
  const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
  const c = parseCookiePair(cookiePair, !!options.loose);
  if (!c) {
    return;
  }

  if (firstSemi === -1) {
    return c;
  }

  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (";") in question)." plus later on in the same section
  // "discard the first ";" and trim".
  const unparsed = str.slice(firstSemi + 1).trim();

  // "If the unparsed-attributes string is empty, skip the rest of these
  // steps."
  if (unparsed.length === 0) {
    return c;
  }

  /*
   * S5.2 says that when looping over the items "[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections" for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the "attribute-value of the last attribute in the
   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  const cookie_avs = unparsed.split(";");
  while (cookie_avs.length) {
    const av = cookie_avs.shift().trim();
    if (av.length === 0) {
      // happens if ";;" appears
      continue;
    }
    const av_sep = av.indexOf("=");
    let av_key, av_value;

    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0, av_sep);
      av_value = av.substr(av_sep + 1);
    }

    av_key = av_key.trim().toLowerCase();

    if (av_value) {
      av_value = av_value.trim();
    }

    switch (av_key) {
      case "expires": // S5.2.1
        if (av_value) {
          const exp = parseDate(av_value);
          // "If the attribute-value failed to parse as a cookie date, ignore the
          // cookie-av."
          if (exp) {
            // over and underflow not realistically a concern: V8's getTime() seems to
            // store something larger than a 32-bit time_t (even with 32-bit node)
            c.expires = exp;
          }
        }
        break;

      case "max-age": // S5.2.2
        if (av_value) {
          // "If the first character of the attribute-value is not a DIGIT or a "-"
          // character ...[or]... If the remainder of attribute-value contains a
          // non-DIGIT character, ignore the cookie-av."
          if (/^-?[0-9]+$/.test(av_value)) {
            const delta = parseInt(av_value, 10);
            // "If delta-seconds is less than or equal to zero (0), let expiry-time
            // be the earliest representable date and time."
            c.setMaxAge(delta);
          }
        }
        break;

      case "domain": // S5.2.3
        // "If the attribute-value is empty, the behavior is undefined.  However,
        // the user agent SHOULD ignore the cookie-av entirely."
        if (av_value) {
          // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
          // (".") character."
          const domain = av_value.trim().replace(/^\./, "");
          if (domain) {
            // "Convert the cookie-domain to lower case."
            c.domain = domain.toLowerCase();
          }
        }
        break;

      case "path": // S5.2.4
        /*
         * "If the attribute-value is empty or if the first character of the
         * attribute-value is not %x2F ("/"):
         *   Let cookie-path be the default-path.
         * Otherwise:
         *   Let cookie-path be the attribute-value."
         *
         * We'll represent the default-path as null since it depends on the
         * context of the parsing.
         */
        c.path = av_value && av_value[0] === "/" ? av_value : null;
        break;

      case "secure": // S5.2.5
        /*
         * "If the attribute-name case-insensitively matches the string "Secure",
         * the user agent MUST append an attribute to the cookie-attribute-list
         * with an attribute-name of Secure and an empty attribute-value."
         */
        c.secure = true;
        break;

      case "httponly": // S5.2.6 -- effectively the same as 'secure'
        c.httpOnly = true;
        break;

      case "samesite": // RFC6265bis-02 S5.3.7
        const enforcement = av_value ? av_value.toLowerCase() : "";
        switch (enforcement) {
          case "strict":
            c.sameSite = "strict";
            break;
          case "lax":
            c.sameSite = "lax";
            break;
          case "none":
            c.sameSite = "none";
            break;
          default:
            c.sameSite = undefined;
            break;
        }
        break;

      default:
        c.extensions = c.extensions || [];
        c.extensions.push(av);
        break;
    }
  }

  return c;
}

/**
 *  If the cookie-name begins with a case-sensitive match for the
 *  string "__Secure-", abort these steps and ignore the cookie
 *  entirely unless the cookie's secure-only-flag is true.
 * @param cookie
 * @returns boolean
 */
function isSecurePrefixConditionMet(cookie) {
  validators.validate(validators.isObject(cookie), cookie);
  return !cookie.key.startsWith("__Secure-") || cookie.secure;
}

/**
 *  If the cookie-name begins with a case-sensitive match for the
 *  string "__Host-", abort these steps and ignore the cookie
 *  entirely unless the cookie meets all the following criteria:
 *    1.  The cookie's secure-only-flag is true.
 *    2.  The cookie's host-only-flag is true.
 *    3.  The cookie-attribute-list contains an attribute with an
 *        attribute-name of "Path", and the cookie's path is "/".
 * @param cookie
 * @returns boolean
 */
function isHostPrefixConditionMet(cookie) {
  validators.validate(validators.isObject(cookie));
  return (
    !cookie.key.startsWith("__Host-") ||
    (cookie.secure &&
      cookie.hostOnly &&
      cookie.path != null &&
      cookie.path === "/")
  );
}

// avoid the V8 deoptimization monster!
function jsonParse(str) {
  let obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return e;
  }
  return obj;
}

function fromJSON(str) {
  if (!str || validators.isEmptyString(str)) {
    return null;
  }

  let obj;
  if (typeof str === "string") {
    obj = jsonParse(str);
    if (obj instanceof Error) {
      return null;
    }
  } else {
    // assume it's an Object
    obj = str;
  }

  const c = new Cookie();
  for (let i = 0; i < Cookie.serializableProperties.length; i++) {
    const prop = Cookie.serializableProperties[i];
    if (obj[prop] === undefined || obj[prop] === cookieDefaults[prop]) {
      continue; // leave as prototype default
    }

    if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
      if (obj[prop] === null) {
        c[prop] = null;
      } else {
        c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
      }
    } else {
      c[prop] = obj[prop];
    }
  }

  return c;
}

/* Section 5.4 part 2:
 * "*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times."
 */

function cookieCompare(a, b) {
  validators.validate(validators.isObject(a), a);
  validators.validate(validators.isObject(b), b);
  let cmp = 0;

  // descending for length: b CMP a
  const aPathLen = a.path ? a.path.length : 0;
  const bPathLen = b.path ? b.path.length : 0;
  cmp = bPathLen - aPathLen;
  if (cmp !== 0) {
    return cmp;
  }

  // ascending for time: a CMP b
  const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
  const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
  cmp = aTime - bTime;
  if (cmp !== 0) {
    return cmp;
  }

  // break ties for the same millisecond (precision of JavaScript's clock)
  cmp = a.creationIndex - b.creationIndex;

  return cmp;
}

// Gives the permutation of all possible pathMatch()es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path) {
  validators.validate(validators.isString(path));
  if (path === "/") {
    return ["/"];
  }
  const permutations = [path];
  while (path.length > 1) {
    const lindex = path.lastIndexOf("/");
    if (lindex === 0) {
      break;
    }
    path = path.substr(0, lindex);
    permutations.push(path);
  }
  permutations.push("/");
  return permutations;
}

function getCookieContext(url) {
  if (url instanceof Object) {
    return url;
  }
  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
  // Therefore, we will just skip decoding for such URIs.
  try {
    url = decodeURI(url);
  } catch (err) {
    // Silently swallow error
  }

  return urlParse(url);
}

function isLocalhost(host) {
  if (!(host && typeof host === "string")) {
    return false;
  }

  if (host === "localhost" || host.endsWith(".localhost")) {
    return true;
  }

  // check if IPv6 loopback address
  if (host === "::1") {
    return true;
  }

  // check if IPv4 loopback address
  if (IP_REGEX_LOWERCASE.test(host)) {
    return host.startsWith("127.");
  }

  return false;
}

const cookieDefaults = {
  // the order in which the RFC has them:
  key: "",
  value: "",
  expires: "Infinity",
  maxAge: null,
  domain: null,
  path: null,
  secure: false,
  httpOnly: false,
  extensions: null,
  // set by the CookieJar:
  hostOnly: null,
  pathIsDefault: null,
  creation: null,
  lastAccessed: null,
  sameSite: undefined
};

class Cookie {
  constructor(options = {}) {
    const customInspectSymbol = getCustomInspectSymbol();
    if (customInspectSymbol) {
      this[customInspectSymbol] = this.inspect;
    }

    Object.assign(this, cookieDefaults, options);
    this.creation = this.creation || new Date();

    // used to break creation ties in cookieCompare():
    Object.defineProperty(this, "creationIndex", {
      configurable: false,
      enumerable: false, // important for assert.deepEqual checks
      writable: true,
      value: ++Cookie.cookiesCreated
    });
  }

  inspect() {
    const now = Date.now();
    const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
    const createAge = this.creation
      ? `${now - this.creation.getTime()}ms`
      : "?";
    const accessAge = this.lastAccessed
      ? `${now - this.lastAccessed.getTime()}ms`
      : "?";
    return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
  }

  toJSON() {
    const obj = {};

    for (const prop of Cookie.serializableProperties) {
      if (this[prop] === cookieDefaults[prop]) {
        continue; // leave as prototype default
      }

      if (
        prop === "expires" ||
        prop === "creation" ||
        prop === "lastAccessed"
      ) {
        if (this[prop] === null) {
          obj[prop] = null;
        } else {
          obj[prop] =
            this[prop] == "Infinity" // intentionally not ===
              ? "Infinity"
              : this[prop].toISOString();
        }
      } else if (prop === "maxAge") {
        if (this[prop] !== null) {
          // again, intentionally not ===
          obj[prop] =
            this[prop] == Infinity || this[prop] == -Infinity
              ? this[prop].toString()
              : this[prop];
        }
      } else {
        if (this[prop] !== cookieDefaults[prop]) {
          obj[prop] = this[prop];
        }
      }
    }

    return obj;
  }

  clone() {
    return fromJSON(this.toJSON());
  }

  validate() {
    if (!COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (
      this.expires != Infinity &&
      !(this.expires instanceof Date) &&
      !parseDate(this.expires)
    ) {
      return false;
    }
    if (this.maxAge != null && this.maxAge <= 0) {
      return false; // "Max-Age=" non-zero-digit *DIGIT
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }

    const cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
      }
      const suffix = pubsuffix.getPublicSuffix(cdomain);
      if (suffix == null) {
        // it's a public suffix
        return false;
      }
    }
    return true;
  }

  setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = parseDate(exp) || "Infinity";
    }
  }

  setMaxAge(age) {
    if (age === Infinity || age === -Infinity) {
      this.maxAge = age.toString(); // so JSON.stringify() works
    } else {
      this.maxAge = age;
    }
  }

  cookieString() {
    let val = this.value;
    if (val == null) {
      val = "";
    }
    if (this.key === "") {
      return val;
    }
    return `${this.key}=${val}`;
  }

  // gives Set-Cookie header format
  toString() {
    let str = this.cookieString();

    if (this.expires != Infinity) {
      if (this.expires instanceof Date) {
        str += `; Expires=${formatDate(this.expires)}`;
      } else {
        str += `; Expires=${this.expires}`;
      }
    }

    if (this.maxAge != null && this.maxAge != Infinity) {
      str += `; Max-Age=${this.maxAge}`;
    }

    if (this.domain && !this.hostOnly) {
      str += `; Domain=${this.domain}`;
    }
    if (this.path) {
      str += `; Path=${this.path}`;
    }

    if (this.secure) {
      str += "; Secure";
    }
    if (this.httpOnly) {
      str += "; HttpOnly";
    }
    if (this.sameSite && this.sameSite !== "none") {
      const ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
      str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
    }
    if (this.extensions) {
      this.extensions.forEach(ext => {
        str += `; ${ext}`;
      });
    }

    return str;
  }

  // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
  // elsewhere)
  // S5.3 says to give the "latest representable date" for which we use Infinity
  // For "expired" we use 0
  TTL(now) {
    /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
     * attribute, the Max-Age attribute has precedence and controls the
     * expiration date of the cookie.
     * (Concurs with S5.3 step 3)
     */
    if (this.maxAge != null) {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
    }

    let expires = this.expires;
    if (expires != Infinity) {
      if (!(expires instanceof Date)) {
        expires = parseDate(expires) || Infinity;
      }

      if (expires == Infinity) {
        return Infinity;
      }

      return expires.getTime() - (now || Date.now());
    }

    return Infinity;
  }

  // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
  // elsewhere)
  expiryTime(now) {
    if (this.maxAge != null) {
      const relativeTo = now || this.creation || new Date();
      const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;
      return relativeTo.getTime() + age;
    }

    if (this.expires == Infinity) {
      return Infinity;
    }
    return this.expires.getTime();
  }

  // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
  // elsewhere), except it returns a Date
  expiryDate(now) {
    const millisec = this.expiryTime(now);
    if (millisec == Infinity) {
      return new Date(MAX_TIME);
    } else if (millisec == -Infinity) {
      return new Date(MIN_TIME);
    } else {
      return new Date(millisec);
    }
  }

  // This replaces the "persistent-flag" parts of S5.3 step 3
  isPersistent() {
    return this.maxAge != null || this.expires != Infinity;
  }

  // Mostly S5.1.2 and S5.2.3:
  canonicalizedDomain() {
    if (this.domain == null) {
      return null;
    }
    return canonicalDomain(this.domain);
  }

  cdomain() {
    return this.canonicalizedDomain();
  }
}

Cookie.cookiesCreated = 0;
Cookie.parse = parse;
Cookie.fromJSON = fromJSON;
Cookie.serializableProperties = Object.keys(cookieDefaults);
Cookie.sameSiteLevel = {
  strict: 3,
  lax: 2,
  none: 1
};

Cookie.sameSiteCanonical = {
  strict: "Strict",
  lax: "Lax"
};

function getNormalizedPrefixSecurity(prefixSecurity) {
  if (prefixSecurity != null) {
    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
    /* The three supported options */
    switch (normalizedPrefixSecurity) {
      case PrefixSecurityEnum.STRICT:
      case PrefixSecurityEnum.SILENT:
      case PrefixSecurityEnum.DISABLED:
        return normalizedPrefixSecurity;
    }
  }
  /* Default is SILENT */
  return PrefixSecurityEnum.SILENT;
}

class CookieJar {
  constructor(store, options = { rejectPublicSuffixes: true }) {
    if (typeof options === "boolean") {
      options = { rejectPublicSuffixes: options };
    }
    validators.validate(validators.isObject(options), options);
    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    this.enableLooseMode = !!options.looseMode;
    this.allowSpecialUseDomain =
      typeof options.allowSpecialUseDomain === "boolean"
        ? options.allowSpecialUseDomain
        : true;
    this.store = store || new MemoryCookieStore();
    this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
    this._cloneSync = syncWrap("clone");
    this._importCookiesSync = syncWrap("_importCookies");
    this.getCookiesSync = syncWrap("getCookies");
    this.getCookieStringSync = syncWrap("getCookieString");
    this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
    this.removeAllCookiesSync = syncWrap("removeAllCookies");
    this.setCookieSync = syncWrap("setCookie");
    this.serializeSync = syncWrap("serialize");
  }

  setCookie(cookie, url, options, cb) {
    validators.validate(validators.isUrlStringOrObject(url), cb, options);

    let err;

    if (validators.isFunction(url)) {
      cb = url;
      return cb(new Error("No URL was specified"));
    }

    const context = getCookieContext(url);
    if (validators.isFunction(options)) {
      cb = options;
      options = {};
    }

    validators.validate(validators.isFunction(cb), cb);

    if (
      !validators.isNonEmptyString(cookie) &&
      !validators.isObject(cookie) &&
      cookie instanceof String &&
      cookie.length == 0
    ) {
      return cb(null);
    }

    const host = canonicalDomain(context.hostname);
    const loose = options.loose || this.enableLooseMode;

    let sameSiteContext = null;
    if (options.sameSiteContext) {
      sameSiteContext = checkSameSiteContext(options.sameSiteContext);
      if (!sameSiteContext) {
        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
    }

    // S5.3 step 1
    if (typeof cookie === "string" || cookie instanceof String) {
      cookie = Cookie.parse(cookie, { loose: loose });
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
    } else if (!(cookie instanceof Cookie)) {
      // If you're seeing this error, and are passing in a Cookie object,
      // it *might* be a Cookie object from another loaded version of tough-cookie.
      err = new Error(
        "First argument to setCookie must be a Cookie object or string"
      );
      return cb(options.ignoreError ? null : err);
    }

    // S5.3 step 2
    const now = options.now || new Date(); // will assign later to save effort in the face of errors

    // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

    // S5.3 step 4: NOOP; domain is null by default

    // S5.3 step 5: public suffixes
    if (this.rejectPublicSuffixes && cookie.domain) {
      const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
        allowSpecialUseDomain: this.allowSpecialUseDomain,
        ignoreError: options.ignoreError
      });
      if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
        // e.g. "com"
        err = new Error("Cookie has domain set to a public suffix");
        return cb(options.ignoreError ? null : err);
      }
    }

    // S5.3 step 6:
    if (cookie.domain) {
      if (!domainMatch(host, cookie.cdomain(), false)) {
        err = new Error(
          `Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`
        );
        return cb(options.ignoreError ? null : err);
      }

      if (cookie.hostOnly == null) {
        // don't reset if already set
        cookie.hostOnly = false;
      }
    } else {
      cookie.hostOnly = true;
      cookie.domain = host;
    }

    //S5.2.4 If the attribute-value is empty or if the first character of the
    //attribute-value is not %x2F ("/"):
    //Let cookie-path be the default-path.
    if (!cookie.path || cookie.path[0] !== "/") {
      cookie.path = defaultPath(context.pathname);
      cookie.pathIsDefault = true;
    }

    // S5.3 step 8: NOOP; secure attribute
    // S5.3 step 9: NOOP; httpOnly attribute

    // S5.3 step 10
    if (options.http === false && cookie.httpOnly) {
      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return cb(options.ignoreError ? null : err);
    }

    // 6252bis-02 S5.4 Step 13 & 14:
    if (
      cookie.sameSite !== "none" &&
      cookie.sameSite !== undefined &&
      sameSiteContext
    ) {
      // "If the cookie's "same-site-flag" is not "None", and the cookie
      //  is being set from a context whose "site for cookies" is not an
      //  exact match for request-uri's host's registered domain, then
      //  abort these steps and ignore the newly created cookie entirely."
      if (sameSiteContext === "none") {
        err = new Error(
          "Cookie is SameSite but this is a cross-origin request"
        );
        return cb(options.ignoreError ? null : err);
      }
    }

    /* 6265bis-02 S5.4 Steps 15 & 16 */
    const ignoreErrorForPrefixSecurity =
      this.prefixSecurity === PrefixSecurityEnum.SILENT;
    const prefixSecurityDisabled =
      this.prefixSecurity === PrefixSecurityEnum.DISABLED;
    /* If prefix checking is not disabled ...*/
    if (!prefixSecurityDisabled) {
      let errorFound = false;
      let errorMsg;
      /* Check secure prefix condition */
      if (!isSecurePrefixConditionMet(cookie)) {
        errorFound = true;
        errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
      } else if (!isHostPrefixConditionMet(cookie)) {
        /* Check host prefix condition */
        errorFound = true;
        errorMsg =
          "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
      }
      if (errorFound) {
        return cb(
          options.ignoreError || ignoreErrorForPrefixSecurity
            ? null
            : new Error(errorMsg)
        );
      }
    }

    const store = this.store;

    if (!store.updateCookie) {
      store.updateCookie = function(oldCookie, newCookie, cb) {
        this.putCookie(newCookie, cb);
      };
    }

    function withCookie(err, oldCookie) {
      if (err) {
        return cb(err);
      }

      const next = function(err) {
        if (err) {
          return cb(err);
        } else {
          cb(null, cookie);
        }
      };

      if (oldCookie) {
        // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
        // domain, and path as the newly created cookie:"
        if (options.http === false && oldCookie.httpOnly) {
          // step 11.2
          err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err);
        }
        cookie.creation = oldCookie.creation; // step 11.3
        cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
        cookie.lastAccessed = now;
        // Step 11.4 (delete cookie) is implied by just setting the new one:
        store.updateCookie(oldCookie, cookie, next); // step 12
      } else {
        cookie.creation = cookie.lastAccessed = now;
        store.putCookie(cookie, next); // step 12
      }
    }

    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
  }

  // RFC6365 S5.4
  getCookies(url, options, cb) {
    validators.validate(validators.isUrlStringOrObject(url), cb, url);

    const context = getCookieContext(url);
    if (validators.isFunction(options)) {
      cb = options;
      options = {};
    }
    validators.validate(validators.isObject(options), cb, options);
    validators.validate(validators.isFunction(cb), cb);

    const host = canonicalDomain(context.hostname);
    const path = context.pathname || "/";

    let secure = options.secure;
    if (
      secure == null &&
      context.protocol &&
      (context.protocol == "https:" || context.protocol == "wss:")
    ) {
      secure = true;
    }

    // Additional check for special domain as per RFC 6265 to treat localhost as secure channel
    // https://www.rfc-editor.org/rfc/rfc6265#page-21
    if (secure == null && isLocalhost(host)) {
      secure = true;
    }

    let sameSiteLevel = 0;
    if (options.sameSiteContext) {
      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
      sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
      if (!sameSiteLevel) {
        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
    }

    let http = options.http;
    if (http == null) {
      http = true;
    }

    const now = options.now || Date.now();
    const expireCheck = options.expire !== false;
    const allPaths = !!options.allPaths;
    const store = this.store;

    function matchingCookie(c) {
      // "Either:
      //   The cookie's host-only-flag is true and the canonicalized
      //   request-host is identical to the cookie's domain.
      // Or:
      //   The cookie's host-only-flag is false and the canonicalized
      //   request-host domain-matches the cookie's domain."
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!domainMatch(host, c.domain, false)) {
          return false;
        }
      }

      // "The request-uri's path path-matches the cookie's path."
      if (!allPaths && !pathMatch(path, c.path)) {
        return false;
      }

      // "If the cookie's secure-only-flag is true, then the request-uri's
      // scheme must denote a "secure" protocol"
      if (c.secure && !secure) {
        return false;
      }

      // "If the cookie's http-only-flag is true, then exclude the cookie if the
      // cookie-string is being generated for a "non-HTTP" API"
      if (c.httpOnly && !http) {
        return false;
      }

      // RFC6265bis-02 S5.3.7
      if (sameSiteLevel) {
        const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
        if (cookieLevel > sameSiteLevel) {
          // only allow cookies at or below the request level
          return false;
        }
      }

      // deferred from S5.3
      // non-RFC: allow retention of expired cookies by choice
      if (expireCheck && c.expiryTime() <= now) {
        store.removeCookie(c.domain, c.path, c.key, () => {}); // result ignored
        return false;
      }

      return true;
    }

    store.findCookies(
      host,
      allPaths ? null : path,
      this.allowSpecialUseDomain,
      (err, cookies) => {
        if (err) {
          return cb(err);
        }

        cookies = cookies.filter(matchingCookie);

        // sorting of S5.4 part 2
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }

        // S5.4 part 3
        const now = new Date();
        for (const cookie of cookies) {
          cookie.lastAccessed = now;
        }
        // TODO persist lastAccessed

        cb(null, cookies);
      }
    );
  }

  getCookieString(...args) {
    const cb = args.pop();
    validators.validate(validators.isFunction(cb), cb);
    const next = function(err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(
          null,
          cookies
            .sort(cookieCompare)
            .map(c => c.cookieString())
            .join("; ")
        );
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  }

  getSetCookieStrings(...args) {
    const cb = args.pop();
    validators.validate(validators.isFunction(cb), cb);
    const next = function(err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(
          null,
          cookies.map(c => {
            return c.toString();
          })
        );
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  }

  serialize(cb) {
    validators.validate(validators.isFunction(cb), cb);
    let type = this.store.constructor.name;
    if (validators.isObject(type)) {
      type = null;
    }

    // update README.md "Serialization Format" if you change this, please!
    const serialized = {
      // The version of tough-cookie that serialized this jar. Generally a good
      // practice since future versions can make data import decisions based on
      // known past behavior. When/if this matters, use `semver`.
      version: `tough-cookie@${VERSION}`,

      // add the store type, to make humans happy:
      storeType: type,

      // CookieJar configuration:
      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
      enableLooseMode: !!this.enableLooseMode,
      allowSpecialUseDomain: !!this.allowSpecialUseDomain,
      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),

      // this gets filled from getAllCookies:
      cookies: []
    };

    if (
      !(
        this.store.getAllCookies &&
        typeof this.store.getAllCookies === "function"
      )
    ) {
      return cb(
        new Error(
          "store does not support getAllCookies and cannot be serialized"
        )
      );
    }

    this.store.getAllCookies((err, cookies) => {
      if (err) {
        return cb(err);
      }

      serialized.cookies = cookies.map(cookie => {
        // convert to serialized 'raw' cookies
        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;

        // Remove the index so new ones get assigned during deserialization
        delete cookie.creationIndex;

        return cookie;
      });

      return cb(null, serialized);
    });
  }

  toJSON() {
    return this.serializeSync();
  }

  // use the class method CookieJar.deserialize instead of calling this directly
  _importCookies(serialized, cb) {
    let cookies = serialized.cookies;
    if (!cookies || !Array.isArray(cookies)) {
      return cb(new Error("serialized jar has no cookies array"));
    }
    cookies = cookies.slice(); // do not modify the original

    const putNext = err => {
      if (err) {
        return cb(err);
      }

      if (!cookies.length) {
        return cb(err, this);
      }

      let cookie;
      try {
        cookie = fromJSON(cookies.shift());
      } catch (e) {
        return cb(e);
      }

      if (cookie === null) {
        return putNext(null); // skip this cookie
      }

      this.store.putCookie(cookie, putNext);
    };

    putNext();
  }

  clone(newStore, cb) {
    if (arguments.length === 1) {
      cb = newStore;
      newStore = null;
    }

    this.serialize((err, serialized) => {
      if (err) {
        return cb(err);
      }
      CookieJar.deserialize(serialized, newStore, cb);
    });
  }

  cloneSync(newStore) {
    if (arguments.length === 0) {
      return this._cloneSync();
    }
    if (!newStore.synchronous) {
      throw new Error(
        "CookieJar clone destination store is not synchronous; use async API instead."
      );
    }
    return this._cloneSync(newStore);
  }

  removeAllCookies(cb) {
    validators.validate(validators.isFunction(cb), cb);
    const store = this.store;

    // Check that the store implements its own removeAllCookies(). The default
    // implementation in Store will immediately call the callback with a "not
    // implemented" Error.
    if (
      typeof store.removeAllCookies === "function" &&
      store.removeAllCookies !== Store.prototype.removeAllCookies
    ) {
      return store.removeAllCookies(cb);
    }

    store.getAllCookies((err, cookies) => {
      if (err) {
        return cb(err);
      }

      if (cookies.length === 0) {
        return cb(null);
      }

      let completedCount = 0;
      const removeErrors = [];

      function removeCookieCb(removeErr) {
        if (removeErr) {
          removeErrors.push(removeErr);
        }

        completedCount++;

        if (completedCount === cookies.length) {
          return cb(removeErrors.length ? removeErrors[0] : null);
        }
      }

      cookies.forEach(cookie => {
        store.removeCookie(
          cookie.domain,
          cookie.path,
          cookie.key,
          removeCookieCb
        );
      });
    });
  }

  static deserialize(strOrObj, store, cb) {
    if (arguments.length !== 3) {
      // store is optional
      cb = store;
      store = null;
    }
    validators.validate(validators.isFunction(cb), cb);

    let serialized;
    if (typeof strOrObj === "string") {
      serialized = jsonParse(strOrObj);
      if (serialized instanceof Error) {
        return cb(serialized);
      }
    } else {
      serialized = strOrObj;
    }

    const jar = new CookieJar(store, {
      rejectPublicSuffixes: serialized.rejectPublicSuffixes,
      looseMode: serialized.enableLooseMode,
      allowSpecialUseDomain: serialized.allowSpecialUseDomain,
      prefixSecurity: serialized.prefixSecurity
    });
    jar._importCookies(serialized, err => {
      if (err) {
        return cb(err);
      }
      cb(null, jar);
    });
  }

  static deserializeSync(strOrObj, store) {
    const serialized =
      typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    const jar = new CookieJar(store, {
      rejectPublicSuffixes: serialized.rejectPublicSuffixes,
      looseMode: serialized.enableLooseMode
    });

    // catch this mistake early:
    if (!jar.store.synchronous) {
      throw new Error(
        "CookieJar store is not synchronous; use async API instead."
      );
    }

    jar._importCookiesSync(serialized);
    return jar;
  }
}
CookieJar.fromJSON = CookieJar.deserializeSync;

[
  "_importCookies",
  "clone",
  "getCookies",
  "getCookieString",
  "getSetCookieStrings",
  "removeAllCookies",
  "serialize",
  "setCookie"
].forEach(name => {
  CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
});
CookieJar.deserialize = fromCallback(CookieJar.deserialize);

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method) {
  return function(...args) {
    if (!this.store.synchronous) {
      throw new Error(
        "CookieJar store is not synchronous; use async API instead."
      );
    }

    let syncErr, syncResult;
    this[method](...args, (err, result) => {
      syncErr = err;
      syncResult = result;
    });

    if (syncErr) {
      throw syncErr;
    }
    return syncResult;
  };
}

exports.version = VERSION;
exports.CookieJar = CookieJar;
exports.Cookie = Cookie;
exports.Store = Store;
exports.MemoryCookieStore = MemoryCookieStore;
exports.parseDate = parseDate;
exports.formatDate = formatDate;
exports.parse = parse;
exports.fromJSON = fromJSON;
exports.domainMatch = domainMatch;
exports.defaultPath = defaultPath;
exports.pathMatch = pathMatch;
exports.getPublicSuffix = pubsuffix.getPublicSuffix;
exports.cookieCompare = cookieCompare;
exports.permuteDomain = require("./permuteDomain").permuteDomain;
exports.permutePath = permutePath;
exports.canonicalDomain = canonicalDomain;
exports.PrefixSecurityEnum = PrefixSecurityEnum;
exports.ParameterError = validators.ParameterError;
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const { fromCallback } = require("universalify");
const Store = require("./store").Store;
const permuteDomain = require("./permuteDomain").permuteDomain;
const pathMatch = require("./pathMatch").pathMatch;
const { getCustomInspectSymbol, getUtilInspect } = require("./utilHelper");

class MemoryCookieStore extends Store {
  constructor() {
    super();
    this.synchronous = true;
    this.idx = Object.create(null);
    const customInspectSymbol = getCustomInspectSymbol();
    if (customInspectSymbol) {
      this[customInspectSymbol] = this.inspect;
    }
  }

  inspect() {
    const util = { inspect: getUtilInspect(inspectFallback) };
    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;
  }

  findCookie(domain, path, key, cb) {
    if (!this.idx[domain]) {
      return cb(null, undefined);
    }
    if (!this.idx[domain][path]) {
      return cb(null, undefined);
    }
    return cb(null, this.idx[domain][path][key] || null);
  }
  findCookies(domain, path, allowSpecialUseDomain, cb) {
    const results = [];
    if (typeof allowSpecialUseDomain === "function") {
      cb = allowSpecialUseDomain;
      allowSpecialUseDomain = true;
    }
    if (!domain) {
      return cb(null, []);
    }

    let pathMatcher;
    if (!path) {
      // null means "all paths"
      pathMatcher = function matchAll(domainIndex) {
        for (const curPath in domainIndex) {
          const pathIndex = domainIndex[curPath];
          for (const key in pathIndex) {
            results.push(pathIndex[key]);
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        //NOTE: we should use path-match algorithm from S5.1.4 here
        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
        Object.keys(domainIndex).forEach(cookiePath => {
          if (pathMatch(path, cookiePath)) {
            const pathIndex = domainIndex[cookiePath];
            for (const key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        });
      };
    }

    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
    const idx = this.idx;
    domains.forEach(curDomain => {
      const domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });

    cb(null, results);
  }

  putCookie(cookie, cb) {
    if (!this.idx[cookie.domain]) {
      this.idx[cookie.domain] = Object.create(null);
    }
    if (!this.idx[cookie.domain][cookie.path]) {
      this.idx[cookie.domain][cookie.path] = Object.create(null);
    }
    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
    cb(null);
  }
  updateCookie(oldCookie, newCookie, cb) {
    // updateCookie() may avoid updating cookies that are identical.  For example,
    // lastAccessed may not be important to some stores and an equality
    // comparison could exclude that field.
    this.putCookie(newCookie, cb);
  }
  removeCookie(domain, path, key, cb) {
    if (
      this.idx[domain] &&
      this.idx[domain][path] &&
      this.idx[domain][path][key]
    ) {
      delete this.idx[domain][path][key];
    }
    cb(null);
  }
  removeCookies(domain, path, cb) {
    if (this.idx[domain]) {
      if (path) {
        delete this.idx[domain][path];
      } else {
        delete this.idx[domain];
      }
    }
    return cb(null);
  }
  removeAllCookies(cb) {
    this.idx = Object.create(null);
    return cb(null);
  }
  getAllCookies(cb) {
    const cookies = [];
    const idx = this.idx;

    const domains = Object.keys(idx);
    domains.forEach(domain => {
      const paths = Object.keys(idx[domain]);
      paths.forEach(path => {
        const keys = Object.keys(idx[domain][path]);
        keys.forEach(key => {
          if (key !== null) {
            cookies.push(idx[domain][path][key]);
          }
        });
      });
    });

    // Sort by creationIndex so deserializing retains the creation order.
    // When implementing your own store, this SHOULD retain the order too
    cookies.sort((a, b) => {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });

    cb(null, cookies);
  }
}

[
  "findCookie",
  "findCookies",
  "putCookie",
  "updateCookie",
  "removeCookie",
  "removeCookies",
  "removeAllCookies",
  "getAllCookies"
].forEach(name => {
  MemoryCookieStore.prototype[name] = fromCallback(
    MemoryCookieStore.prototype[name]
  );
});

exports.MemoryCookieStore = MemoryCookieStore;

function inspectFallback(val) {
  const domains = Object.keys(val);
  if (domains.length === 0) {
    return "[Object: null prototype] {}";
  }
  let result = "[Object: null prototype] {\n";
  Object.keys(val).forEach((domain, i) => {
    result += formatDomain(domain, val[domain]);
    if (i < domains.length - 1) {
      result += ",";
    }
    result += "\n";
  });
  result += "}";
  return result;
}

function formatDomain(domainName, domainValue) {
  const indent = "  ";
  let result = `${indent}'${domainName}': [Object: null prototype] {\n`;
  Object.keys(domainValue).forEach((path, i, paths) => {
    result += formatPath(path, domainValue[path]);
    if (i < paths.length - 1) {
      result += ",";
    }
    result += "\n";
  });
  result += `${indent}}`;
  return result;
}

function formatPath(pathName, pathValue) {
  const indent = "    ";
  let result = `${indent}'${pathName}': [Object: null prototype] {\n`;
  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
    const cookie = pathValue[cookieName];
    result += `      ${cookieName}: ${cookie.inspect()}`;
    if (i < cookieNames.length - 1) {
      result += ",";
    }
    result += "\n";
  });
  result += `${indent}}`;
  return result;
}

exports.inspectFallback = inspectFallback;
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
/*
 * "A request-path path-matches a given cookie-path if at least one of the
 * following conditions holds:"
 */
function pathMatch(reqPath, cookiePath) {
  // "o  The cookie-path and the request-path are identical."
  if (cookiePath === reqPath) {
    return true;
  }

  const idx = reqPath.indexOf(cookiePath);
  if (idx === 0) {
    // "o  The cookie-path is a prefix of the request-path, and the last
    // character of the cookie-path is %x2F ("/")."
    if (cookiePath.substr(-1) === "/") {
      return true;
    }

    // " o  The cookie-path is a prefix of the request-path, and the first
    // character of the request-path that is not included in the cookie- path
    // is a %x2F ("/") character."
    if (reqPath.substr(cookiePath.length, 1) === "/") {
      return true;
    }
  }

  return false;
}

exports.pathMatch = pathMatch;
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const pubsuffix = require("./pubsuffix-psl");

// Gives the permutation of all possible domainMatch()es of a given domain. The
// array is in shortest-to-longest order.  Handy for indexing.

function permuteDomain(domain, allowSpecialUseDomain) {
  const pubSuf = pubsuffix.getPublicSuffix(domain, {
    allowSpecialUseDomain: allowSpecialUseDomain
  });

  if (!pubSuf) {
    return null;
  }
  if (pubSuf == domain) {
    return [domain];
  }

  // Nuke trailing dot
  if (domain.slice(-1) == ".") {
    domain = domain.slice(0, -1);
  }

  const prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
  const parts = prefix.split(".").reverse();
  let cur = pubSuf;
  const permutations = [cur];
  while (parts.length) {
    cur = `${parts.shift()}.${cur}`;
    permutations.push(cur);
  }
  return permutations;
}

exports.permuteDomain = permuteDomain;
/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const psl = require("psl");

// RFC 6761
const SPECIAL_USE_DOMAINS = [
  "local",
  "example",
  "invalid",
  "localhost",
  "test"
];

const SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];

function getPublicSuffix(domain, options = {}) {
  const domainParts = domain.split(".");
  const topLevelDomain = domainParts[domainParts.length - 1];
  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
  const ignoreError = !!options.ignoreError;

  if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    if (domainParts.length > 1) {
      const secondLevelDomain = domainParts[domainParts.length - 2];
      // In aforementioned example, the eTLD/pubSuf will be apple.localhost
      return `${secondLevelDomain}.${topLevelDomain}`;
    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
      // For a single word special use domain, e.g. 'localhost' or 'invalid', per RFC 6761,
      // "Application software MAY recognize {localhost/invalid} names as special, or
      // MAY pass them to name resolution APIs as they would for other domain names."
      return `${topLevelDomain}`;
    }
  }

  if (
    !ignoreError &&
    !allowSpecialUseDomain &&
    SPECIAL_USE_DOMAINS.includes(topLevelDomain)
  ) {
    throw new Error(
      `Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`
    );
  }

  return psl.get(domain);
}

exports.getPublicSuffix = getPublicSuffix;
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
/*jshint unused:false */

class Store {
  constructor() {
    this.synchronous = false;
  }

  findCookie(domain, path, key, cb) {
    throw new Error("findCookie is not implemented");
  }

  findCookies(domain, path, allowSpecialUseDomain, cb) {
    throw new Error("findCookies is not implemented");
  }

  putCookie(cookie, cb) {
    throw new Error("putCookie is not implemented");
  }

  updateCookie(oldCookie, newCookie, cb) {
    // recommended default implementation:
    // return this.putCookie(newCookie, cb);
    throw new Error("updateCookie is not implemented");
  }

  removeCookie(domain, path, key, cb) {
    throw new Error("removeCookie is not implemented");
  }

  removeCookies(domain, path, cb) {
    throw new Error("removeCookies is not implemented");
  }

  removeAllCookies(cb) {
    throw new Error("removeAllCookies is not implemented");
  }

  getAllCookies(cb) {
    throw new Error(
      "getAllCookies is not implemented (therefore jar cannot be serialized)"
    );
  }
}

exports.Store = Store;
function requireUtil() {
  try {
    // eslint-disable-next-line no-restricted-modules
    return require("util");
  } catch (e) {
    return null;
  }
}

// for v10.12.0+
function lookupCustomInspectSymbol() {
  return Symbol.for("nodejs.util.inspect.custom");
}

// for older node environments
function tryReadingCustomSymbolFromUtilInspect(options) {
  const _requireUtil = options.requireUtil || requireUtil;
  const util = _requireUtil();
  return util ? util.inspect.custom : null;
}

exports.getUtilInspect = function getUtilInspect(fallback, options = {}) {
  const _requireUtil = options.requireUtil || requireUtil;
  const util = _requireUtil();
  return function inspect(value, showHidden, depth) {
    return util ? util.inspect(value, showHidden, depth) : fallback(value);
  };
};

exports.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
  const _lookupCustomInspectSymbol =
    options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;

  // get custom inspect symbol for node environments
  return (
    _lookupCustomInspectSymbol() ||
    tryReadingCustomSymbolFromUtilInspect(options)
  );
};
/* ************************************************************************************
Extracted from check-types.js
https://gitlab.com/philbooth/check-types.js

MIT License

Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Phil Booth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

************************************************************************************ */
"use strict";

/* Validation functions copied from check-types package - https://www.npmjs.com/package/check-types */
function isFunction(data) {
  return typeof data === "function";
}

function isNonEmptyString(data) {
  return isString(data) && data !== "";
}

function isDate(data) {
  return isInstanceStrict(data, Date) && isInteger(data.getTime());
}

function isEmptyString(data) {
  return data === "" || (data instanceof String && data.toString() === "");
}

function isString(data) {
  return typeof data === "string" || data instanceof String;
}

function isObject(data) {
  return toString.call(data) === "[object Object]";
}
function isInstanceStrict(data, prototype) {
  try {
    return data instanceof prototype;
  } catch (error) {
    return false;
  }
}

function isUrlStringOrObject(data) {
  return (
    isNonEmptyString(data) ||
    isObject(data) || // TODO: Check for URL properties that are used.
    isInstanceStrict(data, URL)
  );
}

function isInteger(data) {
  return typeof data === "number" && data % 1 === 0;
}
/* End validation functions */

function validate(bool, cb, options) {
  if (!isFunction(cb)) {
    options = cb;
    cb = null;
  }
  if (!isObject(options)) options = { Error: "Failed Check" };
  if (!bool) {
    if (cb) {
      cb(new ParameterError(options));
    } else {
      throw new ParameterError(options);
    }
  }
}

class ParameterError extends Error {
  constructor(...params) {
    super(...params);
  }
}

exports.ParameterError = ParameterError;
exports.isFunction = isFunction;
exports.isNonEmptyString = isNonEmptyString;
exports.isDate = isDate;
exports.isEmptyString = isEmptyString;
exports.isString = isString;
exports.isObject = isObject;
exports.isUrlStringOrObject = isUrlStringOrObject;
exports.validate = validate;
// generated by genversion
module.exports = '4.1.3-postman.1'
Copyright (c) 2015, Salesforce.com, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of Salesforce.com nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "author": {
    "name": "Jeremy Stashewsky",
    "email": "jstash@gmail.com",
    "website": "https://github.com/stash"
  },
  "contributors": [
    {
      "name": "Ivan Nikulin",
      "website": "https://github.com/inikulin"
    },
    {
      "name": "Shivan Kaul Sahib",
      "website": "https://github.com/ShivanKaul"
    },
    {
      "name": "Clint Ruoho",
      "website": "https://github.com/ruoho"
    },
    {
      "name": "Ian Livingstone",
      "website": "https://github.com/ianlivingstone"
    },
    {
      "name": "Andrew Waterman",
      "website": "https://github.com/awaterma"
    },
    {
      "name": "Michael de Libero ",
      "website": "https://github.com/medelibero-sfdc"
    },
    {
      "name": "Jonathan Stewmon",
      "website": "https://github.com/jstewmon"
    },
    {
      "name": "Miguel Roncancio",
      "website": "https://github.com/miggs125"
    },
    {
      "name": "Sebastian Mayr",
      "website": "https://github.com/Sebmaster"
    },
    {
      "name": "Alexander Savin",
      "website": "https://github.com/apsavin"
    },
    {
      "name": "Lalit Kapoor",
      "website": "https://github.com/lalitkapoor"
    },
    {
      "name": "Sam Thompson",
      "website": "https://github.com/sambthompson"
    }
  ],
  "license": "BSD-3-Clause",
  "name": "@postman/tough-cookie",
  "description": "RFC6265 Cookies and Cookie Jar for node.js",
  "keywords": [
    "HTTP",
    "cookie",
    "cookies",
    "set-cookie",
    "cookiejar",
    "jar",
    "RFC6265",
    "RFC2965"
  ],
  "version": "4.1.3-postman.1",
  "homepage": "https://github.com/postmanlabs/tough-cookie",
  "repository": {
    "type": "git",
    "url": "git://github.com/postmanlabs/tough-cookie.git"
  },
  "bugs": {
    "url": "https://github.com/postmanlabs/tough-cookie/issues"
  },
  "main": "./lib/cookie",
  "files": [
    "lib"
  ],
  "scripts": {
    "version": "genversion lib/version.js && git add lib/version.js",
    "test": "vows test/*_test.js && npm run eslint",
    "cover": "nyc --reporter=lcov --reporter=html vows test/*_test.js",
    "eslint": "eslint --env node --ext .js .",
    "prettier": "prettier '**/*.{json,ts,yaml,md}'",
    "format": "npm run eslint -- --fix"
  },
  "engines": {
    "node": ">=6"
  },
  "devDependencies": {
    "async": "^2.6.2",
    "eslint": "^5.16.0",
    "eslint-config-prettier": "^4.2.0",
    "eslint-plugin-prettier": "^3.0.1",
    "genversion": "^2.1.0",
    "nyc": "^14.0.0",
    "prettier": "^1.17.0",
    "vows": "^0.8.2"
  },
  "dependencies": {
    "psl": "^1.1.33",
    "punycode": "^2.1.1",
    "universalify": "^0.2.0",
    "url-parse": "^1.5.3"
  }
}
# tough-cookie

[RFC 6265](https://tools.ietf.org/html/rfc6265) Cookies and CookieJar for Node.js

[![npm package](https://nodei.co/npm/tough-cookie.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/tough-cookie/)

[![Build Status](https://travis-ci.org/salesforce/tough-cookie.svg?branch=master)](https://travis-ci.org/salesforce/tough-cookie)

## Synopsis

```javascript
var tough = require("tough-cookie");
var Cookie = tough.Cookie;
var cookie = Cookie.parse(header);
cookie.value = "somethingdifferent";
header = cookie.toString();
var cookiejar = new tough.CookieJar();

// Asynchronous!
var cookie = await cookiejar.setCookie(
  cookie,
  "https://currentdomain.example.com/path"
);
var cookies = await cookiejar.getCookies("https://example.com/otherpath");

// Or with callbacks!
cookiejar.setCookie(
  cookie,
  "https://currentdomain.example.com/path",
  function (err, cookie) {
    /* ... */
  }
);
cookiejar.getCookies("http://example.com/otherpath", function (err, cookies) {
  /* ... */
});
```

Why the name? NPM modules `cookie`, `cookies` and `cookiejar` were already taken.

## Installation

It's _so_ easy! Install with `npm` or your preferred package manager.

```sh
npm install tough-cookie
```

## Node.js Version Support

We follow the [node.js release schedule](https://github.com/nodejs/Release#release-schedule) and support all versions that are in Active LTS or Maintenance. We will always do a major release when dropping support for older versions of node, and we will do so in consultation with our community.

## API

### tough

The top-level exports from `require('tough-cookie')` can all be used as pure functions and don't need to be bound.

#### `parseDate(string)`

Parse a cookie date string into a `Date`. Parses according to [RFC 6265 Section 5.1.1](https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.1), not `Date.parse()`.

#### `formatDate(date)`

Format a `Date` into an [RFC 822](https://datatracker.ietf.org/doc/html/rfc822#section-5) string (the RFC 6265 recommended format).

#### `canonicalDomain(str)`

Transforms a domain name into a canonical domain name. The canonical domain name is a domain name that has been trimmed, lowercased, stripped of leading dot, and optionally punycode-encoded ([Section 5.1.2 of RFC 6265](https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.2)). For the most part, this function is idempotent (calling the function with the output from a previous call returns the same output).

#### `domainMatch(str, domStr[, canonicalize=true])`

Answers "does this real domain match the domain in a cookie?". The `str` is the "current" domain name and the `domStr` is the "cookie" domain name. Matches according to [RFC 6265 Section 5.1.3](https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.3), but it helps to think of it as a "suffix match".

The `canonicalize` parameter toggles whether the domain parameters get normalized with `canonicalDomain` or not.

#### `defaultPath(path)`

Given a current request/response path, gives the path appropriate for storing in a cookie. This is basically the "directory" of a "file" in the path, but is specified by [Section 5.1.4 of the RFC](https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4).

The `path` parameter MUST be _only_ the pathname part of a URI (excluding the hostname, query, fragment, and so on). This is the `.pathname` property of node's `uri.parse()` output.

#### `pathMatch(reqPath, cookiePath)`

Answers "does the request-path path-match a given cookie-path?" as per [RFC 6265 Section 5.1.4](https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4). Returns a boolean.

This is essentially a prefix-match where `cookiePath` is a prefix of `reqPath`.

#### `parse(cookieString[, options])`

Alias for [`Cookie.parse(cookieString[, options])`](#cookieparsecookiestring-options).

#### `fromJSON(string)`

Alias for [`Cookie.fromJSON(string)`](#cookiefromjsonstrorobj).

#### `getPublicSuffix(hostname)`

Returns the public suffix of this hostname. The public suffix is the shortest domain name upon which a cookie can be set. Returns `null` if the hostname cannot have cookies set for it.

For example: `www.example.com` and `www.subdomain.example.com` both have public suffix `example.com`.

For further information, see the [Public Suffix List](http://publicsuffix.org/). This module derives its list from that site. This call is a wrapper around [`psl`](https://www.npmjs.com/package/psl)'s [`get` method](https://www.npmjs.com/package/psl##pslgetdomain).

#### `cookieCompare(a, b)`

For use with `.sort()`, sorts a list of cookies into the recommended order given in step 2 of ([RFC 6265 Section 5.4](https://datatracker.ietf.org/doc/html/rfc6265#section-5.4)). The sort algorithm is, in order of precedence:

- Longest `.path`
- oldest `.creation` (which has a 1-ms precision, same as `Date`)
- lowest `.creationIndex` (to get beyond the 1-ms precision)

```javascript
var cookies = [
  /* unsorted array of Cookie objects */
];
cookies = cookies.sort(cookieCompare);
```

> **Note**: Since the JavaScript `Date` is limited to a 1-ms precision, cookies within the same millisecond are entirely possible. This is especially true when using the `now` option to `.setCookie()`. The `.creationIndex` property is a per-process global counter, assigned during construction with `new Cookie()`, which preserves the spirit of the RFC sorting: older cookies go first. This works great for `MemoryCookieStore` since `Set-Cookie` headers are parsed in order, but is not so great for distributed systems. Sophisticated `Store`s may wish to set this to some other _logical clock_ so that if cookies A and B are created in the same millisecond, but cookie A is created before cookie B, then `A.creationIndex < B.creationIndex`. If you want to alter the global counter, which you probably _shouldn't_ do, it's stored in `Cookie.cookiesCreated`.

#### `permuteDomain(domain)`

Generates a list of all possible domains that `domainMatch()` the parameter. Can be handy for implementing cookie stores.

#### `permutePath(path)`

Generates a list of all possible paths that `pathMatch()` the parameter. Can be handy for implementing cookie stores.

### Cookie

Exported via `tough.Cookie`.

#### `Cookie.parse(cookieString[, options])`

Parses a single Cookie or Set-Cookie HTTP header into a `Cookie` object. Returns `undefined` if the string can't be parsed.

The options parameter is not required and currently has only one property:

- _loose_ - boolean - if `true` enable parsing of keyless cookies like `=abc` and `=`, which are not RFC-compliant.

If options is not an object it is ignored, which means it can be used with [`Array#map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).

To process the Set-Cookie header(s) on a node HTTP/HTTPS response:

```javascript
if (Array.isArray(res.headers["set-cookie"]))
  cookies = res.headers["set-cookie"].map(Cookie.parse);
else cookies = [Cookie.parse(res.headers["set-cookie"])];
```

_Note:_ In version 2.3.3, tough-cookie limited the number of spaces before the `=` to 256 characters. This limitation was removed in version 2.3.4.
For more details, see [issue #92](https://github.com/salesforce/tough-cookie/issues/92).

#### Properties

Cookie object properties:

- _key_ - string - the name or key of the cookie (default `""`)
- _value_ - string - the value of the cookie (default `""`)
- _expires_ - `Date` - if set, the `Expires=` attribute of the cookie (defaults to the string `"Infinity"`). See `setExpires()`
- _maxAge_ - seconds - if set, the `Max-Age=` attribute _in seconds_ of the cookie. Can also be set to strings `"Infinity"` and `"-Infinity"` for non-expiry and immediate-expiry, respectively. See `setMaxAge()`
- _domain_ - string - the `Domain=` attribute of the cookie
- _path_ - string - the `Path=` of the cookie
- _secure_ - boolean - the `Secure` cookie flag
- _httpOnly_ - boolean - the `HttpOnly` cookie flag
- _sameSite_ - string - the `SameSite` cookie attribute (from [RFC 6265bis](#rfc-6265bis)); must be one of `none`, `lax`, or `strict`
- _extensions_ - `Array` - any unrecognized cookie attributes as strings (even if equal-signs inside)
- _creation_ - `Date` - when this cookie was constructed
- _creationIndex_ - number - set at construction, used to provide greater sort precision (see `cookieCompare(a,b)` for a full explanation)

After a cookie has been passed through `CookieJar.setCookie()` it has the following additional attributes:

- _hostOnly_ - boolean - is this a host-only cookie (that is, no Domain field was set, but was instead implied).
- _pathIsDefault_ - boolean - if true, there was no Path field on the cookie and `defaultPath()` was used to derive one.
- _creation_ - `Date` - **modified** from construction to when the cookie was added to the jar.
- _lastAccessed_ - `Date` - last time the cookie got accessed. Affects cookie cleaning after it is implemented. Using `cookiejar.getCookies(...)` updates this attribute.

#### `new Cookie([properties])`

Receives an options object that can contain any of the above Cookie properties. Uses the default for unspecified properties.

#### `.toString()`

Encodes to a Set-Cookie header value. The Expires cookie field is set using `formatDate()`, but is omitted entirely if `.expires` is `Infinity`.

#### `.cookieString()`

Encodes to a Cookie header value (specifically, the `.key` and `.value` properties joined with `"="`).

#### `.setExpires(string)`

Sets the expiry based on a date-string passed through `parseDate()`. If parseDate returns `null` (that is, can't parse this date string), `.expires` is set to `"Infinity"` (a string).

#### `.setMaxAge(number)`

Sets the maxAge in seconds. Coerces `-Infinity` to `"-Infinity"` and `Infinity` to `"Infinity"` so it correctly serializes to JSON.

#### `.expiryDate([now=Date.now()])`

`expiryTime()` computes the absolute unix-epoch milliseconds that this cookie expires. `expiryDate()` works similarly, except it returns a `Date` object. Note that in both cases the `now` parameter should be milliseconds.

Max-Age takes precedence over Expires (as per the RFC). The `.creation` attribute -- or, by default, the `now` parameter -- is used to offset the `.maxAge` attribute.

If Expires (`.expires`) is set, that's returned.

Otherwise, `expiryTime()` returns `Infinity` and `expiryDate()` returns a `Date` object for "Tue, 19 Jan 2038 03:14:07 GMT" (latest date that can be expressed by a 32-bit `time_t`; the common limit for most user-agents).

#### `.TTL([now=Date.now()])`

Computes the TTL relative to `now` (milliseconds). The same precedence rules as for `expiryTime`/`expiryDate` apply.

`Infinity` is returned for cookies without an explicit expiry and `0` is returned if the cookie is expired. Otherwise a time-to-live in milliseconds is returned.

#### `.canonicalizedDomain()`

#### `.cdomain()`

Returns the canonicalized `.domain` field. This is lower-cased and punycode ([RFC 3490](https://datatracker.ietf.org/doc/html/rfc3490)) encoded if the domain has any non-ASCII characters.

#### `.toJSON()`

For convenience in using `JSON.serialize(cookie)`. Returns a plain-old `Object` that can be JSON-serialized.

Any `Date` properties (such as `.expires`, `.creation`, and `.lastAccessed`) are exported in ISO format (`.toISOString()`).

> **NOTE**: Custom `Cookie` properties are discarded. In tough-cookie 1.x, since there was no `.toJSON` method explicitly defined, all enumerable properties were captured. If you want a property to be serialized, add the property name to the `Cookie.serializableProperties` Array.

#### `Cookie.fromJSON(strOrObj)`

Does the reverse of `cookie.toJSON()`. If passed a string, will `JSON.parse()` that first.

Any `Date` properties (such as `.expires`, `.creation`, and `.lastAccessed`) are parsed via [`Date.parse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse), not tough-cookie's `parseDate`, since ISO timestamps are being handled at this layer.

Returns `null` upon a JSON parsing error.

#### `.clone()`

Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.

#### `.validate()`

Status: _IN PROGRESS_. Works for a few things, but is by no means comprehensive.

Validates cookie attributes for semantic correctness. Useful for "lint" checking any Set-Cookie headers you generate. For now, it returns a boolean, but eventually could return a reason string. Future-proof with this construct:

```javascript
if (cookie.validate() === true) {
  // it's tasty
} else {
  // yuck!
}
```

### CookieJar

Exported via `tough.CookieJar`.

#### `CookieJar([store][, options])`

Simply use `new CookieJar()`. If a custom store is not passed to the constructor, a [`MemoryCookieStore`](#memorycookiestore) is created and used.

The `options` object can be omitted and can have the following properties:

- _rejectPublicSuffixes_ - boolean - default `true` - reject cookies with domains like "com" and "co.uk"
- _looseMode_ - boolean - default `false` - accept malformed cookies like `bar` and `=bar`, which have an implied empty name.
- _prefixSecurity_ - string - default `silent` - set to `'unsafe-disabled'`, `'silent'`, or `'strict'`. See [Cookie Prefixes](#cookie-prefixes) below.
- _allowSpecialUseDomain_ - boolean - default `true` - accepts special-use domain suffixes, such as `local`. Useful for testing purposes.
  This is not in the standard, but is used sometimes on the web and is accepted by most browsers.

#### `.setCookie(cookieOrString, currentUrl[, options][, callback(err, cookie)])`

Attempt to set the cookie in the cookie jar. The cookie has updated `.creation`, `.lastAccessed` and `.hostOnly` properties. And returns a promise if a callback is not provided.

The `options` object can be omitted and can have the following properties:

- _http_ - boolean - default `true` - indicates if this is an HTTP or non-HTTP API. Affects `HttpOnly` cookies.
- _secure_ - boolean - autodetect from URL - indicates if this is a "Secure" API. If the currentUrl starts with `https:` or `wss:` this defaults to `true`, otherwise `false`.
- _now_ - Date - default `new Date()` - what to use for the creation or access time of cookies.
- _ignoreError_ - boolean - default `false` - silently ignore things like parse errors and invalid domains. `Store` errors aren't ignored by this option.
- _sameSiteContext_ - string - default unset - set to `'none'`, `'lax'`, or `'strict'` See [SameSite Cookies](#samesite-cookies) below.

As per the RFC, the `.hostOnly` property is set if there was no "Domain=" parameter in the cookie string (or `.domain` was null on the Cookie object). The `.domain` property is set to the fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an exact hostname match (not a `domainMatch` as per usual).

#### `.setCookieSync(cookieOrString, currentUrl[, options])`

Synchronous version of [`setCookie`](#setcookiecookieorstring-currenturl-options-callbackerr-cookie); only works with synchronous stores (that is, the default `MemoryCookieStore`).

#### `.getCookies(currentUrl[, options][, callback(err, cookies)])`

Retrieve the list of cookies that can be sent in a Cookie header for the current URL. Returns a promise if a callback is not provided.

Returns an array of `Cookie` objects, sorted by default using [`cookieCompare`](#cookiecomparea-b).

If an error is encountered it's passed as `err` to the callback, otherwise an array of `Cookie` objects is passed. The array is sorted with `cookieCompare()` unless the `{sort:false}` option is given.

The `options` object can be omitted and can have the following properties:

- _http_ - boolean - default `true` - indicates if this is an HTTP or non-HTTP API. Affects `HttpOnly` cookies.
- _secure_ - boolean - autodetect from URL - indicates if this is a "Secure" API. If the currentUrl starts with `https:` or `wss:` then this is defaulted to `true`, otherwise `false`.
- _now_ - Date - default `new Date()` - what to use for the creation or access time of cookies
- _expire_ - boolean - default `true` - perform expiry-time checking of cookies and asynchronously remove expired cookies from the store. Using `false` returns expired cookies and does **not** remove them from the store (which is potentially useful for replaying Set-Cookie headers).
- _allPaths_ - boolean - default `false` - if `true`, do not scope cookies by path. The default uses RFC-compliant path scoping. **Note**: may not be supported by the underlying store (the default `MemoryCookieStore` supports it).
- _sameSiteContext_ - string - default unset - Set this to `'none'`, `'lax'`, or `'strict'` to enforce SameSite cookies upon retrieval. See [SameSite Cookies](#samesite-cookies) below.
- _sort_ - boolean - whether to sort the list of cookies.

The `.lastAccessed` property of the returned cookies will have been updated.

#### `.getCookiesSync(currentUrl, [{options}])`

Synchronous version of [`getCookies`](#getcookiescurrenturl-options-callbackerr-cookies); only works with synchronous stores (for example, the default `MemoryCookieStore`).

#### `.getCookieString(...)`

Accepts the same options as [`.getCookies()`](#getcookiescurrenturl-options-callbackerr-cookies) but returns a string suitable for a Cookie header rather than an Array.

#### `.getCookieStringSync(...)`

Synchronous version of [`getCookieString`](#getcookiestring); only works with synchronous stores (for example, the default `MemoryCookieStore`).

#### `.getSetCookieStrings(...)`

Returns an array of strings suitable for **Set-Cookie** headers. Accepts the same options as [`.getCookies()`](#getcookiescurrenturl-options-callbackerr-cookies). Simply maps the cookie array via `.toString()`.

#### `.getSetCookieStringsSync(...)`

Synchronous version of [`getSetCookieStrings`](#getsetcookiestrings); only works with synchronous stores (for example, the default `MemoryCookieStore`).

#### `.serialize([callback(err, serializedObject)])`

Returns a promise if a callback is not provided.

Serialize the Jar if the underlying store supports `.getAllCookies`.

> **NOTE**: Custom `Cookie` properties are discarded. If you want a property to be serialized, add the property name to the `Cookie.serializableProperties` Array.

See [Serialization Format](#serialization-format).

#### `.serializeSync()`

Synchronous version of [`serialize`](#serializecallbackerr-serializedobject); only works with synchronous stores (for example, the default `MemoryCookieStore`).

#### `.toJSON()`

Alias of [`.serializeSync()`](#serializesync) for the convenience of `JSON.stringify(cookiejar)`.

#### `CookieJar.deserialize(serialized[, store][, callback(err, object)])`

A new Jar is created and the serialized Cookies are added to the underlying store. Each `Cookie` is added via `store.putCookie` in the order in which they appear in the serialization. A promise is returned if a callback is not provided.

The `store` argument is optional, but should be an instance of `Store`. By default, a new instance of `MemoryCookieStore` is created.

As a convenience, if `serialized` is a string, it is passed through `JSON.parse` first.

#### `CookieJar.deserializeSync(serialized[, store])`

Sync version of [`.deserialize`](#cookiejardeserializeserialized-store-callbackerr-object); only works with synchronous stores (for example, the default `MemoryCookieStore`).

#### `CookieJar.fromJSON(string)`

Alias of [`.deserializeSync`](#cookiejardeserializesyncserialized-store) to provide consistency with [`Cookie.fromJSON()`](#cookiefromjsonstrorobj).

#### `.clone([store][, callback(err, cloned))`

Produces a deep clone of this jar. Modifications to the original do not affect the clone, and vice versa. Returns a promise if a callback is not provided.

The `store` argument is optional, but should be an instance of `Store`. By default, a new instance of `MemoryCookieStore` is created. Transferring between store types is supported so long as the source implements `.getAllCookies()` and the destination implements `.putCookie()`.

#### `.cloneSync([store])`

Synchronous version of [`.clone`](#clonestore-callbackerr-cloned), returning a new `CookieJar` instance.

The `store` argument is optional, but must be a _synchronous_ `Store` instance if specified. If not passed, a new instance of `MemoryCookieStore` is used.

The _source_ and _destination_ must both be synchronous `Store`s. If one or both stores are asynchronous, use `.clone` instead. Recall that `MemoryCookieStore` supports both synchronous and asynchronous API calls.

#### `.removeAllCookies([callback(err)])`

Removes all cookies from the jar. Returns a promise if a callback is not provided.

This is a new backwards-compatible feature of `tough-cookie` version 2.5, so not all Stores will implement it efficiently. For Stores that do not implement `removeAllCookies`, the fallback is to call `removeCookie` after `getAllCookies`. If `getAllCookies` fails or isn't implemented in the Store, that error is returned. If one or more of the `removeCookie` calls fail, only the first error is returned.

#### `.removeAllCookiesSync()`

Sync version of [`.removeAllCookies()`](#removeallcookiescallbackerr); only works with synchronous stores (for example, the default `MemoryCookieStore`).

### Store

Base class for CookieJar stores. Available as `tough.Store`.

### Store API

The storage model for each `CookieJar` instance can be replaced with a custom implementation. The default is `MemoryCookieStore` which can be found in [`lib/memstore.js`](https://github.com/salesforce/tough-cookie/blob/master/lib/memstore.js). The API uses continuation-passing-style to allow for asynchronous stores.

Stores should inherit from the base `Store` class, which is available as a top-level export.

Stores are asynchronous by default, but if `store.synchronous` is set to `true`, then the `*Sync` methods of the containing `CookieJar` can be used.

All `domain` parameters are normalized before calling.

The Cookie store must have all of the following methods. Note that asynchronous implementations **must** support callback parameters.

#### `store.findCookie(domain, path, key, callback(err, cookie))`

Retrieve a cookie with the given domain, path, and key (name). The RFC maintains that exactly one of these cookies should exist in a store. If the store is using versioning, this means that the latest or newest such cookie should be returned.

Callback takes an error and the resulting `Cookie` object. If no cookie is found then `null` MUST be passed instead (that is, not an error).

#### `store.findCookies(domain, path, allowSpecialUseDomain, callback(err, cookies))`

Locates cookies matching the given domain and path. This is most often called in the context of [`cookiejar.getCookies()`](#getcookiescurrenturl-options-callbackerr-cookies).

If no cookies are found, the callback MUST be passed an empty array.

The resulting list is checked for applicability to the current request according to the RFC (domain-match, path-match, http-only-flag, secure-flag, expiry, and so on), so it's OK to use an optimistic search algorithm when implementing this method. However, the search algorithm used SHOULD try to find cookies that `domainMatch()` the domain and `pathMatch()` the path in order to limit the amount of checking that needs to be done.

As of version 0.9.12, the `allPaths` option to `cookiejar.getCookies()` above causes the path here to be `null`. If the path is `null`, path-matching MUST NOT be performed (that is, domain-matching only).

#### `store.putCookie(cookie, callback(err))`

Adds a new cookie to the store. The implementation SHOULD replace any existing cookie with the same `.domain`, `.path`, and `.key` properties. Depending on the nature of the implementation, it's possible that between the call to `fetchCookie` and `putCookie` that a duplicate `putCookie` can occur.

The `cookie` object MUST NOT be modified; as the caller has already updated the `.creation` and `.lastAccessed` properties.

Pass an error if the cookie cannot be stored.

#### `store.updateCookie(oldCookie, newCookie, callback(err))`

Update an existing cookie. The implementation MUST update the `.value` for a cookie with the same `domain`, `.path`, and `.key`. The implementation SHOULD check that the old value in the store is equivalent to `oldCookie` - how the conflict is resolved is up to the store.

The `.lastAccessed` property is always different between the two objects (to the precision possible via JavaScript's clock). Both `.creation` and `.creationIndex` are guaranteed to be the same. Stores MAY ignore or defer the `.lastAccessed` change at the cost of affecting how cookies are selected for automatic deletion (for example, least-recently-used, which is up to the store to implement).

Stores may wish to optimize changing the `.value` of the cookie in the store versus storing a new cookie. If the implementation doesn't define this method, a stub that calls [`putCookie`](#storeputcookiecookie-callbackerr) is added to the store object.

The `newCookie` and `oldCookie` objects MUST NOT be modified.

Pass an error if the newCookie cannot be stored.

#### `store.removeCookie(domain, path, key, callback(err))`

Remove a cookie from the store (see notes on [`findCookie`](#storefindcookiedomain-path-key-callbackerr-cookie) about the uniqueness constraint).

The implementation MUST NOT pass an error if the cookie doesn't exist, and only pass an error due to the failure to remove an existing cookie.

#### `store.removeCookies(domain, path, callback(err))`

Removes matching cookies from the store. The `path` parameter is optional and if missing, means all paths in a domain should be removed.

Pass an error ONLY if removing any existing cookies failed.

#### `store.removeAllCookies(callback(err))`

_Optional_. Removes all cookies from the store.

Pass an error if one or more cookies can't be removed.

#### `store.getAllCookies(callback(err, cookies))`

_Optional_. Produces an `Array` of all cookies during [`jar.serialize()`](#serializecallbackerr-serializedobject). The items in the array can be true `Cookie` objects or generic `Object`s with the [Serialization Format](#serialization-format) data structure.

Cookies SHOULD be returned in creation order to preserve sorting via [`compareCookie()`](#cookiecomparea-b). For reference, `MemoryCookieStore` sorts by `.creationIndex` since it uses true `Cookie` objects internally. If you don't return the cookies in creation order, they'll still be sorted by creation time, but this only has a precision of 1-ms. See `cookieCompare` for more detail.

Pass an error if retrieval fails.

**Note**: Not all Stores can implement this due to technical limitations, so it is optional.

### MemoryCookieStore

Inherits from `Store`.

A just-in-memory CookieJar synchronous store implementation, used by default. Despite being a synchronous implementation, it's usable with both the synchronous and asynchronous forms of the `CookieJar` API. Supports serialization, `getAllCookies`, and `removeAllCookies`.

### Community Cookie Stores

These are some Store implementations authored and maintained by the community. They aren't official and we don't vouch for them but you may be interested to have a look:

- [`db-cookie-store`](https://github.com/JSBizon/db-cookie-store): SQL including SQLite-based databases
- [`file-cookie-store`](https://github.com/JSBizon/file-cookie-store): Netscape cookie file format on disk
- [`redis-cookie-store`](https://github.com/benkroeger/redis-cookie-store): Redis
- [`tough-cookie-filestore`](https://github.com/mitsuru/tough-cookie-filestore): JSON on disk
- [`tough-cookie-web-storage-store`](https://github.com/exponentjs/tough-cookie-web-storage-store): DOM localStorage and sessionStorage

## Serialization Format

**NOTE**: If you want to have custom `Cookie` properties serialized, add the property name to `Cookie.serializableProperties`.

```js
  {
    // The version of tough-cookie that serialized this jar.
    version: 'tough-cookie@1.x.y',

    // add the store type, to make humans happy:
    storeType: 'MemoryCookieStore',

    // CookieJar configuration:
    rejectPublicSuffixes: true,
    // ... future items go here

    // Gets filled from jar.store.getAllCookies():
    cookies: [
      {
        key: 'string',
        value: 'string',
        // ...
        /* other Cookie.serializableProperties go here */
      }
    ]
  }
```

## RFC 6265bis

Support for RFC 6265bis revision 02 is being developed. Since this is a bit of an omnibus revision to the RFC 6252, support is broken up into the functional areas.

### Leave Secure Cookies Alone

Not yet supported.

This change makes it so that if a cookie is sent from the server to the client with a `Secure` attribute, the channel must also be secure or the cookie is ignored.

### SameSite Cookies

Supported.

This change makes it possible for servers, and supporting clients, to mitigate certain types of CSRF attacks by disallowing `SameSite` cookies from being sent cross-origin.

On the Cookie object itself, you can get or set the `.sameSite` attribute, which is serialized into the `SameSite=` cookie attribute. When unset or `undefined`, no `SameSite=` attribute is serialized. The valid values of this attribute are `'none'`, `'lax'`, or `'strict'`. Other values are serialized as-is.

When parsing cookies with a `SameSite` cookie attribute, values other than `'lax'` or `'strict'` are parsed as `'none'`. For example, `SomeCookie=SomeValue; SameSite=garbage` parses so that `cookie.sameSite === 'none'`.

In order to support SameSite cookies, you must provide a `sameSiteContext` option to _both_ `setCookie` and `getCookies`. Valid values for this option are just like for the Cookie object, but have particular meanings:

1. `'strict'` mode - If the request is on the same "site for cookies" (see the RFC draft for more information), pass this option to add a layer of defense against CSRF.
2. `'lax'` mode - If the request is from another site, _but_ is directly because of navigation by the user, such as, `<link type=prefetch>` or `<a href="...">`, pass `sameSiteContext: 'lax'`.
3. `'none'` - Otherwise, pass `sameSiteContext: 'none'` (this indicates a cross-origin request).
4. unset/`undefined` - SameSite **is not** be enforced! This can be a valid use-case for when CSRF isn't in the threat model of the system being built.

It is highly recommended that you read RFC 6265bis for fine details on SameSite cookies. In particular [Section 8.8](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02##section-8.8) discusses security considerations and defense in depth.

### Cookie Prefixes

Supported.

Cookie prefixes are a way to indicate that a given cookie was set with a set of attributes simply by inspecting the first few characters of the cookie's name.

Cookie prefixes are defined in [Section 4.1.3 of 6265bis](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03##section-4.1.3).

Two prefixes are defined:

1. `"__Secure-" Prefix`: If a cookie's name begins with a case-sensitive match for the string "\_\_Secure-", then the cookie was set with a "Secure" attribute.
2. `"__Host-" Prefix`: If a cookie's name begins with a case-sensitive match for the string "\_\_Host-", then the cookie was set with a "Secure" attribute, a "Path" attribute with a value of "/", and no "Domain" attribute.

If `prefixSecurity` is enabled for `CookieJar`, then cookies that match the prefixes defined above but do not obey the attribute restrictions are not added.

You can define this functionality by passing in the `prefixSecurity` option to `CookieJar`. It can be one of 3 values:

1. `silent`: Enable cookie prefix checking but silently fail to add the cookie if conditions are not met. Default.
2. `strict`: Enable cookie prefix checking and error out if conditions are not met.
3. `unsafe-disabled`: Disable cookie prefix checking.

Note that if `ignoreError` is passed in as `true` then the error is silent regardless of the `prefixSecurity` option (assuming it's enabled).

## Copyright and License

BSD-3-Clause:

```text
 Copyright (c) 2015, Salesforce.com, Inc.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 3. Neither the name of Salesforce.com nor the names of its contributors may
 be used to endorse or promote products derived from this software without
 specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
```
'use strict'

var net = require('net')
  , tls = require('tls')
  , http = require('http')
  , https = require('https')
  , events = require('events')
  , util = require('util')
  , Buffer = require('safe-buffer').Buffer
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  agent.defaultPort = 443
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  agent.defaultPort = 443
  return agent
}


function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
  var self = this

   // Legacy API: addRequest(req, host, port, path)
  if (typeof options === 'string') {
    options = {
      host: options,
      port: arguments[2],
      path: arguments[3]
    };
  }

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: options.host, port: options.port, request: req})
    return
  }

  // If we are under maxSockets create a new one.
  self.createConnection({host: options.host, port: options.port, request: req})
}

TunnelingAgent.prototype.createConnection = function createConnection(pending) {
  var self = this

  self.createSocket(pending, function(err, socket) {
    if (err) {
      pending.request.emit('error', err)
      return
    }

    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    pending.request.onSocket(socket)

    function onFree() {
      self.emit('free', socket, pending.host, pending.port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket)
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions,
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  )
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        Buffer.from(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse) // for v0.6
  connectReq.once('upgrade', onUpgrade)   // for v0.6
  connectReq.once('connect', onConnect)   // for v0.7 or later
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      // @note `head` is the buffer for the response sent by the proxy server
      // after a successful tunnel is established. The RFC says that any
      // response sent after the successful response headers is to be considered
      // to be sent from the target server. But handling this edge-case requires
      // a lot of architecture changes which we're deferring for later.
      //
      // RFC: https://tools.ietf.org/html/rfc7231#section-4.3.6
      //
      // To prevent assertion error for this case we're commenting out the
      // following statement:
      //
      // assert.equal(head.length, 0)

      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(null, socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      self.removeSocket(placeholder)
      cb(error)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) return

  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createConnection(pending)
  }
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(err, socket) {
    if (err) {
      return cb(err)
    }

    var secureSocket
    var secureContext

    if(self.options.extraCA) {
      secureContext = tls.createSecureContext(self.options)
      secureContext.context.addCACert(self.options.extraCA)
    }

    try {
      // 0 is dummy port for v0.6
      secureSocket = tls.connect(0, mergeOptions({}, self.options,
        { servername: options.host
        , socket: socket
        , secureContext: secureContext
        }
      ))
    }
    catch (error) {
      self.removeSocket(socket)
      socket.destroy()
      return cb(error)
    }

    self.sockets[self.sockets.indexOf(socket)] = secureSocket
    cb(null, secureSocket)
  })
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides)
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== undefined) {
          target[k] = overrides[k]
        }
      }
    }
  }
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments)
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0]
    } else {
      args.unshift('TUNNEL:')
    }
    console.error.apply(console, args)
  }
} else {
  debug = function() {}
}
exports.debug = debug // for test
Apache License

Version 2.0, January 2004

http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:

You must give any other recipients of the Work or Derivative Works a copy of this License; and

You must cause any modified files to carry prominent notices stating that You changed the files; and

You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and

If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS{
  "author": "Postman Labs <help@getpostman.com>",
  "name": "@postman/tunnel-agent",
  "license": "Apache-2.0",
  "description": "HTTP proxy tunneling agent.",
  "version": "0.6.4",
  "repository": {
    "url": "git+https://github.com/postmanlabs/tunnel-agent.git"
  },
  "main": "index.js",
  "files": [
    "index.js"
  ],
  "dependencies": {
    "safe-buffer": "^5.0.1"
  },
  "devDependencies": {},
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "bugs": {
    "url": "https://github.com/postmanlabs/tunnel-agent/issues"
  },
  "homepage": "https://github.com/postmanlabs/tunnel-agent#readme",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }
}
tunnel-agent
============

HTTP proxy tunneling agent.
export = asPromise;

type asPromiseCallback = (error: Error | null, ...params: any[]) => {};

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
declare function asPromise(fn: asPromiseCallback, ctx: any, ...params: any[]): Promise<any>;
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/aspromise",
  "description": "Returns a promise from a node-style callback function.",
  "version": "1.1.2",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}@protobufjs/aspromise
=====================
[![npm](https://img.shields.io/npm/v/@protobufjs/aspromise.svg)](https://www.npmjs.com/package/@protobufjs/aspromise)

Returns a promise from a node-style callback function.

API
---

* **asPromise(fn: `function`, ctx: `Object`, ...params: `*`): `Promise<*>`**<br />
  Returns a promise from a node-style callback function.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var asPromise = require("..");

tape.test("aspromise", function(test) {

    test.test(this.name + " - resolve", function(test) {

        function fn(arg1, arg2, callback) {
            test.equal(this, ctx, "function should be called with this = ctx");
            test.equal(arg1, 1, "function should be called with arg1 = 1");
            test.equal(arg2, 2, "function should be called with arg2 = 2");
            callback(null, arg2);
        }

        var ctx = {};

        var promise = asPromise(fn, ctx, 1, 2);
        promise.then(function(arg2) {
            test.equal(arg2, 2, "promise should be resolved with arg2 = 2");
            test.end();
        }).catch(function(err) {
            test.fail("promise should not be rejected (" + err + ")");
        });
    });

    test.test(this.name + " - reject", function(test) {

        function fn(arg1, arg2, callback) {
            test.equal(this, ctx, "function should be called with this = ctx");
            test.equal(arg1, 1, "function should be called with arg1 = 1");
            test.equal(arg2, 2, "function should be called with arg2 = 2");
            callback(arg1);
        }

        var ctx = {};

        var promise = asPromise(fn, ctx, 1, 2);
        promise.then(function() {
            test.fail("promise should not be resolved");
        }).catch(function(err) {
            test.equal(err, 1, "promise should be rejected with err = 1");
            test.end();
        });
    });

    test.test(this.name + " - resolve twice", function(test) {

        function fn(arg1, arg2, callback) {
            test.equal(this, ctx, "function should be called with this = ctx");
            test.equal(arg1, 1, "function should be called with arg1 = 1");
            test.equal(arg2, 2, "function should be called with arg2 = 2");
            callback(null, arg2);
            callback(null, arg1);
        }

        var ctx = {};
        var count = 0;

        var promise = asPromise(fn, ctx, 1, 2);
        promise.then(function(arg2) {
            test.equal(arg2, 2, "promise should be resolved with arg2 = 2");
            if (++count > 1)
                test.fail("promise should not be resolved twice");
            test.end();
        }).catch(function(err) {
            test.fail("promise should not be rejected (" + err + ")");
        });
    });

    test.test(this.name + " - reject twice", function(test) {

        function fn(arg1, arg2, callback) {
            test.equal(this, ctx, "function should be called with this = ctx");
            test.equal(arg1, 1, "function should be called with arg1 = 1");
            test.equal(arg2, 2, "function should be called with arg2 = 2");
            callback(arg1);
            callback(arg2);
        }

        var ctx = {};
        var count = 0;

        var promise = asPromise(fn, ctx, 1, 2);
        promise.then(function() {
            test.fail("promise should not be resolved");
        }).catch(function(err) {
            test.equal(err, 1, "promise should be rejected with err = 1");
            if (++count > 1)
                test.fail("promise should not be rejected twice");
            test.end();
        });
    });

    test.test(this.name + " - reject error", function(test) {

        function fn(callback) {
            test.ok(arguments.length === 1 && typeof callback === "function", "function should be called with just a callback");
            throw 3;
        }

        var promise = asPromise(fn, null);
        promise.then(function() {
            test.fail("promise should not be resolved");
        }).catch(function(err) {
            test.equal(err, 3, "promise should be rejected with err = 3");
            test.end();
        });
    });

    test.test(this.name + " - reject and error", function(test) {

        function fn(callback) {
            callback(3);
            throw 4;
        }

        var count = 0;

        var promise = asPromise(fn, null);
        promise.then(function() {
            test.fail("promise should not be resolved");
        }).catch(function(err) {
            test.equal(err, 3, "promise should be rejected with err = 3");
            if (++count > 1)
                test.fail("promise should not be rejected twice");
            test.end();
        });
    });
});
/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
export function length(string: string): number;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
export function encode(buffer: Uint8Array, start: number, end: number): string;

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
export function decode(string: string, buffer: Uint8Array, offset: number): number;

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if it appears to be base64 encoded, otherwise false
 */
export function test(string: string): boolean;
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/base64",
  "description": "A minimal base64 implementation for number arrays.",
  "version": "1.1.2",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}@protobufjs/base64
==================
[![npm](https://img.shields.io/npm/v/@protobufjs/base64.svg)](https://www.npmjs.com/package/@protobufjs/base64)

A minimal base64 implementation for number arrays.

API
---

* **base64.length(string: `string`): `number`**<br />
  Calculates the byte length of a base64 encoded string.

* **base64.encode(buffer: `Uint8Array`, start: `number`, end: `number`): `string`**<br />
  Encodes a buffer to a base64 encoded string.

* **base64.decode(string: `string`, buffer: `Uint8Array`, offset: `number`): `number`**<br />
  Decodes a base64 encoded string to a buffer.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var base64 = require("..");

var strings = {
    "": "",
    "a": "YQ==",
    "ab": "YWI=",
    "abcdefg": "YWJjZGVmZw==",
    "abcdefgh": "YWJjZGVmZ2g=",
    "abcdefghi": "YWJjZGVmZ2hp"
};

tape.test("base64", function(test) {

    Object.keys(strings).forEach(function(str) {
        var enc = strings[str];

        test.equal(base64.test(enc), true, "should detect '" + enc + "' to be base64 encoded");

        var len = base64.length(enc);
        test.equal(len, str.length, "should calculate '" + enc + "' as " + str.length + " bytes");

        var buf = new Array(len);
        var len2 = base64.decode(enc, buf, 0);
        test.equal(len2, len, "should decode '" + enc + "' to " + len + " bytes");

        test.equal(String.fromCharCode.apply(String, buf), str, "should decode '" + enc + "' to '" + str + "'");

        var enc2 = base64.encode(buf, 0, buf.length);
        test.equal(enc2, enc, "should encode '" + str + "' to '" + enc + "'");

    });

    test.throws(function() {
        var buf = new Array(10);
        base64.decode("YQ!", buf, 0);
    }, Error, "should throw if encoding is invalid");

    test.throws(function() {
        var buf = new Array(10);
        base64.decode("Y", buf, 0);
    }, Error, "should throw if string is truncated");

    test.end();
});
export = codegen;

/**
 * Appends code to the function's body.
 * @param [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
 * @param [formatParams] Format parameters
 * @returns Itself or the generated function if finished
 * @throws {Error} If format parameter counts do not match
 */
type Codegen = (formatStringOrScope?: (string|{ [k: string]: any }), ...formatParams: any[]) => (Codegen|Function);

/**
 * Begins generating a function.
 * @param functionParams Function parameter names
 * @param [functionName] Function name if not anonymous
 * @returns Appender that appends code to the function's body
 */
declare function codegen(functionParams: string[], functionName?: string): Codegen;

/**
 * Begins generating a function.
 * @param [functionName] Function name if not anonymous
 * @returns Appender that appends code to the function's body
 */
declare function codegen(functionName?: string): Codegen;

declare namespace codegen {

    /** When set to `true`, codegen will log generated code to console. Useful for debugging. */
    let verbose: boolean;
}
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/codegen",
  "description": "A minimalistic code generation utility.",
  "version": "2.0.4",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts"
}@protobufjs/codegen
===================
[![npm](https://img.shields.io/npm/v/@protobufjs/codegen.svg)](https://www.npmjs.com/package/@protobufjs/codegen)

A minimalistic code generation utility.

API
---

* **codegen([functionParams: `string[]`], [functionName: string]): `Codegen`**<br />
  Begins generating a function.

* **codegen.verbose = `false`**<br />
  When set to true, codegen will log generated code to console. Useful for debugging.

Invoking **codegen** returns an appender function that appends code to the function's body and returns itself:

* **Codegen(formatString: `string`, [...formatParams: `any`]): Codegen**<br />
  Appends code to the function's body. The format string can contain placeholders specifying the types of inserted format parameters:

  * `%d`: Number (integer or floating point value)
  * `%f`: Floating point value
  * `%i`: Integer value
  * `%j`: JSON.stringify'ed value
  * `%s`: String value
  * `%%`: Percent sign<br />

* **Codegen([scope: `Object.<string,*>`]): `Function`**<br />
  Finishes the function and returns it.

* **Codegen.toString([functionNameOverride: `string`]): `string`**<br />
  Returns the function as a string.

Example
-------

```js
var codegen = require("@protobufjs/codegen");

var add = codegen(["a", "b"], "add") // A function with parameters "a" and "b" named "add"
  ("// awesome comment")             // adds the line to the function's body
  ("return a + b - c + %d", 1)       // replaces %d with 1 and adds the line to the body
  ({ c: 1 });                        // adds "c" with a value of 1 to the function's scope

console.log(add.toString()); // function add(a, b) { return a + b - c + 1 }
console.log(add(1, 2));      // calculates 1 + 2 - 1 + 1 = 3
```

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var codegen = require("..");

// new require("benchmark").Suite().add("add", function() {

var add = codegen(["a", "b"], "add")
  ("// awesome comment")
  ("return a + b - c + %d", 1)
  ({ c: 1 });

if (add(1, 2) !== 3)
  throw Error("failed");

// }).on("cycle", function(event) { process.stdout.write(String(event.target) + "\n"); }).run();
export = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
declare class EventEmitter {

    /**
     * Constructs a new event emitter instance.
     * @classdesc A minimal event emitter.
     * @memberof util
     * @constructor
     */
    constructor();

    /**
     * Registers an event listener.
     * @param {string} evt Event name
     * @param {function} fn Listener
     * @param {*} [ctx] Listener context
     * @returns {util.EventEmitter} `this`
     */
    on(evt: string, fn: () => any, ctx?: any): EventEmitter;

    /**
     * Removes an event listener or any matching listeners if arguments are omitted.
     * @param {string} [evt] Event name. Removes all listeners if omitted.
     * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
     * @returns {util.EventEmitter} `this`
     */
    off(evt?: string, fn?: () => any): EventEmitter;

    /**
     * Emits an event by calling its listeners with the specified arguments.
     * @param {string} evt Event name
     * @param {...*} args Arguments
     * @returns {util.EventEmitter} `this`
     */
    emit(evt: string, ...args: any[]): EventEmitter;
}
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/eventemitter",
  "description": "A minimal event emitter.",
  "version": "1.1.0",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}@protobufjs/eventemitter
========================
[![npm](https://img.shields.io/npm/v/@protobufjs/eventemitter.svg)](https://www.npmjs.com/package/@protobufjs/eventemitter)

A minimal event emitter.

API
---

* **new EventEmitter()**<br />
  Constructs a new event emitter instance.

* **EventEmitter#on(evt: `string`, fn: `function`, [ctx: `Object`]): `EventEmitter`**<br />
  Registers an event listener.

* **EventEmitter#off([evt: `string`], [fn: `function`]): `EventEmitter`**<br />
  Removes an event listener or any matching listeners if arguments are omitted.

* **EventEmitter#emit(evt: `string`, ...args: `*`): `EventEmitter`**<br />
  Emits an event by calling its listeners with the specified arguments.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var EventEmitter = require("..");

tape.test("eventemitter", function(test) {

    var ee = new EventEmitter();
    var fn;
    var ctx = {};

    test.doesNotThrow(function() {
        ee.emit("a", 1);
        ee.off();
        ee.off("a");
        ee.off("a", function() {});
    }, "should not throw if no listeners are registered");
    
    test.equal(ee.on("a", function(arg1) {
        test.equal(this, ctx, "should be called with this = ctx");
        test.equal(arg1, 1, "should be called with arg1 = 1");
    }, ctx), ee, "should return itself when registering events");
    ee.emit("a", 1);

    ee.off("a");
    test.same(ee._listeners, { a: [] }, "should remove all listeners of the respective event when calling off(evt)");

    ee.off();
    test.same(ee._listeners, {}, "should remove all listeners when just calling off()");

    ee.on("a", fn = function(arg1) {
        test.equal(this, ctx, "should be called with this = ctx");
        test.equal(arg1, 1, "should be called with arg1 = 1");
    }, ctx).emit("a", 1);

    ee.off("a", fn);
    test.same(ee._listeners, { a: [] }, "should remove the exact listener when calling off(evt, fn)");

    ee.on("a", function() {
        test.equal(this, ee, "should be called with this = ee");
    }).emit("a");

    test.doesNotThrow(function() {
        ee.off("a", fn);
    }, "should not throw if no such listener is found");

    test.end();
});
export = fetch;

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */
type FetchCallback = (error: Error, contents?: string) => void;

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

interface FetchOptions {
    binary?: boolean;
    xhr?: boolean
}

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
declare function fetch(filename: string, options: FetchOptions, callback: FetchCallback): void;

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
declare function fetch(path: string, callback: FetchCallback): void;

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */
declare function fetch(path: string, options?: FetchOptions): Promise<(string|Uint8Array)>;
"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/fetch",
  "description": "Fetches the contents of a file accross node and browsers.",
  "version": "1.1.0",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "dependencies": {
    "@protobufjs/aspromise": "^1.1.1",
    "@protobufjs/inquire": "^1.1.0"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}@protobufjs/fetch
=================
[![npm](https://img.shields.io/npm/v/@protobufjs/fetch.svg)](https://www.npmjs.com/package/@protobufjs/fetch)

Fetches the contents of a file accross node and browsers.

API
---

* **fetch(path: `string`, [options: { binary: boolean } ], [callback: `function(error: ?Error, [contents: string])`]): `Promise<string|Uint8Array>|undefined`**
  Fetches the contents of a file.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var fetch = require("..");

tape.test("fetch", function(test) {

    if (typeof Promise !== "undefined") {
        var promise = fetch("NOTFOUND");
        promise.catch(function() {});
        test.ok(promise instanceof Promise, "should return a promise if callback has been omitted");
    }

    // TODO - some way to test this properly?
    
    test.end();
});
"use strict";

var float = require(".."),
    ieee754 = require("ieee754"),
    newSuite = require("./suite");

var F32 = Float32Array;
var F64 = Float64Array;
delete global.Float32Array;
delete global.Float64Array;
var floatFallback = float({});
global.Float32Array = F32;
global.Float64Array = F64;

var buf = new Buffer(8);

newSuite("writeFloat")
.add("float", function() {
    float.writeFloatLE(0.1, buf, 0);
})
.add("float (fallback)", function() {
    floatFallback.writeFloatLE(0.1, buf, 0);
})
.add("ieee754", function() {
    ieee754.write(buf, 0.1, 0, true, 23, 4);
})
.add("buffer", function() {
    buf.writeFloatLE(0.1, 0);
})
.add("buffer (noAssert)", function() {
    buf.writeFloatLE(0.1, 0, true);
})
.run();

newSuite("readFloat")
.add("float", function() {
    float.readFloatLE(buf, 0);
})
.add("float (fallback)", function() {
    floatFallback.readFloatLE(buf, 0);
})
.add("ieee754", function() {
    ieee754.read(buf, 0, true, 23, 4);
})
.add("buffer", function() {
    buf.readFloatLE(0);
})
.add("buffer (noAssert)", function() {
    buf.readFloatLE(0, true);
})
.run();

newSuite("writeDouble")
.add("float", function() {
    float.writeDoubleLE(0.1, buf, 0);
})
.add("float (fallback)", function() {
    floatFallback.writeDoubleLE(0.1, buf, 0);
})
.add("ieee754", function() {
    ieee754.write(buf, 0.1, 0, true, 52, 8);
})
.add("buffer", function() {
    buf.writeDoubleLE(0.1, 0);
})
.add("buffer (noAssert)", function() {
    buf.writeDoubleLE(0.1, 0, true);
})
.run();

newSuite("readDouble")
.add("float", function() {
    float.readDoubleLE(buf, 0);
})
.add("float (fallback)", function() {
    floatFallback.readDoubleLE(buf, 0);
})
.add("ieee754", function() {
    ieee754.read(buf, 0, true, 52, 8);
})
.add("buffer", function() {
    buf.readDoubleLE(0);
})
.add("buffer (noAssert)", function() {
    buf.readDoubleLE(0, true);
})
.run();
"use strict";
module.exports = newSuite;

var benchmark = require("benchmark"),
    chalk     = require("chalk");

var padSize = 27;

function newSuite(name) {
    var benches = [];
    return new benchmark.Suite(name)
    .on("add", function(event) {
        benches.push(event.target);
    })
    .on("start", function() {
        process.stdout.write("benchmarking " + name + " performance ...\n\n");
    })
    .on("cycle", function(event) {
        process.stdout.write(String(event.target) + "\n");
    })
    .on("complete", function() {
        if (benches.length > 1) {
            var fastest = this.filter("fastest"), // eslint-disable-line no-invalid-this
                fastestHz = getHz(fastest[0]);
            process.stdout.write("\n" + chalk.white(pad(fastest[0].name, padSize)) + " was " + chalk.green("fastest") + "\n");
            benches.forEach(function(bench) {
                if (fastest.indexOf(bench) === 0)
                    return;
                var hz = hz = getHz(bench);
                var percent = (1 - hz / fastestHz) * 100;
                process.stdout.write(chalk.white(pad(bench.name, padSize)) + " was " + chalk.red(percent.toFixed(1) + "% slower") + "\n");
            });
        }
        process.stdout.write("\n");
    });
}

function getHz(bench) {
    return 1 / (bench.stats.mean + bench.stats.moe);
}

function pad(str, len, l) {
    while (str.length < len)
        str = l ? str + " " : " " + str;
    return str;
}
/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */
export function writeFloatLE(val: number, buf: Uint8Array, pos: number): void;

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */
export function writeFloatBE(val: number, buf: Uint8Array, pos: number): void;

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */
export function readFloatLE(buf: Uint8Array, pos: number): number;

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */
export function readFloatBE(buf: Uint8Array, pos: number): number;

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */
export function writeDoubleLE(val: number, buf: Uint8Array, pos: number): void;

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */
export function writeDoubleBE(val: number, buf: Uint8Array, pos: number): void;

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */
export function readDoubleLE(buf: Uint8Array, pos: number): number;

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */
export function readDoubleBE(buf: Uint8Array, pos: number): number;
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/float",
  "description": "Reads / writes floats / doubles from / to buffers in both modern and ancient browsers.",
  "version": "1.0.2",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "dependencies": {},
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "chalk": "^1.1.3",
    "ieee754": "^1.1.8",
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js",
    "bench": "node bench"
  }
}@protobufjs/float
=================
[![npm](https://img.shields.io/npm/v/@protobufjs/float.svg)](https://www.npmjs.com/package/@protobufjs/float)

Reads / writes floats / doubles from / to buffers in both modern and ancient browsers. Fast.

API
---

* **writeFloatLE(val: `number`, buf: `Uint8Array`, pos: `number`)**<br />
  Writes a 32 bit float to a buffer using little endian byte order.

* **writeFloatBE(val: `number`, buf: `Uint8Array`, pos: `number`)**<br />
  Writes a 32 bit float to a buffer using big endian byte order.

* **readFloatLE(buf: `Uint8Array`, pos: `number`): `number`**<br />
  Reads a 32 bit float from a buffer using little endian byte order.

* **readFloatBE(buf: `Uint8Array`, pos: `number`): `number`**<br />
  Reads a 32 bit float from a buffer using big endian byte order.

* **writeDoubleLE(val: `number`, buf: `Uint8Array`, pos: `number`)**<br />
  Writes a 64 bit double to a buffer using little endian byte order.

* **writeDoubleBE(val: `number`, buf: `Uint8Array`, pos: `number`)**<br />
  Writes a 64 bit double to a buffer using big endian byte order.

* **readDoubleLE(buf: `Uint8Array`, pos: `number`): `number`**<br />
  Reads a 64 bit double from a buffer using little endian byte order.

* **readDoubleBE(buf: `Uint8Array`, pos: `number`): `number`**<br />
  Reads a 64 bit double from a buffer using big endian byte order.

Performance
-----------
There is a simple benchmark included comparing raw read/write performance of this library (float), float's fallback for old browsers, the [ieee754](https://www.npmjs.com/package/ieee754) module and node's [buffer](https://nodejs.org/api/buffer.html). On an i7-2600k running node 6.9.1 it yields:

```
benchmarking writeFloat performance ...

float x 42,741,625 ops/sec ±1.75% (81 runs sampled)
float (fallback) x 11,272,532 ops/sec ±1.12% (85 runs sampled)
ieee754 x 8,653,337 ops/sec ±1.18% (84 runs sampled)
buffer x 12,412,414 ops/sec ±1.41% (83 runs sampled)
buffer (noAssert) x 13,471,149 ops/sec ±1.09% (84 runs sampled)

                      float was fastest
           float (fallback) was 73.5% slower
                    ieee754 was 79.6% slower
                     buffer was 70.9% slower
          buffer (noAssert) was 68.3% slower

benchmarking readFloat performance ...

float x 44,382,729 ops/sec ±1.70% (84 runs sampled)
float (fallback) x 20,925,938 ops/sec ±0.86% (87 runs sampled)
ieee754 x 17,189,009 ops/sec ±1.01% (87 runs sampled)
buffer x 10,518,437 ops/sec ±1.04% (83 runs sampled)
buffer (noAssert) x 11,031,636 ops/sec ±1.15% (87 runs sampled)

                      float was fastest
           float (fallback) was 52.5% slower
                    ieee754 was 61.0% slower
                     buffer was 76.1% slower
          buffer (noAssert) was 75.0% slower

benchmarking writeDouble performance ...

float x 38,624,906 ops/sec ±0.93% (83 runs sampled)
float (fallback) x 10,457,811 ops/sec ±1.54% (85 runs sampled)
ieee754 x 7,681,130 ops/sec ±1.11% (83 runs sampled)
buffer x 12,657,876 ops/sec ±1.03% (83 runs sampled)
buffer (noAssert) x 13,372,795 ops/sec ±0.84% (85 runs sampled)

                      float was fastest
           float (fallback) was 73.1% slower
                    ieee754 was 80.1% slower
                     buffer was 67.3% slower
          buffer (noAssert) was 65.3% slower

benchmarking readDouble performance ...

float x 40,527,888 ops/sec ±1.05% (84 runs sampled)
float (fallback) x 18,696,480 ops/sec ±0.84% (86 runs sampled)
ieee754 x 14,074,028 ops/sec ±1.04% (87 runs sampled)
buffer x 10,092,367 ops/sec ±1.15% (84 runs sampled)
buffer (noAssert) x 10,623,793 ops/sec ±0.96% (84 runs sampled)

                      float was fastest
           float (fallback) was 53.8% slower
                    ieee754 was 65.3% slower
                     buffer was 75.1% slower
          buffer (noAssert) was 73.8% slower
```

To run it yourself:

```
$> npm run bench
```

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var float = require("..");

tape.test("float", function(test) {

    // default
    test.test(test.name + " - typed array", function(test) {
        runTest(float, test);
    });

    // ieee754
    test.test(test.name + " - fallback", function(test) {
        var F32 = global.Float32Array,
            F64 = global.Float64Array;
        delete global.Float32Array;
        delete global.Float64Array;
        runTest(float({}), test);
        global.Float32Array = F32;
        global.Float64Array = F64;
    });
});

function runTest(float, test) {

    var common = [
        0,
        -0,
        Infinity,
        -Infinity,
        0.125,
        1024.5,
        -4096.5,
        NaN
    ];

    test.test(test.name + " - using 32 bits", function(test) {
        common.concat([
            3.4028234663852886e+38,
            1.1754943508222875e-38,
            1.1754946310819804e-39
        ])
        .forEach(function(value) {
            var strval = value === 0 && 1 / value < 0 ? "-0" : value.toString();
            test.ok(
                checkValue(value, 4, float.readFloatLE, float.writeFloatLE, Buffer.prototype.writeFloatLE),
                "should write and read back " + strval + " (32 bit LE)"
            );
            test.ok(
                checkValue(value, 4, float.readFloatBE, float.writeFloatBE, Buffer.prototype.writeFloatBE),
                "should write and read back " + strval + " (32 bit BE)"
            );
        });
        test.end();
    });

    test.test(test.name + " - using 64 bits", function(test) {
        common.concat([
            1.7976931348623157e+308,
            2.2250738585072014e-308,
            2.2250738585072014e-309
        ])
        .forEach(function(value) {
            var strval = value === 0 && 1 / value < 0 ? "-0" : value.toString();
            test.ok(
                checkValue(value, 8, float.readDoubleLE, float.writeDoubleLE, Buffer.prototype.writeDoubleLE),
                "should write and read back " + strval + " (64 bit LE)"
            );
            test.ok(
                checkValue(value, 8, float.readDoubleBE, float.writeDoubleBE, Buffer.prototype.writeDoubleBE),
                "should write and read back " + strval + " (64 bit BE)"
            );
        });
        test.end();
    });

    test.end();
}

function checkValue(value, size, read, write, write_comp) {
    var buffer = new Buffer(size);
    write(value, buffer, 0);
    var value_comp = read(buffer, 0);
    var strval = value === 0 && 1 / value < 0 ? "-0" : value.toString();
    if (value !== value) {
        if (value_comp === value_comp)
            return false;
    } else if (value_comp !== value)
        return false;

    var buffer_comp = new Buffer(size);
    write_comp.call(buffer_comp, value, 0);
    for (var i = 0; i < size; ++i)
        if (buffer[i] !== buffer_comp[i]) {
            console.error(">", buffer, buffer_comp);
            return false;
        }

    return true;
}npm-debug.*
node_modules/
coverage/
export = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
declare function inquire(moduleName: string): Object;
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/inquire",
  "description": "Requires a module only if available and hides the require call from bundlers.",
  "version": "1.1.0",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}@protobufjs/inquire
===================
[![npm](https://img.shields.io/npm/v/@protobufjs/inquire.svg)](https://www.npmjs.com/package/@protobufjs/inquire)

Requires a module only if available and hides the require call from bundlers.

API
---

* **inquire(moduleName: `string`): `?Object`**<br />
  Requires a module only if available.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
module.exports = [1];
module.exports = [];
module.exports = {};
module.exports = { a: 1 };
var tape = require("tape");

var inquire = require("..");

tape.test("inquire", function(test) {

    test.equal(inquire("buffer").Buffer, Buffer, "should be able to require \"buffer\"");

    test.equal(inquire("%invalid"), null, "should not be able to require \"%invalid\"");

    test.equal(inquire("./tests/data/emptyObject"), null, "should return null when requiring a module exporting an empty object");

    test.equal(inquire("./tests/data/emptyArray"), null, "should return null when requiring a module exporting an empty array");

    test.same(inquire("./tests/data/object"), { a: 1 }, "should return the object if a non-empty object");

    test.same(inquire("./tests/data/array"), [ 1 ], "should return the module if a non-empty array");

    test.end();
});
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
export function isAbsolute(path: string): boolean;

/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
export function normalize(path: string): string;

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
export function resolve(originPath: string, includePath: string, alreadyNormalized?: boolean): string;
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/path",
  "description": "A minimal path module to resolve Unix, Windows and URL paths alike.",
  "version": "1.1.2",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}@protobufjs/path
================
[![npm](https://img.shields.io/npm/v/@protobufjs/path.svg)](https://www.npmjs.com/package/@protobufjs/path)

A minimal path module to resolve Unix, Windows and URL paths alike.

API
---

* **path.isAbsolute(path: `string`): `boolean`**<br />
  Tests if the specified path is absolute.

* **path.normalize(path: `string`): `string`**<br />
  Normalizes the specified path.

* **path.resolve(originPath: `string`, includePath: `string`, [alreadyNormalized=false: `boolean`]): `string`**<br />
  Resolves the specified include path against the specified origin path.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var path = require("..");

tape.test("path", function(test) {

    test.ok(path.isAbsolute("X:\\some\\path\\file.js"), "should identify absolute windows paths");
    test.ok(path.isAbsolute("/some/path/file.js"), "should identify absolute unix paths");

    test.notOk(path.isAbsolute("some\\path\\file.js"), "should identify relative windows paths");
    test.notOk(path.isAbsolute("some/path/file.js"), "should identify relative unix paths");

    var paths = [
        {
            actual: "X:\\some\\..\\.\\path\\\\file.js",
            normal: "X:/path/file.js",
            resolve: {
                origin: "X:/path/origin.js",
                expected: "X:/path/file.js"
            }
        }, {
            actual: "some\\..\\.\\path\\\\file.js",
            normal: "path/file.js",
            resolve: {
                origin: "X:/path/origin.js",
                expected: "X:/path/path/file.js"
            }
        }, {
            actual: "/some/.././path//file.js",
            normal: "/path/file.js",
            resolve: {
                origin: "/path/origin.js",
                expected: "/path/file.js"
            }
        }, {
            actual: "some/.././path//file.js",
            normal: "path/file.js",
            resolve: {
                origin: "",
                expected: "path/file.js"
            }
        }, {
            actual: ".././path//file.js",
            normal: "../path/file.js"
        }, {
            actual: "/.././path//file.js",
            normal: "/path/file.js"
        }
    ];

    paths.forEach(function(p) {
        test.equal(path.normalize(p.actual), p.normal, "should normalize " + p.actual);
        if (p.resolve) {
            test.equal(path.resolve(p.resolve.origin, p.actual), p.resolve.expected, "should resolve " + p.actual);
            test.equal(path.resolve(p.resolve.origin, p.normal, true), p.resolve.expected, "should resolve " + p.normal + " (already normalized)");
        }
    });

    test.end();
});
npm-debug.*
node_modules/
coverage/
export = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
type PoolAllocator = (size: number) => Uint8Array;

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */
type PoolSlicer = (this: Uint8Array, start: number, end: number) => Uint8Array;

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
declare function pool(alloc: PoolAllocator, slice: PoolSlicer, size?: number): PoolAllocator;
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/pool",
  "description": "A general purpose buffer pool.",
  "version": "1.1.0",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}
@protobufjs/pool
================
[![npm](https://img.shields.io/npm/v/@protobufjs/pool.svg)](https://www.npmjs.com/package/@protobufjs/pool)

A general purpose buffer pool.

API
---

* **pool(alloc: `function(size: number): Uint8Array`, slice: `function(this: Uint8Array, start: number, end: number): Uint8Array`, [size=8192: `number`]): `function(size: number): Uint8Array`**<br />
  Creates a pooled allocator.

**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
var tape = require("tape");

var pool = require("..");

if (typeof Uint8Array !== "undefined")
tape.test("pool", function(test) {

    var alloc = pool(function(size) { return new Uint8Array(size); }, Uint8Array.prototype.subarray);

    var buf1 = alloc(0);
    test.equal(buf1.length, 0, "should allocate a buffer of size 0");

    var buf2 = alloc(1);
    test.equal(buf2.length, 1, "should allocate a buffer of size 1 (initializes slab)");

    test.notEqual(buf2.buffer, buf1.buffer, "should not reference the same backing buffer if previous buffer had size 0");
    test.equal(buf2.byteOffset, 0, "should allocate at byteOffset 0 when using a new slab");

    buf1 = alloc(1);
    test.equal(buf1.buffer, buf2.buffer, "should reference the same backing buffer when allocating a chunk fitting into the slab");
    test.equal(buf1.byteOffset, 8, "should align slices to 32 bit and this allocate at byteOffset 8");

    var buf3 = alloc(4097);
    test.notEqual(buf3.buffer, buf2.buffer, "should not reference the same backing buffer when allocating a buffer larger than half the backing buffer's size");

    buf2 = alloc(4096);
    test.equal(buf2.buffer, buf1.buffer, "should reference the same backing buffer when allocating a buffer smaller or equal than half the backing buffer's size");

    buf1 = alloc(4096);
    test.notEqual(buf1.buffer, buf2.buffer, "should not reference the same backing buffer when the slab is exhausted (initializes new slab)");

    test.end();
});npm-debug.*
node_modules/
coverage/
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
export function length(string: string): number;

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
export function read(buffer: Uint8Array, start: number, end: number): string;

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
export function write(string: string, buffer: Uint8Array, offset: number): number;
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};
Copyright (c) 2016, Daniel Wirtz  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of its author, nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@protobufjs/utf8",
  "description": "A minimal UTF8 implementation for number arrays.",
  "version": "1.1.0",
  "author": "Daniel Wirtz <dcode+protobufjs@dcode.io>",
  "repository": {
    "type": "git",
    "url": "https://github.com/dcodeIO/protobuf.js.git"
  },
  "license": "BSD-3-Clause",
  "main": "index.js",
  "types": "index.d.ts",
  "devDependencies": {
    "istanbul": "^0.4.5",
    "tape": "^4.6.3"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js"
  }
}
@protobufjs/utf8
================
[![npm](https://img.shields.io/npm/v/@protobufjs/utf8.svg)](https://www.npmjs.com/package/@protobufjs/utf8)

A minimal UTF8 implementation for number arrays.

API
---

* **utf8.length(string: `string`): `number`**<br />
  Calculates the UTF8 byte length of a string.

* **utf8.read(buffer: `Uint8Array`, start: `number`, end: `number`): `string`**<br />
  Reads UTF8 bytes as a string.

* **utf8.write(string: `string`, buffer: `Uint8Array`, offset: `number`): `number`**<br />
  Writes a string as UTF8 bytes.


**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)
UTF-8 encoded sample plain-text file
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

Markus Kuhn [ˈmaʳkʊs kuːn] <http://www.cl.cam.ac.uk/~mgk25/> — 2002-07-25 CC BY


The ASCII compatible UTF-8 encoding used in this plain-text file
is defined in Unicode, ISO 10646-1, and RFC 2279.


Using Unicode/UTF-8, you can write in emails and source code things such as

Mathematics and sciences:

  ∮ E⋅da = Q,  n → ∞, ∑ f(i) = ∏ g(i),      ⎧⎡⎛┌─────┐⎞⎤⎫
                                            ⎪⎢⎜│a²+b³ ⎟⎥⎪
  ∀x∈ℝ: ⌈x⌉ = −⌊−x⌋, α ∧ ¬β = ¬(¬α ∨ β),    ⎪⎢⎜│───── ⎟⎥⎪
                                            ⎪⎢⎜⎷ c₈   ⎟⎥⎪
  ℕ ⊆ ℕ₀ ⊂ ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ,                   ⎨⎢⎜       ⎟⎥⎬
                                            ⎪⎢⎜ ∞     ⎟⎥⎪
  ⊥ < a ≠ b ≡ c ≤ d ≪ ⊤ ⇒ (⟦A⟧ ⇔ ⟪B⟫),      ⎪⎢⎜ ⎲     ⎟⎥⎪
                                            ⎪⎢⎜ ⎳aⁱ-bⁱ⎟⎥⎪
  2H₂ + O₂ ⇌ 2H₂O, R = 4.7 kΩ, ⌀ 200 mm     ⎩⎣⎝i=1    ⎠⎦⎭

Linguistics and dictionaries:

  ði ıntəˈnæʃənəl fəˈnɛtık əsoʊsiˈeıʃn
  Y [ˈʏpsilɔn], Yen [jɛn], Yoga [ˈjoːgɑ]

APL:

  ((V⍳V)=⍳⍴V)/V←,V    ⌷←⍳→⍴∆∇⊃‾⍎⍕⌈

Nicer typography in plain text files:

  ╔══════════════════════════════════════════╗
  ║                                          ║
  ║   • ‘single’ and “double” quotes         ║
  ║                                          ║
  ║   • Curly apostrophes: “We’ve been here” ║
  ║                                          ║
  ║   • Latin-1 apostrophe and accents: '´`  ║
  ║                                          ║
  ║   • ‚deutsche‘ „Anführungszeichen“       ║
  ║                                          ║
  ║   • †, ‡, ‰, •, 3–4, —, −5/+5, ™, …      ║
  ║                                          ║
  ║   • ASCII safety test: 1lI|, 0OD, 8B     ║
  ║                      ╭─────────╮         ║
  ║   • the euro symbol: │ 14.95 € │         ║
  ║                      ╰─────────╯         ║
  ╚══════════════════════════════════════════╝

Combining characters:

  STARGΛ̊TE SG-1, a = v̇ = r̈, a⃑ ⊥ b⃑

Greek (in Polytonic):

  The Greek anthem:

  Σὲ γνωρίζω ἀπὸ τὴν κόψη
  τοῦ σπαθιοῦ τὴν τρομερή,
  σὲ γνωρίζω ἀπὸ τὴν ὄψη
  ποὺ μὲ βία μετράει τὴ γῆ.

  ᾿Απ᾿ τὰ κόκκαλα βγαλμένη
  τῶν ῾Ελλήνων τὰ ἱερά
  καὶ σὰν πρῶτα ἀνδρειωμένη
  χαῖρε, ὦ χαῖρε, ᾿Ελευθεριά!

  From a speech of Demosthenes in the 4th century BC:

  Οὐχὶ ταὐτὰ παρίσταταί μοι γιγνώσκειν, ὦ ἄνδρες ᾿Αθηναῖοι,
  ὅταν τ᾿ εἰς τὰ πράγματα ἀποβλέψω καὶ ὅταν πρὸς τοὺς
  λόγους οὓς ἀκούω· τοὺς μὲν γὰρ λόγους περὶ τοῦ
  τιμωρήσασθαι Φίλιππον ὁρῶ γιγνομένους, τὰ δὲ πράγματ᾿
  εἰς τοῦτο προήκοντα,  ὥσθ᾿ ὅπως μὴ πεισόμεθ᾿ αὐτοὶ
  πρότερον κακῶς σκέψασθαι δέον. οὐδέν οὖν ἄλλο μοι δοκοῦσιν
  οἱ τὰ τοιαῦτα λέγοντες ἢ τὴν ὑπόθεσιν, περὶ ἧς βουλεύεσθαι,
  οὐχὶ τὴν οὖσαν παριστάντες ὑμῖν ἁμαρτάνειν. ἐγὼ δέ, ὅτι μέν
  ποτ᾿ ἐξῆν τῇ πόλει καὶ τὰ αὑτῆς ἔχειν ἀσφαλῶς καὶ Φίλιππον
  τιμωρήσασθαι, καὶ μάλ᾿ ἀκριβῶς οἶδα· ἐπ᾿ ἐμοῦ γάρ, οὐ πάλαι
  γέγονεν ταῦτ᾿ ἀμφότερα· νῦν μέντοι πέπεισμαι τοῦθ᾿ ἱκανὸν
  προλαβεῖν ἡμῖν εἶναι τὴν πρώτην, ὅπως τοὺς συμμάχους
  σώσομεν. ἐὰν γὰρ τοῦτο βεβαίως ὑπάρξῃ, τότε καὶ περὶ τοῦ
  τίνα τιμωρήσεταί τις καὶ ὃν τρόπον ἐξέσται σκοπεῖν· πρὶν δὲ
  τὴν ἀρχὴν ὀρθῶς ὑποθέσθαι, μάταιον ἡγοῦμαι περὶ τῆς
  τελευτῆς ὁντινοῦν ποιεῖσθαι λόγον.

  Δημοσθένους, Γ´ ᾿Ολυνθιακὸς

Georgian:

  From a Unicode conference invitation:

  გთხოვთ ახლავე გაიაროთ რეგისტრაცია Unicode-ის მეათე საერთაშორისო
  კონფერენციაზე დასასწრებად, რომელიც გაიმართება 10-12 მარტს,
  ქ. მაინცში, გერმანიაში. კონფერენცია შეჰკრებს ერთად მსოფლიოს
  ექსპერტებს ისეთ დარგებში როგორიცაა ინტერნეტი და Unicode-ი,
  ინტერნაციონალიზაცია და ლოკალიზაცია, Unicode-ის გამოყენება
  ოპერაციულ სისტემებსა, და გამოყენებით პროგრამებში, შრიფტებში,
  ტექსტების დამუშავებასა და მრავალენოვან კომპიუტერულ სისტემებში.

Russian:

  From a Unicode conference invitation:

  Зарегистрируйтесь сейчас на Десятую Международную Конференцию по
  Unicode, которая состоится 10-12 марта 1997 года в Майнце в Германии.
  Конференция соберет широкий круг экспертов по  вопросам глобального
  Интернета и Unicode, локализации и интернационализации, воплощению и
  применению Unicode в различных операционных системах и программных
  приложениях, шрифтах, верстке и многоязычных компьютерных системах.

Thai (UCS Level 2):

  Excerpt from a poetry on The Romance of The Three Kingdoms (a Chinese
  classic 'San Gua'):

  [----------------------------|------------------------]
    ๏ แผ่นดินฮั่นเสื่อมโทรมแสนสังเวช  พระปกเกศกองบู๊กู้ขึ้นใหม่
  สิบสองกษัตริย์ก่อนหน้าแลถัดไป       สององค์ไซร้โง่เขลาเบาปัญญา
    ทรงนับถือขันทีเป็นที่พึ่ง           บ้านเมืองจึงวิปริตเป็นนักหนา
  โฮจิ๋นเรียกทัพทั่วหัวเมืองมา         หมายจะฆ่ามดชั่วตัวสำคัญ
    เหมือนขับไสไล่เสือจากเคหา      รับหมาป่าเข้ามาเลยอาสัญ
  ฝ่ายอ้องอุ้นยุแยกให้แตกกัน          ใช้สาวนั้นเป็นชนวนชื่นชวนใจ
    พลันลิฉุยกุยกีกลับก่อเหตุ          ช่างอาเพศจริงหนาฟ้าร้องไห้
  ต้องรบราฆ่าฟันจนบรรลัย           ฤๅหาใครค้ำชูกู้บรรลังก์ ฯ

  (The above is a two-column text. If combining characters are handled
  correctly, the lines of the second column should be aligned with the
  | character above.)

Ethiopian:

  Proverbs in the Amharic language:

  ሰማይ አይታረስ ንጉሥ አይከሰስ።
  ብላ ካለኝ እንደአባቴ በቆመጠኝ።
  ጌጥ ያለቤቱ ቁምጥና ነው።
  ደሀ በሕልሙ ቅቤ ባይጠጣ ንጣት በገደለው።
  የአፍ ወለምታ በቅቤ አይታሽም።
  አይጥ በበላ ዳዋ ተመታ።
  ሲተረጉሙ ይደረግሙ።
  ቀስ በቀስ፥ ዕንቁላል በእግሩ ይሄዳል።
  ድር ቢያብር አንበሳ ያስር።
  ሰው እንደቤቱ እንጅ እንደ ጉረቤቱ አይተዳደርም።
  እግዜር የከፈተውን ጉሮሮ ሳይዘጋው አይድርም።
  የጎረቤት ሌባ፥ ቢያዩት ይስቅ ባያዩት ያጠልቅ።
  ሥራ ከመፍታት ልጄን ላፋታት።
  ዓባይ ማደሪያ የለው፥ ግንድ ይዞ ይዞራል።
  የእስላም አገሩ መካ የአሞራ አገሩ ዋርካ።
  ተንጋሎ ቢተፉ ተመልሶ ባፉ።
  ወዳጅህ ማር ቢሆን ጨርስህ አትላሰው።
  እግርህን በፍራሽህ ልክ ዘርጋ።

Runes:

  ᚻᛖ ᚳᚹᚫᚦ ᚦᚫᛏ ᚻᛖ ᛒᚢᛞᛖ ᚩᚾ ᚦᚫᛗ ᛚᚪᚾᛞᛖ ᚾᚩᚱᚦᚹᛖᚪᚱᛞᚢᛗ ᚹᛁᚦ ᚦᚪ ᚹᛖᛥᚫ

  (Old English, which transcribed into Latin reads 'He cwaeth that he
  bude thaem lande northweardum with tha Westsae.' and means 'He said
  that he lived in the northern land near the Western Sea.')

Braille:

  ⡌⠁⠧⠑ ⠼⠁⠒  ⡍⠜⠇⠑⠹⠰⠎ ⡣⠕⠌

  ⡍⠜⠇⠑⠹ ⠺⠁⠎ ⠙⠑⠁⠙⠒ ⠞⠕ ⠃⠑⠛⠔ ⠺⠊⠹⠲ ⡹⠻⠑ ⠊⠎ ⠝⠕ ⠙⠳⠃⠞
  ⠱⠁⠞⠑⠧⠻ ⠁⠃⠳⠞ ⠹⠁⠞⠲ ⡹⠑ ⠗⠑⠛⠊⠌⠻ ⠕⠋ ⠙⠊⠎ ⠃⠥⠗⠊⠁⠇ ⠺⠁⠎
  ⠎⠊⠛⠝⠫ ⠃⠹ ⠹⠑ ⠊⠇⠻⠛⠹⠍⠁⠝⠂ ⠹⠑ ⠊⠇⠻⠅⠂ ⠹⠑ ⠥⠝⠙⠻⠞⠁⠅⠻⠂
  ⠁⠝⠙ ⠹⠑ ⠡⠊⠑⠋ ⠍⠳⠗⠝⠻⠲ ⡎⠊⠗⠕⠕⠛⠑ ⠎⠊⠛⠝⠫ ⠊⠞⠲ ⡁⠝⠙
  ⡎⠊⠗⠕⠕⠛⠑⠰⠎ ⠝⠁⠍⠑ ⠺⠁⠎ ⠛⠕⠕⠙ ⠥⠏⠕⠝ ⠰⡡⠁⠝⠛⠑⠂ ⠋⠕⠗ ⠁⠝⠹⠹⠔⠛ ⠙⠑
  ⠡⠕⠎⠑ ⠞⠕ ⠏⠥⠞ ⠙⠊⠎ ⠙⠁⠝⠙ ⠞⠕⠲

  ⡕⠇⠙ ⡍⠜⠇⠑⠹ ⠺⠁⠎ ⠁⠎ ⠙⠑⠁⠙ ⠁⠎ ⠁ ⠙⠕⠕⠗⠤⠝⠁⠊⠇⠲

  ⡍⠔⠙⠖ ⡊ ⠙⠕⠝⠰⠞ ⠍⠑⠁⠝ ⠞⠕ ⠎⠁⠹ ⠹⠁⠞ ⡊ ⠅⠝⠪⠂ ⠕⠋ ⠍⠹
  ⠪⠝ ⠅⠝⠪⠇⠫⠛⠑⠂ ⠱⠁⠞ ⠹⠻⠑ ⠊⠎ ⠏⠜⠞⠊⠊⠥⠇⠜⠇⠹ ⠙⠑⠁⠙ ⠁⠃⠳⠞
  ⠁ ⠙⠕⠕⠗⠤⠝⠁⠊⠇⠲ ⡊ ⠍⠊⠣⠞ ⠙⠁⠧⠑ ⠃⠑⠲ ⠔⠊⠇⠔⠫⠂ ⠍⠹⠎⠑⠇⠋⠂ ⠞⠕
  ⠗⠑⠛⠜⠙ ⠁ ⠊⠕⠋⠋⠔⠤⠝⠁⠊⠇ ⠁⠎ ⠹⠑ ⠙⠑⠁⠙⠑⠌ ⠏⠊⠑⠊⠑ ⠕⠋ ⠊⠗⠕⠝⠍⠕⠝⠛⠻⠹
  ⠔ ⠹⠑ ⠞⠗⠁⠙⠑⠲ ⡃⠥⠞ ⠹⠑ ⠺⠊⠎⠙⠕⠍ ⠕⠋ ⠳⠗ ⠁⠝⠊⠑⠌⠕⠗⠎
  ⠊⠎ ⠔ ⠹⠑ ⠎⠊⠍⠊⠇⠑⠆ ⠁⠝⠙ ⠍⠹ ⠥⠝⠙⠁⠇⠇⠪⠫ ⠙⠁⠝⠙⠎
  ⠩⠁⠇⠇ ⠝⠕⠞ ⠙⠊⠌⠥⠗⠃ ⠊⠞⠂ ⠕⠗ ⠹⠑ ⡊⠳⠝⠞⠗⠹⠰⠎ ⠙⠕⠝⠑ ⠋⠕⠗⠲ ⡹⠳
  ⠺⠊⠇⠇ ⠹⠻⠑⠋⠕⠗⠑ ⠏⠻⠍⠊⠞ ⠍⠑ ⠞⠕ ⠗⠑⠏⠑⠁⠞⠂ ⠑⠍⠏⠙⠁⠞⠊⠊⠁⠇⠇⠹⠂ ⠹⠁⠞
  ⡍⠜⠇⠑⠹ ⠺⠁⠎ ⠁⠎ ⠙⠑⠁⠙ ⠁⠎ ⠁ ⠙⠕⠕⠗⠤⠝⠁⠊⠇⠲

  (The first couple of paragraphs of "A Christmas Carol" by Dickens)

Compact font selection example text:

  ABCDEFGHIJKLMNOPQRSTUVWXYZ /0123456789
  abcdefghijklmnopqrstuvwxyz £©µÀÆÖÞßéöÿ
  –—‘“”„†•…‰™œŠŸž€ ΑΒΓΔΩαβγδω АБВГДабвгд
  ∀∂∈ℝ∧∪≡∞ ↑↗↨↻⇣ ┐┼╔╘░►☺♀ ﬁ�⑀₂ἠḂӥẄɐː⍎אԱა

Greetings in various languages:

  Hello world, Καλημέρα κόσμε, コンニチハ

Box drawing alignment tests:                                          █
                                                                      ▉
  ╔══╦══╗  ┌──┬──┐  ╭──┬──╮  ╭──┬──╮  ┏━━┳━━┓  ┎┒┏┑   ╷  ╻ ┏┯┓ ┌┰┐    ▊ ╱╲╱╲╳╳╳
  ║┌─╨─┐║  │╔═╧═╗│  │╒═╪═╕│  │╓─╁─╖│  ┃┌─╂─┐┃  ┗╃╄┙  ╶┼╴╺╋╸┠┼┨ ┝╋┥    ▋ ╲╱╲╱╳╳╳
  ║│╲ ╱│║  │║   ║│  ││ │ ││  │║ ┃ ║│  ┃│ ╿ │┃  ┍╅╆┓   ╵  ╹ ┗┷┛ └┸┘    ▌ ╱╲╱╲╳╳╳
  ╠╡ ╳ ╞╣  ├╢   ╟┤  ├┼─┼─┼┤  ├╫─╂─╫┤  ┣┿╾┼╼┿┫  ┕┛┖┚     ┌┄┄┐ ╎ ┏┅┅┓ ┋ ▍ ╲╱╲╱╳╳╳
  ║│╱ ╲│║  │║   ║│  ││ │ ││  │║ ┃ ║│  ┃│ ╽ │┃  ░░▒▒▓▓██ ┊  ┆ ╎ ╏  ┇ ┋ ▎
  ║└─╥─┘║  │╚═╤═╝│  │╘═╪═╛│  │╙─╀─╜│  ┃└─╂─┘┃  ░░▒▒▓▓██ ┊  ┆ ╎ ╏  ┇ ┋ ▏
  ╚══╩══╝  └──┴──┘  ╰──┴──╯  ╰──┴──╯  ┗━━┻━━┛  ▗▄▖▛▀▜   └╌╌┘ ╎ ┗╍╍┛ ┋  ▁▂▃▄▅▆▇█
                                               ▝▀▘▙▄▟

Surrogates:

𠜎 𠜱 𠝹 𠱓 𠱸 𠲖 𠳏 𠳕 𠴕 𠵼 𠵿 𠸎 𠸏 𠹷 𠺝 𠺢 𠻗 𠻹 𠻺 𠼭 𠼮 𠽌 𠾴 𠾼 𠿪 𡁜 𡁯 𡁵 𡁶 𡁻 𡃁
𡃉 𡇙 𢃇 𢞵 𢫕 𢭃 𢯊 𢱑 𢱕 𢳂 𢴈 𢵌 𢵧 𢺳 𣲷 𤓓 𤶸 𤷪 𥄫 𦉘 𦟌 𦧲 𦧺 𧨾 𨅝 𨈇 𨋢 𨳊 𨳍 𨳒 𩶘
var tape = require("tape");

var utf8 = require("..");

var data = require("fs").readFileSync(require.resolve("./data/utf8.txt")),
    dataStr = data.toString("utf8");

tape.test("utf8", function(test) {

    test.test(test.name + " - length", function(test) {
        test.equal(utf8.length(""), 0, "should return a byte length of zero for an empty string");

        test.equal(utf8.length(dataStr), Buffer.byteLength(dataStr), "should return the same byte length as node buffers");

        test.end();
    });

    test.test(test.name + " - read", function(test) {
        var comp = utf8.read([], 0, 0);
        test.equal(comp, "", "should decode an empty buffer to an empty string");

        comp = utf8.read(data, 0, data.length);
        test.equal(comp, data.toString("utf8"), "should decode to the same byte data as node buffers");

        var longData = Buffer.concat([data, data, data, data]);
        comp = utf8.read(longData, 0, longData.length);
        test.equal(comp, longData.toString("utf8"), "should decode to the same byte data as node buffers (long)");

        var chunkData = new Buffer(data.toString("utf8").substring(0, 8192));
        comp = utf8.read(chunkData, 0, chunkData.length);
        test.equal(comp, chunkData.toString("utf8"), "should decode to the same byte data as node buffers (chunk size)");

        test.end();
    });

    test.test(test.name + " - write", function(test) {
        var buf = new Buffer(0);
        test.equal(utf8.write("", buf, 0), 0, "should encode an empty string to an empty buffer");

        var len = utf8.length(dataStr);
        buf = new Buffer(len);
        test.equal(utf8.write(dataStr, buf, 0), len, "should encode to exactly " + len + " bytes");

        test.equal(buf.length, data.length, "should encode to a buffer length equal to that of node buffers");

        for (var i = 0; i < buf.length; ++i) {
            if (buf[i] !== data[i]) {
                test.fail("should encode to the same buffer data as node buffers (offset " + i + ")");
                return;
            }
        }
        test.pass("should encode to the same buffer data as node buffers");

        test.end();
    });

});
const crypto = require('node:crypto');

// Refs: https://github.com/brix/crypto-js/issues/468#issuecomment-2060562277
function encryptAES(plainText, secret) {
  const salt = crypto.randomBytes(8);
  const password = Buffer.concat([Buffer.from(secret), salt]);
  const hash = [];
  let digest = password;
  for (let i = 0; i < 3; i++) {
    hash[i] = crypto.createHash('md5').update(digest).digest();
    digest = Buffer.concat([hash[i], password]);
  }
  const keyDerivation = Buffer.concat(hash);
  const key = keyDerivation.subarray(0, 32);
  const iv = keyDerivation.subarray(32);
  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
  return Buffer.concat([
    Buffer.from('Salted__', 'utf8'),
    salt,
    cipher.update(plainText),
    cipher.final()
  ]).toString('base64');
}

// Refs: https://github.com/brix/crypto-js/issues/468#issuecomment-1783351942
function decryptAES(encryptedText, secret) {
  // From https://gist.github.com/schakko/2628689?permalink_comment_id=3321113#gistcomment-3321113
  // From https://gist.github.com/chengen/450129cb95c7159cb05001cc6bdbf6a1
  const cypher = Buffer.from(encryptedText, 'base64');
  const salt = cypher.slice(8, 16);
  const password = Buffer.concat([Buffer.from(secret), salt]);
  const md5Hashes = [];
  let digest = password;
  for (let i = 0; i < 3; i++) {
    md5Hashes[i] = crypto.createHash('md5').update(digest).digest();
    digest = Buffer.concat([md5Hashes[i], password]);
  }
  const key = Buffer.concat([md5Hashes[0], md5Hashes[1]]);
  const iv = md5Hashes[2];
  const contents = cypher.slice(16);
  const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);

  return Buffer.concat([
    decipher.update(contents),
    decipher.final()
  ]).toString('utf8');
}

module.exports = {
  encryptAES,
  decryptAES,
};
MIT License

Copyright (c) 2024 Darshan Sen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
{
  "name": "@raisinten/aes-crypto-js",
  "version": "0.0.2",
  "description": "Lightweight and convenient AES encryption/decryption library to make it easier to migrate away from the deprecated crypto-js library",
  "main": "index.js",
  "scripts": {
    "test": "node --test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/RaisinTen/aes-crypto-js.git"
  },
  "keywords": [
    "aes",
    "crypto-js"
  ],
  "author": "Darshan Sen <raisinten@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/RaisinTen/aes-crypto-js/issues"
  },
  "homepage": "https://github.com/RaisinTen/aes-crypto-js#readme",
  "devDependencies": {
    "crypto-js": "^4.2.0"
  }
}
# aes-crypto-js

The `@raisinten/aes-crypto-js` library provides a lightweight and convenient AES encryption/decryption API to make it easier to migrate away from the [deprecated `crypto-js` library](https://github.com/brix/crypto-js).

## Usage

```js
const { encryptAES, decryptAES } = require('@raisinten/aes-crypto-js');

const plainText = 'Hello, world!';
const secret = 'umm, shhh ...';

const encrypted = encryptAES(plainText, secret);
console.log(encrypted);
// U2FsdGVkX18T+lGbQ19d5PT205PrfCiti+f8hlKr/9E=

const decrypted = decryptAES(encrypted, secret);
console.log(decrypted);
// Hello, world!
```

## API

### `encryptAES(plainText, secret)`

- `plainText` (**string**) - The string to be encrypted.
- `secret` (**string**) - The string to be used as the secret for the encryption.
- Returns **string** - The encrypted string in `base64` format.

Encrypts the plaintext using the secret.

### `decryptAES(encrypted, secret)`

- `encrypted` (**string**) - The string to be decrypted.
- `secret` (**string**) - The string to be used as the secret for the decryption.
- Returns **string** - The decrypted string.

Decrypts the encrypted string using the secret.

> [!NOTE]
> The only difference from the AES implementation in the `crypto-js` library is that if there is a lone surrogate in a string, the `crypto-js` library crashes whereas this library replaces it with `U+FFFD`.

## License

MIT
import { DsnComponents, DsnLike, SdkMetadata } from '@sentry/types';
/**
 * Stores details about a Sentry SDK
 */
export interface APIDetails {
    /** The DSN as passed to Sentry.init() */
    initDsn: DsnLike;
    /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */
    metadata: SdkMetadata;
    /** The internally used Dsn object. */
    readonly dsn: DsnComponents;
    /** The envelope tunnel to use. */
    readonly tunnel?: string;
}
/**
 * Helper class to provide urls, headers and metadata that can be used to form
 * different types of requests to Sentry endpoints.
 * Supports both envelopes and regular event requests.
 *
 * @deprecated Please use APIDetails
 **/
export declare class API {
    /** The DSN as passed to Sentry.init() */
    dsn: DsnLike;
    /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */
    metadata: SdkMetadata;
    /** The internally used Dsn object. */
    private readonly _dsnObject;
    /** The envelope tunnel to use. */
    private readonly _tunnel?;
    /** Create a new instance of API */
    constructor(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string);
    /** Returns the Dsn object. */
    getDsn(): DsnComponents;
    /** Does this transport force envelopes? */
    forceEnvelope(): boolean;
    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    getBaseApiEndpoint(): string;
    /** Returns the store endpoint URL. */
    getStoreEndpoint(): string;
    /**
     * Returns the store endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    getStoreEndpointWithUrlEncodedAuth(): string;
    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    getEnvelopeEndpointWithUrlEncodedAuth(): string;
}
/** Initializes API Details */
export declare function initAPIDetails(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string): APIDetails;
/**
 * Returns the store endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export declare function getStoreEndpointWithUrlEncodedAuth(dsn: DsnComponents): string;
/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export declare function getEnvelopeEndpointWithUrlEncodedAuth(dsn: DsnComponents, tunnel?: string): string;
/**
 * Returns an object that can be used in request headers.
 * This is needed for node and the old /store endpoint in sentry
 */
export declare function getRequestHeaders(dsn: DsnComponents, clientName: string, clientVersion: string): {
    [key: string]: string;
};
/** Returns the url to the report dialog endpoint. */
export declare function getReportDialogEndpoint(dsnLike: DsnLike, dialogOptions: {
    [key: string]: any;
    user?: {
        name?: string;
        email?: string;
    };
}): string;
//# sourceMappingURL=api.d.ts.map{"version":3,"file":"api.d.ts","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAKpE;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB,yCAAyC;IACzC,OAAO,EAAE,OAAO,CAAC;IACjB,oFAAoF;IACpF,QAAQ,EAAE,WAAW,CAAC;IACtB,sCAAsC;IACtC,QAAQ,CAAC,GAAG,EAAE,aAAa,CAAC;IAC5B,kCAAkC;IAClC,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC;CAC1B;AAED;;;;;;IAMI;AACJ,qBAAa,GAAG;IACd,yCAAyC;IAClC,GAAG,EAAE,OAAO,CAAC;IAEpB,oFAAoF;IAC7E,QAAQ,EAAE,WAAW,CAAC;IAE7B,sCAAsC;IACtC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAgB;IAE3C,kCAAkC;IAClC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAS;IAElC,mCAAmC;gBAChB,GAAG,EAAE,OAAO,EAAE,QAAQ,GAAE,WAAgB,EAAE,MAAM,CAAC,EAAE,MAAM;IAO5E,8BAA8B;IACvB,MAAM,IAAI,aAAa;IAI9B,2CAA2C;IACpC,aAAa,IAAI,OAAO;IAI/B,sEAAsE;IAC/D,kBAAkB,IAAI,MAAM;IAInC,sCAAsC;IAC/B,gBAAgB,IAAI,MAAM;IAIjC;;;;OAIG;IACI,kCAAkC,IAAI,MAAM;IAInD;;;;OAIG;IACI,qCAAqC,IAAI,MAAM;CAGvD;AAED,8BAA8B;AAC9B,wBAAgB,cAAc,CAAC,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,WAAW,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,UAAU,CAOhG;AA6BD;;;;GAIG;AACH,wBAAgB,kCAAkC,CAAC,GAAG,EAAE,aAAa,GAAG,MAAM,CAE7E;AAOD;;;;GAIG;AACH,wBAAgB,qCAAqC,CAAC,GAAG,EAAE,aAAa,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,MAAM,CAEjG;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAC/B,GAAG,EAAE,aAAa,EAClB,UAAU,EAAE,MAAM,EAClB,aAAa,EAAE,MAAM,GACpB;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;CAAE,CAY3B;AAED,qDAAqD;AACrD,wBAAgB,uBAAuB,CACrC,OAAO,EAAE,OAAO,EAChB,aAAa,EAAE;IAEb,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAE,CAAC;CAC1C,GACA,MAAM,CA0BR"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
var SENTRY_API_VERSION = '7';
/**
 * Helper class to provide urls, headers and metadata that can be used to form
 * different types of requests to Sentry endpoints.
 * Supports both envelopes and regular event requests.
 *
 * @deprecated Please use APIDetails
 **/
var API = /** @class */ (function () {
    /** Create a new instance of API */
    function API(dsn, metadata, tunnel) {
        if (metadata === void 0) { metadata = {}; }
        this.dsn = dsn;
        this._dsnObject = utils_1.makeDsn(dsn);
        this.metadata = metadata;
        this._tunnel = tunnel;
    }
    /** Returns the Dsn object. */
    API.prototype.getDsn = function () {
        return this._dsnObject;
    };
    /** Does this transport force envelopes? */
    API.prototype.forceEnvelope = function () {
        return !!this._tunnel;
    };
    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    API.prototype.getBaseApiEndpoint = function () {
        return getBaseApiEndpoint(this._dsnObject);
    };
    /** Returns the store endpoint URL. */
    API.prototype.getStoreEndpoint = function () {
        return getStoreEndpoint(this._dsnObject);
    };
    /**
     * Returns the store endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    API.prototype.getStoreEndpointWithUrlEncodedAuth = function () {
        return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
    };
    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    API.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function () {
        return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
    };
    return API;
}());
exports.API = API;
/** Initializes API Details */
function initAPIDetails(dsn, metadata, tunnel) {
    return {
        initDsn: dsn,
        metadata: metadata || {},
        dsn: utils_1.makeDsn(dsn),
        tunnel: tunnel,
    };
}
exports.initAPIDetails = initAPIDetails;
/** Returns the prefix to construct Sentry ingestion API endpoints. */
function getBaseApiEndpoint(dsn) {
    var protocol = dsn.protocol ? dsn.protocol + ":" : '';
    var port = dsn.port ? ":" + dsn.port : '';
    return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : '') + "/api/";
}
/** Returns the ingest API endpoint for target. */
function _getIngestEndpoint(dsn, target) {
    return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
}
/** Returns a URL-encoded string with auth config suitable for a query string. */
function _encodedAuth(dsn) {
    return utils_1.urlEncode({
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION,
    });
}
/** Returns the store endpoint URL. */
function getStoreEndpoint(dsn) {
    return _getIngestEndpoint(dsn, 'store');
}
/**
 * Returns the store endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
function getStoreEndpointWithUrlEncodedAuth(dsn) {
    return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
}
exports.getStoreEndpointWithUrlEncodedAuth = getStoreEndpointWithUrlEncodedAuth;
/** Returns the envelope endpoint URL. */
function _getEnvelopeEndpoint(dsn) {
    return _getIngestEndpoint(dsn, 'envelope');
}
/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
    return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
}
exports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;
/**
 * Returns an object that can be used in request headers.
 * This is needed for node and the old /store endpoint in sentry
 */
function getRequestHeaders(dsn, clientName, clientVersion) {
    // CHANGE THIS to use metadata but keep clientName and clientVersion compatible
    var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
    header.push("sentry_client=" + clientName + "/" + clientVersion);
    header.push("sentry_key=" + dsn.publicKey);
    if (dsn.pass) {
        header.push("sentry_secret=" + dsn.pass);
    }
    return {
        'Content-Type': 'application/json',
        'X-Sentry-Auth': header.join(', '),
    };
}
exports.getRequestHeaders = getRequestHeaders;
/** Returns the url to the report dialog endpoint. */
function getReportDialogEndpoint(dsnLike, dialogOptions) {
    var dsn = utils_1.makeDsn(dsnLike);
    var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
    var encodedOptions = "dsn=" + utils_1.dsnToString(dsn);
    for (var key in dialogOptions) {
        if (key === 'dsn') {
            continue;
        }
        if (key === 'user') {
            if (!dialogOptions.user) {
                continue;
            }
            if (dialogOptions.user.name) {
                encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
            }
            if (dialogOptions.user.email) {
                encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
            }
        }
        else {
            encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
        }
    }
    return endpoint + "?" + encodedOptions;
}
exports.getReportDialogEndpoint = getReportDialogEndpoint;
//# sourceMappingURL=api.js.map{"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"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","sourcesContent":["import { DsnComponents, DsnLike, SdkMetadata } from '@sentry/types';\nimport { dsnToString, makeDsn, urlEncode } from '@sentry/utils';\n\nconst SENTRY_API_VERSION = '7';\n\n/**\n * Stores details about a Sentry SDK\n */\nexport interface APIDetails {\n  /** The DSN as passed to Sentry.init() */\n  initDsn: DsnLike;\n  /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */\n  metadata: SdkMetadata;\n  /** The internally used Dsn object. */\n  readonly dsn: DsnComponents;\n  /** The envelope tunnel to use. */\n  readonly tunnel?: string;\n}\n\n/**\n * Helper class to provide urls, headers and metadata that can be used to form\n * different types of requests to Sentry endpoints.\n * Supports both envelopes and regular event requests.\n *\n * @deprecated Please use APIDetails\n **/\nexport class API {\n  /** The DSN as passed to Sentry.init() */\n  public dsn: DsnLike;\n\n  /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */\n  public metadata: SdkMetadata;\n\n  /** The internally used Dsn object. */\n  private readonly _dsnObject: DsnComponents;\n\n  /** The envelope tunnel to use. */\n  private readonly _tunnel?: string;\n\n  /** Create a new instance of API */\n  public constructor(dsn: DsnLike, metadata: SdkMetadata = {}, tunnel?: string) {\n    this.dsn = dsn;\n    this._dsnObject = makeDsn(dsn);\n    this.metadata = metadata;\n    this._tunnel = tunnel;\n  }\n\n  /** Returns the Dsn object. */\n  public getDsn(): DsnComponents {\n    return this._dsnObject;\n  }\n\n  /** Does this transport force envelopes? */\n  public forceEnvelope(): boolean {\n    return !!this._tunnel;\n  }\n\n  /** Returns the prefix to construct Sentry ingestion API endpoints. */\n  public getBaseApiEndpoint(): string {\n    return getBaseApiEndpoint(this._dsnObject);\n  }\n\n  /** Returns the store endpoint URL. */\n  public getStoreEndpoint(): string {\n    return getStoreEndpoint(this._dsnObject);\n  }\n\n  /**\n   * Returns the store endpoint URL with auth in the query string.\n   *\n   * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n   */\n  public getStoreEndpointWithUrlEncodedAuth(): string {\n    return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);\n  }\n\n  /**\n   * Returns the envelope endpoint URL with auth in the query string.\n   *\n   * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n   */\n  public getEnvelopeEndpointWithUrlEncodedAuth(): string {\n    return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);\n  }\n}\n\n/** Initializes API Details */\nexport function initAPIDetails(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string): APIDetails {\n  return {\n    initDsn: dsn,\n    metadata: metadata || {},\n    dsn: makeDsn(dsn),\n    tunnel,\n  } as APIDetails;\n}\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn: DsnComponents): string {\n  const protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  const port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn: DsnComponents, target: 'store' | 'envelope'): string {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/${target}/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn: DsnComponents): string {\n  return urlEncode({\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    sentry_key: dsn.publicKey,\n    sentry_version: SENTRY_API_VERSION,\n  });\n}\n\n/** Returns the store endpoint URL. */\nfunction getStoreEndpoint(dsn: DsnComponents): string {\n  return _getIngestEndpoint(dsn, 'store');\n}\n\n/**\n * Returns the store endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nexport function getStoreEndpointWithUrlEncodedAuth(dsn: DsnComponents): string {\n  return `${getStoreEndpoint(dsn)}?${_encodedAuth(dsn)}`;\n}\n\n/** Returns the envelope endpoint URL. */\nfunction _getEnvelopeEndpoint(dsn: DsnComponents): string {\n  return _getIngestEndpoint(dsn, 'envelope');\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nexport function getEnvelopeEndpointWithUrlEncodedAuth(dsn: DsnComponents, tunnel?: string): string {\n  return tunnel ? tunnel : `${_getEnvelopeEndpoint(dsn)}?${_encodedAuth(dsn)}`;\n}\n\n/**\n * Returns an object that can be used in request headers.\n * This is needed for node and the old /store endpoint in sentry\n */\nexport function getRequestHeaders(\n  dsn: DsnComponents,\n  clientName: string,\n  clientVersion: string,\n): { [key: string]: string } {\n  // CHANGE THIS to use metadata but keep clientName and clientVersion compatible\n  const header = [`Sentry sentry_version=${SENTRY_API_VERSION}`];\n  header.push(`sentry_client=${clientName}/${clientVersion}`);\n  header.push(`sentry_key=${dsn.publicKey}`);\n  if (dsn.pass) {\n    header.push(`sentry_secret=${dsn.pass}`);\n  }\n  return {\n    'Content-Type': 'application/json',\n    'X-Sentry-Auth': header.join(', '),\n  };\n}\n\n/** Returns the url to the report dialog endpoint. */\nexport function getReportDialogEndpoint(\n  dsnLike: DsnLike,\n  dialogOptions: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any;\n    user?: { name?: string; email?: string };\n  },\n): string {\n  const dsn = makeDsn(dsnLike);\n  const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsnToString(dsn)}`;\n  for (const key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'user') {\n      if (!dialogOptions.user) {\n        continue;\n      }\n      if (dialogOptions.user.name) {\n        encodedOptions += `&name=${encodeURIComponent(dialogOptions.user.name)}`;\n      }\n      if (dialogOptions.user.email) {\n        encodedOptions += `&email=${encodeURIComponent(dialogOptions.user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] as string)}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n"]}import { Event, EventHint, Options, Session, Severity, Transport } from '@sentry/types';
import { NewTransport } from './transports/base';
/**
 * Internal platform-dependent Sentry SDK Backend.
 *
 * While {@link Client} contains business logic specific to an SDK, the
 * Backend offers platform specific implementations for low-level operations.
 * These are persisting and loading information, sending events, and hooking
 * into the environment.
 *
 * Backends receive a handle to the Client in their constructor. When a
 * Backend automatically generates events, it must pass them to
 * the Client for validation and processing first.
 *
 * Usually, the Client will be of corresponding type, e.g. NodeBackend
 * receives NodeClient. However, higher-level SDKs can choose to instantiate
 * multiple Backends and delegate tasks between them. In this case, an event
 * generated by one backend might very well be sent by another one.
 *
 * The client also provides access to options via {@link Client.getOptions}.
 * @hidden
 */
export interface Backend {
    /** Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`. */
    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;
    /** Creates an {@link Event} from primitive inputs to `captureMessage`. */
    eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;
    /** Submits the event to Sentry */
    sendEvent(event: Event): void;
    /** Submits the session to Sentry */
    sendSession(session: Session): void;
    /**
     * Returns the transport that is used by the backend.
     * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
     *
     * @returns The transport.
     */
    getTransport(): Transport;
}
/**
 * A class object that can instantiate Backend objects.
 * @hidden
 */
export declare type BackendClass<B extends Backend, O extends Options> = new (options: O) => B;
/**
 * This is the base implemention of a Backend.
 * @hidden
 */
export declare abstract class BaseBackend<O extends Options> implements Backend {
    /** Options passed to the SDK. */
    protected readonly _options: O;
    /** Cached transport used internally. */
    protected _transport: Transport;
    /** New v7 Transport that is initialized alongside the old one */
    protected _newTransport?: NewTransport;
    /** Creates a new backend instance. */
    constructor(options: O);
    /**
     * @inheritDoc
     */
    eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    eventFromMessage(_message: string, _level?: Severity, _hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): void;
    /**
     * @inheritDoc
     */
    sendSession(session: Session): void;
    /**
     * @inheritDoc
     */
    getTransport(): Transport;
    /**
     * Sets up the transport so it can be used later to send requests.
     */
    protected _setupTransport(): Transport;
}
//# sourceMappingURL=basebackend.d.ts.map{"version":3,"file":"basebackend.d.ts","sourceRoot":"","sources":["../../src/basebackend.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAMxF,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAGjD;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,WAAW,OAAO;IACtB,mHAAmH;IAEnH,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;IAEzE,0EAA0E;IAC1E,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;IAE1F,kCAAkC;IAClC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;IAE9B,oCAAoC;IACpC,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC;IAEpC;;;;;OAKG;IACH,YAAY,IAAI,SAAS,CAAC;CAC3B;AAED;;;GAGG;AACH,oBAAY,YAAY,CAAC,CAAC,SAAS,OAAO,EAAE,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAEvF;;;GAGG;AACH,8BAAsB,WAAW,CAAC,CAAC,SAAS,OAAO,CAAE,YAAW,OAAO;IACrE,iCAAiC;IACjC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,wCAAwC;IACxC,SAAS,CAAC,UAAU,EAAE,SAAS,CAAC;IAEhC,iEAAiE;IACjE,SAAS,CAAC,aAAa,CAAC,EAAE,YAAY,CAAC;IAEvC,sCAAsC;gBACnB,OAAO,EAAE,CAAC;IAQ7B;;OAEG;IAEI,kBAAkB,CAAC,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAIjF;;OAEG;IACI,gBAAgB,CAAC,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAInG;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAoBpC;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAyB1C;;OAEG;IACI,YAAY,IAAI,SAAS;IAIhC;;OAEG;IACH,SAAS,CAAC,eAAe,IAAI,SAAS;CAGvC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
var api_1 = require("./api");
var flags_1 = require("./flags");
var request_1 = require("./request");
var noop_1 = require("./transports/noop");
/**
 * This is the base implemention of a Backend.
 * @hidden
 */
var BaseBackend = /** @class */ (function () {
    /** Creates a new backend instance. */
    function BaseBackend(options) {
        this._options = options;
        if (!this._options.dsn) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('No DSN provided, backend will not do anything.');
        }
        this._transport = this._setupTransport();
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    BaseBackend.prototype.eventFromException = function (_exception, _hint) {
        throw new utils_1.SentryError('Backend has to implement `eventFromException` method');
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.eventFromMessage = function (_message, _level, _hint) {
        throw new utils_1.SentryError('Backend has to implement `eventFromMessage` method');
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.sendEvent = function (event) {
        // TODO(v7): Remove the if-else
        if (this._newTransport &&
            this._options.dsn &&
            this._options._experiments &&
            this._options._experiments.newTransport) {
            var api = api_1.initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
            var env = request_1.createEventEnvelope(event, api);
            void this._newTransport.send(env).then(null, function (reason) {
                flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending event:', reason);
            });
        }
        else {
            void this._transport.sendEvent(event).then(null, function (reason) {
                flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending event:', reason);
            });
        }
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.sendSession = function (session) {
        if (!this._transport.sendSession) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
            return;
        }
        // TODO(v7): Remove the if-else
        if (this._newTransport &&
            this._options.dsn &&
            this._options._experiments &&
            this._options._experiments.newTransport) {
            var api = api_1.initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
            var _a = tslib_1.__read(request_1.createSessionEnvelope(session, api), 1), env = _a[0];
            void this._newTransport.send(env).then(null, function (reason) {
                flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
            });
        }
        else {
            void this._transport.sendSession(session).then(null, function (reason) {
                flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
            });
        }
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.getTransport = function () {
        return this._transport;
    };
    /**
     * Sets up the transport so it can be used later to send requests.
     */
    BaseBackend.prototype._setupTransport = function () {
        return new noop_1.NoopTransport();
    };
    return BaseBackend;
}());
exports.BaseBackend = BaseBackend;
//# sourceMappingURL=basebackend.js.map{"version":3,"file":"basebackend.js","sourceRoot":"","sources":["../../src/basebackend.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventHint, Options, Session, Severity, Transport } from '@sentry/types';\nimport { logger, SentryError } from '@sentry/utils';\n\nimport { initAPIDetails } from './api';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { createEventEnvelope, createSessionEnvelope } from './request';\nimport { NewTransport } from './transports/base';\nimport { NoopTransport } from './transports/noop';\n\n/**\n * Internal platform-dependent Sentry SDK Backend.\n *\n * While {@link Client} contains business logic specific to an SDK, the\n * Backend offers platform specific implementations for low-level operations.\n * These are persisting and loading information, sending events, and hooking\n * into the environment.\n *\n * Backends receive a handle to the Client in their constructor. When a\n * Backend automatically generates events, it must pass them to\n * the Client for validation and processing first.\n *\n * Usually, the Client will be of corresponding type, e.g. NodeBackend\n * receives NodeClient. However, higher-level SDKs can choose to instantiate\n * multiple Backends and delegate tasks between them. In this case, an event\n * generated by one backend might very well be sent by another one.\n *\n * The client also provides access to options via {@link Client.getOptions}.\n * @hidden\n */\nexport interface Backend {\n  /** Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;\n\n  /** Creates an {@link Event} from primitive inputs to `captureMessage`. */\n  eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;\n\n  /** Submits the event to Sentry */\n  sendEvent(event: Event): void;\n\n  /** Submits the session to Sentry */\n  sendSession(session: Session): void;\n\n  /**\n   * Returns the transport that is used by the backend.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   *\n   * @returns The transport.\n   */\n  getTransport(): Transport;\n}\n\n/**\n * A class object that can instantiate Backend objects.\n * @hidden\n */\nexport type BackendClass<B extends Backend, O extends Options> = new (options: O) => B;\n\n/**\n * This is the base implemention of a Backend.\n * @hidden\n */\nexport abstract class BaseBackend<O extends Options> implements Backend {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** Cached transport used internally. */\n  protected _transport: Transport;\n\n  /** New v7 Transport that is initialized alongside the old one */\n  protected _newTransport?: NewTransport;\n\n  /** Creates a new backend instance. */\n  public constructor(options: O) {\n    this._options = options;\n    if (!this._options.dsn) {\n      IS_DEBUG_BUILD && logger.warn('No DSN provided, backend will not do anything.');\n    }\n    this._transport = this._setupTransport();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event> {\n    throw new SentryError('Backend has to implement `eventFromException` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(_message: string, _level?: Severity, _hint?: EventHint): PromiseLike<Event> {\n    throw new SentryError('Backend has to implement `eventFromMessage` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): void {\n    // TODO(v7): Remove the if-else\n    if (\n      this._newTransport &&\n      this._options.dsn &&\n      this._options._experiments &&\n      this._options._experiments.newTransport\n    ) {\n      const api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);\n      const env = createEventEnvelope(event, api);\n      void this._newTransport.send(env).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      void this._transport.sendEvent(event).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): void {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n\n    // TODO(v7): Remove the if-else\n    if (\n      this._newTransport &&\n      this._options.dsn &&\n      this._options._experiments &&\n      this._options._experiments.newTransport\n    ) {\n      const api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);\n      const [env] = createSessionEnvelope(session, api);\n      void this._newTransport.send(env).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n      });\n    } else {\n      void this._transport.sendSession(session).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport {\n    return this._transport;\n  }\n\n  /**\n   * Sets up the transport so it can be used later to send requests.\n   */\n  protected _setupTransport(): Transport {\n    return new NoopTransport();\n  }\n}\n"]}import { Scope, Session } from '@sentry/hub';
import { Client, DsnComponents, Event, EventHint, Integration, IntegrationClass, Options, Severity, Transport } from '@sentry/types';
import { Backend, BackendClass } from './basebackend';
import { IntegrationIndex } from './integration';
/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding backend constructor and options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}. Also, the Backend instance is available via
 * {@link Client.getBackend}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event via the backend, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(NodeBackend, options);
 *   }
 *
 *   // ...
 * }
 */
export declare abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {
    /**
     * The backend used to physically interact in the environment. Usually, this
     * will correspond to the client. When composing SDKs, however, the Backend
     * from the root SDK will be used.
     */
    protected readonly _backend: B;
    /** Options passed to the SDK. */
    protected readonly _options: O;
    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
    protected readonly _dsn?: DsnComponents;
    /** Array of used integrations. */
    protected _integrations: IntegrationIndex;
    /** Number of calls being processed */
    protected _numProcessing: number;
    /**
     * Initializes this client instance.
     *
     * @param backendClass A constructor function to create the backend.
     * @param options Options for the client.
     */
    protected constructor(backendClass: BackendClass<B, O>, options: O);
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureSession(session: Session): void;
    /**
     * @inheritDoc
     */
    getDsn(): DsnComponents | undefined;
    /**
     * @inheritDoc
     */
    getOptions(): O;
    /**
     * @inheritDoc
     */
    getTransport(): Transport;
    /**
     * @inheritDoc
     */
    flush(timeout?: number): PromiseLike<boolean>;
    /**
     * @inheritDoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Sets up the integrations
     */
    setupIntegrations(): void;
    /**
     * @inheritDoc
     */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** Updates existing session based on the provided event */
    protected _updateSessionFromEvent(session: Session, event: Event): void;
    /** Deliver captured session to Sentry */
    protected _sendSession(session: Session): void;
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean>;
    /** Returns the current backend. */
    protected _getBackend(): B;
    /** Determines whether this SDK is enabled and a valid Dsn is present. */
    protected _isEnabled(): boolean;
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
     * Normalized keys:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * @param event Event
     * @returns Normalized event
     */
    protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null;
    /**
     *  Enhances event using the client configuration.
     *  It takes care of all "static" values like environment, release and `dist`,
     *  as well as truncating overly long values.
     * @param event event instance to be enhanced
     */
    protected _applyClientOptions(event: Event): void;
    /**
     * This function adds all used integrations to the SDK info in the event.
     * @param event The event that will be filled with all integrations.
     */
    protected _applyIntegrationsMetadata(event: Event): void;
    /**
     * Tells the backend to send this event
     * @param event The Sentry event to send
     */
    protected _sendEvent(event: Event): void;
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined>;
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event>;
    /**
     * Occupies the client with processing and event
     */
    protected _process<T>(promise: PromiseLike<T>): void;
}
//# sourceMappingURL=baseclient.d.ts.map{"version":3,"file":"baseclient.d.ts","sourceRoot":"","sources":["../../src/baseclient.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,EACL,MAAM,EACN,aAAa,EACb,KAAK,EACL,SAAS,EACT,WAAW,EACX,gBAAgB,EAChB,OAAO,EACP,QAAQ,EACR,SAAS,EACV,MAAM,eAAe,CAAC;AAkBvB,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAEtD,OAAO,EAAE,gBAAgB,EAAqB,MAAM,eAAe,CAAC;AAIpE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,8BAAsB,UAAU,CAAC,CAAC,SAAS,OAAO,EAAE,CAAC,SAAS,OAAO,CAAE,YAAW,MAAM,CAAC,CAAC,CAAC;IACzF;;;;OAIG;IACH,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,iCAAiC;IACjC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,2FAA2F;IAC3F,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,aAAa,CAAC;IAExC,kCAAkC;IAClC,SAAS,CAAC,aAAa,EAAE,gBAAgB,CAAM;IAE/C,sCAAsC;IACtC,SAAS,CAAC,cAAc,EAAE,MAAM,CAAK;IAErC;;;;;OAKG;IACH,SAAS,aAAa,YAAY,EAAE,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC;IASlE;;OAEG;IAEI,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAqB5F;;OAEG;IACI,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAkB7G;;OAEG;IACI,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAkBtF;;OAEG;IACI,cAAc,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAe7C;;OAEG;IACI,MAAM,IAAI,aAAa,GAAG,SAAS;IAI1C;;OAEG;IACI,UAAU,IAAI,CAAC;IAItB;;OAEG;IACI,YAAY,IAAI,SAAS;IAIhC;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAQpD;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAOpD;;OAEG;IACI,iBAAiB,IAAI,IAAI;IAMhC;;OAEG;IACI,cAAc,CAAC,CAAC,SAAS,WAAW,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI;IASxF,2DAA2D;IAC3D,SAAS,CAAC,uBAAuB,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI;IAgCvE,yCAAyC;IACzC,SAAS,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAI9C;;;;;;;;;OASG;IACH,SAAS,CAAC,uBAAuB,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAoBzE,mCAAmC;IACnC,SAAS,CAAC,WAAW,IAAI,CAAC;IAI1B,yEAAyE;IACzE,SAAS,CAAC,UAAU,IAAI,OAAO;IAI/B;;;;;;;;;;;;;OAaG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IA4CjG;;;;;;;;;OASG;IACH,SAAS,CAAC,eAAe,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,GAAG,KAAK,GAAG,IAAI;IA0C/F;;;;;OAKG;IACH,SAAS,CAAC,mBAAmB,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IA+BjD;;;OAGG;IACH,SAAS,CAAC,0BAA0B,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAQxD;;;OAGG;IACH,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAIxC;;;;;OAKG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,MAAM,GAAG,SAAS,CAAC;IAYvG;;;;;;;;;;;;OAYG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;IA6E1F;;OAEG;IACH,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI;CAarD"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable max-lines */
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
var flags_1 = require("./flags");
var integration_1 = require("./integration");
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding backend constructor and options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}. Also, the Backend instance is available via
 * {@link Client.getBackend}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event via the backend, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(NodeBackend, options);
 *   }
 *
 *   // ...
 * }
 */
var BaseClient = /** @class */ (function () {
    /**
     * Initializes this client instance.
     *
     * @param backendClass A constructor function to create the backend.
     * @param options Options for the client.
     */
    function BaseClient(backendClass, options) {
        /** Array of used integrations. */
        this._integrations = {};
        /** Number of calls being processed */
        this._numProcessing = 0;
        this._backend = new backendClass(options);
        this._options = options;
        if (options.dsn) {
            this._dsn = utils_1.makeDsn(options.dsn);
        }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    BaseClient.prototype.captureException = function (exception, hint, scope) {
        var _this = this;
        // ensure we haven't captured this very object before
        if (utils_1.checkOrSetAlreadyCaught(exception)) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.log(ALREADY_SEEN_ERROR);
            return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._getBackend()
            .eventFromException(exception, hint)
            .then(function (event) { return _this._captureEvent(event, hint, scope); })
            .then(function (result) {
            eventId = result;
        }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.captureMessage = function (message, level, hint, scope) {
        var _this = this;
        var eventId = hint && hint.event_id;
        var promisedEvent = utils_1.isPrimitive(message)
            ? this._getBackend().eventFromMessage(String(message), level, hint)
            : this._getBackend().eventFromException(message, hint);
        this._process(promisedEvent
            .then(function (event) { return _this._captureEvent(event, hint, scope); })
            .then(function (result) {
            eventId = result;
        }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.captureEvent = function (event, hint, scope) {
        // ensure we haven't captured this very object before
        if (hint && hint.originalException && utils_1.checkOrSetAlreadyCaught(hint.originalException)) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.log(ALREADY_SEEN_ERROR);
            return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._captureEvent(event, hint, scope).then(function (result) {
            eventId = result;
        }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.captureSession = function (session) {
        if (!this._isEnabled()) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('SDK not enabled, will not capture session.');
            return;
        }
        if (!(typeof session.release === 'string')) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Discarded session because of missing or non-string release');
        }
        else {
            this._sendSession(session);
            // After sending, we set init false to indicate it's not the first occurrence
            session.update({ init: false });
        }
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getDsn = function () {
        return this._dsn;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getOptions = function () {
        return this._options;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getTransport = function () {
        return this._getBackend().getTransport();
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.flush = function (timeout) {
        var _this = this;
        return this._isClientDoneProcessing(timeout).then(function (clientFinished) {
            return _this.getTransport()
                .close(timeout)
                .then(function (transportFlushed) { return clientFinished && transportFlushed; });
        });
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.close = function (timeout) {
        var _this = this;
        return this.flush(timeout).then(function (result) {
            _this.getOptions().enabled = false;
            return result;
        });
    };
    /**
     * Sets up the integrations
     */
    BaseClient.prototype.setupIntegrations = function () {
        if (this._isEnabled() && !this._integrations.initialized) {
            this._integrations = integration_1.setupIntegrations(this._options);
        }
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getIntegration = function (integration) {
        try {
            return this._integrations[integration.id] || null;
        }
        catch (_oO) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
            return null;
        }
    };
    /** Updates existing session based on the provided event */
    BaseClient.prototype._updateSessionFromEvent = function (session, event) {
        var e_1, _a;
        var crashed = false;
        var errored = false;
        var exceptions = event.exception && event.exception.values;
        if (exceptions) {
            errored = true;
            try {
                for (var exceptions_1 = tslib_1.__values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
                    var ex = exceptions_1_1.value;
                    var mechanism = ex.mechanism;
                    if (mechanism && mechanism.handled === false) {
                        crashed = true;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // A session is updated and that session update is sent in only one of the two following scenarios:
        // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
        // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update
        var sessionNonTerminal = session.status === 'ok';
        var shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);
        if (shouldUpdateAndSend) {
            session.update(tslib_1.__assign(tslib_1.__assign({}, (crashed && { status: 'crashed' })), { errors: session.errors || Number(errored || crashed) }));
            this.captureSession(session);
        }
    };
    /** Deliver captured session to Sentry */
    BaseClient.prototype._sendSession = function (session) {
        this._getBackend().sendSession(session);
    };
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    BaseClient.prototype._isClientDoneProcessing = function (timeout) {
        var _this = this;
        return new utils_1.SyncPromise(function (resolve) {
            var ticked = 0;
            var tick = 1;
            var interval = setInterval(function () {
                if (_this._numProcessing == 0) {
                    clearInterval(interval);
                    resolve(true);
                }
                else {
                    ticked += tick;
                    if (timeout && ticked >= timeout) {
                        clearInterval(interval);
                        resolve(false);
                    }
                }
            }, tick);
        });
    };
    /** Returns the current backend. */
    BaseClient.prototype._getBackend = function () {
        return this._backend;
    };
    /** Determines whether this SDK is enabled and a valid Dsn is present. */
    BaseClient.prototype._isEnabled = function () {
        return this.getOptions().enabled !== false && this._dsn !== undefined;
    };
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    BaseClient.prototype._prepareEvent = function (event, scope, hint) {
        var _this = this;
        var _a = this.getOptions(), _b = _a.normalizeDepth, normalizeDepth = _b === void 0 ? 3 : _b, _c = _a.normalizeMaxBreadth, normalizeMaxBreadth = _c === void 0 ? 1000 : _c;
        var prepared = tslib_1.__assign(tslib_1.__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : utils_1.uuid4()), timestamp: event.timestamp || utils_1.dateTimestampInSeconds() });
        this._applyClientOptions(prepared);
        this._applyIntegrationsMetadata(prepared);
        // If we have scope given to us, use it as the base for further modifications.
        // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
        var finalScope = scope;
        if (hint && hint.captureContext) {
            finalScope = hub_1.Scope.clone(finalScope).update(hint.captureContext);
        }
        // We prepare the result here with a resolved Event.
        var result = utils_1.resolvedSyncPromise(prepared);
        // This should be the last thing called, since we want that
        // {@link Hub.addEventProcessor} gets the finished prepared event.
        if (finalScope) {
            // In case we have a hub we reassign it.
            result = finalScope.applyToEvent(prepared, hint);
        }
        return result.then(function (evt) {
            if (evt) {
                // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809
                // it is only attached as extra data to the event if the event somehow skips being normalized
                evt.sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, evt.sdkProcessingMetadata), { normalizeDepth: utils_1.normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")" });
            }
            if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
                return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
            }
            return evt;
        });
    };
    /**
     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
     * Normalized keys:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * @param event Event
     * @returns Normalized event
     */
    BaseClient.prototype._normalizeEvent = function (event, depth, maxBreadth) {
        if (!event) {
            return null;
        }
        var normalized = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, event), (event.breadcrumbs && {
            breadcrumbs: event.breadcrumbs.map(function (b) { return (tslib_1.__assign(tslib_1.__assign({}, b), (b.data && {
                data: utils_1.normalize(b.data, depth, maxBreadth),
            }))); }),
        })), (event.user && {
            user: utils_1.normalize(event.user, depth, maxBreadth),
        })), (event.contexts && {
            contexts: utils_1.normalize(event.contexts, depth, maxBreadth),
        })), (event.extra && {
            extra: utils_1.normalize(event.extra, depth, maxBreadth),
        }));
        // event.contexts.trace stores information about a Transaction. Similarly,
        // event.spans[] stores information about child Spans. Given that a
        // Transaction is conceptually a Span, normalization should apply to both
        // Transactions and Spans consistently.
        // For now the decision is to skip normalization of Transactions and Spans,
        // so this block overwrites the normalized event to add back the original
        // Transaction information prior to normalization.
        if (event.contexts && event.contexts.trace) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            normalized.contexts.trace = event.contexts.trace;
        }
        normalized.sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, normalized.sdkProcessingMetadata), { baseClientNormalized: true });
        return normalized;
    };
    /**
     *  Enhances event using the client configuration.
     *  It takes care of all "static" values like environment, release and `dist`,
     *  as well as truncating overly long values.
     * @param event event instance to be enhanced
     */
    BaseClient.prototype._applyClientOptions = function (event) {
        var options = this.getOptions();
        var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
        if (!('environment' in event)) {
            event.environment = 'environment' in options ? environment : 'production';
        }
        if (event.release === undefined && release !== undefined) {
            event.release = release;
        }
        if (event.dist === undefined && dist !== undefined) {
            event.dist = dist;
        }
        if (event.message) {
            event.message = utils_1.truncate(event.message, maxValueLength);
        }
        var exception = event.exception && event.exception.values && event.exception.values[0];
        if (exception && exception.value) {
            exception.value = utils_1.truncate(exception.value, maxValueLength);
        }
        var request = event.request;
        if (request && request.url) {
            request.url = utils_1.truncate(request.url, maxValueLength);
        }
    };
    /**
     * This function adds all used integrations to the SDK info in the event.
     * @param event The event that will be filled with all integrations.
     */
    BaseClient.prototype._applyIntegrationsMetadata = function (event) {
        var integrationsArray = Object.keys(this._integrations);
        if (integrationsArray.length > 0) {
            event.sdk = event.sdk || {};
            event.sdk.integrations = tslib_1.__spread((event.sdk.integrations || []), integrationsArray);
        }
    };
    /**
     * Tells the backend to send this event
     * @param event The Sentry event to send
     */
    BaseClient.prototype._sendEvent = function (event) {
        this._getBackend().sendEvent(event);
    };
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    BaseClient.prototype._captureEvent = function (event, hint, scope) {
        return this._processEvent(event, hint, scope).then(function (finalEvent) {
            return finalEvent.event_id;
        }, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error(reason);
            return undefined;
        });
    };
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    BaseClient.prototype._processEvent = function (event, hint, scope) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
        var transport = this.getTransport();
        function recordLostEvent(outcome, category) {
            if (transport.recordLostEvent) {
                transport.recordLostEvent(outcome, category);
            }
        }
        if (!this._isEnabled()) {
            return utils_1.rejectedSyncPromise(new utils_1.SentryError('SDK not enabled, will not capture event.'));
        }
        var isTransaction = event.type === 'transaction';
        // 1.0 === 100% events are sent
        // 0.0 === 0% events are sent
        // Sampling for transaction happens somewhere else
        if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
            recordLostEvent('sample_rate', 'event');
            return utils_1.rejectedSyncPromise(new utils_1.SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
        }
        return this._prepareEvent(event, scope, hint)
            .then(function (prepared) {
            if (prepared === null) {
                recordLostEvent('event_processor', event.type || 'event');
                throw new utils_1.SentryError('An event processor returned null, will not send event.');
            }
            var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
            if (isInternalException || isTransaction || !beforeSend) {
                return prepared;
            }
            var beforeSendResult = beforeSend(prepared, hint);
            return _ensureBeforeSendRv(beforeSendResult);
        })
            .then(function (processedEvent) {
            if (processedEvent === null) {
                recordLostEvent('before_send', event.type || 'event');
                throw new utils_1.SentryError('`beforeSend` returned `null`, will not send event.');
            }
            var session = scope && scope.getSession && scope.getSession();
            if (!isTransaction && session) {
                _this._updateSessionFromEvent(session, processedEvent);
            }
            _this._sendEvent(processedEvent);
            return processedEvent;
        })
            .then(null, function (reason) {
            if (reason instanceof utils_1.SentryError) {
                throw reason;
            }
            _this.captureException(reason, {
                data: {
                    __sentry__: true,
                },
                originalException: reason,
            });
            throw new utils_1.SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
        });
    };
    /**
     * Occupies the client with processing and event
     */
    BaseClient.prototype._process = function (promise) {
        var _this = this;
        this._numProcessing += 1;
        void promise.then(function (value) {
            _this._numProcessing -= 1;
            return value;
        }, function (reason) {
            _this._numProcessing -= 1;
            return reason;
        });
    };
    return BaseClient;
}());
exports.BaseClient = BaseClient;
/**
 * Verifies that return value of configured `beforeSend` is of expected type.
 */
function _ensureBeforeSendRv(rv) {
    var nullErr = '`beforeSend` method has to return `null` or a valid event.';
    if (utils_1.isThenable(rv)) {
        return rv.then(function (event) {
            if (!(utils_1.isPlainObject(event) || event === null)) {
                throw new utils_1.SentryError(nullErr);
            }
            return event;
        }, function (e) {
            throw new utils_1.SentryError("beforeSend rejected with " + e);
        });
    }
    else if (!(utils_1.isPlainObject(rv) || rv === null)) {
        throw new utils_1.SentryError(nullErr);
    }
    return rv;
}
//# sourceMappingURL=baseclient.js.map{"version":3,"file":"baseclient.js","sourceRoot":"","sources":["../../src/baseclient.ts"],"names":[],"mappings":";;AAAA,8BAA8B;AAC9B,mCAA6C;AAY7C,uCAeuB;AAGvB,iCAAyC;AACzC,6CAAoE;AAEpE,IAAM,kBAAkB,GAAG,6DAA6D,CAAC;AAEzF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH;IAoBE;;;;;OAKG;IACH,oBAAsB,YAAgC,EAAE,OAAU;QAZlE,kCAAkC;QACxB,kBAAa,GAAqB,EAAE,CAAC;QAE/C,sCAAsC;QAC5B,mBAAc,GAAW,CAAC,CAAC;QASnC,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC;QAC1C,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,IAAI,OAAO,CAAC,GAAG,EAAE;YACf,IAAI,CAAC,IAAI,GAAG,eAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SAClC;IACH,CAAC;IAED;;OAEG;IACH,iHAAiH;IAC1G,qCAAgB,GAAvB,UAAwB,SAAc,EAAE,IAAgB,EAAE,KAAa;QAAvE,iBAmBC;QAlBC,qDAAqD;QACrD,IAAI,+BAAuB,CAAC,SAAS,CAAC,EAAE;YACtC,sBAAc,IAAI,cAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;YACjD,OAAO;SACR;QAED,IAAI,OAAO,GAAuB,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC;QAExD,IAAI,CAAC,QAAQ,CACX,IAAI,CAAC,WAAW,EAAE;aACf,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC;aACnC,IAAI,CAAC,UAAA,KAAK,IAAI,OAAA,KAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,EAAtC,CAAsC,CAAC;aACrD,IAAI,CAAC,UAAA,MAAM;YACV,OAAO,GAAG,MAAM,CAAC;QACnB,CAAC,CAAC,CACL,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;OAEG;IACI,mCAAc,GAArB,UAAsB,OAAe,EAAE,KAAgB,EAAE,IAAgB,EAAE,KAAa;QAAxF,iBAgBC;QAfC,IAAI,OAAO,GAAuB,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC;QAExD,IAAM,aAAa,GAAG,mBAAW,CAAC,OAAO,CAAC;YACxC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC;YACnE,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAEzD,IAAI,CAAC,QAAQ,CACX,aAAa;aACV,IAAI,CAAC,UAAA,KAAK,IAAI,OAAA,KAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,EAAtC,CAAsC,CAAC;aACrD,IAAI,CAAC,UAAA,MAAM;YACV,OAAO,GAAG,MAAM,CAAC;QACnB,CAAC,CAAC,CACL,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;OAEG;IACI,iCAAY,GAAnB,UAAoB,KAAY,EAAE,IAAgB,EAAE,KAAa;QAC/D,qDAAqD;QACrD,IAAI,IAAI,IAAI,IAAI,CAAC,iBAAiB,IAAI,+BAAuB,CAAC,IAAI,CAAC,iBAAiB,CAAC,EAAE;YACrF,sBAAc,IAAI,cAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;YACjD,OAAO;SACR;QAED,IAAI,OAAO,GAAuB,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC;QAExD,IAAI,CAAC,QAAQ,CACX,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,UAAA,MAAM;YAChD,OAAO,GAAG,MAAM,CAAC;QACnB,CAAC,CAAC,CACH,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;OAEG;IACI,mCAAc,GAArB,UAAsB,OAAgB;QACpC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;YACtB,sBAAc,IAAI,cAAM,CAAC,IAAI,CAAC,4CAA4C,CAAC,CAAC;YAC5E,OAAO;SACR;QAED,IAAI,CAAC,CAAC,OAAO,OAAO,CAAC,OAAO,KAAK,QAAQ,CAAC,EAAE;YAC1C,sBAAc,IAAI,cAAM,CAAC,IAAI,CAAC,4DAA4D,CAAC,CAAC;SAC7F;aAAM;YACL,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YAC3B,6EAA6E;YAC7E,OAAO,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;SACjC;IACH,CAAC;IAED;;OAEG;IACI,2BAAM,GAAb;QACE,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAED;;OAEG;IACI,+BAAU,GAAjB;QACE,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED;;OAEG;IACI,iCAAY,GAAnB;QACE,OAAO,IAAI,CAAC,WAAW,EAAE,CAAC,YAAY,EAAE,CAAC;IAC3C,CAAC;IAED;;OAEG;IACI,0BAAK,GAAZ,UAAa,OAAgB;QAA7B,iBAMC;QALC,OAAO,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAA,cAAc;YAC9D,OAAO,KAAI,CAAC,YAAY,EAAE;iBACvB,KAAK,CAAC,OAAO,CAAC;iBACd,IAAI,CAAC,UAAA,gBAAgB,IAAI,OAAA,cAAc,IAAI,gBAAgB,EAAlC,CAAkC,CAAC,CAAC;QAClE,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,0BAAK,GAAZ,UAAa,OAAgB;QAA7B,iBAKC;QAJC,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAA,MAAM;YACpC,KAAI,CAAC,UAAU,EAAE,CAAC,OAAO,GAAG,KAAK,CAAC;YAClC,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,sCAAiB,GAAxB;QACE,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE;YACxD,IAAI,CAAC,aAAa,GAAG,+BAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SACvD;IACH,CAAC;IAED;;OAEG;IACI,mCAAc,GAArB,UAA6C,WAAgC;QAC3E,IAAI;YACF,OAAQ,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,EAAE,CAAO,IAAI,IAAI,CAAC;SAC1D;QAAC,OAAO,GAAG,EAAE;YACZ,sBAAc,IAAI,cAAM,CAAC,IAAI,CAAC,iCAA+B,WAAW,CAAC,EAAE,6BAA0B,CAAC,CAAC;YACvG,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAED,2DAA2D;IACjD,4CAAuB,GAAjC,UAAkC,OAAgB,EAAE,KAAY;;QAC9D,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,IAAM,UAAU,GAAG,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC;QAE7D,IAAI,UAAU,EAAE;YACd,OAAO,GAAG,IAAI,CAAC;;gBAEf,KAAiB,IAAA,eAAA,iBAAA,UAAU,CAAA,sCAAA,8DAAE;oBAAxB,IAAM,EAAE,uBAAA;oBACX,IAAM,SAAS,GAAG,EAAE,CAAC,SAAS,CAAC;oBAC/B,IAAI,SAAS,IAAI,SAAS,CAAC,OAAO,KAAK,KAAK,EAAE;wBAC5C,OAAO,GAAG,IAAI,CAAC;wBACf,MAAM;qBACP;iBACF;;;;;;;;;SACF;QAED,mGAAmG;QACnG,oHAAoH;QACpH,gHAAgH;QAChH,IAAM,kBAAkB,GAAG,OAAO,CAAC,MAAM,KAAK,IAAI,CAAC;QACnD,IAAM,mBAAmB,GAAG,CAAC,kBAAkB,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,IAAI,CAAC,kBAAkB,IAAI,OAAO,CAAC,CAAC;QAE5G,IAAI,mBAAmB,EAAE;YACvB,OAAO,CAAC,MAAM,uCACT,CAAC,OAAO,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,KACrC,MAAM,EAAE,OAAO,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,OAAO,CAAC,IACpD,CAAC;YACH,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;SAC9B;IACH,CAAC;IAED,yCAAyC;IAC/B,iCAAY,GAAtB,UAAuB,OAAgB;QACrC,IAAI,CAAC,WAAW,EAAE,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;;OASG;IACO,4CAAuB,GAAjC,UAAkC,OAAgB;QAAlD,iBAkBC;QAjBC,OAAO,IAAI,mBAAW,CAAC,UAAA,OAAO;YAC5B,IAAI,MAAM,GAAW,CAAC,CAAC;YACvB,IAAM,IAAI,GAAW,CAAC,CAAC;YAEvB,IAAM,QAAQ,GAAG,WAAW,CAAC;gBAC3B,IAAI,KAAI,CAAC,cAAc,IAAI,CAAC,EAAE;oBAC5B,aAAa,CAAC,QAAQ,CAAC,CAAC;oBACxB,OAAO,CAAC,IAAI,CAAC,CAAC;iBACf;qBAAM;oBACL,MAAM,IAAI,IAAI,CAAC;oBACf,IAAI,OAAO,IAAI,MAAM,IAAI,OAAO,EAAE;wBAChC,aAAa,CAAC,QAAQ,CAAC,CAAC;wBACxB,OAAO,CAAC,KAAK,CAAC,CAAC;qBAChB;iBACF;YACH,CAAC,EAAE,IAAI,CAAC,CAAC;QACX,CAAC,CAAC,CAAC;IACL,CAAC;IAED,mCAAmC;IACzB,gCAAW,GAArB;QACE,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,yEAAyE;IAC/D,+BAAU,GAApB;QACE,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC,OAAO,KAAK,KAAK,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC;IACxE,CAAC;IAED;;;;;;;;;;;;;OAaG;IACO,kCAAa,GAAvB,UAAwB,KAAY,EAAE,KAAa,EAAE,IAAgB;QAArE,iBA0CC;QAzCO,IAAA,sBAAuE,EAArE,sBAAkB,EAAlB,uCAAkB,EAAE,2BAA2B,EAA3B,+CAAiD,CAAC;QAC9E,IAAM,QAAQ,yCACT,KAAK,KACR,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,aAAK,EAAE,CAAC,EAC7E,SAAS,EAAE,KAAK,CAAC,SAAS,IAAI,8BAAsB,EAAE,GACvD,CAAC;QAEF,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;QACnC,IAAI,CAAC,0BAA0B,CAAC,QAAQ,CAAC,CAAC;QAE1C,8EAA8E;QAC9E,6FAA6F;QAC7F,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,IAAI,IAAI,IAAI,IAAI,CAAC,cAAc,EAAE;YAC/B,UAAU,GAAG,WAAK,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;SAClE;QAED,oDAAoD;QACpD,IAAI,MAAM,GAAG,2BAAmB,CAAe,QAAQ,CAAC,CAAC;QAEzD,2DAA2D;QAC3D,kEAAkE;QAClE,IAAI,UAAU,EAAE;YACd,wCAAwC;YACxC,MAAM,GAAG,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SAClD;QAED,OAAO,MAAM,CAAC,IAAI,CAAC,UAAA,GAAG;YACpB,IAAI,GAAG,EAAE;gBACP,2GAA2G;gBAC3G,6FAA6F;gBAC7F,GAAG,CAAC,qBAAqB,yCACpB,GAAG,CAAC,qBAAqB,KAC5B,cAAc,EAAK,iBAAS,CAAC,cAAc,CAAC,UAAK,OAAO,cAAc,MAAG,GAC1E,CAAC;aACH;YACD,IAAI,OAAO,cAAc,KAAK,QAAQ,IAAI,cAAc,GAAG,CAAC,EAAE;gBAC5D,OAAO,KAAI,CAAC,eAAe,CAAC,GAAG,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC;aACvE;YACD,OAAO,GAAG,CAAC;QACb,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;OASG;IACO,oCAAe,GAAzB,UAA0B,KAAmB,EAAE,KAAa,EAAE,UAAkB;QAC9E,IAAI,CAAC,KAAK,EAAE;YACV,OAAO,IAAI,CAAC;SACb;QAED,IAAM,UAAU,4FACX,KAAK,GACL,CAAC,KAAK,CAAC,WAAW,IAAI;YACvB,WAAW,EAAE,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,uCACnC,CAAC,GACD,CAAC,CAAC,CAAC,IAAI,IAAI;gBACZ,IAAI,EAAE,iBAAS,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC;aAC3C,CAAC,EACF,EALsC,CAKtC,CAAC;SACJ,CAAC,GACC,CAAC,KAAK,CAAC,IAAI,IAAI;YAChB,IAAI,EAAE,iBAAS,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC;SAC/C,CAAC,GACC,CAAC,KAAK,CAAC,QAAQ,IAAI;YACpB,QAAQ,EAAE,iBAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,EAAE,UAAU,CAAC;SACvD,CAAC,GACC,CAAC,KAAK,CAAC,KAAK,IAAI;YACjB,KAAK,EAAE,iBAAS,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,CAAC;SACjD,CAAC,CACH,CAAC;QACF,0EAA0E;QAC1E,mEAAmE;QACnE,yEAAyE;QACzE,uCAAuC;QACvC,2EAA2E;QAC3E,yEAAyE;QACzE,kDAAkD;QAClD,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE;YAC1C,sEAAsE;YACtE,UAAU,CAAC,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC;SAClD;QAED,UAAU,CAAC,qBAAqB,yCAAQ,UAAU,CAAC,qBAAqB,KAAE,oBAAoB,EAAE,IAAI,GAAE,CAAC;QAEvG,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;;;;OAKG;IACO,wCAAmB,GAA7B,UAA8B,KAAY;QACxC,IAAM,OAAO,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;QAC1B,IAAA,iCAAW,EAAE,yBAAO,EAAE,mBAAI,EAAE,2BAAoB,EAApB,yCAAoB,CAAa;QAErE,IAAI,CAAC,CAAC,aAAa,IAAI,KAAK,CAAC,EAAE;YAC7B,KAAK,CAAC,WAAW,GAAG,aAAa,IAAI,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,YAAY,CAAC;SAC3E;QAED,IAAI,KAAK,CAAC,OAAO,KAAK,SAAS,IAAI,OAAO,KAAK,SAAS,EAAE;YACxD,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;SACzB;QAED,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,EAAE;YAClD,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;SACnB;QAED,IAAI,KAAK,CAAC,OAAO,EAAE;YACjB,KAAK,CAAC,OAAO,GAAG,gBAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;SACzD;QAED,IAAM,SAAS,GAAG,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACzF,IAAI,SAAS,IAAI,SAAS,CAAC,KAAK,EAAE;YAChC,SAAS,CAAC,KAAK,GAAG,gBAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;SAC7D;QAED,IAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;QAC9B,IAAI,OAAO,IAAI,OAAO,CAAC,GAAG,EAAE;YAC1B,OAAO,CAAC,GAAG,GAAG,gBAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,cAAc,CAAC,CAAC;SACrD;IACH,CAAC;IAED;;;OAGG;IACO,+CAA0B,GAApC,UAAqC,KAAY;QAC/C,IAAM,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC1D,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;YAChC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC;YAC5B,KAAK,CAAC,GAAG,CAAC,YAAY,oBAAO,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,IAAI,EAAE,CAAC,EAAK,iBAAiB,CAAC,CAAC;SACpF;IACH,CAAC;IAED;;;OAGG;IACO,+BAAU,GAApB,UAAqB,KAAY;QAC/B,IAAI,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAED;;;;;OAKG;IACO,kCAAa,GAAvB,UAAwB,KAAY,EAAE,IAAgB,EAAE,KAAa;QACnE,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,IAAI,CAChD,UAAA,UAAU;YACR,OAAO,UAAU,CAAC,QAAQ,CAAC;QAC7B,CAAC,EACD,UAAA,MAAM;YACJ,sBAAc,IAAI,cAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACvC,OAAO,SAAS,CAAC;QACnB,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACO,kCAAa,GAAvB,UAAwB,KAAY,EAAE,IAAgB,EAAE,KAAa;QAArE,iBA2EC;QA1EC,6DAA6D;QACvD,IAAA,sBAA8C,EAA5C,0BAAU,EAAE,0BAAgC,CAAC;QACrD,IAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAKtC,SAAS,eAAe,CAAC,OAAiC,EAAE,QAAkC;YAC5F,IAAI,SAAS,CAAC,eAAe,EAAE;gBAC7B,SAAS,CAAC,eAAe,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;aAC9C;QACH,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;YACtB,OAAO,2BAAmB,CAAC,IAAI,mBAAW,CAAC,0CAA0C,CAAC,CAAC,CAAC;SACzF;QAED,IAAM,aAAa,GAAG,KAAK,CAAC,IAAI,KAAK,aAAa,CAAC;QACnD,+BAA+B;QAC/B,6BAA6B;QAC7B,kDAAkD;QAClD,IAAI,CAAC,aAAa,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,EAAE;YAClF,eAAe,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;YACxC,OAAO,2BAAmB,CACxB,IAAI,mBAAW,CACb,sFAAoF,UAAU,MAAG,CAClG,CACF,CAAC;SACH;QAED,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC;aAC1C,IAAI,CAAC,UAAA,QAAQ;YACZ,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,eAAe,CAAC,iBAAiB,EAAE,KAAK,CAAC,IAAI,IAAI,OAAO,CAAC,CAAC;gBAC1D,MAAM,IAAI,mBAAW,CAAC,wDAAwD,CAAC,CAAC;aACjF;YAED,IAAM,mBAAmB,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,IAAK,IAAI,CAAC,IAAgC,CAAC,UAAU,KAAK,IAAI,CAAC;YAC5G,IAAI,mBAAmB,IAAI,aAAa,IAAI,CAAC,UAAU,EAAE;gBACvD,OAAO,QAAQ,CAAC;aACjB;YAED,IAAM,gBAAgB,GAAG,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YACpD,OAAO,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;QAC/C,CAAC,CAAC;aACD,IAAI,CAAC,UAAA,cAAc;YAClB,IAAI,cAAc,KAAK,IAAI,EAAE;gBAC3B,eAAe,CAAC,aAAa,EAAE,KAAK,CAAC,IAAI,IAAI,OAAO,CAAC,CAAC;gBACtD,MAAM,IAAI,mBAAW,CAAC,oDAAoD,CAAC,CAAC;aAC7E;YAED,IAAM,OAAO,GAAG,KAAK,IAAI,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC,UAAU,EAAE,CAAC;YAChE,IAAI,CAAC,aAAa,IAAI,OAAO,EAAE;gBAC7B,KAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;aACvD;YAED,KAAI,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;YAChC,OAAO,cAAc,CAAC;QACxB,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,EAAE,UAAA,MAAM;YAChB,IAAI,MAAM,YAAY,mBAAW,EAAE;gBACjC,MAAM,MAAM,CAAC;aACd;YAED,KAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE;gBAC5B,IAAI,EAAE;oBACJ,UAAU,EAAE,IAAI;iBACjB;gBACD,iBAAiB,EAAE,MAAe;aACnC,CAAC,CAAC;YACH,MAAM,IAAI,mBAAW,CACnB,gIAA8H,MAAQ,CACvI,CAAC;QACJ,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACO,6BAAQ,GAAlB,UAAsB,OAAuB;QAA7C,iBAYC;QAXC,IAAI,CAAC,cAAc,IAAI,CAAC,CAAC;QACzB,KAAK,OAAO,CAAC,IAAI,CACf,UAAA,KAAK;YACH,KAAI,CAAC,cAAc,IAAI,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;QACf,CAAC,EACD,UAAA,MAAM;YACJ,KAAI,CAAC,cAAc,IAAI,CAAC,CAAC;YACzB,OAAO,MAAM,CAAC;QAChB,CAAC,CACF,CAAC;IACJ,CAAC;IACH,iBAAC;AAAD,CAAC,AAxiBD,IAwiBC;AAxiBqB,gCAAU;AA0iBhC;;GAEG;AACH,SAAS,mBAAmB,CAAC,EAA4C;IACvE,IAAM,OAAO,GAAG,4DAA4D,CAAC;IAC7E,IAAI,kBAAU,CAAC,EAAE,CAAC,EAAE;QAClB,OAAO,EAAE,CAAC,IAAI,CACZ,UAAA,KAAK;YACH,IAAI,CAAC,CAAC,qBAAa,CAAC,KAAK,CAAC,IAAI,KAAK,KAAK,IAAI,CAAC,EAAE;gBAC7C,MAAM,IAAI,mBAAW,CAAC,OAAO,CAAC,CAAC;aAChC;YACD,OAAO,KAAK,CAAC;QACf,CAAC,EACD,UAAA,CAAC;YACC,MAAM,IAAI,mBAAW,CAAC,8BAA4B,CAAG,CAAC,CAAC;QACzD,CAAC,CACF,CAAC;KACH;SAAM,IAAI,CAAC,CAAC,qBAAa,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,IAAI,CAAC,EAAE;QAC9C,MAAM,IAAI,mBAAW,CAAC,OAAO,CAAC,CAAC;KAChC;IACD,OAAO,EAAE,CAAC;AACZ,CAAC","sourcesContent":["/* eslint-disable max-lines */\nimport { Scope, Session } from '@sentry/hub';\nimport {\n  Client,\n  DsnComponents,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Options,\n  Severity,\n  Transport,\n} from '@sentry/types';\nimport {\n  checkOrSetAlreadyCaught,\n  dateTimestampInSeconds,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  normalize,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  SentryError,\n  SyncPromise,\n  truncate,\n  uuid4,\n} from '@sentry/utils';\n\nimport { Backend, BackendClass } from './basebackend';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { IntegrationIndex, setupIntegrations } from './integration';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the environment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  protected readonly _backend: B;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  /** Array of used integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Number of calls being processed */\n  protected _numProcessing: number = 0;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._getBackend()\n        .eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this._getBackend().eventFromMessage(String(message), level, hint)\n      : this._getBackend().eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!this._isEnabled()) {\n      IS_DEBUG_BUILD && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      IS_DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this._sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      session.update({ init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport {\n    return this._getBackend().getTransport();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    return this._isClientDoneProcessing(timeout).then(clientFinished => {\n      return this.getTransport()\n        .close(timeout)\n        .then(transportFlushed => clientFinished && transportFlushed);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled() && !this._integrations.initialized) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      IS_DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      session.update({\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /** Deliver captured session to Sentry */\n  protected _sendSession(session: Session): void {\n    this._getBackend().sendSession(session);\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Returns the current backend. */\n  protected _getBackend(): B {\n    return this._backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = this.getOptions();\n    const prepared: Event = {\n      ...event,\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = resolvedSyncPromise<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (evt) {\n        // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809\n        // it is only attached as extra data to the event if the event somehow skips being normalized\n        evt.sdkProcessingMetadata = {\n          ...evt.sdkProcessingMetadata,\n          normalizeDepth: `${normalize(normalizeDepth)} (${typeof normalizeDepth})`,\n        };\n      }\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n    if (!event) {\n      return null;\n    }\n\n    const normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth),\n      }),\n    };\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      normalized.contexts.trace = event.contexts.trace;\n    }\n\n    normalized.sdkProcessingMetadata = { ...normalized.sdkProcessingMetadata, baseClientNormalized: true };\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  protected _applyClientOptions(event: Event): void {\n    const options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n  protected _applyIntegrationsMetadata(event: Event): void {\n    const integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n  protected _sendEvent(event: Event): void {\n    this._getBackend().sendEvent(event);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        IS_DEBUG_BUILD && logger.error(reason);\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeSend, sampleRate } = this.getOptions();\n    const transport = this.getTransport();\n\n    type RecordLostEvent = NonNullable<Transport['recordLostEvent']>;\n    type RecordLostEventParams = Parameters<RecordLostEvent>;\n\n    function recordLostEvent(outcome: RecordLostEventParams[0], category: RecordLostEventParams[1]): void {\n      if (transport.recordLostEvent) {\n        transport.recordLostEvent(outcome, category);\n      }\n    }\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.'));\n    }\n\n    const isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      recordLostEvent('sample_rate', 'event');\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, scope, hint)\n      .then(prepared => {\n        if (prepared === null) {\n          recordLostEvent('event_processor', event.type || 'event');\n          throw new SentryError('An event processor returned null, will not send event.');\n        }\n\n        const isInternalException = hint && hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException || isTransaction || !beforeSend) {\n          return prepared;\n        }\n\n        const beforeSendResult = beforeSend(prepared, hint);\n        return _ensureBeforeSendRv(beforeSendResult);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          recordLostEvent('before_send', event.type || 'event');\n          throw new SentryError('`beforeSend` returned `null`, will not send event.');\n        }\n\n        const session = scope && scope.getSession && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        this._sendEvent(processedEvent);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason as Error,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing += 1;\n    void promise.then(\n      value => {\n        this._numProcessing -= 1;\n        return value;\n      },\n      reason => {\n        this._numProcessing -= 1;\n        return reason;\n      },\n    );\n  }\n}\n\n/**\n * Verifies that return value of configured `beforeSend` is of expected type.\n */\nfunction _ensureBeforeSendRv(rv: PromiseLike<Event | null> | Event | null): PromiseLike<Event | null> | Event | null {\n  const nullErr = '`beforeSend` method has to return `null` or a valid event.';\n  if (isThenable(rv)) {\n    return rv.then(\n      event => {\n        if (!(isPlainObject(event) || event === null)) {\n          throw new SentryError(nullErr);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`beforeSend rejected with ${e}`);\n      },\n    );\n  } else if (!(isPlainObject(rv) || rv === null)) {\n    throw new SentryError(nullErr);\n  }\n  return rv;\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** Flag that is true for debug builds, false otherwise. */
exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;AAIH,2DAA2D;AAC9C,QAAA,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}export { addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, startTransaction, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/minimal';
export { addGlobalEventProcessor, getCurrentHub, getHubFromCarrier, Hub, makeMain, Scope, Session } from '@sentry/hub';
export { API, APIDetails, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, getRequestHeaders, initAPIDetails, getReportDialogEndpoint, } from './api';
export { BaseClient } from './baseclient';
export { BackendClass, BaseBackend } from './basebackend';
export { eventToSentryRequest, sessionToSentryRequest } from './request';
export { initAndBind, ClientClass } from './sdk';
export { NoopTransport } from './transports/noop';
export { BaseTransportOptions, createTransport, NewTransport, TransportMakeRequestResponse, TransportRequest, TransportRequestExecutor, } from './transports/base';
export { SDK_VERSION } from './version';
import * as Integrations from './integrations';
export { Integrations };
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,gBAAgB,EAChB,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,uBAAuB,EAAE,aAAa,EAAE,iBAAiB,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AACvH,OAAO,EAEL,GAAG,EACH,UAAU,EACV,qCAAqC,EACrC,kCAAkC,EAClC,iBAAiB,EACjB,cAAc,EACd,uBAAuB,GACxB,MAAM,OAAO,CAAC;AACf,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,YAAY,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC1D,OAAO,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,MAAM,WAAW,CAAC;AACzE,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAClD,OAAO,EACL,oBAAoB,EACpB,eAAe,EACf,YAAY,EACZ,4BAA4B,EAC5B,gBAAgB,EAChB,wBAAwB,GACzB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,KAAK,YAAY,MAAM,gBAAgB,CAAC;AAE/C,OAAO,EAAE,YAAY,EAAE,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var minimal_1 = require("@sentry/minimal");
exports.addBreadcrumb = minimal_1.addBreadcrumb;
exports.captureException = minimal_1.captureException;
exports.captureEvent = minimal_1.captureEvent;
exports.captureMessage = minimal_1.captureMessage;
exports.configureScope = minimal_1.configureScope;
exports.startTransaction = minimal_1.startTransaction;
exports.setContext = minimal_1.setContext;
exports.setExtra = minimal_1.setExtra;
exports.setExtras = minimal_1.setExtras;
exports.setTag = minimal_1.setTag;
exports.setTags = minimal_1.setTags;
exports.setUser = minimal_1.setUser;
exports.withScope = minimal_1.withScope;
var hub_1 = require("@sentry/hub");
exports.addGlobalEventProcessor = hub_1.addGlobalEventProcessor;
exports.getCurrentHub = hub_1.getCurrentHub;
exports.getHubFromCarrier = hub_1.getHubFromCarrier;
exports.Hub = hub_1.Hub;
exports.makeMain = hub_1.makeMain;
exports.Scope = hub_1.Scope;
exports.Session = hub_1.Session;
var api_1 = require("./api");
// eslint-disable-next-line deprecation/deprecation
exports.API = api_1.API;
exports.getEnvelopeEndpointWithUrlEncodedAuth = api_1.getEnvelopeEndpointWithUrlEncodedAuth;
exports.getStoreEndpointWithUrlEncodedAuth = api_1.getStoreEndpointWithUrlEncodedAuth;
exports.getRequestHeaders = api_1.getRequestHeaders;
exports.initAPIDetails = api_1.initAPIDetails;
exports.getReportDialogEndpoint = api_1.getReportDialogEndpoint;
var baseclient_1 = require("./baseclient");
exports.BaseClient = baseclient_1.BaseClient;
var basebackend_1 = require("./basebackend");
exports.BaseBackend = basebackend_1.BaseBackend;
var request_1 = require("./request");
exports.eventToSentryRequest = request_1.eventToSentryRequest;
exports.sessionToSentryRequest = request_1.sessionToSentryRequest;
var sdk_1 = require("./sdk");
exports.initAndBind = sdk_1.initAndBind;
var noop_1 = require("./transports/noop");
exports.NoopTransport = noop_1.NoopTransport;
var base_1 = require("./transports/base");
exports.createTransport = base_1.createTransport;
var version_1 = require("./version");
exports.SDK_VERSION = version_1.SDK_VERSION;
var Integrations = require("./integrations");
exports.Integrations = Integrations;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA,2CAcyB;AAbvB,kCAAA,aAAa,CAAA;AACb,qCAAA,gBAAgB,CAAA;AAChB,iCAAA,YAAY,CAAA;AACZ,mCAAA,cAAc,CAAA;AACd,mCAAA,cAAc,CAAA;AACd,qCAAA,gBAAgB,CAAA;AAChB,+BAAA,UAAU,CAAA;AACV,6BAAA,QAAQ,CAAA;AACR,8BAAA,SAAS,CAAA;AACT,2BAAA,MAAM,CAAA;AACN,4BAAA,OAAO,CAAA;AACP,4BAAA,OAAO,CAAA;AACP,8BAAA,SAAS,CAAA;AAEX,mCAAuH;AAA9G,wCAAA,uBAAuB,CAAA;AAAE,8BAAA,aAAa,CAAA;AAAE,kCAAA,iBAAiB,CAAA;AAAE,oBAAA,GAAG,CAAA;AAAE,yBAAA,QAAQ,CAAA;AAAE,sBAAA,KAAK,CAAA;AAAE,wBAAA,OAAO,CAAA;AACjG,6BASe;AARb,mDAAmD;AACnD,oBAAA,GAAG,CAAA;AAEH,sDAAA,qCAAqC,CAAA;AACrC,mDAAA,kCAAkC,CAAA;AAClC,kCAAA,iBAAiB,CAAA;AACjB,+BAAA,cAAc,CAAA;AACd,wCAAA,uBAAuB,CAAA;AAEzB,2CAA0C;AAAjC,kCAAA,UAAU,CAAA;AACnB,6CAA0D;AAAnC,oCAAA,WAAW,CAAA;AAClC,qCAAyE;AAAhE,yCAAA,oBAAoB,CAAA;AAAE,2CAAA,sBAAsB,CAAA;AACrD,6BAAiD;AAAxC,4BAAA,WAAW,CAAA;AACpB,0CAAkD;AAAzC,+BAAA,aAAa,CAAA;AACtB,0CAO2B;AALzB,iCAAA,eAAe,CAAA;AAMjB,qCAAwC;AAA/B,gCAAA,WAAW,CAAA;AAEpB,6CAA+C;AAEtC,oCAAY","sourcesContent":["export {\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  startTransaction,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  withScope,\n} from '@sentry/minimal';\nexport { addGlobalEventProcessor, getCurrentHub, getHubFromCarrier, Hub, makeMain, Scope, Session } from '@sentry/hub';\nexport {\n  // eslint-disable-next-line deprecation/deprecation\n  API,\n  APIDetails,\n  getEnvelopeEndpointWithUrlEncodedAuth,\n  getStoreEndpointWithUrlEncodedAuth,\n  getRequestHeaders,\n  initAPIDetails,\n  getReportDialogEndpoint,\n} from './api';\nexport { BaseClient } from './baseclient';\nexport { BackendClass, BaseBackend } from './basebackend';\nexport { eventToSentryRequest, sessionToSentryRequest } from './request';\nexport { initAndBind, ClientClass } from './sdk';\nexport { NoopTransport } from './transports/noop';\nexport {\n  BaseTransportOptions,\n  createTransport,\n  NewTransport,\n  TransportMakeRequestResponse,\n  TransportRequest,\n  TransportRequestExecutor,\n} from './transports/base';\nexport { SDK_VERSION } from './version';\n\nimport * as Integrations from './integrations';\n\nexport { Integrations };\n"]}import { Integration, Options } from '@sentry/types';
export declare const installedIntegrations: string[];
/** Map of integrations assigned to a client */
export declare type IntegrationIndex = {
    [key: string]: Integration;
} & {
    initialized?: boolean;
};
/** Gets integration to install */
export declare function getIntegrationsToSetup(options: Options): Integration[];
/** Setup given integration */
export declare function setupIntegration(integration: Integration): void;
/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
export declare function setupIntegrations<O extends Options>(options: O): IntegrationIndex;
//# sourceMappingURL=integration.d.ts.map{"version":3,"file":"integration.d.ts","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAKrD,eAAO,MAAM,qBAAqB,EAAE,MAAM,EAAO,CAAC;AAElD,+CAA+C;AAC/C,oBAAY,gBAAgB,GAAG;IAC7B,CAAC,GAAG,EAAE,MAAM,GAAG,WAAW,CAAC;CAC5B,GAAG;IAAE,WAAW,CAAC,EAAE,OAAO,CAAA;CAAE,CAAC;AAc9B,kCAAkC;AAClC,wBAAgB,sBAAsB,CAAC,OAAO,EAAE,OAAO,GAAG,WAAW,EAAE,CA4BtE;AAED,8BAA8B;AAC9B,wBAAgB,gBAAgB,CAAC,WAAW,EAAE,WAAW,GAAG,IAAI,CAO/D;AAED;;;;;GAKG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,SAAS,OAAO,EAAE,OAAO,EAAE,CAAC,GAAG,gBAAgB,CAWjF"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
var flags_1 = require("./flags");
exports.installedIntegrations = [];
/**
 * @private
 */
function filterDuplicates(integrations) {
    return integrations.reduce(function (acc, integrations) {
        if (acc.every(function (accIntegration) { return integrations.name !== accIntegration.name; })) {
            acc.push(integrations);
        }
        return acc;
    }, []);
}
/** Gets integration to install */
function getIntegrationsToSetup(options) {
    var defaultIntegrations = (options.defaultIntegrations && tslib_1.__spread(options.defaultIntegrations)) || [];
    var userIntegrations = options.integrations;
    var integrations = tslib_1.__spread(filterDuplicates(defaultIntegrations));
    if (Array.isArray(userIntegrations)) {
        // Filter out integrations that are also included in user options
        integrations = tslib_1.__spread(integrations.filter(function (integrations) {
            return userIntegrations.every(function (userIntegration) { return userIntegration.name !== integrations.name; });
        }), filterDuplicates(userIntegrations));
    }
    else if (typeof userIntegrations === 'function') {
        integrations = userIntegrations(integrations);
        integrations = Array.isArray(integrations) ? integrations : [integrations];
    }
    // Make sure that if present, `Debug` integration will always run last
    var integrationsNames = integrations.map(function (i) { return i.name; });
    var alwaysLastToRun = 'Debug';
    if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
        integrations.push.apply(integrations, tslib_1.__spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
    }
    return integrations;
}
exports.getIntegrationsToSetup = getIntegrationsToSetup;
/** Setup given integration */
function setupIntegration(integration) {
    if (exports.installedIntegrations.indexOf(integration.name) !== -1) {
        return;
    }
    integration.setupOnce(hub_1.addGlobalEventProcessor, hub_1.getCurrentHub);
    exports.installedIntegrations.push(integration.name);
    flags_1.IS_DEBUG_BUILD && utils_1.logger.log("Integration installed: " + integration.name);
}
exports.setupIntegration = setupIntegration;
/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
function setupIntegrations(options) {
    var integrations = {};
    getIntegrationsToSetup(options).forEach(function (integration) {
        integrations[integration.name] = integration;
        setupIntegration(integration);
    });
    // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`
    // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be
    // considered a member of the index the way the actual integrations are
    utils_1.addNonEnumerableProperty(integrations, 'initialized', true);
    return integrations;
}
exports.setupIntegrations = setupIntegrations;
//# sourceMappingURL=integration.js.map{"version":3,"file":"integration.js","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"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","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Integration, Options } from '@sentry/types';\nimport { addNonEnumerableProperty, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n} & { initialized?: boolean };\n\n/**\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  return integrations.reduce((acc, integrations) => {\n    if (acc.every(accIntegration => integrations.name !== accIntegration.name)) {\n      acc.push(integrations);\n    }\n    return acc;\n  }, [] as Integration[]);\n}\n\n/** Gets integration to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];\n  const userIntegrations = options.integrations;\n\n  let integrations: Integration[] = [...filterDuplicates(defaultIntegrations)];\n\n  if (Array.isArray(userIntegrations)) {\n    // Filter out integrations that are also included in user options\n    integrations = [\n      ...integrations.filter(integrations =>\n        userIntegrations.every(userIntegration => userIntegration.name !== integrations.name),\n      ),\n      // And filter out duplicated user options integrations\n      ...filterDuplicates(userIntegrations),\n    ];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(integrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  }\n\n  // Make sure that if present, `Debug` integration will always run last\n  const integrationsNames = integrations.map(i => i.name);\n  const alwaysLastToRun = 'Debug';\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push(...integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1));\n  }\n\n  return integrations;\n}\n\n/** Setup given integration */\nexport function setupIntegration(integration: Integration): void {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  IS_DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations<O extends Options>(options: O): IntegrationIndex {\n  const integrations: IntegrationIndex = {};\n  getIntegrationsToSetup(options).forEach(integration => {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`\n  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be\n  // considered a member of the index the way the actual integrations are\n  addNonEnumerableProperty(integrations, 'initialized', true);\n  return integrations;\n}\n"]}import { Integration } from '@sentry/types';
/** Patch toString calls to return proper name for wrapped functions */
export declare class FunctionToString implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=functiontostring.d.ts.map{"version":3,"file":"functiontostring.d.ts","sourceRoot":"","sources":["../../../src/integrations/functiontostring.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAmB,MAAM,eAAe,CAAC;AAK7D,uEAAuE;AACvE,qBAAa,gBAAiB,YAAW,WAAW;IAClD;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAsB;IAE9C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAuB;IAE1C;;OAEG;IACI,SAAS,IAAI,IAAI;CAUzB"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
var originalFunctionToString;
/** Patch toString calls to return proper name for wrapped functions */
var FunctionToString = /** @class */ (function () {
    function FunctionToString() {
        /**
         * @inheritDoc
         */
        this.name = FunctionToString.id;
    }
    /**
     * @inheritDoc
     */
    FunctionToString.prototype.setupOnce = function () {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalFunctionToString = Function.prototype.toString;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Function.prototype.toString = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var context = utils_1.getOriginalFunction(this) || this;
            return originalFunctionToString.apply(context, args);
        };
    };
    /**
     * @inheritDoc
     */
    FunctionToString.id = 'FunctionToString';
    return FunctionToString;
}());
exports.FunctionToString = FunctionToString;
//# sourceMappingURL=functiontostring.js.map{"version":3,"file":"functiontostring.js","sourceRoot":"","sources":["../../../src/integrations/functiontostring.ts"],"names":[],"mappings":";AACA,uCAAoD;AAEpD,IAAI,wBAAoC,CAAC;AAEzC,uEAAuE;AACvE;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,gBAAgB,CAAC,EAAE,CAAC;IAe5C,CAAC;IAbC;;OAEG;IACI,oCAAS,GAAhB;QACE,6DAA6D;QAC7D,wBAAwB,GAAG,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC;QAEvD,8DAA8D;QAC9D,QAAQ,CAAC,SAAS,CAAC,QAAQ,GAAG;YAAiC,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC3E,IAAM,OAAO,GAAG,2BAAmB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC;YAClD,OAAO,wBAAwB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACvD,CAAC,CAAC;IACJ,CAAC;IAtBD;;OAEG;IACW,mBAAE,GAAW,kBAAkB,CAAC;IAoBhD,uBAAC;CAAA,AAxBD,IAwBC;AAxBY,4CAAgB","sourcesContent":["import { Integration, WrappedFunction } from '@sentry/types';\nimport { getOriginalFunction } from '@sentry/utils';\n\nlet originalFunctionToString: () => void;\n\n/** Patch toString calls to return proper name for wrapped functions */\nexport class FunctionToString implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'FunctionToString';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = FunctionToString.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    originalFunctionToString = Function.prototype.toString;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Function.prototype.toString = function (this: WrappedFunction, ...args: any[]): string {\n      const context = getOriginalFunction(this) || this;\n      return originalFunctionToString.apply(context, args);\n    };\n  }\n}\n"]}import { Event, EventProcessor, Hub, Integration } from '@sentry/types';
/** Options for the InboundFilters integration */
export interface InboundFiltersOptions {
    allowUrls: Array<string | RegExp>;
    denyUrls: Array<string | RegExp>;
    ignoreErrors: Array<string | RegExp>;
    ignoreInternal: boolean;
    /** @deprecated use {@link InboundFiltersOptions.allowUrls} instead. */
    whitelistUrls: Array<string | RegExp>;
    /** @deprecated use {@link InboundFiltersOptions.denyUrls} instead. */
    blacklistUrls: Array<string | RegExp>;
}
/** Inbound filters configurable by the user */
export declare class InboundFilters implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    constructor(_options?: Partial<InboundFiltersOptions>);
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (processor: EventProcessor) => void, getCurrentHub: () => Hub): void;
}
/** JSDoc */
export declare function _mergeOptions(internalOptions?: Partial<InboundFiltersOptions>, clientOptions?: Partial<InboundFiltersOptions>): Partial<InboundFiltersOptions>;
/** JSDoc */
export declare function _shouldDropEvent(event: Event, options: Partial<InboundFiltersOptions>): boolean;
//# sourceMappingURL=inboundfilters.d.ts.map{"version":3,"file":"inboundfilters.d.ts","sourceRoot":"","sources":["../../../src/integrations/inboundfilters.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAc,MAAM,eAAe,CAAC;AASpF,iDAAiD;AACjD,MAAM,WAAW,qBAAqB;IACpC,SAAS,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IAClC,QAAQ,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACjC,YAAY,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACrC,cAAc,EAAE,OAAO,CAAC;IAExB,uEAAuE;IACvE,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,sEAAsE;IACtE,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;CACvC;AAED,+CAA+C;AAC/C,qBAAa,cAAe,YAAW,WAAW;IAW7B,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAV5C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAoB;IAE5C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAqB;gBAEJ,QAAQ,GAAE,OAAO,CAAC,qBAAqB,CAAM;IAEjF;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,SAAS,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;CAe/G;AAED,YAAY;AACZ,wBAAgB,aAAa,CAC3B,eAAe,GAAE,OAAO,CAAC,qBAAqB,CAAM,EACpD,aAAa,GAAE,OAAO,CAAC,qBAAqB,CAAM,GACjD,OAAO,CAAC,qBAAqB,CAAC,CAyBhC;AAED,YAAY;AACZ,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,qBAAqB,CAAC,GAAG,OAAO,CAgC/F"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
var flags_1 = require("../flags");
// "Script error." is hard coded into browsers for errors that it can't read.
// this is the result of a script being pulled in from an external domain and CORS.
var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
/** Inbound filters configurable by the user */
var InboundFilters = /** @class */ (function () {
    function InboundFilters(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = InboundFilters.id;
    }
    /**
     * @inheritDoc
     */
    InboundFilters.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor(function (event) {
            var hub = getCurrentHub();
            if (hub) {
                var self_1 = hub.getIntegration(InboundFilters);
                if (self_1) {
                    var client = hub.getClient();
                    var clientOptions = client ? client.getOptions() : {};
                    var options = _mergeOptions(self_1._options, clientOptions);
                    return _shouldDropEvent(event, options) ? null : event;
                }
            }
            return event;
        });
    };
    /**
     * @inheritDoc
     */
    InboundFilters.id = 'InboundFilters';
    return InboundFilters;
}());
exports.InboundFilters = InboundFilters;
/** JSDoc */
function _mergeOptions(internalOptions, clientOptions) {
    if (internalOptions === void 0) { internalOptions = {}; }
    if (clientOptions === void 0) { clientOptions = {}; }
    return {
        allowUrls: tslib_1.__spread((internalOptions.whitelistUrls || []), (internalOptions.allowUrls || []), (clientOptions.whitelistUrls || []), (clientOptions.allowUrls || [])),
        denyUrls: tslib_1.__spread((internalOptions.blacklistUrls || []), (internalOptions.denyUrls || []), (clientOptions.blacklistUrls || []), (clientOptions.denyUrls || [])),
        ignoreErrors: tslib_1.__spread((internalOptions.ignoreErrors || []), (clientOptions.ignoreErrors || []), DEFAULT_IGNORE_ERRORS),
        ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,
    };
}
exports._mergeOptions = _mergeOptions;
/** JSDoc */
function _shouldDropEvent(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
        flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + utils_1.getEventDescription(event));
        return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
        flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + utils_1.getEventDescription(event));
        return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
        flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
        return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
        flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
        return true;
    }
    return false;
}
exports._shouldDropEvent = _shouldDropEvent;
function _isIgnoredError(event, ignoreErrors) {
    if (!ignoreErrors || !ignoreErrors.length) {
        return false;
    }
    return _getPossibleEventMessages(event).some(function (message) {
        return ignoreErrors.some(function (pattern) { return utils_1.isMatchingPattern(message, pattern); });
    });
}
function _isDeniedUrl(event, denyUrls) {
    // TODO: Use Glob instead?
    if (!denyUrls || !denyUrls.length) {
        return false;
    }
    var url = _getEventFilterUrl(event);
    return !url ? false : denyUrls.some(function (pattern) { return utils_1.isMatchingPattern(url, pattern); });
}
function _isAllowedUrl(event, allowUrls) {
    // TODO: Use Glob instead?
    if (!allowUrls || !allowUrls.length) {
        return true;
    }
    var url = _getEventFilterUrl(event);
    return !url ? true : allowUrls.some(function (pattern) { return utils_1.isMatchingPattern(url, pattern); });
}
function _getPossibleEventMessages(event) {
    if (event.message) {
        return [event.message];
    }
    if (event.exception) {
        try {
            var _a = (event.exception.values && event.exception.values[0]) || {}, _b = _a.type, type = _b === void 0 ? '' : _b, _c = _a.value, value = _c === void 0 ? '' : _c;
            return ["" + value, type + ": " + value];
        }
        catch (oO) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error("Cannot extract message for event " + utils_1.getEventDescription(event));
            return [];
        }
    }
    return [];
}
function _isSentryError(event) {
    try {
        // @ts-ignore can't be a sentry error if undefined
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return event.exception.values[0].type === 'SentryError';
    }
    catch (e) {
        // ignore
    }
    return false;
}
function _getLastValidUrl(frames) {
    if (frames === void 0) { frames = []; }
    for (var i = frames.length - 1; i >= 0; i--) {
        var frame = frames[i];
        if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
            return frame.filename || null;
        }
    }
    return null;
}
function _getEventFilterUrl(event) {
    try {
        if (event.stacktrace) {
            return _getLastValidUrl(event.stacktrace.frames);
        }
        var frames_1;
        try {
            // @ts-ignore we only care about frames if the whole thing here is defined
            frames_1 = event.exception.values[0].stacktrace.frames;
        }
        catch (e) {
            // ignore
        }
        return frames_1 ? _getLastValidUrl(frames_1) : null;
    }
    catch (oO) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.error("Cannot extract url for event " + utils_1.getEventDescription(event));
        return null;
    }
}
//# sourceMappingURL=inboundfilters.js.map{"version":3,"file":"inboundfilters.js","sourceRoot":"","sources":["../../../src/integrations/inboundfilters.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventProcessor, Hub, Integration, StackFrame } from '@sentry/types';\nimport { getEventDescription, isMatchingPattern, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nconst DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n\n/** Options for the InboundFilters integration */\nexport interface InboundFiltersOptions {\n  allowUrls: Array<string | RegExp>;\n  denyUrls: Array<string | RegExp>;\n  ignoreErrors: Array<string | RegExp>;\n  ignoreInternal: boolean;\n\n  /** @deprecated use {@link InboundFiltersOptions.allowUrls} instead. */\n  whitelistUrls: Array<string | RegExp>;\n  /** @deprecated use {@link InboundFiltersOptions.denyUrls} instead. */\n  blacklistUrls: Array<string | RegExp>;\n}\n\n/** Inbound filters configurable by the user */\nexport class InboundFilters implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'InboundFilters';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = InboundFilters.id;\n\n  public constructor(private readonly _options: Partial<InboundFiltersOptions> = {}) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (processor: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor((event: Event) => {\n      const hub = getCurrentHub();\n      if (hub) {\n        const self = hub.getIntegration(InboundFilters);\n        if (self) {\n          const client = hub.getClient();\n          const clientOptions = client ? client.getOptions() : {};\n          const options = _mergeOptions(self._options, clientOptions);\n          return _shouldDropEvent(event, options) ? null : event;\n        }\n      }\n      return event;\n    });\n  }\n}\n\n/** JSDoc */\nexport function _mergeOptions(\n  internalOptions: Partial<InboundFiltersOptions> = {},\n  clientOptions: Partial<InboundFiltersOptions> = {},\n): Partial<InboundFiltersOptions> {\n  return {\n    allowUrls: [\n      // eslint-disable-next-line deprecation/deprecation\n      ...(internalOptions.whitelistUrls || []),\n      ...(internalOptions.allowUrls || []),\n      // eslint-disable-next-line deprecation/deprecation\n      ...(clientOptions.whitelistUrls || []),\n      ...(clientOptions.allowUrls || []),\n    ],\n    denyUrls: [\n      // eslint-disable-next-line deprecation/deprecation\n      ...(internalOptions.blacklistUrls || []),\n      ...(internalOptions.denyUrls || []),\n      // eslint-disable-next-line deprecation/deprecation\n      ...(clientOptions.blacklistUrls || []),\n      ...(clientOptions.denyUrls || []),\n    ],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...DEFAULT_IGNORE_ERRORS,\n    ],\n    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,\n  };\n}\n\n/** JSDoc */\nexport function _shouldDropEvent(event: Event, options: Partial<InboundFiltersOptions>): boolean {\n  if (options.ignoreInternal && _isSentryError(event)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(`Event dropped due to being internal Sentry Error.\\nEvent: ${getEventDescription(event)}`);\n    return true;\n  }\n  if (_isIgnoredError(event, options.ignoreErrors)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${getEventDescription(event)}`,\n      );\n    return true;\n  }\n  if (_isDeniedUrl(event, options.denyUrls)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  if (!_isAllowedUrl(event, options.allowUrls)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event: Event, ignoreErrors?: Array<string | RegExp>): boolean {\n  if (!ignoreErrors || !ignoreErrors.length) {\n    return false;\n  }\n\n  return _getPossibleEventMessages(event).some(message =>\n    ignoreErrors.some(pattern => isMatchingPattern(message, pattern)),\n  );\n}\n\nfunction _isDeniedUrl(event: Event, denyUrls?: Array<string | RegExp>): boolean {\n  // TODO: Use Glob instead?\n  if (!denyUrls || !denyUrls.length) {\n    return false;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? false : denyUrls.some(pattern => isMatchingPattern(url, pattern));\n}\n\nfunction _isAllowedUrl(event: Event, allowUrls?: Array<string | RegExp>): boolean {\n  // TODO: Use Glob instead?\n  if (!allowUrls || !allowUrls.length) {\n    return true;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? true : allowUrls.some(pattern => isMatchingPattern(url, pattern));\n}\n\nfunction _getPossibleEventMessages(event: Event): string[] {\n  if (event.message) {\n    return [event.message];\n  }\n  if (event.exception) {\n    try {\n      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};\n      return [`${value}`, `${type}: ${value}`];\n    } catch (oO) {\n      IS_DEBUG_BUILD && logger.error(`Cannot extract message for event ${getEventDescription(event)}`);\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction _isSentryError(event: Event): boolean {\n  try {\n    // @ts-ignore can't be a sentry error if undefined\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return event.exception.values[0].type === 'SentryError';\n  } catch (e) {\n    // ignore\n  }\n  return false;\n}\n\nfunction _getLastValidUrl(frames: StackFrame[] = []): string | null {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    const frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event: Event): string | null {\n  try {\n    if (event.stacktrace) {\n      return _getLastValidUrl(event.stacktrace.frames);\n    }\n    let frames;\n    try {\n      // @ts-ignore we only care about frames if the whole thing here is defined\n      frames = event.exception.values[0].stacktrace.frames;\n    } catch (e) {\n      // ignore\n    }\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    IS_DEBUG_BUILD && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);\n    return null;\n  }\n}\n"]}export { FunctionToString } from './functiontostring';
export { InboundFilters } from './inboundfilters';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var functiontostring_1 = require("./functiontostring");
exports.FunctionToString = functiontostring_1.FunctionToString;
var inboundfilters_1 = require("./inboundfilters");
exports.InboundFilters = inboundfilters_1.InboundFilters;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":";AAAA,uDAAsD;AAA7C,8CAAA,gBAAgB,CAAA;AACzB,mDAAkD;AAAzC,0CAAA,cAAc,CAAA","sourcesContent":["export { FunctionToString } from './functiontostring';\nexport { InboundFilters } from './inboundfilters';\n"]}import { Event, EventEnvelope, SentryRequest, SentryRequestType, Session, SessionAggregates, SessionEnvelope } from '@sentry/types';
import { APIDetails } from './api';
/** Creates an envelope from a Session */
export declare function createSessionEnvelope(session: Session | SessionAggregates, api: APIDetails): [SessionEnvelope, SentryRequestType];
/** Creates a SentryRequest from a Session. */
export declare function sessionToSentryRequest(session: Session | SessionAggregates, api: APIDetails): SentryRequest;
/**
 * Create an Envelope from an event. Note that this is duplicated from below,
 * but on purpose as this will be refactored in v7.
 */
export declare function createEventEnvelope(event: Event, api: APIDetails): EventEnvelope;
/** Creates a SentryRequest from an event. */
export declare function eventToSentryRequest(event: Event, api: APIDetails): SentryRequest;
//# sourceMappingURL=request.d.ts.map{"version":3,"file":"request.d.ts","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,KAAK,EACL,aAAa,EAGb,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,eAAe,EAEhB,MAAM,eAAe,CAAC;AAGvB,OAAO,EAAE,UAAU,EAA6E,MAAM,OAAO,CAAC;AA2B9G,yCAAyC;AACzC,wBAAgB,qBAAqB,CACnC,OAAO,EAAE,OAAO,GAAG,iBAAiB,EACpC,GAAG,EAAE,UAAU,GACd,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAgBtC;AAED,8CAA8C;AAC9C,wBAAgB,sBAAsB,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAO3G;AAED;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAkDhF;AAED,6CAA6C;AAC7C,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAgGjF"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
var api_1 = require("./api");
/** Extract sdk info from from the API metadata */
function getSdkMetadataForEnvelopeHeader(api) {
    if (!api.metadata || !api.metadata.sdk) {
        return;
    }
    var _a = api.metadata.sdk, name = _a.name, version = _a.version;
    return { name: name, version: version };
}
/**
 * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
 * Merge with existing data if any.
 **/
function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
        return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = tslib_1.__spread((event.sdk.integrations || []), (sdkInfo.integrations || []));
    event.sdk.packages = tslib_1.__spread((event.sdk.packages || []), (sdkInfo.packages || []));
    return event;
}
/** Creates an envelope from a Session */
function createSessionEnvelope(session, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var envelopeHeaders = tslib_1.__assign(tslib_1.__assign({ sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
    // I know this is hacky but we don't want to add `sessions` to request type since it's never rate limited
    var type = 'aggregates' in session ? 'sessions' : 'session';
    // TODO (v7) Have to cast type because envelope items do not accept a `SentryRequestType`
    var envelopeItem = [{ type: type }, session];
    var envelope = utils_1.createEnvelope(envelopeHeaders, [envelopeItem]);
    return [envelope, type];
}
exports.createSessionEnvelope = createSessionEnvelope;
/** Creates a SentryRequest from a Session. */
function sessionToSentryRequest(session, api) {
    var _a = tslib_1.__read(createSessionEnvelope(session, api), 2), envelope = _a[0], type = _a[1];
    return {
        body: utils_1.serializeEnvelope(envelope),
        type: type,
        url: api_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel),
    };
}
exports.sessionToSentryRequest = sessionToSentryRequest;
/**
 * Create an Envelope from an event. Note that this is duplicated from below,
 * but on purpose as this will be refactored in v7.
 */
function createEventEnvelope(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || 'event';
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    // TODO: Below is a temporary hack in order to debug a serialization error - see
    // https://github.com/getsentry/sentry-javascript/issues/2809,
    // https://github.com/getsentry/sentry-javascript/pull/4425, and
    // https://github.com/getsentry/sentry-javascript/pull/4574.
    //
    // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
    // throw a circular reference error.
    //
    // When it's time to remove it:
    // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
    //    `sdkProcessingMetadata`
    // 2. Restore the original version of the request body, which is commented out
    // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
    //    baseClient tests in this package
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    // In theory, all events should be marked as having gone through normalization and so
    // we should never set this tag/extra data
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
    }
    // prevent this data from being sent to sentry
    // TODO: This is NOT part of the hack - DO NOT DELETE
    delete event.sdkProcessingMetadata;
    var envelopeHeaders = tslib_1.__assign(tslib_1.__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
    var eventItem = [
        {
            type: eventType,
            sample_rates: [{ id: samplingMethod, rate: sampleRate }],
        },
        event,
    ];
    return utils_1.createEnvelope(envelopeHeaders, [eventItem]);
}
exports.createEventEnvelope = createEventEnvelope;
/** Creates a SentryRequest from an event. */
function eventToSentryRequest(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || 'event';
    var useEnvelope = eventType === 'transaction' || !!api.tunnel;
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    // TODO: Below is a temporary hack in order to debug a serialization error - see
    // https://github.com/getsentry/sentry-javascript/issues/2809,
    // https://github.com/getsentry/sentry-javascript/pull/4425, and
    // https://github.com/getsentry/sentry-javascript/pull/4574.
    //
    // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
    // throw a circular reference error.
    //
    // When it's time to remove it:
    // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
    //    `sdkProcessingMetadata`
    // 2. Restore the original version of the request body, which is commented out
    // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
    //    baseClient tests in this package
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    // In theory, all events should be marked as having gone through normalization and so
    // we should never set this tag/extra data
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
    }
    // prevent this data from being sent to sentry
    // TODO: This is NOT part of the hack - DO NOT DELETE
    delete event.sdkProcessingMetadata;
    var body;
    try {
        // 99.9% of events should get through just fine - no change in behavior for them
        body = JSON.stringify(event);
    }
    catch (err) {
        // Record data about the error without replacing original event data, then force renormalization
        event.tags.JSONStringifyError = true;
        event.extra.JSONStringifyError = err;
        try {
            body = JSON.stringify(utils_1.normalize(event));
        }
        catch (newErr) {
            // At this point even renormalization hasn't worked, meaning something about the event data has gone very wrong.
            // Time to cut our losses and record only the new error. With luck, even in the problematic cases we're trying to
            // debug with this hack, we won't ever land here.
            var innerErr = newErr;
            body = JSON.stringify({
                message: 'JSON.stringify error after renormalization',
                // setting `extra: { innerErr }` here for some reason results in an empty object, so unpack manually
                extra: { message: innerErr.message, stack: innerErr.stack },
            });
        }
    }
    var req = {
        // this is the relevant line of code before the hack was added, to make it easy to undo said hack once we've solved
        // the mystery
        // body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
        body: body,
        type: eventType,
        url: useEnvelope
            ? api_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
            : api_1.getStoreEndpointWithUrlEncodedAuth(api.dsn),
    };
    // https://develop.sentry.dev/sdk/envelopes/
    // Since we don't need to manipulate envelopes nor store them, there is no
    // exported concept of an Envelope with operations including serialization and
    // deserialization. Instead, we only implement a minimal subset of the spec to
    // serialize events inline here.
    if (useEnvelope) {
        var envelopeHeaders = tslib_1.__assign(tslib_1.__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
        var eventItem = [
            {
                type: eventType,
                sample_rates: [{ id: samplingMethod, rate: sampleRate }],
            },
            req.body,
        ];
        var envelope = utils_1.createEnvelope(envelopeHeaders, [eventItem]);
        req.body = utils_1.serializeEnvelope(envelope);
    }
    return req;
}
exports.eventToSentryRequest = eventToSentryRequest;
//# sourceMappingURL=request.js.map{"version":3,"file":"request.js","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Event,\n  EventEnvelope,\n  EventItem,\n  SdkInfo,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  SessionAggregates,\n  SessionEnvelope,\n  SessionItem,\n} from '@sentry/types';\nimport { createEnvelope, dsnToString, normalize, serializeEnvelope } from '@sentry/utils';\n\nimport { APIDetails, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth } from './api';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(api: APIDetails): SdkInfo | undefined {\n  if (!api.metadata || !api.metadata.sdk) {\n    return;\n  }\n  const { name, version } = api.metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event: Event, sdkInfo?: SdkInfo): Event {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nexport function createSessionEnvelope(\n  session: Session | SessionAggregates,\n  api: APIDetails,\n): [SessionEnvelope, SentryRequestType] {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!api.tunnel && { dsn: dsnToString(api.dsn) }),\n  };\n\n  // I know this is hacky but we don't want to add `sessions` to request type since it's never rate limited\n  const type = 'aggregates' in session ? ('sessions' as SentryRequestType) : 'session';\n\n  // TODO (v7) Have to cast type because envelope items do not accept a `SentryRequestType`\n  const envelopeItem = [{ type } as { type: 'session' | 'sessions' }, session] as SessionItem;\n  const envelope = createEnvelope<SessionEnvelope>(envelopeHeaders, [envelopeItem]);\n\n  return [envelope, type];\n}\n\n/** Creates a SentryRequest from a Session. */\nexport function sessionToSentryRequest(session: Session | SessionAggregates, api: APIDetails): SentryRequest {\n  const [envelope, type] = createSessionEnvelope(session, api);\n  return {\n    body: serializeEnvelope(envelope),\n    type,\n    url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel),\n  };\n}\n\n/**\n * Create an Envelope from an event. Note that this is duplicated from below,\n * but on purpose as this will be refactored in v7.\n */\nexport function createEventEnvelope(event: Event, api: APIDetails): EventEnvelope {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const eventType = event.type || 'event';\n\n  const { transactionSampling } = event.sdkProcessingMetadata || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n\n  // TODO: Below is a temporary hack in order to debug a serialization error - see\n  // https://github.com/getsentry/sentry-javascript/issues/2809,\n  // https://github.com/getsentry/sentry-javascript/pull/4425, and\n  // https://github.com/getsentry/sentry-javascript/pull/4574.\n  //\n  // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to\n  // throw a circular reference error.\n  //\n  // When it's time to remove it:\n  // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting\n  //    `sdkProcessingMetadata`\n  // 2. Restore the original version of the request body, which is commented out\n  // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the\n  //    baseClient tests in this package\n  enhanceEventWithSdkInfo(event, api.metadata.sdk);\n  event.tags = event.tags || {};\n  event.extra = event.extra || {};\n\n  // In theory, all events should be marked as having gone through normalization and so\n  // we should never set this tag/extra data\n  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {\n    event.tags.skippedNormalization = true;\n    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';\n  }\n\n  // prevent this data from being sent to sentry\n  // TODO: This is NOT part of the hack - DO NOT DELETE\n  delete event.sdkProcessingMetadata;\n\n  const envelopeHeaders = {\n    event_id: event.event_id as string,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!api.tunnel && { dsn: dsnToString(api.dsn) }),\n  };\n  const eventItem: EventItem = [\n    {\n      type: eventType,\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n    },\n    event,\n  ];\n  return createEnvelope<EventEnvelope>(envelopeHeaders, [eventItem]);\n}\n\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event: Event, api: APIDetails): SentryRequest {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const eventType = event.type || 'event';\n  const useEnvelope = eventType === 'transaction' || !!api.tunnel;\n\n  const { transactionSampling } = event.sdkProcessingMetadata || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n\n  // TODO: Below is a temporary hack in order to debug a serialization error - see\n  // https://github.com/getsentry/sentry-javascript/issues/2809,\n  // https://github.com/getsentry/sentry-javascript/pull/4425, and\n  // https://github.com/getsentry/sentry-javascript/pull/4574.\n  //\n  // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to\n  // throw a circular reference error.\n  //\n  // When it's time to remove it:\n  // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting\n  //    `sdkProcessingMetadata`\n  // 2. Restore the original version of the request body, which is commented out\n  // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the\n  //    baseClient tests in this package\n  enhanceEventWithSdkInfo(event, api.metadata.sdk);\n  event.tags = event.tags || {};\n  event.extra = event.extra || {};\n\n  // In theory, all events should be marked as having gone through normalization and so\n  // we should never set this tag/extra data\n  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {\n    event.tags.skippedNormalization = true;\n    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';\n  }\n\n  // prevent this data from being sent to sentry\n  // TODO: This is NOT part of the hack - DO NOT DELETE\n  delete event.sdkProcessingMetadata;\n\n  let body;\n  try {\n    // 99.9% of events should get through just fine - no change in behavior for them\n    body = JSON.stringify(event);\n  } catch (err) {\n    // Record data about the error without replacing original event data, then force renormalization\n    event.tags.JSONStringifyError = true;\n    event.extra.JSONStringifyError = err;\n    try {\n      body = JSON.stringify(normalize(event));\n    } catch (newErr) {\n      // At this point even renormalization hasn't worked, meaning something about the event data has gone very wrong.\n      // Time to cut our losses and record only the new error. With luck, even in the problematic cases we're trying to\n      // debug with this hack, we won't ever land here.\n      const innerErr = newErr as Error;\n      body = JSON.stringify({\n        message: 'JSON.stringify error after renormalization',\n        // setting `extra: { innerErr }` here for some reason results in an empty object, so unpack manually\n        extra: { message: innerErr.message, stack: innerErr.stack },\n      });\n    }\n  }\n\n  const req: SentryRequest = {\n    // this is the relevant line of code before the hack was added, to make it easy to undo said hack once we've solved\n    // the mystery\n    // body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),\n    body,\n    type: eventType,\n    url: useEnvelope\n      ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)\n      : getStoreEndpointWithUrlEncodedAuth(api.dsn),\n  };\n\n  // https://develop.sentry.dev/sdk/envelopes/\n\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    const envelopeHeaders = {\n      event_id: event.event_id as string,\n      sent_at: new Date().toISOString(),\n      ...(sdkInfo && { sdk: sdkInfo }),\n      ...(!!api.tunnel && { dsn: dsnToString(api.dsn) }),\n    };\n    const eventItem: EventItem = [\n      {\n        type: eventType,\n        sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n      },\n      req.body,\n    ];\n    const envelope = createEnvelope<EventEnvelope>(envelopeHeaders, [eventItem]);\n    req.body = serializeEnvelope(envelope);\n  }\n\n  return req;\n}\n"]}import { Client, Options } from '@sentry/types';
/** A class object that can instantiate Client objects. */
export declare type ClientClass<F extends Client, O extends Options> = new (options: O) => F;
/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
export declare function initAndBind<F extends Client, O extends Options>(clientClass: ClientClass<F, O>, options: O): void;
//# sourceMappingURL=sdk.d.ts.map{"version":3,"file":"sdk.d.ts","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAKhD,0DAA0D;AAC1D,oBAAY,WAAW,CAAC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAErF;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,OAAO,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,CAiBjH"}Object.defineProperty(exports, "__esModule", { value: true });
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
var flags_1 = require("./flags");
/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
function initAndBind(clientClass, options) {
    if (options.debug === true) {
        if (flags_1.IS_DEBUG_BUILD) {
            utils_1.logger.enable();
        }
        else {
            // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
            // eslint-disable-next-line no-console
            console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
        }
    }
    var hub = hub_1.getCurrentHub();
    var scope = hub.getScope();
    if (scope) {
        scope.update(options.initialScope);
    }
    var client = new clientClass(options);
    hub.bindClient(client);
}
exports.initAndBind = initAndBind;
//# sourceMappingURL=sdk.js.map{"version":3,"file":"sdk.js","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":";AAAA,mCAA4C;AAE5C,uCAAuC;AAEvC,iCAAyC;AAKzC;;;;;;GAMG;AACH,SAAgB,WAAW,CAAsC,WAA8B,EAAE,OAAU;IACzG,IAAI,OAAO,CAAC,KAAK,KAAK,IAAI,EAAE;QAC1B,IAAI,sBAAc,EAAE;YAClB,cAAM,CAAC,MAAM,EAAE,CAAC;SACjB;aAAM;YACL,kHAAkH;YAClH,sCAAsC;YACtC,OAAO,CAAC,IAAI,CAAC,8EAA8E,CAAC,CAAC;SAC9F;KACF;IACD,IAAM,GAAG,GAAG,mBAAa,EAAE,CAAC;IAC5B,IAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;IAC7B,IAAI,KAAK,EAAE;QACT,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;KACpC;IACD,IAAM,MAAM,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC;IACxC,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AACzB,CAAC;AAjBD,kCAiBC","sourcesContent":["import { getCurrentHub } from '@sentry/hub';\nimport { Client, Options } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\n\n/** A class object that can instantiate Client objects. */\nexport type ClientClass<F extends Client, O extends Options> = new (options: O) => F;\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nexport function initAndBind<F extends Client, O extends Options>(clientClass: ClientClass<F, O>, options: O): void {\n  if (options.debug === true) {\n    if (IS_DEBUG_BUILD) {\n      logger.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n      // eslint-disable-next-line no-console\n      console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');\n    }\n  }\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n  if (scope) {\n    scope.update(options.initialScope);\n  }\n  const client = new clientClass(options);\n  hub.bindClient(client);\n}\n"]}import { Envelope, EventStatus } from '@sentry/types';
import { PromiseBuffer } from '@sentry/utils';
export declare const ERROR_TRANSPORT_CATEGORY = "error";
export declare const TRANSACTION_TRANSPORT_CATEGORY = "transaction";
export declare const ATTACHMENT_TRANSPORT_CATEGORY = "attachment";
export declare const SESSION_TRANSPORT_CATEGORY = "session";
declare type TransportCategory = typeof ERROR_TRANSPORT_CATEGORY | typeof TRANSACTION_TRANSPORT_CATEGORY | typeof ATTACHMENT_TRANSPORT_CATEGORY | typeof SESSION_TRANSPORT_CATEGORY;
export declare type TransportRequest = {
    body: string;
    category: TransportCategory;
};
export declare type TransportMakeRequestResponse = {
    body?: string;
    headers?: {
        [key: string]: string | null;
        'x-sentry-rate-limits': string | null;
        'retry-after': string | null;
    };
    reason?: string;
    statusCode: number;
};
export declare type TransportResponse = {
    status: EventStatus;
    reason?: string;
};
interface InternalBaseTransportOptions {
    bufferSize?: number;
}
export interface BaseTransportOptions extends InternalBaseTransportOptions {
    url: string;
}
export interface BrowserTransportOptions extends BaseTransportOptions {
    fetchParams: Record<string, string>;
    headers?: Record<string, string>;
    sendClientReports?: boolean;
}
export interface NewTransport {
    send(request: Envelope): PromiseLike<TransportResponse>;
    flush(timeout?: number): PromiseLike<boolean>;
}
export declare type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;
export declare const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
/**
 * Creates a `NewTransport`
 *
 * @param options
 * @param makeRequest
 */
export declare function createTransport(options: InternalBaseTransportOptions, makeRequest: TransportRequestExecutor, buffer?: PromiseBuffer<TransportResponse>): NewTransport;
export {};
//# sourceMappingURL=base.d.ts.map{"version":3,"file":"base.d.ts","sourceRoot":"","sources":["../../../src/transports/base.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AACtD,OAAO,EAML,aAAa,EAMd,MAAM,eAAe,CAAC;AAEvB,eAAO,MAAM,wBAAwB,UAAU,CAAC;AAEhD,eAAO,MAAM,8BAA8B,gBAAgB,CAAC;AAE5D,eAAO,MAAM,6BAA6B,eAAe,CAAC;AAE1D,eAAO,MAAM,0BAA0B,YAAY,CAAC;AAEpD,aAAK,iBAAiB,GAClB,OAAO,wBAAwB,GAC/B,OAAO,8BAA8B,GACrC,OAAO,6BAA6B,GACpC,OAAO,0BAA0B,CAAC;AAEtC,oBAAY,gBAAgB,GAAG;IAC7B,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,iBAAiB,CAAC;CAC7B,CAAC;AAEF,oBAAY,4BAA4B,GAAG;IACzC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE;QACR,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC;QAC7B,sBAAsB,EAAE,MAAM,GAAG,IAAI,CAAC;QACtC,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;KAC9B,CAAC;IACF,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,iBAAiB,GAAG;IAC9B,MAAM,EAAE,WAAW,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF,UAAU,4BAA4B;IACpC,UAAU,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,MAAM,WAAW,oBAAqB,SAAQ,4BAA4B;IAIxE,GAAG,EAAE,MAAM,CAAC;CACb;AAGD,MAAM,WAAW,uBAAwB,SAAQ,oBAAoB;IAEnE,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACjC,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC7B;AAED,MAAM,WAAW,YAAY;IAC3B,IAAI,CAAC,OAAO,EAAE,QAAQ,GAAG,WAAW,CAAC,iBAAiB,CAAC,CAAC;IACxD,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;CAC/C;AAED,oBAAY,wBAAwB,GAAG,CAAC,OAAO,EAAE,gBAAgB,KAAK,WAAW,CAAC,4BAA4B,CAAC,CAAC;AAEhH,eAAO,MAAM,6BAA6B,KAAK,CAAC;AAEhD;;;;;GAKG;AACH,wBAAgB,eAAe,CAC7B,OAAO,EAAE,4BAA4B,EACrC,WAAW,EAAE,wBAAwB,EACrC,MAAM,GAAE,aAAa,CAAC,iBAAiB,CAA0E,GAChH,YAAY,CA8Cd"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
exports.ERROR_TRANSPORT_CATEGORY = 'error';
exports.TRANSACTION_TRANSPORT_CATEGORY = 'transaction';
exports.ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';
exports.SESSION_TRANSPORT_CATEGORY = 'session';
exports.DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
/**
 * Creates a `NewTransport`
 *
 * @param options
 * @param makeRequest
 */
function createTransport(options, makeRequest, buffer) {
    if (buffer === void 0) { buffer = utils_1.makePromiseBuffer(options.bufferSize || exports.DEFAULT_TRANSPORT_BUFFER_SIZE); }
    var rateLimits = {};
    var flush = function (timeout) { return buffer.drain(timeout); };
    function send(envelope) {
        var envCategory = utils_1.getEnvelopeType(envelope);
        var category = envCategory === 'event' ? 'error' : envCategory;
        var request = {
            category: category,
            body: utils_1.serializeEnvelope(envelope),
        };
        // Don't add to buffer if transport is already rate-limited
        if (utils_1.isRateLimited(rateLimits, category)) {
            return utils_1.rejectedSyncPromise({
                status: 'rate_limit',
                reason: getRateLimitReason(rateLimits, category),
            });
        }
        var requestTask = function () {
            return makeRequest(request).then(function (_a) {
                var body = _a.body, headers = _a.headers, reason = _a.reason, statusCode = _a.statusCode;
                var status = utils_1.eventStatusFromHttpCode(statusCode);
                if (headers) {
                    rateLimits = utils_1.updateRateLimits(rateLimits, headers);
                }
                if (status === 'success') {
                    return utils_1.resolvedSyncPromise({ status: status, reason: reason });
                }
                return utils_1.rejectedSyncPromise({
                    status: status,
                    reason: reason ||
                        body ||
                        (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),
                });
            });
        };
        return buffer.add(requestTask);
    }
    return {
        send: send,
        flush: flush,
    };
}
exports.createTransport = createTransport;
function getRateLimitReason(rateLimits, category) {
    return "Too many " + category + " requests, backing off until: " + new Date(utils_1.disabledUntil(rateLimits, category)).toISOString();
}
//# sourceMappingURL=base.js.map{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/transports/base.ts"],"names":[],"mappings":";AACA,uCAYuB;AAEV,QAAA,wBAAwB,GAAG,OAAO,CAAC;AAEnC,QAAA,8BAA8B,GAAG,aAAa,CAAC;AAE/C,QAAA,6BAA6B,GAAG,YAAY,CAAC;AAE7C,QAAA,0BAA0B,GAAG,SAAS,CAAC;AAuDvC,QAAA,6BAA6B,GAAG,EAAE,CAAC;AAEhD;;;;;GAKG;AACH,SAAgB,eAAe,CAC7B,OAAqC,EACrC,WAAqC,EACrC,MAAiH;IAAjH,uBAAA,EAAA,SAA2C,yBAAiB,CAAC,OAAO,CAAC,UAAU,IAAI,qCAA6B,CAAC;IAEjH,IAAI,UAAU,GAAe,EAAE,CAAC;IAEhC,IAAM,KAAK,GAAG,UAAC,OAAgB,IAA2B,OAAA,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAArB,CAAqB,CAAC;IAEhF,SAAS,IAAI,CAAC,QAAkB;QAC9B,IAAM,WAAW,GAAG,uBAAe,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAM,QAAQ,GAAG,WAAW,KAAK,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAE,WAAiC,CAAC;QACxF,IAAM,OAAO,GAAqB;YAChC,QAAQ,UAAA;YACR,IAAI,EAAE,yBAAiB,CAAC,QAAQ,CAAC;SAClC,CAAC;QAEF,2DAA2D;QAC3D,IAAI,qBAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,EAAE;YACvC,OAAO,2BAAmB,CAAC;gBACzB,MAAM,EAAE,YAAY;gBACpB,MAAM,EAAE,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC;aACjD,CAAC,CAAC;SACJ;QAED,IAAM,WAAW,GAAG;YAClB,OAAA,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,EAAqC;oBAAnC,cAAI,EAAE,oBAAO,EAAE,kBAAM,EAAE,0BAAU;gBAC5D,IAAM,MAAM,GAAG,+BAAuB,CAAC,UAAU,CAAC,CAAC;gBACnD,IAAI,OAAO,EAAE;oBACX,UAAU,GAAG,wBAAgB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;iBACpD;gBACD,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,OAAO,2BAAmB,CAAC,EAAE,MAAM,QAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;iBAChD;gBACD,OAAO,2BAAmB,CAAC;oBACzB,MAAM,QAAA;oBACN,MAAM,EACJ,MAAM;wBACN,IAAI;wBACJ,CAAC,MAAM,KAAK,YAAY,CAAC,CAAC,CAAC,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,yBAAyB,CAAC;iBACnG,CAAC,CAAC;YACL,CAAC,CAAC;QAfF,CAeE,CAAC;QAEL,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACjC,CAAC;IAED,OAAO;QACL,IAAI,MAAA;QACJ,KAAK,OAAA;KACN,CAAC;AACJ,CAAC;AAlDD,0CAkDC;AAED,SAAS,kBAAkB,CAAC,UAAsB,EAAE,QAA2B;IAC7E,OAAO,cAAY,QAAQ,sCAAiC,IAAI,IAAI,CAClE,qBAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,CACpC,CAAC,WAAW,EAAI,CAAC;AACpB,CAAC","sourcesContent":["import { Envelope, EventStatus } from '@sentry/types';\nimport {\n  disabledUntil,\n  eventStatusFromHttpCode,\n  getEnvelopeType,\n  isRateLimited,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const ERROR_TRANSPORT_CATEGORY = 'error';\n\nexport const TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\n\nexport const ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\n\nexport const SESSION_TRANSPORT_CATEGORY = 'session';\n\ntype TransportCategory =\n  | typeof ERROR_TRANSPORT_CATEGORY\n  | typeof TRANSACTION_TRANSPORT_CATEGORY\n  | typeof ATTACHMENT_TRANSPORT_CATEGORY\n  | typeof SESSION_TRANSPORT_CATEGORY;\n\nexport type TransportRequest = {\n  body: string;\n  category: TransportCategory;\n};\n\nexport type TransportMakeRequestResponse = {\n  body?: string;\n  headers?: {\n    [key: string]: string | null;\n    'x-sentry-rate-limits': string | null;\n    'retry-after': string | null;\n  };\n  reason?: string;\n  statusCode: number;\n};\n\nexport type TransportResponse = {\n  status: EventStatus;\n  reason?: string;\n};\n\ninterface InternalBaseTransportOptions {\n  bufferSize?: number;\n}\n\nexport interface BaseTransportOptions extends InternalBaseTransportOptions {\n  // url to send the event\n  // transport does not care about dsn specific - client should take care of\n  // parsing and figuring that out\n  url: string;\n}\n\n// TODO: Move into Browser Transport\nexport interface BrowserTransportOptions extends BaseTransportOptions {\n  // options to pass into fetch request\n  fetchParams: Record<string, string>;\n  headers?: Record<string, string>;\n  sendClientReports?: boolean;\n}\n\nexport interface NewTransport {\n  send(request: Envelope): PromiseLike<TransportResponse>;\n  flush(timeout?: number): PromiseLike<boolean>;\n}\n\nexport type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportResponse> = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n): NewTransport {\n  let rateLimits: RateLimits = {};\n\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportResponse> {\n    const envCategory = getEnvelopeType(envelope);\n    const category = envCategory === 'event' ? 'error' : (envCategory as TransportCategory);\n    const request: TransportRequest = {\n      category,\n      body: serializeEnvelope(envelope),\n    };\n\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category),\n      });\n    }\n\n    const requestTask = (): PromiseLike<TransportResponse> =>\n      makeRequest(request).then(({ body, headers, reason, statusCode }): PromiseLike<TransportResponse> => {\n        const status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({ status, reason });\n        }\n        return rejectedSyncPromise({\n          status,\n          reason:\n            reason ||\n            body ||\n            (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),\n        });\n      });\n\n    return buffer.add(requestTask);\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getRateLimitReason(rateLimits: RateLimits, category: TransportCategory): string {\n  return `Too many ${category} requests, backing off until: ${new Date(\n    disabledUntil(rateLimits, category),\n  ).toISOString()}`;\n}\n"]}import { Event, Response, Transport } from '@sentry/types';
/** Noop transport */
export declare class NoopTransport implements Transport {
    /**
     * @inheritDoc
     */
    sendEvent(_: Event): PromiseLike<Response>;
    /**
     * @inheritDoc
     */
    close(_?: number): PromiseLike<boolean>;
}
//# sourceMappingURL=noop.d.ts.map{"version":3,"file":"noop.d.ts","sourceRoot":"","sources":["../../../src/transports/noop.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAG3D,qBAAqB;AACrB,qBAAa,aAAc,YAAW,SAAS;IAC7C;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC;IAOjD;;OAEG;IACI,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;CAG/C"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
/** Noop transport */
var NoopTransport = /** @class */ (function () {
    function NoopTransport() {
    }
    /**
     * @inheritDoc
     */
    NoopTransport.prototype.sendEvent = function (_) {
        return utils_1.resolvedSyncPromise({
            reason: 'NoopTransport: Event has been skipped because no Dsn is configured.',
            status: 'skipped',
        });
    };
    /**
     * @inheritDoc
     */
    NoopTransport.prototype.close = function (_) {
        return utils_1.resolvedSyncPromise(true);
    };
    return NoopTransport;
}());
exports.NoopTransport = NoopTransport;
//# sourceMappingURL=noop.js.map{"version":3,"file":"noop.js","sourceRoot":"","sources":["../../../src/transports/noop.ts"],"names":[],"mappings":";AACA,uCAAoD;AAEpD,qBAAqB;AACrB;IAAA;IAiBA,CAAC;IAhBC;;OAEG;IACI,iCAAS,GAAhB,UAAiB,CAAQ;QACvB,OAAO,2BAAmB,CAAC;YACzB,MAAM,EAAE,qEAAqE;YAC7E,MAAM,EAAE,SAAS;SAClB,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,6BAAK,GAAZ,UAAa,CAAU;QACrB,OAAO,2BAAmB,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;IACH,oBAAC;AAAD,CAAC,AAjBD,IAiBC;AAjBY,sCAAa","sourcesContent":["import { Event, Response, Transport } from '@sentry/types';\nimport { resolvedSyncPromise } from '@sentry/utils';\n\n/** Noop transport */\nexport class NoopTransport implements Transport {\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    return resolvedSyncPromise({\n      reason: 'NoopTransport: Event has been skipped because no Dsn is configured.',\n      status: 'skipped',\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(_?: number): PromiseLike<boolean> {\n    return resolvedSyncPromise(true);\n  }\n}\n"]}export declare const SDK_VERSION = "6.19.7";
//# sourceMappingURL=version.d.ts.map{"version":3,"file":"version.d.ts","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,WAAW,WAAW,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
exports.SDK_VERSION = '6.19.7';
//# sourceMappingURL=version.js.map{"version":3,"file":"version.js","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":";AAAa,QAAA,WAAW,GAAG,QAAQ,CAAC","sourcesContent":["export const SDK_VERSION = '6.19.7';\n"]}import { DsnComponents, DsnLike, SdkMetadata } from '@sentry/types';
/**
 * Stores details about a Sentry SDK
 */
export interface APIDetails {
    /** The DSN as passed to Sentry.init() */
    initDsn: DsnLike;
    /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */
    metadata: SdkMetadata;
    /** The internally used Dsn object. */
    readonly dsn: DsnComponents;
    /** The envelope tunnel to use. */
    readonly tunnel?: string;
}
/**
 * Helper class to provide urls, headers and metadata that can be used to form
 * different types of requests to Sentry endpoints.
 * Supports both envelopes and regular event requests.
 *
 * @deprecated Please use APIDetails
 **/
export declare class API {
    /** The DSN as passed to Sentry.init() */
    dsn: DsnLike;
    /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */
    metadata: SdkMetadata;
    /** The internally used Dsn object. */
    private readonly _dsnObject;
    /** The envelope tunnel to use. */
    private readonly _tunnel?;
    /** Create a new instance of API */
    constructor(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string);
    /** Returns the Dsn object. */
    getDsn(): DsnComponents;
    /** Does this transport force envelopes? */
    forceEnvelope(): boolean;
    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    getBaseApiEndpoint(): string;
    /** Returns the store endpoint URL. */
    getStoreEndpoint(): string;
    /**
     * Returns the store endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    getStoreEndpointWithUrlEncodedAuth(): string;
    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    getEnvelopeEndpointWithUrlEncodedAuth(): string;
}
/** Initializes API Details */
export declare function initAPIDetails(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string): APIDetails;
/**
 * Returns the store endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export declare function getStoreEndpointWithUrlEncodedAuth(dsn: DsnComponents): string;
/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export declare function getEnvelopeEndpointWithUrlEncodedAuth(dsn: DsnComponents, tunnel?: string): string;
/**
 * Returns an object that can be used in request headers.
 * This is needed for node and the old /store endpoint in sentry
 */
export declare function getRequestHeaders(dsn: DsnComponents, clientName: string, clientVersion: string): {
    [key: string]: string;
};
/** Returns the url to the report dialog endpoint. */
export declare function getReportDialogEndpoint(dsnLike: DsnLike, dialogOptions: {
    [key: string]: any;
    user?: {
        name?: string;
        email?: string;
    };
}): string;
//# sourceMappingURL=api.d.ts.map{"version":3,"file":"api.d.ts","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAKpE;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB,yCAAyC;IACzC,OAAO,EAAE,OAAO,CAAC;IACjB,oFAAoF;IACpF,QAAQ,EAAE,WAAW,CAAC;IACtB,sCAAsC;IACtC,QAAQ,CAAC,GAAG,EAAE,aAAa,CAAC;IAC5B,kCAAkC;IAClC,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC;CAC1B;AAED;;;;;;IAMI;AACJ,qBAAa,GAAG;IACd,yCAAyC;IAClC,GAAG,EAAE,OAAO,CAAC;IAEpB,oFAAoF;IAC7E,QAAQ,EAAE,WAAW,CAAC;IAE7B,sCAAsC;IACtC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAgB;IAE3C,kCAAkC;IAClC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAS;IAElC,mCAAmC;gBAChB,GAAG,EAAE,OAAO,EAAE,QAAQ,GAAE,WAAgB,EAAE,MAAM,CAAC,EAAE,MAAM;IAO5E,8BAA8B;IACvB,MAAM,IAAI,aAAa;IAI9B,2CAA2C;IACpC,aAAa,IAAI,OAAO;IAI/B,sEAAsE;IAC/D,kBAAkB,IAAI,MAAM;IAInC,sCAAsC;IAC/B,gBAAgB,IAAI,MAAM;IAIjC;;;;OAIG;IACI,kCAAkC,IAAI,MAAM;IAInD;;;;OAIG;IACI,qCAAqC,IAAI,MAAM;CAGvD;AAED,8BAA8B;AAC9B,wBAAgB,cAAc,CAAC,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,WAAW,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,UAAU,CAOhG;AA6BD;;;;GAIG;AACH,wBAAgB,kCAAkC,CAAC,GAAG,EAAE,aAAa,GAAG,MAAM,CAE7E;AAOD;;;;GAIG;AACH,wBAAgB,qCAAqC,CAAC,GAAG,EAAE,aAAa,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,MAAM,CAEjG;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAC/B,GAAG,EAAE,aAAa,EAClB,UAAU,EAAE,MAAM,EAClB,aAAa,EAAE,MAAM,GACpB;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;CAAE,CAY3B;AAED,qDAAqD;AACrD,wBAAgB,uBAAuB,CACrC,OAAO,EAAE,OAAO,EAChB,aAAa,EAAE;IAEb,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAE,CAAC;CAC1C,GACA,MAAM,CA0BR"}import { dsnToString, makeDsn, urlEncode } from '@sentry/utils';
var SENTRY_API_VERSION = '7';
/**
 * Helper class to provide urls, headers and metadata that can be used to form
 * different types of requests to Sentry endpoints.
 * Supports both envelopes and regular event requests.
 *
 * @deprecated Please use APIDetails
 **/
var API = /** @class */ (function () {
    /** Create a new instance of API */
    function API(dsn, metadata, tunnel) {
        if (metadata === void 0) { metadata = {}; }
        this.dsn = dsn;
        this._dsnObject = makeDsn(dsn);
        this.metadata = metadata;
        this._tunnel = tunnel;
    }
    /** Returns the Dsn object. */
    API.prototype.getDsn = function () {
        return this._dsnObject;
    };
    /** Does this transport force envelopes? */
    API.prototype.forceEnvelope = function () {
        return !!this._tunnel;
    };
    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    API.prototype.getBaseApiEndpoint = function () {
        return getBaseApiEndpoint(this._dsnObject);
    };
    /** Returns the store endpoint URL. */
    API.prototype.getStoreEndpoint = function () {
        return getStoreEndpoint(this._dsnObject);
    };
    /**
     * Returns the store endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    API.prototype.getStoreEndpointWithUrlEncodedAuth = function () {
        return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
    };
    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    API.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function () {
        return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
    };
    return API;
}());
export { API };
/** Initializes API Details */
export function initAPIDetails(dsn, metadata, tunnel) {
    return {
        initDsn: dsn,
        metadata: metadata || {},
        dsn: makeDsn(dsn),
        tunnel: tunnel,
    };
}
/** Returns the prefix to construct Sentry ingestion API endpoints. */
function getBaseApiEndpoint(dsn) {
    var protocol = dsn.protocol ? dsn.protocol + ":" : '';
    var port = dsn.port ? ":" + dsn.port : '';
    return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : '') + "/api/";
}
/** Returns the ingest API endpoint for target. */
function _getIngestEndpoint(dsn, target) {
    return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
}
/** Returns a URL-encoded string with auth config suitable for a query string. */
function _encodedAuth(dsn) {
    return urlEncode({
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION,
    });
}
/** Returns the store endpoint URL. */
function getStoreEndpoint(dsn) {
    return _getIngestEndpoint(dsn, 'store');
}
/**
 * Returns the store endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export function getStoreEndpointWithUrlEncodedAuth(dsn) {
    return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
}
/** Returns the envelope endpoint URL. */
function _getEnvelopeEndpoint(dsn) {
    return _getIngestEndpoint(dsn, 'envelope');
}
/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
    return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
}
/**
 * Returns an object that can be used in request headers.
 * This is needed for node and the old /store endpoint in sentry
 */
export function getRequestHeaders(dsn, clientName, clientVersion) {
    // CHANGE THIS to use metadata but keep clientName and clientVersion compatible
    var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
    header.push("sentry_client=" + clientName + "/" + clientVersion);
    header.push("sentry_key=" + dsn.publicKey);
    if (dsn.pass) {
        header.push("sentry_secret=" + dsn.pass);
    }
    return {
        'Content-Type': 'application/json',
        'X-Sentry-Auth': header.join(', '),
    };
}
/** Returns the url to the report dialog endpoint. */
export function getReportDialogEndpoint(dsnLike, dialogOptions) {
    var dsn = makeDsn(dsnLike);
    var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
    var encodedOptions = "dsn=" + dsnToString(dsn);
    for (var key in dialogOptions) {
        if (key === 'dsn') {
            continue;
        }
        if (key === 'user') {
            if (!dialogOptions.user) {
                continue;
            }
            if (dialogOptions.user.name) {
                encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
            }
            if (dialogOptions.user.email) {
                encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
            }
        }
        else {
            encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
        }
    }
    return endpoint + "?" + encodedOptions;
}
//# sourceMappingURL=api.js.map{"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"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","sourcesContent":["import { DsnComponents, DsnLike, SdkMetadata } from '@sentry/types';\nimport { dsnToString, makeDsn, urlEncode } from '@sentry/utils';\n\nconst SENTRY_API_VERSION = '7';\n\n/**\n * Stores details about a Sentry SDK\n */\nexport interface APIDetails {\n  /** The DSN as passed to Sentry.init() */\n  initDsn: DsnLike;\n  /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */\n  metadata: SdkMetadata;\n  /** The internally used Dsn object. */\n  readonly dsn: DsnComponents;\n  /** The envelope tunnel to use. */\n  readonly tunnel?: string;\n}\n\n/**\n * Helper class to provide urls, headers and metadata that can be used to form\n * different types of requests to Sentry endpoints.\n * Supports both envelopes and regular event requests.\n *\n * @deprecated Please use APIDetails\n **/\nexport class API {\n  /** The DSN as passed to Sentry.init() */\n  public dsn: DsnLike;\n\n  /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */\n  public metadata: SdkMetadata;\n\n  /** The internally used Dsn object. */\n  private readonly _dsnObject: DsnComponents;\n\n  /** The envelope tunnel to use. */\n  private readonly _tunnel?: string;\n\n  /** Create a new instance of API */\n  public constructor(dsn: DsnLike, metadata: SdkMetadata = {}, tunnel?: string) {\n    this.dsn = dsn;\n    this._dsnObject = makeDsn(dsn);\n    this.metadata = metadata;\n    this._tunnel = tunnel;\n  }\n\n  /** Returns the Dsn object. */\n  public getDsn(): DsnComponents {\n    return this._dsnObject;\n  }\n\n  /** Does this transport force envelopes? */\n  public forceEnvelope(): boolean {\n    return !!this._tunnel;\n  }\n\n  /** Returns the prefix to construct Sentry ingestion API endpoints. */\n  public getBaseApiEndpoint(): string {\n    return getBaseApiEndpoint(this._dsnObject);\n  }\n\n  /** Returns the store endpoint URL. */\n  public getStoreEndpoint(): string {\n    return getStoreEndpoint(this._dsnObject);\n  }\n\n  /**\n   * Returns the store endpoint URL with auth in the query string.\n   *\n   * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n   */\n  public getStoreEndpointWithUrlEncodedAuth(): string {\n    return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);\n  }\n\n  /**\n   * Returns the envelope endpoint URL with auth in the query string.\n   *\n   * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n   */\n  public getEnvelopeEndpointWithUrlEncodedAuth(): string {\n    return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);\n  }\n}\n\n/** Initializes API Details */\nexport function initAPIDetails(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string): APIDetails {\n  return {\n    initDsn: dsn,\n    metadata: metadata || {},\n    dsn: makeDsn(dsn),\n    tunnel,\n  } as APIDetails;\n}\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn: DsnComponents): string {\n  const protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  const port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn: DsnComponents, target: 'store' | 'envelope'): string {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/${target}/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn: DsnComponents): string {\n  return urlEncode({\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    sentry_key: dsn.publicKey,\n    sentry_version: SENTRY_API_VERSION,\n  });\n}\n\n/** Returns the store endpoint URL. */\nfunction getStoreEndpoint(dsn: DsnComponents): string {\n  return _getIngestEndpoint(dsn, 'store');\n}\n\n/**\n * Returns the store endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nexport function getStoreEndpointWithUrlEncodedAuth(dsn: DsnComponents): string {\n  return `${getStoreEndpoint(dsn)}?${_encodedAuth(dsn)}`;\n}\n\n/** Returns the envelope endpoint URL. */\nfunction _getEnvelopeEndpoint(dsn: DsnComponents): string {\n  return _getIngestEndpoint(dsn, 'envelope');\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nexport function getEnvelopeEndpointWithUrlEncodedAuth(dsn: DsnComponents, tunnel?: string): string {\n  return tunnel ? tunnel : `${_getEnvelopeEndpoint(dsn)}?${_encodedAuth(dsn)}`;\n}\n\n/**\n * Returns an object that can be used in request headers.\n * This is needed for node and the old /store endpoint in sentry\n */\nexport function getRequestHeaders(\n  dsn: DsnComponents,\n  clientName: string,\n  clientVersion: string,\n): { [key: string]: string } {\n  // CHANGE THIS to use metadata but keep clientName and clientVersion compatible\n  const header = [`Sentry sentry_version=${SENTRY_API_VERSION}`];\n  header.push(`sentry_client=${clientName}/${clientVersion}`);\n  header.push(`sentry_key=${dsn.publicKey}`);\n  if (dsn.pass) {\n    header.push(`sentry_secret=${dsn.pass}`);\n  }\n  return {\n    'Content-Type': 'application/json',\n    'X-Sentry-Auth': header.join(', '),\n  };\n}\n\n/** Returns the url to the report dialog endpoint. */\nexport function getReportDialogEndpoint(\n  dsnLike: DsnLike,\n  dialogOptions: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any;\n    user?: { name?: string; email?: string };\n  },\n): string {\n  const dsn = makeDsn(dsnLike);\n  const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsnToString(dsn)}`;\n  for (const key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'user') {\n      if (!dialogOptions.user) {\n        continue;\n      }\n      if (dialogOptions.user.name) {\n        encodedOptions += `&name=${encodeURIComponent(dialogOptions.user.name)}`;\n      }\n      if (dialogOptions.user.email) {\n        encodedOptions += `&email=${encodeURIComponent(dialogOptions.user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] as string)}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n"]}import { Event, EventHint, Options, Session, Severity, Transport } from '@sentry/types';
import { NewTransport } from './transports/base';
/**
 * Internal platform-dependent Sentry SDK Backend.
 *
 * While {@link Client} contains business logic specific to an SDK, the
 * Backend offers platform specific implementations for low-level operations.
 * These are persisting and loading information, sending events, and hooking
 * into the environment.
 *
 * Backends receive a handle to the Client in their constructor. When a
 * Backend automatically generates events, it must pass them to
 * the Client for validation and processing first.
 *
 * Usually, the Client will be of corresponding type, e.g. NodeBackend
 * receives NodeClient. However, higher-level SDKs can choose to instantiate
 * multiple Backends and delegate tasks between them. In this case, an event
 * generated by one backend might very well be sent by another one.
 *
 * The client also provides access to options via {@link Client.getOptions}.
 * @hidden
 */
export interface Backend {
    /** Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`. */
    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;
    /** Creates an {@link Event} from primitive inputs to `captureMessage`. */
    eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;
    /** Submits the event to Sentry */
    sendEvent(event: Event): void;
    /** Submits the session to Sentry */
    sendSession(session: Session): void;
    /**
     * Returns the transport that is used by the backend.
     * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
     *
     * @returns The transport.
     */
    getTransport(): Transport;
}
/**
 * A class object that can instantiate Backend objects.
 * @hidden
 */
export declare type BackendClass<B extends Backend, O extends Options> = new (options: O) => B;
/**
 * This is the base implemention of a Backend.
 * @hidden
 */
export declare abstract class BaseBackend<O extends Options> implements Backend {
    /** Options passed to the SDK. */
    protected readonly _options: O;
    /** Cached transport used internally. */
    protected _transport: Transport;
    /** New v7 Transport that is initialized alongside the old one */
    protected _newTransport?: NewTransport;
    /** Creates a new backend instance. */
    constructor(options: O);
    /**
     * @inheritDoc
     */
    eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    eventFromMessage(_message: string, _level?: Severity, _hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): void;
    /**
     * @inheritDoc
     */
    sendSession(session: Session): void;
    /**
     * @inheritDoc
     */
    getTransport(): Transport;
    /**
     * Sets up the transport so it can be used later to send requests.
     */
    protected _setupTransport(): Transport;
}
//# sourceMappingURL=basebackend.d.ts.map{"version":3,"file":"basebackend.d.ts","sourceRoot":"","sources":["../../src/basebackend.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAMxF,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAGjD;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,WAAW,OAAO;IACtB,mHAAmH;IAEnH,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;IAEzE,0EAA0E;IAC1E,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;IAE1F,kCAAkC;IAClC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;IAE9B,oCAAoC;IACpC,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC;IAEpC;;;;;OAKG;IACH,YAAY,IAAI,SAAS,CAAC;CAC3B;AAED;;;GAGG;AACH,oBAAY,YAAY,CAAC,CAAC,SAAS,OAAO,EAAE,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAEvF;;;GAGG;AACH,8BAAsB,WAAW,CAAC,CAAC,SAAS,OAAO,CAAE,YAAW,OAAO;IACrE,iCAAiC;IACjC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,wCAAwC;IACxC,SAAS,CAAC,UAAU,EAAE,SAAS,CAAC;IAEhC,iEAAiE;IACjE,SAAS,CAAC,aAAa,CAAC,EAAE,YAAY,CAAC;IAEvC,sCAAsC;gBACnB,OAAO,EAAE,CAAC;IAQ7B;;OAEG;IAEI,kBAAkB,CAAC,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAIjF;;OAEG;IACI,gBAAgB,CAAC,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAInG;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAoBpC;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAyB1C;;OAEG;IACI,YAAY,IAAI,SAAS;IAIhC;;OAEG;IACH,SAAS,CAAC,eAAe,IAAI,SAAS;CAGvC"}import { __read } from "tslib";
import { logger, SentryError } from '@sentry/utils';
import { initAPIDetails } from './api';
import { IS_DEBUG_BUILD } from './flags';
import { createEventEnvelope, createSessionEnvelope } from './request';
import { NoopTransport } from './transports/noop';
/**
 * This is the base implemention of a Backend.
 * @hidden
 */
var BaseBackend = /** @class */ (function () {
    /** Creates a new backend instance. */
    function BaseBackend(options) {
        this._options = options;
        if (!this._options.dsn) {
            IS_DEBUG_BUILD && logger.warn('No DSN provided, backend will not do anything.');
        }
        this._transport = this._setupTransport();
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    BaseBackend.prototype.eventFromException = function (_exception, _hint) {
        throw new SentryError('Backend has to implement `eventFromException` method');
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.eventFromMessage = function (_message, _level, _hint) {
        throw new SentryError('Backend has to implement `eventFromMessage` method');
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.sendEvent = function (event) {
        // TODO(v7): Remove the if-else
        if (this._newTransport &&
            this._options.dsn &&
            this._options._experiments &&
            this._options._experiments.newTransport) {
            var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
            var env = createEventEnvelope(event, api);
            void this._newTransport.send(env).then(null, function (reason) {
                IS_DEBUG_BUILD && logger.error('Error while sending event:', reason);
            });
        }
        else {
            void this._transport.sendEvent(event).then(null, function (reason) {
                IS_DEBUG_BUILD && logger.error('Error while sending event:', reason);
            });
        }
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.sendSession = function (session) {
        if (!this._transport.sendSession) {
            IS_DEBUG_BUILD && logger.warn("Dropping session because custom transport doesn't implement sendSession");
            return;
        }
        // TODO(v7): Remove the if-else
        if (this._newTransport &&
            this._options.dsn &&
            this._options._experiments &&
            this._options._experiments.newTransport) {
            var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
            var _a = __read(createSessionEnvelope(session, api), 1), env = _a[0];
            void this._newTransport.send(env).then(null, function (reason) {
                IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);
            });
        }
        else {
            void this._transport.sendSession(session).then(null, function (reason) {
                IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);
            });
        }
    };
    /**
     * @inheritDoc
     */
    BaseBackend.prototype.getTransport = function () {
        return this._transport;
    };
    /**
     * Sets up the transport so it can be used later to send requests.
     */
    BaseBackend.prototype._setupTransport = function () {
        return new NoopTransport();
    };
    return BaseBackend;
}());
export { BaseBackend };
//# sourceMappingURL=basebackend.js.map{"version":3,"file":"basebackend.js","sourceRoot":"","sources":["../../src/basebackend.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventHint, Options, Session, Severity, Transport } from '@sentry/types';\nimport { logger, SentryError } from '@sentry/utils';\n\nimport { initAPIDetails } from './api';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { createEventEnvelope, createSessionEnvelope } from './request';\nimport { NewTransport } from './transports/base';\nimport { NoopTransport } from './transports/noop';\n\n/**\n * Internal platform-dependent Sentry SDK Backend.\n *\n * While {@link Client} contains business logic specific to an SDK, the\n * Backend offers platform specific implementations for low-level operations.\n * These are persisting and loading information, sending events, and hooking\n * into the environment.\n *\n * Backends receive a handle to the Client in their constructor. When a\n * Backend automatically generates events, it must pass them to\n * the Client for validation and processing first.\n *\n * Usually, the Client will be of corresponding type, e.g. NodeBackend\n * receives NodeClient. However, higher-level SDKs can choose to instantiate\n * multiple Backends and delegate tasks between them. In this case, an event\n * generated by one backend might very well be sent by another one.\n *\n * The client also provides access to options via {@link Client.getOptions}.\n * @hidden\n */\nexport interface Backend {\n  /** Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;\n\n  /** Creates an {@link Event} from primitive inputs to `captureMessage`. */\n  eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;\n\n  /** Submits the event to Sentry */\n  sendEvent(event: Event): void;\n\n  /** Submits the session to Sentry */\n  sendSession(session: Session): void;\n\n  /**\n   * Returns the transport that is used by the backend.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   *\n   * @returns The transport.\n   */\n  getTransport(): Transport;\n}\n\n/**\n * A class object that can instantiate Backend objects.\n * @hidden\n */\nexport type BackendClass<B extends Backend, O extends Options> = new (options: O) => B;\n\n/**\n * This is the base implemention of a Backend.\n * @hidden\n */\nexport abstract class BaseBackend<O extends Options> implements Backend {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** Cached transport used internally. */\n  protected _transport: Transport;\n\n  /** New v7 Transport that is initialized alongside the old one */\n  protected _newTransport?: NewTransport;\n\n  /** Creates a new backend instance. */\n  public constructor(options: O) {\n    this._options = options;\n    if (!this._options.dsn) {\n      IS_DEBUG_BUILD && logger.warn('No DSN provided, backend will not do anything.');\n    }\n    this._transport = this._setupTransport();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event> {\n    throw new SentryError('Backend has to implement `eventFromException` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(_message: string, _level?: Severity, _hint?: EventHint): PromiseLike<Event> {\n    throw new SentryError('Backend has to implement `eventFromMessage` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): void {\n    // TODO(v7): Remove the if-else\n    if (\n      this._newTransport &&\n      this._options.dsn &&\n      this._options._experiments &&\n      this._options._experiments.newTransport\n    ) {\n      const api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);\n      const env = createEventEnvelope(event, api);\n      void this._newTransport.send(env).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      void this._transport.sendEvent(event).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending event:', reason);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): void {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n\n    // TODO(v7): Remove the if-else\n    if (\n      this._newTransport &&\n      this._options.dsn &&\n      this._options._experiments &&\n      this._options._experiments.newTransport\n    ) {\n      const api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);\n      const [env] = createSessionEnvelope(session, api);\n      void this._newTransport.send(env).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n      });\n    } else {\n      void this._transport.sendSession(session).then(null, reason => {\n        IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport {\n    return this._transport;\n  }\n\n  /**\n   * Sets up the transport so it can be used later to send requests.\n   */\n  protected _setupTransport(): Transport {\n    return new NoopTransport();\n  }\n}\n"]}import { Scope, Session } from '@sentry/hub';
import { Client, DsnComponents, Event, EventHint, Integration, IntegrationClass, Options, Severity, Transport } from '@sentry/types';
import { Backend, BackendClass } from './basebackend';
import { IntegrationIndex } from './integration';
/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding backend constructor and options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}. Also, the Backend instance is available via
 * {@link Client.getBackend}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event via the backend, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(NodeBackend, options);
 *   }
 *
 *   // ...
 * }
 */
export declare abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {
    /**
     * The backend used to physically interact in the environment. Usually, this
     * will correspond to the client. When composing SDKs, however, the Backend
     * from the root SDK will be used.
     */
    protected readonly _backend: B;
    /** Options passed to the SDK. */
    protected readonly _options: O;
    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
    protected readonly _dsn?: DsnComponents;
    /** Array of used integrations. */
    protected _integrations: IntegrationIndex;
    /** Number of calls being processed */
    protected _numProcessing: number;
    /**
     * Initializes this client instance.
     *
     * @param backendClass A constructor function to create the backend.
     * @param options Options for the client.
     */
    protected constructor(backendClass: BackendClass<B, O>, options: O);
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureSession(session: Session): void;
    /**
     * @inheritDoc
     */
    getDsn(): DsnComponents | undefined;
    /**
     * @inheritDoc
     */
    getOptions(): O;
    /**
     * @inheritDoc
     */
    getTransport(): Transport;
    /**
     * @inheritDoc
     */
    flush(timeout?: number): PromiseLike<boolean>;
    /**
     * @inheritDoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Sets up the integrations
     */
    setupIntegrations(): void;
    /**
     * @inheritDoc
     */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** Updates existing session based on the provided event */
    protected _updateSessionFromEvent(session: Session, event: Event): void;
    /** Deliver captured session to Sentry */
    protected _sendSession(session: Session): void;
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean>;
    /** Returns the current backend. */
    protected _getBackend(): B;
    /** Determines whether this SDK is enabled and a valid Dsn is present. */
    protected _isEnabled(): boolean;
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
     * Normalized keys:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * @param event Event
     * @returns Normalized event
     */
    protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null;
    /**
     *  Enhances event using the client configuration.
     *  It takes care of all "static" values like environment, release and `dist`,
     *  as well as truncating overly long values.
     * @param event event instance to be enhanced
     */
    protected _applyClientOptions(event: Event): void;
    /**
     * This function adds all used integrations to the SDK info in the event.
     * @param event The event that will be filled with all integrations.
     */
    protected _applyIntegrationsMetadata(event: Event): void;
    /**
     * Tells the backend to send this event
     * @param event The Sentry event to send
     */
    protected _sendEvent(event: Event): void;
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined>;
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event>;
    /**
     * Occupies the client with processing and event
     */
    protected _process<T>(promise: PromiseLike<T>): void;
}
//# sourceMappingURL=baseclient.d.ts.map{"version":3,"file":"baseclient.d.ts","sourceRoot":"","sources":["../../src/baseclient.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,EACL,MAAM,EACN,aAAa,EACb,KAAK,EACL,SAAS,EACT,WAAW,EACX,gBAAgB,EAChB,OAAO,EACP,QAAQ,EACR,SAAS,EACV,MAAM,eAAe,CAAC;AAkBvB,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAEtD,OAAO,EAAE,gBAAgB,EAAqB,MAAM,eAAe,CAAC;AAIpE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,8BAAsB,UAAU,CAAC,CAAC,SAAS,OAAO,EAAE,CAAC,SAAS,OAAO,CAAE,YAAW,MAAM,CAAC,CAAC,CAAC;IACzF;;;;OAIG;IACH,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,iCAAiC;IACjC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,2FAA2F;IAC3F,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,aAAa,CAAC;IAExC,kCAAkC;IAClC,SAAS,CAAC,aAAa,EAAE,gBAAgB,CAAM;IAE/C,sCAAsC;IACtC,SAAS,CAAC,cAAc,EAAE,MAAM,CAAK;IAErC;;;;;OAKG;IACH,SAAS,aAAa,YAAY,EAAE,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC;IASlE;;OAEG;IAEI,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAqB5F;;OAEG;IACI,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAkB7G;;OAEG;IACI,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAkBtF;;OAEG;IACI,cAAc,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAe7C;;OAEG;IACI,MAAM,IAAI,aAAa,GAAG,SAAS;IAI1C;;OAEG;IACI,UAAU,IAAI,CAAC;IAItB;;OAEG;IACI,YAAY,IAAI,SAAS;IAIhC;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAQpD;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAOpD;;OAEG;IACI,iBAAiB,IAAI,IAAI;IAMhC;;OAEG;IACI,cAAc,CAAC,CAAC,SAAS,WAAW,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI;IASxF,2DAA2D;IAC3D,SAAS,CAAC,uBAAuB,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI;IAgCvE,yCAAyC;IACzC,SAAS,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAI9C;;;;;;;;;OASG;IACH,SAAS,CAAC,uBAAuB,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAoBzE,mCAAmC;IACnC,SAAS,CAAC,WAAW,IAAI,CAAC;IAI1B,yEAAyE;IACzE,SAAS,CAAC,UAAU,IAAI,OAAO;IAI/B;;;;;;;;;;;;;OAaG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IA4CjG;;;;;;;;;OASG;IACH,SAAS,CAAC,eAAe,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,GAAG,KAAK,GAAG,IAAI;IA0C/F;;;;;OAKG;IACH,SAAS,CAAC,mBAAmB,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IA+BjD;;;OAGG;IACH,SAAS,CAAC,0BAA0B,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAQxD;;;OAGG;IACH,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAIxC;;;;;OAKG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,MAAM,GAAG,SAAS,CAAC;IAYvG;;;;;;;;;;;;OAYG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;IA6E1F;;OAEG;IACH,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI;CAarD"}import { __assign, __read, __spread, __values } from "tslib";
/* eslint-disable max-lines */
import { Scope } from '@sentry/hub';
import { checkOrSetAlreadyCaught, dateTimestampInSeconds, isPlainObject, isPrimitive, isThenable, logger, makeDsn, normalize, rejectedSyncPromise, resolvedSyncPromise, SentryError, SyncPromise, truncate, uuid4, } from '@sentry/utils';
import { IS_DEBUG_BUILD } from './flags';
import { setupIntegrations } from './integration';
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding backend constructor and options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}. Also, the Backend instance is available via
 * {@link Client.getBackend}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event via the backend, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(NodeBackend, options);
 *   }
 *
 *   // ...
 * }
 */
var BaseClient = /** @class */ (function () {
    /**
     * Initializes this client instance.
     *
     * @param backendClass A constructor function to create the backend.
     * @param options Options for the client.
     */
    function BaseClient(backendClass, options) {
        /** Array of used integrations. */
        this._integrations = {};
        /** Number of calls being processed */
        this._numProcessing = 0;
        this._backend = new backendClass(options);
        this._options = options;
        if (options.dsn) {
            this._dsn = makeDsn(options.dsn);
        }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    BaseClient.prototype.captureException = function (exception, hint, scope) {
        var _this = this;
        // ensure we haven't captured this very object before
        if (checkOrSetAlreadyCaught(exception)) {
            IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
            return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._getBackend()
            .eventFromException(exception, hint)
            .then(function (event) { return _this._captureEvent(event, hint, scope); })
            .then(function (result) {
            eventId = result;
        }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.captureMessage = function (message, level, hint, scope) {
        var _this = this;
        var eventId = hint && hint.event_id;
        var promisedEvent = isPrimitive(message)
            ? this._getBackend().eventFromMessage(String(message), level, hint)
            : this._getBackend().eventFromException(message, hint);
        this._process(promisedEvent
            .then(function (event) { return _this._captureEvent(event, hint, scope); })
            .then(function (result) {
            eventId = result;
        }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.captureEvent = function (event, hint, scope) {
        // ensure we haven't captured this very object before
        if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
            IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
            return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._captureEvent(event, hint, scope).then(function (result) {
            eventId = result;
        }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.captureSession = function (session) {
        if (!this._isEnabled()) {
            IS_DEBUG_BUILD && logger.warn('SDK not enabled, will not capture session.');
            return;
        }
        if (!(typeof session.release === 'string')) {
            IS_DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');
        }
        else {
            this._sendSession(session);
            // After sending, we set init false to indicate it's not the first occurrence
            session.update({ init: false });
        }
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getDsn = function () {
        return this._dsn;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getOptions = function () {
        return this._options;
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getTransport = function () {
        return this._getBackend().getTransport();
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.flush = function (timeout) {
        var _this = this;
        return this._isClientDoneProcessing(timeout).then(function (clientFinished) {
            return _this.getTransport()
                .close(timeout)
                .then(function (transportFlushed) { return clientFinished && transportFlushed; });
        });
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.close = function (timeout) {
        var _this = this;
        return this.flush(timeout).then(function (result) {
            _this.getOptions().enabled = false;
            return result;
        });
    };
    /**
     * Sets up the integrations
     */
    BaseClient.prototype.setupIntegrations = function () {
        if (this._isEnabled() && !this._integrations.initialized) {
            this._integrations = setupIntegrations(this._options);
        }
    };
    /**
     * @inheritDoc
     */
    BaseClient.prototype.getIntegration = function (integration) {
        try {
            return this._integrations[integration.id] || null;
        }
        catch (_oO) {
            IS_DEBUG_BUILD && logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
            return null;
        }
    };
    /** Updates existing session based on the provided event */
    BaseClient.prototype._updateSessionFromEvent = function (session, event) {
        var e_1, _a;
        var crashed = false;
        var errored = false;
        var exceptions = event.exception && event.exception.values;
        if (exceptions) {
            errored = true;
            try {
                for (var exceptions_1 = __values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
                    var ex = exceptions_1_1.value;
                    var mechanism = ex.mechanism;
                    if (mechanism && mechanism.handled === false) {
                        crashed = true;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // A session is updated and that session update is sent in only one of the two following scenarios:
        // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
        // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update
        var sessionNonTerminal = session.status === 'ok';
        var shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);
        if (shouldUpdateAndSend) {
            session.update(__assign(__assign({}, (crashed && { status: 'crashed' })), { errors: session.errors || Number(errored || crashed) }));
            this.captureSession(session);
        }
    };
    /** Deliver captured session to Sentry */
    BaseClient.prototype._sendSession = function (session) {
        this._getBackend().sendSession(session);
    };
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    BaseClient.prototype._isClientDoneProcessing = function (timeout) {
        var _this = this;
        return new SyncPromise(function (resolve) {
            var ticked = 0;
            var tick = 1;
            var interval = setInterval(function () {
                if (_this._numProcessing == 0) {
                    clearInterval(interval);
                    resolve(true);
                }
                else {
                    ticked += tick;
                    if (timeout && ticked >= timeout) {
                        clearInterval(interval);
                        resolve(false);
                    }
                }
            }, tick);
        });
    };
    /** Returns the current backend. */
    BaseClient.prototype._getBackend = function () {
        return this._backend;
    };
    /** Determines whether this SDK is enabled and a valid Dsn is present. */
    BaseClient.prototype._isEnabled = function () {
        return this.getOptions().enabled !== false && this._dsn !== undefined;
    };
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    BaseClient.prototype._prepareEvent = function (event, scope, hint) {
        var _this = this;
        var _a = this.getOptions(), _b = _a.normalizeDepth, normalizeDepth = _b === void 0 ? 3 : _b, _c = _a.normalizeMaxBreadth, normalizeMaxBreadth = _c === void 0 ? 1000 : _c;
        var prepared = __assign(__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()), timestamp: event.timestamp || dateTimestampInSeconds() });
        this._applyClientOptions(prepared);
        this._applyIntegrationsMetadata(prepared);
        // If we have scope given to us, use it as the base for further modifications.
        // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
        var finalScope = scope;
        if (hint && hint.captureContext) {
            finalScope = Scope.clone(finalScope).update(hint.captureContext);
        }
        // We prepare the result here with a resolved Event.
        var result = resolvedSyncPromise(prepared);
        // This should be the last thing called, since we want that
        // {@link Hub.addEventProcessor} gets the finished prepared event.
        if (finalScope) {
            // In case we have a hub we reassign it.
            result = finalScope.applyToEvent(prepared, hint);
        }
        return result.then(function (evt) {
            if (evt) {
                // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809
                // it is only attached as extra data to the event if the event somehow skips being normalized
                evt.sdkProcessingMetadata = __assign(__assign({}, evt.sdkProcessingMetadata), { normalizeDepth: normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")" });
            }
            if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
                return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
            }
            return evt;
        });
    };
    /**
     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
     * Normalized keys:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * @param event Event
     * @returns Normalized event
     */
    BaseClient.prototype._normalizeEvent = function (event, depth, maxBreadth) {
        if (!event) {
            return null;
        }
        var normalized = __assign(__assign(__assign(__assign(__assign({}, event), (event.breadcrumbs && {
            breadcrumbs: event.breadcrumbs.map(function (b) { return (__assign(__assign({}, b), (b.data && {
                data: normalize(b.data, depth, maxBreadth),
            }))); }),
        })), (event.user && {
            user: normalize(event.user, depth, maxBreadth),
        })), (event.contexts && {
            contexts: normalize(event.contexts, depth, maxBreadth),
        })), (event.extra && {
            extra: normalize(event.extra, depth, maxBreadth),
        }));
        // event.contexts.trace stores information about a Transaction. Similarly,
        // event.spans[] stores information about child Spans. Given that a
        // Transaction is conceptually a Span, normalization should apply to both
        // Transactions and Spans consistently.
        // For now the decision is to skip normalization of Transactions and Spans,
        // so this block overwrites the normalized event to add back the original
        // Transaction information prior to normalization.
        if (event.contexts && event.contexts.trace) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            normalized.contexts.trace = event.contexts.trace;
        }
        normalized.sdkProcessingMetadata = __assign(__assign({}, normalized.sdkProcessingMetadata), { baseClientNormalized: true });
        return normalized;
    };
    /**
     *  Enhances event using the client configuration.
     *  It takes care of all "static" values like environment, release and `dist`,
     *  as well as truncating overly long values.
     * @param event event instance to be enhanced
     */
    BaseClient.prototype._applyClientOptions = function (event) {
        var options = this.getOptions();
        var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
        if (!('environment' in event)) {
            event.environment = 'environment' in options ? environment : 'production';
        }
        if (event.release === undefined && release !== undefined) {
            event.release = release;
        }
        if (event.dist === undefined && dist !== undefined) {
            event.dist = dist;
        }
        if (event.message) {
            event.message = truncate(event.message, maxValueLength);
        }
        var exception = event.exception && event.exception.values && event.exception.values[0];
        if (exception && exception.value) {
            exception.value = truncate(exception.value, maxValueLength);
        }
        var request = event.request;
        if (request && request.url) {
            request.url = truncate(request.url, maxValueLength);
        }
    };
    /**
     * This function adds all used integrations to the SDK info in the event.
     * @param event The event that will be filled with all integrations.
     */
    BaseClient.prototype._applyIntegrationsMetadata = function (event) {
        var integrationsArray = Object.keys(this._integrations);
        if (integrationsArray.length > 0) {
            event.sdk = event.sdk || {};
            event.sdk.integrations = __spread((event.sdk.integrations || []), integrationsArray);
        }
    };
    /**
     * Tells the backend to send this event
     * @param event The Sentry event to send
     */
    BaseClient.prototype._sendEvent = function (event) {
        this._getBackend().sendEvent(event);
    };
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    BaseClient.prototype._captureEvent = function (event, hint, scope) {
        return this._processEvent(event, hint, scope).then(function (finalEvent) {
            return finalEvent.event_id;
        }, function (reason) {
            IS_DEBUG_BUILD && logger.error(reason);
            return undefined;
        });
    };
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    BaseClient.prototype._processEvent = function (event, hint, scope) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
        var transport = this.getTransport();
        function recordLostEvent(outcome, category) {
            if (transport.recordLostEvent) {
                transport.recordLostEvent(outcome, category);
            }
        }
        if (!this._isEnabled()) {
            return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.'));
        }
        var isTransaction = event.type === 'transaction';
        // 1.0 === 100% events are sent
        // 0.0 === 0% events are sent
        // Sampling for transaction happens somewhere else
        if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
            recordLostEvent('sample_rate', 'event');
            return rejectedSyncPromise(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
        }
        return this._prepareEvent(event, scope, hint)
            .then(function (prepared) {
            if (prepared === null) {
                recordLostEvent('event_processor', event.type || 'event');
                throw new SentryError('An event processor returned null, will not send event.');
            }
            var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
            if (isInternalException || isTransaction || !beforeSend) {
                return prepared;
            }
            var beforeSendResult = beforeSend(prepared, hint);
            return _ensureBeforeSendRv(beforeSendResult);
        })
            .then(function (processedEvent) {
            if (processedEvent === null) {
                recordLostEvent('before_send', event.type || 'event');
                throw new SentryError('`beforeSend` returned `null`, will not send event.');
            }
            var session = scope && scope.getSession && scope.getSession();
            if (!isTransaction && session) {
                _this._updateSessionFromEvent(session, processedEvent);
            }
            _this._sendEvent(processedEvent);
            return processedEvent;
        })
            .then(null, function (reason) {
            if (reason instanceof SentryError) {
                throw reason;
            }
            _this.captureException(reason, {
                data: {
                    __sentry__: true,
                },
                originalException: reason,
            });
            throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
        });
    };
    /**
     * Occupies the client with processing and event
     */
    BaseClient.prototype._process = function (promise) {
        var _this = this;
        this._numProcessing += 1;
        void promise.then(function (value) {
            _this._numProcessing -= 1;
            return value;
        }, function (reason) {
            _this._numProcessing -= 1;
            return reason;
        });
    };
    return BaseClient;
}());
export { BaseClient };
/**
 * Verifies that return value of configured `beforeSend` is of expected type.
 */
function _ensureBeforeSendRv(rv) {
    var nullErr = '`beforeSend` method has to return `null` or a valid event.';
    if (isThenable(rv)) {
        return rv.then(function (event) {
            if (!(isPlainObject(event) || event === null)) {
                throw new SentryError(nullErr);
            }
            return event;
        }, function (e) {
            throw new SentryError("beforeSend rejected with " + e);
        });
    }
    else if (!(isPlainObject(rv) || rv === null)) {
        throw new SentryError(nullErr);
    }
    return rv;
}
//# sourceMappingURL=baseclient.js.map{"version":3,"file":"baseclient.js","sourceRoot":"","sources":["../../src/baseclient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport { Scope, Session } from '@sentry/hub';\nimport {\n  Client,\n  DsnComponents,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Options,\n  Severity,\n  Transport,\n} from '@sentry/types';\nimport {\n  checkOrSetAlreadyCaught,\n  dateTimestampInSeconds,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  normalize,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  SentryError,\n  SyncPromise,\n  truncate,\n  uuid4,\n} from '@sentry/utils';\n\nimport { Backend, BackendClass } from './basebackend';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { IntegrationIndex, setupIntegrations } from './integration';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the environment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  protected readonly _backend: B;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  /** Array of used integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Number of calls being processed */\n  protected _numProcessing: number = 0;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._getBackend()\n        .eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this._getBackend().eventFromMessage(String(message), level, hint)\n      : this._getBackend().eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!this._isEnabled()) {\n      IS_DEBUG_BUILD && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      IS_DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this._sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      session.update({ init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport {\n    return this._getBackend().getTransport();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    return this._isClientDoneProcessing(timeout).then(clientFinished => {\n      return this.getTransport()\n        .close(timeout)\n        .then(transportFlushed => clientFinished && transportFlushed);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled() && !this._integrations.initialized) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      IS_DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      session.update({\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /** Deliver captured session to Sentry */\n  protected _sendSession(session: Session): void {\n    this._getBackend().sendSession(session);\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Returns the current backend. */\n  protected _getBackend(): B {\n    return this._backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = this.getOptions();\n    const prepared: Event = {\n      ...event,\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = resolvedSyncPromise<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (evt) {\n        // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809\n        // it is only attached as extra data to the event if the event somehow skips being normalized\n        evt.sdkProcessingMetadata = {\n          ...evt.sdkProcessingMetadata,\n          normalizeDepth: `${normalize(normalizeDepth)} (${typeof normalizeDepth})`,\n        };\n      }\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n    if (!event) {\n      return null;\n    }\n\n    const normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth),\n      }),\n    };\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      normalized.contexts.trace = event.contexts.trace;\n    }\n\n    normalized.sdkProcessingMetadata = { ...normalized.sdkProcessingMetadata, baseClientNormalized: true };\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  protected _applyClientOptions(event: Event): void {\n    const options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n  protected _applyIntegrationsMetadata(event: Event): void {\n    const integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n  protected _sendEvent(event: Event): void {\n    this._getBackend().sendEvent(event);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        IS_DEBUG_BUILD && logger.error(reason);\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeSend, sampleRate } = this.getOptions();\n    const transport = this.getTransport();\n\n    type RecordLostEvent = NonNullable<Transport['recordLostEvent']>;\n    type RecordLostEventParams = Parameters<RecordLostEvent>;\n\n    function recordLostEvent(outcome: RecordLostEventParams[0], category: RecordLostEventParams[1]): void {\n      if (transport.recordLostEvent) {\n        transport.recordLostEvent(outcome, category);\n      }\n    }\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.'));\n    }\n\n    const isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      recordLostEvent('sample_rate', 'event');\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, scope, hint)\n      .then(prepared => {\n        if (prepared === null) {\n          recordLostEvent('event_processor', event.type || 'event');\n          throw new SentryError('An event processor returned null, will not send event.');\n        }\n\n        const isInternalException = hint && hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException || isTransaction || !beforeSend) {\n          return prepared;\n        }\n\n        const beforeSendResult = beforeSend(prepared, hint);\n        return _ensureBeforeSendRv(beforeSendResult);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          recordLostEvent('before_send', event.type || 'event');\n          throw new SentryError('`beforeSend` returned `null`, will not send event.');\n        }\n\n        const session = scope && scope.getSession && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        this._sendEvent(processedEvent);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason as Error,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing += 1;\n    void promise.then(\n      value => {\n        this._numProcessing -= 1;\n        return value;\n      },\n      reason => {\n        this._numProcessing -= 1;\n        return reason;\n      },\n    );\n  }\n}\n\n/**\n * Verifies that return value of configured `beforeSend` is of expected type.\n */\nfunction _ensureBeforeSendRv(rv: PromiseLike<Event | null> | Event | null): PromiseLike<Event | null> | Event | null {\n  const nullErr = '`beforeSend` method has to return `null` or a valid event.';\n  if (isThenable(rv)) {\n    return rv.then(\n      event => {\n        if (!(isPlainObject(event) || event === null)) {\n          throw new SentryError(nullErr);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`beforeSend rejected with ${e}`);\n      },\n    );\n  } else if (!(isPlainObject(rv) || rv === null)) {\n    throw new SentryError(nullErr);\n  }\n  return rv;\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
/** Flag that is true for debug builds, false otherwise. */
export var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAIH,2DAA2D;AAC3D,MAAM,CAAC,IAAM,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}export { addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, startTransaction, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/minimal';
export { addGlobalEventProcessor, getCurrentHub, getHubFromCarrier, Hub, makeMain, Scope, Session } from '@sentry/hub';
export { API, APIDetails, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, getRequestHeaders, initAPIDetails, getReportDialogEndpoint, } from './api';
export { BaseClient } from './baseclient';
export { BackendClass, BaseBackend } from './basebackend';
export { eventToSentryRequest, sessionToSentryRequest } from './request';
export { initAndBind, ClientClass } from './sdk';
export { NoopTransport } from './transports/noop';
export { BaseTransportOptions, createTransport, NewTransport, TransportMakeRequestResponse, TransportRequest, TransportRequestExecutor, } from './transports/base';
export { SDK_VERSION } from './version';
import * as Integrations from './integrations';
export { Integrations };
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,gBAAgB,EAChB,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,uBAAuB,EAAE,aAAa,EAAE,iBAAiB,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AACvH,OAAO,EAEL,GAAG,EACH,UAAU,EACV,qCAAqC,EACrC,kCAAkC,EAClC,iBAAiB,EACjB,cAAc,EACd,uBAAuB,GACxB,MAAM,OAAO,CAAC;AACf,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,YAAY,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC1D,OAAO,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,MAAM,WAAW,CAAC;AACzE,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAClD,OAAO,EACL,oBAAoB,EACpB,eAAe,EACf,YAAY,EACZ,4BAA4B,EAC5B,gBAAgB,EAChB,wBAAwB,GACzB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,KAAK,YAAY,MAAM,gBAAgB,CAAC;AAE/C,OAAO,EAAE,YAAY,EAAE,CAAC"}export { addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, startTransaction, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/minimal';
export { addGlobalEventProcessor, getCurrentHub, getHubFromCarrier, Hub, makeMain, Scope, Session } from '@sentry/hub';
export { 
// eslint-disable-next-line deprecation/deprecation
API, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, getRequestHeaders, initAPIDetails, getReportDialogEndpoint, } from './api';
export { BaseClient } from './baseclient';
export { BaseBackend } from './basebackend';
export { eventToSentryRequest, sessionToSentryRequest } from './request';
export { initAndBind } from './sdk';
export { NoopTransport } from './transports/noop';
export { createTransport, } from './transports/base';
export { SDK_VERSION } from './version';
import * as Integrations from './integrations';
export { Integrations };
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,gBAAgB,EAChB,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,uBAAuB,EAAE,aAAa,EAAE,iBAAiB,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AACvH,OAAO;AACL,mDAAmD;AACnD,GAAG,EAEH,qCAAqC,EACrC,kCAAkC,EAClC,iBAAiB,EACjB,cAAc,EACd,uBAAuB,GACxB,MAAM,OAAO,CAAC;AACf,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAgB,WAAW,EAAE,MAAM,eAAe,CAAC;AAC1D,OAAO,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,MAAM,WAAW,CAAC;AACzE,OAAO,EAAE,WAAW,EAAe,MAAM,OAAO,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAClD,OAAO,EAEL,eAAe,GAKhB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,KAAK,YAAY,MAAM,gBAAgB,CAAC;AAE/C,OAAO,EAAE,YAAY,EAAE,CAAC","sourcesContent":["export {\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  startTransaction,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  withScope,\n} from '@sentry/minimal';\nexport { addGlobalEventProcessor, getCurrentHub, getHubFromCarrier, Hub, makeMain, Scope, Session } from '@sentry/hub';\nexport {\n  // eslint-disable-next-line deprecation/deprecation\n  API,\n  APIDetails,\n  getEnvelopeEndpointWithUrlEncodedAuth,\n  getStoreEndpointWithUrlEncodedAuth,\n  getRequestHeaders,\n  initAPIDetails,\n  getReportDialogEndpoint,\n} from './api';\nexport { BaseClient } from './baseclient';\nexport { BackendClass, BaseBackend } from './basebackend';\nexport { eventToSentryRequest, sessionToSentryRequest } from './request';\nexport { initAndBind, ClientClass } from './sdk';\nexport { NoopTransport } from './transports/noop';\nexport {\n  BaseTransportOptions,\n  createTransport,\n  NewTransport,\n  TransportMakeRequestResponse,\n  TransportRequest,\n  TransportRequestExecutor,\n} from './transports/base';\nexport { SDK_VERSION } from './version';\n\nimport * as Integrations from './integrations';\n\nexport { Integrations };\n"]}import { Integration, Options } from '@sentry/types';
export declare const installedIntegrations: string[];
/** Map of integrations assigned to a client */
export declare type IntegrationIndex = {
    [key: string]: Integration;
} & {
    initialized?: boolean;
};
/** Gets integration to install */
export declare function getIntegrationsToSetup(options: Options): Integration[];
/** Setup given integration */
export declare function setupIntegration(integration: Integration): void;
/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
export declare function setupIntegrations<O extends Options>(options: O): IntegrationIndex;
//# sourceMappingURL=integration.d.ts.map{"version":3,"file":"integration.d.ts","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAKrD,eAAO,MAAM,qBAAqB,EAAE,MAAM,EAAO,CAAC;AAElD,+CAA+C;AAC/C,oBAAY,gBAAgB,GAAG;IAC7B,CAAC,GAAG,EAAE,MAAM,GAAG,WAAW,CAAC;CAC5B,GAAG;IAAE,WAAW,CAAC,EAAE,OAAO,CAAA;CAAE,CAAC;AAc9B,kCAAkC;AAClC,wBAAgB,sBAAsB,CAAC,OAAO,EAAE,OAAO,GAAG,WAAW,EAAE,CA4BtE;AAED,8BAA8B;AAC9B,wBAAgB,gBAAgB,CAAC,WAAW,EAAE,WAAW,GAAG,IAAI,CAO/D;AAED;;;;;GAKG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,SAAS,OAAO,EAAE,OAAO,EAAE,CAAC,GAAG,gBAAgB,CAWjF"}import { __read, __spread } from "tslib";
import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';
import { addNonEnumerableProperty, logger } from '@sentry/utils';
import { IS_DEBUG_BUILD } from './flags';
export var installedIntegrations = [];
/**
 * @private
 */
function filterDuplicates(integrations) {
    return integrations.reduce(function (acc, integrations) {
        if (acc.every(function (accIntegration) { return integrations.name !== accIntegration.name; })) {
            acc.push(integrations);
        }
        return acc;
    }, []);
}
/** Gets integration to install */
export function getIntegrationsToSetup(options) {
    var defaultIntegrations = (options.defaultIntegrations && __spread(options.defaultIntegrations)) || [];
    var userIntegrations = options.integrations;
    var integrations = __spread(filterDuplicates(defaultIntegrations));
    if (Array.isArray(userIntegrations)) {
        // Filter out integrations that are also included in user options
        integrations = __spread(integrations.filter(function (integrations) {
            return userIntegrations.every(function (userIntegration) { return userIntegration.name !== integrations.name; });
        }), filterDuplicates(userIntegrations));
    }
    else if (typeof userIntegrations === 'function') {
        integrations = userIntegrations(integrations);
        integrations = Array.isArray(integrations) ? integrations : [integrations];
    }
    // Make sure that if present, `Debug` integration will always run last
    var integrationsNames = integrations.map(function (i) { return i.name; });
    var alwaysLastToRun = 'Debug';
    if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
        integrations.push.apply(integrations, __spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
    }
    return integrations;
}
/** Setup given integration */
export function setupIntegration(integration) {
    if (installedIntegrations.indexOf(integration.name) !== -1) {
        return;
    }
    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
    installedIntegrations.push(integration.name);
    IS_DEBUG_BUILD && logger.log("Integration installed: " + integration.name);
}
/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
export function setupIntegrations(options) {
    var integrations = {};
    getIntegrationsToSetup(options).forEach(function (integration) {
        integrations[integration.name] = integration;
        setupIntegration(integration);
    });
    // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`
    // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be
    // considered a member of the index the way the actual integrations are
    addNonEnumerableProperty(integrations, 'initialized', true);
    return integrations;
}
//# sourceMappingURL=integration.js.map{"version":3,"file":"integration.js","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"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","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Integration, Options } from '@sentry/types';\nimport { addNonEnumerableProperty, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n} & { initialized?: boolean };\n\n/**\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  return integrations.reduce((acc, integrations) => {\n    if (acc.every(accIntegration => integrations.name !== accIntegration.name)) {\n      acc.push(integrations);\n    }\n    return acc;\n  }, [] as Integration[]);\n}\n\n/** Gets integration to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];\n  const userIntegrations = options.integrations;\n\n  let integrations: Integration[] = [...filterDuplicates(defaultIntegrations)];\n\n  if (Array.isArray(userIntegrations)) {\n    // Filter out integrations that are also included in user options\n    integrations = [\n      ...integrations.filter(integrations =>\n        userIntegrations.every(userIntegration => userIntegration.name !== integrations.name),\n      ),\n      // And filter out duplicated user options integrations\n      ...filterDuplicates(userIntegrations),\n    ];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(integrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  }\n\n  // Make sure that if present, `Debug` integration will always run last\n  const integrationsNames = integrations.map(i => i.name);\n  const alwaysLastToRun = 'Debug';\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push(...integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1));\n  }\n\n  return integrations;\n}\n\n/** Setup given integration */\nexport function setupIntegration(integration: Integration): void {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  IS_DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations<O extends Options>(options: O): IntegrationIndex {\n  const integrations: IntegrationIndex = {};\n  getIntegrationsToSetup(options).forEach(integration => {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`\n  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be\n  // considered a member of the index the way the actual integrations are\n  addNonEnumerableProperty(integrations, 'initialized', true);\n  return integrations;\n}\n"]}import { Integration } from '@sentry/types';
/** Patch toString calls to return proper name for wrapped functions */
export declare class FunctionToString implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=functiontostring.d.ts.map{"version":3,"file":"functiontostring.d.ts","sourceRoot":"","sources":["../../../src/integrations/functiontostring.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAmB,MAAM,eAAe,CAAC;AAK7D,uEAAuE;AACvE,qBAAa,gBAAiB,YAAW,WAAW;IAClD;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAsB;IAE9C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAuB;IAE1C;;OAEG;IACI,SAAS,IAAI,IAAI;CAUzB"}import { getOriginalFunction } from '@sentry/utils';
var originalFunctionToString;
/** Patch toString calls to return proper name for wrapped functions */
var FunctionToString = /** @class */ (function () {
    function FunctionToString() {
        /**
         * @inheritDoc
         */
        this.name = FunctionToString.id;
    }
    /**
     * @inheritDoc
     */
    FunctionToString.prototype.setupOnce = function () {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalFunctionToString = Function.prototype.toString;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Function.prototype.toString = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var context = getOriginalFunction(this) || this;
            return originalFunctionToString.apply(context, args);
        };
    };
    /**
     * @inheritDoc
     */
    FunctionToString.id = 'FunctionToString';
    return FunctionToString;
}());
export { FunctionToString };
//# sourceMappingURL=functiontostring.js.map{"version":3,"file":"functiontostring.js","sourceRoot":"","sources":["../../../src/integrations/functiontostring.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,mBAAmB,EAAE,MAAM,eAAe,CAAC;AAEpD,IAAI,wBAAoC,CAAC;AAEzC,uEAAuE;AACvE;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,gBAAgB,CAAC,EAAE,CAAC;IAe5C,CAAC;IAbC;;OAEG;IACI,oCAAS,GAAhB;QACE,6DAA6D;QAC7D,wBAAwB,GAAG,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC;QAEvD,8DAA8D;QAC9D,QAAQ,CAAC,SAAS,CAAC,QAAQ,GAAG;YAAiC,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAC3E,IAAM,OAAO,GAAG,mBAAmB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC;YAClD,OAAO,wBAAwB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACvD,CAAC,CAAC;IACJ,CAAC;IAtBD;;OAEG;IACW,mBAAE,GAAW,kBAAkB,CAAC;IAoBhD,uBAAC;CAAA,AAxBD,IAwBC;SAxBY,gBAAgB","sourcesContent":["import { Integration, WrappedFunction } from '@sentry/types';\nimport { getOriginalFunction } from '@sentry/utils';\n\nlet originalFunctionToString: () => void;\n\n/** Patch toString calls to return proper name for wrapped functions */\nexport class FunctionToString implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'FunctionToString';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = FunctionToString.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    originalFunctionToString = Function.prototype.toString;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Function.prototype.toString = function (this: WrappedFunction, ...args: any[]): string {\n      const context = getOriginalFunction(this) || this;\n      return originalFunctionToString.apply(context, args);\n    };\n  }\n}\n"]}import { Event, EventProcessor, Hub, Integration } from '@sentry/types';
/** Options for the InboundFilters integration */
export interface InboundFiltersOptions {
    allowUrls: Array<string | RegExp>;
    denyUrls: Array<string | RegExp>;
    ignoreErrors: Array<string | RegExp>;
    ignoreInternal: boolean;
    /** @deprecated use {@link InboundFiltersOptions.allowUrls} instead. */
    whitelistUrls: Array<string | RegExp>;
    /** @deprecated use {@link InboundFiltersOptions.denyUrls} instead. */
    blacklistUrls: Array<string | RegExp>;
}
/** Inbound filters configurable by the user */
export declare class InboundFilters implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    constructor(_options?: Partial<InboundFiltersOptions>);
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (processor: EventProcessor) => void, getCurrentHub: () => Hub): void;
}
/** JSDoc */
export declare function _mergeOptions(internalOptions?: Partial<InboundFiltersOptions>, clientOptions?: Partial<InboundFiltersOptions>): Partial<InboundFiltersOptions>;
/** JSDoc */
export declare function _shouldDropEvent(event: Event, options: Partial<InboundFiltersOptions>): boolean;
//# sourceMappingURL=inboundfilters.d.ts.map{"version":3,"file":"inboundfilters.d.ts","sourceRoot":"","sources":["../../../src/integrations/inboundfilters.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAc,MAAM,eAAe,CAAC;AASpF,iDAAiD;AACjD,MAAM,WAAW,qBAAqB;IACpC,SAAS,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IAClC,QAAQ,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACjC,YAAY,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACrC,cAAc,EAAE,OAAO,CAAC;IAExB,uEAAuE;IACvE,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,sEAAsE;IACtE,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;CACvC;AAED,+CAA+C;AAC/C,qBAAa,cAAe,YAAW,WAAW;IAW7B,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAV5C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAoB;IAE5C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAqB;gBAEJ,QAAQ,GAAE,OAAO,CAAC,qBAAqB,CAAM;IAEjF;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,SAAS,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;CAe/G;AAED,YAAY;AACZ,wBAAgB,aAAa,CAC3B,eAAe,GAAE,OAAO,CAAC,qBAAqB,CAAM,EACpD,aAAa,GAAE,OAAO,CAAC,qBAAqB,CAAM,GACjD,OAAO,CAAC,qBAAqB,CAAC,CAyBhC;AAED,YAAY;AACZ,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,qBAAqB,CAAC,GAAG,OAAO,CAgC/F"}import { __read, __spread } from "tslib";
import { getEventDescription, isMatchingPattern, logger } from '@sentry/utils';
import { IS_DEBUG_BUILD } from '../flags';
// "Script error." is hard coded into browsers for errors that it can't read.
// this is the result of a script being pulled in from an external domain and CORS.
var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
/** Inbound filters configurable by the user */
var InboundFilters = /** @class */ (function () {
    function InboundFilters(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = InboundFilters.id;
    }
    /**
     * @inheritDoc
     */
    InboundFilters.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor(function (event) {
            var hub = getCurrentHub();
            if (hub) {
                var self_1 = hub.getIntegration(InboundFilters);
                if (self_1) {
                    var client = hub.getClient();
                    var clientOptions = client ? client.getOptions() : {};
                    var options = _mergeOptions(self_1._options, clientOptions);
                    return _shouldDropEvent(event, options) ? null : event;
                }
            }
            return event;
        });
    };
    /**
     * @inheritDoc
     */
    InboundFilters.id = 'InboundFilters';
    return InboundFilters;
}());
export { InboundFilters };
/** JSDoc */
export function _mergeOptions(internalOptions, clientOptions) {
    if (internalOptions === void 0) { internalOptions = {}; }
    if (clientOptions === void 0) { clientOptions = {}; }
    return {
        allowUrls: __spread((internalOptions.whitelistUrls || []), (internalOptions.allowUrls || []), (clientOptions.whitelistUrls || []), (clientOptions.allowUrls || [])),
        denyUrls: __spread((internalOptions.blacklistUrls || []), (internalOptions.denyUrls || []), (clientOptions.blacklistUrls || []), (clientOptions.denyUrls || [])),
        ignoreErrors: __spread((internalOptions.ignoreErrors || []), (clientOptions.ignoreErrors || []), DEFAULT_IGNORE_ERRORS),
        ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,
    };
}
/** JSDoc */
export function _shouldDropEvent(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
        IS_DEBUG_BUILD &&
            logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
        return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
        IS_DEBUG_BUILD &&
            logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
        return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
        IS_DEBUG_BUILD &&
            logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
        return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
        IS_DEBUG_BUILD &&
            logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
        return true;
    }
    return false;
}
function _isIgnoredError(event, ignoreErrors) {
    if (!ignoreErrors || !ignoreErrors.length) {
        return false;
    }
    return _getPossibleEventMessages(event).some(function (message) {
        return ignoreErrors.some(function (pattern) { return isMatchingPattern(message, pattern); });
    });
}
function _isDeniedUrl(event, denyUrls) {
    // TODO: Use Glob instead?
    if (!denyUrls || !denyUrls.length) {
        return false;
    }
    var url = _getEventFilterUrl(event);
    return !url ? false : denyUrls.some(function (pattern) { return isMatchingPattern(url, pattern); });
}
function _isAllowedUrl(event, allowUrls) {
    // TODO: Use Glob instead?
    if (!allowUrls || !allowUrls.length) {
        return true;
    }
    var url = _getEventFilterUrl(event);
    return !url ? true : allowUrls.some(function (pattern) { return isMatchingPattern(url, pattern); });
}
function _getPossibleEventMessages(event) {
    if (event.message) {
        return [event.message];
    }
    if (event.exception) {
        try {
            var _a = (event.exception.values && event.exception.values[0]) || {}, _b = _a.type, type = _b === void 0 ? '' : _b, _c = _a.value, value = _c === void 0 ? '' : _c;
            return ["" + value, type + ": " + value];
        }
        catch (oO) {
            IS_DEBUG_BUILD && logger.error("Cannot extract message for event " + getEventDescription(event));
            return [];
        }
    }
    return [];
}
function _isSentryError(event) {
    try {
        // @ts-ignore can't be a sentry error if undefined
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return event.exception.values[0].type === 'SentryError';
    }
    catch (e) {
        // ignore
    }
    return false;
}
function _getLastValidUrl(frames) {
    if (frames === void 0) { frames = []; }
    for (var i = frames.length - 1; i >= 0; i--) {
        var frame = frames[i];
        if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
            return frame.filename || null;
        }
    }
    return null;
}
function _getEventFilterUrl(event) {
    try {
        if (event.stacktrace) {
            return _getLastValidUrl(event.stacktrace.frames);
        }
        var frames_1;
        try {
            // @ts-ignore we only care about frames if the whole thing here is defined
            frames_1 = event.exception.values[0].stacktrace.frames;
        }
        catch (e) {
            // ignore
        }
        return frames_1 ? _getLastValidUrl(frames_1) : null;
    }
    catch (oO) {
        IS_DEBUG_BUILD && logger.error("Cannot extract url for event " + getEventDescription(event));
        return null;
    }
}
//# sourceMappingURL=inboundfilters.js.map{"version":3,"file":"inboundfilters.js","sourceRoot":"","sources":["../../../src/integrations/inboundfilters.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventProcessor, Hub, Integration, StackFrame } from '@sentry/types';\nimport { getEventDescription, isMatchingPattern, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nconst DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n\n/** Options for the InboundFilters integration */\nexport interface InboundFiltersOptions {\n  allowUrls: Array<string | RegExp>;\n  denyUrls: Array<string | RegExp>;\n  ignoreErrors: Array<string | RegExp>;\n  ignoreInternal: boolean;\n\n  /** @deprecated use {@link InboundFiltersOptions.allowUrls} instead. */\n  whitelistUrls: Array<string | RegExp>;\n  /** @deprecated use {@link InboundFiltersOptions.denyUrls} instead. */\n  blacklistUrls: Array<string | RegExp>;\n}\n\n/** Inbound filters configurable by the user */\nexport class InboundFilters implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'InboundFilters';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = InboundFilters.id;\n\n  public constructor(private readonly _options: Partial<InboundFiltersOptions> = {}) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (processor: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor((event: Event) => {\n      const hub = getCurrentHub();\n      if (hub) {\n        const self = hub.getIntegration(InboundFilters);\n        if (self) {\n          const client = hub.getClient();\n          const clientOptions = client ? client.getOptions() : {};\n          const options = _mergeOptions(self._options, clientOptions);\n          return _shouldDropEvent(event, options) ? null : event;\n        }\n      }\n      return event;\n    });\n  }\n}\n\n/** JSDoc */\nexport function _mergeOptions(\n  internalOptions: Partial<InboundFiltersOptions> = {},\n  clientOptions: Partial<InboundFiltersOptions> = {},\n): Partial<InboundFiltersOptions> {\n  return {\n    allowUrls: [\n      // eslint-disable-next-line deprecation/deprecation\n      ...(internalOptions.whitelistUrls || []),\n      ...(internalOptions.allowUrls || []),\n      // eslint-disable-next-line deprecation/deprecation\n      ...(clientOptions.whitelistUrls || []),\n      ...(clientOptions.allowUrls || []),\n    ],\n    denyUrls: [\n      // eslint-disable-next-line deprecation/deprecation\n      ...(internalOptions.blacklistUrls || []),\n      ...(internalOptions.denyUrls || []),\n      // eslint-disable-next-line deprecation/deprecation\n      ...(clientOptions.blacklistUrls || []),\n      ...(clientOptions.denyUrls || []),\n    ],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...DEFAULT_IGNORE_ERRORS,\n    ],\n    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,\n  };\n}\n\n/** JSDoc */\nexport function _shouldDropEvent(event: Event, options: Partial<InboundFiltersOptions>): boolean {\n  if (options.ignoreInternal && _isSentryError(event)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(`Event dropped due to being internal Sentry Error.\\nEvent: ${getEventDescription(event)}`);\n    return true;\n  }\n  if (_isIgnoredError(event, options.ignoreErrors)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${getEventDescription(event)}`,\n      );\n    return true;\n  }\n  if (_isDeniedUrl(event, options.denyUrls)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  if (!_isAllowedUrl(event, options.allowUrls)) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event: Event, ignoreErrors?: Array<string | RegExp>): boolean {\n  if (!ignoreErrors || !ignoreErrors.length) {\n    return false;\n  }\n\n  return _getPossibleEventMessages(event).some(message =>\n    ignoreErrors.some(pattern => isMatchingPattern(message, pattern)),\n  );\n}\n\nfunction _isDeniedUrl(event: Event, denyUrls?: Array<string | RegExp>): boolean {\n  // TODO: Use Glob instead?\n  if (!denyUrls || !denyUrls.length) {\n    return false;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? false : denyUrls.some(pattern => isMatchingPattern(url, pattern));\n}\n\nfunction _isAllowedUrl(event: Event, allowUrls?: Array<string | RegExp>): boolean {\n  // TODO: Use Glob instead?\n  if (!allowUrls || !allowUrls.length) {\n    return true;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? true : allowUrls.some(pattern => isMatchingPattern(url, pattern));\n}\n\nfunction _getPossibleEventMessages(event: Event): string[] {\n  if (event.message) {\n    return [event.message];\n  }\n  if (event.exception) {\n    try {\n      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};\n      return [`${value}`, `${type}: ${value}`];\n    } catch (oO) {\n      IS_DEBUG_BUILD && logger.error(`Cannot extract message for event ${getEventDescription(event)}`);\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction _isSentryError(event: Event): boolean {\n  try {\n    // @ts-ignore can't be a sentry error if undefined\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return event.exception.values[0].type === 'SentryError';\n  } catch (e) {\n    // ignore\n  }\n  return false;\n}\n\nfunction _getLastValidUrl(frames: StackFrame[] = []): string | null {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    const frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event: Event): string | null {\n  try {\n    if (event.stacktrace) {\n      return _getLastValidUrl(event.stacktrace.frames);\n    }\n    let frames;\n    try {\n      // @ts-ignore we only care about frames if the whole thing here is defined\n      frames = event.exception.values[0].stacktrace.frames;\n    } catch (e) {\n      // ignore\n    }\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    IS_DEBUG_BUILD && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);\n    return null;\n  }\n}\n"]}export { FunctionToString } from './functiontostring';
export { InboundFilters } from './inboundfilters';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC"}export { FunctionToString } from './functiontostring';
export { InboundFilters } from './inboundfilters';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC","sourcesContent":["export { FunctionToString } from './functiontostring';\nexport { InboundFilters } from './inboundfilters';\n"]}import { Event, EventEnvelope, SentryRequest, SentryRequestType, Session, SessionAggregates, SessionEnvelope } from '@sentry/types';
import { APIDetails } from './api';
/** Creates an envelope from a Session */
export declare function createSessionEnvelope(session: Session | SessionAggregates, api: APIDetails): [SessionEnvelope, SentryRequestType];
/** Creates a SentryRequest from a Session. */
export declare function sessionToSentryRequest(session: Session | SessionAggregates, api: APIDetails): SentryRequest;
/**
 * Create an Envelope from an event. Note that this is duplicated from below,
 * but on purpose as this will be refactored in v7.
 */
export declare function createEventEnvelope(event: Event, api: APIDetails): EventEnvelope;
/** Creates a SentryRequest from an event. */
export declare function eventToSentryRequest(event: Event, api: APIDetails): SentryRequest;
//# sourceMappingURL=request.d.ts.map{"version":3,"file":"request.d.ts","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,KAAK,EACL,aAAa,EAGb,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,eAAe,EAEhB,MAAM,eAAe,CAAC;AAGvB,OAAO,EAAE,UAAU,EAA6E,MAAM,OAAO,CAAC;AA2B9G,yCAAyC;AACzC,wBAAgB,qBAAqB,CACnC,OAAO,EAAE,OAAO,GAAG,iBAAiB,EACpC,GAAG,EAAE,UAAU,GACd,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAgBtC;AAED,8CAA8C;AAC9C,wBAAgB,sBAAsB,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAO3G;AAED;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAkDhF;AAED,6CAA6C;AAC7C,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAgGjF"}import { __assign, __read, __spread } from "tslib";
import { createEnvelope, dsnToString, normalize, serializeEnvelope } from '@sentry/utils';
import { getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth } from './api';
/** Extract sdk info from from the API metadata */
function getSdkMetadataForEnvelopeHeader(api) {
    if (!api.metadata || !api.metadata.sdk) {
        return;
    }
    var _a = api.metadata.sdk, name = _a.name, version = _a.version;
    return { name: name, version: version };
}
/**
 * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
 * Merge with existing data if any.
 **/
function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
        return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = __spread((event.sdk.integrations || []), (sdkInfo.integrations || []));
    event.sdk.packages = __spread((event.sdk.packages || []), (sdkInfo.packages || []));
    return event;
}
/** Creates an envelope from a Session */
export function createSessionEnvelope(session, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var envelopeHeaders = __assign(__assign({ sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: dsnToString(api.dsn) }));
    // I know this is hacky but we don't want to add `sessions` to request type since it's never rate limited
    var type = 'aggregates' in session ? 'sessions' : 'session';
    // TODO (v7) Have to cast type because envelope items do not accept a `SentryRequestType`
    var envelopeItem = [{ type: type }, session];
    var envelope = createEnvelope(envelopeHeaders, [envelopeItem]);
    return [envelope, type];
}
/** Creates a SentryRequest from a Session. */
export function sessionToSentryRequest(session, api) {
    var _a = __read(createSessionEnvelope(session, api), 2), envelope = _a[0], type = _a[1];
    return {
        body: serializeEnvelope(envelope),
        type: type,
        url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel),
    };
}
/**
 * Create an Envelope from an event. Note that this is duplicated from below,
 * but on purpose as this will be refactored in v7.
 */
export function createEventEnvelope(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || 'event';
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    // TODO: Below is a temporary hack in order to debug a serialization error - see
    // https://github.com/getsentry/sentry-javascript/issues/2809,
    // https://github.com/getsentry/sentry-javascript/pull/4425, and
    // https://github.com/getsentry/sentry-javascript/pull/4574.
    //
    // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
    // throw a circular reference error.
    //
    // When it's time to remove it:
    // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
    //    `sdkProcessingMetadata`
    // 2. Restore the original version of the request body, which is commented out
    // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
    //    baseClient tests in this package
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    // In theory, all events should be marked as having gone through normalization and so
    // we should never set this tag/extra data
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
    }
    // prevent this data from being sent to sentry
    // TODO: This is NOT part of the hack - DO NOT DELETE
    delete event.sdkProcessingMetadata;
    var envelopeHeaders = __assign(__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: dsnToString(api.dsn) }));
    var eventItem = [
        {
            type: eventType,
            sample_rates: [{ id: samplingMethod, rate: sampleRate }],
        },
        event,
    ];
    return createEnvelope(envelopeHeaders, [eventItem]);
}
/** Creates a SentryRequest from an event. */
export function eventToSentryRequest(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || 'event';
    var useEnvelope = eventType === 'transaction' || !!api.tunnel;
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    // TODO: Below is a temporary hack in order to debug a serialization error - see
    // https://github.com/getsentry/sentry-javascript/issues/2809,
    // https://github.com/getsentry/sentry-javascript/pull/4425, and
    // https://github.com/getsentry/sentry-javascript/pull/4574.
    //
    // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
    // throw a circular reference error.
    //
    // When it's time to remove it:
    // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
    //    `sdkProcessingMetadata`
    // 2. Restore the original version of the request body, which is commented out
    // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
    //    baseClient tests in this package
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    // In theory, all events should be marked as having gone through normalization and so
    // we should never set this tag/extra data
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
    }
    // prevent this data from being sent to sentry
    // TODO: This is NOT part of the hack - DO NOT DELETE
    delete event.sdkProcessingMetadata;
    var body;
    try {
        // 99.9% of events should get through just fine - no change in behavior for them
        body = JSON.stringify(event);
    }
    catch (err) {
        // Record data about the error without replacing original event data, then force renormalization
        event.tags.JSONStringifyError = true;
        event.extra.JSONStringifyError = err;
        try {
            body = JSON.stringify(normalize(event));
        }
        catch (newErr) {
            // At this point even renormalization hasn't worked, meaning something about the event data has gone very wrong.
            // Time to cut our losses and record only the new error. With luck, even in the problematic cases we're trying to
            // debug with this hack, we won't ever land here.
            var innerErr = newErr;
            body = JSON.stringify({
                message: 'JSON.stringify error after renormalization',
                // setting `extra: { innerErr }` here for some reason results in an empty object, so unpack manually
                extra: { message: innerErr.message, stack: innerErr.stack },
            });
        }
    }
    var req = {
        // this is the relevant line of code before the hack was added, to make it easy to undo said hack once we've solved
        // the mystery
        // body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
        body: body,
        type: eventType,
        url: useEnvelope
            ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
            : getStoreEndpointWithUrlEncodedAuth(api.dsn),
    };
    // https://develop.sentry.dev/sdk/envelopes/
    // Since we don't need to manipulate envelopes nor store them, there is no
    // exported concept of an Envelope with operations including serialization and
    // deserialization. Instead, we only implement a minimal subset of the spec to
    // serialize events inline here.
    if (useEnvelope) {
        var envelopeHeaders = __assign(__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: dsnToString(api.dsn) }));
        var eventItem = [
            {
                type: eventType,
                sample_rates: [{ id: samplingMethod, rate: sampleRate }],
            },
            req.body,
        ];
        var envelope = createEnvelope(envelopeHeaders, [eventItem]);
        req.body = serializeEnvelope(envelope);
    }
    return req;
}
//# sourceMappingURL=request.js.map{"version":3,"file":"request.js","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Event,\n  EventEnvelope,\n  EventItem,\n  SdkInfo,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  SessionAggregates,\n  SessionEnvelope,\n  SessionItem,\n} from '@sentry/types';\nimport { createEnvelope, dsnToString, normalize, serializeEnvelope } from '@sentry/utils';\n\nimport { APIDetails, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth } from './api';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(api: APIDetails): SdkInfo | undefined {\n  if (!api.metadata || !api.metadata.sdk) {\n    return;\n  }\n  const { name, version } = api.metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event: Event, sdkInfo?: SdkInfo): Event {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nexport function createSessionEnvelope(\n  session: Session | SessionAggregates,\n  api: APIDetails,\n): [SessionEnvelope, SentryRequestType] {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!api.tunnel && { dsn: dsnToString(api.dsn) }),\n  };\n\n  // I know this is hacky but we don't want to add `sessions` to request type since it's never rate limited\n  const type = 'aggregates' in session ? ('sessions' as SentryRequestType) : 'session';\n\n  // TODO (v7) Have to cast type because envelope items do not accept a `SentryRequestType`\n  const envelopeItem = [{ type } as { type: 'session' | 'sessions' }, session] as SessionItem;\n  const envelope = createEnvelope<SessionEnvelope>(envelopeHeaders, [envelopeItem]);\n\n  return [envelope, type];\n}\n\n/** Creates a SentryRequest from a Session. */\nexport function sessionToSentryRequest(session: Session | SessionAggregates, api: APIDetails): SentryRequest {\n  const [envelope, type] = createSessionEnvelope(session, api);\n  return {\n    body: serializeEnvelope(envelope),\n    type,\n    url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel),\n  };\n}\n\n/**\n * Create an Envelope from an event. Note that this is duplicated from below,\n * but on purpose as this will be refactored in v7.\n */\nexport function createEventEnvelope(event: Event, api: APIDetails): EventEnvelope {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const eventType = event.type || 'event';\n\n  const { transactionSampling } = event.sdkProcessingMetadata || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n\n  // TODO: Below is a temporary hack in order to debug a serialization error - see\n  // https://github.com/getsentry/sentry-javascript/issues/2809,\n  // https://github.com/getsentry/sentry-javascript/pull/4425, and\n  // https://github.com/getsentry/sentry-javascript/pull/4574.\n  //\n  // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to\n  // throw a circular reference error.\n  //\n  // When it's time to remove it:\n  // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting\n  //    `sdkProcessingMetadata`\n  // 2. Restore the original version of the request body, which is commented out\n  // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the\n  //    baseClient tests in this package\n  enhanceEventWithSdkInfo(event, api.metadata.sdk);\n  event.tags = event.tags || {};\n  event.extra = event.extra || {};\n\n  // In theory, all events should be marked as having gone through normalization and so\n  // we should never set this tag/extra data\n  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {\n    event.tags.skippedNormalization = true;\n    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';\n  }\n\n  // prevent this data from being sent to sentry\n  // TODO: This is NOT part of the hack - DO NOT DELETE\n  delete event.sdkProcessingMetadata;\n\n  const envelopeHeaders = {\n    event_id: event.event_id as string,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!api.tunnel && { dsn: dsnToString(api.dsn) }),\n  };\n  const eventItem: EventItem = [\n    {\n      type: eventType,\n      sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n    },\n    event,\n  ];\n  return createEnvelope<EventEnvelope>(envelopeHeaders, [eventItem]);\n}\n\n/** Creates a SentryRequest from an event. */\nexport function eventToSentryRequest(event: Event, api: APIDetails): SentryRequest {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(api);\n  const eventType = event.type || 'event';\n  const useEnvelope = eventType === 'transaction' || !!api.tunnel;\n\n  const { transactionSampling } = event.sdkProcessingMetadata || {};\n  const { method: samplingMethod, rate: sampleRate } = transactionSampling || {};\n\n  // TODO: Below is a temporary hack in order to debug a serialization error - see\n  // https://github.com/getsentry/sentry-javascript/issues/2809,\n  // https://github.com/getsentry/sentry-javascript/pull/4425, and\n  // https://github.com/getsentry/sentry-javascript/pull/4574.\n  //\n  // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to\n  // throw a circular reference error.\n  //\n  // When it's time to remove it:\n  // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting\n  //    `sdkProcessingMetadata`\n  // 2. Restore the original version of the request body, which is commented out\n  // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the\n  //    baseClient tests in this package\n  enhanceEventWithSdkInfo(event, api.metadata.sdk);\n  event.tags = event.tags || {};\n  event.extra = event.extra || {};\n\n  // In theory, all events should be marked as having gone through normalization and so\n  // we should never set this tag/extra data\n  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {\n    event.tags.skippedNormalization = true;\n    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';\n  }\n\n  // prevent this data from being sent to sentry\n  // TODO: This is NOT part of the hack - DO NOT DELETE\n  delete event.sdkProcessingMetadata;\n\n  let body;\n  try {\n    // 99.9% of events should get through just fine - no change in behavior for them\n    body = JSON.stringify(event);\n  } catch (err) {\n    // Record data about the error without replacing original event data, then force renormalization\n    event.tags.JSONStringifyError = true;\n    event.extra.JSONStringifyError = err;\n    try {\n      body = JSON.stringify(normalize(event));\n    } catch (newErr) {\n      // At this point even renormalization hasn't worked, meaning something about the event data has gone very wrong.\n      // Time to cut our losses and record only the new error. With luck, even in the problematic cases we're trying to\n      // debug with this hack, we won't ever land here.\n      const innerErr = newErr as Error;\n      body = JSON.stringify({\n        message: 'JSON.stringify error after renormalization',\n        // setting `extra: { innerErr }` here for some reason results in an empty object, so unpack manually\n        extra: { message: innerErr.message, stack: innerErr.stack },\n      });\n    }\n  }\n\n  const req: SentryRequest = {\n    // this is the relevant line of code before the hack was added, to make it easy to undo said hack once we've solved\n    // the mystery\n    // body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),\n    body,\n    type: eventType,\n    url: useEnvelope\n      ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)\n      : getStoreEndpointWithUrlEncodedAuth(api.dsn),\n  };\n\n  // https://develop.sentry.dev/sdk/envelopes/\n\n  // Since we don't need to manipulate envelopes nor store them, there is no\n  // exported concept of an Envelope with operations including serialization and\n  // deserialization. Instead, we only implement a minimal subset of the spec to\n  // serialize events inline here.\n  if (useEnvelope) {\n    const envelopeHeaders = {\n      event_id: event.event_id as string,\n      sent_at: new Date().toISOString(),\n      ...(sdkInfo && { sdk: sdkInfo }),\n      ...(!!api.tunnel && { dsn: dsnToString(api.dsn) }),\n    };\n    const eventItem: EventItem = [\n      {\n        type: eventType,\n        sample_rates: [{ id: samplingMethod, rate: sampleRate }],\n      },\n      req.body,\n    ];\n    const envelope = createEnvelope<EventEnvelope>(envelopeHeaders, [eventItem]);\n    req.body = serializeEnvelope(envelope);\n  }\n\n  return req;\n}\n"]}import { Client, Options } from '@sentry/types';
/** A class object that can instantiate Client objects. */
export declare type ClientClass<F extends Client, O extends Options> = new (options: O) => F;
/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
export declare function initAndBind<F extends Client, O extends Options>(clientClass: ClientClass<F, O>, options: O): void;
//# sourceMappingURL=sdk.d.ts.map{"version":3,"file":"sdk.d.ts","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAKhD,0DAA0D;AAC1D,oBAAY,WAAW,CAAC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAErF;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,OAAO,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,CAiBjH"}import { getCurrentHub } from '@sentry/hub';
import { logger } from '@sentry/utils';
import { IS_DEBUG_BUILD } from './flags';
/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
export function initAndBind(clientClass, options) {
    if (options.debug === true) {
        if (IS_DEBUG_BUILD) {
            logger.enable();
        }
        else {
            // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
            // eslint-disable-next-line no-console
            console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
        }
    }
    var hub = getCurrentHub();
    var scope = hub.getScope();
    if (scope) {
        scope.update(options.initialScope);
    }
    var client = new clientClass(options);
    hub.bindClient(client);
}
//# sourceMappingURL=sdk.js.map{"version":3,"file":"sdk.js","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAE5C,OAAO,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAEvC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AAKzC;;;;;;GAMG;AACH,MAAM,UAAU,WAAW,CAAsC,WAA8B,EAAE,OAAU;IACzG,IAAI,OAAO,CAAC,KAAK,KAAK,IAAI,EAAE;QAC1B,IAAI,cAAc,EAAE;YAClB,MAAM,CAAC,MAAM,EAAE,CAAC;SACjB;aAAM;YACL,kHAAkH;YAClH,sCAAsC;YACtC,OAAO,CAAC,IAAI,CAAC,8EAA8E,CAAC,CAAC;SAC9F;KACF;IACD,IAAM,GAAG,GAAG,aAAa,EAAE,CAAC;IAC5B,IAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;IAC7B,IAAI,KAAK,EAAE;QACT,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;KACpC;IACD,IAAM,MAAM,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC;IACxC,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AACzB,CAAC","sourcesContent":["import { getCurrentHub } from '@sentry/hub';\nimport { Client, Options } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\n\n/** A class object that can instantiate Client objects. */\nexport type ClientClass<F extends Client, O extends Options> = new (options: O) => F;\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nexport function initAndBind<F extends Client, O extends Options>(clientClass: ClientClass<F, O>, options: O): void {\n  if (options.debug === true) {\n    if (IS_DEBUG_BUILD) {\n      logger.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n      // eslint-disable-next-line no-console\n      console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');\n    }\n  }\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n  if (scope) {\n    scope.update(options.initialScope);\n  }\n  const client = new clientClass(options);\n  hub.bindClient(client);\n}\n"]}import { Envelope, EventStatus } from '@sentry/types';
import { PromiseBuffer } from '@sentry/utils';
export declare const ERROR_TRANSPORT_CATEGORY = "error";
export declare const TRANSACTION_TRANSPORT_CATEGORY = "transaction";
export declare const ATTACHMENT_TRANSPORT_CATEGORY = "attachment";
export declare const SESSION_TRANSPORT_CATEGORY = "session";
declare type TransportCategory = typeof ERROR_TRANSPORT_CATEGORY | typeof TRANSACTION_TRANSPORT_CATEGORY | typeof ATTACHMENT_TRANSPORT_CATEGORY | typeof SESSION_TRANSPORT_CATEGORY;
export declare type TransportRequest = {
    body: string;
    category: TransportCategory;
};
export declare type TransportMakeRequestResponse = {
    body?: string;
    headers?: {
        [key: string]: string | null;
        'x-sentry-rate-limits': string | null;
        'retry-after': string | null;
    };
    reason?: string;
    statusCode: number;
};
export declare type TransportResponse = {
    status: EventStatus;
    reason?: string;
};
interface InternalBaseTransportOptions {
    bufferSize?: number;
}
export interface BaseTransportOptions extends InternalBaseTransportOptions {
    url: string;
}
export interface BrowserTransportOptions extends BaseTransportOptions {
    fetchParams: Record<string, string>;
    headers?: Record<string, string>;
    sendClientReports?: boolean;
}
export interface NewTransport {
    send(request: Envelope): PromiseLike<TransportResponse>;
    flush(timeout?: number): PromiseLike<boolean>;
}
export declare type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;
export declare const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
/**
 * Creates a `NewTransport`
 *
 * @param options
 * @param makeRequest
 */
export declare function createTransport(options: InternalBaseTransportOptions, makeRequest: TransportRequestExecutor, buffer?: PromiseBuffer<TransportResponse>): NewTransport;
export {};
//# sourceMappingURL=base.d.ts.map{"version":3,"file":"base.d.ts","sourceRoot":"","sources":["../../../src/transports/base.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AACtD,OAAO,EAML,aAAa,EAMd,MAAM,eAAe,CAAC;AAEvB,eAAO,MAAM,wBAAwB,UAAU,CAAC;AAEhD,eAAO,MAAM,8BAA8B,gBAAgB,CAAC;AAE5D,eAAO,MAAM,6BAA6B,eAAe,CAAC;AAE1D,eAAO,MAAM,0BAA0B,YAAY,CAAC;AAEpD,aAAK,iBAAiB,GAClB,OAAO,wBAAwB,GAC/B,OAAO,8BAA8B,GACrC,OAAO,6BAA6B,GACpC,OAAO,0BAA0B,CAAC;AAEtC,oBAAY,gBAAgB,GAAG;IAC7B,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,iBAAiB,CAAC;CAC7B,CAAC;AAEF,oBAAY,4BAA4B,GAAG;IACzC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE;QACR,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC;QAC7B,sBAAsB,EAAE,MAAM,GAAG,IAAI,CAAC;QACtC,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;KAC9B,CAAC;IACF,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,iBAAiB,GAAG;IAC9B,MAAM,EAAE,WAAW,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF,UAAU,4BAA4B;IACpC,UAAU,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,MAAM,WAAW,oBAAqB,SAAQ,4BAA4B;IAIxE,GAAG,EAAE,MAAM,CAAC;CACb;AAGD,MAAM,WAAW,uBAAwB,SAAQ,oBAAoB;IAEnE,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACjC,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC7B;AAED,MAAM,WAAW,YAAY;IAC3B,IAAI,CAAC,OAAO,EAAE,QAAQ,GAAG,WAAW,CAAC,iBAAiB,CAAC,CAAC;IACxD,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;CAC/C;AAED,oBAAY,wBAAwB,GAAG,CAAC,OAAO,EAAE,gBAAgB,KAAK,WAAW,CAAC,4BAA4B,CAAC,CAAC;AAEhH,eAAO,MAAM,6BAA6B,KAAK,CAAC;AAEhD;;;;;GAKG;AACH,wBAAgB,eAAe,CAC7B,OAAO,EAAE,4BAA4B,EACrC,WAAW,EAAE,wBAAwB,EACrC,MAAM,GAAE,aAAa,CAAC,iBAAiB,CAA0E,GAChH,YAAY,CA8Cd"}import { disabledUntil, eventStatusFromHttpCode, getEnvelopeType, isRateLimited, makePromiseBuffer, rejectedSyncPromise, resolvedSyncPromise, serializeEnvelope, updateRateLimits, } from '@sentry/utils';
export var ERROR_TRANSPORT_CATEGORY = 'error';
export var TRANSACTION_TRANSPORT_CATEGORY = 'transaction';
export var ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';
export var SESSION_TRANSPORT_CATEGORY = 'session';
export var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
/**
 * Creates a `NewTransport`
 *
 * @param options
 * @param makeRequest
 */
export function createTransport(options, makeRequest, buffer) {
    if (buffer === void 0) { buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE); }
    var rateLimits = {};
    var flush = function (timeout) { return buffer.drain(timeout); };
    function send(envelope) {
        var envCategory = getEnvelopeType(envelope);
        var category = envCategory === 'event' ? 'error' : envCategory;
        var request = {
            category: category,
            body: serializeEnvelope(envelope),
        };
        // Don't add to buffer if transport is already rate-limited
        if (isRateLimited(rateLimits, category)) {
            return rejectedSyncPromise({
                status: 'rate_limit',
                reason: getRateLimitReason(rateLimits, category),
            });
        }
        var requestTask = function () {
            return makeRequest(request).then(function (_a) {
                var body = _a.body, headers = _a.headers, reason = _a.reason, statusCode = _a.statusCode;
                var status = eventStatusFromHttpCode(statusCode);
                if (headers) {
                    rateLimits = updateRateLimits(rateLimits, headers);
                }
                if (status === 'success') {
                    return resolvedSyncPromise({ status: status, reason: reason });
                }
                return rejectedSyncPromise({
                    status: status,
                    reason: reason ||
                        body ||
                        (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),
                });
            });
        };
        return buffer.add(requestTask);
    }
    return {
        send: send,
        flush: flush,
    };
}
function getRateLimitReason(rateLimits, category) {
    return "Too many " + category + " requests, backing off until: " + new Date(disabledUntil(rateLimits, category)).toISOString();
}
//# sourceMappingURL=base.js.map{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../src/transports/base.ts"],"names":[],"mappings":"AACA,OAAO,EACL,aAAa,EACb,uBAAuB,EACvB,eAAe,EACf,aAAa,EACb,iBAAiB,EAGjB,mBAAmB,EACnB,mBAAmB,EACnB,iBAAiB,EACjB,gBAAgB,GACjB,MAAM,eAAe,CAAC;AAEvB,MAAM,CAAC,IAAM,wBAAwB,GAAG,OAAO,CAAC;AAEhD,MAAM,CAAC,IAAM,8BAA8B,GAAG,aAAa,CAAC;AAE5D,MAAM,CAAC,IAAM,6BAA6B,GAAG,YAAY,CAAC;AAE1D,MAAM,CAAC,IAAM,0BAA0B,GAAG,SAAS,CAAC;AAuDpD,MAAM,CAAC,IAAM,6BAA6B,GAAG,EAAE,CAAC;AAEhD;;;;;GAKG;AACH,MAAM,UAAU,eAAe,CAC7B,OAAqC,EACrC,WAAqC,EACrC,MAAiH;IAAjH,uBAAA,EAAA,SAA2C,iBAAiB,CAAC,OAAO,CAAC,UAAU,IAAI,6BAA6B,CAAC;IAEjH,IAAI,UAAU,GAAe,EAAE,CAAC;IAEhC,IAAM,KAAK,GAAG,UAAC,OAAgB,IAA2B,OAAA,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAArB,CAAqB,CAAC;IAEhF,SAAS,IAAI,CAAC,QAAkB;QAC9B,IAAM,WAAW,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAM,QAAQ,GAAG,WAAW,KAAK,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAE,WAAiC,CAAC;QACxF,IAAM,OAAO,GAAqB;YAChC,QAAQ,UAAA;YACR,IAAI,EAAE,iBAAiB,CAAC,QAAQ,CAAC;SAClC,CAAC;QAEF,2DAA2D;QAC3D,IAAI,aAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,EAAE;YACvC,OAAO,mBAAmB,CAAC;gBACzB,MAAM,EAAE,YAAY;gBACpB,MAAM,EAAE,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC;aACjD,CAAC,CAAC;SACJ;QAED,IAAM,WAAW,GAAG;YAClB,OAAA,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,EAAqC;oBAAnC,cAAI,EAAE,oBAAO,EAAE,kBAAM,EAAE,0BAAU;gBAC5D,IAAM,MAAM,GAAG,uBAAuB,CAAC,UAAU,CAAC,CAAC;gBACnD,IAAI,OAAO,EAAE;oBACX,UAAU,GAAG,gBAAgB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;iBACpD;gBACD,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,OAAO,mBAAmB,CAAC,EAAE,MAAM,QAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;iBAChD;gBACD,OAAO,mBAAmB,CAAC;oBACzB,MAAM,QAAA;oBACN,MAAM,EACJ,MAAM;wBACN,IAAI;wBACJ,CAAC,MAAM,KAAK,YAAY,CAAC,CAAC,CAAC,kBAAkB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,yBAAyB,CAAC;iBACnG,CAAC,CAAC;YACL,CAAC,CAAC;QAfF,CAeE,CAAC;QAEL,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACjC,CAAC;IAED,OAAO;QACL,IAAI,MAAA;QACJ,KAAK,OAAA;KACN,CAAC;AACJ,CAAC;AAED,SAAS,kBAAkB,CAAC,UAAsB,EAAE,QAA2B;IAC7E,OAAO,cAAY,QAAQ,sCAAiC,IAAI,IAAI,CAClE,aAAa,CAAC,UAAU,EAAE,QAAQ,CAAC,CACpC,CAAC,WAAW,EAAI,CAAC;AACpB,CAAC","sourcesContent":["import { Envelope, EventStatus } from '@sentry/types';\nimport {\n  disabledUntil,\n  eventStatusFromHttpCode,\n  getEnvelopeType,\n  isRateLimited,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const ERROR_TRANSPORT_CATEGORY = 'error';\n\nexport const TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\n\nexport const ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\n\nexport const SESSION_TRANSPORT_CATEGORY = 'session';\n\ntype TransportCategory =\n  | typeof ERROR_TRANSPORT_CATEGORY\n  | typeof TRANSACTION_TRANSPORT_CATEGORY\n  | typeof ATTACHMENT_TRANSPORT_CATEGORY\n  | typeof SESSION_TRANSPORT_CATEGORY;\n\nexport type TransportRequest = {\n  body: string;\n  category: TransportCategory;\n};\n\nexport type TransportMakeRequestResponse = {\n  body?: string;\n  headers?: {\n    [key: string]: string | null;\n    'x-sentry-rate-limits': string | null;\n    'retry-after': string | null;\n  };\n  reason?: string;\n  statusCode: number;\n};\n\nexport type TransportResponse = {\n  status: EventStatus;\n  reason?: string;\n};\n\ninterface InternalBaseTransportOptions {\n  bufferSize?: number;\n}\n\nexport interface BaseTransportOptions extends InternalBaseTransportOptions {\n  // url to send the event\n  // transport does not care about dsn specific - client should take care of\n  // parsing and figuring that out\n  url: string;\n}\n\n// TODO: Move into Browser Transport\nexport interface BrowserTransportOptions extends BaseTransportOptions {\n  // options to pass into fetch request\n  fetchParams: Record<string, string>;\n  headers?: Record<string, string>;\n  sendClientReports?: boolean;\n}\n\nexport interface NewTransport {\n  send(request: Envelope): PromiseLike<TransportResponse>;\n  flush(timeout?: number): PromiseLike<boolean>;\n}\n\nexport type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportResponse> = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n): NewTransport {\n  let rateLimits: RateLimits = {};\n\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportResponse> {\n    const envCategory = getEnvelopeType(envelope);\n    const category = envCategory === 'event' ? 'error' : (envCategory as TransportCategory);\n    const request: TransportRequest = {\n      category,\n      body: serializeEnvelope(envelope),\n    };\n\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category),\n      });\n    }\n\n    const requestTask = (): PromiseLike<TransportResponse> =>\n      makeRequest(request).then(({ body, headers, reason, statusCode }): PromiseLike<TransportResponse> => {\n        const status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({ status, reason });\n        }\n        return rejectedSyncPromise({\n          status,\n          reason:\n            reason ||\n            body ||\n            (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),\n        });\n      });\n\n    return buffer.add(requestTask);\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getRateLimitReason(rateLimits: RateLimits, category: TransportCategory): string {\n  return `Too many ${category} requests, backing off until: ${new Date(\n    disabledUntil(rateLimits, category),\n  ).toISOString()}`;\n}\n"]}import { Event, Response, Transport } from '@sentry/types';
/** Noop transport */
export declare class NoopTransport implements Transport {
    /**
     * @inheritDoc
     */
    sendEvent(_: Event): PromiseLike<Response>;
    /**
     * @inheritDoc
     */
    close(_?: number): PromiseLike<boolean>;
}
//# sourceMappingURL=noop.d.ts.map{"version":3,"file":"noop.d.ts","sourceRoot":"","sources":["../../../src/transports/noop.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAG3D,qBAAqB;AACrB,qBAAa,aAAc,YAAW,SAAS;IAC7C;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC;IAOjD;;OAEG;IACI,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;CAG/C"}import { resolvedSyncPromise } from '@sentry/utils';
/** Noop transport */
var NoopTransport = /** @class */ (function () {
    function NoopTransport() {
    }
    /**
     * @inheritDoc
     */
    NoopTransport.prototype.sendEvent = function (_) {
        return resolvedSyncPromise({
            reason: 'NoopTransport: Event has been skipped because no Dsn is configured.',
            status: 'skipped',
        });
    };
    /**
     * @inheritDoc
     */
    NoopTransport.prototype.close = function (_) {
        return resolvedSyncPromise(true);
    };
    return NoopTransport;
}());
export { NoopTransport };
//# sourceMappingURL=noop.js.map{"version":3,"file":"noop.js","sourceRoot":"","sources":["../../../src/transports/noop.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,mBAAmB,EAAE,MAAM,eAAe,CAAC;AAEpD,qBAAqB;AACrB;IAAA;IAiBA,CAAC;IAhBC;;OAEG;IACI,iCAAS,GAAhB,UAAiB,CAAQ;QACvB,OAAO,mBAAmB,CAAC;YACzB,MAAM,EAAE,qEAAqE;YAC7E,MAAM,EAAE,SAAS;SAClB,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,6BAAK,GAAZ,UAAa,CAAU;QACrB,OAAO,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC;IACH,oBAAC;AAAD,CAAC,AAjBD,IAiBC","sourcesContent":["import { Event, Response, Transport } from '@sentry/types';\nimport { resolvedSyncPromise } from '@sentry/utils';\n\n/** Noop transport */\nexport class NoopTransport implements Transport {\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    return resolvedSyncPromise({\n      reason: 'NoopTransport: Event has been skipped because no Dsn is configured.',\n      status: 'skipped',\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(_?: number): PromiseLike<boolean> {\n    return resolvedSyncPromise(true);\n  }\n}\n"]}export declare const SDK_VERSION = "6.19.7";
//# sourceMappingURL=version.d.ts.map{"version":3,"file":"version.d.ts","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,WAAW,WAAW,CAAC"}export var SDK_VERSION = '6.19.7';
//# sourceMappingURL=version.js.map{"version":3,"file":"version.js","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,IAAM,WAAW,GAAG,QAAQ,CAAC","sourcesContent":["export const SDK_VERSION = '6.19.7';\n"]}BSD 3-Clause License

Copyright (c) 2019, Sentry
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@sentry/core",
  "version": "6.19.7",
  "description": "Base implementation for all Sentry JavaScript SDKs",
  "repository": "git://github.com/getsentry/sentry-javascript.git",
  "homepage": "https://github.com/getsentry/sentry-javascript/tree/master/packages/core",
  "author": "Sentry",
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=6"
  },
  "main": "dist/index.js",
  "module": "esm/index.js",
  "types": "types/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@sentry/hub": "6.19.7",
    "@sentry/minimal": "6.19.7",
    "@sentry/types": "6.19.7",
    "@sentry/utils": "6.19.7",
    "tslib": "^1.9.3"
  },
  "sideEffects": false
}<p align="center">
  <a href="https://sentry.io" target="_blank" align="center">
    <img src="https://sentry-brand.storage.googleapis.com/sentry-logo-black.png" width="280">
  </a>
  <br />
</p>

# Sentry JavaScript SDK Core

[![npm version](https://img.shields.io/npm/v/@sentry/core.svg)](https://www.npmjs.com/package/@sentry/core)
[![npm dm](https://img.shields.io/npm/dm/@sentry/core.svg)](https://www.npmjs.com/package/@sentry/core)
[![npm dt](https://img.shields.io/npm/dt/@sentry/core.svg)](https://www.npmjs.com/package/@sentry/core)
[![typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](http://getsentry.github.io/sentry-javascript/)

## Links

- [Official SDK Docs](https://docs.sentry.io/quickstart/)
- [TypeDoc](http://getsentry.github.io/sentry-javascript/)

## General

This package contains interface definitions, base classes and utilities for building Sentry JavaScript SDKs, like
`@sentry/node` or `@sentry/browser`.

Please consider all classes and exported functions and interfaces `internal`.
import { DsnComponents, DsnLike, SdkMetadata } from '@sentry/types';
/**
 * Stores details about a Sentry SDK
 */
export interface APIDetails {
    /** The DSN as passed to Sentry.init() */
    initDsn: DsnLike;
    /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */
    metadata: SdkMetadata;
    /** The internally used Dsn object. */
    readonly dsn: DsnComponents;
    /** The envelope tunnel to use. */
    readonly tunnel?: string;
}
/**
 * Helper class to provide urls, headers and metadata that can be used to form
 * different types of requests to Sentry endpoints.
 * Supports both envelopes and regular event requests.
 *
 * @deprecated Please use APIDetails
 **/
export declare class API {
    /** The DSN as passed to Sentry.init() */
    dsn: DsnLike;
    /** Metadata about the SDK (name, version, etc) for inclusion in envelope headers */
    metadata: SdkMetadata;
    /** The internally used Dsn object. */
    private readonly _dsnObject;
    /** The envelope tunnel to use. */
    private readonly _tunnel?;
    /** Create a new instance of API */
    constructor(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string);
    /** Returns the Dsn object. */
    getDsn(): DsnComponents;
    /** Does this transport force envelopes? */
    forceEnvelope(): boolean;
    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    getBaseApiEndpoint(): string;
    /** Returns the store endpoint URL. */
    getStoreEndpoint(): string;
    /**
     * Returns the store endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    getStoreEndpointWithUrlEncodedAuth(): string;
    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    getEnvelopeEndpointWithUrlEncodedAuth(): string;
}
/** Initializes API Details */
export declare function initAPIDetails(dsn: DsnLike, metadata?: SdkMetadata, tunnel?: string): APIDetails;
/**
 * Returns the store endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export declare function getStoreEndpointWithUrlEncodedAuth(dsn: DsnComponents): string;
/**
 * Returns the envelope endpoint URL with auth in the query string.
 *
 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
 */
export declare function getEnvelopeEndpointWithUrlEncodedAuth(dsn: DsnComponents, tunnel?: string): string;
/**
 * Returns an object that can be used in request headers.
 * This is needed for node and the old /store endpoint in sentry
 */
export declare function getRequestHeaders(dsn: DsnComponents, clientName: string, clientVersion: string): {
    [key: string]: string;
};
/** Returns the url to the report dialog endpoint. */
export declare function getReportDialogEndpoint(dsnLike: DsnLike, dialogOptions: {
    [key: string]: any;
    user?: {
        name?: string;
        email?: string;
    };
}): string;
//# sourceMappingURL=api.d.ts.map{"version":3,"file":"api.d.ts","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAKpE;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB,yCAAyC;IACzC,OAAO,EAAE,OAAO,CAAC;IACjB,oFAAoF;IACpF,QAAQ,EAAE,WAAW,CAAC;IACtB,sCAAsC;IACtC,QAAQ,CAAC,GAAG,EAAE,aAAa,CAAC;IAC5B,kCAAkC;IAClC,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC;CAC1B;AAED;;;;;;IAMI;AACJ,qBAAa,GAAG;IACd,yCAAyC;IAClC,GAAG,EAAE,OAAO,CAAC;IAEpB,oFAAoF;IAC7E,QAAQ,EAAE,WAAW,CAAC;IAE7B,sCAAsC;IACtC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAgB;IAE3C,kCAAkC;IAClC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAS;IAElC,mCAAmC;gBAChB,GAAG,EAAE,OAAO,EAAE,QAAQ,GAAE,WAAgB,EAAE,MAAM,CAAC,EAAE,MAAM;IAO5E,8BAA8B;IACvB,MAAM,IAAI,aAAa;IAI9B,2CAA2C;IACpC,aAAa,IAAI,OAAO;IAI/B,sEAAsE;IAC/D,kBAAkB,IAAI,MAAM;IAInC,sCAAsC;IAC/B,gBAAgB,IAAI,MAAM;IAIjC;;;;OAIG;IACI,kCAAkC,IAAI,MAAM;IAInD;;;;OAIG;IACI,qCAAqC,IAAI,MAAM;CAGvD;AAED,8BAA8B;AAC9B,wBAAgB,cAAc,CAAC,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,WAAW,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,UAAU,CAOhG;AA6BD;;;;GAIG;AACH,wBAAgB,kCAAkC,CAAC,GAAG,EAAE,aAAa,GAAG,MAAM,CAE7E;AAOD;;;;GAIG;AACH,wBAAgB,qCAAqC,CAAC,GAAG,EAAE,aAAa,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,MAAM,CAEjG;AAED;;;GAGG;AACH,wBAAgB,iBAAiB,CAC/B,GAAG,EAAE,aAAa,EAClB,UAAU,EAAE,MAAM,EAClB,aAAa,EAAE,MAAM,GACpB;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;CAAE,CAY3B;AAED,qDAAqD;AACrD,wBAAgB,uBAAuB,CACrC,OAAO,EAAE,OAAO,EAChB,aAAa,EAAE;IAEb,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAE,CAAC;CAC1C,GACA,MAAM,CA0BR"}import { Event, EventHint, Options, Session, Severity, Transport } from '@sentry/types';
import { NewTransport } from './transports/base';
/**
 * Internal platform-dependent Sentry SDK Backend.
 *
 * While {@link Client} contains business logic specific to an SDK, the
 * Backend offers platform specific implementations for low-level operations.
 * These are persisting and loading information, sending events, and hooking
 * into the environment.
 *
 * Backends receive a handle to the Client in their constructor. When a
 * Backend automatically generates events, it must pass them to
 * the Client for validation and processing first.
 *
 * Usually, the Client will be of corresponding type, e.g. NodeBackend
 * receives NodeClient. However, higher-level SDKs can choose to instantiate
 * multiple Backends and delegate tasks between them. In this case, an event
 * generated by one backend might very well be sent by another one.
 *
 * The client also provides access to options via {@link Client.getOptions}.
 * @hidden
 */
export interface Backend {
    /** Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`. */
    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;
    /** Creates an {@link Event} from primitive inputs to `captureMessage`. */
    eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;
    /** Submits the event to Sentry */
    sendEvent(event: Event): void;
    /** Submits the session to Sentry */
    sendSession(session: Session): void;
    /**
     * Returns the transport that is used by the backend.
     * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.
     *
     * @returns The transport.
     */
    getTransport(): Transport;
}
/**
 * A class object that can instantiate Backend objects.
 * @hidden
 */
export declare type BackendClass<B extends Backend, O extends Options> = new (options: O) => B;
/**
 * This is the base implemention of a Backend.
 * @hidden
 */
export declare abstract class BaseBackend<O extends Options> implements Backend {
    /** Options passed to the SDK. */
    protected readonly _options: O;
    /** Cached transport used internally. */
    protected _transport: Transport;
    /** New v7 Transport that is initialized alongside the old one */
    protected _newTransport?: NewTransport;
    /** Creates a new backend instance. */
    constructor(options: O);
    /**
     * @inheritDoc
     */
    eventFromException(_exception: any, _hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    eventFromMessage(_message: string, _level?: Severity, _hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): void;
    /**
     * @inheritDoc
     */
    sendSession(session: Session): void;
    /**
     * @inheritDoc
     */
    getTransport(): Transport;
    /**
     * Sets up the transport so it can be used later to send requests.
     */
    protected _setupTransport(): Transport;
}
//# sourceMappingURL=basebackend.d.ts.map{"version":3,"file":"basebackend.d.ts","sourceRoot":"","sources":["../../src/basebackend.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAMxF,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAGjD;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,WAAW,OAAO;IACtB,mHAAmH;IAEnH,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;IAEzE,0EAA0E;IAC1E,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;IAE1F,kCAAkC;IAClC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;IAE9B,oCAAoC;IACpC,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC;IAEpC;;;;;OAKG;IACH,YAAY,IAAI,SAAS,CAAC;CAC3B;AAED;;;GAGG;AACH,oBAAY,YAAY,CAAC,CAAC,SAAS,OAAO,EAAE,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAEvF;;;GAGG;AACH,8BAAsB,WAAW,CAAC,CAAC,SAAS,OAAO,CAAE,YAAW,OAAO;IACrE,iCAAiC;IACjC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;IAE/B,wCAAwC;IACxC,SAAS,CAAC,UAAU,EAAE,SAAS,CAAC;IAEhC,iEAAiE;IACjE,SAAS,CAAC,aAAa,CAAC,EAAE,YAAY,CAAC;IAEvC,sCAAsC;gBACnB,OAAO,EAAE,CAAC;IAQ7B;;OAEG;IAEI,kBAAkB,CAAC,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAIjF;;OAEG;IACI,gBAAgB,CAAC,QAAQ,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAInG;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI;IAoBpC;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAyB1C;;OAEG;IACI,YAAY,IAAI,SAAS;IAIhC;;OAEG;IACH,SAAS,CAAC,eAAe,IAAI,SAAS;CAGvC"}import { Scope, Session } from '@sentry/hub';
import { Client, DsnComponents, Event, EventHint, Integration, IntegrationClass, Options, Severity, Transport } from '@sentry/types';
import { Backend, BackendClass } from './basebackend';
import { IntegrationIndex } from './integration';
/**
 * Base implementation for all JavaScript SDK clients.
 *
 * Call the constructor with the corresponding backend constructor and options
 * specific to the client subclass. To access these options later, use
 * {@link Client.getOptions}. Also, the Backend instance is available via
 * {@link Client.getBackend}.
 *
 * If a Dsn is specified in the options, it will be parsed and stored. Use
 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
 * invalid, the constructor will throw a {@link SentryException}. Note that
 * without a valid Dsn, the SDK will not send any events to Sentry.
 *
 * Before sending an event via the backend, it is passed through
 * {@link BaseClient._prepareEvent} to add SDK information and scope data
 * (breadcrumbs and context). To add more custom information, override this
 * method and extend the resulting prepared event.
 *
 * To issue automatically created events (e.g. via instrumentation), use
 * {@link Client.captureEvent}. It will prepare the event and pass it through
 * the callback lifecycle. To issue auto-breadcrumbs, use
 * {@link Client.addBreadcrumb}.
 *
 * @example
 * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
 *   public constructor(options: NodeOptions) {
 *     super(NodeBackend, options);
 *   }
 *
 *   // ...
 * }
 */
export declare abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {
    /**
     * The backend used to physically interact in the environment. Usually, this
     * will correspond to the client. When composing SDKs, however, the Backend
     * from the root SDK will be used.
     */
    protected readonly _backend: B;
    /** Options passed to the SDK. */
    protected readonly _options: O;
    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
    protected readonly _dsn?: DsnComponents;
    /** Array of used integrations. */
    protected _integrations: IntegrationIndex;
    /** Number of calls being processed */
    protected _numProcessing: number;
    /**
     * Initializes this client instance.
     *
     * @param backendClass A constructor function to create the backend.
     * @param options Options for the client.
     */
    protected constructor(backendClass: BackendClass<B, O>, options: O);
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureSession(session: Session): void;
    /**
     * @inheritDoc
     */
    getDsn(): DsnComponents | undefined;
    /**
     * @inheritDoc
     */
    getOptions(): O;
    /**
     * @inheritDoc
     */
    getTransport(): Transport;
    /**
     * @inheritDoc
     */
    flush(timeout?: number): PromiseLike<boolean>;
    /**
     * @inheritDoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Sets up the integrations
     */
    setupIntegrations(): void;
    /**
     * @inheritDoc
     */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** Updates existing session based on the provided event */
    protected _updateSessionFromEvent(session: Session, event: Event): void;
    /** Deliver captured session to Sentry */
    protected _sendSession(session: Session): void;
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean>;
    /** Returns the current backend. */
    protected _getBackend(): B;
    /** Determines whether this SDK is enabled and a valid Dsn is present. */
    protected _isEnabled(): boolean;
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
     * Normalized keys:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * @param event Event
     * @returns Normalized event
     */
    protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null;
    /**
     *  Enhances event using the client configuration.
     *  It takes care of all "static" values like environment, release and `dist`,
     *  as well as truncating overly long values.
     * @param event event instance to be enhanced
     */
    protected _applyClientOptions(event: Event): void;
    /**
     * This function adds all used integrations to the SDK info in the event.
     * @param event The event that will be filled with all integrations.
     */
    protected _applyIntegrationsMetadata(event: Event): void;
    /**
     * Tells the backend to send this event
     * @param event The Sentry event to send
     */
    protected _sendEvent(event: Event): void;
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined>;
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event>;
    /**
     * Occupies the client with processing and event
     */
    protected _process<T>(promise: PromiseLike<T>): void;
}
//# sourceMappingURL=baseclient.d.ts.map{"version":3,"file":"baseclient.d.ts","sourceRoot":"","sources":["../../src/baseclient.ts"],"names":[],"mappings":"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"}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}export { addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, startTransaction, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/minimal';
export { addGlobalEventProcessor, getCurrentHub, getHubFromCarrier, Hub, makeMain, Scope, Session } from '@sentry/hub';
export { API, APIDetails, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, getRequestHeaders, initAPIDetails, getReportDialogEndpoint, } from './api';
export { BaseClient } from './baseclient';
export { BackendClass, BaseBackend } from './basebackend';
export { eventToSentryRequest, sessionToSentryRequest } from './request';
export { initAndBind, ClientClass } from './sdk';
export { NoopTransport } from './transports/noop';
export { BaseTransportOptions, createTransport, NewTransport, TransportMakeRequestResponse, TransportRequest, TransportRequestExecutor, } from './transports/base';
export { SDK_VERSION } from './version';
import * as Integrations from './integrations';
export { Integrations };
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,gBAAgB,EAChB,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,uBAAuB,EAAE,aAAa,EAAE,iBAAiB,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AACvH,OAAO,EAEL,GAAG,EACH,UAAU,EACV,qCAAqC,EACrC,kCAAkC,EAClC,iBAAiB,EACjB,cAAc,EACd,uBAAuB,GACxB,MAAM,OAAO,CAAC;AACf,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,YAAY,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC1D,OAAO,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,MAAM,WAAW,CAAC;AACzE,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AACjD,OAAO,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAClD,OAAO,EACL,oBAAoB,EACpB,eAAe,EACf,YAAY,EACZ,4BAA4B,EAC5B,gBAAgB,EAChB,wBAAwB,GACzB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,KAAK,YAAY,MAAM,gBAAgB,CAAC;AAE/C,OAAO,EAAE,YAAY,EAAE,CAAC"}import { Integration, Options } from '@sentry/types';
export declare const installedIntegrations: string[];
/** Map of integrations assigned to a client */
export declare type IntegrationIndex = {
    [key: string]: Integration;
} & {
    initialized?: boolean;
};
/** Gets integration to install */
export declare function getIntegrationsToSetup(options: Options): Integration[];
/** Setup given integration */
export declare function setupIntegration(integration: Integration): void;
/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
export declare function setupIntegrations<O extends Options>(options: O): IntegrationIndex;
//# sourceMappingURL=integration.d.ts.map{"version":3,"file":"integration.d.ts","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAKrD,eAAO,MAAM,qBAAqB,EAAE,MAAM,EAAO,CAAC;AAElD,+CAA+C;AAC/C,oBAAY,gBAAgB,GAAG;IAC7B,CAAC,GAAG,EAAE,MAAM,GAAG,WAAW,CAAC;CAC5B,GAAG;IAAE,WAAW,CAAC,EAAE,OAAO,CAAA;CAAE,CAAC;AAc9B,kCAAkC;AAClC,wBAAgB,sBAAsB,CAAC,OAAO,EAAE,OAAO,GAAG,WAAW,EAAE,CA4BtE;AAED,8BAA8B;AAC9B,wBAAgB,gBAAgB,CAAC,WAAW,EAAE,WAAW,GAAG,IAAI,CAO/D;AAED;;;;;GAKG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,SAAS,OAAO,EAAE,OAAO,EAAE,CAAC,GAAG,gBAAgB,CAWjF"}import { Integration } from '@sentry/types';
/** Patch toString calls to return proper name for wrapped functions */
export declare class FunctionToString implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=functiontostring.d.ts.map{"version":3,"file":"functiontostring.d.ts","sourceRoot":"","sources":["../../../src/integrations/functiontostring.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAmB,MAAM,eAAe,CAAC;AAK7D,uEAAuE;AACvE,qBAAa,gBAAiB,YAAW,WAAW;IAClD;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAsB;IAE9C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAuB;IAE1C;;OAEG;IACI,SAAS,IAAI,IAAI;CAUzB"}import { Event, EventProcessor, Hub, Integration } from '@sentry/types';
/** Options for the InboundFilters integration */
export interface InboundFiltersOptions {
    allowUrls: Array<string | RegExp>;
    denyUrls: Array<string | RegExp>;
    ignoreErrors: Array<string | RegExp>;
    ignoreInternal: boolean;
    /** @deprecated use {@link InboundFiltersOptions.allowUrls} instead. */
    whitelistUrls: Array<string | RegExp>;
    /** @deprecated use {@link InboundFiltersOptions.denyUrls} instead. */
    blacklistUrls: Array<string | RegExp>;
}
/** Inbound filters configurable by the user */
export declare class InboundFilters implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    constructor(_options?: Partial<InboundFiltersOptions>);
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (processor: EventProcessor) => void, getCurrentHub: () => Hub): void;
}
/** JSDoc */
export declare function _mergeOptions(internalOptions?: Partial<InboundFiltersOptions>, clientOptions?: Partial<InboundFiltersOptions>): Partial<InboundFiltersOptions>;
/** JSDoc */
export declare function _shouldDropEvent(event: Event, options: Partial<InboundFiltersOptions>): boolean;
//# sourceMappingURL=inboundfilters.d.ts.map{"version":3,"file":"inboundfilters.d.ts","sourceRoot":"","sources":["../../../src/integrations/inboundfilters.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAc,MAAM,eAAe,CAAC;AASpF,iDAAiD;AACjD,MAAM,WAAW,qBAAqB;IACpC,SAAS,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IAClC,QAAQ,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACjC,YAAY,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACrC,cAAc,EAAE,OAAO,CAAC;IAExB,uEAAuE;IACvE,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,sEAAsE;IACtE,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;CACvC;AAED,+CAA+C;AAC/C,qBAAa,cAAe,YAAW,WAAW;IAW7B,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAV5C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAoB;IAE5C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAqB;gBAEJ,QAAQ,GAAE,OAAO,CAAC,qBAAqB,CAAM;IAEjF;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,SAAS,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;CAe/G;AAED,YAAY;AACZ,wBAAgB,aAAa,CAC3B,eAAe,GAAE,OAAO,CAAC,qBAAqB,CAAM,EACpD,aAAa,GAAE,OAAO,CAAC,qBAAqB,CAAM,GACjD,OAAO,CAAC,qBAAqB,CAAC,CAyBhC;AAED,YAAY;AACZ,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,qBAAqB,CAAC,GAAG,OAAO,CAgC/F"}export { FunctionToString } from './functiontostring';
export { InboundFilters } from './inboundfilters';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC"}import { Event, EventEnvelope, SentryRequest, SentryRequestType, Session, SessionAggregates, SessionEnvelope } from '@sentry/types';
import { APIDetails } from './api';
/** Creates an envelope from a Session */
export declare function createSessionEnvelope(session: Session | SessionAggregates, api: APIDetails): [SessionEnvelope, SentryRequestType];
/** Creates a SentryRequest from a Session. */
export declare function sessionToSentryRequest(session: Session | SessionAggregates, api: APIDetails): SentryRequest;
/**
 * Create an Envelope from an event. Note that this is duplicated from below,
 * but on purpose as this will be refactored in v7.
 */
export declare function createEventEnvelope(event: Event, api: APIDetails): EventEnvelope;
/** Creates a SentryRequest from an event. */
export declare function eventToSentryRequest(event: Event, api: APIDetails): SentryRequest;
//# sourceMappingURL=request.d.ts.map{"version":3,"file":"request.d.ts","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,KAAK,EACL,aAAa,EAGb,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,eAAe,EAEhB,MAAM,eAAe,CAAC;AAGvB,OAAO,EAAE,UAAU,EAA6E,MAAM,OAAO,CAAC;AA2B9G,yCAAyC;AACzC,wBAAgB,qBAAqB,CACnC,OAAO,EAAE,OAAO,GAAG,iBAAiB,EACpC,GAAG,EAAE,UAAU,GACd,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAgBtC;AAED,8CAA8C;AAC9C,wBAAgB,sBAAsB,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAO3G;AAED;;;GAGG;AACH,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAkDhF;AAED,6CAA6C;AAC7C,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,GAAG,aAAa,CAgGjF"}import { Client, Options } from '@sentry/types';
/** A class object that can instantiate Client objects. */
export declare type ClientClass<F extends Client, O extends Options> = new (options: O) => F;
/**
 * Internal function to create a new SDK client instance. The client is
 * installed and then bound to the current scope.
 *
 * @param clientClass The client class to instantiate.
 * @param options Options to pass to the client.
 */
export declare function initAndBind<F extends Client, O extends Options>(clientClass: ClientClass<F, O>, options: O): void;
//# sourceMappingURL=sdk.d.ts.map{"version":3,"file":"sdk.d.ts","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAKhD,0DAA0D;AAC1D,oBAAY,WAAW,CAAC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;AAErF;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,CAAC,SAAS,MAAM,EAAE,CAAC,SAAS,OAAO,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,GAAG,IAAI,CAiBjH"}import { Envelope, EventStatus } from '@sentry/types';
import { PromiseBuffer } from '@sentry/utils';
export declare const ERROR_TRANSPORT_CATEGORY = "error";
export declare const TRANSACTION_TRANSPORT_CATEGORY = "transaction";
export declare const ATTACHMENT_TRANSPORT_CATEGORY = "attachment";
export declare const SESSION_TRANSPORT_CATEGORY = "session";
declare type TransportCategory = typeof ERROR_TRANSPORT_CATEGORY | typeof TRANSACTION_TRANSPORT_CATEGORY | typeof ATTACHMENT_TRANSPORT_CATEGORY | typeof SESSION_TRANSPORT_CATEGORY;
export declare type TransportRequest = {
    body: string;
    category: TransportCategory;
};
export declare type TransportMakeRequestResponse = {
    body?: string;
    headers?: {
        [key: string]: string | null;
        'x-sentry-rate-limits': string | null;
        'retry-after': string | null;
    };
    reason?: string;
    statusCode: number;
};
export declare type TransportResponse = {
    status: EventStatus;
    reason?: string;
};
interface InternalBaseTransportOptions {
    bufferSize?: number;
}
export interface BaseTransportOptions extends InternalBaseTransportOptions {
    url: string;
}
export interface BrowserTransportOptions extends BaseTransportOptions {
    fetchParams: Record<string, string>;
    headers?: Record<string, string>;
    sendClientReports?: boolean;
}
export interface NewTransport {
    send(request: Envelope): PromiseLike<TransportResponse>;
    flush(timeout?: number): PromiseLike<boolean>;
}
export declare type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;
export declare const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
/**
 * Creates a `NewTransport`
 *
 * @param options
 * @param makeRequest
 */
export declare function createTransport(options: InternalBaseTransportOptions, makeRequest: TransportRequestExecutor, buffer?: PromiseBuffer<TransportResponse>): NewTransport;
export {};
//# sourceMappingURL=base.d.ts.map{"version":3,"file":"base.d.ts","sourceRoot":"","sources":["../../../src/transports/base.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AACtD,OAAO,EAML,aAAa,EAMd,MAAM,eAAe,CAAC;AAEvB,eAAO,MAAM,wBAAwB,UAAU,CAAC;AAEhD,eAAO,MAAM,8BAA8B,gBAAgB,CAAC;AAE5D,eAAO,MAAM,6BAA6B,eAAe,CAAC;AAE1D,eAAO,MAAM,0BAA0B,YAAY,CAAC;AAEpD,aAAK,iBAAiB,GAClB,OAAO,wBAAwB,GAC/B,OAAO,8BAA8B,GACrC,OAAO,6BAA6B,GACpC,OAAO,0BAA0B,CAAC;AAEtC,oBAAY,gBAAgB,GAAG;IAC7B,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,iBAAiB,CAAC;CAC7B,CAAC;AAEF,oBAAY,4BAA4B,GAAG;IACzC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE;QACR,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC;QAC7B,sBAAsB,EAAE,MAAM,GAAG,IAAI,CAAC;QACtC,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;KAC9B,CAAC;IACF,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,UAAU,EAAE,MAAM,CAAC;CACpB,CAAC;AAEF,oBAAY,iBAAiB,GAAG;IAC9B,MAAM,EAAE,WAAW,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF,UAAU,4BAA4B;IACpC,UAAU,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,MAAM,WAAW,oBAAqB,SAAQ,4BAA4B;IAIxE,GAAG,EAAE,MAAM,CAAC;CACb;AAGD,MAAM,WAAW,uBAAwB,SAAQ,oBAAoB;IAEnE,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACjC,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC7B;AAED,MAAM,WAAW,YAAY;IAC3B,IAAI,CAAC,OAAO,EAAE,QAAQ,GAAG,WAAW,CAAC,iBAAiB,CAAC,CAAC;IACxD,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;CAC/C;AAED,oBAAY,wBAAwB,GAAG,CAAC,OAAO,EAAE,gBAAgB,KAAK,WAAW,CAAC,4BAA4B,CAAC,CAAC;AAEhH,eAAO,MAAM,6BAA6B,KAAK,CAAC;AAEhD;;;;;GAKG;AACH,wBAAgB,eAAe,CAC7B,OAAO,EAAE,4BAA4B,EACrC,WAAW,EAAE,wBAAwB,EACrC,MAAM,GAAE,aAAa,CAAC,iBAAiB,CAA0E,GAChH,YAAY,CA8Cd"}import { Event, Response, Transport } from '@sentry/types';
/** Noop transport */
export declare class NoopTransport implements Transport {
    /**
     * @inheritDoc
     */
    sendEvent(_: Event): PromiseLike<Response>;
    /**
     * @inheritDoc
     */
    close(_?: number): PromiseLike<boolean>;
}
//# sourceMappingURL=noop.d.ts.map{"version":3,"file":"noop.d.ts","sourceRoot":"","sources":["../../../src/transports/noop.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAG3D,qBAAqB;AACrB,qBAAa,aAAc,YAAW,SAAS;IAC7C;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC;IAOjD;;OAEG;IACI,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;CAG/C"}export declare const SDK_VERSION = "6.19.7";
//# sourceMappingURL=version.d.ts.map{"version":3,"file":"version.d.ts","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,WAAW,WAAW,CAAC"}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** Flag that is true for debug builds, false otherwise. */
exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;AAIH,2DAA2D;AAC9C,QAAA,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}import { Breadcrumb, BreadcrumbHint, Client, CustomSamplingContext, Event, EventHint, Extra, Extras, Hub as HubInterface, Integration, IntegrationClass, Primitive, SessionContext, Severity, Span, SpanContext, Transaction, TransactionContext, User } from '@sentry/types';
import { Scope } from './scope';
import { Session } from './session';
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
export declare const API_VERSION = 4;
/**
 * A layer in the process stack.
 * @hidden
 */
export interface Layer {
    client?: Client;
    scope?: Scope;
}
/**
 * An object that contains a hub and maintains a scope stack.
 * @hidden
 */
export interface Carrier {
    __SENTRY__?: {
        hub?: Hub;
        /**
         * Extra Hub properties injected by various SDKs
         */
        integrations?: Integration[];
        extensions?: {
            /** Hack to prevent bundlers from breaking our usage of the domain package in the cross-platform Hub package */
            domain?: {
                [key: string]: any;
            };
        } & {
            /** Extension methods for the hub, which are bound to the current Hub instance */
            [key: string]: Function;
        };
    };
}
/**
 * @hidden
 * @deprecated Can be removed once `Hub.getActiveDomain` is removed.
 */
export interface DomainAsCarrier extends Carrier {
    members: {
        [key: string]: any;
    }[];
}
/**
 * @inheritDoc
 */
export declare class Hub implements HubInterface {
    private readonly _version;
    /** Is a {@link Layer}[] containing the client and scope */
    private readonly _stack;
    /** Contains the last event id of a captured event.  */
    private _lastEventId?;
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    constructor(client?: Client, scope?: Scope, _version?: number);
    /**
     * @inheritDoc
     */
    isOlderThan(version: number): boolean;
    /**
     * @inheritDoc
     */
    bindClient(client?: Client): void;
    /**
     * @inheritDoc
     */
    pushScope(): Scope;
    /**
     * @inheritDoc
     */
    popScope(): boolean;
    /**
     * @inheritDoc
     */
    withScope(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    getClient<C extends Client>(): C | undefined;
    /** Returns the scope of the top stack. */
    getScope(): Scope | undefined;
    /** Returns the scope stack for domains or the process. */
    getStack(): Layer[];
    /** Returns the topmost scope layer in the order domain > local > process. */
    getStackTop(): Layer;
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    lastEventId(): string | undefined;
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;
    /**
     * @inheritDoc
     */
    setUser(user: User | null): void;
    /**
     * @inheritDoc
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): void;
    /**
     * @inheritDoc
     */
    setExtras(extras: Extras): void;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: Primitive): void;
    /**
     * @inheritDoc
     */
    setExtra(key: string, extra: Extra): void;
    /**
     * @inheritDoc
     */
    setContext(name: string, context: {
        [key: string]: any;
    } | null): void;
    /**
     * @inheritDoc
     */
    configureScope(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    run(callback: (hub: Hub) => void): void;
    /**
     * @inheritDoc
     */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /**
     * @inheritDoc
     */
    startSpan(context: SpanContext): Span;
    /**
     * @inheritDoc
     */
    startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
    /**
     * @inheritDoc
     */
    traceHeaders(): {
        [key: string]: string;
    };
    /**
     * @inheritDoc
     */
    captureSession(endSession?: boolean): void;
    /**
     * @inheritDoc
     */
    endSession(): void;
    /**
     * @inheritDoc
     */
    startSession(context?: SessionContext): Session;
    /**
     * Sends the current Session on the scope
     */
    private _sendSessionUpdate;
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    private _invokeClient;
    /**
     * Calls global extension method and binding current instance to the function call
     */
    private _callExtensionMethod;
}
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
export declare function getMainCarrier(): Carrier;
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
export declare function makeMain(hub: Hub): Hub;
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
export declare function getCurrentHub(): Hub;
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
export declare function getActiveDomain(): DomainAsCarrier | undefined;
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
export declare function getHubFromCarrier(carrier: Carrier): Hub;
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
export declare function setHubOnCarrier(carrier: Carrier, hub: Hub): boolean;
//# sourceMappingURL=hub.d.ts.map{"version":3,"file":"hub.d.ts","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
var flags_1 = require("./flags");
var scope_1 = require("./scope");
var session_1 = require("./session");
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
exports.API_VERSION = 4;
/**
 * Default maximum number of breadcrumbs added to an event. Can be overwritten
 * with {@link Options.maxBreadcrumbs}.
 */
var DEFAULT_BREADCRUMBS = 100;
/**
 * @inheritDoc
 */
var Hub = /** @class */ (function () {
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    function Hub(client, scope, _version) {
        if (scope === void 0) { scope = new scope_1.Scope(); }
        if (_version === void 0) { _version = exports.API_VERSION; }
        this._version = _version;
        /** Is a {@link Layer}[] containing the client and scope */
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
            this.bindClient(client);
        }
    }
    /**
     * @inheritDoc
     */
    Hub.prototype.isOlderThan = function (version) {
        return this._version < version;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.bindClient = function (client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
            client.setupIntegrations();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.pushScope = function () {
        // We want to clone the content of prev scope
        var scope = scope_1.Scope.clone(this.getScope());
        this.getStack().push({
            client: this.getClient(),
            scope: scope,
        });
        return scope;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.popScope = function () {
        if (this.getStack().length <= 1)
            return false;
        return !!this.getStack().pop();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.withScope = function (callback) {
        var scope = this.pushScope();
        try {
            callback(scope);
        }
        finally {
            this.popScope();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getClient = function () {
        return this.getStackTop().client;
    };
    /** Returns the scope of the top stack. */
    Hub.prototype.getScope = function () {
        return this.getStackTop().scope;
    };
    /** Returns the scope stack for domains or the process. */
    Hub.prototype.getStack = function () {
        return this._stack;
    };
    /** Returns the topmost scope layer in the order domain > local > process. */
    Hub.prototype.getStackTop = function () {
        return this._stack[this._stack.length - 1];
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    Hub.prototype.captureException = function (exception, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error('Sentry syntheticException');
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: exception,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureException', exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureMessage = function (message, level, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error(message);
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: message,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureMessage', message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureEvent = function (event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4();
        if (event.type !== 'transaction') {
            this._lastEventId = eventId;
        }
        this._invokeClient('captureEvent', event, tslib_1.__assign(tslib_1.__assign({}, hint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.lastEventId = function () {
        return this._lastEventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope || !client)
            return;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _b = (client.getOptions && client.getOptions()) || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
        if (maxBreadcrumbs <= 0)
            return;
        var timestamp = utils_1.dateTimestampInSeconds();
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb
            ? utils_1.consoleSandbox(function () { return beforeBreadcrumb(mergedBreadcrumb, hint); })
            : mergedBreadcrumb;
        if (finalBreadcrumb === null)
            return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setUser = function (user) {
        var scope = this.getScope();
        if (scope)
            scope.setUser(user);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTags = function (tags) {
        var scope = this.getScope();
        if (scope)
            scope.setTags(tags);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtras = function (extras) {
        var scope = this.getScope();
        if (scope)
            scope.setExtras(extras);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTag = function (key, value) {
        var scope = this.getScope();
        if (scope)
            scope.setTag(key, value);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtra = function (key, extra) {
        var scope = this.getScope();
        if (scope)
            scope.setExtra(key, extra);
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype.setContext = function (name, context) {
        var scope = this.getScope();
        if (scope)
            scope.setContext(name, context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.configureScope = function (callback) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (scope && client) {
            callback(scope);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.run = function (callback) {
        var oldHub = makeMain(this);
        try {
            callback(this);
        }
        finally {
            makeMain(oldHub);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getIntegration = function (integration) {
        var client = this.getClient();
        if (!client)
            return null;
        try {
            return client.getIntegration(integration);
        }
        catch (_oO) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSpan = function (context) {
        return this._callExtensionMethod('startSpan', context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startTransaction = function (context, customSamplingContext) {
        return this._callExtensionMethod('startTransaction', context, customSamplingContext);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.traceHeaders = function () {
        return this._callExtensionMethod('traceHeaders');
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureSession = function (endSession) {
        if (endSession === void 0) { endSession = false; }
        // both send the update and pull the session from the scope
        if (endSession) {
            return this.endSession();
        }
        // only send the update
        this._sendSessionUpdate();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.endSession = function () {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
            session.close();
        }
        this._sendSessionUpdate();
        // the session is over; take it off of the scope
        if (scope) {
            scope.setSession();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSession = function (context) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        var _b = (client && client.getOptions()) || {}, release = _b.release, environment = _b.environment;
        // Will fetch userAgent if called from browser sdk
        var global = utils_1.getGlobalObject();
        var userAgent = (global.navigator || {}).userAgent;
        var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ release: release,
            environment: environment }, (scope && { user: scope.getUser() })), (userAgent && { userAgent: userAgent })), context));
        if (scope) {
            // End existing session if there's one
            var currentSession = scope.getSession && scope.getSession();
            if (currentSession && currentSession.status === 'ok') {
                currentSession.update({ status: 'exited' });
            }
            this.endSession();
            // Afterwards we set the new session on the scope
            scope.setSession(session);
        }
        return session;
    };
    /**
     * Sends the current Session on the scope
     */
    Hub.prototype._sendSessionUpdate = function () {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope)
            return;
        var session = scope.getSession && scope.getSession();
        if (session) {
            if (client && client.captureSession) {
                client.captureSession(session);
            }
        }
    };
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._invokeClient = function (method) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
            (_a = client)[method].apply(_a, tslib_1.__spread(args, [scope]));
        }
    };
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._callExtensionMethod = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
            return sentry.extensions[method].apply(this, args);
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub;
}());
exports.Hub = Hub;
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
function getMainCarrier() {
    var carrier = utils_1.getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: undefined,
    };
    return carrier;
}
exports.getMainCarrier = getMainCarrier;
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
}
exports.makeMain = makeMain;
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
function getCurrentHub() {
    // Get main carrier (global for every environment)
    var registry = getMainCarrier();
    // If there's no hub, or its an old API, assign a new one
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports.API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
    }
    // Prefer domains over global if they are there (applicable only to Node environment)
    if (utils_1.isNodeEnv()) {
        return getHubFromActiveDomain(registry);
    }
    // Return hub that lives on a global object
    return getHubFromCarrier(registry);
}
exports.getCurrentHub = getCurrentHub;
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
// eslint-disable-next-line deprecation/deprecation
function getActiveDomain() {
    flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');
    var sentry = getMainCarrier().__SENTRY__;
    return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
}
exports.getActiveDomain = getActiveDomain;
/**
 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
 * @returns discovered hub
 */
function getHubFromActiveDomain(registry) {
    try {
        var sentry = getMainCarrier().__SENTRY__;
        var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
        // If there's no active domain, just return global hub
        if (!activeDomain) {
            return getHubFromCarrier(registry);
        }
        // If there's no hub on current domain, or it's an old API, assign a new one
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports.API_VERSION)) {
            var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
            setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
        }
        // Return hub that lives on a domain
        return getHubFromCarrier(activeDomain);
    }
    catch (_Oo) {
        // Return hub that lives on a global object
        return getHubFromCarrier(registry);
    }
}
/**
 * This will tell whether a carrier has a hub on it or not
 * @param carrier object
 */
function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
function getHubFromCarrier(carrier) {
    return utils_1.getGlobalSingleton('hub', function () { return new Hub(); }, carrier);
}
exports.getHubFromCarrier = getHubFromCarrier;
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
function setHubOnCarrier(carrier, hub) {
    if (!carrier)
        return false;
    var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});
    __SENTRY__.hub = hub;
    return true;
}
exports.setHubOnCarrier = setHubOnCarrier;
//# sourceMappingURL=hub.js.map{"version":3,"file":"hub.js","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport {\n  Breadcrumb,\n  BreadcrumbHint,\n  Client,\n  CustomSamplingContext,\n  Event,\n  EventHint,\n  Extra,\n  Extras,\n  Hub as HubInterface,\n  Integration,\n  IntegrationClass,\n  Primitive,\n  SessionContext,\n  Severity,\n  Span,\n  SpanContext,\n  Transaction,\n  TransactionContext,\n  User,\n} from '@sentry/types';\nimport {\n  consoleSandbox,\n  dateTimestampInSeconds,\n  getGlobalObject,\n  getGlobalSingleton,\n  isNodeEnv,\n  logger,\n  uuid4,\n} from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Scope } from './scope';\nimport { Session } from './session';\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */\nexport const API_VERSION = 4;\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 100;\n\n/**\n * A layer in the process stack.\n * @hidden\n */\nexport interface Layer {\n  client?: Client;\n  scope?: Scope;\n}\n\n/**\n * An object that contains a hub and maintains a scope stack.\n * @hidden\n */\nexport interface Carrier {\n  __SENTRY__?: {\n    hub?: Hub;\n    /**\n     * Extra Hub properties injected by various SDKs\n     */\n    integrations?: Integration[];\n    extensions?: {\n      /** Hack to prevent bundlers from breaking our usage of the domain package in the cross-platform Hub package */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      domain?: { [key: string]: any };\n    } & {\n      /** Extension methods for the hub, which are bound to the current Hub instance */\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      [key: string]: Function;\n    };\n  };\n}\n\n/**\n * @hidden\n * @deprecated Can be removed once `Hub.getActiveDomain` is removed.\n */\nexport interface DomainAsCarrier extends Carrier {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  members: { [key: string]: any }[];\n}\n\n/**\n * @inheritDoc\n */\nexport class Hub implements HubInterface {\n  /** Is a {@link Layer}[] containing the client and scope */\n  private readonly _stack: Layer[] = [{}];\n\n  /** Contains the last event id of a captured event.  */\n  private _lastEventId?: string;\n\n  /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   */\n  public constructor(client?: Client, scope: Scope = new Scope(), private readonly _version: number = API_VERSION) {\n    this.getStackTop().scope = scope;\n    if (client) {\n      this.bindClient(client);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public isOlderThan(version: number): boolean {\n    return this._version < version;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public bindClient(client?: Client): void {\n    const top = this.getStackTop();\n    top.client = client;\n    if (client && client.setupIntegrations) {\n      client.setupIntegrations();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public pushScope(): Scope {\n    // We want to clone the content of prev scope\n    const scope = Scope.clone(this.getScope());\n    this.getStack().push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public popScope(): boolean {\n    if (this.getStack().length <= 1) return false;\n    return !!this.getStack().pop();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public withScope(callback: (scope: Scope) => void): void {\n    const scope = this.pushScope();\n    try {\n      callback(scope);\n    } finally {\n      this.popScope();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getClient<C extends Client>(): C | undefined {\n    return this.getStackTop().client as C;\n  }\n\n  /** Returns the scope of the top stack. */\n  public getScope(): Scope | undefined {\n    return this.getStackTop().scope;\n  }\n\n  /** Returns the scope stack for domains or the process. */\n  public getStack(): Layer[] {\n    return this._stack;\n  }\n\n  /** Returns the topmost scope layer in the order domain > local > process. */\n  public getStackTop(): Layer {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint): string {\n    const eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    let finalHint = hint;\n\n    // If there's no explicit hint provided, mimic the same thing that would happen\n    // in the minimal itself to create a consistent behavior.\n    // We don't do this in the client, as it's the lowest level API, and doing this,\n    // would prevent user from having full control over direct calls.\n    if (!hint) {\n      let syntheticException: Error;\n      try {\n        throw new Error('Sentry syntheticException');\n      } catch (exception) {\n        syntheticException = exception as Error;\n      }\n      finalHint = {\n        originalException: exception,\n        syntheticException,\n      };\n    }\n\n    this._invokeClient('captureException', exception, {\n      ...finalHint,\n      event_id: eventId,\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint): string {\n    const eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    let finalHint = hint;\n\n    // If there's no explicit hint provided, mimic the same thing that would happen\n    // in the minimal itself to create a consistent behavior.\n    // We don't do this in the client, as it's the lowest level API, and doing this,\n    // would prevent user from having full control over direct calls.\n    if (!hint) {\n      let syntheticException: Error;\n      try {\n        throw new Error(message);\n      } catch (exception) {\n        syntheticException = exception as Error;\n      }\n      finalHint = {\n        originalException: message,\n        syntheticException,\n      };\n    }\n\n    this._invokeClient('captureMessage', message, level, {\n      ...finalHint,\n      event_id: eventId,\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint): string {\n    const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n    if (event.type !== 'transaction') {\n      this._lastEventId = eventId;\n    }\n\n    this._invokeClient('captureEvent', event, {\n      ...hint,\n      event_id: eventId,\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public lastEventId(): string | undefined {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void {\n    const { scope, client } = this.getStackTop();\n\n    if (!scope || !client) return;\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =\n      (client.getOptions && client.getOptions()) || {};\n\n    if (maxBreadcrumbs <= 0) return;\n\n    const timestamp = dateTimestampInSeconds();\n    const mergedBreadcrumb = { timestamp, ...breadcrumb };\n    const finalBreadcrumb = beforeBreadcrumb\n      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) as Breadcrumb | null)\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) return;\n\n    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setUser(user: User | null): void {\n    const scope = this.getScope();\n    if (scope) scope.setUser(user);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTags(tags: { [key: string]: Primitive }): void {\n    const scope = this.getScope();\n    if (scope) scope.setTags(tags);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtras(extras: Extras): void {\n    const scope = this.getScope();\n    if (scope) scope.setExtras(extras);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTag(key: string, value: Primitive): void {\n    const scope = this.getScope();\n    if (scope) scope.setTag(key, value);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtra(key: string, extra: Extra): void {\n    const scope = this.getScope();\n    if (scope) scope.setExtra(key, extra);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public setContext(name: string, context: { [key: string]: any } | null): void {\n    const scope = this.getScope();\n    if (scope) scope.setContext(name, context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public configureScope(callback: (scope: Scope) => void): void {\n    const { scope, client } = this.getStackTop();\n    if (scope && client) {\n      callback(scope);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public run(callback: (hub: Hub) => void): void {\n    const oldHub = makeMain(this);\n    try {\n      callback(this);\n    } finally {\n      makeMain(oldHub);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    const client = this.getClient();\n    if (!client) return null;\n    try {\n      return client.getIntegration(integration);\n    } catch (_oO) {\n      IS_DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startSpan(context: SpanContext): Span {\n    return this._callExtensionMethod('startSpan', context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction {\n    return this._callExtensionMethod('startTransaction', context, customSamplingContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public traceHeaders(): { [key: string]: string } {\n    return this._callExtensionMethod<{ [key: string]: string }>('traceHeaders');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(endSession: boolean = false): void {\n    // both send the update and pull the session from the scope\n    if (endSession) {\n      return this.endSession();\n    }\n\n    // only send the update\n    this._sendSessionUpdate();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public endSession(): void {\n    const layer = this.getStackTop();\n    const scope = layer && layer.scope;\n    const session = scope && scope.getSession();\n    if (session) {\n      session.close();\n    }\n    this._sendSessionUpdate();\n\n    // the session is over; take it off of the scope\n    if (scope) {\n      scope.setSession();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startSession(context?: SessionContext): Session {\n    const { scope, client } = this.getStackTop();\n    const { release, environment } = (client && client.getOptions()) || {};\n\n    // Will fetch userAgent if called from browser sdk\n    const global = getGlobalObject<{ navigator?: { userAgent?: string } }>();\n    const { userAgent } = global.navigator || {};\n\n    const session = new Session({\n      release,\n      environment,\n      ...(scope && { user: scope.getUser() }),\n      ...(userAgent && { userAgent }),\n      ...context,\n    });\n\n    if (scope) {\n      // End existing session if there's one\n      const currentSession = scope.getSession && scope.getSession();\n      if (currentSession && currentSession.status === 'ok') {\n        currentSession.update({ status: 'exited' });\n      }\n      this.endSession();\n\n      // Afterwards we set the new session on the scope\n      scope.setSession(session);\n    }\n\n    return session;\n  }\n\n  /**\n   * Sends the current Session on the scope\n   */\n  private _sendSessionUpdate(): void {\n    const { scope, client } = this.getStackTop();\n    if (!scope) return;\n\n    const session = scope.getSession && scope.getSession();\n    if (session) {\n      if (client && client.captureSession) {\n        client.captureSession(session);\n      }\n    }\n  }\n\n  /**\n   * Internal helper function to call a method on the top client if it exists.\n   *\n   * @param method The method to call on the client.\n   * @param args Arguments to pass to the client function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _invokeClient<M extends keyof Client>(method: M, ...args: any[]): void {\n    const { scope, client } = this.getStackTop();\n    if (client && client[method]) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n      (client as any)[method](...args, scope);\n    }\n  }\n\n  /**\n   * Calls global extension method and binding current instance to the function call\n   */\n  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _callExtensionMethod<T>(method: string, ...args: any[]): T {\n    const carrier = getMainCarrier();\n    const sentry = carrier.__SENTRY__;\n    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {\n      return sentry.extensions[method].apply(this, args);\n    }\n    IS_DEBUG_BUILD && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n  }\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nexport function getMainCarrier(): Carrier {\n  const carrier = getGlobalObject();\n  carrier.__SENTRY__ = carrier.__SENTRY__ || {\n    extensions: {},\n    hub: undefined,\n  };\n  return carrier;\n}\n\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n */\nexport function makeMain(hub: Hub): Hub {\n  const registry = getMainCarrier();\n  const oldHub = getHubFromCarrier(registry);\n  setHubOnCarrier(registry, hub);\n  return oldHub;\n}\n\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n */\nexport function getCurrentHub(): Hub {\n  // Get main carrier (global for every environment)\n  const registry = getMainCarrier();\n\n  // If there's no hub, or its an old API, assign a new one\n  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n    setHubOnCarrier(registry, new Hub());\n  }\n\n  // Prefer domains over global if they are there (applicable only to Node environment)\n  if (isNodeEnv()) {\n    return getHubFromActiveDomain(registry);\n  }\n  // Return hub that lives on a global object\n  return getHubFromCarrier(registry);\n}\n\n/**\n * Returns the active domain, if one exists\n * @deprecated No longer used; remove in v7\n * @returns The domain, or undefined if there is no active domain\n */\n// eslint-disable-next-line deprecation/deprecation\nexport function getActiveDomain(): DomainAsCarrier | undefined {\n  IS_DEBUG_BUILD && logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');\n\n  const sentry = getMainCarrier().__SENTRY__;\n\n  return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n}\n\n/**\n * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist\n * @returns discovered hub\n */\nfunction getHubFromActiveDomain(registry: Carrier): Hub {\n  try {\n    const sentry = getMainCarrier().__SENTRY__;\n    const activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n\n    // If there's no active domain, just return global hub\n    if (!activeDomain) {\n      return getHubFromCarrier(registry);\n    }\n\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {\n      const registryHubTopStack = getHubFromCarrier(registry).getStackTop();\n      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));\n    }\n\n    // Return hub that lives on a domain\n    return getHubFromCarrier(activeDomain);\n  } catch (_Oo) {\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n  }\n}\n\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */\nfunction hasHubOnCarrier(carrier: Carrier): boolean {\n  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */\nexport function getHubFromCarrier(carrier: Carrier): Hub {\n  return getGlobalSingleton<Hub>('hub', () => new Hub(), carrier);\n}\n\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */\nexport function setHubOnCarrier(carrier: Carrier, hub: Hub): boolean {\n  if (!carrier) return false;\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n  __SENTRY__.hub = hub;\n  return true;\n}\n"]}export { addGlobalEventProcessor, Scope } from './scope';
export { Session } from './session';
export { SessionFlusher } from './sessionflusher';
export { getActiveDomain, getCurrentHub, getHubFromCarrier, getMainCarrier, Hub, makeMain, setHubOnCarrier, Carrier, DomainAsCarrier, Layer, } from './hub';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,uBAAuB,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AACzD,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAEL,eAAe,EACf,aAAa,EACb,iBAAiB,EACjB,cAAc,EACd,GAAG,EACH,QAAQ,EACR,eAAe,EACf,OAAO,EAEP,eAAe,EACf,KAAK,GACN,MAAM,OAAO,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var scope_1 = require("./scope");
exports.addGlobalEventProcessor = scope_1.addGlobalEventProcessor;
exports.Scope = scope_1.Scope;
var session_1 = require("./session");
exports.Session = session_1.Session;
var sessionflusher_1 = require("./sessionflusher");
exports.SessionFlusher = sessionflusher_1.SessionFlusher;
var hub_1 = require("./hub");
// eslint-disable-next-line deprecation/deprecation
exports.getActiveDomain = hub_1.getActiveDomain;
exports.getCurrentHub = hub_1.getCurrentHub;
exports.getHubFromCarrier = hub_1.getHubFromCarrier;
exports.getMainCarrier = hub_1.getMainCarrier;
exports.Hub = hub_1.Hub;
exports.makeMain = hub_1.makeMain;
exports.setHubOnCarrier = hub_1.setHubOnCarrier;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA,iCAAyD;AAAhD,0CAAA,uBAAuB,CAAA;AAAE,wBAAA,KAAK,CAAA;AACvC,qCAAoC;AAA3B,4BAAA,OAAO,CAAA;AAChB,mDAAkD;AAAzC,0CAAA,cAAc,CAAA;AACvB,6BAae;AAZb,mDAAmD;AACnD,gCAAA,eAAe,CAAA;AACf,8BAAA,aAAa,CAAA;AACb,kCAAA,iBAAiB,CAAA;AACjB,+BAAA,cAAc,CAAA;AACd,oBAAA,GAAG,CAAA;AACH,yBAAA,QAAQ,CAAA;AACR,gCAAA,eAAe,CAAA","sourcesContent":["export { addGlobalEventProcessor, Scope } from './scope';\nexport { Session } from './session';\nexport { SessionFlusher } from './sessionflusher';\nexport {\n  // eslint-disable-next-line deprecation/deprecation\n  getActiveDomain,\n  getCurrentHub,\n  getHubFromCarrier,\n  getMainCarrier,\n  Hub,\n  makeMain,\n  setHubOnCarrier,\n  Carrier,\n  // eslint-disable-next-line deprecation/deprecation\n  DomainAsCarrier,\n  Layer,\n} from './hub';\n"]}import { Breadcrumb, CaptureContext, Context, Contexts, Event, EventHint, EventProcessor, Extra, Extras, Primitive, RequestSession, Scope as ScopeInterface, Severity, Span, Transaction, User } from '@sentry/types';
import { Session } from './session';
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
export declare class Scope implements ScopeInterface {
    /** Flag if notifying is happening. */
    protected _notifyingListeners: boolean;
    /** Callback for client to receive scope changes. */
    protected _scopeListeners: Array<(scope: Scope) => void>;
    /** Callback list that will be called after {@link applyToEvent}. */
    protected _eventProcessors: EventProcessor[];
    /** Array of breadcrumbs. */
    protected _breadcrumbs: Breadcrumb[];
    /** User */
    protected _user: User;
    /** Tags */
    protected _tags: {
        [key: string]: Primitive;
    };
    /** Extra */
    protected _extra: Extras;
    /** Contexts */
    protected _contexts: Contexts;
    /** Fingerprint */
    protected _fingerprint?: string[];
    /** Severity */
    protected _level?: Severity;
    /** Transaction Name */
    protected _transactionName?: string;
    /** Span */
    protected _span?: Span;
    /** Session */
    protected _session?: Session;
    /** Request Mode Session Status */
    protected _requestSession?: RequestSession;
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    protected _sdkProcessingMetadata?: {
        [key: string]: unknown;
    };
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    static clone(scope?: Scope): Scope;
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    addScopeListener(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    addEventProcessor(callback: EventProcessor): this;
    /**
     * @inheritDoc
     */
    setUser(user: User | null): this;
    /**
     * @inheritDoc
     */
    getUser(): User | undefined;
    /**
     * @inheritDoc
     */
    getRequestSession(): RequestSession | undefined;
    /**
     * @inheritDoc
     */
    setRequestSession(requestSession?: RequestSession): this;
    /**
     * @inheritDoc
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): this;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: Primitive): this;
    /**
     * @inheritDoc
     */
    setExtras(extras: Extras): this;
    /**
     * @inheritDoc
     */
    setExtra(key: string, extra: Extra): this;
    /**
     * @inheritDoc
     */
    setFingerprint(fingerprint: string[]): this;
    /**
     * @inheritDoc
     */
    setLevel(level: Severity): this;
    /**
     * @inheritDoc
     */
    setTransactionName(name?: string): this;
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    setTransaction(name?: string): this;
    /**
     * @inheritDoc
     */
    setContext(key: string, context: Context | null): this;
    /**
     * @inheritDoc
     */
    setSpan(span?: Span): this;
    /**
     * @inheritDoc
     */
    getSpan(): Span | undefined;
    /**
     * @inheritDoc
     */
    getTransaction(): Transaction | undefined;
    /**
     * @inheritDoc
     */
    setSession(session?: Session): this;
    /**
     * @inheritDoc
     */
    getSession(): Session | undefined;
    /**
     * @inheritDoc
     */
    update(captureContext?: CaptureContext): this;
    /**
     * @inheritDoc
     */
    clear(): this;
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;
    /**
     * @inheritDoc
     */
    clearBreadcrumbs(): this;
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    applyToEvent(event: Event, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    setSDKProcessingMetadata(newData: {
        [key: string]: unknown;
    }): this;
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    protected _notifyEventProcessors(processors: EventProcessor[], event: Event | null, hint?: EventHint, index?: number): PromiseLike<Event | null>;
    /**
     * This will be called on every set call.
     */
    protected _notifyScopeListeners(): void;
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    private _applyFingerprint;
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
export declare function addGlobalEventProcessor(callback: EventProcessor): void;
//# sourceMappingURL=scope.d.ts.map{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
/**
 * Absolute maximum number of breadcrumbs added to an event.
 * The `maxBreadcrumbs` option cannot be higher than this value.
 */
var MAX_BREADCRUMBS = 100;
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
var Scope = /** @class */ (function () {
    function Scope() {
        /** Flag if notifying is happening. */
        this._notifyingListeners = false;
        /** Callback for client to receive scope changes. */
        this._scopeListeners = [];
        /** Callback list that will be called after {@link applyToEvent}. */
        this._eventProcessors = [];
        /** Array of breadcrumbs. */
        this._breadcrumbs = [];
        /** User */
        this._user = {};
        /** Tags */
        this._tags = {};
        /** Extra */
        this._extra = {};
        /** Contexts */
        this._contexts = {};
        /**
         * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
         * sent to Sentry
         */
        this._sdkProcessingMetadata = {};
    }
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    Scope.clone = function (scope) {
        var newScope = new Scope();
        if (scope) {
            newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
            newScope._tags = tslib_1.__assign({}, scope._tags);
            newScope._extra = tslib_1.__assign({}, scope._extra);
            newScope._contexts = tslib_1.__assign({}, scope._contexts);
            newScope._user = scope._user;
            newScope._level = scope._level;
            newScope._span = scope._span;
            newScope._session = scope._session;
            newScope._transactionName = scope._transactionName;
            newScope._fingerprint = scope._fingerprint;
            newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
            newScope._requestSession = scope._requestSession;
        }
        return newScope;
    };
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    Scope.prototype.addScopeListener = function (callback) {
        this._scopeListeners.push(callback);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addEventProcessor = function (callback) {
        this._eventProcessors.push(callback);
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setUser = function (user) {
        this._user = user || {};
        if (this._session) {
            this._session.update({ user: user });
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getUser = function () {
        return this._user;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getRequestSession = function () {
        return this._requestSession;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setRequestSession = function (requestSession) {
        this._requestSession = requestSession;
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTags = function (tags) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTag = function (key, value) {
        var _a;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtras = function (extras) {
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtra = function (key, extra) {
        var _a;
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setFingerprint = function (fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setLevel = function (level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTransactionName = function (name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    Scope.prototype.setTransaction = function (name) {
        return this.setTransactionName(name);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setContext = function (key, context) {
        var _a;
        if (context === null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete this._contexts[key];
        }
        else {
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSpan = function (span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSpan = function () {
        return this._span;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getTransaction = function () {
        // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
        // have a pointer to the currently-active transaction.
        var span = this.getSpan();
        return span && span.transaction;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSession = function (session) {
        if (!session) {
            delete this._session;
        }
        else {
            this._session = session;
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSession = function () {
        return this._session;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.update = function (captureContext) {
        if (!captureContext) {
            return this;
        }
        if (typeof captureContext === 'function') {
            var updatedScope = captureContext(this);
            return updatedScope instanceof Scope ? updatedScope : this;
        }
        if (captureContext instanceof Scope) {
            this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
            this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
            if (captureContext._user && Object.keys(captureContext._user).length) {
                this._user = captureContext._user;
            }
            if (captureContext._level) {
                this._level = captureContext._level;
            }
            if (captureContext._fingerprint) {
                this._fingerprint = captureContext._fingerprint;
            }
            if (captureContext._requestSession) {
                this._requestSession = captureContext._requestSession;
            }
        }
        else if (utils_1.isPlainObject(captureContext)) {
            // eslint-disable-next-line no-param-reassign
            captureContext = captureContext;
            this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
            this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
            if (captureContext.user) {
                this._user = captureContext.user;
            }
            if (captureContext.level) {
                this._level = captureContext.level;
            }
            if (captureContext.fingerprint) {
                this._fingerprint = captureContext.fingerprint;
            }
            if (captureContext.requestSession) {
                this._requestSession = captureContext.requestSession;
            }
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clear = function () {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._requestSession = undefined;
        this._span = undefined;
        this._session = undefined;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        // No data has been changed, so don't notify scope listeners
        if (maxCrumbs <= 0) {
            return this;
        }
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: utils_1.dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clearBreadcrumbs = function () {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    Scope.prototype.applyToEvent = function (event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
            event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
            event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
            event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
            event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
            event.level = this._level;
        }
        if (this._transactionName) {
            event.transaction = this._transactionName;
        }
        // We want to set the trace context for normal events only if there isn't already
        // a trace context on the event. There is a product feature in place where we link
        // errors with transaction and it relies on that.
        if (this._span) {
            event.contexts = tslib_1.__assign({ trace: this._span.getTraceContext() }, event.contexts);
            var transactionName = this._span.transaction && this._span.transaction.name;
            if (transactionName) {
                event.tags = tslib_1.__assign({ transaction: transactionName }, event.tags);
            }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = tslib_1.__spread((event.breadcrumbs || []), this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    Scope.prototype.setSDKProcessingMetadata = function (newData) {
        this._sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, this._sdkProcessingMetadata), newData);
        return this;
    };
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
        var _this = this;
        if (index === void 0) { index = 0; }
        return new utils_1.SyncPromise(function (resolve, reject) {
            var processor = processors[index];
            if (event === null || typeof processor !== 'function') {
                resolve(event);
            }
            else {
                var result = processor(tslib_1.__assign({}, event), hint);
                if (utils_1.isThenable(result)) {
                    void result
                        .then(function (final) { return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve); })
                        .then(null, reject);
                }
                else {
                    void _this._notifyEventProcessors(processors, result, hint, index + 1)
                        .then(resolve)
                        .then(null, reject);
                }
            }
        });
    };
    /**
     * This will be called on every set call.
     */
    Scope.prototype._notifyScopeListeners = function () {
        var _this = this;
        // We need this check for this._notifyingListeners to be able to work on scope during updates
        // If this check is not here we'll produce endless recursion when something is done with the scope
        // during the callback.
        if (!this._notifyingListeners) {
            this._notifyingListeners = true;
            this._scopeListeners.forEach(function (callback) {
                callback(_this);
            });
            this._notifyingListeners = false;
        }
    };
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    Scope.prototype._applyFingerprint = function (event) {
        // Make sure it's an array first and we actually have something in place
        event.fingerprint = event.fingerprint
            ? Array.isArray(event.fingerprint)
                ? event.fingerprint
                : [event.fingerprint]
            : [];
        // If we have something on the scope, then merge it with event
        if (this._fingerprint) {
            event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        // If we have no data at all, remove empty array default
        if (event.fingerprint && !event.fingerprint.length) {
            delete event.fingerprint;
        }
    };
    return Scope;
}());
exports.Scope = Scope;
/**
 * Returns the global event processors.
 */
function getGlobalEventProcessors() {
    return utils_1.getGlobalSingleton('globalEventProcessors', function () { return []; });
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
}
exports.addGlobalEventProcessor = addGlobalEventProcessor;
//# sourceMappingURL=scope.js.map{"version":3,"file":"scope.js","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport {\n  Breadcrumb,\n  CaptureContext,\n  Context,\n  Contexts,\n  Event,\n  EventHint,\n  EventProcessor,\n  Extra,\n  Extras,\n  Primitive,\n  RequestSession,\n  Scope as ScopeInterface,\n  ScopeContext,\n  Severity,\n  Span,\n  Transaction,\n  User,\n} from '@sentry/types';\nimport { dateTimestampInSeconds, getGlobalSingleton, isPlainObject, isThenable, SyncPromise } from '@sentry/utils';\n\nimport { Session } from './session';\n\n/**\n * Absolute maximum number of breadcrumbs added to an event.\n * The `maxBreadcrumbs` option cannot be higher than this value.\n */\nconst MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nexport class Scope implements ScopeInterface {\n  /** Flag if notifying is happening. */\n  protected _notifyingListeners: boolean = false;\n\n  /** Callback for client to receive scope changes. */\n  protected _scopeListeners: Array<(scope: Scope) => void> = [];\n\n  /** Callback list that will be called after {@link applyToEvent}. */\n  protected _eventProcessors: EventProcessor[] = [];\n\n  /** Array of breadcrumbs. */\n  protected _breadcrumbs: Breadcrumb[] = [];\n\n  /** User */\n  protected _user: User = {};\n\n  /** Tags */\n  protected _tags: { [key: string]: Primitive } = {};\n\n  /** Extra */\n  protected _extra: Extras = {};\n\n  /** Contexts */\n  protected _contexts: Contexts = {};\n\n  /** Fingerprint */\n  protected _fingerprint?: string[];\n\n  /** Severity */\n  protected _level?: Severity;\n\n  /** Transaction Name */\n  protected _transactionName?: string;\n\n  /** Span */\n  protected _span?: Span;\n\n  /** Session */\n  protected _session?: Session;\n\n  /** Request Mode Session Status */\n  protected _requestSession?: RequestSession;\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  protected _sdkProcessingMetadata?: { [key: string]: unknown } = {};\n\n  /**\n   * Inherit values from the parent scope.\n   * @param scope to clone.\n   */\n  public static clone(scope?: Scope): Scope {\n    const newScope = new Scope();\n    if (scope) {\n      newScope._breadcrumbs = [...scope._breadcrumbs];\n      newScope._tags = { ...scope._tags };\n      newScope._extra = { ...scope._extra };\n      newScope._contexts = { ...scope._contexts };\n      newScope._user = scope._user;\n      newScope._level = scope._level;\n      newScope._span = scope._span;\n      newScope._session = scope._session;\n      newScope._transactionName = scope._transactionName;\n      newScope._fingerprint = scope._fingerprint;\n      newScope._eventProcessors = [...scope._eventProcessors];\n      newScope._requestSession = scope._requestSession;\n    }\n    return newScope;\n  }\n\n  /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */\n  public addScopeListener(callback: (scope: Scope) => void): void {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addEventProcessor(callback: EventProcessor): this {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setUser(user: User | null): this {\n    this._user = user || {};\n    if (this._session) {\n      this._session.update({ user });\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getUser(): User | undefined {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getRequestSession(): RequestSession | undefined {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setRequestSession(requestSession?: RequestSession): this {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTags(tags: { [key: string]: Primitive }): this {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTag(key: string, value: Primitive): this {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtras(extras: Extras): this {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtra(key: string, extra: Extra): this {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setFingerprint(fingerprint: string[]): this {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setLevel(level: Severity): this {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTransactionName(name?: string): this {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Can be removed in major version.\n   * @deprecated in favor of {@link this.setTransactionName}\n   */\n  public setTransaction(name?: string): this {\n    return this.setTransactionName(name);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setContext(key: string, context: Context | null): this {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts = { ...this._contexts, [key]: context };\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setSpan(span?: Span): this {\n    this._span = span;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getSpan(): Span | undefined {\n    return this._span;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransaction(): Transaction | undefined {\n    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n    // have a pointer to the currently-active transaction.\n    const span = this.getSpan();\n    return span && span.transaction;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setSession(session?: Session): this {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getSession(): Session | undefined {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public update(captureContext?: CaptureContext): this {\n    if (!captureContext) {\n      return this;\n    }\n\n    if (typeof captureContext === 'function') {\n      const updatedScope = (captureContext as <T>(scope: T) => T)(this);\n      return updatedScope instanceof Scope ? updatedScope : this;\n    }\n\n    if (captureContext instanceof Scope) {\n      this._tags = { ...this._tags, ...captureContext._tags };\n      this._extra = { ...this._extra, ...captureContext._extra };\n      this._contexts = { ...this._contexts, ...captureContext._contexts };\n      if (captureContext._user && Object.keys(captureContext._user).length) {\n        this._user = captureContext._user;\n      }\n      if (captureContext._level) {\n        this._level = captureContext._level;\n      }\n      if (captureContext._fingerprint) {\n        this._fingerprint = captureContext._fingerprint;\n      }\n      if (captureContext._requestSession) {\n        this._requestSession = captureContext._requestSession;\n      }\n    } else if (isPlainObject(captureContext)) {\n      // eslint-disable-next-line no-param-reassign\n      captureContext = captureContext as ScopeContext;\n      this._tags = { ...this._tags, ...captureContext.tags };\n      this._extra = { ...this._extra, ...captureContext.extra };\n      this._contexts = { ...this._contexts, ...captureContext.contexts };\n      if (captureContext.user) {\n        this._user = captureContext.user;\n      }\n      if (captureContext.level) {\n        this._level = captureContext.level;\n      }\n      if (captureContext.fingerprint) {\n        this._fingerprint = captureContext.fingerprint;\n      }\n      if (captureContext.requestSession) {\n        this._requestSession = captureContext.requestSession;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public clear(): this {\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._span = undefined;\n    this._session = undefined;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n    };\n    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public clearBreadcrumbs(): this {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Applies the current context and fingerprint to the event.\n   * Note that breadcrumbs will be added by the client.\n   * Also if the event has already breadcrumbs on it, we do not merge them.\n   * @param event Event\n   * @param hint May contain additional information about the original exception.\n   * @hidden\n   */\n  public applyToEvent(event: Event, hint?: EventHint): PromiseLike<Event | null> {\n    if (this._extra && Object.keys(this._extra).length) {\n      event.extra = { ...this._extra, ...event.extra };\n    }\n    if (this._tags && Object.keys(this._tags).length) {\n      event.tags = { ...this._tags, ...event.tags };\n    }\n    if (this._user && Object.keys(this._user).length) {\n      event.user = { ...this._user, ...event.user };\n    }\n    if (this._contexts && Object.keys(this._contexts).length) {\n      event.contexts = { ...this._contexts, ...event.contexts };\n    }\n    if (this._level) {\n      event.level = this._level;\n    }\n    if (this._transactionName) {\n      event.transaction = this._transactionName;\n    }\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (this._span) {\n      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };\n      const transactionName = this._span.transaction && this._span.transaction.name;\n      if (transactionName) {\n        event.tags = { transaction: transactionName, ...event.tags };\n      }\n    }\n\n    this._applyFingerprint(event);\n\n    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];\n    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;\n\n    event.sdkProcessingMetadata = this._sdkProcessingMetadata;\n\n    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */\n  public setSDKProcessingMetadata(newData: { [key: string]: unknown }): this {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * This will be called after {@link applyToEvent} is finished.\n   */\n  protected _notifyEventProcessors(\n    processors: EventProcessor[],\n    event: Event | null,\n    hint?: EventHint,\n    index: number = 0,\n  ): PromiseLike<Event | null> {\n    return new SyncPromise<Event | null>((resolve, reject) => {\n      const processor = processors[index];\n      if (event === null || typeof processor !== 'function') {\n        resolve(event);\n      } else {\n        const result = processor({ ...event }, hint) as Event | null;\n        if (isThenable(result)) {\n          void result\n            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n            .then(null, reject);\n        } else {\n          void this._notifyEventProcessors(processors, result, hint, index + 1)\n            .then(resolve)\n            .then(null, reject);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n  protected _notifyScopeListeners(): void {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n\n  /**\n   * Applies fingerprint from the scope to the event if there's one,\n   * uses message if there's one instead or get rid of empty fingerprint\n   */\n  private _applyFingerprint(event: Event): void {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint\n      ? Array.isArray(event.fingerprint)\n        ? event.fingerprint\n        : [event.fingerprint]\n      : [];\n\n    // If we have something on the scope, then merge it with event\n    if (this._fingerprint) {\n      event.fingerprint = event.fingerprint.concat(this._fingerprint);\n    }\n\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n}\n\n/**\n * Returns the global event processors.\n */\nfunction getGlobalEventProcessors(): EventProcessor[] {\n  return getGlobalSingleton<EventProcessor[]>('globalEventProcessors', () => []);\n}\n\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nexport function addGlobalEventProcessor(callback: EventProcessor): void {\n  getGlobalEventProcessors().push(callback);\n}\n"]}import { Session as SessionInterface, SessionContext, SessionStatus } from '@sentry/types';
/**
 * @inheritdoc
 */
export declare class Session implements SessionInterface {
    userAgent?: string;
    errors: number;
    release?: string;
    sid: string;
    did?: string;
    timestamp: number;
    started: number;
    duration?: number;
    status: SessionStatus;
    environment?: string;
    ipAddress?: string;
    init: boolean;
    ignoreDuration: boolean;
    constructor(context?: Omit<SessionContext, 'started' | 'status'>);
    /** JSDoc */
    update(context?: SessionContext): void;
    /** JSDoc */
    close(status?: Exclude<SessionStatus, 'ok'>): void;
    /** JSDoc */
    toJSON(): {
        init: boolean;
        sid: string;
        did?: string;
        timestamp: string;
        started: string;
        duration?: number;
        status: SessionStatus;
        errors: number;
        attrs?: {
            release?: string;
            environment?: string;
            user_agent?: string;
            ip_address?: string;
        };
    };
}
//# sourceMappingURL=session.d.ts.map{"version":3,"file":"session.d.ts","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,IAAI,gBAAgB,EAAE,cAAc,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAG3F;;GAEG;AACH,qBAAa,OAAQ,YAAW,gBAAgB;IACvC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAK;IACnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,GAAG,EAAE,MAAM,CAAW;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAK;IACtB,MAAM,EAAE,aAAa,CAAQ;IAC7B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,EAAE,OAAO,CAAQ;IACrB,cAAc,EAAE,OAAO,CAAS;gBAEpB,OAAO,CAAC,EAAE,IAAI,CAAC,cAAc,EAAE,SAAS,GAAG,QAAQ,CAAC;IAUvE,YAAY;IAEL,MAAM,CAAC,OAAO,GAAE,cAAmB,GAAG,IAAI;IAwDjD,YAAY;IACL,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,IAAI;IAUzD,YAAY;IACL,MAAM,IAAI;QACf,IAAI,EAAE,OAAO,CAAC;QACd,GAAG,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,MAAM,CAAC;QAClB,OAAO,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,MAAM,EAAE,aAAa,CAAC;QACtB,MAAM,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE;YACN,OAAO,CAAC,EAAE,MAAM,CAAC;YACjB,WAAW,CAAC,EAAE,MAAM,CAAC;YACrB,UAAU,CAAC,EAAE,MAAM,CAAC;YACpB,UAAU,CAAC,EAAE,MAAM,CAAC;SACrB,CAAC;KACH;CAmBF"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
/**
 * @inheritdoc
 */
var Session = /** @class */ (function () {
    function Session(context) {
        this.errors = 0;
        this.sid = utils_1.uuid4();
        this.duration = 0;
        this.status = 'ok';
        this.init = true;
        this.ignoreDuration = false;
        // Both timestamp and started are in seconds since the UNIX epoch.
        var startingTime = utils_1.timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
            this.update(context);
        }
    }
    /** JSDoc */
    // eslint-disable-next-line complexity
    Session.prototype.update = function (context) {
        if (context === void 0) { context = {}; }
        if (context.user) {
            if (!this.ipAddress && context.user.ip_address) {
                this.ipAddress = context.user.ip_address;
            }
            if (!this.did && !context.did) {
                this.did = context.user.id || context.user.email || context.user.username;
            }
        }
        this.timestamp = context.timestamp || utils_1.timestampInSeconds();
        if (context.ignoreDuration) {
            this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
            // Good enough uuid validation. — Kamil
            this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
        }
        if (context.init !== undefined) {
            this.init = context.init;
        }
        if (!this.did && context.did) {
            this.did = "" + context.did;
        }
        if (typeof context.started === 'number') {
            this.started = context.started;
        }
        if (this.ignoreDuration) {
            this.duration = undefined;
        }
        else if (typeof context.duration === 'number') {
            this.duration = context.duration;
        }
        else {
            var duration = this.timestamp - this.started;
            this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
            this.release = context.release;
        }
        if (context.environment) {
            this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
            this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
            this.userAgent = context.userAgent;
        }
        if (typeof context.errors === 'number') {
            this.errors = context.errors;
        }
        if (context.status) {
            this.status = context.status;
        }
    };
    /** JSDoc */
    Session.prototype.close = function (status) {
        if (status) {
            this.update({ status: status });
        }
        else if (this.status === 'ok') {
            this.update({ status: 'exited' });
        }
        else {
            this.update();
        }
    };
    /** JSDoc */
    Session.prototype.toJSON = function () {
        return utils_1.dropUndefinedKeys({
            sid: "" + this.sid,
            init: this.init,
            // Make sure that sec is converted to ms for date constructor
            started: new Date(this.started * 1000).toISOString(),
            timestamp: new Date(this.timestamp * 1000).toISOString(),
            status: this.status,
            errors: this.errors,
            did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
            duration: this.duration,
            attrs: {
                release: this.release,
                environment: this.environment,
                ip_address: this.ipAddress,
                user_agent: this.userAgent,
            },
        });
    };
    return Session;
}());
exports.Session = Session;
//# sourceMappingURL=session.js.map{"version":3,"file":"session.js","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"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","sourcesContent":["import { Session as SessionInterface, SessionContext, SessionStatus } from '@sentry/types';\nimport { dropUndefinedKeys, timestampInSeconds, uuid4 } from '@sentry/utils';\n\n/**\n * @inheritdoc\n */\nexport class Session implements SessionInterface {\n  public userAgent?: string;\n  public errors: number = 0;\n  public release?: string;\n  public sid: string = uuid4();\n  public did?: string;\n  public timestamp: number;\n  public started: number;\n  public duration?: number = 0;\n  public status: SessionStatus = 'ok';\n  public environment?: string;\n  public ipAddress?: string;\n  public init: boolean = true;\n  public ignoreDuration: boolean = false;\n\n  public constructor(context?: Omit<SessionContext, 'started' | 'status'>) {\n    // Both timestamp and started are in seconds since the UNIX epoch.\n    const startingTime = timestampInSeconds();\n    this.timestamp = startingTime;\n    this.started = startingTime;\n    if (context) {\n      this.update(context);\n    }\n  }\n\n  /** JSDoc */\n  // eslint-disable-next-line complexity\n  public update(context: SessionContext = {}): void {\n    if (context.user) {\n      if (!this.ipAddress && context.user.ip_address) {\n        this.ipAddress = context.user.ip_address;\n      }\n\n      if (!this.did && !context.did) {\n        this.did = context.user.id || context.user.email || context.user.username;\n      }\n    }\n\n    this.timestamp = context.timestamp || timestampInSeconds();\n    if (context.ignoreDuration) {\n      this.ignoreDuration = context.ignoreDuration;\n    }\n    if (context.sid) {\n      // Good enough uuid validation. — Kamil\n      this.sid = context.sid.length === 32 ? context.sid : uuid4();\n    }\n    if (context.init !== undefined) {\n      this.init = context.init;\n    }\n    if (!this.did && context.did) {\n      this.did = `${context.did}`;\n    }\n    if (typeof context.started === 'number') {\n      this.started = context.started;\n    }\n    if (this.ignoreDuration) {\n      this.duration = undefined;\n    } else if (typeof context.duration === 'number') {\n      this.duration = context.duration;\n    } else {\n      const duration = this.timestamp - this.started;\n      this.duration = duration >= 0 ? duration : 0;\n    }\n    if (context.release) {\n      this.release = context.release;\n    }\n    if (context.environment) {\n      this.environment = context.environment;\n    }\n    if (!this.ipAddress && context.ipAddress) {\n      this.ipAddress = context.ipAddress;\n    }\n    if (!this.userAgent && context.userAgent) {\n      this.userAgent = context.userAgent;\n    }\n    if (typeof context.errors === 'number') {\n      this.errors = context.errors;\n    }\n    if (context.status) {\n      this.status = context.status;\n    }\n  }\n\n  /** JSDoc */\n  public close(status?: Exclude<SessionStatus, 'ok'>): void {\n    if (status) {\n      this.update({ status });\n    } else if (this.status === 'ok') {\n      this.update({ status: 'exited' });\n    } else {\n      this.update();\n    }\n  }\n\n  /** JSDoc */\n  public toJSON(): {\n    init: boolean;\n    sid: string;\n    did?: string;\n    timestamp: string;\n    started: string;\n    duration?: number;\n    status: SessionStatus;\n    errors: number;\n    attrs?: {\n      release?: string;\n      environment?: string;\n      user_agent?: string;\n      ip_address?: string;\n    };\n  } {\n    return dropUndefinedKeys({\n      sid: `${this.sid}`,\n      init: this.init,\n      // Make sure that sec is converted to ms for date constructor\n      started: new Date(this.started * 1000).toISOString(),\n      timestamp: new Date(this.timestamp * 1000).toISOString(),\n      status: this.status,\n      errors: this.errors,\n      did: typeof this.did === 'number' || typeof this.did === 'string' ? `${this.did}` : undefined,\n      duration: this.duration,\n      attrs: {\n        release: this.release,\n        environment: this.environment,\n        ip_address: this.ipAddress,\n        user_agent: this.userAgent,\n      },\n    });\n  }\n}\n"]}import { SessionAggregates, SessionFlusherLike, Transport } from '@sentry/types';
declare type ReleaseHealthAttributes = {
    environment?: string;
    release: string;
};
/**
 * @inheritdoc
 */
export declare class SessionFlusher implements SessionFlusherLike {
    readonly flushTimeout: number;
    private _pendingAggregates;
    private _sessionAttrs;
    private _intervalId;
    private _isEnabled;
    private _transport;
    constructor(transport: Transport, attrs: ReleaseHealthAttributes);
    /** Sends session aggregates to Transport */
    sendSessionAggregates(sessionAggregates: SessionAggregates): void;
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    flush(): void;
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    getSessionAggregates(): SessionAggregates;
    /** JSDoc */
    close(): void;
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    incrementSessionStatusCount(): void;
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    private _incrementSessionStatusCount;
}
export {};
//# sourceMappingURL=sessionflusher.d.ts.map{"version":3,"file":"sessionflusher.d.ts","sourceRoot":"","sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"AAAA,OAAO,EAGL,iBAAiB,EACjB,kBAAkB,EAClB,SAAS,EACV,MAAM,eAAe,CAAC;AAMvB,aAAK,uBAAuB,GAAG;IAC7B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF;;GAEG;AACH,qBAAa,cAAe,YAAW,kBAAkB;IACvD,SAAgB,YAAY,EAAE,MAAM,CAAM;IAC1C,OAAO,CAAC,kBAAkB,CAAyC;IACnE,OAAO,CAAC,aAAa,CAA0B;IAC/C,OAAO,CAAC,WAAW,CAAiC;IACpD,OAAO,CAAC,UAAU,CAAiB;IACnC,OAAO,CAAC,UAAU,CAAY;gBAEX,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,uBAAuB;IAOvE,4CAA4C;IACrC,qBAAqB,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,IAAI;IAUxE,uGAAuG;IAChG,KAAK,IAAI,IAAI;IASpB,kFAAkF;IAC3E,oBAAoB,IAAI,iBAAiB;IAYhD,YAAY;IACL,KAAK,IAAI,IAAI;IAMpB;;;;OAIG;IACI,2BAA2B,IAAI,IAAI;IAkB1C;;;OAGG;IACH,OAAO,CAAC,4BAA4B;CAwBrC"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
var flags_1 = require("./flags");
var hub_1 = require("./hub");
/**
 * @inheritdoc
 */
var SessionFlusher = /** @class */ (function () {
    function SessionFlusher(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        // Call to setInterval, so that flush is called every 60 seconds
        this._intervalId = setInterval(function () { return _this.flush(); }, this.flushTimeout * 1000);
        this._sessionAttrs = attrs;
    }
    /** Sends session aggregates to Transport */
    SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {
        if (!this._transport.sendSession) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
            return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
        });
    };
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    SessionFlusher.prototype.flush = function () {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
            return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
    };
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    SessionFlusher.prototype.getSessionAggregates = function () {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function (key) {
            return _this._pendingAggregates[parseInt(key)];
        });
        var sessionAggregates = {
            attrs: this._sessionAttrs,
            aggregates: aggregates,
        };
        return utils_1.dropUndefinedKeys(sessionAggregates);
    };
    /** JSDoc */
    SessionFlusher.prototype.close = function () {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
    };
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    SessionFlusher.prototype.incrementSessionStatusCount = function () {
        if (!this._isEnabled) {
            return;
        }
        var scope = hub_1.getCurrentHub().getScope();
        var requestSession = scope && scope.getRequestSession();
        if (requestSession && requestSession.status) {
            this._incrementSessionStatusCount(requestSession.status, new Date());
            // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in
            // case captureRequestSession is called more than once to prevent double count
            if (scope) {
                scope.setRequestSession(undefined);
            }
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        }
    };
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {
        // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        // corresponds to aggregated sessions in one specific minute bucket
        // for example, {"started":"2021-03-16T08:00:00.000Z","exited":4, "errored": 1}
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
            aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
            case 'errored':
                aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
                return aggregationCounts.errored;
            case 'ok':
                aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
                return aggregationCounts.exited;
            default:
                aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
                return aggregationCounts.crashed;
        }
    };
    return SessionFlusher;
}());
exports.SessionFlusher = SessionFlusher;
//# sourceMappingURL=sessionflusher.js.map{"version":3,"file":"sessionflusher.js","sourceRoot":"","sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AggregationCounts,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n  Transport,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _transport: Transport;\n\n  public constructor(transport: Transport, attrs: ReleaseHealthAttributes) {\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Sends session aggregates to Transport */\n  public sendSessionAggregates(sessionAggregates: SessionAggregates): void {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    void this._transport.sendSession(sessionAggregates).then(null, reason => {\n      IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n    });\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope && scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
/** Flag that is true for debug builds, false otherwise. */
export var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAIH,2DAA2D;AAC3D,MAAM,CAAC,IAAM,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}import { Breadcrumb, BreadcrumbHint, Client, CustomSamplingContext, Event, EventHint, Extra, Extras, Hub as HubInterface, Integration, IntegrationClass, Primitive, SessionContext, Severity, Span, SpanContext, Transaction, TransactionContext, User } from '@sentry/types';
import { Scope } from './scope';
import { Session } from './session';
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
export declare const API_VERSION = 4;
/**
 * A layer in the process stack.
 * @hidden
 */
export interface Layer {
    client?: Client;
    scope?: Scope;
}
/**
 * An object that contains a hub and maintains a scope stack.
 * @hidden
 */
export interface Carrier {
    __SENTRY__?: {
        hub?: Hub;
        /**
         * Extra Hub properties injected by various SDKs
         */
        integrations?: Integration[];
        extensions?: {
            /** Hack to prevent bundlers from breaking our usage of the domain package in the cross-platform Hub package */
            domain?: {
                [key: string]: any;
            };
        } & {
            /** Extension methods for the hub, which are bound to the current Hub instance */
            [key: string]: Function;
        };
    };
}
/**
 * @hidden
 * @deprecated Can be removed once `Hub.getActiveDomain` is removed.
 */
export interface DomainAsCarrier extends Carrier {
    members: {
        [key: string]: any;
    }[];
}
/**
 * @inheritDoc
 */
export declare class Hub implements HubInterface {
    private readonly _version;
    /** Is a {@link Layer}[] containing the client and scope */
    private readonly _stack;
    /** Contains the last event id of a captured event.  */
    private _lastEventId?;
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    constructor(client?: Client, scope?: Scope, _version?: number);
    /**
     * @inheritDoc
     */
    isOlderThan(version: number): boolean;
    /**
     * @inheritDoc
     */
    bindClient(client?: Client): void;
    /**
     * @inheritDoc
     */
    pushScope(): Scope;
    /**
     * @inheritDoc
     */
    popScope(): boolean;
    /**
     * @inheritDoc
     */
    withScope(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    getClient<C extends Client>(): C | undefined;
    /** Returns the scope of the top stack. */
    getScope(): Scope | undefined;
    /** Returns the scope stack for domains or the process. */
    getStack(): Layer[];
    /** Returns the topmost scope layer in the order domain > local > process. */
    getStackTop(): Layer;
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    lastEventId(): string | undefined;
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;
    /**
     * @inheritDoc
     */
    setUser(user: User | null): void;
    /**
     * @inheritDoc
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): void;
    /**
     * @inheritDoc
     */
    setExtras(extras: Extras): void;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: Primitive): void;
    /**
     * @inheritDoc
     */
    setExtra(key: string, extra: Extra): void;
    /**
     * @inheritDoc
     */
    setContext(name: string, context: {
        [key: string]: any;
    } | null): void;
    /**
     * @inheritDoc
     */
    configureScope(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    run(callback: (hub: Hub) => void): void;
    /**
     * @inheritDoc
     */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /**
     * @inheritDoc
     */
    startSpan(context: SpanContext): Span;
    /**
     * @inheritDoc
     */
    startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
    /**
     * @inheritDoc
     */
    traceHeaders(): {
        [key: string]: string;
    };
    /**
     * @inheritDoc
     */
    captureSession(endSession?: boolean): void;
    /**
     * @inheritDoc
     */
    endSession(): void;
    /**
     * @inheritDoc
     */
    startSession(context?: SessionContext): Session;
    /**
     * Sends the current Session on the scope
     */
    private _sendSessionUpdate;
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    private _invokeClient;
    /**
     * Calls global extension method and binding current instance to the function call
     */
    private _callExtensionMethod;
}
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
export declare function getMainCarrier(): Carrier;
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
export declare function makeMain(hub: Hub): Hub;
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
export declare function getCurrentHub(): Hub;
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
export declare function getActiveDomain(): DomainAsCarrier | undefined;
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
export declare function getHubFromCarrier(carrier: Carrier): Hub;
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
export declare function setHubOnCarrier(carrier: Carrier, hub: Hub): boolean;
//# sourceMappingURL=hub.d.ts.map{"version":3,"file":"hub.d.ts","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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"}import { __assign, __read, __spread } from "tslib";
import { consoleSandbox, dateTimestampInSeconds, getGlobalObject, getGlobalSingleton, isNodeEnv, logger, uuid4, } from '@sentry/utils';
import { IS_DEBUG_BUILD } from './flags';
import { Scope } from './scope';
import { Session } from './session';
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
export var API_VERSION = 4;
/**
 * Default maximum number of breadcrumbs added to an event. Can be overwritten
 * with {@link Options.maxBreadcrumbs}.
 */
var DEFAULT_BREADCRUMBS = 100;
/**
 * @inheritDoc
 */
var Hub = /** @class */ (function () {
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    function Hub(client, scope, _version) {
        if (scope === void 0) { scope = new Scope(); }
        if (_version === void 0) { _version = API_VERSION; }
        this._version = _version;
        /** Is a {@link Layer}[] containing the client and scope */
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
            this.bindClient(client);
        }
    }
    /**
     * @inheritDoc
     */
    Hub.prototype.isOlderThan = function (version) {
        return this._version < version;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.bindClient = function (client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
            client.setupIntegrations();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.pushScope = function () {
        // We want to clone the content of prev scope
        var scope = Scope.clone(this.getScope());
        this.getStack().push({
            client: this.getClient(),
            scope: scope,
        });
        return scope;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.popScope = function () {
        if (this.getStack().length <= 1)
            return false;
        return !!this.getStack().pop();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.withScope = function (callback) {
        var scope = this.pushScope();
        try {
            callback(scope);
        }
        finally {
            this.popScope();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getClient = function () {
        return this.getStackTop().client;
    };
    /** Returns the scope of the top stack. */
    Hub.prototype.getScope = function () {
        return this.getStackTop().scope;
    };
    /** Returns the scope stack for domains or the process. */
    Hub.prototype.getStack = function () {
        return this._stack;
    };
    /** Returns the topmost scope layer in the order domain > local > process. */
    Hub.prototype.getStackTop = function () {
        return this._stack[this._stack.length - 1];
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    Hub.prototype.captureException = function (exception, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error('Sentry syntheticException');
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: exception,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureException', exception, __assign(__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureMessage = function (message, level, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error(message);
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: message,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureMessage', message, level, __assign(__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureEvent = function (event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : uuid4();
        if (event.type !== 'transaction') {
            this._lastEventId = eventId;
        }
        this._invokeClient('captureEvent', event, __assign(__assign({}, hint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.lastEventId = function () {
        return this._lastEventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope || !client)
            return;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _b = (client.getOptions && client.getOptions()) || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
        if (maxBreadcrumbs <= 0)
            return;
        var timestamp = dateTimestampInSeconds();
        var mergedBreadcrumb = __assign({ timestamp: timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb
            ? consoleSandbox(function () { return beforeBreadcrumb(mergedBreadcrumb, hint); })
            : mergedBreadcrumb;
        if (finalBreadcrumb === null)
            return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setUser = function (user) {
        var scope = this.getScope();
        if (scope)
            scope.setUser(user);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTags = function (tags) {
        var scope = this.getScope();
        if (scope)
            scope.setTags(tags);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtras = function (extras) {
        var scope = this.getScope();
        if (scope)
            scope.setExtras(extras);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTag = function (key, value) {
        var scope = this.getScope();
        if (scope)
            scope.setTag(key, value);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtra = function (key, extra) {
        var scope = this.getScope();
        if (scope)
            scope.setExtra(key, extra);
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype.setContext = function (name, context) {
        var scope = this.getScope();
        if (scope)
            scope.setContext(name, context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.configureScope = function (callback) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (scope && client) {
            callback(scope);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.run = function (callback) {
        var oldHub = makeMain(this);
        try {
            callback(this);
        }
        finally {
            makeMain(oldHub);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getIntegration = function (integration) {
        var client = this.getClient();
        if (!client)
            return null;
        try {
            return client.getIntegration(integration);
        }
        catch (_oO) {
            IS_DEBUG_BUILD && logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSpan = function (context) {
        return this._callExtensionMethod('startSpan', context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startTransaction = function (context, customSamplingContext) {
        return this._callExtensionMethod('startTransaction', context, customSamplingContext);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.traceHeaders = function () {
        return this._callExtensionMethod('traceHeaders');
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureSession = function (endSession) {
        if (endSession === void 0) { endSession = false; }
        // both send the update and pull the session from the scope
        if (endSession) {
            return this.endSession();
        }
        // only send the update
        this._sendSessionUpdate();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.endSession = function () {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
            session.close();
        }
        this._sendSessionUpdate();
        // the session is over; take it off of the scope
        if (scope) {
            scope.setSession();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSession = function (context) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        var _b = (client && client.getOptions()) || {}, release = _b.release, environment = _b.environment;
        // Will fetch userAgent if called from browser sdk
        var global = getGlobalObject();
        var userAgent = (global.navigator || {}).userAgent;
        var session = new Session(__assign(__assign(__assign({ release: release,
            environment: environment }, (scope && { user: scope.getUser() })), (userAgent && { userAgent: userAgent })), context));
        if (scope) {
            // End existing session if there's one
            var currentSession = scope.getSession && scope.getSession();
            if (currentSession && currentSession.status === 'ok') {
                currentSession.update({ status: 'exited' });
            }
            this.endSession();
            // Afterwards we set the new session on the scope
            scope.setSession(session);
        }
        return session;
    };
    /**
     * Sends the current Session on the scope
     */
    Hub.prototype._sendSessionUpdate = function () {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope)
            return;
        var session = scope.getSession && scope.getSession();
        if (session) {
            if (client && client.captureSession) {
                client.captureSession(session);
            }
        }
    };
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._invokeClient = function (method) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
            (_a = client)[method].apply(_a, __spread(args, [scope]));
        }
    };
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._callExtensionMethod = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
            return sentry.extensions[method].apply(this, args);
        }
        IS_DEBUG_BUILD && logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub;
}());
export { Hub };
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
export function getMainCarrier() {
    var carrier = getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: undefined,
    };
    return carrier;
}
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
export function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
}
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
export function getCurrentHub() {
    // Get main carrier (global for every environment)
    var registry = getMainCarrier();
    // If there's no hub, or its an old API, assign a new one
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
    }
    // Prefer domains over global if they are there (applicable only to Node environment)
    if (isNodeEnv()) {
        return getHubFromActiveDomain(registry);
    }
    // Return hub that lives on a global object
    return getHubFromCarrier(registry);
}
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
// eslint-disable-next-line deprecation/deprecation
export function getActiveDomain() {
    IS_DEBUG_BUILD && logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');
    var sentry = getMainCarrier().__SENTRY__;
    return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
}
/**
 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
 * @returns discovered hub
 */
function getHubFromActiveDomain(registry) {
    try {
        var sentry = getMainCarrier().__SENTRY__;
        var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
        // If there's no active domain, just return global hub
        if (!activeDomain) {
            return getHubFromCarrier(registry);
        }
        // If there's no hub on current domain, or it's an old API, assign a new one
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
            var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
            setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
        }
        // Return hub that lives on a domain
        return getHubFromCarrier(activeDomain);
    }
    catch (_Oo) {
        // Return hub that lives on a global object
        return getHubFromCarrier(registry);
    }
}
/**
 * This will tell whether a carrier has a hub on it or not
 * @param carrier object
 */
function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
export function getHubFromCarrier(carrier) {
    return getGlobalSingleton('hub', function () { return new Hub(); }, carrier);
}
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
export function setHubOnCarrier(carrier, hub) {
    if (!carrier)
        return false;
    var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});
    __SENTRY__.hub = hub;
    return true;
}
//# sourceMappingURL=hub.js.map{"version":3,"file":"hub.js","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport {\n  Breadcrumb,\n  BreadcrumbHint,\n  Client,\n  CustomSamplingContext,\n  Event,\n  EventHint,\n  Extra,\n  Extras,\n  Hub as HubInterface,\n  Integration,\n  IntegrationClass,\n  Primitive,\n  SessionContext,\n  Severity,\n  Span,\n  SpanContext,\n  Transaction,\n  TransactionContext,\n  User,\n} from '@sentry/types';\nimport {\n  consoleSandbox,\n  dateTimestampInSeconds,\n  getGlobalObject,\n  getGlobalSingleton,\n  isNodeEnv,\n  logger,\n  uuid4,\n} from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Scope } from './scope';\nimport { Session } from './session';\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */\nexport const API_VERSION = 4;\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 100;\n\n/**\n * A layer in the process stack.\n * @hidden\n */\nexport interface Layer {\n  client?: Client;\n  scope?: Scope;\n}\n\n/**\n * An object that contains a hub and maintains a scope stack.\n * @hidden\n */\nexport interface Carrier {\n  __SENTRY__?: {\n    hub?: Hub;\n    /**\n     * Extra Hub properties injected by various SDKs\n     */\n    integrations?: Integration[];\n    extensions?: {\n      /** Hack to prevent bundlers from breaking our usage of the domain package in the cross-platform Hub package */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      domain?: { [key: string]: any };\n    } & {\n      /** Extension methods for the hub, which are bound to the current Hub instance */\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      [key: string]: Function;\n    };\n  };\n}\n\n/**\n * @hidden\n * @deprecated Can be removed once `Hub.getActiveDomain` is removed.\n */\nexport interface DomainAsCarrier extends Carrier {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  members: { [key: string]: any }[];\n}\n\n/**\n * @inheritDoc\n */\nexport class Hub implements HubInterface {\n  /** Is a {@link Layer}[] containing the client and scope */\n  private readonly _stack: Layer[] = [{}];\n\n  /** Contains the last event id of a captured event.  */\n  private _lastEventId?: string;\n\n  /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   */\n  public constructor(client?: Client, scope: Scope = new Scope(), private readonly _version: number = API_VERSION) {\n    this.getStackTop().scope = scope;\n    if (client) {\n      this.bindClient(client);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public isOlderThan(version: number): boolean {\n    return this._version < version;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public bindClient(client?: Client): void {\n    const top = this.getStackTop();\n    top.client = client;\n    if (client && client.setupIntegrations) {\n      client.setupIntegrations();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public pushScope(): Scope {\n    // We want to clone the content of prev scope\n    const scope = Scope.clone(this.getScope());\n    this.getStack().push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public popScope(): boolean {\n    if (this.getStack().length <= 1) return false;\n    return !!this.getStack().pop();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public withScope(callback: (scope: Scope) => void): void {\n    const scope = this.pushScope();\n    try {\n      callback(scope);\n    } finally {\n      this.popScope();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getClient<C extends Client>(): C | undefined {\n    return this.getStackTop().client as C;\n  }\n\n  /** Returns the scope of the top stack. */\n  public getScope(): Scope | undefined {\n    return this.getStackTop().scope;\n  }\n\n  /** Returns the scope stack for domains or the process. */\n  public getStack(): Layer[] {\n    return this._stack;\n  }\n\n  /** Returns the topmost scope layer in the order domain > local > process. */\n  public getStackTop(): Layer {\n    return this._stack[this._stack.length - 1];\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint): string {\n    const eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    let finalHint = hint;\n\n    // If there's no explicit hint provided, mimic the same thing that would happen\n    // in the minimal itself to create a consistent behavior.\n    // We don't do this in the client, as it's the lowest level API, and doing this,\n    // would prevent user from having full control over direct calls.\n    if (!hint) {\n      let syntheticException: Error;\n      try {\n        throw new Error('Sentry syntheticException');\n      } catch (exception) {\n        syntheticException = exception as Error;\n      }\n      finalHint = {\n        originalException: exception,\n        syntheticException,\n      };\n    }\n\n    this._invokeClient('captureException', exception, {\n      ...finalHint,\n      event_id: eventId,\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint): string {\n    const eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4());\n    let finalHint = hint;\n\n    // If there's no explicit hint provided, mimic the same thing that would happen\n    // in the minimal itself to create a consistent behavior.\n    // We don't do this in the client, as it's the lowest level API, and doing this,\n    // would prevent user from having full control over direct calls.\n    if (!hint) {\n      let syntheticException: Error;\n      try {\n        throw new Error(message);\n      } catch (exception) {\n        syntheticException = exception as Error;\n      }\n      finalHint = {\n        originalException: message,\n        syntheticException,\n      };\n    }\n\n    this._invokeClient('captureMessage', message, level, {\n      ...finalHint,\n      event_id: eventId,\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint): string {\n    const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n    if (event.type !== 'transaction') {\n      this._lastEventId = eventId;\n    }\n\n    this._invokeClient('captureEvent', event, {\n      ...hint,\n      event_id: eventId,\n    });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public lastEventId(): string | undefined {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void {\n    const { scope, client } = this.getStackTop();\n\n    if (!scope || !client) return;\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } =\n      (client.getOptions && client.getOptions()) || {};\n\n    if (maxBreadcrumbs <= 0) return;\n\n    const timestamp = dateTimestampInSeconds();\n    const mergedBreadcrumb = { timestamp, ...breadcrumb };\n    const finalBreadcrumb = beforeBreadcrumb\n      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) as Breadcrumb | null)\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) return;\n\n    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setUser(user: User | null): void {\n    const scope = this.getScope();\n    if (scope) scope.setUser(user);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTags(tags: { [key: string]: Primitive }): void {\n    const scope = this.getScope();\n    if (scope) scope.setTags(tags);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtras(extras: Extras): void {\n    const scope = this.getScope();\n    if (scope) scope.setExtras(extras);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTag(key: string, value: Primitive): void {\n    const scope = this.getScope();\n    if (scope) scope.setTag(key, value);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtra(key: string, extra: Extra): void {\n    const scope = this.getScope();\n    if (scope) scope.setExtra(key, extra);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public setContext(name: string, context: { [key: string]: any } | null): void {\n    const scope = this.getScope();\n    if (scope) scope.setContext(name, context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public configureScope(callback: (scope: Scope) => void): void {\n    const { scope, client } = this.getStackTop();\n    if (scope && client) {\n      callback(scope);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public run(callback: (hub: Hub) => void): void {\n    const oldHub = makeMain(this);\n    try {\n      callback(this);\n    } finally {\n      makeMain(oldHub);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    const client = this.getClient();\n    if (!client) return null;\n    try {\n      return client.getIntegration(integration);\n    } catch (_oO) {\n      IS_DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startSpan(context: SpanContext): Span {\n    return this._callExtensionMethod('startSpan', context);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction {\n    return this._callExtensionMethod('startTransaction', context, customSamplingContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public traceHeaders(): { [key: string]: string } {\n    return this._callExtensionMethod<{ [key: string]: string }>('traceHeaders');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(endSession: boolean = false): void {\n    // both send the update and pull the session from the scope\n    if (endSession) {\n      return this.endSession();\n    }\n\n    // only send the update\n    this._sendSessionUpdate();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public endSession(): void {\n    const layer = this.getStackTop();\n    const scope = layer && layer.scope;\n    const session = scope && scope.getSession();\n    if (session) {\n      session.close();\n    }\n    this._sendSessionUpdate();\n\n    // the session is over; take it off of the scope\n    if (scope) {\n      scope.setSession();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startSession(context?: SessionContext): Session {\n    const { scope, client } = this.getStackTop();\n    const { release, environment } = (client && client.getOptions()) || {};\n\n    // Will fetch userAgent if called from browser sdk\n    const global = getGlobalObject<{ navigator?: { userAgent?: string } }>();\n    const { userAgent } = global.navigator || {};\n\n    const session = new Session({\n      release,\n      environment,\n      ...(scope && { user: scope.getUser() }),\n      ...(userAgent && { userAgent }),\n      ...context,\n    });\n\n    if (scope) {\n      // End existing session if there's one\n      const currentSession = scope.getSession && scope.getSession();\n      if (currentSession && currentSession.status === 'ok') {\n        currentSession.update({ status: 'exited' });\n      }\n      this.endSession();\n\n      // Afterwards we set the new session on the scope\n      scope.setSession(session);\n    }\n\n    return session;\n  }\n\n  /**\n   * Sends the current Session on the scope\n   */\n  private _sendSessionUpdate(): void {\n    const { scope, client } = this.getStackTop();\n    if (!scope) return;\n\n    const session = scope.getSession && scope.getSession();\n    if (session) {\n      if (client && client.captureSession) {\n        client.captureSession(session);\n      }\n    }\n  }\n\n  /**\n   * Internal helper function to call a method on the top client if it exists.\n   *\n   * @param method The method to call on the client.\n   * @param args Arguments to pass to the client function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _invokeClient<M extends keyof Client>(method: M, ...args: any[]): void {\n    const { scope, client } = this.getStackTop();\n    if (client && client[method]) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n      (client as any)[method](...args, scope);\n    }\n  }\n\n  /**\n   * Calls global extension method and binding current instance to the function call\n   */\n  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _callExtensionMethod<T>(method: string, ...args: any[]): T {\n    const carrier = getMainCarrier();\n    const sentry = carrier.__SENTRY__;\n    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {\n      return sentry.extensions[method].apply(this, args);\n    }\n    IS_DEBUG_BUILD && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n  }\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nexport function getMainCarrier(): Carrier {\n  const carrier = getGlobalObject();\n  carrier.__SENTRY__ = carrier.__SENTRY__ || {\n    extensions: {},\n    hub: undefined,\n  };\n  return carrier;\n}\n\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n */\nexport function makeMain(hub: Hub): Hub {\n  const registry = getMainCarrier();\n  const oldHub = getHubFromCarrier(registry);\n  setHubOnCarrier(registry, hub);\n  return oldHub;\n}\n\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n */\nexport function getCurrentHub(): Hub {\n  // Get main carrier (global for every environment)\n  const registry = getMainCarrier();\n\n  // If there's no hub, or its an old API, assign a new one\n  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n    setHubOnCarrier(registry, new Hub());\n  }\n\n  // Prefer domains over global if they are there (applicable only to Node environment)\n  if (isNodeEnv()) {\n    return getHubFromActiveDomain(registry);\n  }\n  // Return hub that lives on a global object\n  return getHubFromCarrier(registry);\n}\n\n/**\n * Returns the active domain, if one exists\n * @deprecated No longer used; remove in v7\n * @returns The domain, or undefined if there is no active domain\n */\n// eslint-disable-next-line deprecation/deprecation\nexport function getActiveDomain(): DomainAsCarrier | undefined {\n  IS_DEBUG_BUILD && logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');\n\n  const sentry = getMainCarrier().__SENTRY__;\n\n  return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n}\n\n/**\n * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist\n * @returns discovered hub\n */\nfunction getHubFromActiveDomain(registry: Carrier): Hub {\n  try {\n    const sentry = getMainCarrier().__SENTRY__;\n    const activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;\n\n    // If there's no active domain, just return global hub\n    if (!activeDomain) {\n      return getHubFromCarrier(registry);\n    }\n\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {\n      const registryHubTopStack = getHubFromCarrier(registry).getStackTop();\n      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));\n    }\n\n    // Return hub that lives on a domain\n    return getHubFromCarrier(activeDomain);\n  } catch (_Oo) {\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n  }\n}\n\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */\nfunction hasHubOnCarrier(carrier: Carrier): boolean {\n  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */\nexport function getHubFromCarrier(carrier: Carrier): Hub {\n  return getGlobalSingleton<Hub>('hub', () => new Hub(), carrier);\n}\n\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */\nexport function setHubOnCarrier(carrier: Carrier, hub: Hub): boolean {\n  if (!carrier) return false;\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n  __SENTRY__.hub = hub;\n  return true;\n}\n"]}export { addGlobalEventProcessor, Scope } from './scope';
export { Session } from './session';
export { SessionFlusher } from './sessionflusher';
export { getActiveDomain, getCurrentHub, getHubFromCarrier, getMainCarrier, Hub, makeMain, setHubOnCarrier, Carrier, DomainAsCarrier, Layer, } from './hub';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,uBAAuB,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AACzD,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAEL,eAAe,EACf,aAAa,EACb,iBAAiB,EACjB,cAAc,EACd,GAAG,EACH,QAAQ,EACR,eAAe,EACf,OAAO,EAEP,eAAe,EACf,KAAK,GACN,MAAM,OAAO,CAAC"}export { addGlobalEventProcessor, Scope } from './scope';
export { Session } from './session';
export { SessionFlusher } from './sessionflusher';
export { 
// eslint-disable-next-line deprecation/deprecation
getActiveDomain, getCurrentHub, getHubFromCarrier, getMainCarrier, Hub, makeMain, setHubOnCarrier, } from './hub';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,uBAAuB,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AACzD,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO;AACL,mDAAmD;AACnD,eAAe,EACf,aAAa,EACb,iBAAiB,EACjB,cAAc,EACd,GAAG,EACH,QAAQ,EACR,eAAe,GAKhB,MAAM,OAAO,CAAC","sourcesContent":["export { addGlobalEventProcessor, Scope } from './scope';\nexport { Session } from './session';\nexport { SessionFlusher } from './sessionflusher';\nexport {\n  // eslint-disable-next-line deprecation/deprecation\n  getActiveDomain,\n  getCurrentHub,\n  getHubFromCarrier,\n  getMainCarrier,\n  Hub,\n  makeMain,\n  setHubOnCarrier,\n  Carrier,\n  // eslint-disable-next-line deprecation/deprecation\n  DomainAsCarrier,\n  Layer,\n} from './hub';\n"]}import { Breadcrumb, CaptureContext, Context, Contexts, Event, EventHint, EventProcessor, Extra, Extras, Primitive, RequestSession, Scope as ScopeInterface, Severity, Span, Transaction, User } from '@sentry/types';
import { Session } from './session';
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
export declare class Scope implements ScopeInterface {
    /** Flag if notifying is happening. */
    protected _notifyingListeners: boolean;
    /** Callback for client to receive scope changes. */
    protected _scopeListeners: Array<(scope: Scope) => void>;
    /** Callback list that will be called after {@link applyToEvent}. */
    protected _eventProcessors: EventProcessor[];
    /** Array of breadcrumbs. */
    protected _breadcrumbs: Breadcrumb[];
    /** User */
    protected _user: User;
    /** Tags */
    protected _tags: {
        [key: string]: Primitive;
    };
    /** Extra */
    protected _extra: Extras;
    /** Contexts */
    protected _contexts: Contexts;
    /** Fingerprint */
    protected _fingerprint?: string[];
    /** Severity */
    protected _level?: Severity;
    /** Transaction Name */
    protected _transactionName?: string;
    /** Span */
    protected _span?: Span;
    /** Session */
    protected _session?: Session;
    /** Request Mode Session Status */
    protected _requestSession?: RequestSession;
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    protected _sdkProcessingMetadata?: {
        [key: string]: unknown;
    };
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    static clone(scope?: Scope): Scope;
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    addScopeListener(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    addEventProcessor(callback: EventProcessor): this;
    /**
     * @inheritDoc
     */
    setUser(user: User | null): this;
    /**
     * @inheritDoc
     */
    getUser(): User | undefined;
    /**
     * @inheritDoc
     */
    getRequestSession(): RequestSession | undefined;
    /**
     * @inheritDoc
     */
    setRequestSession(requestSession?: RequestSession): this;
    /**
     * @inheritDoc
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): this;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: Primitive): this;
    /**
     * @inheritDoc
     */
    setExtras(extras: Extras): this;
    /**
     * @inheritDoc
     */
    setExtra(key: string, extra: Extra): this;
    /**
     * @inheritDoc
     */
    setFingerprint(fingerprint: string[]): this;
    /**
     * @inheritDoc
     */
    setLevel(level: Severity): this;
    /**
     * @inheritDoc
     */
    setTransactionName(name?: string): this;
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    setTransaction(name?: string): this;
    /**
     * @inheritDoc
     */
    setContext(key: string, context: Context | null): this;
    /**
     * @inheritDoc
     */
    setSpan(span?: Span): this;
    /**
     * @inheritDoc
     */
    getSpan(): Span | undefined;
    /**
     * @inheritDoc
     */
    getTransaction(): Transaction | undefined;
    /**
     * @inheritDoc
     */
    setSession(session?: Session): this;
    /**
     * @inheritDoc
     */
    getSession(): Session | undefined;
    /**
     * @inheritDoc
     */
    update(captureContext?: CaptureContext): this;
    /**
     * @inheritDoc
     */
    clear(): this;
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;
    /**
     * @inheritDoc
     */
    clearBreadcrumbs(): this;
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    applyToEvent(event: Event, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    setSDKProcessingMetadata(newData: {
        [key: string]: unknown;
    }): this;
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    protected _notifyEventProcessors(processors: EventProcessor[], event: Event | null, hint?: EventHint, index?: number): PromiseLike<Event | null>;
    /**
     * This will be called on every set call.
     */
    protected _notifyScopeListeners(): void;
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    private _applyFingerprint;
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
export declare function addGlobalEventProcessor(callback: EventProcessor): void;
//# sourceMappingURL=scope.d.ts.map{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"AACA,OAAO,EACL,UAAU,EACV,cAAc,EACd,OAAO,EACP,QAAQ,EACR,KAAK,EACL,SAAS,EACT,cAAc,EACd,KAAK,EACL,MAAM,EACN,SAAS,EACT,cAAc,EACd,KAAK,IAAI,cAAc,EAEvB,QAAQ,EACR,IAAI,EACJ,WAAW,EACX,IAAI,EACL,MAAM,eAAe,CAAC;AAGvB,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAQpC;;;GAGG;AACH,qBAAa,KAAM,YAAW,cAAc;IAC1C,sCAAsC;IACtC,SAAS,CAAC,mBAAmB,EAAE,OAAO,CAAS;IAE/C,oDAAoD;IACpD,SAAS,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,CAAC,CAAM;IAE9D,oEAAoE;IACpE,SAAS,CAAC,gBAAgB,EAAE,cAAc,EAAE,CAAM;IAElD,4BAA4B;IAC5B,SAAS,CAAC,YAAY,EAAE,UAAU,EAAE,CAAM;IAE1C,WAAW;IACX,SAAS,CAAC,KAAK,EAAE,IAAI,CAAM;IAE3B,WAAW;IACX,SAAS,CAAC,KAAK,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAM;IAEnD,YAAY;IACZ,SAAS,CAAC,MAAM,EAAE,MAAM,CAAM;IAE9B,eAAe;IACf,SAAS,CAAC,SAAS,EAAE,QAAQ,CAAM;IAEnC,kBAAkB;IAClB,SAAS,CAAC,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IAElC,eAAe;IACf,SAAS,CAAC,MAAM,CAAC,EAAE,QAAQ,CAAC;IAE5B,uBAAuB;IACvB,SAAS,CAAC,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAEpC,WAAW;IACX,SAAS,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC;IAEvB,cAAc;IACd,SAAS,CAAC,QAAQ,CAAC,EAAE,OAAO,CAAC;IAE7B,kCAAkC;IAClC,SAAS,CAAC,eAAe,CAAC,EAAE,cAAc,CAAC;IAE3C;;;OAGG;IACH,SAAS,CAAC,sBAAsB,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;KAAE,CAAM;IAEnE;;;OAGG;WACW,KAAK,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,KAAK;IAmBzC;;;OAGG;IACI,gBAAgB,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI;IAI/D;;OAEG;IACI,iBAAiB,CAAC,QAAQ,EAAE,cAAc,GAAG,IAAI;IAKxD;;OAEG;IACI,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI;IASvC;;OAEG;IACI,OAAO,IAAI,IAAI,GAAG,SAAS;IAIlC;;OAEG;IACI,iBAAiB,IAAI,cAAc,GAAG,SAAS;IAItD;;OAEG;IACI,iBAAiB,CAAC,cAAc,CAAC,EAAE,cAAc,GAAG,IAAI;IAK/D;;OAEG;IACI,OAAO,CAAC,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,GAAG,IAAI;IASxD;;OAEG;IACI,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,GAAG,IAAI;IAMlD;;OAEG;IACI,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI;IAStC;;OAEG;IACI,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI;IAMhD;;OAEG;IACI,cAAc,CAAC,WAAW,EAAE,MAAM,EAAE,GAAG,IAAI;IAMlD;;OAEG;IACI,QAAQ,CAAC,KAAK,EAAE,QAAQ,GAAG,IAAI;IAMtC;;OAEG;IACI,kBAAkB,CAAC,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI;IAM9C;;;OAGG;IACI,cAAc,CAAC,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI;IAI1C;;OAEG;IACI,UAAU,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,IAAI,GAAG,IAAI;IAY7D;;OAEG;IACI,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,GAAG,IAAI;IAMjC;;OAEG;IACI,OAAO,IAAI,IAAI,GAAG,SAAS;IAIlC;;OAEG;IACI,cAAc,IAAI,WAAW,GAAG,SAAS;IAOhD;;OAEG;IACI,UAAU,CAAC,OAAO,CAAC,EAAE,OAAO,GAAG,IAAI;IAU1C;;OAEG;IACI,UAAU,IAAI,OAAO,GAAG,SAAS;IAIxC;;OAEG;IACI,MAAM,CAAC,cAAc,CAAC,EAAE,cAAc,GAAG,IAAI;IAiDpD;;OAEG;IACI,KAAK,IAAI,IAAI;IAgBpB;;OAEG;IACI,aAAa,CAAC,UAAU,EAAE,UAAU,EAAE,cAAc,CAAC,EAAE,MAAM,GAAG,IAAI;IAkB3E;;OAEG;IACI,gBAAgB,IAAI,IAAI;IAM/B;;;;;;;OAOG;IACI,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IAwC9E;;OAEG;IACI,wBAAwB,CAAC,OAAO,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;KAAE,GAAG,IAAI;IAM1E;;OAEG;IACH,SAAS,CAAC,sBAAsB,CAC9B,UAAU,EAAE,cAAc,EAAE,EAC5B,KAAK,EAAE,KAAK,GAAG,IAAI,EACnB,IAAI,CAAC,EAAE,SAAS,EAChB,KAAK,GAAE,MAAU,GAChB,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IAoB5B;;OAEG;IACH,SAAS,CAAC,qBAAqB,IAAI,IAAI;IAavC;;;OAGG;IACH,OAAO,CAAC,iBAAiB;CAkB1B;AASD;;;GAGG;AACH,wBAAgB,uBAAuB,CAAC,QAAQ,EAAE,cAAc,GAAG,IAAI,CAEtE"}import { __assign, __read, __spread } from "tslib";
import { dateTimestampInSeconds, getGlobalSingleton, isPlainObject, isThenable, SyncPromise } from '@sentry/utils';
/**
 * Absolute maximum number of breadcrumbs added to an event.
 * The `maxBreadcrumbs` option cannot be higher than this value.
 */
var MAX_BREADCRUMBS = 100;
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
var Scope = /** @class */ (function () {
    function Scope() {
        /** Flag if notifying is happening. */
        this._notifyingListeners = false;
        /** Callback for client to receive scope changes. */
        this._scopeListeners = [];
        /** Callback list that will be called after {@link applyToEvent}. */
        this._eventProcessors = [];
        /** Array of breadcrumbs. */
        this._breadcrumbs = [];
        /** User */
        this._user = {};
        /** Tags */
        this._tags = {};
        /** Extra */
        this._extra = {};
        /** Contexts */
        this._contexts = {};
        /**
         * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
         * sent to Sentry
         */
        this._sdkProcessingMetadata = {};
    }
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    Scope.clone = function (scope) {
        var newScope = new Scope();
        if (scope) {
            newScope._breadcrumbs = __spread(scope._breadcrumbs);
            newScope._tags = __assign({}, scope._tags);
            newScope._extra = __assign({}, scope._extra);
            newScope._contexts = __assign({}, scope._contexts);
            newScope._user = scope._user;
            newScope._level = scope._level;
            newScope._span = scope._span;
            newScope._session = scope._session;
            newScope._transactionName = scope._transactionName;
            newScope._fingerprint = scope._fingerprint;
            newScope._eventProcessors = __spread(scope._eventProcessors);
            newScope._requestSession = scope._requestSession;
        }
        return newScope;
    };
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    Scope.prototype.addScopeListener = function (callback) {
        this._scopeListeners.push(callback);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addEventProcessor = function (callback) {
        this._eventProcessors.push(callback);
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setUser = function (user) {
        this._user = user || {};
        if (this._session) {
            this._session.update({ user: user });
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getUser = function () {
        return this._user;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getRequestSession = function () {
        return this._requestSession;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setRequestSession = function (requestSession) {
        this._requestSession = requestSession;
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTags = function (tags) {
        this._tags = __assign(__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTag = function (key, value) {
        var _a;
        this._tags = __assign(__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtras = function (extras) {
        this._extra = __assign(__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtra = function (key, extra) {
        var _a;
        this._extra = __assign(__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setFingerprint = function (fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setLevel = function (level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTransactionName = function (name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    Scope.prototype.setTransaction = function (name) {
        return this.setTransactionName(name);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setContext = function (key, context) {
        var _a;
        if (context === null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete this._contexts[key];
        }
        else {
            this._contexts = __assign(__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSpan = function (span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSpan = function () {
        return this._span;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getTransaction = function () {
        // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
        // have a pointer to the currently-active transaction.
        var span = this.getSpan();
        return span && span.transaction;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSession = function (session) {
        if (!session) {
            delete this._session;
        }
        else {
            this._session = session;
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSession = function () {
        return this._session;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.update = function (captureContext) {
        if (!captureContext) {
            return this;
        }
        if (typeof captureContext === 'function') {
            var updatedScope = captureContext(this);
            return updatedScope instanceof Scope ? updatedScope : this;
        }
        if (captureContext instanceof Scope) {
            this._tags = __assign(__assign({}, this._tags), captureContext._tags);
            this._extra = __assign(__assign({}, this._extra), captureContext._extra);
            this._contexts = __assign(__assign({}, this._contexts), captureContext._contexts);
            if (captureContext._user && Object.keys(captureContext._user).length) {
                this._user = captureContext._user;
            }
            if (captureContext._level) {
                this._level = captureContext._level;
            }
            if (captureContext._fingerprint) {
                this._fingerprint = captureContext._fingerprint;
            }
            if (captureContext._requestSession) {
                this._requestSession = captureContext._requestSession;
            }
        }
        else if (isPlainObject(captureContext)) {
            // eslint-disable-next-line no-param-reassign
            captureContext = captureContext;
            this._tags = __assign(__assign({}, this._tags), captureContext.tags);
            this._extra = __assign(__assign({}, this._extra), captureContext.extra);
            this._contexts = __assign(__assign({}, this._contexts), captureContext.contexts);
            if (captureContext.user) {
                this._user = captureContext.user;
            }
            if (captureContext.level) {
                this._level = captureContext.level;
            }
            if (captureContext.fingerprint) {
                this._fingerprint = captureContext.fingerprint;
            }
            if (captureContext.requestSession) {
                this._requestSession = captureContext.requestSession;
            }
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clear = function () {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._requestSession = undefined;
        this._span = undefined;
        this._session = undefined;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        // No data has been changed, so don't notify scope listeners
        if (maxCrumbs <= 0) {
            return this;
        }
        var mergedBreadcrumb = __assign({ timestamp: dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = __spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clearBreadcrumbs = function () {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    Scope.prototype.applyToEvent = function (event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
            event.extra = __assign(__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
            event.tags = __assign(__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
            event.user = __assign(__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
            event.contexts = __assign(__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
            event.level = this._level;
        }
        if (this._transactionName) {
            event.transaction = this._transactionName;
        }
        // We want to set the trace context for normal events only if there isn't already
        // a trace context on the event. There is a product feature in place where we link
        // errors with transaction and it relies on that.
        if (this._span) {
            event.contexts = __assign({ trace: this._span.getTraceContext() }, event.contexts);
            var transactionName = this._span.transaction && this._span.transaction.name;
            if (transactionName) {
                event.tags = __assign({ transaction: transactionName }, event.tags);
            }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = __spread((event.breadcrumbs || []), this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    Scope.prototype.setSDKProcessingMetadata = function (newData) {
        this._sdkProcessingMetadata = __assign(__assign({}, this._sdkProcessingMetadata), newData);
        return this;
    };
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
        var _this = this;
        if (index === void 0) { index = 0; }
        return new SyncPromise(function (resolve, reject) {
            var processor = processors[index];
            if (event === null || typeof processor !== 'function') {
                resolve(event);
            }
            else {
                var result = processor(__assign({}, event), hint);
                if (isThenable(result)) {
                    void result
                        .then(function (final) { return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve); })
                        .then(null, reject);
                }
                else {
                    void _this._notifyEventProcessors(processors, result, hint, index + 1)
                        .then(resolve)
                        .then(null, reject);
                }
            }
        });
    };
    /**
     * This will be called on every set call.
     */
    Scope.prototype._notifyScopeListeners = function () {
        var _this = this;
        // We need this check for this._notifyingListeners to be able to work on scope during updates
        // If this check is not here we'll produce endless recursion when something is done with the scope
        // during the callback.
        if (!this._notifyingListeners) {
            this._notifyingListeners = true;
            this._scopeListeners.forEach(function (callback) {
                callback(_this);
            });
            this._notifyingListeners = false;
        }
    };
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    Scope.prototype._applyFingerprint = function (event) {
        // Make sure it's an array first and we actually have something in place
        event.fingerprint = event.fingerprint
            ? Array.isArray(event.fingerprint)
                ? event.fingerprint
                : [event.fingerprint]
            : [];
        // If we have something on the scope, then merge it with event
        if (this._fingerprint) {
            event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        // If we have no data at all, remove empty array default
        if (event.fingerprint && !event.fingerprint.length) {
            delete event.fingerprint;
        }
    };
    return Scope;
}());
export { Scope };
/**
 * Returns the global event processors.
 */
function getGlobalEventProcessors() {
    return getGlobalSingleton('globalEventProcessors', function () { return []; });
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
export function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
}
//# sourceMappingURL=scope.js.map{"version":3,"file":"scope.js","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport {\n  Breadcrumb,\n  CaptureContext,\n  Context,\n  Contexts,\n  Event,\n  EventHint,\n  EventProcessor,\n  Extra,\n  Extras,\n  Primitive,\n  RequestSession,\n  Scope as ScopeInterface,\n  ScopeContext,\n  Severity,\n  Span,\n  Transaction,\n  User,\n} from '@sentry/types';\nimport { dateTimestampInSeconds, getGlobalSingleton, isPlainObject, isThenable, SyncPromise } from '@sentry/utils';\n\nimport { Session } from './session';\n\n/**\n * Absolute maximum number of breadcrumbs added to an event.\n * The `maxBreadcrumbs` option cannot be higher than this value.\n */\nconst MAX_BREADCRUMBS = 100;\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */\nexport class Scope implements ScopeInterface {\n  /** Flag if notifying is happening. */\n  protected _notifyingListeners: boolean = false;\n\n  /** Callback for client to receive scope changes. */\n  protected _scopeListeners: Array<(scope: Scope) => void> = [];\n\n  /** Callback list that will be called after {@link applyToEvent}. */\n  protected _eventProcessors: EventProcessor[] = [];\n\n  /** Array of breadcrumbs. */\n  protected _breadcrumbs: Breadcrumb[] = [];\n\n  /** User */\n  protected _user: User = {};\n\n  /** Tags */\n  protected _tags: { [key: string]: Primitive } = {};\n\n  /** Extra */\n  protected _extra: Extras = {};\n\n  /** Contexts */\n  protected _contexts: Contexts = {};\n\n  /** Fingerprint */\n  protected _fingerprint?: string[];\n\n  /** Severity */\n  protected _level?: Severity;\n\n  /** Transaction Name */\n  protected _transactionName?: string;\n\n  /** Span */\n  protected _span?: Span;\n\n  /** Session */\n  protected _session?: Session;\n\n  /** Request Mode Session Status */\n  protected _requestSession?: RequestSession;\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  protected _sdkProcessingMetadata?: { [key: string]: unknown } = {};\n\n  /**\n   * Inherit values from the parent scope.\n   * @param scope to clone.\n   */\n  public static clone(scope?: Scope): Scope {\n    const newScope = new Scope();\n    if (scope) {\n      newScope._breadcrumbs = [...scope._breadcrumbs];\n      newScope._tags = { ...scope._tags };\n      newScope._extra = { ...scope._extra };\n      newScope._contexts = { ...scope._contexts };\n      newScope._user = scope._user;\n      newScope._level = scope._level;\n      newScope._span = scope._span;\n      newScope._session = scope._session;\n      newScope._transactionName = scope._transactionName;\n      newScope._fingerprint = scope._fingerprint;\n      newScope._eventProcessors = [...scope._eventProcessors];\n      newScope._requestSession = scope._requestSession;\n    }\n    return newScope;\n  }\n\n  /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */\n  public addScopeListener(callback: (scope: Scope) => void): void {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addEventProcessor(callback: EventProcessor): this {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setUser(user: User | null): this {\n    this._user = user || {};\n    if (this._session) {\n      this._session.update({ user });\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getUser(): User | undefined {\n    return this._user;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getRequestSession(): RequestSession | undefined {\n    return this._requestSession;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setRequestSession(requestSession?: RequestSession): this {\n    this._requestSession = requestSession;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTags(tags: { [key: string]: Primitive }): this {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTag(key: string, value: Primitive): this {\n    this._tags = { ...this._tags, [key]: value };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtras(extras: Extras): this {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setExtra(key: string, extra: Extra): this {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setFingerprint(fingerprint: string[]): this {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setLevel(level: Severity): this {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTransactionName(name?: string): this {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Can be removed in major version.\n   * @deprecated in favor of {@link this.setTransactionName}\n   */\n  public setTransaction(name?: string): this {\n    return this.setTransactionName(name);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setContext(key: string, context: Context | null): this {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts = { ...this._contexts, [key]: context };\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setSpan(span?: Span): this {\n    this._span = span;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getSpan(): Span | undefined {\n    return this._span;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransaction(): Transaction | undefined {\n    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n    // have a pointer to the currently-active transaction.\n    const span = this.getSpan();\n    return span && span.transaction;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setSession(session?: Session): this {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getSession(): Session | undefined {\n    return this._session;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public update(captureContext?: CaptureContext): this {\n    if (!captureContext) {\n      return this;\n    }\n\n    if (typeof captureContext === 'function') {\n      const updatedScope = (captureContext as <T>(scope: T) => T)(this);\n      return updatedScope instanceof Scope ? updatedScope : this;\n    }\n\n    if (captureContext instanceof Scope) {\n      this._tags = { ...this._tags, ...captureContext._tags };\n      this._extra = { ...this._extra, ...captureContext._extra };\n      this._contexts = { ...this._contexts, ...captureContext._contexts };\n      if (captureContext._user && Object.keys(captureContext._user).length) {\n        this._user = captureContext._user;\n      }\n      if (captureContext._level) {\n        this._level = captureContext._level;\n      }\n      if (captureContext._fingerprint) {\n        this._fingerprint = captureContext._fingerprint;\n      }\n      if (captureContext._requestSession) {\n        this._requestSession = captureContext._requestSession;\n      }\n    } else if (isPlainObject(captureContext)) {\n      // eslint-disable-next-line no-param-reassign\n      captureContext = captureContext as ScopeContext;\n      this._tags = { ...this._tags, ...captureContext.tags };\n      this._extra = { ...this._extra, ...captureContext.extra };\n      this._contexts = { ...this._contexts, ...captureContext.contexts };\n      if (captureContext.user) {\n        this._user = captureContext.user;\n      }\n      if (captureContext.level) {\n        this._level = captureContext.level;\n      }\n      if (captureContext.fingerprint) {\n        this._fingerprint = captureContext.fingerprint;\n      }\n      if (captureContext.requestSession) {\n        this._requestSession = captureContext.requestSession;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public clear(): this {\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._requestSession = undefined;\n    this._span = undefined;\n    this._session = undefined;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n    };\n    this._breadcrumbs = [...this._breadcrumbs, mergedBreadcrumb].slice(-maxCrumbs);\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public clearBreadcrumbs(): this {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Applies the current context and fingerprint to the event.\n   * Note that breadcrumbs will be added by the client.\n   * Also if the event has already breadcrumbs on it, we do not merge them.\n   * @param event Event\n   * @param hint May contain additional information about the original exception.\n   * @hidden\n   */\n  public applyToEvent(event: Event, hint?: EventHint): PromiseLike<Event | null> {\n    if (this._extra && Object.keys(this._extra).length) {\n      event.extra = { ...this._extra, ...event.extra };\n    }\n    if (this._tags && Object.keys(this._tags).length) {\n      event.tags = { ...this._tags, ...event.tags };\n    }\n    if (this._user && Object.keys(this._user).length) {\n      event.user = { ...this._user, ...event.user };\n    }\n    if (this._contexts && Object.keys(this._contexts).length) {\n      event.contexts = { ...this._contexts, ...event.contexts };\n    }\n    if (this._level) {\n      event.level = this._level;\n    }\n    if (this._transactionName) {\n      event.transaction = this._transactionName;\n    }\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (this._span) {\n      event.contexts = { trace: this._span.getTraceContext(), ...event.contexts };\n      const transactionName = this._span.transaction && this._span.transaction.name;\n      if (transactionName) {\n        event.tags = { transaction: transactionName, ...event.tags };\n      }\n    }\n\n    this._applyFingerprint(event);\n\n    event.breadcrumbs = [...(event.breadcrumbs || []), ...this._breadcrumbs];\n    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;\n\n    event.sdkProcessingMetadata = this._sdkProcessingMetadata;\n\n    return this._notifyEventProcessors([...getGlobalEventProcessors(), ...this._eventProcessors], event, hint);\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */\n  public setSDKProcessingMetadata(newData: { [key: string]: unknown }): this {\n    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n\n    return this;\n  }\n\n  /**\n   * This will be called after {@link applyToEvent} is finished.\n   */\n  protected _notifyEventProcessors(\n    processors: EventProcessor[],\n    event: Event | null,\n    hint?: EventHint,\n    index: number = 0,\n  ): PromiseLike<Event | null> {\n    return new SyncPromise<Event | null>((resolve, reject) => {\n      const processor = processors[index];\n      if (event === null || typeof processor !== 'function') {\n        resolve(event);\n      } else {\n        const result = processor({ ...event }, hint) as Event | null;\n        if (isThenable(result)) {\n          void result\n            .then(final => this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve))\n            .then(null, reject);\n        } else {\n          void this._notifyEventProcessors(processors, result, hint, index + 1)\n            .then(resolve)\n            .then(null, reject);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n  protected _notifyScopeListeners(): void {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n\n  /**\n   * Applies fingerprint from the scope to the event if there's one,\n   * uses message if there's one instead or get rid of empty fingerprint\n   */\n  private _applyFingerprint(event: Event): void {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint\n      ? Array.isArray(event.fingerprint)\n        ? event.fingerprint\n        : [event.fingerprint]\n      : [];\n\n    // If we have something on the scope, then merge it with event\n    if (this._fingerprint) {\n      event.fingerprint = event.fingerprint.concat(this._fingerprint);\n    }\n\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n}\n\n/**\n * Returns the global event processors.\n */\nfunction getGlobalEventProcessors(): EventProcessor[] {\n  return getGlobalSingleton<EventProcessor[]>('globalEventProcessors', () => []);\n}\n\n/**\n * Add a EventProcessor to be kept globally.\n * @param callback EventProcessor to add\n */\nexport function addGlobalEventProcessor(callback: EventProcessor): void {\n  getGlobalEventProcessors().push(callback);\n}\n"]}import { Session as SessionInterface, SessionContext, SessionStatus } from '@sentry/types';
/**
 * @inheritdoc
 */
export declare class Session implements SessionInterface {
    userAgent?: string;
    errors: number;
    release?: string;
    sid: string;
    did?: string;
    timestamp: number;
    started: number;
    duration?: number;
    status: SessionStatus;
    environment?: string;
    ipAddress?: string;
    init: boolean;
    ignoreDuration: boolean;
    constructor(context?: Omit<SessionContext, 'started' | 'status'>);
    /** JSDoc */
    update(context?: SessionContext): void;
    /** JSDoc */
    close(status?: Exclude<SessionStatus, 'ok'>): void;
    /** JSDoc */
    toJSON(): {
        init: boolean;
        sid: string;
        did?: string;
        timestamp: string;
        started: string;
        duration?: number;
        status: SessionStatus;
        errors: number;
        attrs?: {
            release?: string;
            environment?: string;
            user_agent?: string;
            ip_address?: string;
        };
    };
}
//# sourceMappingURL=session.d.ts.map{"version":3,"file":"session.d.ts","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,IAAI,gBAAgB,EAAE,cAAc,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAG3F;;GAEG;AACH,qBAAa,OAAQ,YAAW,gBAAgB;IACvC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAK;IACnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,GAAG,EAAE,MAAM,CAAW;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAK;IACtB,MAAM,EAAE,aAAa,CAAQ;IAC7B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,EAAE,OAAO,CAAQ;IACrB,cAAc,EAAE,OAAO,CAAS;gBAEpB,OAAO,CAAC,EAAE,IAAI,CAAC,cAAc,EAAE,SAAS,GAAG,QAAQ,CAAC;IAUvE,YAAY;IAEL,MAAM,CAAC,OAAO,GAAE,cAAmB,GAAG,IAAI;IAwDjD,YAAY;IACL,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,IAAI;IAUzD,YAAY;IACL,MAAM,IAAI;QACf,IAAI,EAAE,OAAO,CAAC;QACd,GAAG,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,MAAM,CAAC;QAClB,OAAO,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,MAAM,EAAE,aAAa,CAAC;QACtB,MAAM,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE;YACN,OAAO,CAAC,EAAE,MAAM,CAAC;YACjB,WAAW,CAAC,EAAE,MAAM,CAAC;YACrB,UAAU,CAAC,EAAE,MAAM,CAAC;YACpB,UAAU,CAAC,EAAE,MAAM,CAAC;SACrB,CAAC;KACH;CAmBF"}import { dropUndefinedKeys, timestampInSeconds, uuid4 } from '@sentry/utils';
/**
 * @inheritdoc
 */
var Session = /** @class */ (function () {
    function Session(context) {
        this.errors = 0;
        this.sid = uuid4();
        this.duration = 0;
        this.status = 'ok';
        this.init = true;
        this.ignoreDuration = false;
        // Both timestamp and started are in seconds since the UNIX epoch.
        var startingTime = timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
            this.update(context);
        }
    }
    /** JSDoc */
    // eslint-disable-next-line complexity
    Session.prototype.update = function (context) {
        if (context === void 0) { context = {}; }
        if (context.user) {
            if (!this.ipAddress && context.user.ip_address) {
                this.ipAddress = context.user.ip_address;
            }
            if (!this.did && !context.did) {
                this.did = context.user.id || context.user.email || context.user.username;
            }
        }
        this.timestamp = context.timestamp || timestampInSeconds();
        if (context.ignoreDuration) {
            this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
            // Good enough uuid validation. — Kamil
            this.sid = context.sid.length === 32 ? context.sid : uuid4();
        }
        if (context.init !== undefined) {
            this.init = context.init;
        }
        if (!this.did && context.did) {
            this.did = "" + context.did;
        }
        if (typeof context.started === 'number') {
            this.started = context.started;
        }
        if (this.ignoreDuration) {
            this.duration = undefined;
        }
        else if (typeof context.duration === 'number') {
            this.duration = context.duration;
        }
        else {
            var duration = this.timestamp - this.started;
            this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
            this.release = context.release;
        }
        if (context.environment) {
            this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
            this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
            this.userAgent = context.userAgent;
        }
        if (typeof context.errors === 'number') {
            this.errors = context.errors;
        }
        if (context.status) {
            this.status = context.status;
        }
    };
    /** JSDoc */
    Session.prototype.close = function (status) {
        if (status) {
            this.update({ status: status });
        }
        else if (this.status === 'ok') {
            this.update({ status: 'exited' });
        }
        else {
            this.update();
        }
    };
    /** JSDoc */
    Session.prototype.toJSON = function () {
        return dropUndefinedKeys({
            sid: "" + this.sid,
            init: this.init,
            // Make sure that sec is converted to ms for date constructor
            started: new Date(this.started * 1000).toISOString(),
            timestamp: new Date(this.timestamp * 1000).toISOString(),
            status: this.status,
            errors: this.errors,
            did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
            duration: this.duration,
            attrs: {
                release: this.release,
                environment: this.environment,
                ip_address: this.ipAddress,
                user_agent: this.userAgent,
            },
        });
    };
    return Session;
}());
export { Session };
//# sourceMappingURL=session.js.map{"version":3,"file":"session.js","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"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","sourcesContent":["import { Session as SessionInterface, SessionContext, SessionStatus } from '@sentry/types';\nimport { dropUndefinedKeys, timestampInSeconds, uuid4 } from '@sentry/utils';\n\n/**\n * @inheritdoc\n */\nexport class Session implements SessionInterface {\n  public userAgent?: string;\n  public errors: number = 0;\n  public release?: string;\n  public sid: string = uuid4();\n  public did?: string;\n  public timestamp: number;\n  public started: number;\n  public duration?: number = 0;\n  public status: SessionStatus = 'ok';\n  public environment?: string;\n  public ipAddress?: string;\n  public init: boolean = true;\n  public ignoreDuration: boolean = false;\n\n  public constructor(context?: Omit<SessionContext, 'started' | 'status'>) {\n    // Both timestamp and started are in seconds since the UNIX epoch.\n    const startingTime = timestampInSeconds();\n    this.timestamp = startingTime;\n    this.started = startingTime;\n    if (context) {\n      this.update(context);\n    }\n  }\n\n  /** JSDoc */\n  // eslint-disable-next-line complexity\n  public update(context: SessionContext = {}): void {\n    if (context.user) {\n      if (!this.ipAddress && context.user.ip_address) {\n        this.ipAddress = context.user.ip_address;\n      }\n\n      if (!this.did && !context.did) {\n        this.did = context.user.id || context.user.email || context.user.username;\n      }\n    }\n\n    this.timestamp = context.timestamp || timestampInSeconds();\n    if (context.ignoreDuration) {\n      this.ignoreDuration = context.ignoreDuration;\n    }\n    if (context.sid) {\n      // Good enough uuid validation. — Kamil\n      this.sid = context.sid.length === 32 ? context.sid : uuid4();\n    }\n    if (context.init !== undefined) {\n      this.init = context.init;\n    }\n    if (!this.did && context.did) {\n      this.did = `${context.did}`;\n    }\n    if (typeof context.started === 'number') {\n      this.started = context.started;\n    }\n    if (this.ignoreDuration) {\n      this.duration = undefined;\n    } else if (typeof context.duration === 'number') {\n      this.duration = context.duration;\n    } else {\n      const duration = this.timestamp - this.started;\n      this.duration = duration >= 0 ? duration : 0;\n    }\n    if (context.release) {\n      this.release = context.release;\n    }\n    if (context.environment) {\n      this.environment = context.environment;\n    }\n    if (!this.ipAddress && context.ipAddress) {\n      this.ipAddress = context.ipAddress;\n    }\n    if (!this.userAgent && context.userAgent) {\n      this.userAgent = context.userAgent;\n    }\n    if (typeof context.errors === 'number') {\n      this.errors = context.errors;\n    }\n    if (context.status) {\n      this.status = context.status;\n    }\n  }\n\n  /** JSDoc */\n  public close(status?: Exclude<SessionStatus, 'ok'>): void {\n    if (status) {\n      this.update({ status });\n    } else if (this.status === 'ok') {\n      this.update({ status: 'exited' });\n    } else {\n      this.update();\n    }\n  }\n\n  /** JSDoc */\n  public toJSON(): {\n    init: boolean;\n    sid: string;\n    did?: string;\n    timestamp: string;\n    started: string;\n    duration?: number;\n    status: SessionStatus;\n    errors: number;\n    attrs?: {\n      release?: string;\n      environment?: string;\n      user_agent?: string;\n      ip_address?: string;\n    };\n  } {\n    return dropUndefinedKeys({\n      sid: `${this.sid}`,\n      init: this.init,\n      // Make sure that sec is converted to ms for date constructor\n      started: new Date(this.started * 1000).toISOString(),\n      timestamp: new Date(this.timestamp * 1000).toISOString(),\n      status: this.status,\n      errors: this.errors,\n      did: typeof this.did === 'number' || typeof this.did === 'string' ? `${this.did}` : undefined,\n      duration: this.duration,\n      attrs: {\n        release: this.release,\n        environment: this.environment,\n        ip_address: this.ipAddress,\n        user_agent: this.userAgent,\n      },\n    });\n  }\n}\n"]}import { SessionAggregates, SessionFlusherLike, Transport } from '@sentry/types';
declare type ReleaseHealthAttributes = {
    environment?: string;
    release: string;
};
/**
 * @inheritdoc
 */
export declare class SessionFlusher implements SessionFlusherLike {
    readonly flushTimeout: number;
    private _pendingAggregates;
    private _sessionAttrs;
    private _intervalId;
    private _isEnabled;
    private _transport;
    constructor(transport: Transport, attrs: ReleaseHealthAttributes);
    /** Sends session aggregates to Transport */
    sendSessionAggregates(sessionAggregates: SessionAggregates): void;
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    flush(): void;
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    getSessionAggregates(): SessionAggregates;
    /** JSDoc */
    close(): void;
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    incrementSessionStatusCount(): void;
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    private _incrementSessionStatusCount;
}
export {};
//# sourceMappingURL=sessionflusher.d.ts.map{"version":3,"file":"sessionflusher.d.ts","sourceRoot":"","sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"AAAA,OAAO,EAGL,iBAAiB,EACjB,kBAAkB,EAClB,SAAS,EACV,MAAM,eAAe,CAAC;AAMvB,aAAK,uBAAuB,GAAG;IAC7B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF;;GAEG;AACH,qBAAa,cAAe,YAAW,kBAAkB;IACvD,SAAgB,YAAY,EAAE,MAAM,CAAM;IAC1C,OAAO,CAAC,kBAAkB,CAAyC;IACnE,OAAO,CAAC,aAAa,CAA0B;IAC/C,OAAO,CAAC,WAAW,CAAiC;IACpD,OAAO,CAAC,UAAU,CAAiB;IACnC,OAAO,CAAC,UAAU,CAAY;gBAEX,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,uBAAuB;IAOvE,4CAA4C;IACrC,qBAAqB,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,IAAI;IAUxE,uGAAuG;IAChG,KAAK,IAAI,IAAI;IASpB,kFAAkF;IAC3E,oBAAoB,IAAI,iBAAiB;IAYhD,YAAY;IACL,KAAK,IAAI,IAAI;IAMpB;;;;OAIG;IACI,2BAA2B,IAAI,IAAI;IAkB1C;;;OAGG;IACH,OAAO,CAAC,4BAA4B;CAwBrC"}import { dropUndefinedKeys, logger } from '@sentry/utils';
import { IS_DEBUG_BUILD } from './flags';
import { getCurrentHub } from './hub';
/**
 * @inheritdoc
 */
var SessionFlusher = /** @class */ (function () {
    function SessionFlusher(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        // Call to setInterval, so that flush is called every 60 seconds
        this._intervalId = setInterval(function () { return _this.flush(); }, this.flushTimeout * 1000);
        this._sessionAttrs = attrs;
    }
    /** Sends session aggregates to Transport */
    SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {
        if (!this._transport.sendSession) {
            IS_DEBUG_BUILD && logger.warn("Dropping session because custom transport doesn't implement sendSession");
            return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function (reason) {
            IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);
        });
    };
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    SessionFlusher.prototype.flush = function () {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
            return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
    };
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    SessionFlusher.prototype.getSessionAggregates = function () {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function (key) {
            return _this._pendingAggregates[parseInt(key)];
        });
        var sessionAggregates = {
            attrs: this._sessionAttrs,
            aggregates: aggregates,
        };
        return dropUndefinedKeys(sessionAggregates);
    };
    /** JSDoc */
    SessionFlusher.prototype.close = function () {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
    };
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    SessionFlusher.prototype.incrementSessionStatusCount = function () {
        if (!this._isEnabled) {
            return;
        }
        var scope = getCurrentHub().getScope();
        var requestSession = scope && scope.getRequestSession();
        if (requestSession && requestSession.status) {
            this._incrementSessionStatusCount(requestSession.status, new Date());
            // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in
            // case captureRequestSession is called more than once to prevent double count
            if (scope) {
                scope.setRequestSession(undefined);
            }
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        }
    };
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {
        // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        // corresponds to aggregated sessions in one specific minute bucket
        // for example, {"started":"2021-03-16T08:00:00.000Z","exited":4, "errored": 1}
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
            aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
            case 'errored':
                aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
                return aggregationCounts.errored;
            case 'ok':
                aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
                return aggregationCounts.exited;
            default:
                aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
                return aggregationCounts.crashed;
        }
    };
    return SessionFlusher;
}());
export { SessionFlusher };
//# sourceMappingURL=sessionflusher.js.map{"version":3,"file":"sessionflusher.js","sourceRoot":"","sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AggregationCounts,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n  Transport,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _transport: Transport;\n\n  public constructor(transport: Transport, attrs: ReleaseHealthAttributes) {\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Sends session aggregates to Transport */\n  public sendSessionAggregates(sessionAggregates: SessionAggregates): void {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    void this._transport.sendSession(sessionAggregates).then(null, reason => {\n      IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n    });\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope && scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"]}BSD 3-Clause License

Copyright (c) 2019, Sentry
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@sentry/hub",
  "version": "6.19.7",
  "description": "Sentry hub which handles global state managment.",
  "repository": "git://github.com/getsentry/sentry-javascript.git",
  "homepage": "https://github.com/getsentry/sentry-javascript/tree/master/packages/hub",
  "author": "Sentry",
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=6"
  },
  "main": "dist/index.js",
  "module": "esm/index.js",
  "types": "types/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@sentry/types": "6.19.7",
    "@sentry/utils": "6.19.7",
    "tslib": "^1.9.3"
  },
  "sideEffects": false
}<p align="center">
  <a href="https://sentry.io" target="_blank" align="center">
    <img src="https://sentry-brand.storage.googleapis.com/sentry-logo-black.png" width="280">
  </a>
  <br />
</p>

# Sentry JavaScript SDK Hub

[![npm version](https://img.shields.io/npm/v/@sentry/hub.svg)](https://www.npmjs.com/package/@sentry/hub)
[![npm dm](https://img.shields.io/npm/dm/@sentry/hub.svg)](https://www.npmjs.com/package/@sentry/hub)
[![npm dt](https://img.shields.io/npm/dt/@sentry/hub.svg)](https://www.npmjs.com/package/@sentry/hub)
[![typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](http://getsentry.github.io/sentry-javascript/)

## Links

- [Official SDK Docs](https://docs.sentry.io/quickstart/)
- [TypeDoc](http://getsentry.github.io/sentry-javascript/)

## General

This package provides the `Hub` and `Scope` for all JavaScript related SDKs.
/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}import { Breadcrumb, BreadcrumbHint, Client, CustomSamplingContext, Event, EventHint, Extra, Extras, Hub as HubInterface, Integration, IntegrationClass, Primitive, SessionContext, Severity, Span, SpanContext, Transaction, TransactionContext, User } from '@sentry/types';
import { Scope } from './scope';
import { Session } from './session';
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
export declare const API_VERSION = 4;
/**
 * A layer in the process stack.
 * @hidden
 */
export interface Layer {
    client?: Client;
    scope?: Scope;
}
/**
 * An object that contains a hub and maintains a scope stack.
 * @hidden
 */
export interface Carrier {
    __SENTRY__?: {
        hub?: Hub;
        /**
         * Extra Hub properties injected by various SDKs
         */
        integrations?: Integration[];
        extensions?: {
            /** Hack to prevent bundlers from breaking our usage of the domain package in the cross-platform Hub package */
            domain?: {
                [key: string]: any;
            };
        } & {
            /** Extension methods for the hub, which are bound to the current Hub instance */
            [key: string]: Function;
        };
    };
}
/**
 * @hidden
 * @deprecated Can be removed once `Hub.getActiveDomain` is removed.
 */
export interface DomainAsCarrier extends Carrier {
    members: {
        [key: string]: any;
    }[];
}
/**
 * @inheritDoc
 */
export declare class Hub implements HubInterface {
    private readonly _version;
    /** Is a {@link Layer}[] containing the client and scope */
    private readonly _stack;
    /** Contains the last event id of a captured event.  */
    private _lastEventId?;
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    constructor(client?: Client, scope?: Scope, _version?: number);
    /**
     * @inheritDoc
     */
    isOlderThan(version: number): boolean;
    /**
     * @inheritDoc
     */
    bindClient(client?: Client): void;
    /**
     * @inheritDoc
     */
    pushScope(): Scope;
    /**
     * @inheritDoc
     */
    popScope(): boolean;
    /**
     * @inheritDoc
     */
    withScope(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    getClient<C extends Client>(): C | undefined;
    /** Returns the scope of the top stack. */
    getScope(): Scope | undefined;
    /** Returns the scope stack for domains or the process. */
    getStack(): Layer[];
    /** Returns the topmost scope layer in the order domain > local > process. */
    getStackTop(): Layer;
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint): string;
    /**
     * @inheritDoc
     */
    lastEventId(): string | undefined;
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;
    /**
     * @inheritDoc
     */
    setUser(user: User | null): void;
    /**
     * @inheritDoc
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): void;
    /**
     * @inheritDoc
     */
    setExtras(extras: Extras): void;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: Primitive): void;
    /**
     * @inheritDoc
     */
    setExtra(key: string, extra: Extra): void;
    /**
     * @inheritDoc
     */
    setContext(name: string, context: {
        [key: string]: any;
    } | null): void;
    /**
     * @inheritDoc
     */
    configureScope(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    run(callback: (hub: Hub) => void): void;
    /**
     * @inheritDoc
     */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /**
     * @inheritDoc
     */
    startSpan(context: SpanContext): Span;
    /**
     * @inheritDoc
     */
    startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
    /**
     * @inheritDoc
     */
    traceHeaders(): {
        [key: string]: string;
    };
    /**
     * @inheritDoc
     */
    captureSession(endSession?: boolean): void;
    /**
     * @inheritDoc
     */
    endSession(): void;
    /**
     * @inheritDoc
     */
    startSession(context?: SessionContext): Session;
    /**
     * Sends the current Session on the scope
     */
    private _sendSessionUpdate;
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    private _invokeClient;
    /**
     * Calls global extension method and binding current instance to the function call
     */
    private _callExtensionMethod;
}
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
export declare function getMainCarrier(): Carrier;
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
export declare function makeMain(hub: Hub): Hub;
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
export declare function getCurrentHub(): Hub;
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
export declare function getActiveDomain(): DomainAsCarrier | undefined;
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
export declare function getHubFromCarrier(carrier: Carrier): Hub;
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
export declare function setHubOnCarrier(carrier: Carrier, hub: Hub): boolean;
//# sourceMappingURL=hub.d.ts.map{"version":3,"file":"hub.d.ts","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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"}export { addGlobalEventProcessor, Scope } from './scope';
export { Session } from './session';
export { SessionFlusher } from './sessionflusher';
export { getActiveDomain, getCurrentHub, getHubFromCarrier, getMainCarrier, Hub, makeMain, setHubOnCarrier, Carrier, DomainAsCarrier, Layer, } from './hub';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,uBAAuB,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AACzD,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAEL,eAAe,EACf,aAAa,EACb,iBAAiB,EACjB,cAAc,EACd,GAAG,EACH,QAAQ,EACR,eAAe,EACf,OAAO,EAEP,eAAe,EACf,KAAK,GACN,MAAM,OAAO,CAAC"}import { Breadcrumb, CaptureContext, Context, Contexts, Event, EventHint, EventProcessor, Extra, Extras, Primitive, RequestSession, Scope as ScopeInterface, Severity, Span, Transaction, User } from '@sentry/types';
import { Session } from './session';
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
export declare class Scope implements ScopeInterface {
    /** Flag if notifying is happening. */
    protected _notifyingListeners: boolean;
    /** Callback for client to receive scope changes. */
    protected _scopeListeners: Array<(scope: Scope) => void>;
    /** Callback list that will be called after {@link applyToEvent}. */
    protected _eventProcessors: EventProcessor[];
    /** Array of breadcrumbs. */
    protected _breadcrumbs: Breadcrumb[];
    /** User */
    protected _user: User;
    /** Tags */
    protected _tags: {
        [key: string]: Primitive;
    };
    /** Extra */
    protected _extra: Extras;
    /** Contexts */
    protected _contexts: Contexts;
    /** Fingerprint */
    protected _fingerprint?: string[];
    /** Severity */
    protected _level?: Severity;
    /** Transaction Name */
    protected _transactionName?: string;
    /** Span */
    protected _span?: Span;
    /** Session */
    protected _session?: Session;
    /** Request Mode Session Status */
    protected _requestSession?: RequestSession;
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    protected _sdkProcessingMetadata?: {
        [key: string]: unknown;
    };
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    static clone(scope?: Scope): Scope;
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    addScopeListener(callback: (scope: Scope) => void): void;
    /**
     * @inheritDoc
     */
    addEventProcessor(callback: EventProcessor): this;
    /**
     * @inheritDoc
     */
    setUser(user: User | null): this;
    /**
     * @inheritDoc
     */
    getUser(): User | undefined;
    /**
     * @inheritDoc
     */
    getRequestSession(): RequestSession | undefined;
    /**
     * @inheritDoc
     */
    setRequestSession(requestSession?: RequestSession): this;
    /**
     * @inheritDoc
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): this;
    /**
     * @inheritDoc
     */
    setTag(key: string, value: Primitive): this;
    /**
     * @inheritDoc
     */
    setExtras(extras: Extras): this;
    /**
     * @inheritDoc
     */
    setExtra(key: string, extra: Extra): this;
    /**
     * @inheritDoc
     */
    setFingerprint(fingerprint: string[]): this;
    /**
     * @inheritDoc
     */
    setLevel(level: Severity): this;
    /**
     * @inheritDoc
     */
    setTransactionName(name?: string): this;
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    setTransaction(name?: string): this;
    /**
     * @inheritDoc
     */
    setContext(key: string, context: Context | null): this;
    /**
     * @inheritDoc
     */
    setSpan(span?: Span): this;
    /**
     * @inheritDoc
     */
    getSpan(): Span | undefined;
    /**
     * @inheritDoc
     */
    getTransaction(): Transaction | undefined;
    /**
     * @inheritDoc
     */
    setSession(session?: Session): this;
    /**
     * @inheritDoc
     */
    getSession(): Session | undefined;
    /**
     * @inheritDoc
     */
    update(captureContext?: CaptureContext): this;
    /**
     * @inheritDoc
     */
    clear(): this;
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;
    /**
     * @inheritDoc
     */
    clearBreadcrumbs(): this;
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    applyToEvent(event: Event, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    setSDKProcessingMetadata(newData: {
        [key: string]: unknown;
    }): this;
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    protected _notifyEventProcessors(processors: EventProcessor[], event: Event | null, hint?: EventHint, index?: number): PromiseLike<Event | null>;
    /**
     * This will be called on every set call.
     */
    protected _notifyScopeListeners(): void;
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    private _applyFingerprint;
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
export declare function addGlobalEventProcessor(callback: EventProcessor): void;
//# sourceMappingURL=scope.d.ts.map{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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"}import { Session as SessionInterface, SessionContext, SessionStatus } from '@sentry/types';
/**
 * @inheritdoc
 */
export declare class Session implements SessionInterface {
    userAgent?: string;
    errors: number;
    release?: string;
    sid: string;
    did?: string;
    timestamp: number;
    started: number;
    duration?: number;
    status: SessionStatus;
    environment?: string;
    ipAddress?: string;
    init: boolean;
    ignoreDuration: boolean;
    constructor(context?: Omit<SessionContext, 'started' | 'status'>);
    /** JSDoc */
    update(context?: SessionContext): void;
    /** JSDoc */
    close(status?: Exclude<SessionStatus, 'ok'>): void;
    /** JSDoc */
    toJSON(): {
        init: boolean;
        sid: string;
        did?: string;
        timestamp: string;
        started: string;
        duration?: number;
        status: SessionStatus;
        errors: number;
        attrs?: {
            release?: string;
            environment?: string;
            user_agent?: string;
            ip_address?: string;
        };
    };
}
//# sourceMappingURL=session.d.ts.map{"version":3,"file":"session.d.ts","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,IAAI,gBAAgB,EAAE,cAAc,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAG3F;;GAEG;AACH,qBAAa,OAAQ,YAAW,gBAAgB;IACvC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAK;IACnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,GAAG,EAAE,MAAM,CAAW;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAK;IACtB,MAAM,EAAE,aAAa,CAAQ;IAC7B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,EAAE,OAAO,CAAQ;IACrB,cAAc,EAAE,OAAO,CAAS;gBAEpB,OAAO,CAAC,EAAE,IAAI,CAAC,cAAc,EAAE,SAAS,GAAG,QAAQ,CAAC;IAUvE,YAAY;IAEL,MAAM,CAAC,OAAO,GAAE,cAAmB,GAAG,IAAI;IAwDjD,YAAY;IACL,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,IAAI;IAUzD,YAAY;IACL,MAAM,IAAI;QACf,IAAI,EAAE,OAAO,CAAC;QACd,GAAG,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,MAAM,CAAC;QAClB,OAAO,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,MAAM,EAAE,aAAa,CAAC;QACtB,MAAM,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE;YACN,OAAO,CAAC,EAAE,MAAM,CAAC;YACjB,WAAW,CAAC,EAAE,MAAM,CAAC;YACrB,UAAU,CAAC,EAAE,MAAM,CAAC;YACpB,UAAU,CAAC,EAAE,MAAM,CAAC;SACrB,CAAC;KACH;CAmBF"}import { SessionAggregates, SessionFlusherLike, Transport } from '@sentry/types';
declare type ReleaseHealthAttributes = {
    environment?: string;
    release: string;
};
/**
 * @inheritdoc
 */
export declare class SessionFlusher implements SessionFlusherLike {
    readonly flushTimeout: number;
    private _pendingAggregates;
    private _sessionAttrs;
    private _intervalId;
    private _isEnabled;
    private _transport;
    constructor(transport: Transport, attrs: ReleaseHealthAttributes);
    /** Sends session aggregates to Transport */
    sendSessionAggregates(sessionAggregates: SessionAggregates): void;
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    flush(): void;
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    getSessionAggregates(): SessionAggregates;
    /** JSDoc */
    close(): void;
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    incrementSessionStatusCount(): void;
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    private _incrementSessionStatusCount;
}
export {};
//# sourceMappingURL=sessionflusher.d.ts.map{"version":3,"file":"sessionflusher.d.ts","sourceRoot":"","sources":["../../src/sessionflusher.ts"],"names":[],"mappings":"AAAA,OAAO,EAGL,iBAAiB,EACjB,kBAAkB,EAClB,SAAS,EACV,MAAM,eAAe,CAAC;AAMvB,aAAK,uBAAuB,GAAG;IAC7B,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF;;GAEG;AACH,qBAAa,cAAe,YAAW,kBAAkB;IACvD,SAAgB,YAAY,EAAE,MAAM,CAAM;IAC1C,OAAO,CAAC,kBAAkB,CAAyC;IACnE,OAAO,CAAC,aAAa,CAA0B;IAC/C,OAAO,CAAC,WAAW,CAAiC;IACpD,OAAO,CAAC,UAAU,CAAiB;IACnC,OAAO,CAAC,UAAU,CAAY;gBAEX,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,uBAAuB;IAOvE,4CAA4C;IACrC,qBAAqB,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,IAAI;IAUxE,uGAAuG;IAChG,KAAK,IAAI,IAAI;IASpB,kFAAkF;IAC3E,oBAAoB,IAAI,iBAAiB;IAYhD,YAAY;IACL,KAAK,IAAI,IAAI;IAMpB;;;;OAIG;IACI,2BAA2B,IAAI,IAAI;IAkB1C;;;OAGG;IACH,OAAO,CAAC,4BAA4B;CAwBrC"}import { Scope } from '@sentry/hub';
import { Breadcrumb, CaptureContext, CustomSamplingContext, Event, Extra, Extras, Primitive, Severity, Transaction, TransactionContext, User } from '@sentry/types';
/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @returns The generated eventId.
 */
export declare function captureException(exception: any, captureContext?: CaptureContext): string;
/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
export declare function captureMessage(message: string, captureContext?: CaptureContext | Severity): string;
/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
export declare function captureEvent(event: Event): string;
/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
export declare function configureScope(callback: (scope: Scope) => void): void;
/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
export declare function addBreadcrumb(breadcrumb: Breadcrumb): void;
/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
export declare function setContext(name: string, context: {
    [key: string]: any;
} | null): void;
/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
export declare function setExtras(extras: Extras): void;
/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
export declare function setTags(tags: {
    [key: string]: Primitive;
}): void;
/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
export declare function setExtra(key: string, extra: Extra): void;
/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
export declare function setTag(key: string, value: Primitive): void;
/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
export declare function setUser(user: User | null): void;
/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
export declare function withScope(callback: (scope: Scope) => void): void;
/**
 * Calls a function on the latest client. Use this with caution, it's meant as
 * in "internal" helper so we don't need to expose every possible function in
 * the shim. It is not guaranteed that the client actually implements the
 * function.
 *
 * @param method The method to call on the client/client.
 * @param args Arguments to pass to the client/fontend.
 * @hidden
 */
export declare function _callOnClient(method: string, ...args: any[]): void;
/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
export declare function startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAsB,KAAK,EAAE,MAAM,aAAa,CAAC;AACxD,OAAO,EACL,UAAU,EACV,cAAc,EACd,qBAAqB,EACrB,KAAK,EACL,KAAK,EACL,MAAM,EACN,SAAS,EACT,QAAQ,EACR,WAAW,EACX,kBAAkB,EAClB,IAAI,EACL,MAAM,eAAe,CAAC;AAiBvB;;;;;GAKG;AAEH,wBAAgB,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,cAAc,CAAC,EAAE,cAAc,GAAG,MAAM,CAQxF;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,cAAc,CAAC,EAAE,cAAc,GAAG,QAAQ,GAAG,MAAM,CAalG;AAED;;;;;GAKG;AACH,wBAAgB,YAAY,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAEjD;AAED;;;GAGG;AACH,wBAAgB,cAAc,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,CAErE;AAED;;;;;;;GAOG;AACH,wBAAgB,aAAa,CAAC,UAAU,EAAE,UAAU,GAAG,IAAI,CAE1D;AAED;;;;GAIG;AAEH,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,GAAG,IAAI,GAAG,IAAI,CAErF;AAED;;;GAGG;AACH,wBAAgB,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAE9C;AAED;;;GAGG;AACH,wBAAgB,OAAO,CAAC,IAAI,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;CAAE,GAAG,IAAI,CAEhE;AAED;;;;GAIG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI,CAExD;AAED;;;;;;;GAOG;AACH,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,GAAG,IAAI,CAE1D;AAED;;;;GAIG;AACH,wBAAgB,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,CAE/C;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,SAAS,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,CAEhE;AAED;;;;;;;;;GASG;AAEH,wBAAgB,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,CAElE;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,gBAAgB,CAC9B,OAAO,EAAE,kBAAkB,EAC3B,qBAAqB,CAAC,EAAE,qBAAqB,GAC5C,WAAW,CAEb"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var hub_1 = require("@sentry/hub");
/**
 * This calls a function on the current hub.
 * @param method function to call on hub.
 * @param args to pass to function.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function callOnHub(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var hub = hub_1.getCurrentHub();
    if (hub && hub[method]) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return hub[method].apply(hub, tslib_1.__spread(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
}
/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @returns The generated eventId.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function captureException(exception, captureContext) {
    var syntheticException = new Error('Sentry syntheticException');
    return callOnHub('captureException', exception, {
        captureContext: captureContext,
        originalException: exception,
        syntheticException: syntheticException,
    });
}
exports.captureException = captureException;
/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
function captureMessage(message, captureContext) {
    var syntheticException = new Error(message);
    // This is necessary to provide explicit scopes upgrade, without changing the original
    // arity of the `captureMessage(message, level)` method.
    var level = typeof captureContext === 'string' ? captureContext : undefined;
    var context = typeof captureContext !== 'string' ? { captureContext: captureContext } : undefined;
    return callOnHub('captureMessage', message, level, tslib_1.__assign({ originalException: message, syntheticException: syntheticException }, context));
}
exports.captureMessage = captureMessage;
/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
function captureEvent(event) {
    return callOnHub('captureEvent', event);
}
exports.captureEvent = captureEvent;
/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
function configureScope(callback) {
    callOnHub('configureScope', callback);
}
exports.configureScope = configureScope;
/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
function addBreadcrumb(breadcrumb) {
    callOnHub('addBreadcrumb', breadcrumb);
}
exports.addBreadcrumb = addBreadcrumb;
/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setContext(name, context) {
    callOnHub('setContext', name, context);
}
exports.setContext = setContext;
/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
function setExtras(extras) {
    callOnHub('setExtras', extras);
}
exports.setExtras = setExtras;
/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
function setTags(tags) {
    callOnHub('setTags', tags);
}
exports.setTags = setTags;
/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
function setExtra(key, extra) {
    callOnHub('setExtra', key, extra);
}
exports.setExtra = setExtra;
/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
function setTag(key, value) {
    callOnHub('setTag', key, value);
}
exports.setTag = setTag;
/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
function setUser(user) {
    callOnHub('setUser', user);
}
exports.setUser = setUser;
/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
function withScope(callback) {
    callOnHub('withScope', callback);
}
exports.withScope = withScope;
/**
 * Calls a function on the latest client. Use this with caution, it's meant as
 * in "internal" helper so we don't need to expose every possible function in
 * the shim. It is not guaranteed that the client actually implements the
 * function.
 *
 * @param method The method to call on the client/client.
 * @param args Arguments to pass to the client/fontend.
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function _callOnClient(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    callOnHub.apply(void 0, tslib_1.__spread(['_invokeClient', method], args));
}
exports._callOnClient = _callOnClient;
/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
function startTransaction(context, customSamplingContext) {
    return callOnHub('startTransaction', tslib_1.__assign({}, context), customSamplingContext);
}
exports.startTransaction = startTransaction;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, Hub, Scope } from '@sentry/hub';\nimport {\n  Breadcrumb,\n  CaptureContext,\n  CustomSamplingContext,\n  Event,\n  Extra,\n  Extras,\n  Primitive,\n  Severity,\n  Transaction,\n  TransactionContext,\n  User,\n} from '@sentry/types';\n\n/**\n * This calls a function on the current hub.\n * @param method function to call on hub.\n * @param args to pass to function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction callOnHub<T>(method: string, ...args: any[]): T {\n  const hub = getCurrentHub();\n  if (hub && hub[method as keyof Hub]) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (hub[method as keyof Hub] as any)(...args);\n  }\n  throw new Error(`No hub defined or ${method} was not found on the hub, please open a bug report.`);\n}\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @returns The generated eventId.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport function captureException(exception: any, captureContext?: CaptureContext): string {\n  const syntheticException = new Error('Sentry syntheticException');\n\n  return callOnHub('captureException', exception, {\n    captureContext,\n    originalException: exception,\n    syntheticException,\n  });\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param Severity Define the level of the message.\n * @returns The generated eventId.\n */\nexport function captureMessage(message: string, captureContext?: CaptureContext | Severity): string {\n  const syntheticException = new Error(message);\n\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n\n  return callOnHub('captureMessage', message, level, {\n    originalException: message,\n    syntheticException,\n    ...context,\n  });\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nexport function captureEvent(event: Event): string {\n  return callOnHub('captureEvent', event);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nexport function configureScope(callback: (scope: Scope) => void): void {\n  callOnHub<void>('configureScope', callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nexport function addBreadcrumb(breadcrumb: Breadcrumb): void {\n  callOnHub<void>('addBreadcrumb', breadcrumb);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setContext(name: string, context: { [key: string]: any } | null): void {\n  callOnHub<void>('setContext', name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nexport function setExtras(extras: Extras): void {\n  callOnHub<void>('setExtras', extras);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nexport function setTags(tags: { [key: string]: Primitive }): void {\n  callOnHub<void>('setTags', tags);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nexport function setExtra(key: string, extra: Extra): void {\n  callOnHub<void>('setExtra', key, extra);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nexport function setTag(key: string, value: Primitive): void {\n  callOnHub<void>('setTag', key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nexport function setUser(user: User | null): void {\n  callOnHub<void>('setUser', user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nexport function withScope(callback: (scope: Scope) => void): void {\n  callOnHub<void>('withScope', callback);\n}\n\n/**\n * Calls a function on the latest client. Use this with caution, it's meant as\n * in \"internal\" helper so we don't need to expose every possible function in\n * the shim. It is not guaranteed that the client actually implements the\n * function.\n *\n * @param method The method to call on the client/client.\n * @param args Arguments to pass to the client/fontend.\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _callOnClient(method: string, ...args: any[]): void {\n  callOnHub<void>('_invokeClient', method, ...args);\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nexport function startTransaction(\n  context: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n): Transaction {\n  return callOnHub('startTransaction', { ...context }, customSamplingContext);\n}\n"]}import { Scope } from '@sentry/hub';
import { Breadcrumb, CaptureContext, CustomSamplingContext, Event, Extra, Extras, Primitive, Severity, Transaction, TransactionContext, User } from '@sentry/types';
/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @returns The generated eventId.
 */
export declare function captureException(exception: any, captureContext?: CaptureContext): string;
/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
export declare function captureMessage(message: string, captureContext?: CaptureContext | Severity): string;
/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
export declare function captureEvent(event: Event): string;
/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
export declare function configureScope(callback: (scope: Scope) => void): void;
/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
export declare function addBreadcrumb(breadcrumb: Breadcrumb): void;
/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
export declare function setContext(name: string, context: {
    [key: string]: any;
} | null): void;
/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
export declare function setExtras(extras: Extras): void;
/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
export declare function setTags(tags: {
    [key: string]: Primitive;
}): void;
/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
export declare function setExtra(key: string, extra: Extra): void;
/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
export declare function setTag(key: string, value: Primitive): void;
/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
export declare function setUser(user: User | null): void;
/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
export declare function withScope(callback: (scope: Scope) => void): void;
/**
 * Calls a function on the latest client. Use this with caution, it's meant as
 * in "internal" helper so we don't need to expose every possible function in
 * the shim. It is not guaranteed that the client actually implements the
 * function.
 *
 * @param method The method to call on the client/client.
 * @param args Arguments to pass to the client/fontend.
 * @hidden
 */
export declare function _callOnClient(method: string, ...args: any[]): void;
/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
export declare function startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAsB,KAAK,EAAE,MAAM,aAAa,CAAC;AACxD,OAAO,EACL,UAAU,EACV,cAAc,EACd,qBAAqB,EACrB,KAAK,EACL,KAAK,EACL,MAAM,EACN,SAAS,EACT,QAAQ,EACR,WAAW,EACX,kBAAkB,EAClB,IAAI,EACL,MAAM,eAAe,CAAC;AAiBvB;;;;;GAKG;AAEH,wBAAgB,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,cAAc,CAAC,EAAE,cAAc,GAAG,MAAM,CAQxF;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,cAAc,CAAC,EAAE,cAAc,GAAG,QAAQ,GAAG,MAAM,CAalG;AAED;;;;;GAKG;AACH,wBAAgB,YAAY,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAEjD;AAED;;;GAGG;AACH,wBAAgB,cAAc,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,CAErE;AAED;;;;;;;GAOG;AACH,wBAAgB,aAAa,CAAC,UAAU,EAAE,UAAU,GAAG,IAAI,CAE1D;AAED;;;;GAIG;AAEH,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,GAAG,IAAI,GAAG,IAAI,CAErF;AAED;;;GAGG;AACH,wBAAgB,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAE9C;AAED;;;GAGG;AACH,wBAAgB,OAAO,CAAC,IAAI,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;CAAE,GAAG,IAAI,CAEhE;AAED;;;;GAIG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI,CAExD;AAED;;;;;;;GAOG;AACH,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,GAAG,IAAI,CAE1D;AAED;;;;GAIG;AACH,wBAAgB,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,CAE/C;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,SAAS,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,CAEhE;AAED;;;;;;;;;GASG;AAEH,wBAAgB,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,CAElE;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,gBAAgB,CAC9B,OAAO,EAAE,kBAAkB,EAC3B,qBAAqB,CAAC,EAAE,qBAAqB,GAC5C,WAAW,CAEb"}import { __assign, __read, __spread } from "tslib";
import { getCurrentHub } from '@sentry/hub';
/**
 * This calls a function on the current hub.
 * @param method function to call on hub.
 * @param args to pass to function.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function callOnHub(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var hub = getCurrentHub();
    if (hub && hub[method]) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return hub[method].apply(hub, __spread(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
}
/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @returns The generated eventId.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
export function captureException(exception, captureContext) {
    var syntheticException = new Error('Sentry syntheticException');
    return callOnHub('captureException', exception, {
        captureContext: captureContext,
        originalException: exception,
        syntheticException: syntheticException,
    });
}
/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
export function captureMessage(message, captureContext) {
    var syntheticException = new Error(message);
    // This is necessary to provide explicit scopes upgrade, without changing the original
    // arity of the `captureMessage(message, level)` method.
    var level = typeof captureContext === 'string' ? captureContext : undefined;
    var context = typeof captureContext !== 'string' ? { captureContext: captureContext } : undefined;
    return callOnHub('captureMessage', message, level, __assign({ originalException: message, syntheticException: syntheticException }, context));
}
/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
export function captureEvent(event) {
    return callOnHub('captureEvent', event);
}
/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
export function configureScope(callback) {
    callOnHub('configureScope', callback);
}
/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
export function addBreadcrumb(breadcrumb) {
    callOnHub('addBreadcrumb', breadcrumb);
}
/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function setContext(name, context) {
    callOnHub('setContext', name, context);
}
/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
export function setExtras(extras) {
    callOnHub('setExtras', extras);
}
/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
export function setTags(tags) {
    callOnHub('setTags', tags);
}
/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
export function setExtra(key, extra) {
    callOnHub('setExtra', key, extra);
}
/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
export function setTag(key, value) {
    callOnHub('setTag', key, value);
}
/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
export function setUser(user) {
    callOnHub('setUser', user);
}
/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
export function withScope(callback) {
    callOnHub('withScope', callback);
}
/**
 * Calls a function on the latest client. Use this with caution, it's meant as
 * in "internal" helper so we don't need to expose every possible function in
 * the shim. It is not guaranteed that the client actually implements the
 * function.
 *
 * @param method The method to call on the client/client.
 * @param args Arguments to pass to the client/fontend.
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function _callOnClient(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    callOnHub.apply(void 0, __spread(['_invokeClient', method], args));
}
/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
export function startTransaction(context, customSamplingContext) {
    return callOnHub('startTransaction', __assign({}, context), customSamplingContext);
}
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,aAAa,EAAc,MAAM,aAAa,CAAC;AAexD;;;;GAIG;AACH,8DAA8D;AAC9D,SAAS,SAAS,CAAI,MAAc;IAAE,cAAc;SAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;QAAd,6BAAc;;IAClD,IAAM,GAAG,GAAG,aAAa,EAAE,CAAC;IAC5B,IAAI,GAAG,IAAI,GAAG,CAAC,MAAmB,CAAC,EAAE;QACnC,8DAA8D;QAC9D,OAAQ,GAAG,CAAC,MAAmB,CAAC,OAAxB,GAAG,WAAiC,IAAI,GAAE;KACnD;IACD,MAAM,IAAI,KAAK,CAAC,uBAAqB,MAAM,yDAAsD,CAAC,CAAC;AACrG,CAAC;AAED;;;;;GAKG;AACH,iHAAiH;AACjH,MAAM,UAAU,gBAAgB,CAAC,SAAc,EAAE,cAA+B;IAC9E,IAAM,kBAAkB,GAAG,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;IAElE,OAAO,SAAS,CAAC,kBAAkB,EAAE,SAAS,EAAE;QAC9C,cAAc,gBAAA;QACd,iBAAiB,EAAE,SAAS;QAC5B,kBAAkB,oBAAA;KACnB,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,cAAc,CAAC,OAAe,EAAE,cAA0C;IACxF,IAAM,kBAAkB,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;IAE9C,sFAAsF;IACtF,wDAAwD;IACxD,IAAM,KAAK,GAAG,OAAO,cAAc,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC;IAC9E,IAAM,OAAO,GAAG,OAAO,cAAc,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,cAAc,gBAAA,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;IAEpF,OAAO,SAAS,CAAC,gBAAgB,EAAE,OAAO,EAAE,KAAK,aAC/C,iBAAiB,EAAE,OAAO,EAC1B,kBAAkB,oBAAA,IACf,OAAO,EACV,CAAC;AACL,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,YAAY,CAAC,KAAY;IACvC,OAAO,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;AAC1C,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,cAAc,CAAC,QAAgC;IAC7D,SAAS,CAAO,gBAAgB,EAAE,QAAQ,CAAC,CAAC;AAC9C,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,aAAa,CAAC,UAAsB;IAClD,SAAS,CAAO,eAAe,EAAE,UAAU,CAAC,CAAC;AAC/C,CAAC;AAED;;;;GAIG;AACH,8DAA8D;AAC9D,MAAM,UAAU,UAAU,CAAC,IAAY,EAAE,OAAsC;IAC7E,SAAS,CAAO,YAAY,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;AAC/C,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,SAAS,CAAC,MAAc;IACtC,SAAS,CAAO,WAAW,EAAE,MAAM,CAAC,CAAC;AACvC,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,OAAO,CAAC,IAAkC;IACxD,SAAS,CAAO,SAAS,EAAE,IAAI,CAAC,CAAC;AACnC,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,QAAQ,CAAC,GAAW,EAAE,KAAY;IAChD,SAAS,CAAO,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;AAC1C,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,MAAM,CAAC,GAAW,EAAE,KAAgB;IAClD,SAAS,CAAO,QAAQ,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;AACxC,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,OAAO,CAAC,IAAiB;IACvC,SAAS,CAAO,SAAS,EAAE,IAAI,CAAC,CAAC;AACnC,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,SAAS,CAAC,QAAgC;IACxD,SAAS,CAAO,WAAW,EAAE,QAAQ,CAAC,CAAC;AACzC,CAAC;AAED;;;;;;;;;GASG;AACH,8DAA8D;AAC9D,MAAM,UAAU,aAAa,CAAC,MAAc;IAAE,cAAc;SAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;QAAd,6BAAc;;IAC1D,SAAS,yBAAO,eAAe,EAAE,MAAM,GAAK,IAAI,GAAE;AACpD,CAAC;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,UAAU,gBAAgB,CAC9B,OAA2B,EAC3B,qBAA6C;IAE7C,OAAO,SAAS,CAAC,kBAAkB,eAAO,OAAO,GAAI,qBAAqB,CAAC,CAAC;AAC9E,CAAC","sourcesContent":["import { getCurrentHub, Hub, Scope } from '@sentry/hub';\nimport {\n  Breadcrumb,\n  CaptureContext,\n  CustomSamplingContext,\n  Event,\n  Extra,\n  Extras,\n  Primitive,\n  Severity,\n  Transaction,\n  TransactionContext,\n  User,\n} from '@sentry/types';\n\n/**\n * This calls a function on the current hub.\n * @param method function to call on hub.\n * @param args to pass to function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction callOnHub<T>(method: string, ...args: any[]): T {\n  const hub = getCurrentHub();\n  if (hub && hub[method as keyof Hub]) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (hub[method as keyof Hub] as any)(...args);\n  }\n  throw new Error(`No hub defined or ${method} was not found on the hub, please open a bug report.`);\n}\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @returns The generated eventId.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport function captureException(exception: any, captureContext?: CaptureContext): string {\n  const syntheticException = new Error('Sentry syntheticException');\n\n  return callOnHub('captureException', exception, {\n    captureContext,\n    originalException: exception,\n    syntheticException,\n  });\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param Severity Define the level of the message.\n * @returns The generated eventId.\n */\nexport function captureMessage(message: string, captureContext?: CaptureContext | Severity): string {\n  const syntheticException = new Error(message);\n\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const context = typeof captureContext !== 'string' ? { captureContext } : undefined;\n\n  return callOnHub('captureMessage', message, level, {\n    originalException: message,\n    syntheticException,\n    ...context,\n  });\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nexport function captureEvent(event: Event): string {\n  return callOnHub('captureEvent', event);\n}\n\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nexport function configureScope(callback: (scope: Scope) => void): void {\n  callOnHub<void>('configureScope', callback);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nexport function addBreadcrumb(breadcrumb: Breadcrumb): void {\n  callOnHub<void>('addBreadcrumb', breadcrumb);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setContext(name: string, context: { [key: string]: any } | null): void {\n  callOnHub<void>('setContext', name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nexport function setExtras(extras: Extras): void {\n  callOnHub<void>('setExtras', extras);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nexport function setTags(tags: { [key: string]: Primitive }): void {\n  callOnHub<void>('setTags', tags);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nexport function setExtra(key: string, extra: Extra): void {\n  callOnHub<void>('setExtra', key, extra);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nexport function setTag(key: string, value: Primitive): void {\n  callOnHub<void>('setTag', key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nexport function setUser(user: User | null): void {\n  callOnHub<void>('setUser', user);\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nexport function withScope(callback: (scope: Scope) => void): void {\n  callOnHub<void>('withScope', callback);\n}\n\n/**\n * Calls a function on the latest client. Use this with caution, it's meant as\n * in \"internal\" helper so we don't need to expose every possible function in\n * the shim. It is not guaranteed that the client actually implements the\n * function.\n *\n * @param method The method to call on the client/client.\n * @param args Arguments to pass to the client/fontend.\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _callOnClient(method: string, ...args: any[]): void {\n  callOnHub<void>('_invokeClient', method, ...args);\n}\n\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nexport function startTransaction(\n  context: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n): Transaction {\n  return callOnHub('startTransaction', { ...context }, customSamplingContext);\n}\n"]}BSD 3-Clause License

Copyright (c) 2019, Sentry
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@sentry/minimal",
  "version": "6.19.7",
  "description": "Sentry minimal library that can be used in other packages",
  "repository": "git://github.com/getsentry/sentry-javascript.git",
  "homepage": "https://github.com/getsentry/sentry-javascript/tree/master/packages/minimal",
  "author": "Sentry",
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=6"
  },
  "main": "dist/index.js",
  "module": "esm/index.js",
  "types": "types/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@sentry/hub": "6.19.7",
    "@sentry/types": "6.19.7",
    "tslib": "^1.9.3"
  },
  "sideEffects": false
}<p align="center">
  <a href="https://sentry.io" target="_blank" align="center">
    <img src="https://sentry-brand.storage.googleapis.com/sentry-logo-black.png" width="280">
  </a>
  <br />
</p>

# Sentry JavaScript SDK Minimal

[![npm version](https://img.shields.io/npm/v/@sentry/minimal.svg)](https://www.npmjs.com/package/@sentry/minimal)
[![npm dm](https://img.shields.io/npm/dm/@sentry/minimal.svg)](https://www.npmjs.com/package/@sentry/minimal)
[![npm dt](https://img.shields.io/npm/dt/@sentry/minimal.svg)](https://www.npmjs.com/package/@sentry/minimal)
[![typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](http://getsentry.github.io/sentry-javascript/)

## Links

- [Official SDK Docs](https://docs.sentry.io/quickstart/)
- [TypeDoc](http://getsentry.github.io/sentry-javascript/)

## General

A minimal Sentry SDK that uses a configured client when embedded into an application. It allows library authors add
support for a Sentry SDK without having to bundle the entire SDK or being dependent on a specific platform. If the user
is using Sentry in their application and your library uses `@sentry/minimal`, the user receives all
breadcrumbs/messages/events you added to your libraries codebase.

## Usage

To use the minimal, you do not have to initialize an SDK. This should be handled by the user of your library. Instead,
directly use the exported functions of `@sentry/minimal` to add breadcrumbs or capture events:

```javascript
import * as Sentry from '@sentry/minimal';

// Add a breadcrumb for future events
Sentry.addBreadcrumb({
  message: 'My Breadcrumb',
  // ...
});

// Capture exceptions, messages or manual events
Sentry.captureMessage('Hello, world!');
Sentry.captureException(new Error('Good bye'));
Sentry.captureEvent({
  message: 'Manual',
  stacktrace: [
    // ...
  ],
});
```

Note that while strictly possible, it is discouraged to interfere with the event context. If for some reason your
library needs to inject context information, beware that this might override the user's context values:

```javascript
// Set user information, as well as tags and further extras
Sentry.configureScope(scope => {
  scope.setExtra('battery', 0.7);
  scope.setTag('user_mode', 'admin');
  scope.setUser({ id: '4711' });
  // scope.clear();
});
```
import { Scope } from '@sentry/hub';
import { Breadcrumb, CaptureContext, CustomSamplingContext, Event, Extra, Extras, Primitive, Severity, Transaction, TransactionContext, User } from '@sentry/types';
/**
 * Captures an exception event and sends it to Sentry.
 *
 * @param exception An exception-like object.
 * @returns The generated eventId.
 */
export declare function captureException(exception: any, captureContext?: CaptureContext): string;
/**
 * Captures a message event and sends it to Sentry.
 *
 * @param message The message to send to Sentry.
 * @param Severity Define the level of the message.
 * @returns The generated eventId.
 */
export declare function captureMessage(message: string, captureContext?: CaptureContext | Severity): string;
/**
 * Captures a manually created event and sends it to Sentry.
 *
 * @param event The event to send to Sentry.
 * @returns The generated eventId.
 */
export declare function captureEvent(event: Event): string;
/**
 * Callback to set context information onto the scope.
 * @param callback Callback function that receives Scope.
 */
export declare function configureScope(callback: (scope: Scope) => void): void;
/**
 * Records a new breadcrumb which will be attached to future events.
 *
 * Breadcrumbs will be added to subsequent events to provide more context on
 * user's actions prior to an error or crash.
 *
 * @param breadcrumb The breadcrumb to record.
 */
export declare function addBreadcrumb(breadcrumb: Breadcrumb): void;
/**
 * Sets context data with the given name.
 * @param name of the context
 * @param context Any kind of data. This data will be normalized.
 */
export declare function setContext(name: string, context: {
    [key: string]: any;
} | null): void;
/**
 * Set an object that will be merged sent as extra data with the event.
 * @param extras Extras object to merge into current context.
 */
export declare function setExtras(extras: Extras): void;
/**
 * Set an object that will be merged sent as tags data with the event.
 * @param tags Tags context object to merge into current context.
 */
export declare function setTags(tags: {
    [key: string]: Primitive;
}): void;
/**
 * Set key:value that will be sent as extra data with the event.
 * @param key String of extra
 * @param extra Any kind of data. This data will be normalized.
 */
export declare function setExtra(key: string, extra: Extra): void;
/**
 * Set key:value that will be sent as tags data with the event.
 *
 * Can also be used to unset a tag, by passing `undefined`.
 *
 * @param key String key of tag
 * @param value Value of tag
 */
export declare function setTag(key: string, value: Primitive): void;
/**
 * Updates user context information for future events.
 *
 * @param user User context object to be set in the current context. Pass `null` to unset the user.
 */
export declare function setUser(user: User | null): void;
/**
 * Creates a new scope with and executes the given operation within.
 * The scope is automatically removed once the operation
 * finishes or throws.
 *
 * This is essentially a convenience function for:
 *
 *     pushScope();
 *     callback();
 *     popScope();
 *
 * @param callback that will be enclosed into push/popScope.
 */
export declare function withScope(callback: (scope: Scope) => void): void;
/**
 * Calls a function on the latest client. Use this with caution, it's meant as
 * in "internal" helper so we don't need to expose every possible function in
 * the shim. It is not guaranteed that the client actually implements the
 * function.
 *
 * @param method The method to call on the client/client.
 * @param args Arguments to pass to the client/fontend.
 * @hidden
 */
export declare function _callOnClient(method: string, ...args: any[]): void;
/**
 * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
 *
 * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
 * new child span within the transaction or any span, call the respective `.startChild()` method.
 *
 * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
 *
 * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
 * finished child spans will be sent to Sentry.
 *
 * @param context Properties of the new `Transaction`.
 * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
 * default values). See {@link Options.tracesSampler}.
 *
 * @returns The transaction which was just started
 */
export declare function startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAsB,KAAK,EAAE,MAAM,aAAa,CAAC;AACxD,OAAO,EACL,UAAU,EACV,cAAc,EACd,qBAAqB,EACrB,KAAK,EACL,KAAK,EACL,MAAM,EACN,SAAS,EACT,QAAQ,EACR,WAAW,EACX,kBAAkB,EAClB,IAAI,EACL,MAAM,eAAe,CAAC;AAiBvB;;;;;GAKG;AAEH,wBAAgB,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,cAAc,CAAC,EAAE,cAAc,GAAG,MAAM,CAQxF;AAED;;;;;;GAMG;AACH,wBAAgB,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,cAAc,CAAC,EAAE,cAAc,GAAG,QAAQ,GAAG,MAAM,CAalG;AAED;;;;;GAKG;AACH,wBAAgB,YAAY,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAEjD;AAED;;;GAGG;AACH,wBAAgB,cAAc,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,CAErE;AAED;;;;;;;GAOG;AACH,wBAAgB,aAAa,CAAC,UAAU,EAAE,UAAU,GAAG,IAAI,CAE1D;AAED;;;;GAIG;AAEH,wBAAgB,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,GAAG,IAAI,GAAG,IAAI,CAErF;AAED;;;GAGG;AACH,wBAAgB,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAE9C;AAED;;;GAGG;AACH,wBAAgB,OAAO,CAAC,IAAI,EAAE;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;CAAE,GAAG,IAAI,CAEhE;AAED;;;;GAIG;AACH,wBAAgB,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAG,IAAI,CAExD;AAED;;;;;;;GAOG;AACH,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,GAAG,IAAI,CAE1D;AAED;;;;GAIG;AACH,wBAAgB,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,IAAI,CAE/C;AAED;;;;;;;;;;;;GAYG;AACH,wBAAgB,SAAS,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,CAEhE;AAED;;;;;;;;;GASG;AAEH,wBAAgB,aAAa,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,CAElE;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,gBAAgB,CAC9B,OAAO,EAAE,kBAAkB,EAC3B,qBAAqB,CAAC,EAAE,qBAAqB,GAC5C,WAAW,CAEb"}import { BaseBackend } from '@sentry/core';
import { Event, EventHint, Severity, Transport } from '@sentry/types';
import { NodeOptions } from './types';
/**
 * The Sentry Node SDK Backend.
 * @hidden
 */
export declare class NodeBackend extends BaseBackend<NodeOptions> {
    /**
     * @inheritDoc
     */
    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    protected _setupTransport(): Transport;
}
//# sourceMappingURL=backend.d.ts.map{"version":3,"file":"backend.d.ts","sourceRoot":"","sources":["../../src/backend.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAyD,MAAM,cAAc,CAAC;AAClG,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAoB,MAAM,eAAe,CAAC;AAKxF,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC;;;GAGG;AACH,qBAAa,WAAY,SAAQ,WAAW,CAAC,WAAW,CAAC;IACvD;;OAEG;IAEI,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAI/E;;OAEG;IACI,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,GAAE,QAAwB,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAI/G;;OAEG;IACH,SAAS,CAAC,eAAe,IAAI,SAAS;CAqCvC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var eventbuilder_1 = require("./eventbuilder");
var transports_1 = require("./transports");
/**
 * The Sentry Node SDK Backend.
 * @hidden
 */
var NodeBackend = /** @class */ (function (_super) {
    tslib_1.__extends(NodeBackend, _super);
    function NodeBackend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    NodeBackend.prototype.eventFromException = function (exception, hint) {
        return utils_1.resolvedSyncPromise(eventbuilder_1.eventFromUnknownInput(exception, hint));
    };
    /**
     * @inheritDoc
     */
    NodeBackend.prototype.eventFromMessage = function (message, level, hint) {
        if (level === void 0) { level = types_1.Severity.Info; }
        return utils_1.resolvedSyncPromise(eventbuilder_1.eventFromMessage(message, level, hint, this._options.attachStacktrace));
    };
    /**
     * @inheritDoc
     */
    NodeBackend.prototype._setupTransport = function () {
        if (!this._options.dsn) {
            // We return the noop transport here in case there is no Dsn.
            return _super.prototype._setupTransport.call(this);
        }
        var dsn = utils_1.makeDsn(this._options.dsn);
        var transportOptions = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this._options.transportOptions), (this._options.httpProxy && { httpProxy: this._options.httpProxy })), (this._options.httpsProxy && { httpsProxy: this._options.httpsProxy })), (this._options.caCerts && { caCerts: this._options.caCerts })), { dsn: this._options.dsn, tunnel: this._options.tunnel, _metadata: this._options._metadata });
        if (this._options.transport) {
            return new this._options.transport(transportOptions);
        }
        var api = core_1.initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
        var url = core_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);
        this._newTransport = transports_1.makeNodeTransport({
            url: url,
            headers: transportOptions.headers,
            proxy: transportOptions.httpProxy,
            caCerts: transportOptions.caCerts,
        });
        if (dsn.protocol === 'http') {
            return new transports_1.HTTPTransport(transportOptions);
        }
        return new transports_1.HTTPSTransport(transportOptions);
    };
    return NodeBackend;
}(core_1.BaseBackend));
exports.NodeBackend = NodeBackend;
//# sourceMappingURL=backend.js.map{"version":3,"file":"backend.js","sourceRoot":"","sources":["../../src/backend.ts"],"names":[],"mappings":";;AAAA,qCAAkG;AAClG,uCAAwF;AACxF,uCAA6D;AAE7D,+CAAyE;AACzE,2CAAgF;AAGhF;;;GAGG;AACH;IAAiC,uCAAwB;IAAzD;;IAwDA,CAAC;IAvDC;;OAEG;IACH,iHAAiH;IAC1G,wCAAkB,GAAzB,UAA0B,SAAc,EAAE,IAAgB;QACxD,OAAO,2BAAmB,CAAC,oCAAqB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;IACrE,CAAC;IAED;;OAEG;IACI,sCAAgB,GAAvB,UAAwB,OAAe,EAAE,KAA+B,EAAE,IAAgB;QAAjD,sBAAA,EAAA,QAAkB,gBAAQ,CAAC,IAAI;QACtE,OAAO,2BAAmB,CAAC,+BAAgB,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC;IACrG,CAAC;IAED;;OAEG;IACO,qCAAe,GAAzB;QACE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;YACtB,6DAA6D;YAC7D,OAAO,iBAAM,eAAe,WAAE,CAAC;SAChC;QAED,IAAM,GAAG,GAAG,eAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAEvC,IAAM,gBAAgB,4FACjB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAC9B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,GACnE,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC,GACtE,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,KAChE,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EACtB,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAC5B,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,GACnC,CAAC;QAEF,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;YAC3B,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;SACtD;QAED,IAAM,GAAG,GAAG,qBAAc,CAAC,gBAAgB,CAAC,GAAG,EAAE,gBAAgB,CAAC,SAAS,EAAE,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACtG,IAAM,GAAG,GAAG,4CAAqC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;QAEvE,IAAI,CAAC,aAAa,GAAG,8BAAiB,CAAC;YACrC,GAAG,KAAA;YACH,OAAO,EAAE,gBAAgB,CAAC,OAAO;YACjC,KAAK,EAAE,gBAAgB,CAAC,SAAS;YACjC,OAAO,EAAE,gBAAgB,CAAC,OAAO;SAClC,CAAC,CAAC;QAEH,IAAI,GAAG,CAAC,QAAQ,KAAK,MAAM,EAAE;YAC3B,OAAO,IAAI,0BAAa,CAAC,gBAAgB,CAAC,CAAC;SAC5C;QACD,OAAO,IAAI,2BAAc,CAAC,gBAAgB,CAAC,CAAC;IAC9C,CAAC;IACH,kBAAC;AAAD,CAAC,AAxDD,CAAiC,kBAAW,GAwD3C;AAxDY,kCAAW","sourcesContent":["import { BaseBackend, getEnvelopeEndpointWithUrlEncodedAuth, initAPIDetails } from '@sentry/core';\nimport { Event, EventHint, Severity, Transport, TransportOptions } from '@sentry/types';\nimport { makeDsn, resolvedSyncPromise } from '@sentry/utils';\n\nimport { eventFromMessage, eventFromUnknownInput } from './eventbuilder';\nimport { HTTPSTransport, HTTPTransport, makeNodeTransport } from './transports';\nimport { NodeOptions } from './types';\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    return resolvedSyncPromise(eventFromUnknownInput(exception, hint));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    return resolvedSyncPromise(eventFromMessage(message, level, hint, this._options.attachStacktrace));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = makeDsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n      tunnel: this._options.tunnel,\n      _metadata: this._options._metadata,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n\n    const api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);\n    const url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);\n\n    this._newTransport = makeNodeTransport({\n      url,\n      headers: transportOptions.headers,\n      proxy: transportOptions.httpProxy,\n      caCerts: transportOptions.caCerts,\n    });\n\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"]}import { BaseClient, Scope } from '@sentry/core';
import { SessionFlusher } from '@sentry/hub';
import { Event, EventHint } from '@sentry/types';
import { NodeBackend } from './backend';
import { NodeOptions } from './types';
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
export declare class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
    protected _sessionFlusher: SessionFlusher | undefined;
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    constructor(options: NodeOptions);
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     *
     * @inheritdoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /** Method that initialises an instance of SessionFlusher on Client */
    initSessionFlusher(): void;
    /**
     * @inheritDoc
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
     * appropriate session aggregates bucket
     */
    protected _captureRequestSession(): void;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,KAAK,EAAe,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAGjD,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC;;;;;GAKG;AACH,qBAAa,UAAW,SAAQ,UAAU,CAAC,WAAW,EAAE,WAAW,CAAC;IAClE,SAAS,CAAC,eAAe,EAAE,cAAc,GAAG,SAAS,CAAC;IAEtD;;;OAGG;gBACgB,OAAO,EAAE,WAAW;IAgBvC;;OAEG;IAEI,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAiB5F;;OAEG;IACI,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAwBtF;;;OAGG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAKpD,sEAAsE;IAC/D,kBAAkB,IAAI,IAAI;IAYjC;;OAEG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IAQjG;;;OAGG;IACH,SAAS,CAAC,sBAAsB,IAAI,IAAI;CAOzC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
var backend_1 = require("./backend");
var flags_1 = require("./flags");
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
var NodeClient = /** @class */ (function (_super) {
    tslib_1.__extends(NodeClient, _super);
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    function NodeClient(options) {
        var _this = this;
        options._metadata = options._metadata || {};
        options._metadata.sdk = options._metadata.sdk || {
            name: 'sentry.javascript.node',
            packages: [
                {
                    name: 'npm:@sentry/node',
                    version: core_1.SDK_VERSION,
                },
            ],
            version: core_1.SDK_VERSION,
        };
        _this = _super.call(this, backend_1.NodeBackend, options) || this;
        return _this;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    NodeClient.prototype.captureException = function (exception, hint, scope) {
        // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only
        // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload
        // sent to the Server only when the `requestHandler` middleware is used
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
            var requestSession = scope.getRequestSession();
            // Necessary checks to ensure this is code block is executed only within a request
            // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage
            if (requestSession && requestSession.status === 'ok') {
                requestSession.status = 'errored';
            }
        }
        return _super.prototype.captureException.call(this, exception, hint, scope);
    };
    /**
     * @inheritDoc
     */
    NodeClient.prototype.captureEvent = function (event, hint, scope) {
        // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only
        // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload
        // sent to the Server only when the `requestHandler` middleware is used
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
            var eventType = event.type || 'exception';
            var isException = eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;
            // If the event is of type Exception, then a request session should be captured
            if (isException) {
                var requestSession = scope.getRequestSession();
                // Ensure that this is happening within the bounds of a request, and make sure not to override
                // Session Status if Errored / Crashed
                if (requestSession && requestSession.status === 'ok') {
                    requestSession.status = 'errored';
                }
            }
        }
        return _super.prototype.captureEvent.call(this, event, hint, scope);
    };
    /**
     *
     * @inheritdoc
     */
    NodeClient.prototype.close = function (timeout) {
        var _a;
        (_a = this._sessionFlusher) === null || _a === void 0 ? void 0 : _a.close();
        return _super.prototype.close.call(this, timeout);
    };
    /** Method that initialises an instance of SessionFlusher on Client */
    NodeClient.prototype.initSessionFlusher = function () {
        var _a = this._options, release = _a.release, environment = _a.environment;
        if (!release) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');
        }
        else {
            this._sessionFlusher = new hub_1.SessionFlusher(this.getTransport(), {
                release: release,
                environment: environment,
            });
        }
    };
    /**
     * @inheritDoc
     */
    NodeClient.prototype._prepareEvent = function (event, scope, hint) {
        event.platform = event.platform || 'node';
        if (this.getOptions().serverName) {
            event.server_name = this.getOptions().serverName;
        }
        return _super.prototype._prepareEvent.call(this, event, scope, hint);
    };
    /**
     * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
     * appropriate session aggregates bucket
     */
    NodeClient.prototype._captureRequestSession = function () {
        if (!this._sessionFlusher) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Discarded request mode session because autoSessionTracking option was disabled');
        }
        else {
            this._sessionFlusher.incrementSessionStatusCount();
        }
    };
    return NodeClient;
}(core_1.BaseClient));
exports.NodeClient = NodeClient;
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseClient, Scope, SDK_VERSION } from '@sentry/core';\nimport { SessionFlusher } from '@sentry/hub';\nimport { Event, EventHint } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { NodeBackend } from './backend';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { NodeOptions } from './types';\n\n/**\n * The Sentry Node SDK Client.\n *\n * @see NodeOptions for documentation on configuration options.\n * @see SentryClient for usage documentation.\n */\nexport class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n  protected _sessionFlusher: SessionFlusher | undefined;\n\n  /**\n   * Creates a new Node SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n  public constructor(options: NodeOptions) {\n    options._metadata = options._metadata || {};\n    options._metadata.sdk = options._metadata.sdk || {\n      name: 'sentry.javascript.node',\n      packages: [\n        {\n          name: 'npm:@sentry/node',\n          version: SDK_VERSION,\n        },\n      ],\n      version: SDK_VERSION,\n    };\n\n    super(NodeBackend, options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const requestSession = scope.getRequestSession();\n\n      // Necessary checks to ensure this is code block is executed only within a request\n      // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage\n      if (requestSession && requestSession.status === 'ok') {\n        requestSession.status = 'errored';\n      }\n    }\n\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const eventType = event.type || 'exception';\n      const isException =\n        eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;\n\n      // If the event is of type Exception, then a request session should be captured\n      if (isException) {\n        const requestSession = scope.getRequestSession();\n\n        // Ensure that this is happening within the bounds of a request, and make sure not to override\n        // Session Status if Errored / Crashed\n        if (requestSession && requestSession.status === 'ok') {\n          requestSession.status = 'errored';\n        }\n      }\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   *\n   * @inheritdoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    this._sessionFlusher?.close();\n    return super.close(timeout);\n  }\n\n  /** Method that initialises an instance of SessionFlusher on Client */\n  public initSessionFlusher(): void {\n    const { release, environment } = this._options;\n    if (!release) {\n      IS_DEBUG_BUILD && logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');\n    } else {\n      this._sessionFlusher = new SessionFlusher(this.getTransport(), {\n        release,\n        environment,\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    event.platform = event.platform || 'node';\n    if (this.getOptions().serverName) {\n      event.server_name = this.getOptions().serverName;\n    }\n    return super._prepareEvent(event, scope, hint);\n  }\n\n  /**\n   * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment\n   * appropriate session aggregates bucket\n   */\n  protected _captureRequestSession(): void {\n    if (!this._sessionFlusher) {\n      IS_DEBUG_BUILD && logger.warn('Discarded request mode session because autoSessionTracking option was disabled');\n    } else {\n      this._sessionFlusher.incrementSessionStatusCount();\n    }\n  }\n}\n"]}import { Event, EventHint, Exception, Severity, StackFrame } from '@sentry/types';
/**
 * Extracts stack frames from the error.stack string
 */
export declare function parseStackFrames(error: Error): StackFrame[];
/**
 * Extracts stack frames from the error and builds a Sentry Exception
 */
export declare function exceptionFromError(error: Error): Exception;
/**
 * Builds and Event from a Exception
 * @hidden
 */
export declare function eventFromUnknownInput(exception: unknown, hint?: EventHint): Event;
/**
 * Builds and Event from a Message
 * @hidden
 */
export declare function eventFromMessage(message: string, level?: Severity, hint?: EventHint, attachStacktrace?: boolean): Event;
//# sourceMappingURL=eventbuilder.d.ts.map{"version":3,"file":"eventbuilder.d.ts","sourceRoot":"","sources":["../../src/eventbuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAa,QAAQ,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAa7F;;GAEG;AACH,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,UAAU,EAAE,CAE3D;AAED;;GAEG;AACH,wBAAgB,kBAAkB,CAAC,KAAK,EAAE,KAAK,GAAG,SAAS,CAY1D;AAED;;;GAGG;AACH,wBAAgB,qBAAqB,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,KAAK,CA4CjF;AAED;;;GAGG;AACH,wBAAgB,gBAAgB,CAC9B,OAAO,EAAE,MAAM,EACf,KAAK,GAAE,QAAwB,EAC/B,IAAI,CAAC,EAAE,SAAS,EAChB,gBAAgB,CAAC,EAAE,OAAO,GACzB,KAAK,CAeP"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var hub_1 = require("@sentry/hub");
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var stack_parser_1 = require("./stack-parser");
/**
 * Extracts stack frames from the error.stack string
 */
function parseStackFrames(error) {
    return utils_1.createStackParser(stack_parser_1.nodeStackParser)(error.stack || '', 1);
}
exports.parseStackFrames = parseStackFrames;
/**
 * Extracts stack frames from the error and builds a Sentry Exception
 */
function exceptionFromError(error) {
    var exception = {
        type: error.name || error.constructor.name,
        value: error.message,
    };
    var frames = parseStackFrames(error);
    if (frames.length) {
        exception.stacktrace = { frames: frames };
    }
    return exception;
}
exports.exceptionFromError = exceptionFromError;
/**
 * Builds and Event from a Exception
 * @hidden
 */
function eventFromUnknownInput(exception, hint) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var ex = exception;
    var providedMechanism = hint && hint.data && hint.data.mechanism;
    var mechanism = providedMechanism || {
        handled: true,
        type: 'generic',
    };
    if (!utils_1.isError(exception)) {
        if (utils_1.isPlainObject(exception)) {
            // This will allow us to group events based on top-level keys
            // which is much better than creating new group when any key/value change
            var message = "Non-Error exception captured with keys: " + utils_1.extractExceptionKeysForMessage(exception);
            hub_1.getCurrentHub().configureScope(function (scope) {
                scope.setExtra('__serialized__', utils_1.normalizeToSize(exception));
            });
            ex = (hint && hint.syntheticException) || new Error(message);
            ex.message = message;
        }
        else {
            // This handles when someone does: `throw "something awesome";`
            // We use synthesized Error here so we can extract a (rough) stack trace.
            ex = (hint && hint.syntheticException) || new Error(exception);
            ex.message = exception;
        }
        mechanism.synthetic = true;
    }
    var event = {
        exception: {
            values: [exceptionFromError(ex)],
        },
    };
    utils_1.addExceptionTypeValue(event, undefined, undefined);
    utils_1.addExceptionMechanism(event, mechanism);
    return tslib_1.__assign(tslib_1.__assign({}, event), { event_id: hint && hint.event_id });
}
exports.eventFromUnknownInput = eventFromUnknownInput;
/**
 * Builds and Event from a Message
 * @hidden
 */
function eventFromMessage(message, level, hint, attachStacktrace) {
    if (level === void 0) { level = types_1.Severity.Info; }
    var event = {
        event_id: hint && hint.event_id,
        level: level,
        message: message,
    };
    if (attachStacktrace && hint && hint.syntheticException) {
        var frames_1 = parseStackFrames(hint.syntheticException);
        if (frames_1.length) {
            event.stacktrace = { frames: frames_1 };
        }
    }
    return event;
}
exports.eventFromMessage = eventFromMessage;
//# sourceMappingURL=eventbuilder.js.map{"version":3,"file":"eventbuilder.js","sourceRoot":"","sources":["../../src/eventbuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/hub';\nimport { Event, EventHint, Exception, Mechanism, Severity, StackFrame } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  createStackParser,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n} from '@sentry/utils';\n\nimport { nodeStackParser } from './stack-parser';\n\n/**\n * Extracts stack frames from the error.stack string\n */\nexport function parseStackFrames(error: Error): StackFrame[] {\n  return createStackParser(nodeStackParser)(error.stack || '', 1);\n}\n\n/**\n * Extracts stack frames from the error and builds a Sentry Exception\n */\nexport function exceptionFromError(error: Error): Exception {\n  const exception: Exception = {\n    type: error.name || error.constructor.name,\n    value: error.message,\n  };\n\n  const frames = parseStackFrames(error);\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  return exception;\n}\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromUnknownInput(exception: unknown, hint?: EventHint): Event {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let ex: unknown = exception;\n  const providedMechanism: Mechanism | undefined =\n    hint && hint.data && (hint.data as { mechanism: Mechanism }).mechanism;\n  const mechanism: Mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic',\n  };\n\n  if (!isError(exception)) {\n    if (isPlainObject(exception)) {\n      // This will allow us to group events based on top-level keys\n      // which is much better than creating new group when any key/value change\n      const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n      getCurrentHub().configureScope(scope => {\n        scope.setExtra('__serialized__', normalizeToSize(exception));\n      });\n\n      ex = (hint && hint.syntheticException) || new Error(message);\n      (ex as Error).message = message;\n    } else {\n      // This handles when someone does: `throw \"something awesome\";`\n      // We use synthesized Error here so we can extract a (rough) stack trace.\n      ex = (hint && hint.syntheticException) || new Error(exception as string);\n      (ex as Error).message = exception as string;\n    }\n    mechanism.synthetic = true;\n  }\n\n  const event = {\n    exception: {\n      values: [exceptionFromError(ex as Error)],\n    },\n  };\n\n  addExceptionTypeValue(event, undefined, undefined);\n  addExceptionMechanism(event, mechanism);\n\n  return {\n    ...event,\n    event_id: hint && hint.event_id,\n  };\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): Event {\n  const event: Event = {\n    event_id: hint && hint.event_id,\n    level,\n    message,\n  };\n\n  if (attachStacktrace && hint && hint.syntheticException) {\n    const frames = parseStackFrames(hint.syntheticException);\n    if (frames.length) {\n      event.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** Flag that is true for debug builds, false otherwise. */
exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;AAIH,2DAA2D;AAC9C,QAAA,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}/// <reference types="node" />
import { Event, ExtractedNodeRequestData } from '@sentry/types';
import * as http from 'http';
export interface ExpressRequest {
    baseUrl?: string;
    connection?: {
        remoteAddress?: string;
    };
    ip?: string;
    method?: string;
    originalUrl?: string;
    route?: {
        path: string;
        stack: [{
            name: string;
        }];
    };
    query?: {
        [key: string]: unknown;
    };
    url?: string;
    user?: {
        [key: string]: any;
    };
}
/**
 * Express-compatible tracing handler.
 * @see Exposed as `Handlers.tracingHandler`
 */
export declare function tracingHandler(): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void;
declare type TransactionNamingScheme = 'path' | 'methodPath' | 'handler';
/**
 * Normalizes data from the request object, accounting for framework differences.
 *
 * @param req The request object from which to extract data
 * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not
 * provided.
 * @returns An object containing normalized request data
 */
export declare function extractRequestData(req: {
    [key: string]: any;
}, keys?: string[]): ExtractedNodeRequestData;
/**
 * Options deciding what parts of the request to use when enhancing an event
 */
export interface ParseRequestOptions {
    ip?: boolean;
    request?: boolean | string[];
    serverName?: boolean;
    transaction?: boolean | TransactionNamingScheme;
    user?: boolean | string[];
    version?: boolean;
}
/**
 * Enriches passed event with request data.
 *
 * @param event Will be mutated and enriched with req data
 * @param req Request object
 * @param options object containing flags to enable functionality
 * @hidden
 */
export declare function parseRequest(event: Event, req: ExpressRequest, options?: ParseRequestOptions): Event;
export declare type RequestHandlerOptions = ParseRequestOptions & {
    flushTimeout?: number;
};
/**
 * Express compatible request handler.
 * @see Exposed as `Handlers.requestHandler`
 */
export declare function requestHandler(options?: RequestHandlerOptions): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void;
/** JSDoc */
interface MiddlewareError extends Error {
    status?: number | string;
    statusCode?: number | string;
    status_code?: number | string;
    output?: {
        statusCode?: number | string;
    };
}
/**
 * Express compatible error handler.
 * @see Exposed as `Handlers.errorHandler`
 */
export declare function errorHandler(options?: {
    /**
     * Callback method deciding whether error should be captured and sent to Sentry
     * @param error Captured middleware error
     */
    shouldHandleError?(error: MiddlewareError): boolean;
}): (error: MiddlewareError, req: http.IncomingMessage, res: http.ServerResponse, next: (error: MiddlewareError) => void) => void;
export {};
//# sourceMappingURL=handlers.d.ts.map{"version":3,"file":"handlers.d.ts","sourceRoot":"","sources":["../../src/handlers.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable max-lines */
/* eslint-disable @typescript-eslint/no-explicit-any */
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var cookie = require("cookie");
var domain = require("domain");
var os = require("os");
var url = require("url");
var flags_1 = require("./flags");
var sdk_1 = require("./sdk");
/**
 * Express-compatible tracing handler.
 * @see Exposed as `Handlers.tracingHandler`
 */
function tracingHandler() {
    return function sentryTracingMiddleware(req, res, next) {
        // If there is a trace header set, we extract the data from it (parentSpanId, traceId, and sampling decision)
        var traceparentData;
        if (req.headers && utils_1.isString(req.headers['sentry-trace'])) {
            traceparentData = utils_1.extractTraceparentData(req.headers['sentry-trace']);
        }
        var transaction = core_1.startTransaction(tslib_1.__assign({ name: extractExpressTransactionName(req, { path: true, method: true }), op: 'http.server' }, traceparentData), 
        // extra context passed to the tracesSampler
        { request: extractRequestData(req) });
        // We put the transaction on the scope so users can attach children to it
        core_1.getCurrentHub().configureScope(function (scope) {
            scope.setSpan(transaction);
        });
        // We also set __sentry_transaction on the response so people can grab the transaction there to add
        // spans to it later.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        res.__sentry_transaction = transaction;
        res.once('finish', function () {
            // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction
            // closes
            setImmediate(function () {
                addExpressReqToTransaction(transaction, req);
                transaction.setHttpStatus(res.statusCode);
                transaction.finish();
            });
        });
        next();
    };
}
exports.tracingHandler = tracingHandler;
/**
 * Set parameterized as transaction name e.g.: `GET /users/:id`
 * Also adds more context data on the transaction from the request
 */
function addExpressReqToTransaction(transaction, req) {
    if (!transaction)
        return;
    transaction.name = extractExpressTransactionName(req, { path: true, method: true });
    transaction.setData('url', req.originalUrl);
    transaction.setData('baseUrl', req.baseUrl);
    transaction.setData('query', req.query);
}
/**
 * Extracts complete generalized path from the request object and uses it to construct transaction name.
 *
 * eg. GET /mountpoint/user/:id
 *
 * @param req The ExpressRequest object
 * @param options What to include in the transaction name (method, path, or both)
 *
 * @returns The fully constructed transaction name
 */
function extractExpressTransactionName(req, options) {
    if (options === void 0) { options = {}; }
    var _a;
    var method = (_a = req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    var path = '';
    if (req.route) {
        path = "" + (req.baseUrl || '') + req.route.path;
    }
    else if (req.originalUrl || req.url) {
        path = utils_1.stripUrlQueryAndFragment(req.originalUrl || req.url || '');
    }
    var info = '';
    if (options.method && method) {
        info += method;
    }
    if (options.method && options.path) {
        info += ' ';
    }
    if (options.path && path) {
        info += path;
    }
    return info;
}
/** JSDoc */
function extractTransaction(req, type) {
    var _a;
    switch (type) {
        case 'path': {
            return extractExpressTransactionName(req, { path: true });
        }
        case 'handler': {
            return ((_a = req.route) === null || _a === void 0 ? void 0 : _a.stack[0].name) || '<anonymous>';
        }
        case 'methodPath':
        default: {
            return extractExpressTransactionName(req, { path: true, method: true });
        }
    }
}
/** Default user keys that'll be used to extract data from the request */
var DEFAULT_USER_KEYS = ['id', 'username', 'email'];
/** JSDoc */
function extractUserData(user, keys) {
    var extractedUser = {};
    var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_KEYS;
    attributes.forEach(function (key) {
        if (user && key in user) {
            extractedUser[key] = user[key];
        }
    });
    return extractedUser;
}
/** Default request keys that'll be used to extract data from the request */
var DEFAULT_REQUEST_KEYS = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];
/**
 * Normalizes data from the request object, accounting for framework differences.
 *
 * @param req The request object from which to extract data
 * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not
 * provided.
 * @returns An object containing normalized request data
 */
function extractRequestData(req, keys) {
    if (keys === void 0) { keys = DEFAULT_REQUEST_KEYS; }
    var requestData = {};
    // headers:
    //   node, express, nextjs: req.headers
    //   koa: req.header
    var headers = (req.headers || req.header || {});
    // method:
    //   node, express, koa, nextjs: req.method
    var method = req.method;
    // host:
    //   express: req.hostname in > 4 and req.host in < 4
    //   koa: req.host
    //   node, nextjs: req.headers.host
    var host = req.hostname || req.host || headers.host || '<no host>';
    // protocol:
    //   node, nextjs: <n/a>
    //   express, koa: req.protocol
    var protocol = req.protocol === 'https' || req.secure || (req.socket || {}).encrypted
        ? 'https'
        : 'http';
    // url (including path and query string):
    //   node, express: req.originalUrl
    //   koa, nextjs: req.url
    var originalUrl = (req.originalUrl || req.url || '');
    // absolute url
    var absoluteUrl = protocol + "://" + host + originalUrl;
    keys.forEach(function (key) {
        switch (key) {
            case 'headers':
                requestData.headers = headers;
                break;
            case 'method':
                requestData.method = method;
                break;
            case 'url':
                requestData.url = absoluteUrl;
                break;
            case 'cookies':
                // cookies:
                //   node, express, koa: req.headers.cookie
                //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                requestData.cookies = req.cookies || cookie.parse(headers.cookie || '');
                break;
            case 'query_string':
                // query string:
                //   node: req.url (raw)
                //   express, koa, nextjs: req.query
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                requestData.query_string = req.query || url.parse(originalUrl || '', false).query;
                break;
            case 'data':
                if (method === 'GET' || method === 'HEAD') {
                    break;
                }
                // body data:
                //   express, koa, nextjs: req.body
                //
                //   when using node by itself, you have to read the incoming stream(see
                //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know
                //   where they're going to store the final result, so they'll have to capture this data themselves
                if (req.body !== undefined) {
                    requestData.data = utils_1.isString(req.body) ? req.body : JSON.stringify(utils_1.normalize(req.body));
                }
                break;
            default:
                if ({}.hasOwnProperty.call(req, key)) {
                    requestData[key] = req[key];
                }
        }
    });
    return requestData;
}
exports.extractRequestData = extractRequestData;
/**
 * Enriches passed event with request data.
 *
 * @param event Will be mutated and enriched with req data
 * @param req Request object
 * @param options object containing flags to enable functionality
 * @hidden
 */
function parseRequest(event, req, options) {
    // eslint-disable-next-line no-param-reassign
    options = tslib_1.__assign({ ip: false, request: true, serverName: true, transaction: true, user: true, version: true }, options);
    if (options.version) {
        event.contexts = tslib_1.__assign(tslib_1.__assign({}, event.contexts), { runtime: {
                name: 'node',
                version: global.process.version,
            } });
    }
    if (options.request) {
        // if the option value is `true`, use the default set of keys by not passing anything to `extractRequestData()`
        var extractedRequestData = Array.isArray(options.request)
            ? extractRequestData(req, options.request)
            : extractRequestData(req);
        event.request = tslib_1.__assign(tslib_1.__assign({}, event.request), extractedRequestData);
    }
    if (options.serverName && !event.server_name) {
        event.server_name = global.process.env.SENTRY_NAME || os.hostname();
    }
    if (options.user) {
        var extractedUser = req.user && utils_1.isPlainObject(req.user) ? extractUserData(req.user, options.user) : {};
        if (Object.keys(extractedUser)) {
            event.user = tslib_1.__assign(tslib_1.__assign({}, event.user), extractedUser);
        }
    }
    // client ip:
    //   node, nextjs: req.connection.remoteAddress
    //   express, koa: req.ip
    if (options.ip) {
        var ip = req.ip || (req.connection && req.connection.remoteAddress);
        if (ip) {
            event.user = tslib_1.__assign(tslib_1.__assign({}, event.user), { ip_address: ip });
        }
    }
    if (options.transaction && !event.transaction) {
        // TODO do we even need this anymore?
        // TODO make this work for nextjs
        event.transaction = extractTransaction(req, options.transaction);
    }
    return event;
}
exports.parseRequest = parseRequest;
/**
 * Express compatible request handler.
 * @see Exposed as `Handlers.requestHandler`
 */
function requestHandler(options) {
    var currentHub = core_1.getCurrentHub();
    var client = currentHub.getClient();
    // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the
    // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode
    if (client && sdk_1.isAutoSessionTrackingEnabled(client)) {
        client.initSessionFlusher();
        // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode
        var scope = currentHub.getScope();
        if (scope && scope.getSession()) {
            scope.setSession();
        }
    }
    return function sentryRequestMiddleware(req, res, next) {
        if (options && options.flushTimeout && options.flushTimeout > 0) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            var _end_1 = res.end;
            res.end = function (chunk, encoding, cb) {
                var _this = this;
                void sdk_1.flush(options.flushTimeout)
                    .then(function () {
                    _end_1.call(_this, chunk, encoding, cb);
                })
                    .then(null, function (e) {
                    flags_1.IS_DEBUG_BUILD && utils_1.logger.error(e);
                    _end_1.call(_this, chunk, encoding, cb);
                });
            };
        }
        var local = domain.create();
        local.add(req);
        local.add(res);
        local.on('error', next);
        local.run(function () {
            var currentHub = core_1.getCurrentHub();
            currentHub.configureScope(function (scope) {
                scope.addEventProcessor(function (event) { return parseRequest(event, req, options); });
                var client = currentHub.getClient();
                if (sdk_1.isAutoSessionTrackingEnabled(client)) {
                    var scope_1 = currentHub.getScope();
                    if (scope_1) {
                        // Set `status` of `RequestSession` to Ok, at the beginning of the request
                        scope_1.setRequestSession({ status: 'ok' });
                    }
                }
            });
            res.once('finish', function () {
                var client = currentHub.getClient();
                if (sdk_1.isAutoSessionTrackingEnabled(client)) {
                    setImmediate(function () {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        if (client && client._captureRequestSession) {
                            // Calling _captureRequestSession to capture request session at the end of the request by incrementing
                            // the correct SessionAggregates bucket i.e. crashed, errored or exited
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            client._captureRequestSession();
                        }
                    });
                }
            });
            next();
        });
    };
}
exports.requestHandler = requestHandler;
/** JSDoc */
function getStatusCodeFromResponse(error) {
    var statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);
    return statusCode ? parseInt(statusCode, 10) : 500;
}
/** Returns true if response code is internal server error */
function defaultShouldHandleError(error) {
    var status = getStatusCodeFromResponse(error);
    return status >= 500;
}
/**
 * Express compatible error handler.
 * @see Exposed as `Handlers.errorHandler`
 */
function errorHandler(options) {
    return function sentryErrorMiddleware(error, _req, res, next) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var shouldHandleError = (options && options.shouldHandleError) || defaultShouldHandleError;
        if (shouldHandleError(error)) {
            core_1.withScope(function (_scope) {
                // For some reason we need to set the transaction on the scope again
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                var transaction = res.__sentry_transaction;
                if (transaction && _scope.getSpan() === undefined) {
                    _scope.setSpan(transaction);
                }
                var client = core_1.getCurrentHub().getClient();
                if (client && sdk_1.isAutoSessionTrackingEnabled(client)) {
                    // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the
                    // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only
                    // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be
                    // running in SessionAggregates mode
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    var isSessionAggregatesMode = client._sessionFlusher !== undefined;
                    if (isSessionAggregatesMode) {
                        var requestSession = _scope.getRequestSession();
                        // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a
                        // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within
                        // the bounds of a request, and if so the status is updated
                        if (requestSession && requestSession.status !== undefined) {
                            requestSession.status = 'crashed';
                        }
                    }
                }
                var eventId = core_1.captureException(error);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                res.sentry = eventId;
                next(error);
            });
            return;
        }
        next(error);
    };
}
exports.errorHandler = errorHandler;
//# sourceMappingURL=handlers.js.map{"version":3,"file":"handlers.js","sourceRoot":"","sources":["../../src/handlers.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { captureException, getCurrentHub, startTransaction, withScope } from '@sentry/core';\nimport { Event, ExtractedNodeRequestData, Span, Transaction } from '@sentry/types';\nimport {\n  extractTraceparentData,\n  isPlainObject,\n  isString,\n  logger,\n  normalize,\n  stripUrlQueryAndFragment,\n} from '@sentry/utils';\nimport * as cookie from 'cookie';\nimport * as domain from 'domain';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as url from 'url';\n\nimport { NodeClient } from './client';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { flush, isAutoSessionTrackingEnabled } from './sdk';\n\nexport interface ExpressRequest {\n  baseUrl?: string;\n  connection?: {\n    remoteAddress?: string;\n  };\n  ip?: string;\n  method?: string;\n  originalUrl?: string;\n  route?: {\n    path: string;\n    stack: [\n      {\n        name: string;\n      },\n    ];\n  };\n  query?: {\n    // It can be: undefined | string | string[] | ParsedQs | ParsedQs[] (from `qs` package), but we dont want to pull it.\n    [key: string]: unknown;\n  };\n  url?: string;\n  user?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * Express-compatible tracing handler.\n * @see Exposed as `Handlers.tracingHandler`\n */\nexport function tracingHandler(): (\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error?: any) => void,\n) => void {\n  return function sentryTracingMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    // If there is a trace header set, we extract the data from it (parentSpanId, traceId, and sampling decision)\n    let traceparentData;\n    if (req.headers && isString(req.headers['sentry-trace'])) {\n      traceparentData = extractTraceparentData(req.headers['sentry-trace']);\n    }\n\n    const transaction = startTransaction(\n      {\n        name: extractExpressTransactionName(req, { path: true, method: true }),\n        op: 'http.server',\n        ...traceparentData,\n      },\n      // extra context passed to the tracesSampler\n      { request: extractRequestData(req) },\n    );\n\n    // We put the transaction on the scope so users can attach children to it\n    getCurrentHub().configureScope(scope => {\n      scope.setSpan(transaction);\n    });\n\n    // We also set __sentry_transaction on the response so people can grab the transaction there to add\n    // spans to it later.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    (res as any).__sentry_transaction = transaction;\n\n    res.once('finish', () => {\n      // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction\n      // closes\n      setImmediate(() => {\n        addExpressReqToTransaction(transaction, req);\n        transaction.setHttpStatus(res.statusCode);\n        transaction.finish();\n      });\n    });\n\n    next();\n  };\n}\n\n/**\n * Set parameterized as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nfunction addExpressReqToTransaction(transaction: Transaction | undefined, req: ExpressRequest): void {\n  if (!transaction) return;\n  transaction.name = extractExpressTransactionName(req, { path: true, method: true });\n  transaction.setData('url', req.originalUrl);\n  transaction.setData('baseUrl', req.baseUrl);\n  transaction.setData('query', req.query);\n}\n\n/**\n * Extracts complete generalized path from the request object and uses it to construct transaction name.\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req The ExpressRequest object\n * @param options What to include in the transaction name (method, path, or both)\n *\n * @returns The fully constructed transaction name\n */\nfunction extractExpressTransactionName(\n  req: ExpressRequest,\n  options: { path?: boolean; method?: boolean } = {},\n): string {\n  const method = req.method?.toUpperCase();\n\n  let path = '';\n  if (req.route) {\n    path = `${req.baseUrl || ''}${req.route.path}`;\n  } else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let info = '';\n  if (options.method && method) {\n    info += method;\n  }\n  if (options.method && options.path) {\n    info += ' ';\n  }\n  if (options.path && path) {\n    info += path;\n  }\n\n  return info;\n}\n\ntype TransactionNamingScheme = 'path' | 'methodPath' | 'handler';\n\n/** JSDoc */\nfunction extractTransaction(req: ExpressRequest, type: boolean | TransactionNamingScheme): string {\n  switch (type) {\n    case 'path': {\n      return extractExpressTransactionName(req, { path: true });\n    }\n    case 'handler': {\n      return req.route?.stack[0].name || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      return extractExpressTransactionName(req, { path: true, method: true });\n    }\n  }\n}\n\n/** Default user keys that'll be used to extract data from the request */\nconst DEFAULT_USER_KEYS = ['id', 'username', 'email'];\n\n/** JSDoc */\nfunction extractUserData(\n  user: {\n    [key: string]: any;\n  },\n  keys: boolean | string[],\n): { [key: string]: any } {\n  const extractedUser: { [key: string]: any } = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_KEYS;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/** Default request keys that'll be used to extract data from the request */\nconst DEFAULT_REQUEST_KEYS = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\n\n/**\n * Normalizes data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not\n * provided.\n * @returns An object containing normalized request data\n */\nexport function extractRequestData(\n  req: { [key: string]: any },\n  keys: string[] = DEFAULT_REQUEST_KEYS,\n): ExtractedNodeRequestData {\n  const requestData: { [key: string]: any } = {};\n\n  // headers:\n  //   node, express, nextjs: req.headers\n  //   koa: req.header\n  const headers = (req.headers || req.header || {}) as {\n    host?: string;\n    cookie?: string;\n  };\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  const host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol =\n    req.protocol === 'https' || req.secure || ((req.socket || {}) as { encrypted?: boolean }).encrypted\n      ? 'https'\n      : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = (req.originalUrl || req.url || '') as string;\n  // absolute url\n  const absoluteUrl = `${protocol}://${host}${originalUrl}`;\n\n  keys.forEach(key => {\n    switch (key) {\n      case 'headers':\n        requestData.headers = headers;\n        break;\n      case 'method':\n        requestData.method = method;\n        break;\n      case 'url':\n        requestData.url = absoluteUrl;\n        break;\n      case 'cookies':\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.cookies = req.cookies || cookie.parse(headers.cookie || '');\n        break;\n      case 'query_string':\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.query_string = req.query || url.parse(originalUrl || '', false).query;\n        break;\n      case 'data':\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      default:\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req as { [key: string]: any })[key];\n        }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\nexport interface ParseRequestOptions {\n  ip?: boolean;\n  request?: boolean | string[];\n  serverName?: boolean;\n  transaction?: boolean | TransactionNamingScheme;\n  user?: boolean | string[];\n  version?: boolean;\n}\n\n/**\n * Enriches passed event with request data.\n *\n * @param event Will be mutated and enriched with req data\n * @param req Request object\n * @param options object containing flags to enable functionality\n * @hidden\n */\nexport function parseRequest(event: Event, req: ExpressRequest, options?: ParseRequestOptions): Event {\n  // eslint-disable-next-line no-param-reassign\n  options = {\n    ip: false,\n    request: true,\n    serverName: true,\n    transaction: true,\n    user: true,\n    version: true,\n    ...options,\n  };\n\n  if (options.version) {\n    event.contexts = {\n      ...event.contexts,\n      runtime: {\n        name: 'node',\n        version: global.process.version,\n      },\n    };\n  }\n\n  if (options.request) {\n    // if the option value is `true`, use the default set of keys by not passing anything to `extractRequestData()`\n    const extractedRequestData = Array.isArray(options.request)\n      ? extractRequestData(req, options.request)\n      : extractRequestData(req);\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (options.serverName && !event.server_name) {\n    event.server_name = global.process.env.SENTRY_NAME || os.hostname();\n  }\n\n  if (options.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, options.user) : {};\n\n    if (Object.keys(extractedUser)) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.connection.remoteAddress\n  //   express, koa: req.ip\n  if (options.ip) {\n    const ip = req.ip || (req.connection && req.connection.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (options.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, options.transaction);\n  }\n\n  return event;\n}\n\nexport type RequestHandlerOptions = ParseRequestOptions & {\n  flushTimeout?: number;\n};\n\n/**\n * Express compatible request handler.\n * @see Exposed as `Handlers.requestHandler`\n */\nexport function requestHandler(\n  options?: RequestHandlerOptions,\n): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void {\n  const currentHub = getCurrentHub();\n  const client = currentHub.getClient<NodeClient>();\n  // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the\n  // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode\n  if (client && isAutoSessionTrackingEnabled(client)) {\n    client.initSessionFlusher();\n\n    // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode\n    const scope = currentHub.getScope();\n    if (scope && scope.getSession()) {\n      scope.setSession();\n    }\n  }\n  return function sentryRequestMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    if (options && options.flushTimeout && options.flushTimeout > 0) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _end = res.end;\n      res.end = function (chunk?: any | (() => void), encoding?: string | (() => void), cb?: () => void): void {\n        void flush(options.flushTimeout)\n          .then(() => {\n            _end.call(this, chunk, encoding, cb);\n          })\n          .then(null, e => {\n            IS_DEBUG_BUILD && logger.error(e);\n            _end.call(this, chunk, encoding, cb);\n          });\n      };\n    }\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n    local.on('error', next);\n\n    local.run(() => {\n      const currentHub = getCurrentHub();\n\n      currentHub.configureScope(scope => {\n        scope.addEventProcessor((event: Event) => parseRequest(event, req, options));\n        const client = currentHub.getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          const scope = currentHub.getScope();\n          if (scope) {\n            // Set `status` of `RequestSession` to Ok, at the beginning of the request\n            scope.setRequestSession({ status: 'ok' });\n          }\n        }\n      });\n\n      res.once('finish', () => {\n        const client = currentHub.getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          setImmediate(() => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (client && (client as any)._captureRequestSession) {\n              // Calling _captureRequestSession to capture request session at the end of the request by incrementing\n              // the correct SessionAggregates bucket i.e. crashed, errored or exited\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              (client as any)._captureRequestSession();\n            }\n          });\n        }\n      });\n      next();\n    });\n  };\n}\n\n/** JSDoc */\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\n/** JSDoc */\nfunction getStatusCodeFromResponse(error: MiddlewareError): number {\n  const statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);\n  return statusCode ? parseInt(statusCode as string, 10) : 500;\n}\n\n/** Returns true if response code is internal server error */\nfunction defaultShouldHandleError(error: MiddlewareError): boolean {\n  const status = getStatusCodeFromResponse(error);\n  return status >= 500;\n}\n\n/**\n * Express compatible error handler.\n * @see Exposed as `Handlers.errorHandler`\n */\nexport function errorHandler(options?: {\n  /**\n   * Callback method deciding whether error should be captured and sent to Sentry\n   * @param error Captured middleware error\n   */\n  shouldHandleError?(error: MiddlewareError): boolean;\n}): (\n  error: MiddlewareError,\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error: MiddlewareError) => void,\n) => void {\n  return function sentryErrorMiddleware(\n    error: MiddlewareError,\n    _req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error: MiddlewareError) => void,\n  ): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const shouldHandleError = (options && options.shouldHandleError) || defaultShouldHandleError;\n\n    if (shouldHandleError(error)) {\n      withScope(_scope => {\n        // For some reason we need to set the transaction on the scope again\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const transaction = (res as any).__sentry_transaction as Span;\n        if (transaction && _scope.getSpan() === undefined) {\n          _scope.setSpan(transaction);\n        }\n\n        const client = getCurrentHub().getClient<NodeClient>();\n        if (client && isAutoSessionTrackingEnabled(client)) {\n          // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the\n          // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only\n          // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be\n          // running in SessionAggregates mode\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          const isSessionAggregatesMode = (client as any)._sessionFlusher !== undefined;\n          if (isSessionAggregatesMode) {\n            const requestSession = _scope.getRequestSession();\n            // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a\n            // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within\n            // the bounds of a request, and if so the status is updated\n            if (requestSession && requestSession.status !== undefined) {\n              requestSession.status = 'crashed';\n            }\n          }\n        }\n\n        const eventId = captureException(error);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        (res as any).sentry = eventId;\n        next(error);\n      });\n\n      return;\n    }\n\n    next(error);\n  };\n}\n"]}export { Breadcrumb, BreadcrumbHint, Request, SdkInfo, Event, EventHint, EventStatus, Exception, Response, Severity, StackFrame, Stacktrace, Thread, User, } from '@sentry/types';
export { SeverityLevel } from '@sentry/utils';
export { addGlobalEventProcessor, addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, getHubFromCarrier, getCurrentHub, Hub, makeMain, Scope, Session, startTransaction, SDK_VERSION, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/core';
export { NodeOptions } from './types';
export { NodeBackend } from './backend';
export { NodeClient } from './client';
export { defaultIntegrations, init, lastEventId, flush, close, getSentryRelease } from './sdk';
export { deepReadDirSync } from './utils';
export { SDK_NAME } from './version';
import { Integrations as CoreIntegrations } from '@sentry/core';
import * as Handlers from './handlers';
import * as NodeIntegrations from './integrations';
import * as Transports from './transports';
declare const INTEGRATIONS: {
    Console: typeof NodeIntegrations.Console;
    Http: typeof NodeIntegrations.Http;
    OnUncaughtException: typeof NodeIntegrations.OnUncaughtException;
    OnUnhandledRejection: typeof NodeIntegrations.OnUnhandledRejection;
    LinkedErrors: typeof NodeIntegrations.LinkedErrors;
    Modules: typeof NodeIntegrations.Modules;
    ContextLines: typeof NodeIntegrations.ContextLines;
    FunctionToString: typeof CoreIntegrations.FunctionToString;
    InboundFilters: typeof CoreIntegrations.InboundFilters;
};
export { INTEGRATIONS as Integrations, Transports, Handlers };
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,UAAU,EACV,cAAc,EACd,OAAO,EACP,OAAO,EACP,KAAK,EACL,SAAS,EACT,WAAW,EACX,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,UAAU,EACV,UAAU,EACV,MAAM,EACN,IAAI,GACL,MAAM,eAAe,CAAC;AAEvB,OAAO,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAE9C,OAAO,EACL,uBAAuB,EACvB,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,iBAAiB,EACjB,aAAa,EACb,GAAG,EACH,QAAQ,EACR,KAAK,EACL,OAAO,EACP,gBAAgB,EAChB,WAAW,EACX,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,cAAc,CAAC;AAEtB,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AACtC,OAAO,EAAE,mBAAmB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,KAAK,EAAE,gBAAgB,EAAE,MAAM,OAAO,CAAC;AAC/F,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAErC,OAAO,EAAE,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAIhE,OAAO,KAAK,QAAQ,MAAM,YAAY,CAAC;AACvC,OAAO,KAAK,gBAAgB,MAAM,gBAAgB,CAAC;AACnD,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAE3C,QAAA,MAAM,YAAY;;;;;;;;;;CAGjB,CAAC;AAEF,OAAO,EAAE,YAAY,IAAI,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var types_1 = require("@sentry/types");
exports.Severity = types_1.Severity;
var core_1 = require("@sentry/core");
exports.addGlobalEventProcessor = core_1.addGlobalEventProcessor;
exports.addBreadcrumb = core_1.addBreadcrumb;
exports.captureException = core_1.captureException;
exports.captureEvent = core_1.captureEvent;
exports.captureMessage = core_1.captureMessage;
exports.configureScope = core_1.configureScope;
exports.getHubFromCarrier = core_1.getHubFromCarrier;
exports.getCurrentHub = core_1.getCurrentHub;
exports.Hub = core_1.Hub;
exports.makeMain = core_1.makeMain;
exports.Scope = core_1.Scope;
exports.Session = core_1.Session;
exports.startTransaction = core_1.startTransaction;
exports.SDK_VERSION = core_1.SDK_VERSION;
exports.setContext = core_1.setContext;
exports.setExtra = core_1.setExtra;
exports.setExtras = core_1.setExtras;
exports.setTag = core_1.setTag;
exports.setTags = core_1.setTags;
exports.setUser = core_1.setUser;
exports.withScope = core_1.withScope;
var backend_1 = require("./backend");
exports.NodeBackend = backend_1.NodeBackend;
var client_1 = require("./client");
exports.NodeClient = client_1.NodeClient;
var sdk_1 = require("./sdk");
exports.defaultIntegrations = sdk_1.defaultIntegrations;
exports.init = sdk_1.init;
exports.lastEventId = sdk_1.lastEventId;
exports.flush = sdk_1.flush;
exports.close = sdk_1.close;
exports.getSentryRelease = sdk_1.getSentryRelease;
var utils_1 = require("./utils");
exports.deepReadDirSync = utils_1.deepReadDirSync;
var version_1 = require("./version");
exports.SDK_NAME = version_1.SDK_NAME;
var core_2 = require("@sentry/core");
var hub_1 = require("@sentry/hub");
var domain = require("domain");
var Handlers = require("./handlers");
exports.Handlers = Handlers;
var NodeIntegrations = require("./integrations");
var Transports = require("./transports");
exports.Transports = Transports;
var INTEGRATIONS = tslib_1.__assign(tslib_1.__assign({}, core_2.Integrations), NodeIntegrations);
exports.Integrations = INTEGRATIONS;
// We need to patch domain on the global __SENTRY__ object to make it work for node in cross-platform packages like
// @sentry/hub. If we don't do this, browser bundlers will have troubles resolving `require('domain')`.
var carrier = hub_1.getMainCarrier();
if (carrier.__SENTRY__) {
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    carrier.__SENTRY__.extensions.domain = carrier.__SENTRY__.extensions.domain || domain;
}
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;AAAA,uCAeuB;AALrB,2BAAA,QAAQ,CAAA;AASV,qCAsBsB;AArBpB,yCAAA,uBAAuB,CAAA;AACvB,+BAAA,aAAa,CAAA;AACb,kCAAA,gBAAgB,CAAA;AAChB,8BAAA,YAAY,CAAA;AACZ,gCAAA,cAAc,CAAA;AACd,gCAAA,cAAc,CAAA;AACd,mCAAA,iBAAiB,CAAA;AACjB,+BAAA,aAAa,CAAA;AACb,qBAAA,GAAG,CAAA;AACH,0BAAA,QAAQ,CAAA;AACR,uBAAA,KAAK,CAAA;AACL,yBAAA,OAAO,CAAA;AACP,kCAAA,gBAAgB,CAAA;AAChB,6BAAA,WAAW,CAAA;AACX,4BAAA,UAAU,CAAA;AACV,0BAAA,QAAQ,CAAA;AACR,2BAAA,SAAS,CAAA;AACT,wBAAA,MAAM,CAAA;AACN,yBAAA,OAAO,CAAA;AACP,yBAAA,OAAO,CAAA;AACP,2BAAA,SAAS,CAAA;AAIX,qCAAwC;AAA/B,gCAAA,WAAW,CAAA;AACpB,mCAAsC;AAA7B,8BAAA,UAAU,CAAA;AACnB,6BAA+F;AAAtF,oCAAA,mBAAmB,CAAA;AAAE,qBAAA,IAAI,CAAA;AAAE,4BAAA,WAAW,CAAA;AAAE,sBAAA,KAAK,CAAA;AAAE,sBAAA,KAAK,CAAA;AAAE,iCAAA,gBAAgB,CAAA;AAC/E,iCAA0C;AAAjC,kCAAA,eAAe,CAAA;AACxB,qCAAqC;AAA5B,6BAAA,QAAQ,CAAA;AAEjB,qCAAgE;AAChE,mCAA6C;AAC7C,+BAAiC;AAEjC,qCAAuC;AASY,4BAAQ;AAR3D,iDAAmD;AACnD,yCAA2C;AAOJ,gCAAU;AALjD,IAAM,YAAY,yCACb,mBAAgB,GAChB,gBAAgB,CACpB,CAAC;AAEuB,oCAAY;AAErC,mHAAmH;AACnH,uGAAuG;AACvG,IAAM,OAAO,GAAG,oBAAc,EAAE,CAAC;AACjC,IAAI,OAAO,CAAC,UAAU,EAAE;IACtB,OAAO,CAAC,UAAU,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC;IACpE,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,IAAI,MAAM,CAAC;CACvF","sourcesContent":["export {\n  Breadcrumb,\n  BreadcrumbHint,\n  Request,\n  SdkInfo,\n  Event,\n  EventHint,\n  EventStatus,\n  Exception,\n  Response,\n  Severity,\n  StackFrame,\n  Stacktrace,\n  Thread,\n  User,\n} from '@sentry/types';\n\nexport { SeverityLevel } from '@sentry/utils';\n\nexport {\n  addGlobalEventProcessor,\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  getHubFromCarrier,\n  getCurrentHub,\n  Hub,\n  makeMain,\n  Scope,\n  Session,\n  startTransaction,\n  SDK_VERSION,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  withScope,\n} from '@sentry/core';\n\nexport { NodeOptions } from './types';\nexport { NodeBackend } from './backend';\nexport { NodeClient } from './client';\nexport { defaultIntegrations, init, lastEventId, flush, close, getSentryRelease } from './sdk';\nexport { deepReadDirSync } from './utils';\nexport { SDK_NAME } from './version';\n\nimport { Integrations as CoreIntegrations } from '@sentry/core';\nimport { getMainCarrier } from '@sentry/hub';\nimport * as domain from 'domain';\n\nimport * as Handlers from './handlers';\nimport * as NodeIntegrations from './integrations';\nimport * as Transports from './transports';\n\nconst INTEGRATIONS = {\n  ...CoreIntegrations,\n  ...NodeIntegrations,\n};\n\nexport { INTEGRATIONS as Integrations, Transports, Handlers };\n\n// We need to patch domain on the global __SENTRY__ object to make it work for node in cross-platform packages like\n// @sentry/hub. If we don't do this, browser bundlers will have troubles resolving `require('domain')`.\nconst carrier = getMainCarrier();\nif (carrier.__SENTRY__) {\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  carrier.__SENTRY__.extensions.domain = carrier.__SENTRY__.extensions.domain || domain;\n}\n"]}import { Integration } from '@sentry/types';
/** Console module integration */
export declare class Console implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=console.d.ts.map{"version":3,"file":"console.d.ts","sourceRoot":"","sources":["../../../src/integrations/console.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAI5C,iCAAiC;AACjC,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,IAAI,IAAI;CAKzB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var util = require("util");
/** Console module integration */
var Console = /** @class */ (function () {
    function Console() {
        /**
         * @inheritDoc
         */
        this.name = Console.id;
    }
    /**
     * @inheritDoc
     */
    Console.prototype.setupOnce = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(['debug', 'info', 'warn', 'error', 'log']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var level = _c.value;
                utils_1.fill(console, level, createConsoleWrapper(level));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @inheritDoc
     */
    Console.id = 'Console';
    return Console;
}());
exports.Console = Console;
/**
 * Wrapper function that'll be used for every console level
 */
function createConsoleWrapper(level) {
    return function consoleWrapper(originalConsoleMethod) {
        var sentryLevel = utils_1.severityFromString(level);
        /* eslint-disable prefer-rest-params */
        return function () {
            if (core_1.getCurrentHub().getIntegration(Console)) {
                core_1.getCurrentHub().addBreadcrumb({
                    category: 'console',
                    level: sentryLevel,
                    message: util.format.apply(undefined, arguments),
                }, {
                    input: tslib_1.__spread(arguments),
                    level: level,
                });
            }
            originalConsoleMethod.apply(this, arguments);
        };
        /* eslint-enable prefer-rest-params */
    };
}
//# sourceMappingURL=console.js.map{"version":3,"file":"console.js","sourceRoot":"","sources":["../../../src/integrations/console.ts"],"names":[],"mappings":";;AAAA,qCAA6C;AAE7C,uCAAyD;AACzD,2BAA6B;AAE7B,iCAAiC;AACjC;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,OAAO,CAAC,EAAE,CAAC;IAUnC,CAAC;IARC;;OAEG;IACI,2BAAS,GAAhB;;;YACE,KAAoB,IAAA,KAAA,iBAAA,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA,gBAAA,4BAAE;gBAA1D,IAAM,KAAK,WAAA;gBACd,YAAI,CAAC,OAAO,EAAE,KAAK,EAAE,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;aACnD;;;;;;;;;IACH,CAAC;IAjBD;;OAEG;IACW,UAAE,GAAW,SAAS,CAAC;IAevC,cAAC;CAAA,AAnBD,IAmBC;AAnBY,0BAAO;AAqBpB;;GAEG;AACH,SAAS,oBAAoB,CAAC,KAAa;IACzC,OAAO,SAAS,cAAc,CAAC,qBAAiC;QAC9D,IAAM,WAAW,GAAG,0BAAkB,CAAC,KAAK,CAAC,CAAC;QAE9C,uCAAuC;QACvC,OAAO;YACL,IAAI,oBAAa,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;gBAC3C,oBAAa,EAAE,CAAC,aAAa,CAC3B;oBACE,QAAQ,EAAE,SAAS;oBACnB,KAAK,EAAE,WAAW;oBAClB,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,SAAS,CAAC;iBACjD,EACD;oBACE,KAAK,mBAAM,SAAS,CAAC;oBACrB,KAAK,OAAA;iBACN,CACF,CAAC;aACH;YAED,qBAAqB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QAC/C,CAAC,CAAC;QACF,sCAAsC;IACxC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Integration } from '@sentry/types';\nimport { fill, severityFromString } from '@sentry/utils';\nimport * as util from 'util';\n\n/** Console module integration */\nexport class Console implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Console';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Console.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    for (const level of ['debug', 'info', 'warn', 'error', 'log']) {\n      fill(console, level, createConsoleWrapper(level));\n    }\n  }\n}\n\n/**\n * Wrapper function that'll be used for every console level\n */\nfunction createConsoleWrapper(level: string): (originalConsoleMethod: () => void) => void {\n  return function consoleWrapper(originalConsoleMethod: () => void): () => void {\n    const sentryLevel = severityFromString(level);\n\n    /* eslint-disable prefer-rest-params */\n    return function (this: typeof console): void {\n      if (getCurrentHub().getIntegration(Console)) {\n        getCurrentHub().addBreadcrumb(\n          {\n            category: 'console',\n            level: sentryLevel,\n            message: util.format.apply(undefined, arguments),\n          },\n          {\n            input: [...arguments],\n            level,\n          },\n        );\n      }\n\n      originalConsoleMethod.apply(this, arguments);\n    };\n    /* eslint-enable prefer-rest-params */\n  };\n}\n"]}import { Event, EventProcessor, Integration, StackFrame } from '@sentry/types';
/**
 * Resets the file cache. Exists for testing purposes.
 * @hidden
 */
export declare function resetFileContentCache(): void;
interface ContextLinesOptions {
    /**
     * Sets the number of context lines for each frame when loading a file.
     * Defaults to 7.
     *
     * Set to 0 to disable loading and inclusion of source files.
     **/
    frameContextLines?: number;
}
/** Add node modules / packages to the event */
export declare class ContextLines implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    constructor(_options?: ContextLinesOptions);
    /** Get's the number of context lines to add */
    private get _contextLines();
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void;
    /** Processes an event and adds context lines */
    addSourceContext(event: Event): Promise<Event>;
    /** Adds context lines to frames */
    addSourceContextToFrames(frames: StackFrame[]): Promise<void>;
}
export {};
//# sourceMappingURL=contextlines.d.ts.map{"version":3,"file":"contextlines.d.ts","sourceRoot":"","sources":["../../../src/integrations/contextlines.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,WAAW,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAoB/E;;;GAGG;AACH,wBAAgB,qBAAqB,IAAI,IAAI,CAE5C;AAED,UAAU,mBAAmB;IAC3B;;;;;QAKI;IACJ,iBAAiB,CAAC,EAAE,MAAM,CAAC;CAC5B;AAED,+CAA+C;AAC/C,qBAAa,YAAa,YAAW,WAAW;IAW3B,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAV5C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAmB;gBAEF,QAAQ,GAAE,mBAAwB;IAEtE,+CAA+C;IAC/C,OAAO,KAAK,aAAa,GAYxB;IAED;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,GAAG,IAAI;IAInF,gDAAgD;IACnC,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;IAY3D,mCAAmC;IACtB,wBAAwB,CAAC,MAAM,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC;CAoB3E"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var fs_1 = require("fs");
var lru_map_1 = require("lru_map");
var FILE_CONTENT_CACHE = new lru_map_1.LRUMap(100);
var DEFAULT_LINES_OF_CONTEXT = 7;
// TODO: Replace with promisify when minimum supported node >= v8
function readTextFileAsync(path) {
    return new Promise(function (resolve, reject) {
        fs_1.readFile(path, 'utf8', function (err, data) {
            if (err)
                reject(err);
            else
                resolve(data);
        });
    });
}
/**
 * Resets the file cache. Exists for testing purposes.
 * @hidden
 */
function resetFileContentCache() {
    FILE_CONTENT_CACHE.clear();
}
exports.resetFileContentCache = resetFileContentCache;
/** Add node modules / packages to the event */
var ContextLines = /** @class */ (function () {
    function ContextLines(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = ContextLines.id;
    }
    Object.defineProperty(ContextLines.prototype, "_contextLines", {
        /** Get's the number of context lines to add */
        get: function () {
            var _a, _b;
            // This is only here to copy frameContextLines from init options if it hasn't
            // been set via this integrations constructor.
            //
            // TODO: Remove on next major!
            if (this._options.frameContextLines === undefined) {
                var initOptions = (_a = core_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
                // eslint-disable-next-line deprecation/deprecation
                this._options.frameContextLines = (_b = initOptions) === null || _b === void 0 ? void 0 : _b.frameContextLines;
            }
            return this._options.frameContextLines !== undefined ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ContextLines.prototype.setupOnce = function (addGlobalEventProcessor) {
        var _this = this;
        addGlobalEventProcessor(function (event) { return _this.addSourceContext(event); });
    };
    /** Processes an event and adds context lines */
    ContextLines.prototype.addSourceContext = function (event) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _c, _d, exception, e_1_1;
            var e_1, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!(this._contextLines > 0 && ((_a = event.exception) === null || _a === void 0 ? void 0 : _a.values))) return [3 /*break*/, 8];
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 6, 7, 8]);
                        _c = tslib_1.__values(event.exception.values), _d = _c.next();
                        _f.label = 2;
                    case 2:
                        if (!!_d.done) return [3 /*break*/, 5];
                        exception = _d.value;
                        if (!((_b = exception.stacktrace) === null || _b === void 0 ? void 0 : _b.frames)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.addSourceContextToFrames(exception.stacktrace.frames)];
                    case 3:
                        _f.sent();
                        _f.label = 4;
                    case 4:
                        _d = _c.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _f.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, event];
                }
            });
        });
    };
    /** Adds context lines to frames */
    ContextLines.prototype.addSourceContextToFrames = function (frames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var contextLines, frames_1, frames_1_1, frame, sourceFile, lines, e_2_1;
            var e_2, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        contextLines = this._contextLines;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        frames_1 = tslib_1.__values(frames), frames_1_1 = frames_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!frames_1_1.done) return [3 /*break*/, 5];
                        frame = frames_1_1.value;
                        if (!(frame.filename && frame.context_line === undefined)) return [3 /*break*/, 4];
                        return [4 /*yield*/, _readSourceFile(frame.filename)];
                    case 3:
                        sourceFile = _b.sent();
                        if (sourceFile) {
                            try {
                                lines = sourceFile.split('\n');
                                utils_1.addContextToFrame(lines, frame, contextLines);
                            }
                            catch (e) {
                                // anomaly, being defensive in case
                                // unlikely to ever happen in practice but can definitely happen in theory
                            }
                        }
                        _b.label = 4;
                    case 4:
                        frames_1_1 = frames_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (frames_1_1 && !frames_1_1.done && (_a = frames_1.return)) _a.call(frames_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @inheritDoc
     */
    ContextLines.id = 'ContextLines';
    return ContextLines;
}());
exports.ContextLines = ContextLines;
/**
 * Reads file contents and caches them in a global LRU cache.
 *
 * @param filename filepath to read content from.
 */
function _readSourceFile(filename) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var cachedFile, content, _1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cachedFile = FILE_CONTENT_CACHE.get(filename);
                    // We have a cache hit
                    if (cachedFile !== undefined) {
                        return [2 /*return*/, cachedFile];
                    }
                    content = null;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, readTextFileAsync(filename)];
                case 2:
                    content = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    _1 = _a.sent();
                    return [3 /*break*/, 4];
                case 4:
                    FILE_CONTENT_CACHE.set(filename, content);
                    return [2 /*return*/, content];
            }
        });
    });
}
//# sourceMappingURL=contextlines.js.map{"version":3,"file":"contextlines.js","sourceRoot":"","sources":["../../../src/integrations/contextlines.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Event, EventProcessor, Integration, StackFrame } from '@sentry/types';\nimport { addContextToFrame } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nimport { NodeClient } from '../client';\n\nconst FILE_CONTENT_CACHE = new LRUMap<string, string | null>(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\ninterface ContextLinesOptions {\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   * Defaults to 7.\n   *\n   * Set to 0 to disable loading and inclusion of source files.\n   **/\n  frameContextLines?: number;\n}\n\n/** Add node modules / packages to the event */\nexport class ContextLines implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'ContextLines';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = ContextLines.id;\n\n  public constructor(private readonly _options: ContextLinesOptions = {}) {}\n\n  /** Get's the number of context lines to add */\n  private get _contextLines(): number {\n    // This is only here to copy frameContextLines from init options if it hasn't\n    // been set via this integrations constructor.\n    //\n    // TODO: Remove on next major!\n    if (this._options.frameContextLines === undefined) {\n      const initOptions = getCurrentHub().getClient<NodeClient>()?.getOptions();\n      // eslint-disable-next-line deprecation/deprecation\n      this._options.frameContextLines = initOptions?.frameContextLines;\n    }\n\n    return this._options.frameContextLines !== undefined ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void {\n    addGlobalEventProcessor(event => this.addSourceContext(event));\n  }\n\n  /** Processes an event and adds context lines */\n  public async addSourceContext(event: Event): Promise<Event> {\n    if (this._contextLines > 0 && event.exception?.values) {\n      for (const exception of event.exception.values) {\n        if (exception.stacktrace?.frames) {\n          await this.addSourceContextToFrames(exception.stacktrace.frames);\n        }\n      }\n    }\n\n    return event;\n  }\n\n  /** Adds context lines to frames */\n  public async addSourceContextToFrames(frames: StackFrame[]): Promise<void> {\n    const contextLines = this._contextLines;\n\n    for (const frame of frames) {\n      // Only add context if we have a filename and it hasn't already been added\n      if (frame.filename && frame.context_line === undefined) {\n        const sourceFile = await _readSourceFile(frame.filename);\n\n        if (sourceFile) {\n          try {\n            const lines = sourceFile.split('\\n');\n            addContextToFrame(lines, frame, contextLines);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Reads file contents and caches them in a global LRU cache.\n *\n * @param filename filepath to read content from.\n */\nasync function _readSourceFile(filename: string): Promise<string | null> {\n  const cachedFile = FILE_CONTENT_CACHE.get(filename);\n  // We have a cache hit\n  if (cachedFile !== undefined) {\n    return cachedFile;\n  }\n\n  let content: string | null = null;\n  try {\n    content = await readTextFileAsync(filename);\n  } catch (_) {\n    //\n  }\n\n  FILE_CONTENT_CACHE.set(filename, content);\n  return content;\n}\n"]}import { Integration } from '@sentry/types';
/** http module integration */
export declare class Http implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    private readonly _breadcrumbs;
    /**
     * @inheritDoc
     */
    private readonly _tracing;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        breadcrumbs?: boolean;
        tracing?: boolean;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/integrations/http.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAQ,MAAM,eAAe,CAAC;AAiBlD,8BAA8B;AAC9B,qBAAa,IAAK,YAAW,WAAW;IACtC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAU;IAElC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAW;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAU;IAEvC;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAU;IAEnC;;OAEG;gBACgB,OAAO,GAAE;QAAE,WAAW,CAAC,EAAE,OAAO,CAAC;QAAC,OAAO,CAAC,EAAE,OAAO,CAAA;KAAO;IAK7E;;OAEG;IACI,SAAS,IAAI,IAAI;CAuBzB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var flags_1 = require("../flags");
var http_1 = require("./utils/http");
var NODE_VERSION = utils_1.parseSemver(process.versions.node);
/** http module integration */
var Http = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function Http(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Http.id;
        this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
        this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;
    }
    /**
     * @inheritDoc
     */
    Http.prototype.setupOnce = function () {
        // No need to instrument if we don't want to track anything
        if (!this._breadcrumbs && !this._tracing) {
            return;
        }
        var wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var httpModule = require('http');
        utils_1.fill(httpModule, 'get', wrappedHandlerMaker);
        utils_1.fill(httpModule, 'request', wrappedHandlerMaker);
        // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.
        // If we do, we'd get double breadcrumbs and double spans for `https` calls.
        // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.
        if (NODE_VERSION.major && NODE_VERSION.major > 8) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            var httpsModule = require('https');
            utils_1.fill(httpsModule, 'get', wrappedHandlerMaker);
            utils_1.fill(httpsModule, 'request', wrappedHandlerMaker);
        }
    };
    /**
     * @inheritDoc
     */
    Http.id = 'Http';
    return Http;
}());
exports.Http = Http;
/**
 * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`
 * and `https` modules. (NB: Not a typo - this is a creator^2!)
 *
 * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs
 * @param tracingEnabled Whether or not to record outgoing requests as tracing spans
 *
 * @returns A function which accepts the exiting handler and returns a wrapped handler
 */
function _createWrappedRequestMethodFactory(breadcrumbsEnabled, tracingEnabled) {
    return function wrappedRequestMethodFactory(originalRequestMethod) {
        return function wrappedMethod() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var httpModule = this;
            var requestArgs = http_1.normalizeRequestArgs(this, args);
            var requestOptions = requestArgs[0];
            var requestUrl = http_1.extractUrl(requestOptions);
            // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method
            if (http_1.isSentryRequest(requestUrl)) {
                return originalRequestMethod.apply(httpModule, requestArgs);
            }
            var span;
            var parentSpan;
            var scope = core_1.getCurrentHub().getScope();
            if (scope && tracingEnabled) {
                parentSpan = scope.getSpan();
                if (parentSpan) {
                    span = parentSpan.startChild({
                        description: (requestOptions.method || 'GET') + " " + requestUrl,
                        op: 'http.client',
                    });
                    var sentryTraceHeader = span.toTraceparent();
                    flags_1.IS_DEBUG_BUILD &&
                        utils_1.logger.log("[Tracing] Adding sentry-trace header " + sentryTraceHeader + " to outgoing request to " + requestUrl + ": ");
                    requestOptions.headers = tslib_1.__assign(tslib_1.__assign({}, requestOptions.headers), { 'sentry-trace': sentryTraceHeader });
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            return originalRequestMethod
                .apply(httpModule, requestArgs)
                .once('response', function (res) {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var req = this;
                if (breadcrumbsEnabled) {
                    addRequestBreadcrumb('response', requestUrl, req, res);
                }
                if (tracingEnabled && span) {
                    if (res.statusCode) {
                        span.setHttpStatus(res.statusCode);
                    }
                    span.description = http_1.cleanSpanDescription(span.description, requestOptions, req);
                    span.finish();
                }
            })
                .once('error', function () {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var req = this;
                if (breadcrumbsEnabled) {
                    addRequestBreadcrumb('error', requestUrl, req);
                }
                if (tracingEnabled && span) {
                    span.setHttpStatus(500);
                    span.description = http_1.cleanSpanDescription(span.description, requestOptions, req);
                    span.finish();
                }
            });
        };
    };
}
/**
 * Captures Breadcrumb based on provided request/response pair
 */
function addRequestBreadcrumb(event, url, req, res) {
    if (!core_1.getCurrentHub().getIntegration(Http)) {
        return;
    }
    core_1.getCurrentHub().addBreadcrumb({
        category: 'http',
        data: {
            method: req.method,
            status_code: res && res.statusCode,
            url: url,
        },
        type: 'http',
    }, {
        event: event,
        request: req,
        response: res,
    });
}
//# sourceMappingURL=http.js.map{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../src/integrations/http.ts"],"names":[],"mappings":";;AAAA,qCAA6C;AAE7C,uCAA0D;AAI1D,kCAA0C;AAC1C,qCAOsB;AAEtB,IAAM,YAAY,GAAG,mBAAW,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAExD,8BAA8B;AAC9B;IAqBE;;OAEG;IACH,cAAmB,OAA0D;QAA1D,wBAAA,EAAA,YAA0D;QAlB7E;;WAEG;QACI,SAAI,GAAW,IAAI,CAAC,EAAE,CAAC;QAgB5B,IAAI,CAAC,YAAY,GAAG,OAAO,OAAO,CAAC,WAAW,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC;QAC5F,IAAI,CAAC,QAAQ,GAAG,OAAO,OAAO,CAAC,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;IACnF,CAAC;IAED;;OAEG;IACI,wBAAS,GAAhB;QACE,2DAA2D;QAC3D,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YACxC,OAAO;SACR;QAED,IAAM,mBAAmB,GAAG,kCAAkC,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEjG,8DAA8D;QAC9D,IAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;QACnC,YAAI,CAAC,UAAU,EAAE,KAAK,EAAE,mBAAmB,CAAC,CAAC;QAC7C,YAAI,CAAC,UAAU,EAAE,SAAS,EAAE,mBAAmB,CAAC,CAAC;QAEjD,0FAA0F;QAC1F,4EAA4E;QAC5E,mGAAmG;QACnG,IAAI,YAAY,CAAC,KAAK,IAAI,YAAY,CAAC,KAAK,GAAG,CAAC,EAAE;YAChD,8DAA8D;YAC9D,IAAM,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;YACrC,YAAI,CAAC,WAAW,EAAE,KAAK,EAAE,mBAAmB,CAAC,CAAC;YAC9C,YAAI,CAAC,WAAW,EAAE,SAAS,EAAE,mBAAmB,CAAC,CAAC;SACnD;IACH,CAAC;IArDD;;OAEG;IACW,OAAE,GAAW,MAAM,CAAC;IAmDpC,WAAC;CAAA,AAvDD,IAuDC;AAvDY,oBAAI;AA8DjB;;;;;;;;GAQG;AACH,SAAS,kCAAkC,CACzC,kBAA2B,EAC3B,cAAuB;IAEvB,OAAO,SAAS,2BAA2B,CAAC,qBAA4C;QACtF,OAAO,SAAS,aAAa;YAAmC,cAA0B;iBAA1B,UAA0B,EAA1B,qBAA0B,EAA1B,IAA0B;gBAA1B,yBAA0B;;YACxF,4DAA4D;YAC5D,IAAM,UAAU,GAAG,IAAI,CAAC;YAExB,IAAM,WAAW,GAAG,2BAAoB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACrD,IAAM,cAAc,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;YACtC,IAAM,UAAU,GAAG,iBAAU,CAAC,cAAc,CAAC,CAAC;YAE9C,6GAA6G;YAC7G,IAAI,sBAAe,CAAC,UAAU,CAAC,EAAE;gBAC/B,OAAO,qBAAqB,CAAC,KAAK,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;aAC7D;YAED,IAAI,IAAsB,CAAC;YAC3B,IAAI,UAA4B,CAAC;YAEjC,IAAM,KAAK,GAAG,oBAAa,EAAE,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAI,KAAK,IAAI,cAAc,EAAE;gBAC3B,UAAU,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC;gBAC7B,IAAI,UAAU,EAAE;oBACd,IAAI,GAAG,UAAU,CAAC,UAAU,CAAC;wBAC3B,WAAW,EAAE,CAAG,cAAc,CAAC,MAAM,IAAI,KAAK,UAAI,UAAY;wBAC9D,EAAE,EAAE,aAAa;qBAClB,CAAC,CAAC;oBAEH,IAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;oBAC/C,sBAAc;wBACZ,cAAM,CAAC,GAAG,CACR,0CAAwC,iBAAiB,gCAA2B,UAAU,OAAI,CACnG,CAAC;oBACJ,cAAc,CAAC,OAAO,yCAAQ,cAAc,CAAC,OAAO,KAAE,cAAc,EAAE,iBAAiB,GAAE,CAAC;iBAC3F;aACF;YAED,sEAAsE;YACtE,OAAO,qBAAqB;iBACzB,KAAK,CAAC,UAAU,EAAE,WAAW,CAAC;iBAC9B,IAAI,CAAC,UAAU,EAAE,UAAoC,GAAyB;gBAC7E,4DAA4D;gBAC5D,IAAM,GAAG,GAAG,IAAI,CAAC;gBACjB,IAAI,kBAAkB,EAAE;oBACtB,oBAAoB,CAAC,UAAU,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;iBACxD;gBACD,IAAI,cAAc,IAAI,IAAI,EAAE;oBAC1B,IAAI,GAAG,CAAC,UAAU,EAAE;wBAClB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;qBACpC;oBACD,IAAI,CAAC,WAAW,GAAG,2BAAoB,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,EAAE,GAAG,CAAC,CAAC;oBAC/E,IAAI,CAAC,MAAM,EAAE,CAAC;iBACf;YACH,CAAC,CAAC;iBACD,IAAI,CAAC,OAAO,EAAE;gBACb,4DAA4D;gBAC5D,IAAM,GAAG,GAAG,IAAI,CAAC;gBAEjB,IAAI,kBAAkB,EAAE;oBACtB,oBAAoB,CAAC,OAAO,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;iBAChD;gBACD,IAAI,cAAc,IAAI,IAAI,EAAE;oBAC1B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;oBACxB,IAAI,CAAC,WAAW,GAAG,2BAAoB,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,EAAE,GAAG,CAAC,CAAC;oBAC/E,IAAI,CAAC,MAAM,EAAE,CAAC;iBACf;YACH,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,SAAS,oBAAoB,CAAC,KAAa,EAAE,GAAW,EAAE,GAAuB,EAAE,GAA0B;IAC3G,IAAI,CAAC,oBAAa,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO;KACR;IAED,oBAAa,EAAE,CAAC,aAAa,CAC3B;QACE,QAAQ,EAAE,MAAM;QAChB,IAAI,EAAE;YACJ,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,WAAW,EAAE,GAAG,IAAI,GAAG,CAAC,UAAU;YAClC,GAAG,KAAA;SACJ;QACD,IAAI,EAAE,MAAM;KACb,EACD;QACE,KAAK,OAAA;QACL,OAAO,EAAE,GAAG;QACZ,QAAQ,EAAE,GAAG;KACd,CACF,CAAC;AACJ,CAAC","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Integration, Span } from '@sentry/types';\nimport { fill, logger, parseSemver } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\n\nimport { IS_DEBUG_BUILD } from '../flags';\nimport {\n  cleanSpanDescription,\n  extractUrl,\n  isSentryRequest,\n  normalizeRequestArgs,\n  RequestMethod,\n  RequestMethodArgs,\n} from './utils/http';\n\nconst NODE_VERSION = parseSemver(process.versions.node);\n\n/** http module integration */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Http';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Http.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _breadcrumbs: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _tracing: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { breadcrumbs?: boolean; tracing?: boolean } = {}) {\n    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;\n    this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    // No need to instrument if we don't want to track anything\n    if (!this._breadcrumbs && !this._tracing) {\n      return;\n    }\n\n    const wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const httpModule = require('http');\n    fill(httpModule, 'get', wrappedHandlerMaker);\n    fill(httpModule, 'request', wrappedHandlerMaker);\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // If we do, we'd get double breadcrumbs and double spans for `https` calls.\n    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.\n    if (NODE_VERSION.major && NODE_VERSION.major > 8) {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const httpsModule = require('https');\n      fill(httpsModule, 'get', wrappedHandlerMaker);\n      fill(httpsModule, 'request', wrappedHandlerMaker);\n    }\n  }\n}\n\n// for ease of reading below\ntype OriginalRequestMethod = RequestMethod;\ntype WrappedRequestMethod = RequestMethod;\ntype WrappedRequestMethodFactory = (original: OriginalRequestMethod) => WrappedRequestMethod;\n\n/**\n * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`\n * and `https` modules. (NB: Not a typo - this is a creator^2!)\n *\n * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs\n * @param tracingEnabled Whether or not to record outgoing requests as tracing spans\n *\n * @returns A function which accepts the exiting handler and returns a wrapped handler\n */\nfunction _createWrappedRequestMethodFactory(\n  breadcrumbsEnabled: boolean,\n  tracingEnabled: boolean,\n): WrappedRequestMethodFactory {\n  return function wrappedRequestMethodFactory(originalRequestMethod: OriginalRequestMethod): WrappedRequestMethod {\n    return function wrappedMethod(this: typeof http | typeof https, ...args: RequestMethodArgs): http.ClientRequest {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const httpModule = this;\n\n      const requestArgs = normalizeRequestArgs(this, args);\n      const requestOptions = requestArgs[0];\n      const requestUrl = extractUrl(requestOptions);\n\n      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method\n      if (isSentryRequest(requestUrl)) {\n        return originalRequestMethod.apply(httpModule, requestArgs);\n      }\n\n      let span: Span | undefined;\n      let parentSpan: Span | undefined;\n\n      const scope = getCurrentHub().getScope();\n      if (scope && tracingEnabled) {\n        parentSpan = scope.getSpan();\n        if (parentSpan) {\n          span = parentSpan.startChild({\n            description: `${requestOptions.method || 'GET'} ${requestUrl}`,\n            op: 'http.client',\n          });\n\n          const sentryTraceHeader = span.toTraceparent();\n          IS_DEBUG_BUILD &&\n            logger.log(\n              `[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to ${requestUrl}: `,\n            );\n          requestOptions.headers = { ...requestOptions.headers, 'sentry-trace': sentryTraceHeader };\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalRequestMethod\n        .apply(httpModule, requestArgs)\n        .once('response', function (this: http.ClientRequest, res: http.IncomingMessage): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('response', requestUrl, req, res);\n          }\n          if (tracingEnabled && span) {\n            if (res.statusCode) {\n              span.setHttpStatus(res.statusCode);\n            }\n            span.description = cleanSpanDescription(span.description, requestOptions, req);\n            span.finish();\n          }\n        })\n        .once('error', function (this: http.ClientRequest): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('error', requestUrl, req);\n          }\n          if (tracingEnabled && span) {\n            span.setHttpStatus(500);\n            span.description = cleanSpanDescription(span.description, requestOptions, req);\n            span.finish();\n          }\n        });\n    };\n  };\n}\n\n/**\n * Captures Breadcrumb based on provided request/response pair\n */\nfunction addRequestBreadcrumb(event: string, url: string, req: http.ClientRequest, res?: http.IncomingMessage): void {\n  if (!getCurrentHub().getIntegration(Http)) {\n    return;\n  }\n\n  getCurrentHub().addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        method: req.method,\n        status_code: res && res.statusCode,\n        url,\n      },\n      type: 'http',\n    },\n    {\n      event,\n      request: req,\n      response: res,\n    },\n  );\n}\n"]}export { Console } from './console';
export { Http } from './http';
export { OnUncaughtException } from './onuncaughtexception';
export { OnUnhandledRejection } from './onunhandledrejection';
export { LinkedErrors } from './linkederrors';
export { Modules } from './modules';
export { ContextLines } from './contextlines';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var console_1 = require("./console");
exports.Console = console_1.Console;
var http_1 = require("./http");
exports.Http = http_1.Http;
var onuncaughtexception_1 = require("./onuncaughtexception");
exports.OnUncaughtException = onuncaughtexception_1.OnUncaughtException;
var onunhandledrejection_1 = require("./onunhandledrejection");
exports.OnUnhandledRejection = onunhandledrejection_1.OnUnhandledRejection;
var linkederrors_1 = require("./linkederrors");
exports.LinkedErrors = linkederrors_1.LinkedErrors;
var modules_1 = require("./modules");
exports.Modules = modules_1.Modules;
var contextlines_1 = require("./contextlines");
exports.ContextLines = contextlines_1.ContextLines;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":";AAAA,qCAAoC;AAA3B,4BAAA,OAAO,CAAA;AAChB,+BAA8B;AAArB,sBAAA,IAAI,CAAA;AACb,6DAA4D;AAAnD,oDAAA,mBAAmB,CAAA;AAC5B,+DAA8D;AAArD,sDAAA,oBAAoB,CAAA;AAC7B,+CAA8C;AAArC,sCAAA,YAAY,CAAA;AACrB,qCAAoC;AAA3B,4BAAA,OAAO,CAAA;AAChB,+CAA8C;AAArC,sCAAA,YAAY,CAAA","sourcesContent":["export { Console } from './console';\nexport { Http } from './http';\nexport { OnUncaughtException } from './onuncaughtexception';\nexport { OnUnhandledRejection } from './onunhandledrejection';\nexport { LinkedErrors } from './linkederrors';\nexport { Modules } from './modules';\nexport { ContextLines } from './contextlines';\n"]}import { Integration } from '@sentry/types';
/** Adds SDK info to an event. */
export declare class LinkedErrors implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    readonly name: string;
    /**
     * @inheritDoc
     */
    private readonly _key;
    /**
     * @inheritDoc
     */
    private readonly _limit;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        key?: string;
        limit?: number;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @inheritDoc
     */
    private _handler;
    /**
     * @inheritDoc
     */
    private _walkErrorTree;
}
//# sourceMappingURL=linkederrors.d.ts.map{"version":3,"file":"linkederrors.d.ts","sourceRoot":"","sources":["../../../src/integrations/linkederrors.ts"],"names":[],"mappings":"AACA,OAAO,EAA8C,WAAW,EAAE,MAAM,eAAe,CAAC;AASxF,iCAAiC;AACjC,qBAAa,YAAa,YAAW,WAAW;IAC9C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACH,SAAgB,IAAI,EAAE,MAAM,CAAmB;IAE/C;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAS;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAS;IAEhC;;OAEG;gBACgB,OAAO,GAAE;QAAE,GAAG,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAO;IAKjE;;OAEG;IACI,SAAS,IAAI,IAAI;IAWxB;;OAEG;IACH,OAAO,CAAC,QAAQ;IAmBhB;;OAEG;YACW,cAAc;CAsB7B"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var eventbuilder_1 = require("../eventbuilder");
var contextlines_1 = require("./contextlines");
var DEFAULT_KEY = 'cause';
var DEFAULT_LIMIT = 5;
/** Adds SDK info to an event. */
var LinkedErrors = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function LinkedErrors(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = LinkedErrors.id;
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
    }
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype.setupOnce = function () {
        core_1.addGlobalEventProcessor(function (event, hint) {
            var self = core_1.getCurrentHub().getIntegration(LinkedErrors);
            if (self) {
                var handler = self._handler && self._handler.bind(self);
                return typeof handler === 'function' ? handler(event, hint) : event;
            }
            return event;
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype._handler = function (event, hint) {
        var _this = this;
        if (!event.exception || !event.exception.values || !hint || !utils_1.isInstanceOf(hint.originalException, Error)) {
            return utils_1.resolvedSyncPromise(event);
        }
        return new utils_1.SyncPromise(function (resolve) {
            void _this._walkErrorTree(hint.originalException, _this._key)
                .then(function (linkedErrors) {
                if (event && event.exception && event.exception.values) {
                    event.exception.values = tslib_1.__spread(linkedErrors, event.exception.values);
                }
                resolve(event);
            })
                .then(null, function () {
                resolve(event);
            });
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype._walkErrorTree = function (error, key, stack) {
        if (stack === void 0) { stack = []; }
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var exception, contextLines;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!utils_1.isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
                            return [2 /*return*/, Promise.resolve(stack)];
                        }
                        exception = eventbuilder_1.exceptionFromError(error[key]);
                        contextLines = core_1.getCurrentHub().getIntegration(contextlines_1.ContextLines);
                        if (!(contextLines && ((_a = exception.stacktrace) === null || _a === void 0 ? void 0 : _a.frames))) return [3 /*break*/, 2];
                        return [4 /*yield*/, contextLines.addSourceContextToFrames(exception.stacktrace.frames)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                            void _this._walkErrorTree(error[key], key, tslib_1.__spread([exception], stack))
                                .then(resolve)
                                .then(null, function () {
                                reject();
                            });
                        })];
                }
            });
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.id = 'LinkedErrors';
    return LinkedErrors;
}());
exports.LinkedErrors = LinkedErrors;
//# sourceMappingURL=linkederrors.js.map{"version":3,"file":"linkederrors.js","sourceRoot":"","sources":["../../../src/integrations/linkederrors.ts"],"names":[],"mappings":"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","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Exception, ExtendedError, Integration } from '@sentry/types';\nimport { isInstanceOf, resolvedSyncPromise, SyncPromise } from '@sentry/utils';\n\nimport { exceptionFromError } from '../eventbuilder';\nimport { ContextLines } from './contextlines';\n\nconst DEFAULT_KEY = 'cause';\nconst DEFAULT_LIMIT = 5;\n\n/** Adds SDK info to an event. */\nexport class LinkedErrors implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'LinkedErrors';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string = LinkedErrors.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _key: string;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _limit: number;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { key?: string; limit?: number } = {}) {\n    this._key = options.key || DEFAULT_KEY;\n    this._limit = options.limit || DEFAULT_LIMIT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    addGlobalEventProcessor((event: Event, hint?: EventHint) => {\n      const self = getCurrentHub().getIntegration(LinkedErrors);\n      if (self) {\n        const handler = self._handler && self._handler.bind(self);\n        return typeof handler === 'function' ? handler(event, hint) : event;\n      }\n      return event;\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  private _handler(event: Event, hint?: EventHint): PromiseLike<Event> {\n    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n      return resolvedSyncPromise(event);\n    }\n\n    return new SyncPromise<Event>(resolve => {\n      void this._walkErrorTree(hint.originalException as Error, this._key)\n        .then((linkedErrors: Exception[]) => {\n          if (event && event.exception && event.exception.values) {\n            event.exception.values = [...linkedErrors, ...event.exception.values];\n          }\n          resolve(event);\n        })\n        .then(null, () => {\n          resolve(event);\n        });\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  private async _walkErrorTree(error: ExtendedError, key: string, stack: Exception[] = []): Promise<Exception[]> {\n    if (!isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {\n      return Promise.resolve(stack);\n    }\n\n    const exception = exceptionFromError(error[key]);\n\n    // If the ContextLines integration is enabled, we add source code context to linked errors\n    // because we can't guarantee the order that integrations are run.\n    const contextLines = getCurrentHub().getIntegration(ContextLines);\n    if (contextLines && exception.stacktrace?.frames) {\n      await contextLines.addSourceContextToFrames(exception.stacktrace.frames);\n    }\n\n    return new Promise<Exception[]>((resolve, reject) => {\n      void this._walkErrorTree(error[key], key, [exception, ...stack])\n        .then(resolve)\n        .then(null, () => {\n          reject();\n        });\n    });\n  }\n}\n"]}import { EventProcessor, Hub, Integration } from '@sentry/types';
/** Add node modules / packages to the event */
export declare class Modules implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    private _getModules;
}
//# sourceMappingURL=modules.d.ts.map{"version":3,"file":"modules.d.ts","sourceRoot":"","sources":["../../../src/integrations/modules.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAmEjE,+CAA+C;AAC/C,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;IAY7G,kGAAkG;IAClG,OAAO,CAAC,WAAW;CAMpB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var path_1 = require("path");
var moduleCache;
/** Extract information about paths */
function getPaths() {
    try {
        return require.cache ? Object.keys(require.cache) : [];
    }
    catch (e) {
        return [];
    }
}
/** Extract information about package.json modules */
function collectModules() {
    var mainPaths = (require.main && require.main.paths) || [];
    var paths = getPaths();
    var infos = {};
    var seen = {};
    paths.forEach(function (path) {
        var dir = path;
        /** Traverse directories upward in the search of package.json file */
        var updir = function () {
            var orig = dir;
            dir = path_1.dirname(orig);
            if (!dir || orig === dir || seen[orig]) {
                return undefined;
            }
            if (mainPaths.indexOf(dir) < 0) {
                return updir();
            }
            var pkgfile = path_1.join(orig, 'package.json');
            seen[orig] = true;
            if (!fs_1.existsSync(pkgfile)) {
                return updir();
            }
            try {
                var info = JSON.parse(fs_1.readFileSync(pkgfile, 'utf8'));
                infos[info.name] = info.version;
            }
            catch (_oO) {
                // no-empty
            }
        };
        updir();
    });
    return infos;
}
/** Add node modules / packages to the event */
var Modules = /** @class */ (function () {
    function Modules() {
        /**
         * @inheritDoc
         */
        this.name = Modules.id;
    }
    /**
     * @inheritDoc
     */
    Modules.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        var _this = this;
        addGlobalEventProcessor(function (event) {
            if (!getCurrentHub().getIntegration(Modules)) {
                return event;
            }
            return tslib_1.__assign(tslib_1.__assign({}, event), { modules: _this._getModules() });
        });
    };
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    Modules.prototype._getModules = function () {
        if (!moduleCache) {
            moduleCache = collectModules();
        }
        return moduleCache;
    };
    /**
     * @inheritDoc
     */
    Modules.id = 'Modules';
    return Modules;
}());
exports.Modules = Modules;
//# sourceMappingURL=modules.js.map{"version":3,"file":"modules.js","sourceRoot":"","sources":["../../../src/integrations/modules.ts"],"names":[],"mappings":";;AACA,yBAA8C;AAC9C,6BAAqC;AAErC,IAAI,WAAsC,CAAC;AAE3C,sCAAsC;AACtC,SAAS,QAAQ;IACf,IAAI;QACF,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAgC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;KACnF;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,EAAE,CAAC;KACX;AACH,CAAC;AAED,qDAAqD;AACrD,SAAS,cAAc;IAGrB,IAAM,SAAS,GAAG,CAAC,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IAC7D,IAAM,KAAK,GAAG,QAAQ,EAAE,CAAC;IACzB,IAAM,KAAK,GAEP,EAAE,CAAC;IACP,IAAM,IAAI,GAEN,EAAE,CAAC;IAEP,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;QAChB,IAAI,GAAG,GAAG,IAAI,CAAC;QAEf,qEAAqE;QACrE,IAAM,KAAK,GAAG;YACZ,IAAM,IAAI,GAAG,GAAG,CAAC;YACjB,GAAG,GAAG,cAAO,CAAC,IAAI,CAAC,CAAC;YAEpB,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE;gBACtC,OAAO,SAAS,CAAC;aAClB;YACD,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBAC9B,OAAO,KAAK,EAAE,CAAC;aAChB;YAED,IAAM,OAAO,GAAG,WAAI,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;YAC3C,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAElB,IAAI,CAAC,eAAU,CAAC,OAAO,CAAC,EAAE;gBACxB,OAAO,KAAK,EAAE,CAAC;aAChB;YAED,IAAI;gBACF,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,iBAAY,CAAC,OAAO,EAAE,MAAM,CAAC,CAGpD,CAAC;gBACF,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;aACjC;YAAC,OAAO,GAAG,EAAE;gBACZ,WAAW;aACZ;QACH,CAAC,CAAC;QAEF,KAAK,EAAE,CAAC;IACV,CAAC,CAAC,CAAC;IAEH,OAAO,KAAK,CAAC;AACf,CAAC;AAED,+CAA+C;AAC/C;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,OAAO,CAAC,EAAE,CAAC;IAwBnC,CAAC;IAtBC;;OAEG;IACI,2BAAS,GAAhB,UAAiB,uBAA2D,EAAE,aAAwB;QAAtG,iBAUC;QATC,uBAAuB,CAAC,UAAA,KAAK;YAC3B,IAAI,CAAC,aAAa,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;gBAC5C,OAAO,KAAK,CAAC;aACd;YACD,6CACK,KAAK,KACR,OAAO,EAAE,KAAI,CAAC,WAAW,EAAE,IAC3B;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAED,kGAAkG;IAC1F,6BAAW,GAAnB;QACE,IAAI,CAAC,WAAW,EAAE;YAChB,WAAW,GAAG,cAAc,EAAE,CAAC;SAChC;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IA/BD;;OAEG;IACW,UAAE,GAAW,SAAS,CAAC;IA6BvC,cAAC;CAAA,AAjCD,IAiCC;AAjCY,0BAAO","sourcesContent":["import { EventProcessor, Hub, Integration } from '@sentry/types';\nimport { existsSync, readFileSync } from 'fs';\nimport { dirname, join } from 'path';\n\nlet moduleCache: { [key: string]: string };\n\n/** Extract information about paths */\nfunction getPaths(): string[] {\n  try {\n    return require.cache ? Object.keys(require.cache as Record<string, unknown>) : [];\n  } catch (e) {\n    return [];\n  }\n}\n\n/** Extract information about package.json modules */\nfunction collectModules(): {\n  [name: string]: string;\n} {\n  const mainPaths = (require.main && require.main.paths) || [];\n  const paths = getPaths();\n  const infos: {\n    [name: string]: string;\n  } = {};\n  const seen: {\n    [path: string]: boolean;\n  } = {};\n\n  paths.forEach(path => {\n    let dir = path;\n\n    /** Traverse directories upward in the search of package.json file */\n    const updir = (): void | (() => void) => {\n      const orig = dir;\n      dir = dirname(orig);\n\n      if (!dir || orig === dir || seen[orig]) {\n        return undefined;\n      }\n      if (mainPaths.indexOf(dir) < 0) {\n        return updir();\n      }\n\n      const pkgfile = join(orig, 'package.json');\n      seen[orig] = true;\n\n      if (!existsSync(pkgfile)) {\n        return updir();\n      }\n\n      try {\n        const info = JSON.parse(readFileSync(pkgfile, 'utf8')) as {\n          name: string;\n          version: string;\n        };\n        infos[info.name] = info.version;\n      } catch (_oO) {\n        // no-empty\n      }\n    };\n\n    updir();\n  });\n\n  return infos;\n}\n\n/** Add node modules / packages to the event */\nexport class Modules implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Modules';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Modules.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor(event => {\n      if (!getCurrentHub().getIntegration(Modules)) {\n        return event;\n      }\n      return {\n        ...event,\n        modules: this._getModules(),\n      };\n    });\n  }\n\n  /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */\n  private _getModules(): { [key: string]: string } {\n    if (!moduleCache) {\n      moduleCache = collectModules();\n    }\n    return moduleCache;\n  }\n}\n"]}import { Integration } from '@sentry/types';
/** Global Promise Rejection handler */
export declare class OnUncaughtException implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    readonly handler: (error: Error) => void;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Default onFatalError handler
         * @param firstError Error that has been thrown
         * @param secondError If this was called multiple times this will be set
         */
        onFatalError?(firstError: Error, secondError?: Error): void;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @hidden
     */
    private _makeErrorHandler;
}
//# sourceMappingURL=onuncaughtexception.d.ts.map{"version":3,"file":"onuncaughtexception.d.ts","sourceRoot":"","sources":["../../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAY,MAAM,eAAe,CAAC;AAStD,uCAAuC;AACvC,qBAAa,mBAAoB,YAAW,WAAW;IAoBnD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAnB3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAyB;IAEjD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA0B;IAE7C;;OAEG;IACH,SAAgB,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,CAA4B;IAE3E;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;;WAIG;QACH,YAAY,CAAC,CAAC,UAAU,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;KACxD;IAER;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;OAEG;IACH,OAAO,CAAC,iBAAiB;CA+E1B"}Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@sentry/core");
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var flags_1 = require("../flags");
var errorhandling_1 = require("./utils/errorhandling");
/** Global Promise Rejection handler */
var OnUncaughtException = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUncaughtException(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUncaughtException.id;
        /**
         * @inheritDoc
         */
        this.handler = this._makeErrorHandler();
    }
    /**
     * @inheritDoc
     */
    OnUncaughtException.prototype.setupOnce = function () {
        global.process.on('uncaughtException', this.handler.bind(this));
    };
    /**
     * @hidden
     */
    OnUncaughtException.prototype._makeErrorHandler = function () {
        var _this = this;
        var timeout = 2000;
        var caughtFirstError = false;
        var caughtSecondError = false;
        var calledFatalError = false;
        var firstError;
        return function (error) {
            var onFatalError = errorhandling_1.logAndExitProcess;
            var client = core_1.getCurrentHub().getClient();
            if (_this._options.onFatalError) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                onFatalError = _this._options.onFatalError;
            }
            else if (client && client.getOptions().onFatalError) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                onFatalError = client.getOptions().onFatalError;
            }
            if (!caughtFirstError) {
                var hub_1 = core_1.getCurrentHub();
                // this is the first uncaught error and the ultimate reason for shutting down
                // we want to do absolutely everything possible to ensure it gets captured
                // also we want to make sure we don't go recursion crazy if more errors happen after this one
                firstError = error;
                caughtFirstError = true;
                if (hub_1.getIntegration(OnUncaughtException)) {
                    hub_1.withScope(function (scope) {
                        scope.setLevel(types_1.Severity.Fatal);
                        hub_1.captureException(error, {
                            originalException: error,
                            data: { mechanism: { handled: false, type: 'onuncaughtexception' } },
                        });
                        if (!calledFatalError) {
                            calledFatalError = true;
                            onFatalError(error);
                        }
                    });
                }
                else {
                    if (!calledFatalError) {
                        calledFatalError = true;
                        onFatalError(error);
                    }
                }
            }
            else if (calledFatalError) {
                // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down
                flags_1.IS_DEBUG_BUILD &&
                    utils_1.logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');
                errorhandling_1.logAndExitProcess(error);
            }
            else if (!caughtSecondError) {
                // two cases for how we can hit this branch:
                //   - capturing of first error blew up and we just caught the exception from that
                //     - quit trying to capture, proceed with shutdown
                //   - a second independent error happened while waiting for first error to capture
                //     - want to avoid causing premature shutdown before first error capture finishes
                // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff
                // so let's instead just delay a bit before we proceed with our action here
                // in case 1, we just wait a bit unnecessarily but ultimately do the same thing
                // in case 2, the delay hopefully made us wait long enough for the capture to finish
                // two potential nonideal outcomes:
                //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError
                //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error
                // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)
                //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish
                caughtSecondError = true;
                setTimeout(function () {
                    if (!calledFatalError) {
                        // it was probably case 1, let's treat err as the sendErr and call onFatalError
                        calledFatalError = true;
                        onFatalError(firstError, error);
                    }
                    else {
                        // it was probably case 2, our first error finished capturing while we waited, cool, do nothing
                    }
                }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc
            }
        };
    };
    /**
     * @inheritDoc
     */
    OnUncaughtException.id = 'OnUncaughtException';
    return OnUncaughtException;
}());
exports.OnUncaughtException = OnUncaughtException;
//# sourceMappingURL=onuncaughtexception.js.map{"version":3,"file":"onuncaughtexception.js","sourceRoot":"","sources":["../../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":";AAAA,qCAAoD;AACpD,uCAAsD;AACtD,uCAAuC;AAGvC,kCAA0C;AAC1C,uDAA0D;AAI1D,uCAAuC;AACvC;IAgBE;;OAEG;IACH,6BACmB,QAOX;QAPW,yBAAA,EAAA,aAOX;QAPW,aAAQ,GAAR,QAAQ,CAOnB;QArBR;;WAEG;QACI,SAAI,GAAW,mBAAmB,CAAC,EAAE,CAAC;QAE7C;;WAEG;QACa,YAAO,GAA2B,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAcxE,CAAC;IACJ;;OAEG;IACI,uCAAS,GAAhB;QACE,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACK,+CAAiB,GAAzB;QAAA,iBA8EC;QA7EC,IAAM,OAAO,GAAG,IAAI,CAAC;QACrB,IAAI,gBAAgB,GAAY,KAAK,CAAC;QACtC,IAAI,iBAAiB,GAAY,KAAK,CAAC;QACvC,IAAI,gBAAgB,GAAY,KAAK,CAAC;QACtC,IAAI,UAAiB,CAAC;QAEtB,OAAO,UAAC,KAAY;YAClB,IAAI,YAAY,GAAwB,iCAAiB,CAAC;YAC1D,IAAM,MAAM,GAAG,oBAAa,EAAE,CAAC,SAAS,EAAc,CAAC;YAEvD,IAAI,KAAI,CAAC,QAAQ,CAAC,YAAY,EAAE;gBAC9B,6DAA6D;gBAC7D,YAAY,GAAG,KAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;aAC3C;iBAAM,IAAI,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC,YAAY,EAAE;gBACrD,6DAA6D;gBAC7D,YAAY,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC,YAAmC,CAAC;aACxE;YAED,IAAI,CAAC,gBAAgB,EAAE;gBACrB,IAAM,KAAG,GAAG,oBAAa,EAAE,CAAC;gBAE5B,6EAA6E;gBAC7E,0EAA0E;gBAC1E,6FAA6F;gBAC7F,UAAU,GAAG,KAAK,CAAC;gBACnB,gBAAgB,GAAG,IAAI,CAAC;gBAExB,IAAI,KAAG,CAAC,cAAc,CAAC,mBAAmB,CAAC,EAAE;oBAC3C,KAAG,CAAC,SAAS,CAAC,UAAC,KAAY;wBACzB,KAAK,CAAC,QAAQ,CAAC,gBAAQ,CAAC,KAAK,CAAC,CAAC;wBAC/B,KAAG,CAAC,gBAAgB,CAAC,KAAK,EAAE;4BAC1B,iBAAiB,EAAE,KAAK;4BACxB,IAAI,EAAE,EAAE,SAAS,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,qBAAqB,EAAE,EAAE;yBACrE,CAAC,CAAC;wBACH,IAAI,CAAC,gBAAgB,EAAE;4BACrB,gBAAgB,GAAG,IAAI,CAAC;4BACxB,YAAY,CAAC,KAAK,CAAC,CAAC;yBACrB;oBACH,CAAC,CAAC,CAAC;iBACJ;qBAAM;oBACL,IAAI,CAAC,gBAAgB,EAAE;wBACrB,gBAAgB,GAAG,IAAI,CAAC;wBACxB,YAAY,CAAC,KAAK,CAAC,CAAC;qBACrB;iBACF;aACF;iBAAM,IAAI,gBAAgB,EAAE;gBAC3B,+FAA+F;gBAC/F,sBAAc;oBACZ,cAAM,CAAC,IAAI,CAAC,gGAAgG,CAAC,CAAC;gBAChH,iCAAiB,CAAC,KAAK,CAAC,CAAC;aAC1B;iBAAM,IAAI,CAAC,iBAAiB,EAAE;gBAC7B,4CAA4C;gBAC5C,kFAAkF;gBAClF,sDAAsD;gBACtD,mFAAmF;gBACnF,qFAAqF;gBACrF,sGAAsG;gBACtG,2EAA2E;gBAC3E,+EAA+E;gBAC/E,oFAAoF;gBACpF,mCAAmC;gBACnC,6IAA6I;gBAC7I,6MAA6M;gBAC7M,iHAAiH;gBACjH,wGAAwG;gBACxG,iBAAiB,GAAG,IAAI,CAAC;gBACzB,UAAU,CAAC;oBACT,IAAI,CAAC,gBAAgB,EAAE;wBACrB,+EAA+E;wBAC/E,gBAAgB,GAAG,IAAI,CAAC;wBACxB,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;qBACjC;yBAAM;wBACL,+FAA+F;qBAChG;gBACH,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,sIAAsI;aACpJ;QACH,CAAC,CAAC;IACJ,CAAC;IApHD;;OAEG;IACW,sBAAE,GAAW,qBAAqB,CAAC;IAkHnD,0BAAC;CAAA,AAtHD,IAsHC;AAtHY,kDAAmB","sourcesContent":["import { getCurrentHub, Scope } from '@sentry/core';\nimport { Integration, Severity } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { NodeClient } from '../client';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { logAndExitProcess } from './utils/errorhandling';\n\ntype OnFatalErrorHandler = (firstError: Error, secondError?: Error) => void;\n\n/** Global Promise Rejection handler */\nexport class OnUncaughtException implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUncaughtException';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUncaughtException.id;\n\n  /**\n   * @inheritDoc\n   */\n  public readonly handler: (error: Error) => void = this._makeErrorHandler();\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly _options: {\n      /**\n       * Default onFatalError handler\n       * @param firstError Error that has been thrown\n       * @param secondError If this was called multiple times this will be set\n       */\n      onFatalError?(firstError: Error, secondError?: Error): void;\n    } = {},\n  ) {}\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('uncaughtException', this.handler.bind(this));\n  }\n\n  /**\n   * @hidden\n   */\n  private _makeErrorHandler(): (error: Error) => void {\n    const timeout = 2000;\n    let caughtFirstError: boolean = false;\n    let caughtSecondError: boolean = false;\n    let calledFatalError: boolean = false;\n    let firstError: Error;\n\n    return (error: Error): void => {\n      let onFatalError: OnFatalErrorHandler = logAndExitProcess;\n      const client = getCurrentHub().getClient<NodeClient>();\n\n      if (this._options.onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = this._options.onFatalError;\n      } else if (client && client.getOptions().onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = client.getOptions().onFatalError as OnFatalErrorHandler;\n      }\n\n      if (!caughtFirstError) {\n        const hub = getCurrentHub();\n\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (hub.getIntegration(OnUncaughtException)) {\n          hub.withScope((scope: Scope) => {\n            scope.setLevel(Severity.Fatal);\n            hub.captureException(error, {\n              originalException: error,\n              data: { mechanism: { handled: false, type: 'onuncaughtexception' } },\n            });\n            if (!calledFatalError) {\n              calledFatalError = true;\n              onFatalError(error);\n            }\n          });\n        } else {\n          if (!calledFatalError) {\n            calledFatalError = true;\n            onFatalError(error);\n          }\n        }\n      } else if (calledFatalError) {\n        // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n        IS_DEBUG_BUILD &&\n          logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n        logAndExitProcess(error);\n      } else if (!caughtSecondError) {\n        // two cases for how we can hit this branch:\n        //   - capturing of first error blew up and we just caught the exception from that\n        //     - quit trying to capture, proceed with shutdown\n        //   - a second independent error happened while waiting for first error to capture\n        //     - want to avoid causing premature shutdown before first error capture finishes\n        // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n        // so let's instead just delay a bit before we proceed with our action here\n        // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n        // in case 2, the delay hopefully made us wait long enough for the capture to finish\n        // two potential nonideal outcomes:\n        //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n        //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n        // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n        //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n        caughtSecondError = true;\n        setTimeout(() => {\n          if (!calledFatalError) {\n            // it was probably case 1, let's treat err as the sendErr and call onFatalError\n            calledFatalError = true;\n            onFatalError(firstError, error);\n          } else {\n            // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n          }\n        }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n      }\n    };\n  }\n}\n"]}import { Integration } from '@sentry/types';
declare type UnhandledRejectionMode = 'none' | 'warn' | 'strict';
/** Global Promise Rejection handler */
export declare class OnUnhandledRejection implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Option deciding what to do after capturing unhandledRejection,
         * that mimicks behavior of node's --unhandled-rejection flag.
         */
        mode: UnhandledRejectionMode;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    sendUnhandledPromise(reason: any, promise: any): void;
    /**
     * Handler for `mode` option
     */
    private _handleRejection;
}
export {};
//# sourceMappingURL=onunhandledrejection.d.ts.map{"version":3,"file":"onunhandledrejection.d.ts","sourceRoot":"","sources":["../../../src/integrations/onunhandledrejection.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAK5C,aAAK,sBAAsB,GAAG,MAAM,GAAG,MAAM,GAAG,QAAQ,CAAC;AAEzD,uCAAuC;AACvC,qBAAa,oBAAqB,YAAW,WAAW;IAepD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAd3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAA0B;IAElD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA2B;IAE9C;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;WAGG;QACH,IAAI,EAAE,sBAAsB,CAAC;KACX;IAGtB;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;;;OAIG;IAEI,oBAAoB,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG,IAAI;IAmC5D;;OAEG;IAEH,OAAO,CAAC,gBAAgB;CAuBzB"}Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var errorhandling_1 = require("./utils/errorhandling");
/** Global Promise Rejection handler */
var OnUnhandledRejection = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUnhandledRejection(_options) {
        if (_options === void 0) { _options = { mode: 'warn' }; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUnhandledRejection.id;
    }
    /**
     * @inheritDoc
     */
    OnUnhandledRejection.prototype.setupOnce = function () {
        global.process.on('unhandledRejection', this.sendUnhandledPromise.bind(this));
    };
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
    OnUnhandledRejection.prototype.sendUnhandledPromise = function (reason, promise) {
        var hub = core_1.getCurrentHub();
        if (!hub.getIntegration(OnUnhandledRejection)) {
            this._handleRejection(reason);
            return;
        }
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        var context = (promise.domain && promise.domain.sentryContext) || {};
        hub.withScope(function (scope) {
            scope.setExtra('unhandledPromiseRejection', true);
            // Preserve backwards compatibility with raven-node for now
            if (context.user) {
                scope.setUser(context.user);
            }
            if (context.tags) {
                scope.setTags(context.tags);
            }
            if (context.extra) {
                scope.setExtras(context.extra);
            }
            hub.captureException(reason, {
                originalException: promise,
                data: { mechanism: { handled: false, type: 'onunhandledrejection' } },
            });
        });
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        this._handleRejection(reason);
    };
    /**
     * Handler for `mode` option
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    OnUnhandledRejection.prototype._handleRejection = function (reason) {
        // https://github.com/nodejs/node/blob/7cf6f9e964aa00772965391c23acda6d71972a9a/lib/internal/process/promises.js#L234-L240
        var rejectionWarning = 'This error originated either by ' +
            'throwing inside of an async function without a catch block, ' +
            'or by rejecting a promise which was not handled with .catch().' +
            ' The promise rejected with the reason:';
        /* eslint-disable no-console */
        if (this._options.mode === 'warn') {
            utils_1.consoleSandbox(function () {
                console.warn(rejectionWarning);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                console.error(reason && reason.stack ? reason.stack : reason);
            });
        }
        else if (this._options.mode === 'strict') {
            utils_1.consoleSandbox(function () {
                console.warn(rejectionWarning);
            });
            errorhandling_1.logAndExitProcess(reason);
        }
        /* eslint-enable no-console */
    };
    /**
     * @inheritDoc
     */
    OnUnhandledRejection.id = 'OnUnhandledRejection';
    return OnUnhandledRejection;
}());
exports.OnUnhandledRejection = OnUnhandledRejection;
//# sourceMappingURL=onunhandledrejection.js.map{"version":3,"file":"onunhandledrejection.js","sourceRoot":"","sources":["../../../src/integrations/onunhandledrejection.ts"],"names":[],"mappings":";AAAA,qCAAoD;AAEpD,uCAA+C;AAE/C,uDAA0D;AAI1D,uCAAuC;AACvC;IAWE;;OAEG;IACH,8BACmB,QAMG;QANH,yBAAA,EAAA,aAMX,IAAI,EAAE,MAAM,EAAE;QANH,aAAQ,GAAR,QAAQ,CAML;QAftB;;WAEG;QACI,SAAI,GAAW,oBAAoB,CAAC,EAAE,CAAC;IAa3C,CAAC;IAEJ;;OAEG;IACI,wCAAS,GAAhB;QACE,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,oBAAoB,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAChF,CAAC;IAED;;;;OAIG;IACH,iHAAiH;IAC1G,mDAAoB,GAA3B,UAA4B,MAAW,EAAE,OAAY;QACnD,IAAM,GAAG,GAAG,oBAAa,EAAE,CAAC;QAE5B,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,oBAAoB,CAAC,EAAE;YAC7C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;YAC9B,OAAO;SACR;QAED,+DAA+D;QAC/D,IAAM,OAAO,GAAG,CAAC,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;QAEvE,GAAG,CAAC,SAAS,CAAC,UAAC,KAAY;YACzB,KAAK,CAAC,QAAQ,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC;YAElD,2DAA2D;YAC3D,IAAI,OAAO,CAAC,IAAI,EAAE;gBAChB,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;aAC7B;YACD,IAAI,OAAO,CAAC,IAAI,EAAE;gBAChB,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;aAC7B;YACD,IAAI,OAAO,CAAC,KAAK,EAAE;gBACjB,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aAChC;YAED,GAAG,CAAC,gBAAgB,CAAC,MAAM,EAAE;gBAC3B,iBAAiB,EAAE,OAAO;gBAC1B,IAAI,EAAE,EAAE,SAAS,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,sBAAsB,EAAE,EAAE;aACtE,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,+DAA+D;QAE/D,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;IAChC,CAAC;IAED;;OAEG;IACH,8DAA8D;IACtD,+CAAgB,GAAxB,UAAyB,MAAW;QAClC,0HAA0H;QAC1H,IAAM,gBAAgB,GACpB,kCAAkC;YAClC,8DAA8D;YAC9D,gEAAgE;YAChE,wCAAwC,CAAC;QAE3C,+BAA+B;QAC/B,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,MAAM,EAAE;YACjC,sBAAc,CAAC;gBACb,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBAC/B,sEAAsE;gBACtE,OAAO,CAAC,KAAK,CAAC,MAAM,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;YAChE,CAAC,CAAC,CAAC;SACJ;aAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,QAAQ,EAAE;YAC1C,sBAAc,CAAC;gBACb,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACjC,CAAC,CAAC,CAAC;YACH,iCAAiB,CAAC,MAAM,CAAC,CAAC;SAC3B;QACD,8BAA8B;IAChC,CAAC;IAjGD;;OAEG;IACW,uBAAE,GAAW,sBAAsB,CAAC;IA+FpD,2BAAC;CAAA,AAnGD,IAmGC;AAnGY,oDAAoB","sourcesContent":["import { getCurrentHub, Scope } from '@sentry/core';\nimport { Integration } from '@sentry/types';\nimport { consoleSandbox } from '@sentry/utils';\n\nimport { logAndExitProcess } from './utils/errorhandling';\n\ntype UnhandledRejectionMode = 'none' | 'warn' | 'strict';\n\n/** Global Promise Rejection handler */\nexport class OnUnhandledRejection implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUnhandledRejection';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUnhandledRejection.id;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly _options: {\n      /**\n       * Option deciding what to do after capturing unhandledRejection,\n       * that mimicks behavior of node's --unhandled-rejection flag.\n       */\n      mode: UnhandledRejectionMode;\n    } = { mode: 'warn' },\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('unhandledRejection', this.sendUnhandledPromise.bind(this));\n  }\n\n  /**\n   * Send an exception with reason\n   * @param reason string\n   * @param promise promise\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n  public sendUnhandledPromise(reason: any, promise: any): void {\n    const hub = getCurrentHub();\n\n    if (!hub.getIntegration(OnUnhandledRejection)) {\n      this._handleRejection(reason);\n      return;\n    }\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    const context = (promise.domain && promise.domain.sentryContext) || {};\n\n    hub.withScope((scope: Scope) => {\n      scope.setExtra('unhandledPromiseRejection', true);\n\n      // Preserve backwards compatibility with raven-node for now\n      if (context.user) {\n        scope.setUser(context.user);\n      }\n      if (context.tags) {\n        scope.setTags(context.tags);\n      }\n      if (context.extra) {\n        scope.setExtras(context.extra);\n      }\n\n      hub.captureException(reason, {\n        originalException: promise,\n        data: { mechanism: { handled: false, type: 'onunhandledrejection' } },\n      });\n    });\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n    this._handleRejection(reason);\n  }\n\n  /**\n   * Handler for `mode` option\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _handleRejection(reason: any): void {\n    // https://github.com/nodejs/node/blob/7cf6f9e964aa00772965391c23acda6d71972a9a/lib/internal/process/promises.js#L234-L240\n    const rejectionWarning =\n      'This error originated either by ' +\n      'throwing inside of an async function without a catch block, ' +\n      'or by rejecting a promise which was not handled with .catch().' +\n      ' The promise rejected with the reason:';\n\n    /* eslint-disable no-console */\n    if (this._options.mode === 'warn') {\n      consoleSandbox(() => {\n        console.warn(rejectionWarning);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        console.error(reason && reason.stack ? reason.stack : reason);\n      });\n    } else if (this._options.mode === 'strict') {\n      consoleSandbox(() => {\n        console.warn(rejectionWarning);\n      });\n      logAndExitProcess(reason);\n    }\n    /* eslint-enable no-console */\n  }\n}\n"]}/**
 * @hidden
 */
export declare function logAndExitProcess(error: Error): void;
//# sourceMappingURL=errorhandling.d.ts.map{"version":3,"file":"errorhandling.d.ts","sourceRoot":"","sources":["../../../../src/integrations/utils/errorhandling.ts"],"names":[],"mappings":"AAQA;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAuBpD"}Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var flags_1 = require("../../flags");
var DEFAULT_SHUTDOWN_TIMEOUT = 2000;
/**
 * @hidden
 */
function logAndExitProcess(error) {
    // eslint-disable-next-line no-console
    console.error(error && error.stack ? error.stack : error);
    var client = core_1.getCurrentHub().getClient();
    if (client === undefined) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('No NodeClient was defined, we are exiting the process now.');
        global.process.exit(1);
    }
    var options = client.getOptions();
    var timeout = (options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout) ||
        DEFAULT_SHUTDOWN_TIMEOUT;
    utils_1.forget(client.close(timeout).then(function (result) {
        if (!result) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('We reached the timeout for emptying the request buffer, still exiting now!');
        }
        global.process.exit(1);
    }));
}
exports.logAndExitProcess = logAndExitProcess;
//# sourceMappingURL=errorhandling.js.map{"version":3,"file":"errorhandling.js","sourceRoot":"","sources":["../../../../src/integrations/utils/errorhandling.ts"],"names":[],"mappings":";AAAA,qCAA6C;AAC7C,uCAA+C;AAG/C,qCAA6C;AAE7C,IAAM,wBAAwB,GAAG,IAAI,CAAC;AAEtC;;GAEG;AACH,SAAgB,iBAAiB,CAAC,KAAY;IAC5C,sCAAsC;IACtC,OAAO,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAE1D,IAAM,MAAM,GAAG,oBAAa,EAAE,CAAC,SAAS,EAAc,CAAC;IAEvD,IAAI,MAAM,KAAK,SAAS,EAAE;QACxB,sBAAc,IAAI,cAAM,CAAC,IAAI,CAAC,4DAA4D,CAAC,CAAC;QAC5F,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACxB;IAED,IAAM,OAAO,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;IACpC,IAAM,OAAO,GACX,CAAC,OAAO,IAAI,OAAO,CAAC,eAAe,IAAI,OAAO,CAAC,eAAe,GAAG,CAAC,IAAI,OAAO,CAAC,eAAe,CAAC;QAC9F,wBAAwB,CAAC;IAC3B,cAAM,CACJ,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,MAAe;QACzC,IAAI,CAAC,MAAM,EAAE;YACX,sBAAc,IAAI,cAAM,CAAC,IAAI,CAAC,4EAA4E,CAAC,CAAC;SAC7G;QACD,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CACH,CAAC;AACJ,CAAC;AAvBD,8CAuBC","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { forget, logger } from '@sentry/utils';\n\nimport { NodeClient } from '../../client';\nimport { IS_DEBUG_BUILD } from '../../flags';\n\nconst DEFAULT_SHUTDOWN_TIMEOUT = 2000;\n\n/**\n * @hidden\n */\nexport function logAndExitProcess(error: Error): void {\n  // eslint-disable-next-line no-console\n  console.error(error && error.stack ? error.stack : error);\n\n  const client = getCurrentHub().getClient<NodeClient>();\n\n  if (client === undefined) {\n    IS_DEBUG_BUILD && logger.warn('No NodeClient was defined, we are exiting the process now.');\n    global.process.exit(1);\n  }\n\n  const options = client.getOptions();\n  const timeout =\n    (options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout) ||\n    DEFAULT_SHUTDOWN_TIMEOUT;\n  forget(\n    client.close(timeout).then((result: boolean) => {\n      if (!result) {\n        IS_DEBUG_BUILD && logger.warn('We reached the timeout for emptying the request buffer, still exiting now!');\n      }\n      global.process.exit(1);\n    }),\n  );\n}\n"]}/// <reference types="node" />
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
/**
 * Checks whether given url points to Sentry server
 * @param url url to verify
 */
export declare function isSentryRequest(url: string): boolean;
/**
 * Assemble a URL to be used for breadcrumbs and spans.
 *
 * @param requestOptions RequestOptions object containing the component parts for a URL
 * @returns Fully-formed URL
 */
export declare function extractUrl(requestOptions: RequestOptions): string;
/**
 * Handle various edge cases in the span description (for spans representing http(s) requests).
 *
 * @param description current `description` property of the span representing the request
 * @param requestOptions Configuration data for the request
 * @param Request Request object
 *
 * @returns The cleaned description
 */
export declare function cleanSpanDescription(description: string | undefined, requestOptions: RequestOptions, request: http.ClientRequest): string | undefined;
export declare type RequestOptions = http.RequestOptions & {
    hash?: string;
    search?: string;
    pathname?: string;
    href?: string;
};
declare type RequestCallback = (response: http.IncomingMessage) => void;
export declare type RequestMethodArgs = [RequestOptions | string | URL, RequestCallback?] | [string | URL, RequestOptions, RequestCallback?];
export declare type RequestMethod = (...args: RequestMethodArgs) => http.ClientRequest;
/**
 * Convert a URL object into a RequestOptions object.
 *
 * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the
 * RequestOptions type above.
 *
 * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.
 */
export declare function urlToOptions(url: URL): RequestOptions;
/**
 * Normalize inputs to `http(s).request()` and `http(s).get()`.
 *
 * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:
 *     [ RequestOptions | string | URL ],
 *     [ RequestOptions | string | URL, RequestCallback ],
 *     [ string | URL, RequestOptions ], and
 *     [ string | URL, RequestOptions, RequestCallback ].
 *
 * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is
 * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact
 * with the args in a standard way.
 *
 * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.
 *
 * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].
 */
export declare function normalizeRequestArgs(httpModule: typeof http | typeof https, requestArgs: RequestMethodArgs): [RequestOptions] | [RequestOptions, RequestCallback];
export {};
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../../src/integrations/utils/http.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAI1B;;;GAGG;AACH,wBAAgB,eAAe,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAGpD;AAED;;;;;GAKG;AACH,wBAAgB,UAAU,CAAC,cAAc,EAAE,cAAc,GAAG,MAAM,CASjE;AAED;;;;;;;;GAQG;AACH,wBAAgB,oBAAoB,CAClC,WAAW,EAAE,MAAM,GAAG,SAAS,EAC/B,cAAc,EAAE,cAAc,EAC9B,OAAO,EAAE,IAAI,CAAC,aAAa,GAC1B,MAAM,GAAG,SAAS,CAuBpB;AAGD,oBAAY,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,MAAM,CAAC,EAAE,MAAM,CAAC;IAAC,QAAQ,CAAC,EAAE,MAAM,CAAC;IAAC,IAAI,CAAC,EAAE,MAAM,CAAA;CAAE,CAAC;AACxH,aAAK,eAAe,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,eAAe,KAAK,IAAI,CAAC;AAChE,oBAAY,iBAAiB,GACzB,CAAC,cAAc,GAAG,MAAM,GAAG,GAAG,EAAE,eAAe,CAAC,CAAC,GACjD,CAAC,MAAM,GAAG,GAAG,EAAE,cAAc,EAAE,eAAe,CAAC,CAAC,CAAC;AACrD,oBAAY,aAAa,GAAG,CAAC,GAAG,IAAI,EAAE,iBAAiB,KAAK,IAAI,CAAC,aAAa,CAAC;AAE/E;;;;;;;GAOG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,GAAG,GAAG,cAAc,CAkBrD;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,oBAAoB,CAClC,UAAU,EAAE,OAAO,IAAI,GAAG,OAAO,KAAK,EACtC,WAAW,EAAE,iBAAiB,GAC7B,CAAC,cAAc,CAAC,GAAG,CAAC,cAAc,EAAE,eAAe,CAAC,CAoDtD"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var url_1 = require("url");
var NODE_VERSION = utils_1.parseSemver(process.versions.node);
/**
 * Checks whether given url points to Sentry server
 * @param url url to verify
 */
function isSentryRequest(url) {
    var _a;
    var dsn = (_a = core_1.getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getDsn();
    return dsn ? url.includes(dsn.host) : false;
}
exports.isSentryRequest = isSentryRequest;
/**
 * Assemble a URL to be used for breadcrumbs and spans.
 *
 * @param requestOptions RequestOptions object containing the component parts for a URL
 * @returns Fully-formed URL
 */
function extractUrl(requestOptions) {
    var protocol = requestOptions.protocol || '';
    var hostname = requestOptions.hostname || requestOptions.host || '';
    // Don't log standard :80 (http) and :443 (https) ports to reduce the noise
    var port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? '' : ":" + requestOptions.port;
    var path = requestOptions.path ? requestOptions.path : '/';
    return protocol + "//" + hostname + port + path;
}
exports.extractUrl = extractUrl;
/**
 * Handle various edge cases in the span description (for spans representing http(s) requests).
 *
 * @param description current `description` property of the span representing the request
 * @param requestOptions Configuration data for the request
 * @param Request Request object
 *
 * @returns The cleaned description
 */
function cleanSpanDescription(description, requestOptions, request) {
    var _a, _b, _c;
    // nothing to clean
    if (!description) {
        return description;
    }
    // eslint-disable-next-line prefer-const
    var _d = tslib_1.__read(description.split(' '), 2), method = _d[0], requestUrl = _d[1];
    // superagent sticks the protocol in a weird place (we check for host because if both host *and* protocol are missing,
    // we're likely dealing with an internal route and this doesn't apply)
    if (requestOptions.host && !requestOptions.protocol) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
        requestOptions.protocol = (_b = (_a = request) === null || _a === void 0 ? void 0 : _a.agent) === null || _b === void 0 ? void 0 : _b.protocol; // worst comes to worst, this is undefined and nothing changes
        requestUrl = extractUrl(requestOptions);
    }
    // internal routes can end up starting with a triple slash rather than a single one
    if ((_c = requestUrl) === null || _c === void 0 ? void 0 : _c.startsWith('///')) {
        requestUrl = requestUrl.slice(2);
    }
    return method + " " + requestUrl;
}
exports.cleanSpanDescription = cleanSpanDescription;
/**
 * Convert a URL object into a RequestOptions object.
 *
 * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the
 * RequestOptions type above.
 *
 * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.
 */
function urlToOptions(url) {
    var options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: "" + (url.pathname || '') + (url.search || ''),
        href: url.href,
    };
    if (url.port !== '') {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = url.username + ":" + url.password;
    }
    return options;
}
exports.urlToOptions = urlToOptions;
/**
 * Normalize inputs to `http(s).request()` and `http(s).get()`.
 *
 * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:
 *     [ RequestOptions | string | URL ],
 *     [ RequestOptions | string | URL, RequestCallback ],
 *     [ string | URL, RequestOptions ], and
 *     [ string | URL, RequestOptions, RequestCallback ].
 *
 * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is
 * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact
 * with the args in a standard way.
 *
 * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.
 *
 * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].
 */
function normalizeRequestArgs(httpModule, requestArgs) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var callback, requestOptions;
    // pop off the callback, if there is one
    if (typeof requestArgs[requestArgs.length - 1] === 'function') {
        callback = requestArgs.pop();
    }
    // create a RequestOptions object of whatever's at index 0
    if (typeof requestArgs[0] === 'string') {
        requestOptions = urlToOptions(new url_1.URL(requestArgs[0]));
    }
    else if (requestArgs[0] instanceof url_1.URL) {
        requestOptions = urlToOptions(requestArgs[0]);
    }
    else {
        requestOptions = requestArgs[0];
    }
    // if the options were given separately from the URL, fold them in
    if (requestArgs.length === 2) {
        requestOptions = tslib_1.__assign(tslib_1.__assign({}, requestOptions), requestArgs[1]);
    }
    // Figure out the protocol if it's currently missing
    if (requestOptions.protocol === undefined) {
        // Worst case we end up populating protocol with undefined, which it already is
        /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
        // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.
        // Because of that, we cannot rely on `httpModule` to provide us with valid protocol,
        // as it will always return `http`, even when using `https` module.
        //
        // See test/integrations/http.test.ts for more details on Node <=v8 protocol issue.
        if (NODE_VERSION.major && NODE_VERSION.major > 8) {
            requestOptions.protocol =
                ((_b = (_a = httpModule) === null || _a === void 0 ? void 0 : _a.globalAgent) === null || _b === void 0 ? void 0 : _b.protocol) || ((_c = requestOptions.agent) === null || _c === void 0 ? void 0 : _c.protocol) || ((_d = requestOptions._defaultAgent) === null || _d === void 0 ? void 0 : _d.protocol);
        }
        else {
            requestOptions.protocol =
                ((_e = requestOptions.agent) === null || _e === void 0 ? void 0 : _e.protocol) || ((_f = requestOptions._defaultAgent) === null || _f === void 0 ? void 0 : _f.protocol) || ((_h = (_g = httpModule) === null || _g === void 0 ? void 0 : _g.globalAgent) === null || _h === void 0 ? void 0 : _h.protocol);
        }
        /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
    }
    // return args in standardized form
    if (callback) {
        return [requestOptions, callback];
    }
    else {
        return [requestOptions];
    }
}
exports.normalizeRequestArgs = normalizeRequestArgs;
//# sourceMappingURL=http.js.map{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../../src/integrations/utils/http.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { parseSemver } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\n\nconst NODE_VERSION = parseSemver(process.versions.node);\n\n/**\n * Checks whether given url points to Sentry server\n * @param url url to verify\n */\nexport function isSentryRequest(url: string): boolean {\n  const dsn = getCurrentHub().getClient()?.getDsn();\n  return dsn ? url.includes(dsn.host) : false;\n}\n\n/**\n * Assemble a URL to be used for breadcrumbs and spans.\n *\n * @param requestOptions RequestOptions object containing the component parts for a URL\n * @returns Fully-formed URL\n */\nexport function extractUrl(requestOptions: RequestOptions): string {\n  const protocol = requestOptions.protocol || '';\n  const hostname = requestOptions.hostname || requestOptions.host || '';\n  // Don't log standard :80 (http) and :443 (https) ports to reduce the noise\n  const port =\n    !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? '' : `:${requestOptions.port}`;\n  const path = requestOptions.path ? requestOptions.path : '/';\n\n  return `${protocol}//${hostname}${port}${path}`;\n}\n\n/**\n * Handle various edge cases in the span description (for spans representing http(s) requests).\n *\n * @param description current `description` property of the span representing the request\n * @param requestOptions Configuration data for the request\n * @param Request Request object\n *\n * @returns The cleaned description\n */\nexport function cleanSpanDescription(\n  description: string | undefined,\n  requestOptions: RequestOptions,\n  request: http.ClientRequest,\n): string | undefined {\n  // nothing to clean\n  if (!description) {\n    return description;\n  }\n\n  // eslint-disable-next-line prefer-const\n  let [method, requestUrl] = description.split(' ');\n\n  // superagent sticks the protocol in a weird place (we check for host because if both host *and* protocol are missing,\n  // we're likely dealing with an internal route and this doesn't apply)\n  if (requestOptions.host && !requestOptions.protocol) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    requestOptions.protocol = (request as any)?.agent?.protocol; // worst comes to worst, this is undefined and nothing changes\n    requestUrl = extractUrl(requestOptions);\n  }\n\n  // internal routes can end up starting with a triple slash rather than a single one\n  if (requestUrl?.startsWith('///')) {\n    requestUrl = requestUrl.slice(2);\n  }\n\n  return `${method} ${requestUrl}`;\n}\n\n// the node types are missing a few properties which node's `urlToOptions` function spits out\nexport type RequestOptions = http.RequestOptions & { hash?: string; search?: string; pathname?: string; href?: string };\ntype RequestCallback = (response: http.IncomingMessage) => void;\nexport type RequestMethodArgs =\n  | [RequestOptions | string | URL, RequestCallback?]\n  | [string | URL, RequestOptions, RequestCallback?];\nexport type RequestMethod = (...args: RequestMethodArgs) => http.ClientRequest;\n\n/**\n * Convert a URL object into a RequestOptions object.\n *\n * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the\n * RequestOptions type above.\n *\n * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.\n */\nexport function urlToOptions(url: URL): RequestOptions {\n  const options: RequestOptions = {\n    protocol: url.protocol,\n    hostname:\n      typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || ''}${url.search || ''}`,\n    href: url.href,\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\n/**\n * Normalize inputs to `http(s).request()` and `http(s).get()`.\n *\n * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:\n *     [ RequestOptions | string | URL ],\n *     [ RequestOptions | string | URL, RequestCallback ],\n *     [ string | URL, RequestOptions ], and\n *     [ string | URL, RequestOptions, RequestCallback ].\n *\n * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is\n * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact\n * with the args in a standard way.\n *\n * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.\n *\n * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].\n */\nexport function normalizeRequestArgs(\n  httpModule: typeof http | typeof https,\n  requestArgs: RequestMethodArgs,\n): [RequestOptions] | [RequestOptions, RequestCallback] {\n  let callback, requestOptions;\n\n  // pop off the callback, if there is one\n  if (typeof requestArgs[requestArgs.length - 1] === 'function') {\n    callback = requestArgs.pop() as RequestCallback;\n  }\n\n  // create a RequestOptions object of whatever's at index 0\n  if (typeof requestArgs[0] === 'string') {\n    requestOptions = urlToOptions(new URL(requestArgs[0]));\n  } else if (requestArgs[0] instanceof URL) {\n    requestOptions = urlToOptions(requestArgs[0]);\n  } else {\n    requestOptions = requestArgs[0];\n  }\n\n  // if the options were given separately from the URL, fold them in\n  if (requestArgs.length === 2) {\n    requestOptions = { ...requestOptions, ...requestArgs[1] };\n  }\n\n  // Figure out the protocol if it's currently missing\n  if (requestOptions.protocol === undefined) {\n    // Worst case we end up populating protocol with undefined, which it already is\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // Because of that, we cannot rely on `httpModule` to provide us with valid protocol,\n    // as it will always return `http`, even when using `https` module.\n    //\n    // See test/integrations/http.test.ts for more details on Node <=v8 protocol issue.\n    if (NODE_VERSION.major && NODE_VERSION.major > 8) {\n      requestOptions.protocol =\n        (httpModule?.globalAgent as any)?.protocol ||\n        (requestOptions.agent as any)?.protocol ||\n        (requestOptions._defaultAgent as any)?.protocol;\n    } else {\n      requestOptions.protocol =\n        (requestOptions.agent as any)?.protocol ||\n        (requestOptions._defaultAgent as any)?.protocol ||\n        (httpModule?.globalAgent as any)?.protocol;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\n  }\n\n  // return args in standardized form\n  if (callback) {\n    return [requestOptions, callback];\n  } else {\n    return [requestOptions];\n  }\n}\n"]}import { Integrations as CoreIntegrations } from '@sentry/core';
import { NodeClient } from './client';
import { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';
import { NodeOptions } from './types';
export declare const defaultIntegrations: (CoreIntegrations.FunctionToString | CoreIntegrations.InboundFilters | Console | Http | OnUncaughtException | OnUnhandledRejection | ContextLines | LinkedErrors)[];
/**
 * The Sentry Node SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible in the
 * main entry module. To set context information or send manual events, use the
 * provided methods.
 *
 * @example
 * ```
 *
 * const { init } = require('@sentry/node');
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { configureScope } = require('@sentry/node');
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { addBreadcrumb } = require('@sentry/node');
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const Sentry = require('@sentry/node');
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link NodeOptions} for documentation on configuration options.
 */
export declare function init(options?: NodeOptions): void;
/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
export declare function lastEventId(): string | undefined;
/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export declare function flush(timeout?: number): Promise<boolean>;
/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export declare function close(timeout?: number): Promise<boolean>;
/**
 * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client
 */
export declare function isAutoSessionTrackingEnabled(client?: NodeClient): boolean;
/**
 * Returns a release dynamically from environment variables.
 */
export declare function getSentryRelease(fallback?: string): string | undefined;
//# sourceMappingURL=sdk.d.ts.map{"version":3,"file":"sdk.d.ts","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AAAA,OAAO,EAA8B,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAM5F,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAEtC,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,IAAI,EAAE,YAAY,EAAE,mBAAmB,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AACtH,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC,eAAO,MAAM,mBAAmB,qKAa/B,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsDG;AACH,wBAAgB,IAAI,CAAC,OAAO,GAAE,WAAgB,GAAG,IAAI,CAmDpD;AAED;;;;GAIG;AACH,wBAAgB,WAAW,IAAI,MAAM,GAAG,SAAS,CAEhD;AAED;;;;;;;GAOG;AACH,wBAAsB,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAO9D;AAED;;;;;;;GAOG;AACH,wBAAsB,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAO9D;AAED;;GAEG;AACH,wBAAgB,4BAA4B,CAAC,MAAM,CAAC,EAAE,UAAU,GAAG,OAAO,CASzE;AAED;;GAEG;AACH,wBAAgB,gBAAgB,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CA4BtE"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
var domain = require("domain");
var client_1 = require("./client");
var flags_1 = require("./flags");
var integrations_1 = require("./integrations");
exports.defaultIntegrations = [
    // Common
    new core_1.Integrations.InboundFilters(),
    new core_1.Integrations.FunctionToString(),
    new integrations_1.ContextLines(),
    // Native Wrappers
    new integrations_1.Console(),
    new integrations_1.Http(),
    // Global Handlers
    new integrations_1.OnUncaughtException(),
    new integrations_1.OnUnhandledRejection(),
    // Misc
    new integrations_1.LinkedErrors(),
];
/**
 * The Sentry Node SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible in the
 * main entry module. To set context information or send manual events, use the
 * provided methods.
 *
 * @example
 * ```
 *
 * const { init } = require('@sentry/node');
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { configureScope } = require('@sentry/node');
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { addBreadcrumb } = require('@sentry/node');
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const Sentry = require('@sentry/node');
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link NodeOptions} for documentation on configuration options.
 */
function init(options) {
    if (options === void 0) { options = {}; }
    var _a;
    var carrier = hub_1.getMainCarrier();
    var autoloadedIntegrations = ((_a = carrier.__SENTRY__) === null || _a === void 0 ? void 0 : _a.integrations) || [];
    options.defaultIntegrations =
        options.defaultIntegrations === false
            ? []
            : tslib_1.__spread((Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : exports.defaultIntegrations), autoloadedIntegrations);
    if (options.dsn === undefined && process.env.SENTRY_DSN) {
        options.dsn = process.env.SENTRY_DSN;
    }
    if (options.tracesSampleRate === undefined && process.env.SENTRY_TRACES_SAMPLE_RATE) {
        var tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);
        if (isFinite(tracesSampleRate)) {
            options.tracesSampleRate = tracesSampleRate;
        }
    }
    if (options.release === undefined) {
        var detectedRelease = getSentryRelease();
        if (detectedRelease !== undefined) {
            options.release = detectedRelease;
        }
        else {
            // If release is not provided, then we should disable autoSessionTracking
            options.autoSessionTracking = false;
        }
    }
    if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {
        options.environment = process.env.SENTRY_ENVIRONMENT;
    }
    if (options.autoSessionTracking === undefined && options.dsn !== undefined) {
        options.autoSessionTracking = true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    if (domain.active) {
        hub_1.setHubOnCarrier(carrier, core_1.getCurrentHub());
    }
    core_1.initAndBind(client_1.NodeClient, options);
    if (options.autoSessionTracking) {
        startSessionTracking();
    }
}
exports.init = init;
/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
function lastEventId() {
    return core_1.getCurrentHub().lastEventId();
}
exports.lastEventId = lastEventId;
/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
function flush(timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var client;
        return tslib_1.__generator(this, function (_a) {
            client = core_1.getCurrentHub().getClient();
            if (client) {
                return [2 /*return*/, client.flush(timeout)];
            }
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Cannot flush events. No client defined.');
            return [2 /*return*/, Promise.resolve(false)];
        });
    });
}
exports.flush = flush;
/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
function close(timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var client;
        return tslib_1.__generator(this, function (_a) {
            client = core_1.getCurrentHub().getClient();
            if (client) {
                return [2 /*return*/, client.close(timeout)];
            }
            flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Cannot flush events and disable SDK. No client defined.');
            return [2 /*return*/, Promise.resolve(false)];
        });
    });
}
exports.close = close;
/**
 * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client
 */
function isAutoSessionTrackingEnabled(client) {
    if (client === undefined) {
        return false;
    }
    var clientOptions = client && client.getOptions();
    if (clientOptions && clientOptions.autoSessionTracking !== undefined) {
        return clientOptions.autoSessionTracking;
    }
    return false;
}
exports.isAutoSessionTrackingEnabled = isAutoSessionTrackingEnabled;
/**
 * Returns a release dynamically from environment variables.
 */
function getSentryRelease(fallback) {
    // Always read first as Sentry takes this as precedence
    if (process.env.SENTRY_RELEASE) {
        return process.env.SENTRY_RELEASE;
    }
    // This supports the variable that sentry-webpack-plugin injects
    var global = utils_1.getGlobalObject();
    if (global.SENTRY_RELEASE && global.SENTRY_RELEASE.id) {
        return global.SENTRY_RELEASE.id;
    }
    return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env.GITHUB_SHA ||
        // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
        process.env.COMMIT_REF ||
        // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
        process.env.VERCEL_GIT_COMMIT_SHA ||
        process.env.VERCEL_GITHUB_COMMIT_SHA ||
        process.env.VERCEL_GITLAB_COMMIT_SHA ||
        process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
        // Zeit (now known as Vercel)
        process.env.ZEIT_GITHUB_COMMIT_SHA ||
        process.env.ZEIT_GITLAB_COMMIT_SHA ||
        process.env.ZEIT_BITBUCKET_COMMIT_SHA ||
        fallback);
}
exports.getSentryRelease = getSentryRelease;
/**
 * Enable automatic Session Tracking for the node process.
 */
function startSessionTracking() {
    var hub = core_1.getCurrentHub();
    hub.startSession();
    // Emitted in the case of healthy sessions, error of `mechanism.handled: true` and unhandledrejections because
    // The 'beforeExit' event is not emitted for conditions causing explicit termination,
    // such as calling process.exit() or uncaught exceptions.
    // Ref: https://nodejs.org/api/process.html#process_event_beforeexit
    process.on('beforeExit', function () {
        var _a;
        var session = (_a = hub.getScope()) === null || _a === void 0 ? void 0 : _a.getSession();
        var terminalStates = ['exited', 'crashed'];
        // Only call endSession, if the Session exists on Scope and SessionStatus is not a
        // Terminal Status i.e. Exited or Crashed because
        // "When a session is moved away from ok it must not be updated anymore."
        // Ref: https://develop.sentry.dev/sdk/sessions/
        if (session && !terminalStates.includes(session.status))
            hub.endSession();
    });
}
//# sourceMappingURL=sdk.js.map{"version":3,"file":"sdk.js","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, initAndBind, Integrations as CoreIntegrations } from '@sentry/core';\nimport { getMainCarrier, setHubOnCarrier } from '@sentry/hub';\nimport { SessionStatus } from '@sentry/types';\nimport { getGlobalObject, logger } from '@sentry/utils';\nimport * as domain from 'domain';\n\nimport { NodeClient } from './client';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';\nimport { NodeOptions } from './types';\n\nexport const defaultIntegrations = [\n  // Common\n  new CoreIntegrations.InboundFilters(),\n  new CoreIntegrations.FunctionToString(),\n  new ContextLines(),\n  // Native Wrappers\n  new Console(),\n  new Http(),\n  // Global Handlers\n  new OnUncaughtException(),\n  new OnUnhandledRejection(),\n  // Misc\n  new LinkedErrors(),\n];\n\n/**\n * The Sentry Node SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible in the\n * main entry module. To set context information or send manual events, use the\n * provided methods.\n *\n * @example\n * ```\n *\n * const { init } = require('@sentry/node');\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * const { configureScope } = require('@sentry/node');\n * configureScope((scope: Scope) => {\n *   scope.setExtra({ battery: 0.7 });\n *   scope.setTag({ user_mode: 'admin' });\n *   scope.setUser({ id: '4711' });\n * });\n * ```\n *\n * @example\n * ```\n *\n * const { addBreadcrumb } = require('@sentry/node');\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * const Sentry = require('@sentry/node');\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link NodeOptions} for documentation on configuration options.\n */\nexport function init(options: NodeOptions = {}): void {\n  const carrier = getMainCarrier();\n  const autoloadedIntegrations = carrier.__SENTRY__?.integrations || [];\n\n  options.defaultIntegrations =\n    options.defaultIntegrations === false\n      ? []\n      : [\n          ...(Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations),\n          ...autoloadedIntegrations,\n        ];\n\n  if (options.dsn === undefined && process.env.SENTRY_DSN) {\n    options.dsn = process.env.SENTRY_DSN;\n  }\n\n  if (options.tracesSampleRate === undefined && process.env.SENTRY_TRACES_SAMPLE_RATE) {\n    const tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);\n    if (isFinite(tracesSampleRate)) {\n      options.tracesSampleRate = tracesSampleRate;\n    }\n  }\n\n  if (options.release === undefined) {\n    const detectedRelease = getSentryRelease();\n    if (detectedRelease !== undefined) {\n      options.release = detectedRelease;\n    } else {\n      // If release is not provided, then we should disable autoSessionTracking\n      options.autoSessionTracking = false;\n    }\n  }\n\n  if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {\n    options.environment = process.env.SENTRY_ENVIRONMENT;\n  }\n\n  if (options.autoSessionTracking === undefined && options.dsn !== undefined) {\n    options.autoSessionTracking = true;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  if ((domain as any).active) {\n    setHubOnCarrier(carrier, getCurrentHub());\n  }\n\n  initAndBind(NodeClient, options);\n\n  if (options.autoSessionTracking) {\n    startSessionTracking();\n  }\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nexport function lastEventId(): string | undefined {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.flush(timeout);\n  }\n  IS_DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.close(timeout);\n  }\n  IS_DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client\n */\nexport function isAutoSessionTrackingEnabled(client?: NodeClient): boolean {\n  if (client === undefined) {\n    return false;\n  }\n  const clientOptions: NodeOptions = client && client.getOptions();\n  if (clientOptions && clientOptions.autoSessionTracking !== undefined) {\n    return clientOptions.autoSessionTracking;\n  }\n  return false;\n}\n\n/**\n * Returns a release dynamically from environment variables.\n */\nexport function getSentryRelease(fallback?: string): string | undefined {\n  // Always read first as Sentry takes this as precedence\n  if (process.env.SENTRY_RELEASE) {\n    return process.env.SENTRY_RELEASE;\n  }\n\n  // This supports the variable that sentry-webpack-plugin injects\n  const global = getGlobalObject();\n  if (global.SENTRY_RELEASE && global.SENTRY_RELEASE.id) {\n    return global.SENTRY_RELEASE.id;\n  }\n\n  return (\n    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables\n    process.env.GITHUB_SHA ||\n    // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata\n    process.env.COMMIT_REF ||\n    // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables\n    process.env.VERCEL_GIT_COMMIT_SHA ||\n    process.env.VERCEL_GITHUB_COMMIT_SHA ||\n    process.env.VERCEL_GITLAB_COMMIT_SHA ||\n    process.env.VERCEL_BITBUCKET_COMMIT_SHA ||\n    // Zeit (now known as Vercel)\n    process.env.ZEIT_GITHUB_COMMIT_SHA ||\n    process.env.ZEIT_GITLAB_COMMIT_SHA ||\n    process.env.ZEIT_BITBUCKET_COMMIT_SHA ||\n    fallback\n  );\n}\n\n/**\n * Enable automatic Session Tracking for the node process.\n */\nfunction startSessionTracking(): void {\n  const hub = getCurrentHub();\n  hub.startSession();\n  // Emitted in the case of healthy sessions, error of `mechanism.handled: true` and unhandledrejections because\n  // The 'beforeExit' event is not emitted for conditions causing explicit termination,\n  // such as calling process.exit() or uncaught exceptions.\n  // Ref: https://nodejs.org/api/process.html#process_event_beforeexit\n  process.on('beforeExit', () => {\n    const session = hub.getScope()?.getSession();\n    const terminalStates: SessionStatus[] = ['exited', 'crashed'];\n    // Only call endSession, if the Session exists on Scope and SessionStatus is not a\n    // Terminal Status i.e. Exited or Crashed because\n    // \"When a session is moved away from ok it must not be updated anymore.\"\n    // Ref: https://develop.sentry.dev/sdk/sessions/\n    if (session && !terminalStates.includes(session.status)) hub.endSession();\n  });\n}\n"]}import { StackLineParser } from '@sentry/utils';
export declare const nodeStackParser: StackLineParser;
//# sourceMappingURL=stack-parser.d.ts.map{"version":3,"file":"stack-parser.d.ts","sourceRoot":"","sources":["../../src/stack-parser.ts"],"names":[],"mappings":"AAAA,OAAO,EAAqB,eAAe,EAAqB,MAAM,eAAe,CAAC;AAmHtF,eAAO,MAAM,eAAe,EAAE,eAA4B,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
/** Gets the module */
function getModule(filename) {
    if (!filename) {
        return;
    }
    // We could use optional chaining here but webpack does like that mixed with require
    var base = ((require && require.main && require.main.filename && utils_1.dirname(require.main.filename)) || global.process.cwd()) + "/";
    // It's specifically a module
    var file = utils_1.basename(filename, '.js');
    var path = utils_1.dirname(filename);
    var n = path.lastIndexOf('/node_modules/');
    if (n > -1) {
        // /node_modules/ is 14 chars
        return path.substr(n + 14).replace(/\//g, '.') + ":" + file;
    }
    // Let's see if it's a part of the main module
    // To be a part of main module, it has to share the same base
    n = (path + "/").lastIndexOf(base, 0);
    if (n === 0) {
        var moduleName = path.substr(base.length).replace(/\//g, '.');
        if (moduleName) {
            moduleName += ':';
        }
        moduleName += file;
        return moduleName;
    }
    return file;
}
var FILENAME_MATCH = /^\s*[-]{4,}$/;
var FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
// eslint-disable-next-line complexity
var node = function (line) {
    var _a;
    if (line.match(FILENAME_MATCH)) {
        return {
            filename: line,
        };
    }
    var lineMatch = line.match(FULL_MATCH);
    if (!lineMatch) {
        return undefined;
    }
    var object;
    var method;
    var functionName;
    var typeName;
    var methodName;
    if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf('.');
        if (functionName[methodStart - 1] === '.') {
            // eslint-disable-next-line no-plusplus
            methodStart--;
        }
        if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf('.Module');
            if (objectEnd > 0) {
                functionName = functionName.substr(objectEnd + 1);
                object = object.substr(0, objectEnd);
            }
        }
        typeName = undefined;
    }
    if (method) {
        typeName = object;
        methodName = method;
    }
    if (method === '<anonymous>') {
        methodName = undefined;
        functionName = undefined;
    }
    if (functionName === undefined) {
        methodName = methodName || '<anonymous>';
        functionName = typeName ? typeName + "." + methodName : methodName;
    }
    var filename = ((_a = lineMatch[2]) === null || _a === void 0 ? void 0 : _a.startsWith('file://')) ? lineMatch[2].substr(7) : lineMatch[2];
    var isNative = lineMatch[5] === 'native';
    var isInternal = isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\') !== 1);
    // in_app is all that's not an internal Node function or a module within node_modules
    // note that isNative appears to return true even for node core libraries
    // see https://github.com/getsentry/raven-node/issues/176
    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');
    return {
        filename: filename,
        module: getModule(filename),
        function: functionName,
        lineno: parseInt(lineMatch[3], 10) || undefined,
        colno: parseInt(lineMatch[4], 10) || undefined,
        in_app: in_app,
    };
};
exports.nodeStackParser = [90, node];
//# sourceMappingURL=stack-parser.js.map{"version":3,"file":"stack-parser.js","sourceRoot":"","sources":["../../src/stack-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { basename, dirname, StackLineParser, StackLineParserFn } from '@sentry/utils';\n\n/** Gets the module */\nfunction getModule(filename: string | undefined): string | undefined {\n  if (!filename) {\n    return;\n  }\n\n  // We could use optional chaining here but webpack does like that mixed with require\n  const base = `${\n    (require && require.main && require.main.filename && dirname(require.main.filename)) || global.process.cwd()\n  }/`;\n\n  // It's specifically a module\n  const file = basename(filename, '.js');\n\n  const path = dirname(filename);\n  let n = path.lastIndexOf('/node_modules/');\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return `${path.substr(n + 14).replace(/\\//g, '.')}:${file}`;\n  }\n  // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n  n = `${path}/`.lastIndexOf(base, 0);\n\n  if (n === 0) {\n    let moduleName = path.substr(base.length).replace(/\\//g, '.');\n    if (moduleName) {\n      moduleName += ':';\n    }\n    moduleName += file;\n    return moduleName;\n  }\n  return file;\n}\n\nconst FILENAME_MATCH = /^\\s*[-]{4,}$/;\nconst FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\n\n// eslint-disable-next-line complexity\nconst node: StackLineParserFn = (line: string) => {\n  if (line.match(FILENAME_MATCH)) {\n    return {\n      filename: line,\n    };\n  }\n\n  const lineMatch = line.match(FULL_MATCH);\n  if (!lineMatch) {\n    return undefined;\n  }\n\n  let object: string | undefined;\n  let method: string | undefined;\n  let functionName: string | undefined;\n  let typeName: string | undefined;\n  let methodName: string | undefined;\n\n  if (lineMatch[1]) {\n    functionName = lineMatch[1];\n\n    let methodStart = functionName.lastIndexOf('.');\n    if (functionName[methodStart - 1] === '.') {\n      // eslint-disable-next-line no-plusplus\n      methodStart--;\n    }\n\n    if (methodStart > 0) {\n      object = functionName.substr(0, methodStart);\n      method = functionName.substr(methodStart + 1);\n      const objectEnd = object.indexOf('.Module');\n      if (objectEnd > 0) {\n        functionName = functionName.substr(objectEnd + 1);\n        object = object.substr(0, objectEnd);\n      }\n    }\n    typeName = undefined;\n  }\n\n  if (method) {\n    typeName = object;\n    methodName = method;\n  }\n\n  if (method === '<anonymous>') {\n    methodName = undefined;\n    functionName = undefined;\n  }\n\n  if (functionName === undefined) {\n    methodName = methodName || '<anonymous>';\n    functionName = typeName ? `${typeName}.${methodName}` : methodName;\n  }\n\n  const filename = lineMatch[2]?.startsWith('file://') ? lineMatch[2].substr(7) : lineMatch[2];\n  const isNative = lineMatch[5] === 'native';\n  const isInternal =\n    isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n  // in_app is all that's not an internal Node function or a module within node_modules\n  // note that isNative appears to return true even for node core libraries\n  // see https://github.com/getsentry/raven-node/issues/176\n  const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n  return {\n    filename,\n    module: getModule(filename),\n    function: functionName,\n    lineno: parseInt(lineMatch[3], 10) || undefined,\n    colno: parseInt(lineMatch[4], 10) || undefined,\n    in_app,\n  };\n};\n\nexport const nodeStackParser: StackLineParser = [90, node];\n"]}/// <reference types="node" />
import { IncomingHttpHeaders, RequestOptions as HTTPRequestOptions } from 'http';
import { RequestOptions as HTTPSRequestOptions } from 'https';
import { URL } from 'url';
export declare type HTTPModuleRequestOptions = HTTPRequestOptions | HTTPSRequestOptions | string | URL;
/**
 * Cut version of http.IncomingMessage.
 * Some transports work in a special Javascript environment where http.IncomingMessage is not available.
 */
export interface HTTPModuleRequestIncomingMessage {
    headers: IncomingHttpHeaders;
    statusCode?: number;
    on(event: 'data' | 'end', listener: () => void): void;
    setEncoding(encoding: string): void;
}
/**
 * Cut version of http.ClientRequest.
 * Some transports work in a special Javascript environment where http.IncomingMessage is not available.
 */
export interface HTTPModuleClientRequest {
    end(chunk: string): void;
    on(event: 'error', listener: () => void): void;
}
/**
 * Internal used interface for typescript.
 * @hidden
 */
export interface HTTPModule {
    /**
     * Request wrapper
     * @param options These are {@see TransportOptions}
     * @param callback Callback when request is finished
     */
    request(options: HTTPModuleRequestOptions, callback?: (res: HTTPModuleRequestIncomingMessage) => void): HTTPModuleClientRequest;
}
//# sourceMappingURL=http-module.d.ts.map{"version":3,"file":"http-module.d.ts","sourceRoot":"","sources":["../../../../src/transports/base/http-module.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,mBAAmB,EAAE,cAAc,IAAI,kBAAkB,EAAE,MAAM,MAAM,CAAC;AACjF,OAAO,EAAE,cAAc,IAAI,mBAAmB,EAAE,MAAM,OAAO,CAAC;AAC9D,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAE1B,oBAAY,wBAAwB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,MAAM,GAAG,GAAG,CAAC;AAE/F;;;GAGG;AACH,MAAM,WAAW,gCAAgC;IAC/C,OAAO,EAAE,mBAAmB,CAAC;IAC7B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,EAAE,CAAC,KAAK,EAAE,MAAM,GAAG,KAAK,EAAE,QAAQ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;IACtD,WAAW,CAAC,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;CACrC;AAED;;;GAGG;AACH,MAAM,WAAW,uBAAuB;IACtC,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;CAChD;AAED;;;GAGG;AACH,MAAM,WAAW,UAAU;IACzB;;;;OAIG;IACH,OAAO,CACL,OAAO,EAAE,wBAAwB,EACjC,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE,gCAAgC,KAAK,IAAI,GACzD,uBAAuB,CAAC;CAW5B"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=http-module.js.map{"version":3,"file":"http-module.js","sourceRoot":"","sources":["../../../../src/transports/base/http-module.ts"],"names":[],"mappings":"","sourcesContent":["import { IncomingHttpHeaders, RequestOptions as HTTPRequestOptions } from 'http';\nimport { RequestOptions as HTTPSRequestOptions } from 'https';\nimport { URL } from 'url';\n\nexport type HTTPModuleRequestOptions = HTTPRequestOptions | HTTPSRequestOptions | string | URL;\n\n/**\n * Cut version of http.IncomingMessage.\n * Some transports work in a special Javascript environment where http.IncomingMessage is not available.\n */\nexport interface HTTPModuleRequestIncomingMessage {\n  headers: IncomingHttpHeaders;\n  statusCode?: number;\n  on(event: 'data' | 'end', listener: () => void): void;\n  setEncoding(encoding: string): void;\n}\n\n/**\n * Cut version of http.ClientRequest.\n * Some transports work in a special Javascript environment where http.IncomingMessage is not available.\n */\nexport interface HTTPModuleClientRequest {\n  end(chunk: string): void;\n  on(event: 'error', listener: () => void): void;\n}\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPModule {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: HTTPModuleRequestOptions,\n    callback?: (res: HTTPModuleRequestIncomingMessage) => void,\n  ): HTTPModuleClientRequest;\n\n  // This is the type for nodejs versions that handle the URL argument\n  // (v10.9.0+), but we do not use it just yet because we support older node\n  // versions:\n\n  // request(\n  //   url: string | URL,\n  //   options: http.RequestOptions | https.RequestOptions,\n  //   callback?: (res: http.IncomingMessage) => void,\n  // ): http.ClientRequest;\n}\n"]}/// <reference types="node" />
import { APIDetails } from '@sentry/core';
import { DsnProtocol, Event, Response, SentryRequest, SentryRequestType, Session, SessionAggregates, Transport, TransportOptions } from '@sentry/types';
import { PromiseBuffer } from '@sentry/utils';
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
import { HTTPModule } from './http-module';
export declare type URLParts = Pick<URL, 'hostname' | 'pathname' | 'port' | 'protocol'>;
export declare type UrlParser = (url: string) => URLParts;
/** Base Transport class implementation */
export declare abstract class BaseTransport implements Transport {
    options: TransportOptions;
    /** The Agent used for corresponding transport */
    module?: HTTPModule;
    /** The Agent used for corresponding transport */
    client?: http.Agent | https.Agent;
    /** API object */
    protected _api: APIDetails;
    /** A simple buffer holding all requests. */
    protected readonly _buffer: PromiseBuffer<Response>;
    /** Locks transport after receiving rate limits in a response */
    protected readonly _rateLimits: Record<string, Date>;
    /** Create instance and set this.dsn */
    constructor(options: TransportOptions);
    /** Default function used to parse URLs */
    urlParser: UrlParser;
    /**
     * @inheritDoc
     */
    sendEvent(_: Event): PromiseLike<Response>;
    /**
     * @inheritDoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Extracts proxy settings from client options and env variables.
     *
     * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.
     *
     * An order of priority for available protocols is:
     * `http`  => `options.httpProxy` | `process.env.http_proxy`
     * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`
     */
    protected _getProxy(protocol: DsnProtocol): string | undefined;
    /** Returns a build request option object used by request */
    protected _getRequestOptions(urlParts: URLParts): http.RequestOptions | https.RequestOptions;
    /**
     * Gets the time that given category is disabled until for rate limiting
     */
    protected _disabledUntil(requestType: SentryRequestType): Date;
    /**
     * Checks if a category is rate limited
     */
    protected _isRateLimited(requestType: SentryRequestType): boolean;
    /**
     * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.
     */
    protected _handleRateLimit(headers: Record<string, string | null>): boolean;
    /** JSDoc */
    protected _send(sentryRequest: SentryRequest, originalPayload?: Event | Session | SessionAggregates): Promise<Response>;
}
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/transports/base/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAkD,MAAM,cAAc,CAAC;AAC1F,OAAO,EACL,WAAW,EACX,KAAK,EACL,QAAQ,EACR,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,SAAS,EACT,gBAAgB,EACjB,MAAM,eAAe,CAAC;AACvB,OAAO,EAKL,aAAa,EAEd,MAAM,eAAe,CAAC;AAEvB,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAI1B,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAE3C,oBAAY,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,GAAG,MAAM,GAAG,UAAU,CAAC,CAAC;AAChF,oBAAY,SAAS,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,QAAQ,CAAC;AAWlD,0CAA0C;AAC1C,8BAAsB,aAAc,YAAW,SAAS;IAiB5B,OAAO,EAAE,gBAAgB;IAhBnD,iDAAiD;IAC1C,MAAM,CAAC,EAAE,UAAU,CAAC;IAE3B,iDAAiD;IAC1C,MAAM,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;IAEzC,iBAAiB;IACjB,SAAS,CAAC,IAAI,EAAE,UAAU,CAAC;IAE3B,4CAA4C;IAC5C,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAyB;IAE5E,gEAAgE;IAChE,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAM;IAE1D,uCAAuC;gBACb,OAAO,EAAE,gBAAgB;IAKnD,0CAA0C;IACnC,SAAS,EAAE,SAAS,CAAuB;IAElD;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAIpD;;;;;;;;OAQG;IACH,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,WAAW,GAAG,MAAM,GAAG,SAAS;IAmB9D,4DAA4D;IAC5D,SAAS,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,GAAG,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,cAAc;IAwB5F;;OAEG;IACH,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,iBAAiB,GAAG,IAAI;IAK9D;;OAEG;IACH,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,iBAAiB,GAAG,OAAO;IAIjE;;OAEG;IACH,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC,GAAG,OAAO;IAsC3E,YAAY;cACI,KAAK,CACnB,aAAa,EAAE,aAAa,EAC5B,eAAe,CAAC,EAAE,KAAK,GAAG,OAAO,GAAG,iBAAiB,GACpD,OAAO,CAAC,QAAQ,CAAC;CA2ErB"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var fs = require("fs");
var url_1 = require("url");
var flags_1 = require("../../flags");
var version_1 = require("../../version");
var CATEGORY_MAPPING = {
    event: 'error',
    transaction: 'transaction',
    session: 'session',
    attachment: 'attachment',
};
/** Base Transport class implementation */
var BaseTransport = /** @class */ (function () {
    /** Create instance and set this.dsn */
    function BaseTransport(options) {
        this.options = options;
        /** A simple buffer holding all requests. */
        this._buffer = utils_1.makePromiseBuffer(30);
        /** Locks transport after receiving rate limits in a response */
        this._rateLimits = {};
        /** Default function used to parse URLs */
        this.urlParser = function (url) { return new url_1.URL(url); };
        // eslint-disable-next-line deprecation/deprecation
        this._api = core_1.initAPIDetails(options.dsn, options._metadata, options.tunnel);
    }
    /**
     * @inheritDoc
     */
    BaseTransport.prototype.sendEvent = function (_) {
        throw new utils_1.SentryError('Transport Class has to implement `sendEvent` method.');
    };
    /**
     * @inheritDoc
     */
    BaseTransport.prototype.close = function (timeout) {
        return this._buffer.drain(timeout);
    };
    /**
     * Extracts proxy settings from client options and env variables.
     *
     * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.
     *
     * An order of priority for available protocols is:
     * `http`  => `options.httpProxy` | `process.env.http_proxy`
     * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`
     */
    BaseTransport.prototype._getProxy = function (protocol) {
        var e_1, _a;
        var _b = process.env, no_proxy = _b.no_proxy, http_proxy = _b.http_proxy, https_proxy = _b.https_proxy;
        var _c = this.options, httpProxy = _c.httpProxy, httpsProxy = _c.httpsProxy;
        var proxy = protocol === 'http' ? httpProxy || http_proxy : httpsProxy || httpProxy || https_proxy || http_proxy;
        if (!no_proxy) {
            return proxy;
        }
        var _d = this._api.dsn, host = _d.host, port = _d.port;
        try {
            for (var _e = tslib_1.__values(no_proxy.split(',')), _f = _e.next(); !_f.done; _f = _e.next()) {
                var np = _f.value;
                if (host.endsWith(np) || (host + ":" + port).endsWith(np)) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return proxy;
    };
    /** Returns a build request option object used by request */
    BaseTransport.prototype._getRequestOptions = function (urlParts) {
        var headers = tslib_1.__assign(tslib_1.__assign({}, core_1.getRequestHeaders(this._api.dsn, version_1.SDK_NAME, core_1.SDK_VERSION)), this.options.headers);
        var hostname = urlParts.hostname, pathname = urlParts.pathname, port = urlParts.port, protocol = urlParts.protocol;
        // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290
        // We ignore the query string on purpose
        var path = "" + pathname;
        return tslib_1.__assign({ agent: this.client, headers: headers,
            hostname: hostname, method: 'POST', path: path,
            port: port,
            protocol: protocol }, (this.options.caCerts && {
            ca: fs.readFileSync(this.options.caCerts),
        }));
    };
    /**
     * Gets the time that given category is disabled until for rate limiting
     */
    BaseTransport.prototype._disabledUntil = function (requestType) {
        var category = CATEGORY_MAPPING[requestType];
        return this._rateLimits[category] || this._rateLimits.all;
    };
    /**
     * Checks if a category is rate limited
     */
    BaseTransport.prototype._isRateLimited = function (requestType) {
        return this._disabledUntil(requestType) > new Date(Date.now());
    };
    /**
     * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.
     */
    BaseTransport.prototype._handleRateLimit = function (headers) {
        var e_2, _a, e_3, _b;
        var now = Date.now();
        var rlHeader = headers['x-sentry-rate-limits'];
        var raHeader = headers['retry-after'];
        if (rlHeader) {
            try {
                // rate limit headers are of the form
                //     <header>,<header>,..
                // where each <header> is of the form
                //     <retry_after>: <categories>: <scope>: <reason_code>
                // where
                //     <retry_after> is a delay in ms
                //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
                //         <category>;<category>;...
                //     <scope> is what's being limited (org, project, or key) - ignored by SDK
                //     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
                for (var _c = tslib_1.__values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var limit = _d.value;
                    var parameters = limit.split(':', 2);
                    var headerDelay = parseInt(parameters[0], 10);
                    var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
                    try {
                        for (var _e = (e_3 = void 0, tslib_1.__values((parameters[1] && parameters[1].split(';')) || ['all'])), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var category = _f.value;
                            // categoriesAllowed is added here to ensure we are only storing rate limits for categories we support in this
                            // sdk and any categories that are not supported will not be added redundantly to the rateLimits object
                            var categoriesAllowed = tslib_1.__spread(Object.keys(CATEGORY_MAPPING).map(function (k) { return CATEGORY_MAPPING[k]; }), [
                                'all',
                            ]);
                            if (categoriesAllowed.includes(category))
                                this._rateLimits[category] = new Date(now + delay);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return true;
        }
        else if (raHeader) {
            this._rateLimits.all = new Date(now + utils_1.parseRetryAfterHeader(raHeader, now));
            return true;
        }
        return false;
    };
    /** JSDoc */
    BaseTransport.prototype._send = function (sentryRequest, originalPayload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                if (!this.module) {
                    throw new utils_1.SentryError('No module available');
                }
                if (originalPayload && this._isRateLimited(sentryRequest.type)) {
                    return [2 /*return*/, Promise.reject({
                            payload: originalPayload,
                            type: sentryRequest.type,
                            reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
                            status: 429,
                        })];
                }
                return [2 /*return*/, this._buffer.add(function () {
                        return new Promise(function (resolve, reject) {
                            if (!_this.module) {
                                throw new utils_1.SentryError('No module available');
                            }
                            var options = _this._getRequestOptions(_this.urlParser(sentryRequest.url));
                            var req = _this.module.request(options, function (res) {
                                var statusCode = res.statusCode || 500;
                                var status = utils_1.eventStatusFromHttpCode(statusCode);
                                res.setEncoding('utf8');
                                /**
                                 * "Key-value pairs of header names and values. Header names are lower-cased."
                                 * https://nodejs.org/api/http.html#http_message_headers
                                 */
                                var retryAfterHeader = res.headers ? res.headers['retry-after'] : '';
                                retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader);
                                var rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';
                                rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader);
                                var headers = {
                                    'x-sentry-rate-limits': rlHeader,
                                    'retry-after': retryAfterHeader,
                                };
                                var limited = _this._handleRateLimit(headers);
                                if (limited)
                                    flags_1.IS_DEBUG_BUILD &&
                                        utils_1.logger.warn("Too many " + sentryRequest.type + " requests, backing off until: " + _this._disabledUntil(sentryRequest.type));
                                if (status === 'success') {
                                    resolve({ status: status });
                                }
                                else {
                                    var rejectionMessage = "HTTP Error (" + statusCode + ")";
                                    if (res.headers && res.headers['x-sentry-error']) {
                                        rejectionMessage += ": " + res.headers['x-sentry-error'];
                                    }
                                    reject(new utils_1.SentryError(rejectionMessage));
                                }
                                // Force the socket to drain
                                res.on('data', function () {
                                    // Drain
                                });
                                res.on('end', function () {
                                    // Drain
                                });
                            });
                            req.on('error', reject);
                            req.end(sentryRequest.body);
                        });
                    })];
            });
        });
    };
    return BaseTransport;
}());
exports.BaseTransport = BaseTransport;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/transports/base/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { APIDetails, getRequestHeaders, initAPIDetails, SDK_VERSION } from '@sentry/core';\nimport {\n  DsnProtocol,\n  Event,\n  Response,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  SessionAggregates,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport {\n  eventStatusFromHttpCode,\n  logger,\n  makePromiseBuffer,\n  parseRetryAfterHeader,\n  PromiseBuffer,\n  SentryError,\n} from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\nimport { SDK_NAME } from '../../version';\nimport { HTTPModule } from './http-module';\n\nexport type URLParts = Pick<URL, 'hostname' | 'pathname' | 'port' | 'protocol'>;\nexport type UrlParser = (url: string) => URLParts;\n\nconst CATEGORY_MAPPING: {\n  [key in SentryRequestType]: string;\n} = {\n  event: 'error',\n  transaction: 'transaction',\n  session: 'session',\n  attachment: 'attachment',\n};\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPModule;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** API object */\n  protected _api: APIDetails;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = makePromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected readonly _rateLimits: Record<string, Date> = {};\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {\n    // eslint-disable-next-line deprecation/deprecation\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n  }\n\n  /** Default function used to parse URLs */\n  public urlParser: UrlParser = url => new URL(url);\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * Extracts proxy settings from client options and env variables.\n   *\n   * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.\n   *\n   * An order of priority for available protocols is:\n   * `http`  => `options.httpProxy` | `process.env.http_proxy`\n   * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`\n   */\n  protected _getProxy(protocol: DsnProtocol): string | undefined {\n    const { no_proxy, http_proxy, https_proxy } = process.env;\n    const { httpProxy, httpsProxy } = this.options;\n    const proxy = protocol === 'http' ? httpProxy || http_proxy : httpsProxy || httpProxy || https_proxy || http_proxy;\n\n    if (!no_proxy) {\n      return proxy;\n    }\n\n    const { host, port } = this._api.dsn;\n    for (const np of no_proxy.split(',')) {\n      if (host.endsWith(np) || `${host}:${port}`.endsWith(np)) {\n        return;\n      }\n    }\n\n    return proxy;\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(urlParts: URLParts): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...getRequestHeaders(this._api.dsn, SDK_NAME, SDK_VERSION),\n      ...this.options.headers,\n    };\n    const { hostname, pathname, port, protocol } = urlParts;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    const path = `${pathname}`;\n\n    return {\n      agent: this.client,\n      headers,\n      hostname,\n      method: 'POST',\n      path,\n      port,\n      protocol,\n      ...(this.options.caCerts && {\n        ca: fs.readFileSync(this.options.caCerts),\n      }),\n    };\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = CATEGORY_MAPPING[requestType];\n    return this._rateLimits[category] || this._rateLimits.all;\n  }\n\n  /**\n   * Checks if a category is rate limited\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  protected _handleRateLimit(headers: Record<string, string | null>): boolean {\n    const now = Date.now();\n    const rlHeader = headers['x-sentry-rate-limits'];\n    const raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      // rate limit headers are of the form\n      //     <header>,<header>,..\n      // where each <header> is of the form\n      //     <retry_after>: <categories>: <scope>: <reason_code>\n      // where\n      //     <retry_after> is a delay in ms\n      //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n      //         <category>;<category>;...\n      //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n      //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n      for (const limit of rlHeader.trim().split(',')) {\n        const parameters = limit.split(':', 2);\n        const headerDelay = parseInt(parameters[0], 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        for (const category of (parameters[1] && parameters[1].split(';')) || ['all']) {\n          // categoriesAllowed is added here to ensure we are only storing rate limits for categories we support in this\n          // sdk and any categories that are not supported will not be added redundantly to the rateLimits object\n          const categoriesAllowed = [\n            ...(Object.keys(CATEGORY_MAPPING) as [SentryRequestType]).map(k => CATEGORY_MAPPING[k]),\n            'all',\n          ];\n          if (categoriesAllowed.includes(category)) this._rateLimits[category] = new Date(now + delay);\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(raHeader, now));\n      return true;\n    }\n    return false;\n  }\n\n  /** JSDoc */\n  protected async _send(\n    sentryRequest: SentryRequest,\n    originalPayload?: Event | Session | SessionAggregates,\n  ): Promise<Response> {\n    if (!this.module) {\n      throw new SentryError('No module available');\n    }\n    if (originalPayload && this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        payload: originalPayload,\n        type: sentryRequest.type,\n        reason: `Transport for ${sentryRequest.type} requests locked till ${this._disabledUntil(\n          sentryRequest.type,\n        )} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    return this._buffer.add(\n      () =>\n        new Promise<Response>((resolve, reject) => {\n          if (!this.module) {\n            throw new SentryError('No module available');\n          }\n          const options = this._getRequestOptions(this.urlParser(sentryRequest.url));\n          const req = this.module.request(options, res => {\n            const statusCode = res.statusCode || 500;\n            const status = eventStatusFromHttpCode(statusCode);\n\n            res.setEncoding('utf8');\n\n            /**\n             * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n             * https://nodejs.org/api/http.html#http_message_headers\n             */\n            let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n            retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n\n            let rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';\n            rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader) as string;\n\n            const headers = {\n              'x-sentry-rate-limits': rlHeader,\n              'retry-after': retryAfterHeader,\n            };\n\n            const limited = this._handleRateLimit(headers);\n            if (limited)\n              IS_DEBUG_BUILD &&\n                logger.warn(\n                  `Too many ${sentryRequest.type} requests, backing off until: ${this._disabledUntil(\n                    sentryRequest.type,\n                  )}`,\n                );\n\n            if (status === 'success') {\n              resolve({ status });\n            } else {\n              let rejectionMessage = `HTTP Error (${statusCode})`;\n              if (res.headers && res.headers['x-sentry-error']) {\n                rejectionMessage += `: ${res.headers['x-sentry-error']}`;\n              }\n              reject(new SentryError(rejectionMessage));\n            }\n\n            // Force the socket to drain\n            res.on('data', () => {\n              // Drain\n            });\n            res.on('end', () => {\n              // Drain\n            });\n          });\n          req.on('error', reject);\n          req.end(sentryRequest.body);\n        }),\n    );\n  }\n}\n"]}import { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';
import { BaseTransport } from './base';
/** Node http module transport */
export declare class HTTPTransport extends BaseTransport {
    options: TransportOptions;
    /** Create a new instance and set this.agent */
    constructor(options: TransportOptions);
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): Promise<Response>;
    /**
     * @inheritDoc
     */
    sendSession(session: Session | SessionAggregates): PromiseLike<Response>;
}
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/transports/http.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAG9F,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,iCAAiC;AACjC,qBAAa,aAAc,SAAQ,aAAa;IAEpB,OAAO,EAAE,gBAAgB;IADnD,+CAA+C;gBACrB,OAAO,EAAE,gBAAgB;IASnD;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC;CAGhF"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var http = require("http");
var base_1 = require("./base");
/** Node http module transport */
var HTTPTransport = /** @class */ (function (_super) {
    tslib_1.__extends(HTTPTransport, _super);
    /** Create a new instance and set this.agent */
    function HTTPTransport(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        var proxy = _this._getProxy('http');
        _this.module = http;
        _this.client = proxy
            ? new (require('https-proxy-agent'))(proxy)
            : new http.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });
        return _this;
    }
    /**
     * @inheritDoc
     */
    HTTPTransport.prototype.sendEvent = function (event) {
        return this._send(core_1.eventToSentryRequest(event, this._api), event);
    };
    /**
     * @inheritDoc
     */
    HTTPTransport.prototype.sendSession = function (session) {
        return this._send(core_1.sessionToSentryRequest(session, this._api), session);
    };
    return HTTPTransport;
}(base_1.BaseTransport));
exports.HTTPTransport = HTTPTransport;
//# sourceMappingURL=http.js.map{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../src/transports/http.ts"],"names":[],"mappings":";;AAAA,qCAA4E;AAE5E,2BAA6B;AAE7B,+BAAuC;AAEvC,iCAAiC;AACjC;IAAmC,yCAAa;IAC9C,+CAA+C;IAC/C,uBAA0B,OAAyB;QAAnD,YACE,kBAAM,OAAO,CAAC,SAMf;QAPyB,aAAO,GAAP,OAAO,CAAkB;QAEjD,IAAM,KAAK,GAAG,KAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QACrC,KAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,KAAI,CAAC,MAAM,GAAG,KAAK;YACjB,CAAC,CAAE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAgB;YAC3D,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;;IAC1E,CAAC;IAED;;OAEG;IACI,iCAAS,GAAhB,UAAiB,KAAY;QAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,2BAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,mCAAW,GAAlB,UAAmB,OAAoC;QACrD,OAAO,IAAI,CAAC,KAAK,CAAC,6BAAsB,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IACzE,CAAC;IACH,oBAAC;AAAD,CAAC,AAxBD,CAAmC,oBAAa,GAwB/C;AAxBY,sCAAa","sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';\nimport * as http from 'http';\n\nimport { BaseTransport } from './base';\n\n/** Node http module transport */\nexport class HTTPTransport extends BaseTransport {\n  /** Create a new instance and set this.agent */\n  public constructor(public options: TransportOptions) {\n    super(options);\n    const proxy = this._getProxy('http');\n    this.module = http;\n    this.client = proxy\n      ? (new (require('https-proxy-agent'))(proxy) as http.Agent)\n      : new http.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): Promise<Response> {\n    return this._send(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): PromiseLike<Response> {\n    return this._send(sessionToSentryRequest(session, this._api), session);\n  }\n}\n"]}import { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';
import { BaseTransport } from './base';
/** Node https module transport */
export declare class HTTPSTransport extends BaseTransport {
    options: TransportOptions;
    /** Create a new instance and set this.agent */
    constructor(options: TransportOptions);
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): Promise<Response>;
    /**
     * @inheritDoc
     */
    sendSession(session: Session | SessionAggregates): PromiseLike<Response>;
}
//# sourceMappingURL=https.d.ts.map{"version":3,"file":"https.d.ts","sourceRoot":"","sources":["../../../src/transports/https.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAG9F,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,kCAAkC;AAClC,qBAAa,cAAe,SAAQ,aAAa;IAErB,OAAO,EAAE,gBAAgB;IADnD,+CAA+C;gBACrB,OAAO,EAAE,gBAAgB;IASnD;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC;CAGhF"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var https = require("https");
var base_1 = require("./base");
/** Node https module transport */
var HTTPSTransport = /** @class */ (function (_super) {
    tslib_1.__extends(HTTPSTransport, _super);
    /** Create a new instance and set this.agent */
    function HTTPSTransport(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        var proxy = _this._getProxy('https');
        _this.module = https;
        _this.client = proxy
            ? new (require('https-proxy-agent'))(proxy)
            : new https.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });
        return _this;
    }
    /**
     * @inheritDoc
     */
    HTTPSTransport.prototype.sendEvent = function (event) {
        return this._send(core_1.eventToSentryRequest(event, this._api), event);
    };
    /**
     * @inheritDoc
     */
    HTTPSTransport.prototype.sendSession = function (session) {
        return this._send(core_1.sessionToSentryRequest(session, this._api), session);
    };
    return HTTPSTransport;
}(base_1.BaseTransport));
exports.HTTPSTransport = HTTPSTransport;
//# sourceMappingURL=https.js.map{"version":3,"file":"https.js","sourceRoot":"","sources":["../../../src/transports/https.ts"],"names":[],"mappings":";;AAAA,qCAA4E;AAE5E,6BAA+B;AAE/B,+BAAuC;AAEvC,kCAAkC;AAClC;IAAoC,0CAAa;IAC/C,+CAA+C;IAC/C,wBAA0B,OAAyB;QAAnD,YACE,kBAAM,OAAO,CAAC,SAMf;QAPyB,aAAO,GAAP,OAAO,CAAkB;QAEjD,IAAM,KAAK,GAAG,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QACtC,KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,KAAI,CAAC,MAAM,GAAG,KAAK;YACjB,CAAC,CAAE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAiB;YAC5D,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;;IAC3E,CAAC;IAED;;OAEG;IACI,kCAAS,GAAhB,UAAiB,KAAY;QAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,2BAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,oCAAW,GAAlB,UAAmB,OAAoC;QACrD,OAAO,IAAI,CAAC,KAAK,CAAC,6BAAsB,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IACzE,CAAC;IACH,qBAAC;AAAD,CAAC,AAxBD,CAAoC,oBAAa,GAwBhD;AAxBY,wCAAc","sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';\nimport * as https from 'https';\n\nimport { BaseTransport } from './base';\n\n/** Node https module transport */\nexport class HTTPSTransport extends BaseTransport {\n  /** Create a new instance and set this.agent */\n  public constructor(public options: TransportOptions) {\n    super(options);\n    const proxy = this._getProxy('https');\n    this.module = https;\n    this.client = proxy\n      ? (new (require('https-proxy-agent'))(proxy) as https.Agent)\n      : new https.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): Promise<Response> {\n    return this._send(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): PromiseLike<Response> {\n    return this._send(sessionToSentryRequest(session, this._api), session);\n  }\n}\n"]}export { BaseTransport } from './base';
export { HTTPTransport } from './http';
export { HTTPSTransport } from './https';
export { makeNodeTransport, NodeTransportOptions } from './new';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/transports/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,MAAM,OAAO,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var base_1 = require("./base");
exports.BaseTransport = base_1.BaseTransport;
var http_1 = require("./http");
exports.HTTPTransport = http_1.HTTPTransport;
var https_1 = require("./https");
exports.HTTPSTransport = https_1.HTTPSTransport;
var new_1 = require("./new");
exports.makeNodeTransport = new_1.makeNodeTransport;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/transports/index.ts"],"names":[],"mappings":";AAAA,+BAAuC;AAA9B,+BAAA,aAAa,CAAA;AACtB,+BAAuC;AAA9B,+BAAA,aAAa,CAAA;AACtB,iCAAyC;AAAhC,iCAAA,cAAc,CAAA;AACvB,6BAAgE;AAAvD,kCAAA,iBAAiB,CAAA","sourcesContent":["export { BaseTransport } from './base';\nexport { HTTPTransport } from './http';\nexport { HTTPSTransport } from './https';\nexport { makeNodeTransport, NodeTransportOptions } from './new';\n"]}/// <reference types="node" />
import { BaseTransportOptions, NewTransport } from '@sentry/core';
import { HTTPModule } from './base/http-module';
export interface NodeTransportOptions extends BaseTransportOptions {
    /** Define custom headers */
    headers?: Record<string, string>;
    /** Set a proxy that should be used for outbound requests. */
    proxy?: string;
    /** HTTPS proxy CA certificates */
    caCerts?: string | Buffer | Array<string | Buffer>;
    /** Custom HTTP module. Defaults to the native 'http' and 'https' modules. */
    httpModule?: HTTPModule;
}
/**
 * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.
 */
export declare function makeNodeTransport(options: NodeTransportOptions): NewTransport;
//# sourceMappingURL=new.d.ts.map{"version":3,"file":"new.d.ts","sourceRoot":"","sources":["../../../src/transports/new.ts"],"names":[],"mappings":";AAAA,OAAO,EACL,oBAAoB,EAEpB,YAAY,EAIb,MAAM,cAAc,CAAC;AAMtB,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAShD,MAAM,WAAW,oBAAqB,SAAQ,oBAAoB;IAChE,4BAA4B;IAC5B,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACjC,6DAA6D;IAC7D,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,kCAAkC;IAClC,OAAO,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACnD,6EAA6E;IAC7E,UAAU,CAAC,EAAE,UAAU,CAAC;CACzB;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,OAAO,EAAE,oBAAoB,GAAG,YAAY,CAqB7E"}Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@sentry/core");
var utils_1 = require("@sentry/utils");
var http = require("http");
var https = require("https");
var url_1 = require("url");
/**
 * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.
 */
function makeNodeTransport(options) {
    var _a;
    var urlSegments = new url_1.URL(options.url);
    var isHttps = urlSegments.protocol === 'https:';
    // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`
    // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`
    var proxy = applyNoProxyOption(urlSegments, options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy);
    var nativeHttpModule = isHttps ? https : http;
    // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node
    // versions(>= 8) as they had memory leaks when using it: #2555
    var agent = proxy
        ? new (require('https-proxy-agent'))(proxy)
        : new nativeHttpModule.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });
    var requestExecutor = createRequestExecutor(options, (_a = options.httpModule, (_a !== null && _a !== void 0 ? _a : nativeHttpModule)), agent);
    return core_1.createTransport({ bufferSize: options.bufferSize }, requestExecutor);
}
exports.makeNodeTransport = makeNodeTransport;
/**
 * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.
 *
 * @param transportUrl The URL the transport intends to send events to.
 * @param proxy The client configured proxy.
 * @returns A proxy the transport should use.
 */
function applyNoProxyOption(transportUrlSegments, proxy) {
    var no_proxy = process.env.no_proxy;
    var urlIsExemptFromProxy = no_proxy &&
        no_proxy
            .split(',')
            .some(function (exemption) { return transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption); });
    if (urlIsExemptFromProxy) {
        return undefined;
    }
    else {
        return proxy;
    }
}
/**
 * Creates a RequestExecutor to be used with `createTransport`.
 */
function createRequestExecutor(options, httpModule, agent) {
    var _a = new url_1.URL(options.url), hostname = _a.hostname, pathname = _a.pathname, port = _a.port, protocol = _a.protocol, search = _a.search;
    return function makeRequest(request) {
        return new Promise(function (resolve, reject) {
            var req = httpModule.request({
                method: 'POST',
                agent: agent,
                headers: options.headers,
                hostname: hostname,
                path: "" + pathname + search,
                port: port,
                protocol: protocol,
                ca: options.caCerts,
            }, function (res) {
                var _a, _b, _c;
                res.on('data', function () {
                    // Drain socket
                });
                res.on('end', function () {
                    // Drain socket
                });
                var statusCode = (_a = res.statusCode, (_a !== null && _a !== void 0 ? _a : 500));
                var status = utils_1.eventStatusFromHttpCode(statusCode);
                res.setEncoding('utf8');
                // "Key-value pairs of header names and values. Header names are lower-cased."
                // https://nodejs.org/api/http.html#http_message_headers
                var retryAfterHeader = (_b = res.headers['retry-after'], (_b !== null && _b !== void 0 ? _b : null));
                var rateLimitsHeader = (_c = res.headers['x-sentry-rate-limits'], (_c !== null && _c !== void 0 ? _c : null));
                resolve({
                    headers: {
                        'retry-after': retryAfterHeader,
                        'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader,
                    },
                    reason: status,
                    statusCode: statusCode,
                });
            });
            req.on('error', reject);
            req.end(request.body);
        });
    };
}
//# sourceMappingURL=new.js.map{"version":3,"file":"new.js","sourceRoot":"","sources":["../../../src/transports/new.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BaseTransportOptions,\n  createTransport,\n  NewTransport,\n  TransportMakeRequestResponse,\n  TransportRequest,\n  TransportRequestExecutor,\n} from '@sentry/core';\nimport { eventStatusFromHttpCode } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\n\nimport { HTTPModule } from './base/http-module';\n\n// TODO(v7):\n// - Rename this file \"transport.ts\"\n// - Move this file one folder upwards\n// - Delete \"transports\" folder\n// OR\n// - Split this file up and leave it in the transports folder\n\nexport interface NodeTransportOptions extends BaseTransportOptions {\n  /** Define custom headers */\n  headers?: Record<string, string>;\n  /** Set a proxy that should be used for outbound requests. */\n  proxy?: string;\n  /** HTTPS proxy CA certificates */\n  caCerts?: string | Buffer | Array<string | Buffer>;\n  /** Custom HTTP module. Defaults to the native 'http' and 'https' modules. */\n  httpModule?: HTTPModule;\n}\n\n/**\n * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.\n */\nexport function makeNodeTransport(options: NodeTransportOptions): NewTransport {\n  const urlSegments = new URL(options.url);\n  const isHttps = urlSegments.protocol === 'https:';\n\n  // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`\n  // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`\n  const proxy = applyNoProxyOption(\n    urlSegments,\n    options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy,\n  );\n\n  const nativeHttpModule = isHttps ? https : http;\n\n  // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node\n  // versions(>= 8) as they had memory leaks when using it: #2555\n  const agent = proxy\n    ? (new (require('https-proxy-agent'))(proxy) as http.Agent)\n    : new nativeHttpModule.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });\n\n  const requestExecutor = createRequestExecutor(options, options.httpModule ?? nativeHttpModule, agent);\n  return createTransport({ bufferSize: options.bufferSize }, requestExecutor);\n}\n\n/**\n * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.\n *\n * @param transportUrl The URL the transport intends to send events to.\n * @param proxy The client configured proxy.\n * @returns A proxy the transport should use.\n */\nfunction applyNoProxyOption(transportUrlSegments: URL, proxy: string | undefined): string | undefined {\n  const { no_proxy } = process.env;\n\n  const urlIsExemptFromProxy =\n    no_proxy &&\n    no_proxy\n      .split(',')\n      .some(\n        exemption => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption),\n      );\n\n  if (urlIsExemptFromProxy) {\n    return undefined;\n  } else {\n    return proxy;\n  }\n}\n\n/**\n * Creates a RequestExecutor to be used with `createTransport`.\n */\nfunction createRequestExecutor(\n  options: NodeTransportOptions,\n  httpModule: HTTPModule,\n  agent: http.Agent,\n): TransportRequestExecutor {\n  const { hostname, pathname, port, protocol, search } = new URL(options.url);\n\n  return function makeRequest(request: TransportRequest): Promise<TransportMakeRequestResponse> {\n    return new Promise((resolve, reject) => {\n      const req = httpModule.request(\n        {\n          method: 'POST',\n          agent,\n          headers: options.headers,\n          hostname,\n          path: `${pathname}${search}`,\n          port,\n          protocol,\n          ca: options.caCerts,\n        },\n        res => {\n          res.on('data', () => {\n            // Drain socket\n          });\n\n          res.on('end', () => {\n            // Drain socket\n          });\n\n          const statusCode = res.statusCode ?? 500;\n          const status = eventStatusFromHttpCode(statusCode);\n\n          res.setEncoding('utf8');\n\n          // \"Key-value pairs of header names and values. Header names are lower-cased.\"\n          // https://nodejs.org/api/http.html#http_message_headers\n          const retryAfterHeader = res.headers['retry-after'] ?? null;\n          const rateLimitsHeader = res.headers['x-sentry-rate-limits'] ?? null;\n\n          resolve({\n            headers: {\n              'retry-after': retryAfterHeader,\n              'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader,\n            },\n            reason: status,\n            statusCode: statusCode,\n          });\n        },\n      );\n\n      req.on('error', reject);\n      req.end(request.body);\n    });\n  };\n}\n"]}import { Options } from '@sentry/types';
/**
 * Configuration options for the Sentry Node SDK.
 * @see NodeClient for more information.
 */
export interface NodeOptions extends Options {
    /** Sets an optional server name (device name) */
    serverName?: string;
    /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */
    shutdownTimeout?: number;
    /** Set a HTTP proxy that should be used for outbound requests. */
    httpProxy?: string;
    /** Set a HTTPS proxy that should be used for outbound requests. */
    httpsProxy?: string;
    /** HTTPS proxy certificates path */
    caCerts?: string;
    /**
     * Sets the number of context lines for each frame when loading a file.
     *
     * @deprecated Context lines configuration has moved to the `ContextLines` integration, and can be used like this:
     *
     * ```
     * init({
     *   dsn: '__DSN__',
     *   integrations: [new ContextLines({ frameContextLines: 10 })]
     * })
     * ```
     *
     * */
    frameContextLines?: number;
    /** Callback that is executed when a fatal global error occurs. */
    onFatalError?(error: Error): void;
}
//# sourceMappingURL=types.d.ts.map{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAExC;;;GAGG;AACH,MAAM,WAAW,WAAY,SAAQ,OAAO;IAC1C,iDAAiD;IACjD,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,8GAA8G;IAC9G,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB,kEAAkE;IAClE,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB,mEAAmE;IACnE,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,oCAAoC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;;;;;;;;;;SAYK;IACL,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B,kEAAkE;IAClE,YAAY,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;CACnC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import { Options } from '@sentry/types';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   *\n   * @deprecated Context lines configuration has moved to the `ContextLines` integration, and can be used like this:\n   *\n   * ```\n   * init({\n   *   dsn: '__DSN__',\n   *   integrations: [new ContextLines({ frameContextLines: 10 })]\n   * })\n   * ```\n   *\n   * */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n"]}/**
 * Recursively read the contents of a directory.
 *
 * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this
 * directory.
 * @returns Array holding all relative paths
 */
export declare function deepReadDirSync(targetDir: string): string[];
//# sourceMappingURL=utils.d.ts.map{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"AAGA;;;;;;GAMG;AACH,wBAAgB,eAAe,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,CA2B3D"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs = require("fs");
var path = require("path");
/**
 * Recursively read the contents of a directory.
 *
 * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this
 * directory.
 * @returns Array holding all relative paths
 */
function deepReadDirSync(targetDir) {
    var targetDirAbsPath = path.resolve(targetDir);
    if (!fs.existsSync(targetDirAbsPath)) {
        throw new Error("Cannot read contents of " + targetDirAbsPath + ". Directory does not exist.");
    }
    if (!fs.statSync(targetDirAbsPath).isDirectory()) {
        throw new Error("Cannot read contents of " + targetDirAbsPath + ", because it is not a directory.");
    }
    // This does the same thing as its containing function, `deepReadDirSync` (except that - purely for convenience - it
    // deals in absolute paths rather than relative ones). We need this to be separate from the outer function to preserve
    // the difference between `targetDirAbsPath` and `currentDirAbsPath`.
    var deepReadCurrentDir = function (currentDirAbsPath) {
        return fs.readdirSync(currentDirAbsPath).reduce(function (absPaths, itemName) {
            var itemAbsPath = path.join(currentDirAbsPath, itemName);
            if (fs.statSync(itemAbsPath).isDirectory()) {
                return tslib_1.__spread(absPaths, deepReadCurrentDir(itemAbsPath));
            }
            return tslib_1.__spread(absPaths, [itemAbsPath]);
        }, []);
    };
    return deepReadCurrentDir(targetDirAbsPath).map(function (absPath) { return path.relative(targetDirAbsPath, absPath); });
}
exports.deepReadDirSync = deepReadDirSync;
//# sourceMappingURL=utils.js.map{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":";;AAAA,uBAAyB;AACzB,2BAA6B;AAE7B;;;;;;GAMG;AACH,SAAgB,eAAe,CAAC,SAAiB;IAC/C,IAAM,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAEjD,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,EAAE;QACpC,MAAM,IAAI,KAAK,CAAC,6BAA2B,gBAAgB,gCAA6B,CAAC,CAAC;KAC3F;IAED,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,WAAW,EAAE,EAAE;QAChD,MAAM,IAAI,KAAK,CAAC,6BAA2B,gBAAgB,qCAAkC,CAAC,CAAC;KAChG;IAED,oHAAoH;IACpH,sHAAsH;IACtH,qEAAqE;IACrE,IAAM,kBAAkB,GAAG,UAAC,iBAAyB;QACnD,OAAO,EAAE,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC,MAAM,CAAC,UAAC,QAAkB,EAAE,QAAgB;YACnF,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;YAE3D,IAAI,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,EAAE;gBAC1C,wBAAW,QAAQ,EAAK,kBAAkB,CAAC,WAAW,CAAC,EAAE;aAC1D;YAED,wBAAW,QAAQ,GAAE,WAAW,GAAE;QACpC,CAAC,EAAE,EAAE,CAAC,CAAC;IACT,CAAC,CAAC;IAEF,OAAO,kBAAkB,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,OAAO,CAAC,EAAxC,CAAwC,CAAC,CAAC;AACvG,CAAC;AA3BD,0CA2BC","sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Recursively read the contents of a directory.\n *\n * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this\n * directory.\n * @returns Array holding all relative paths\n */\nexport function deepReadDirSync(targetDir: string): string[] {\n  const targetDirAbsPath = path.resolve(targetDir);\n\n  if (!fs.existsSync(targetDirAbsPath)) {\n    throw new Error(`Cannot read contents of ${targetDirAbsPath}. Directory does not exist.`);\n  }\n\n  if (!fs.statSync(targetDirAbsPath).isDirectory()) {\n    throw new Error(`Cannot read contents of ${targetDirAbsPath}, because it is not a directory.`);\n  }\n\n  // This does the same thing as its containing function, `deepReadDirSync` (except that - purely for convenience - it\n  // deals in absolute paths rather than relative ones). We need this to be separate from the outer function to preserve\n  // the difference between `targetDirAbsPath` and `currentDirAbsPath`.\n  const deepReadCurrentDir = (currentDirAbsPath: string): string[] => {\n    return fs.readdirSync(currentDirAbsPath).reduce((absPaths: string[], itemName: string) => {\n      const itemAbsPath = path.join(currentDirAbsPath, itemName);\n\n      if (fs.statSync(itemAbsPath).isDirectory()) {\n        return [...absPaths, ...deepReadCurrentDir(itemAbsPath)];\n      }\n\n      return [...absPaths, itemAbsPath];\n    }, []);\n  };\n\n  return deepReadCurrentDir(targetDirAbsPath).map(absPath => path.relative(targetDirAbsPath, absPath));\n}\n"]}export declare const SDK_NAME = "sentry.javascript.node";
//# sourceMappingURL=version.d.ts.map{"version":3,"file":"version.d.ts","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AACA,eAAO,MAAM,QAAQ,2BAA2B,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
// TODO: Remove in the next major release and rely only on @sentry/core SDK_VERSION and SdkMetadata
exports.SDK_NAME = 'sentry.javascript.node';
//# sourceMappingURL=version.js.map{"version":3,"file":"version.js","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":";AAAA,mGAAmG;AACtF,QAAA,QAAQ,GAAG,wBAAwB,CAAC","sourcesContent":["// TODO: Remove in the next major release and rely only on @sentry/core SDK_VERSION and SdkMetadata\nexport const SDK_NAME = 'sentry.javascript.node';\n"]}import { BaseBackend } from '@sentry/core';
import { Event, EventHint, Severity, Transport } from '@sentry/types';
import { NodeOptions } from './types';
/**
 * The Sentry Node SDK Backend.
 * @hidden
 */
export declare class NodeBackend extends BaseBackend<NodeOptions> {
    /**
     * @inheritDoc
     */
    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    protected _setupTransport(): Transport;
}
//# sourceMappingURL=backend.d.ts.map{"version":3,"file":"backend.d.ts","sourceRoot":"","sources":["../../src/backend.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAyD,MAAM,cAAc,CAAC;AAClG,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAoB,MAAM,eAAe,CAAC;AAKxF,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC;;;GAGG;AACH,qBAAa,WAAY,SAAQ,WAAW,CAAC,WAAW,CAAC;IACvD;;OAEG;IAEI,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAI/E;;OAEG;IACI,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,GAAE,QAAwB,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAI/G;;OAEG;IACH,SAAS,CAAC,eAAe,IAAI,SAAS;CAqCvC"}import { __assign, __extends } from "tslib";
import { BaseBackend, getEnvelopeEndpointWithUrlEncodedAuth, initAPIDetails } from '@sentry/core';
import { Severity } from '@sentry/types';
import { makeDsn, resolvedSyncPromise } from '@sentry/utils';
import { eventFromMessage, eventFromUnknownInput } from './eventbuilder';
import { HTTPSTransport, HTTPTransport, makeNodeTransport } from './transports';
/**
 * The Sentry Node SDK Backend.
 * @hidden
 */
var NodeBackend = /** @class */ (function (_super) {
    __extends(NodeBackend, _super);
    function NodeBackend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    NodeBackend.prototype.eventFromException = function (exception, hint) {
        return resolvedSyncPromise(eventFromUnknownInput(exception, hint));
    };
    /**
     * @inheritDoc
     */
    NodeBackend.prototype.eventFromMessage = function (message, level, hint) {
        if (level === void 0) { level = Severity.Info; }
        return resolvedSyncPromise(eventFromMessage(message, level, hint, this._options.attachStacktrace));
    };
    /**
     * @inheritDoc
     */
    NodeBackend.prototype._setupTransport = function () {
        if (!this._options.dsn) {
            // We return the noop transport here in case there is no Dsn.
            return _super.prototype._setupTransport.call(this);
        }
        var dsn = makeDsn(this._options.dsn);
        var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), (this._options.httpProxy && { httpProxy: this._options.httpProxy })), (this._options.httpsProxy && { httpsProxy: this._options.httpsProxy })), (this._options.caCerts && { caCerts: this._options.caCerts })), { dsn: this._options.dsn, tunnel: this._options.tunnel, _metadata: this._options._metadata });
        if (this._options.transport) {
            return new this._options.transport(transportOptions);
        }
        var api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
        var url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);
        this._newTransport = makeNodeTransport({
            url: url,
            headers: transportOptions.headers,
            proxy: transportOptions.httpProxy,
            caCerts: transportOptions.caCerts,
        });
        if (dsn.protocol === 'http') {
            return new HTTPTransport(transportOptions);
        }
        return new HTTPSTransport(transportOptions);
    };
    return NodeBackend;
}(BaseBackend));
export { NodeBackend };
//# sourceMappingURL=backend.js.map{"version":3,"file":"backend.js","sourceRoot":"","sources":["../../src/backend.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,WAAW,EAAE,qCAAqC,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAClG,OAAO,EAAoB,QAAQ,EAA+B,MAAM,eAAe,CAAC;AACxF,OAAO,EAAE,OAAO,EAAE,mBAAmB,EAAE,MAAM,eAAe,CAAC;AAE7D,OAAO,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,MAAM,gBAAgB,CAAC;AACzE,OAAO,EAAE,cAAc,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,cAAc,CAAC;AAGhF;;;GAGG;AACH;IAAiC,+BAAwB;IAAzD;;IAwDA,CAAC;IAvDC;;OAEG;IACH,iHAAiH;IAC1G,wCAAkB,GAAzB,UAA0B,SAAc,EAAE,IAAgB;QACxD,OAAO,mBAAmB,CAAC,qBAAqB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;IACrE,CAAC;IAED;;OAEG;IACI,sCAAgB,GAAvB,UAAwB,OAAe,EAAE,KAA+B,EAAE,IAAgB;QAAjD,sBAAA,EAAA,QAAkB,QAAQ,CAAC,IAAI;QACtE,OAAO,mBAAmB,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC;IACrG,CAAC;IAED;;OAEG;IACO,qCAAe,GAAzB;QACE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;YACtB,6DAA6D;YAC7D,OAAO,iBAAM,eAAe,WAAE,CAAC;SAChC;QAED,IAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAEvC,IAAM,gBAAgB,oDACjB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAC9B,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,GACnE,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC,GACtE,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,KAChE,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EACtB,MAAM,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAC5B,SAAS,EAAE,IAAI,CAAC,QAAQ,CAAC,SAAS,GACnC,CAAC;QAEF,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;YAC3B,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;SACtD;QAED,IAAM,GAAG,GAAG,cAAc,CAAC,gBAAgB,CAAC,GAAG,EAAE,gBAAgB,CAAC,SAAS,EAAE,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACtG,IAAM,GAAG,GAAG,qCAAqC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;QAEvE,IAAI,CAAC,aAAa,GAAG,iBAAiB,CAAC;YACrC,GAAG,KAAA;YACH,OAAO,EAAE,gBAAgB,CAAC,OAAO;YACjC,KAAK,EAAE,gBAAgB,CAAC,SAAS;YACjC,OAAO,EAAE,gBAAgB,CAAC,OAAO;SAClC,CAAC,CAAC;QAEH,IAAI,GAAG,CAAC,QAAQ,KAAK,MAAM,EAAE;YAC3B,OAAO,IAAI,aAAa,CAAC,gBAAgB,CAAC,CAAC;SAC5C;QACD,OAAO,IAAI,cAAc,CAAC,gBAAgB,CAAC,CAAC;IAC9C,CAAC;IACH,kBAAC;AAAD,CAAC,AAxDD,CAAiC,WAAW,GAwD3C","sourcesContent":["import { BaseBackend, getEnvelopeEndpointWithUrlEncodedAuth, initAPIDetails } from '@sentry/core';\nimport { Event, EventHint, Severity, Transport, TransportOptions } from '@sentry/types';\nimport { makeDsn, resolvedSyncPromise } from '@sentry/utils';\n\nimport { eventFromMessage, eventFromUnknownInput } from './eventbuilder';\nimport { HTTPSTransport, HTTPTransport, makeNodeTransport } from './transports';\nimport { NodeOptions } from './types';\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    return resolvedSyncPromise(eventFromUnknownInput(exception, hint));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    return resolvedSyncPromise(eventFromMessage(message, level, hint, this._options.attachStacktrace));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = makeDsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n      tunnel: this._options.tunnel,\n      _metadata: this._options._metadata,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n\n    const api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);\n    const url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);\n\n    this._newTransport = makeNodeTransport({\n      url,\n      headers: transportOptions.headers,\n      proxy: transportOptions.httpProxy,\n      caCerts: transportOptions.caCerts,\n    });\n\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"]}import { BaseClient, Scope } from '@sentry/core';
import { SessionFlusher } from '@sentry/hub';
import { Event, EventHint } from '@sentry/types';
import { NodeBackend } from './backend';
import { NodeOptions } from './types';
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
export declare class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
    protected _sessionFlusher: SessionFlusher | undefined;
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    constructor(options: NodeOptions);
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     *
     * @inheritdoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /** Method that initialises an instance of SessionFlusher on Client */
    initSessionFlusher(): void;
    /**
     * @inheritDoc
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
     * appropriate session aggregates bucket
     */
    protected _captureRequestSession(): void;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,KAAK,EAAe,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAGjD,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC;;;;;GAKG;AACH,qBAAa,UAAW,SAAQ,UAAU,CAAC,WAAW,EAAE,WAAW,CAAC;IAClE,SAAS,CAAC,eAAe,EAAE,cAAc,GAAG,SAAS,CAAC;IAEtD;;;OAGG;gBACgB,OAAO,EAAE,WAAW;IAgBvC;;OAEG;IAEI,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAiB5F;;OAEG;IACI,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAwBtF;;;OAGG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAKpD,sEAAsE;IAC/D,kBAAkB,IAAI,IAAI;IAYjC;;OAEG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IAQjG;;;OAGG;IACH,SAAS,CAAC,sBAAsB,IAAI,IAAI;CAOzC"}import { __extends } from "tslib";
import { BaseClient, SDK_VERSION } from '@sentry/core';
import { SessionFlusher } from '@sentry/hub';
import { logger } from '@sentry/utils';
import { NodeBackend } from './backend';
import { IS_DEBUG_BUILD } from './flags';
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
var NodeClient = /** @class */ (function (_super) {
    __extends(NodeClient, _super);
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    function NodeClient(options) {
        var _this = this;
        options._metadata = options._metadata || {};
        options._metadata.sdk = options._metadata.sdk || {
            name: 'sentry.javascript.node',
            packages: [
                {
                    name: 'npm:@sentry/node',
                    version: SDK_VERSION,
                },
            ],
            version: SDK_VERSION,
        };
        _this = _super.call(this, NodeBackend, options) || this;
        return _this;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    NodeClient.prototype.captureException = function (exception, hint, scope) {
        // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only
        // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload
        // sent to the Server only when the `requestHandler` middleware is used
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
            var requestSession = scope.getRequestSession();
            // Necessary checks to ensure this is code block is executed only within a request
            // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage
            if (requestSession && requestSession.status === 'ok') {
                requestSession.status = 'errored';
            }
        }
        return _super.prototype.captureException.call(this, exception, hint, scope);
    };
    /**
     * @inheritDoc
     */
    NodeClient.prototype.captureEvent = function (event, hint, scope) {
        // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only
        // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload
        // sent to the Server only when the `requestHandler` middleware is used
        if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
            var eventType = event.type || 'exception';
            var isException = eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;
            // If the event is of type Exception, then a request session should be captured
            if (isException) {
                var requestSession = scope.getRequestSession();
                // Ensure that this is happening within the bounds of a request, and make sure not to override
                // Session Status if Errored / Crashed
                if (requestSession && requestSession.status === 'ok') {
                    requestSession.status = 'errored';
                }
            }
        }
        return _super.prototype.captureEvent.call(this, event, hint, scope);
    };
    /**
     *
     * @inheritdoc
     */
    NodeClient.prototype.close = function (timeout) {
        var _a;
        (_a = this._sessionFlusher) === null || _a === void 0 ? void 0 : _a.close();
        return _super.prototype.close.call(this, timeout);
    };
    /** Method that initialises an instance of SessionFlusher on Client */
    NodeClient.prototype.initSessionFlusher = function () {
        var _a = this._options, release = _a.release, environment = _a.environment;
        if (!release) {
            IS_DEBUG_BUILD && logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');
        }
        else {
            this._sessionFlusher = new SessionFlusher(this.getTransport(), {
                release: release,
                environment: environment,
            });
        }
    };
    /**
     * @inheritDoc
     */
    NodeClient.prototype._prepareEvent = function (event, scope, hint) {
        event.platform = event.platform || 'node';
        if (this.getOptions().serverName) {
            event.server_name = this.getOptions().serverName;
        }
        return _super.prototype._prepareEvent.call(this, event, scope, hint);
    };
    /**
     * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
     * appropriate session aggregates bucket
     */
    NodeClient.prototype._captureRequestSession = function () {
        if (!this._sessionFlusher) {
            IS_DEBUG_BUILD && logger.warn('Discarded request mode session because autoSessionTracking option was disabled');
        }
        else {
            this._sessionFlusher.incrementSessionStatusCount();
        }
    };
    return NodeClient;
}(BaseClient));
export { NodeClient };
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAS,WAAW,EAAE,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAE7C,OAAO,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAEvC,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AAGzC;;;;;GAKG;AACH;IAAgC,8BAAoC;IAGlE;;;OAGG;IACH,oBAAmB,OAAoB;QAAvC,iBAcC;QAbC,OAAO,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,EAAE,CAAC;QAC5C,OAAO,CAAC,SAAS,CAAC,GAAG,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI;YAC/C,IAAI,EAAE,wBAAwB;YAC9B,QAAQ,EAAE;gBACR;oBACE,IAAI,EAAE,kBAAkB;oBACxB,OAAO,EAAE,WAAW;iBACrB;aACF;YACD,OAAO,EAAE,WAAW;SACrB,CAAC;QAEF,QAAA,kBAAM,WAAW,EAAE,OAAO,CAAC,SAAC;;IAC9B,CAAC;IAED;;OAEG;IACH,iHAAiH;IAC1G,qCAAgB,GAAvB,UAAwB,SAAc,EAAE,IAAgB,EAAE,KAAa;QACrE,qHAAqH;QACrH,+GAA+G;QAC/G,uEAAuE;QACvE,IAAI,IAAI,CAAC,QAAQ,CAAC,mBAAmB,IAAI,IAAI,CAAC,eAAe,IAAI,KAAK,EAAE;YACtE,IAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAEjD,kFAAkF;YAClF,iGAAiG;YACjG,IAAI,cAAc,IAAI,cAAc,CAAC,MAAM,KAAK,IAAI,EAAE;gBACpD,cAAc,CAAC,MAAM,GAAG,SAAS,CAAC;aACnC;SACF;QAED,OAAO,iBAAM,gBAAgB,YAAC,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IACxD,CAAC;IAED;;OAEG;IACI,iCAAY,GAAnB,UAAoB,KAAY,EAAE,IAAgB,EAAE,KAAa;QAC/D,qHAAqH;QACrH,+GAA+G;QAC/G,uEAAuE;QACvE,IAAI,IAAI,CAAC,QAAQ,CAAC,mBAAmB,IAAI,IAAI,CAAC,eAAe,IAAI,KAAK,EAAE;YACtE,IAAM,SAAS,GAAG,KAAK,CAAC,IAAI,IAAI,WAAW,CAAC;YAC5C,IAAM,WAAW,GACf,SAAS,KAAK,WAAW,IAAI,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;YAE9G,+EAA+E;YAC/E,IAAI,WAAW,EAAE;gBACf,IAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;gBAEjD,8FAA8F;gBAC9F,sCAAsC;gBACtC,IAAI,cAAc,IAAI,cAAc,CAAC,MAAM,KAAK,IAAI,EAAE;oBACpD,cAAc,CAAC,MAAM,GAAG,SAAS,CAAC;iBACnC;aACF;SACF;QAED,OAAO,iBAAM,YAAY,YAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IAChD,CAAC;IAED;;;OAGG;IACI,0BAAK,GAAZ,UAAa,OAAgB;;QAC3B,MAAA,IAAI,CAAC,eAAe,0CAAE,KAAK,GAAG;QAC9B,OAAO,iBAAM,KAAK,YAAC,OAAO,CAAC,CAAC;IAC9B,CAAC;IAED,sEAAsE;IAC/D,uCAAkB,GAAzB;QACQ,IAAA,kBAAwC,EAAtC,oBAAO,EAAE,4BAA6B,CAAC;QAC/C,IAAI,CAAC,OAAO,EAAE;YACZ,cAAc,IAAI,MAAM,CAAC,IAAI,CAAC,4EAA4E,CAAC,CAAC;SAC7G;aAAM;YACL,IAAI,CAAC,eAAe,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE;gBAC7D,OAAO,SAAA;gBACP,WAAW,aAAA;aACZ,CAAC,CAAC;SACJ;IACH,CAAC;IAED;;OAEG;IACO,kCAAa,GAAvB,UAAwB,KAAY,EAAE,KAAa,EAAE,IAAgB;QACnE,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,IAAI,MAAM,CAAC;QAC1C,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC,UAAU,EAAE;YAChC,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC,UAAU,CAAC;SAClD;QACD,OAAO,iBAAM,aAAa,YAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;IACjD,CAAC;IAED;;;OAGG;IACO,2CAAsB,GAAhC;QACE,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACzB,cAAc,IAAI,MAAM,CAAC,IAAI,CAAC,gFAAgF,CAAC,CAAC;SACjH;aAAM;YACL,IAAI,CAAC,eAAe,CAAC,2BAA2B,EAAE,CAAC;SACpD;IACH,CAAC;IACH,iBAAC;AAAD,CAAC,AAnHD,CAAgC,UAAU,GAmHzC","sourcesContent":["import { BaseClient, Scope, SDK_VERSION } from '@sentry/core';\nimport { SessionFlusher } from '@sentry/hub';\nimport { Event, EventHint } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { NodeBackend } from './backend';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { NodeOptions } from './types';\n\n/**\n * The Sentry Node SDK Client.\n *\n * @see NodeOptions for documentation on configuration options.\n * @see SentryClient for usage documentation.\n */\nexport class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n  protected _sessionFlusher: SessionFlusher | undefined;\n\n  /**\n   * Creates a new Node SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n  public constructor(options: NodeOptions) {\n    options._metadata = options._metadata || {};\n    options._metadata.sdk = options._metadata.sdk || {\n      name: 'sentry.javascript.node',\n      packages: [\n        {\n          name: 'npm:@sentry/node',\n          version: SDK_VERSION,\n        },\n      ],\n      version: SDK_VERSION,\n    };\n\n    super(NodeBackend, options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const requestSession = scope.getRequestSession();\n\n      // Necessary checks to ensure this is code block is executed only within a request\n      // Should override the status only if `requestSession.status` is `Ok`, which is its initial stage\n      if (requestSession && requestSession.status === 'ok') {\n        requestSession.status = 'errored';\n      }\n    }\n\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // Check if the flag `autoSessionTracking` is enabled, and if `_sessionFlusher` exists because it is initialised only\n    // when the `requestHandler` middleware is used, and hence the expectation is to have SessionAggregates payload\n    // sent to the Server only when the `requestHandler` middleware is used\n    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {\n      const eventType = event.type || 'exception';\n      const isException =\n        eventType === 'exception' && event.exception && event.exception.values && event.exception.values.length > 0;\n\n      // If the event is of type Exception, then a request session should be captured\n      if (isException) {\n        const requestSession = scope.getRequestSession();\n\n        // Ensure that this is happening within the bounds of a request, and make sure not to override\n        // Session Status if Errored / Crashed\n        if (requestSession && requestSession.status === 'ok') {\n          requestSession.status = 'errored';\n        }\n      }\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   *\n   * @inheritdoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    this._sessionFlusher?.close();\n    return super.close(timeout);\n  }\n\n  /** Method that initialises an instance of SessionFlusher on Client */\n  public initSessionFlusher(): void {\n    const { release, environment } = this._options;\n    if (!release) {\n      IS_DEBUG_BUILD && logger.warn('Cannot initialise an instance of SessionFlusher if no release is provided!');\n    } else {\n      this._sessionFlusher = new SessionFlusher(this.getTransport(), {\n        release,\n        environment,\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    event.platform = event.platform || 'node';\n    if (this.getOptions().serverName) {\n      event.server_name = this.getOptions().serverName;\n    }\n    return super._prepareEvent(event, scope, hint);\n  }\n\n  /**\n   * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment\n   * appropriate session aggregates bucket\n   */\n  protected _captureRequestSession(): void {\n    if (!this._sessionFlusher) {\n      IS_DEBUG_BUILD && logger.warn('Discarded request mode session because autoSessionTracking option was disabled');\n    } else {\n      this._sessionFlusher.incrementSessionStatusCount();\n    }\n  }\n}\n"]}import { Event, EventHint, Exception, Severity, StackFrame } from '@sentry/types';
/**
 * Extracts stack frames from the error.stack string
 */
export declare function parseStackFrames(error: Error): StackFrame[];
/**
 * Extracts stack frames from the error and builds a Sentry Exception
 */
export declare function exceptionFromError(error: Error): Exception;
/**
 * Builds and Event from a Exception
 * @hidden
 */
export declare function eventFromUnknownInput(exception: unknown, hint?: EventHint): Event;
/**
 * Builds and Event from a Message
 * @hidden
 */
export declare function eventFromMessage(message: string, level?: Severity, hint?: EventHint, attachStacktrace?: boolean): Event;
//# sourceMappingURL=eventbuilder.d.ts.map{"version":3,"file":"eventbuilder.d.ts","sourceRoot":"","sources":["../../src/eventbuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAa,QAAQ,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAa7F;;GAEG;AACH,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,UAAU,EAAE,CAE3D;AAED;;GAEG;AACH,wBAAgB,kBAAkB,CAAC,KAAK,EAAE,KAAK,GAAG,SAAS,CAY1D;AAED;;;GAGG;AACH,wBAAgB,qBAAqB,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,KAAK,CA4CjF;AAED;;;GAGG;AACH,wBAAgB,gBAAgB,CAC9B,OAAO,EAAE,MAAM,EACf,KAAK,GAAE,QAAwB,EAC/B,IAAI,CAAC,EAAE,SAAS,EAChB,gBAAgB,CAAC,EAAE,OAAO,GACzB,KAAK,CAeP"}import { __assign } from "tslib";
import { getCurrentHub } from '@sentry/hub';
import { Severity } from '@sentry/types';
import { addExceptionMechanism, addExceptionTypeValue, createStackParser, extractExceptionKeysForMessage, isError, isPlainObject, normalizeToSize, } from '@sentry/utils';
import { nodeStackParser } from './stack-parser';
/**
 * Extracts stack frames from the error.stack string
 */
export function parseStackFrames(error) {
    return createStackParser(nodeStackParser)(error.stack || '', 1);
}
/**
 * Extracts stack frames from the error and builds a Sentry Exception
 */
export function exceptionFromError(error) {
    var exception = {
        type: error.name || error.constructor.name,
        value: error.message,
    };
    var frames = parseStackFrames(error);
    if (frames.length) {
        exception.stacktrace = { frames: frames };
    }
    return exception;
}
/**
 * Builds and Event from a Exception
 * @hidden
 */
export function eventFromUnknownInput(exception, hint) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var ex = exception;
    var providedMechanism = hint && hint.data && hint.data.mechanism;
    var mechanism = providedMechanism || {
        handled: true,
        type: 'generic',
    };
    if (!isError(exception)) {
        if (isPlainObject(exception)) {
            // This will allow us to group events based on top-level keys
            // which is much better than creating new group when any key/value change
            var message = "Non-Error exception captured with keys: " + extractExceptionKeysForMessage(exception);
            getCurrentHub().configureScope(function (scope) {
                scope.setExtra('__serialized__', normalizeToSize(exception));
            });
            ex = (hint && hint.syntheticException) || new Error(message);
            ex.message = message;
        }
        else {
            // This handles when someone does: `throw "something awesome";`
            // We use synthesized Error here so we can extract a (rough) stack trace.
            ex = (hint && hint.syntheticException) || new Error(exception);
            ex.message = exception;
        }
        mechanism.synthetic = true;
    }
    var event = {
        exception: {
            values: [exceptionFromError(ex)],
        },
    };
    addExceptionTypeValue(event, undefined, undefined);
    addExceptionMechanism(event, mechanism);
    return __assign(__assign({}, event), { event_id: hint && hint.event_id });
}
/**
 * Builds and Event from a Message
 * @hidden
 */
export function eventFromMessage(message, level, hint, attachStacktrace) {
    if (level === void 0) { level = Severity.Info; }
    var event = {
        event_id: hint && hint.event_id,
        level: level,
        message: message,
    };
    if (attachStacktrace && hint && hint.syntheticException) {
        var frames_1 = parseStackFrames(hint.syntheticException);
        if (frames_1.length) {
            event.stacktrace = { frames: frames_1 };
        }
    }
    return event;
}
//# sourceMappingURL=eventbuilder.js.map{"version":3,"file":"eventbuilder.js","sourceRoot":"","sources":["../../src/eventbuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/hub';\nimport { Event, EventHint, Exception, Mechanism, Severity, StackFrame } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  createStackParser,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n} from '@sentry/utils';\n\nimport { nodeStackParser } from './stack-parser';\n\n/**\n * Extracts stack frames from the error.stack string\n */\nexport function parseStackFrames(error: Error): StackFrame[] {\n  return createStackParser(nodeStackParser)(error.stack || '', 1);\n}\n\n/**\n * Extracts stack frames from the error and builds a Sentry Exception\n */\nexport function exceptionFromError(error: Error): Exception {\n  const exception: Exception = {\n    type: error.name || error.constructor.name,\n    value: error.message,\n  };\n\n  const frames = parseStackFrames(error);\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  return exception;\n}\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromUnknownInput(exception: unknown, hint?: EventHint): Event {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let ex: unknown = exception;\n  const providedMechanism: Mechanism | undefined =\n    hint && hint.data && (hint.data as { mechanism: Mechanism }).mechanism;\n  const mechanism: Mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic',\n  };\n\n  if (!isError(exception)) {\n    if (isPlainObject(exception)) {\n      // This will allow us to group events based on top-level keys\n      // which is much better than creating new group when any key/value change\n      const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n      getCurrentHub().configureScope(scope => {\n        scope.setExtra('__serialized__', normalizeToSize(exception));\n      });\n\n      ex = (hint && hint.syntheticException) || new Error(message);\n      (ex as Error).message = message;\n    } else {\n      // This handles when someone does: `throw \"something awesome\";`\n      // We use synthesized Error here so we can extract a (rough) stack trace.\n      ex = (hint && hint.syntheticException) || new Error(exception as string);\n      (ex as Error).message = exception as string;\n    }\n    mechanism.synthetic = true;\n  }\n\n  const event = {\n    exception: {\n      values: [exceptionFromError(ex as Error)],\n    },\n  };\n\n  addExceptionTypeValue(event, undefined, undefined);\n  addExceptionMechanism(event, mechanism);\n\n  return {\n    ...event,\n    event_id: hint && hint.event_id,\n  };\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): Event {\n  const event: Event = {\n    event_id: hint && hint.event_id,\n    level,\n    message,\n  };\n\n  if (attachStacktrace && hint && hint.syntheticException) {\n    const frames = parseStackFrames(hint.syntheticException);\n    if (frames.length) {\n      event.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
/** Flag that is true for debug builds, false otherwise. */
export var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAIH,2DAA2D;AAC3D,MAAM,CAAC,IAAM,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}/// <reference types="node" />
import { Event, ExtractedNodeRequestData } from '@sentry/types';
import * as http from 'http';
export interface ExpressRequest {
    baseUrl?: string;
    connection?: {
        remoteAddress?: string;
    };
    ip?: string;
    method?: string;
    originalUrl?: string;
    route?: {
        path: string;
        stack: [{
            name: string;
        }];
    };
    query?: {
        [key: string]: unknown;
    };
    url?: string;
    user?: {
        [key: string]: any;
    };
}
/**
 * Express-compatible tracing handler.
 * @see Exposed as `Handlers.tracingHandler`
 */
export declare function tracingHandler(): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void;
declare type TransactionNamingScheme = 'path' | 'methodPath' | 'handler';
/**
 * Normalizes data from the request object, accounting for framework differences.
 *
 * @param req The request object from which to extract data
 * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not
 * provided.
 * @returns An object containing normalized request data
 */
export declare function extractRequestData(req: {
    [key: string]: any;
}, keys?: string[]): ExtractedNodeRequestData;
/**
 * Options deciding what parts of the request to use when enhancing an event
 */
export interface ParseRequestOptions {
    ip?: boolean;
    request?: boolean | string[];
    serverName?: boolean;
    transaction?: boolean | TransactionNamingScheme;
    user?: boolean | string[];
    version?: boolean;
}
/**
 * Enriches passed event with request data.
 *
 * @param event Will be mutated and enriched with req data
 * @param req Request object
 * @param options object containing flags to enable functionality
 * @hidden
 */
export declare function parseRequest(event: Event, req: ExpressRequest, options?: ParseRequestOptions): Event;
export declare type RequestHandlerOptions = ParseRequestOptions & {
    flushTimeout?: number;
};
/**
 * Express compatible request handler.
 * @see Exposed as `Handlers.requestHandler`
 */
export declare function requestHandler(options?: RequestHandlerOptions): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void;
/** JSDoc */
interface MiddlewareError extends Error {
    status?: number | string;
    statusCode?: number | string;
    status_code?: number | string;
    output?: {
        statusCode?: number | string;
    };
}
/**
 * Express compatible error handler.
 * @see Exposed as `Handlers.errorHandler`
 */
export declare function errorHandler(options?: {
    /**
     * Callback method deciding whether error should be captured and sent to Sentry
     * @param error Captured middleware error
     */
    shouldHandleError?(error: MiddlewareError): boolean;
}): (error: MiddlewareError, req: http.IncomingMessage, res: http.ServerResponse, next: (error: MiddlewareError) => void) => void;
export {};
//# sourceMappingURL=handlers.d.ts.map{"version":3,"file":"handlers.d.ts","sourceRoot":"","sources":["../../src/handlers.ts"],"names":[],"mappings":"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"}import { __assign } from "tslib";
/* eslint-disable max-lines */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { captureException, getCurrentHub, startTransaction, withScope } from '@sentry/core';
import { extractTraceparentData, isPlainObject, isString, logger, normalize, stripUrlQueryAndFragment, } from '@sentry/utils';
import * as cookie from 'cookie';
import * as domain from 'domain';
import * as os from 'os';
import * as url from 'url';
import { IS_DEBUG_BUILD } from './flags';
import { flush, isAutoSessionTrackingEnabled } from './sdk';
/**
 * Express-compatible tracing handler.
 * @see Exposed as `Handlers.tracingHandler`
 */
export function tracingHandler() {
    return function sentryTracingMiddleware(req, res, next) {
        // If there is a trace header set, we extract the data from it (parentSpanId, traceId, and sampling decision)
        var traceparentData;
        if (req.headers && isString(req.headers['sentry-trace'])) {
            traceparentData = extractTraceparentData(req.headers['sentry-trace']);
        }
        var transaction = startTransaction(__assign({ name: extractExpressTransactionName(req, { path: true, method: true }), op: 'http.server' }, traceparentData), 
        // extra context passed to the tracesSampler
        { request: extractRequestData(req) });
        // We put the transaction on the scope so users can attach children to it
        getCurrentHub().configureScope(function (scope) {
            scope.setSpan(transaction);
        });
        // We also set __sentry_transaction on the response so people can grab the transaction there to add
        // spans to it later.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        res.__sentry_transaction = transaction;
        res.once('finish', function () {
            // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction
            // closes
            setImmediate(function () {
                addExpressReqToTransaction(transaction, req);
                transaction.setHttpStatus(res.statusCode);
                transaction.finish();
            });
        });
        next();
    };
}
/**
 * Set parameterized as transaction name e.g.: `GET /users/:id`
 * Also adds more context data on the transaction from the request
 */
function addExpressReqToTransaction(transaction, req) {
    if (!transaction)
        return;
    transaction.name = extractExpressTransactionName(req, { path: true, method: true });
    transaction.setData('url', req.originalUrl);
    transaction.setData('baseUrl', req.baseUrl);
    transaction.setData('query', req.query);
}
/**
 * Extracts complete generalized path from the request object and uses it to construct transaction name.
 *
 * eg. GET /mountpoint/user/:id
 *
 * @param req The ExpressRequest object
 * @param options What to include in the transaction name (method, path, or both)
 *
 * @returns The fully constructed transaction name
 */
function extractExpressTransactionName(req, options) {
    if (options === void 0) { options = {}; }
    var _a;
    var method = (_a = req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    var path = '';
    if (req.route) {
        path = "" + (req.baseUrl || '') + req.route.path;
    }
    else if (req.originalUrl || req.url) {
        path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');
    }
    var info = '';
    if (options.method && method) {
        info += method;
    }
    if (options.method && options.path) {
        info += ' ';
    }
    if (options.path && path) {
        info += path;
    }
    return info;
}
/** JSDoc */
function extractTransaction(req, type) {
    var _a;
    switch (type) {
        case 'path': {
            return extractExpressTransactionName(req, { path: true });
        }
        case 'handler': {
            return ((_a = req.route) === null || _a === void 0 ? void 0 : _a.stack[0].name) || '<anonymous>';
        }
        case 'methodPath':
        default: {
            return extractExpressTransactionName(req, { path: true, method: true });
        }
    }
}
/** Default user keys that'll be used to extract data from the request */
var DEFAULT_USER_KEYS = ['id', 'username', 'email'];
/** JSDoc */
function extractUserData(user, keys) {
    var extractedUser = {};
    var attributes = Array.isArray(keys) ? keys : DEFAULT_USER_KEYS;
    attributes.forEach(function (key) {
        if (user && key in user) {
            extractedUser[key] = user[key];
        }
    });
    return extractedUser;
}
/** Default request keys that'll be used to extract data from the request */
var DEFAULT_REQUEST_KEYS = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];
/**
 * Normalizes data from the request object, accounting for framework differences.
 *
 * @param req The request object from which to extract data
 * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not
 * provided.
 * @returns An object containing normalized request data
 */
export function extractRequestData(req, keys) {
    if (keys === void 0) { keys = DEFAULT_REQUEST_KEYS; }
    var requestData = {};
    // headers:
    //   node, express, nextjs: req.headers
    //   koa: req.header
    var headers = (req.headers || req.header || {});
    // method:
    //   node, express, koa, nextjs: req.method
    var method = req.method;
    // host:
    //   express: req.hostname in > 4 and req.host in < 4
    //   koa: req.host
    //   node, nextjs: req.headers.host
    var host = req.hostname || req.host || headers.host || '<no host>';
    // protocol:
    //   node, nextjs: <n/a>
    //   express, koa: req.protocol
    var protocol = req.protocol === 'https' || req.secure || (req.socket || {}).encrypted
        ? 'https'
        : 'http';
    // url (including path and query string):
    //   node, express: req.originalUrl
    //   koa, nextjs: req.url
    var originalUrl = (req.originalUrl || req.url || '');
    // absolute url
    var absoluteUrl = protocol + "://" + host + originalUrl;
    keys.forEach(function (key) {
        switch (key) {
            case 'headers':
                requestData.headers = headers;
                break;
            case 'method':
                requestData.method = method;
                break;
            case 'url':
                requestData.url = absoluteUrl;
                break;
            case 'cookies':
                // cookies:
                //   node, express, koa: req.headers.cookie
                //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                requestData.cookies = req.cookies || cookie.parse(headers.cookie || '');
                break;
            case 'query_string':
                // query string:
                //   node: req.url (raw)
                //   express, koa, nextjs: req.query
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                requestData.query_string = req.query || url.parse(originalUrl || '', false).query;
                break;
            case 'data':
                if (method === 'GET' || method === 'HEAD') {
                    break;
                }
                // body data:
                //   express, koa, nextjs: req.body
                //
                //   when using node by itself, you have to read the incoming stream(see
                //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know
                //   where they're going to store the final result, so they'll have to capture this data themselves
                if (req.body !== undefined) {
                    requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));
                }
                break;
            default:
                if ({}.hasOwnProperty.call(req, key)) {
                    requestData[key] = req[key];
                }
        }
    });
    return requestData;
}
/**
 * Enriches passed event with request data.
 *
 * @param event Will be mutated and enriched with req data
 * @param req Request object
 * @param options object containing flags to enable functionality
 * @hidden
 */
export function parseRequest(event, req, options) {
    // eslint-disable-next-line no-param-reassign
    options = __assign({ ip: false, request: true, serverName: true, transaction: true, user: true, version: true }, options);
    if (options.version) {
        event.contexts = __assign(__assign({}, event.contexts), { runtime: {
                name: 'node',
                version: global.process.version,
            } });
    }
    if (options.request) {
        // if the option value is `true`, use the default set of keys by not passing anything to `extractRequestData()`
        var extractedRequestData = Array.isArray(options.request)
            ? extractRequestData(req, options.request)
            : extractRequestData(req);
        event.request = __assign(__assign({}, event.request), extractedRequestData);
    }
    if (options.serverName && !event.server_name) {
        event.server_name = global.process.env.SENTRY_NAME || os.hostname();
    }
    if (options.user) {
        var extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, options.user) : {};
        if (Object.keys(extractedUser)) {
            event.user = __assign(__assign({}, event.user), extractedUser);
        }
    }
    // client ip:
    //   node, nextjs: req.connection.remoteAddress
    //   express, koa: req.ip
    if (options.ip) {
        var ip = req.ip || (req.connection && req.connection.remoteAddress);
        if (ip) {
            event.user = __assign(__assign({}, event.user), { ip_address: ip });
        }
    }
    if (options.transaction && !event.transaction) {
        // TODO do we even need this anymore?
        // TODO make this work for nextjs
        event.transaction = extractTransaction(req, options.transaction);
    }
    return event;
}
/**
 * Express compatible request handler.
 * @see Exposed as `Handlers.requestHandler`
 */
export function requestHandler(options) {
    var currentHub = getCurrentHub();
    var client = currentHub.getClient();
    // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the
    // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode
    if (client && isAutoSessionTrackingEnabled(client)) {
        client.initSessionFlusher();
        // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode
        var scope = currentHub.getScope();
        if (scope && scope.getSession()) {
            scope.setSession();
        }
    }
    return function sentryRequestMiddleware(req, res, next) {
        if (options && options.flushTimeout && options.flushTimeout > 0) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            var _end_1 = res.end;
            res.end = function (chunk, encoding, cb) {
                var _this = this;
                void flush(options.flushTimeout)
                    .then(function () {
                    _end_1.call(_this, chunk, encoding, cb);
                })
                    .then(null, function (e) {
                    IS_DEBUG_BUILD && logger.error(e);
                    _end_1.call(_this, chunk, encoding, cb);
                });
            };
        }
        var local = domain.create();
        local.add(req);
        local.add(res);
        local.on('error', next);
        local.run(function () {
            var currentHub = getCurrentHub();
            currentHub.configureScope(function (scope) {
                scope.addEventProcessor(function (event) { return parseRequest(event, req, options); });
                var client = currentHub.getClient();
                if (isAutoSessionTrackingEnabled(client)) {
                    var scope_1 = currentHub.getScope();
                    if (scope_1) {
                        // Set `status` of `RequestSession` to Ok, at the beginning of the request
                        scope_1.setRequestSession({ status: 'ok' });
                    }
                }
            });
            res.once('finish', function () {
                var client = currentHub.getClient();
                if (isAutoSessionTrackingEnabled(client)) {
                    setImmediate(function () {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        if (client && client._captureRequestSession) {
                            // Calling _captureRequestSession to capture request session at the end of the request by incrementing
                            // the correct SessionAggregates bucket i.e. crashed, errored or exited
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            client._captureRequestSession();
                        }
                    });
                }
            });
            next();
        });
    };
}
/** JSDoc */
function getStatusCodeFromResponse(error) {
    var statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);
    return statusCode ? parseInt(statusCode, 10) : 500;
}
/** Returns true if response code is internal server error */
function defaultShouldHandleError(error) {
    var status = getStatusCodeFromResponse(error);
    return status >= 500;
}
/**
 * Express compatible error handler.
 * @see Exposed as `Handlers.errorHandler`
 */
export function errorHandler(options) {
    return function sentryErrorMiddleware(error, _req, res, next) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var shouldHandleError = (options && options.shouldHandleError) || defaultShouldHandleError;
        if (shouldHandleError(error)) {
            withScope(function (_scope) {
                // For some reason we need to set the transaction on the scope again
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                var transaction = res.__sentry_transaction;
                if (transaction && _scope.getSpan() === undefined) {
                    _scope.setSpan(transaction);
                }
                var client = getCurrentHub().getClient();
                if (client && isAutoSessionTrackingEnabled(client)) {
                    // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the
                    // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only
                    // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be
                    // running in SessionAggregates mode
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    var isSessionAggregatesMode = client._sessionFlusher !== undefined;
                    if (isSessionAggregatesMode) {
                        var requestSession = _scope.getRequestSession();
                        // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a
                        // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within
                        // the bounds of a request, and if so the status is updated
                        if (requestSession && requestSession.status !== undefined) {
                            requestSession.status = 'crashed';
                        }
                    }
                }
                var eventId = captureException(error);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                res.sentry = eventId;
                next(error);
            });
            return;
        }
        next(error);
    };
}
//# sourceMappingURL=handlers.js.map{"version":3,"file":"handlers.js","sourceRoot":"","sources":["../../src/handlers.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { captureException, getCurrentHub, startTransaction, withScope } from '@sentry/core';\nimport { Event, ExtractedNodeRequestData, Span, Transaction } from '@sentry/types';\nimport {\n  extractTraceparentData,\n  isPlainObject,\n  isString,\n  logger,\n  normalize,\n  stripUrlQueryAndFragment,\n} from '@sentry/utils';\nimport * as cookie from 'cookie';\nimport * as domain from 'domain';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as url from 'url';\n\nimport { NodeClient } from './client';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { flush, isAutoSessionTrackingEnabled } from './sdk';\n\nexport interface ExpressRequest {\n  baseUrl?: string;\n  connection?: {\n    remoteAddress?: string;\n  };\n  ip?: string;\n  method?: string;\n  originalUrl?: string;\n  route?: {\n    path: string;\n    stack: [\n      {\n        name: string;\n      },\n    ];\n  };\n  query?: {\n    // It can be: undefined | string | string[] | ParsedQs | ParsedQs[] (from `qs` package), but we dont want to pull it.\n    [key: string]: unknown;\n  };\n  url?: string;\n  user?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * Express-compatible tracing handler.\n * @see Exposed as `Handlers.tracingHandler`\n */\nexport function tracingHandler(): (\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error?: any) => void,\n) => void {\n  return function sentryTracingMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    // If there is a trace header set, we extract the data from it (parentSpanId, traceId, and sampling decision)\n    let traceparentData;\n    if (req.headers && isString(req.headers['sentry-trace'])) {\n      traceparentData = extractTraceparentData(req.headers['sentry-trace']);\n    }\n\n    const transaction = startTransaction(\n      {\n        name: extractExpressTransactionName(req, { path: true, method: true }),\n        op: 'http.server',\n        ...traceparentData,\n      },\n      // extra context passed to the tracesSampler\n      { request: extractRequestData(req) },\n    );\n\n    // We put the transaction on the scope so users can attach children to it\n    getCurrentHub().configureScope(scope => {\n      scope.setSpan(transaction);\n    });\n\n    // We also set __sentry_transaction on the response so people can grab the transaction there to add\n    // spans to it later.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    (res as any).__sentry_transaction = transaction;\n\n    res.once('finish', () => {\n      // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction\n      // closes\n      setImmediate(() => {\n        addExpressReqToTransaction(transaction, req);\n        transaction.setHttpStatus(res.statusCode);\n        transaction.finish();\n      });\n    });\n\n    next();\n  };\n}\n\n/**\n * Set parameterized as transaction name e.g.: `GET /users/:id`\n * Also adds more context data on the transaction from the request\n */\nfunction addExpressReqToTransaction(transaction: Transaction | undefined, req: ExpressRequest): void {\n  if (!transaction) return;\n  transaction.name = extractExpressTransactionName(req, { path: true, method: true });\n  transaction.setData('url', req.originalUrl);\n  transaction.setData('baseUrl', req.baseUrl);\n  transaction.setData('query', req.query);\n}\n\n/**\n * Extracts complete generalized path from the request object and uses it to construct transaction name.\n *\n * eg. GET /mountpoint/user/:id\n *\n * @param req The ExpressRequest object\n * @param options What to include in the transaction name (method, path, or both)\n *\n * @returns The fully constructed transaction name\n */\nfunction extractExpressTransactionName(\n  req: ExpressRequest,\n  options: { path?: boolean; method?: boolean } = {},\n): string {\n  const method = req.method?.toUpperCase();\n\n  let path = '';\n  if (req.route) {\n    path = `${req.baseUrl || ''}${req.route.path}`;\n  } else if (req.originalUrl || req.url) {\n    path = stripUrlQueryAndFragment(req.originalUrl || req.url || '');\n  }\n\n  let info = '';\n  if (options.method && method) {\n    info += method;\n  }\n  if (options.method && options.path) {\n    info += ' ';\n  }\n  if (options.path && path) {\n    info += path;\n  }\n\n  return info;\n}\n\ntype TransactionNamingScheme = 'path' | 'methodPath' | 'handler';\n\n/** JSDoc */\nfunction extractTransaction(req: ExpressRequest, type: boolean | TransactionNamingScheme): string {\n  switch (type) {\n    case 'path': {\n      return extractExpressTransactionName(req, { path: true });\n    }\n    case 'handler': {\n      return req.route?.stack[0].name || '<anonymous>';\n    }\n    case 'methodPath':\n    default: {\n      return extractExpressTransactionName(req, { path: true, method: true });\n    }\n  }\n}\n\n/** Default user keys that'll be used to extract data from the request */\nconst DEFAULT_USER_KEYS = ['id', 'username', 'email'];\n\n/** JSDoc */\nfunction extractUserData(\n  user: {\n    [key: string]: any;\n  },\n  keys: boolean | string[],\n): { [key: string]: any } {\n  const extractedUser: { [key: string]: any } = {};\n  const attributes = Array.isArray(keys) ? keys : DEFAULT_USER_KEYS;\n\n  attributes.forEach(key => {\n    if (user && key in user) {\n      extractedUser[key] = user[key];\n    }\n  });\n\n  return extractedUser;\n}\n\n/** Default request keys that'll be used to extract data from the request */\nconst DEFAULT_REQUEST_KEYS = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'];\n\n/**\n * Normalizes data from the request object, accounting for framework differences.\n *\n * @param req The request object from which to extract data\n * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not\n * provided.\n * @returns An object containing normalized request data\n */\nexport function extractRequestData(\n  req: { [key: string]: any },\n  keys: string[] = DEFAULT_REQUEST_KEYS,\n): ExtractedNodeRequestData {\n  const requestData: { [key: string]: any } = {};\n\n  // headers:\n  //   node, express, nextjs: req.headers\n  //   koa: req.header\n  const headers = (req.headers || req.header || {}) as {\n    host?: string;\n    cookie?: string;\n  };\n  // method:\n  //   node, express, koa, nextjs: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node, nextjs: req.headers.host\n  const host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node, nextjs: <n/a>\n  //   express, koa: req.protocol\n  const protocol =\n    req.protocol === 'https' || req.secure || ((req.socket || {}) as { encrypted?: boolean }).encrypted\n      ? 'https'\n      : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa, nextjs: req.url\n  const originalUrl = (req.originalUrl || req.url || '') as string;\n  // absolute url\n  const absoluteUrl = `${protocol}://${host}${originalUrl}`;\n\n  keys.forEach(key => {\n    switch (key) {\n      case 'headers':\n        requestData.headers = headers;\n        break;\n      case 'method':\n        requestData.method = method;\n        break;\n      case 'url':\n        requestData.url = absoluteUrl;\n        break;\n      case 'cookies':\n        // cookies:\n        //   node, express, koa: req.headers.cookie\n        //   vercel, sails.js, express (w/ cookie middleware), nextjs: req.cookies\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.cookies = req.cookies || cookie.parse(headers.cookie || '');\n        break;\n      case 'query_string':\n        // query string:\n        //   node: req.url (raw)\n        //   express, koa, nextjs: req.query\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        requestData.query_string = req.query || url.parse(originalUrl || '', false).query;\n        break;\n      case 'data':\n        if (method === 'GET' || method === 'HEAD') {\n          break;\n        }\n        // body data:\n        //   express, koa, nextjs: req.body\n        //\n        //   when using node by itself, you have to read the incoming stream(see\n        //   https://nodejs.dev/learn/get-http-request-body-data-using-nodejs); if a user is doing that, we can't know\n        //   where they're going to store the final result, so they'll have to capture this data themselves\n        if (req.body !== undefined) {\n          requestData.data = isString(req.body) ? req.body : JSON.stringify(normalize(req.body));\n        }\n        break;\n      default:\n        if ({}.hasOwnProperty.call(req, key)) {\n          requestData[key] = (req as { [key: string]: any })[key];\n        }\n    }\n  });\n\n  return requestData;\n}\n\n/**\n * Options deciding what parts of the request to use when enhancing an event\n */\nexport interface ParseRequestOptions {\n  ip?: boolean;\n  request?: boolean | string[];\n  serverName?: boolean;\n  transaction?: boolean | TransactionNamingScheme;\n  user?: boolean | string[];\n  version?: boolean;\n}\n\n/**\n * Enriches passed event with request data.\n *\n * @param event Will be mutated and enriched with req data\n * @param req Request object\n * @param options object containing flags to enable functionality\n * @hidden\n */\nexport function parseRequest(event: Event, req: ExpressRequest, options?: ParseRequestOptions): Event {\n  // eslint-disable-next-line no-param-reassign\n  options = {\n    ip: false,\n    request: true,\n    serverName: true,\n    transaction: true,\n    user: true,\n    version: true,\n    ...options,\n  };\n\n  if (options.version) {\n    event.contexts = {\n      ...event.contexts,\n      runtime: {\n        name: 'node',\n        version: global.process.version,\n      },\n    };\n  }\n\n  if (options.request) {\n    // if the option value is `true`, use the default set of keys by not passing anything to `extractRequestData()`\n    const extractedRequestData = Array.isArray(options.request)\n      ? extractRequestData(req, options.request)\n      : extractRequestData(req);\n    event.request = {\n      ...event.request,\n      ...extractedRequestData,\n    };\n  }\n\n  if (options.serverName && !event.server_name) {\n    event.server_name = global.process.env.SENTRY_NAME || os.hostname();\n  }\n\n  if (options.user) {\n    const extractedUser = req.user && isPlainObject(req.user) ? extractUserData(req.user, options.user) : {};\n\n    if (Object.keys(extractedUser)) {\n      event.user = {\n        ...event.user,\n        ...extractedUser,\n      };\n    }\n  }\n\n  // client ip:\n  //   node, nextjs: req.connection.remoteAddress\n  //   express, koa: req.ip\n  if (options.ip) {\n    const ip = req.ip || (req.connection && req.connection.remoteAddress);\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n\n  if (options.transaction && !event.transaction) {\n    // TODO do we even need this anymore?\n    // TODO make this work for nextjs\n    event.transaction = extractTransaction(req, options.transaction);\n  }\n\n  return event;\n}\n\nexport type RequestHandlerOptions = ParseRequestOptions & {\n  flushTimeout?: number;\n};\n\n/**\n * Express compatible request handler.\n * @see Exposed as `Handlers.requestHandler`\n */\nexport function requestHandler(\n  options?: RequestHandlerOptions,\n): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void {\n  const currentHub = getCurrentHub();\n  const client = currentHub.getClient<NodeClient>();\n  // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the\n  // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode\n  if (client && isAutoSessionTrackingEnabled(client)) {\n    client.initSessionFlusher();\n\n    // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode\n    const scope = currentHub.getScope();\n    if (scope && scope.getSession()) {\n      scope.setSession();\n    }\n  }\n  return function sentryRequestMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    if (options && options.flushTimeout && options.flushTimeout > 0) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _end = res.end;\n      res.end = function (chunk?: any | (() => void), encoding?: string | (() => void), cb?: () => void): void {\n        void flush(options.flushTimeout)\n          .then(() => {\n            _end.call(this, chunk, encoding, cb);\n          })\n          .then(null, e => {\n            IS_DEBUG_BUILD && logger.error(e);\n            _end.call(this, chunk, encoding, cb);\n          });\n      };\n    }\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n    local.on('error', next);\n\n    local.run(() => {\n      const currentHub = getCurrentHub();\n\n      currentHub.configureScope(scope => {\n        scope.addEventProcessor((event: Event) => parseRequest(event, req, options));\n        const client = currentHub.getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          const scope = currentHub.getScope();\n          if (scope) {\n            // Set `status` of `RequestSession` to Ok, at the beginning of the request\n            scope.setRequestSession({ status: 'ok' });\n          }\n        }\n      });\n\n      res.once('finish', () => {\n        const client = currentHub.getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          setImmediate(() => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (client && (client as any)._captureRequestSession) {\n              // Calling _captureRequestSession to capture request session at the end of the request by incrementing\n              // the correct SessionAggregates bucket i.e. crashed, errored or exited\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              (client as any)._captureRequestSession();\n            }\n          });\n        }\n      });\n      next();\n    });\n  };\n}\n\n/** JSDoc */\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\n/** JSDoc */\nfunction getStatusCodeFromResponse(error: MiddlewareError): number {\n  const statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);\n  return statusCode ? parseInt(statusCode as string, 10) : 500;\n}\n\n/** Returns true if response code is internal server error */\nfunction defaultShouldHandleError(error: MiddlewareError): boolean {\n  const status = getStatusCodeFromResponse(error);\n  return status >= 500;\n}\n\n/**\n * Express compatible error handler.\n * @see Exposed as `Handlers.errorHandler`\n */\nexport function errorHandler(options?: {\n  /**\n   * Callback method deciding whether error should be captured and sent to Sentry\n   * @param error Captured middleware error\n   */\n  shouldHandleError?(error: MiddlewareError): boolean;\n}): (\n  error: MiddlewareError,\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error: MiddlewareError) => void,\n) => void {\n  return function sentryErrorMiddleware(\n    error: MiddlewareError,\n    _req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error: MiddlewareError) => void,\n  ): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const shouldHandleError = (options && options.shouldHandleError) || defaultShouldHandleError;\n\n    if (shouldHandleError(error)) {\n      withScope(_scope => {\n        // For some reason we need to set the transaction on the scope again\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const transaction = (res as any).__sentry_transaction as Span;\n        if (transaction && _scope.getSpan() === undefined) {\n          _scope.setSpan(transaction);\n        }\n\n        const client = getCurrentHub().getClient<NodeClient>();\n        if (client && isAutoSessionTrackingEnabled(client)) {\n          // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the\n          // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only\n          // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be\n          // running in SessionAggregates mode\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          const isSessionAggregatesMode = (client as any)._sessionFlusher !== undefined;\n          if (isSessionAggregatesMode) {\n            const requestSession = _scope.getRequestSession();\n            // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a\n            // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within\n            // the bounds of a request, and if so the status is updated\n            if (requestSession && requestSession.status !== undefined) {\n              requestSession.status = 'crashed';\n            }\n          }\n        }\n\n        const eventId = captureException(error);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        (res as any).sentry = eventId;\n        next(error);\n      });\n\n      return;\n    }\n\n    next(error);\n  };\n}\n"]}export { Breadcrumb, BreadcrumbHint, Request, SdkInfo, Event, EventHint, EventStatus, Exception, Response, Severity, StackFrame, Stacktrace, Thread, User, } from '@sentry/types';
export { SeverityLevel } from '@sentry/utils';
export { addGlobalEventProcessor, addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, getHubFromCarrier, getCurrentHub, Hub, makeMain, Scope, Session, startTransaction, SDK_VERSION, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/core';
export { NodeOptions } from './types';
export { NodeBackend } from './backend';
export { NodeClient } from './client';
export { defaultIntegrations, init, lastEventId, flush, close, getSentryRelease } from './sdk';
export { deepReadDirSync } from './utils';
export { SDK_NAME } from './version';
import { Integrations as CoreIntegrations } from '@sentry/core';
import * as Handlers from './handlers';
import * as NodeIntegrations from './integrations';
import * as Transports from './transports';
declare const INTEGRATIONS: {
    Console: typeof NodeIntegrations.Console;
    Http: typeof NodeIntegrations.Http;
    OnUncaughtException: typeof NodeIntegrations.OnUncaughtException;
    OnUnhandledRejection: typeof NodeIntegrations.OnUnhandledRejection;
    LinkedErrors: typeof NodeIntegrations.LinkedErrors;
    Modules: typeof NodeIntegrations.Modules;
    ContextLines: typeof NodeIntegrations.ContextLines;
    FunctionToString: typeof CoreIntegrations.FunctionToString;
    InboundFilters: typeof CoreIntegrations.InboundFilters;
};
export { INTEGRATIONS as Integrations, Transports, Handlers };
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,UAAU,EACV,cAAc,EACd,OAAO,EACP,OAAO,EACP,KAAK,EACL,SAAS,EACT,WAAW,EACX,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,UAAU,EACV,UAAU,EACV,MAAM,EACN,IAAI,GACL,MAAM,eAAe,CAAC;AAEvB,OAAO,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAE9C,OAAO,EACL,uBAAuB,EACvB,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,iBAAiB,EACjB,aAAa,EACb,GAAG,EACH,QAAQ,EACR,KAAK,EACL,OAAO,EACP,gBAAgB,EAChB,WAAW,EACX,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,cAAc,CAAC;AAEtB,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AACtC,OAAO,EAAE,mBAAmB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,KAAK,EAAE,gBAAgB,EAAE,MAAM,OAAO,CAAC;AAC/F,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAErC,OAAO,EAAE,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAIhE,OAAO,KAAK,QAAQ,MAAM,YAAY,CAAC;AACvC,OAAO,KAAK,gBAAgB,MAAM,gBAAgB,CAAC;AACnD,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAE3C,QAAA,MAAM,YAAY;;;;;;;;;;CAGjB,CAAC;AAEF,OAAO,EAAE,YAAY,IAAI,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC"}import { __assign } from "tslib";
export { Severity, } from '@sentry/types';
export { addGlobalEventProcessor, addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, getHubFromCarrier, getCurrentHub, Hub, makeMain, Scope, Session, startTransaction, SDK_VERSION, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/core';
export { NodeBackend } from './backend';
export { NodeClient } from './client';
export { defaultIntegrations, init, lastEventId, flush, close, getSentryRelease } from './sdk';
export { deepReadDirSync } from './utils';
export { SDK_NAME } from './version';
import { Integrations as CoreIntegrations } from '@sentry/core';
import { getMainCarrier } from '@sentry/hub';
import * as domain from 'domain';
import * as Handlers from './handlers';
import * as NodeIntegrations from './integrations';
import * as Transports from './transports';
var INTEGRATIONS = __assign(__assign({}, CoreIntegrations), NodeIntegrations);
export { INTEGRATIONS as Integrations, Transports, Handlers };
// We need to patch domain on the global __SENTRY__ object to make it work for node in cross-platform packages like
// @sentry/hub. If we don't do this, browser bundlers will have troubles resolving `require('domain')`.
var carrier = getMainCarrier();
if (carrier.__SENTRY__) {
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    carrier.__SENTRY__.extensions.domain = carrier.__SENTRY__.extensions.domain || domain;
}
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAUL,QAAQ,GAKT,MAAM,eAAe,CAAC;AAIvB,OAAO,EACL,uBAAuB,EACvB,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,iBAAiB,EACjB,aAAa,EACb,GAAG,EACH,QAAQ,EACR,KAAK,EACL,OAAO,EACP,gBAAgB,EAChB,WAAW,EACX,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,cAAc,CAAC;AAGtB,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AACtC,OAAO,EAAE,mBAAmB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,KAAK,EAAE,gBAAgB,EAAE,MAAM,OAAO,CAAC;AAC/F,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAErC,OAAO,EAAE,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAChE,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,KAAK,MAAM,MAAM,QAAQ,CAAC;AAEjC,OAAO,KAAK,QAAQ,MAAM,YAAY,CAAC;AACvC,OAAO,KAAK,gBAAgB,MAAM,gBAAgB,CAAC;AACnD,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAE3C,IAAM,YAAY,yBACb,gBAAgB,GAChB,gBAAgB,CACpB,CAAC;AAEF,OAAO,EAAE,YAAY,IAAI,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC;AAE9D,mHAAmH;AACnH,uGAAuG;AACvG,IAAM,OAAO,GAAG,cAAc,EAAE,CAAC;AACjC,IAAI,OAAO,CAAC,UAAU,EAAE;IACtB,OAAO,CAAC,UAAU,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC;IACpE,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,MAAM,IAAI,MAAM,CAAC;CACvF","sourcesContent":["export {\n  Breadcrumb,\n  BreadcrumbHint,\n  Request,\n  SdkInfo,\n  Event,\n  EventHint,\n  EventStatus,\n  Exception,\n  Response,\n  Severity,\n  StackFrame,\n  Stacktrace,\n  Thread,\n  User,\n} from '@sentry/types';\n\nexport { SeverityLevel } from '@sentry/utils';\n\nexport {\n  addGlobalEventProcessor,\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  getHubFromCarrier,\n  getCurrentHub,\n  Hub,\n  makeMain,\n  Scope,\n  Session,\n  startTransaction,\n  SDK_VERSION,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  withScope,\n} from '@sentry/core';\n\nexport { NodeOptions } from './types';\nexport { NodeBackend } from './backend';\nexport { NodeClient } from './client';\nexport { defaultIntegrations, init, lastEventId, flush, close, getSentryRelease } from './sdk';\nexport { deepReadDirSync } from './utils';\nexport { SDK_NAME } from './version';\n\nimport { Integrations as CoreIntegrations } from '@sentry/core';\nimport { getMainCarrier } from '@sentry/hub';\nimport * as domain from 'domain';\n\nimport * as Handlers from './handlers';\nimport * as NodeIntegrations from './integrations';\nimport * as Transports from './transports';\n\nconst INTEGRATIONS = {\n  ...CoreIntegrations,\n  ...NodeIntegrations,\n};\n\nexport { INTEGRATIONS as Integrations, Transports, Handlers };\n\n// We need to patch domain on the global __SENTRY__ object to make it work for node in cross-platform packages like\n// @sentry/hub. If we don't do this, browser bundlers will have troubles resolving `require('domain')`.\nconst carrier = getMainCarrier();\nif (carrier.__SENTRY__) {\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  carrier.__SENTRY__.extensions.domain = carrier.__SENTRY__.extensions.domain || domain;\n}\n"]}import { Integration } from '@sentry/types';
/** Console module integration */
export declare class Console implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=console.d.ts.map{"version":3,"file":"console.d.ts","sourceRoot":"","sources":["../../../src/integrations/console.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAI5C,iCAAiC;AACjC,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,IAAI,IAAI;CAKzB"}import { __read, __spread, __values } from "tslib";
import { getCurrentHub } from '@sentry/core';
import { fill, severityFromString } from '@sentry/utils';
import * as util from 'util';
/** Console module integration */
var Console = /** @class */ (function () {
    function Console() {
        /**
         * @inheritDoc
         */
        this.name = Console.id;
    }
    /**
     * @inheritDoc
     */
    Console.prototype.setupOnce = function () {
        var e_1, _a;
        try {
            for (var _b = __values(['debug', 'info', 'warn', 'error', 'log']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var level = _c.value;
                fill(console, level, createConsoleWrapper(level));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @inheritDoc
     */
    Console.id = 'Console';
    return Console;
}());
export { Console };
/**
 * Wrapper function that'll be used for every console level
 */
function createConsoleWrapper(level) {
    return function consoleWrapper(originalConsoleMethod) {
        var sentryLevel = severityFromString(level);
        /* eslint-disable prefer-rest-params */
        return function () {
            if (getCurrentHub().getIntegration(Console)) {
                getCurrentHub().addBreadcrumb({
                    category: 'console',
                    level: sentryLevel,
                    message: util.format.apply(undefined, arguments),
                }, {
                    input: __spread(arguments),
                    level: level,
                });
            }
            originalConsoleMethod.apply(this, arguments);
        };
        /* eslint-enable prefer-rest-params */
    };
}
//# sourceMappingURL=console.js.map{"version":3,"file":"console.js","sourceRoot":"","sources":["../../../src/integrations/console.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAE7C,OAAO,EAAE,IAAI,EAAE,kBAAkB,EAAE,MAAM,eAAe,CAAC;AACzD,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAE7B,iCAAiC;AACjC;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,OAAO,CAAC,EAAE,CAAC;IAUnC,CAAC;IARC;;OAEG;IACI,2BAAS,GAAhB;;;YACE,KAAoB,IAAA,KAAA,SAAA,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA,gBAAA,4BAAE;gBAA1D,IAAM,KAAK,WAAA;gBACd,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC;aACnD;;;;;;;;;IACH,CAAC;IAjBD;;OAEG;IACW,UAAE,GAAW,SAAS,CAAC;IAevC,cAAC;CAAA,AAnBD,IAmBC;SAnBY,OAAO;AAqBpB;;GAEG;AACH,SAAS,oBAAoB,CAAC,KAAa;IACzC,OAAO,SAAS,cAAc,CAAC,qBAAiC;QAC9D,IAAM,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAE9C,uCAAuC;QACvC,OAAO;YACL,IAAI,aAAa,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;gBAC3C,aAAa,EAAE,CAAC,aAAa,CAC3B;oBACE,QAAQ,EAAE,SAAS;oBACnB,KAAK,EAAE,WAAW;oBAClB,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,SAAS,CAAC;iBACjD,EACD;oBACE,KAAK,WAAM,SAAS,CAAC;oBACrB,KAAK,OAAA;iBACN,CACF,CAAC;aACH;YAED,qBAAqB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QAC/C,CAAC,CAAC;QACF,sCAAsC;IACxC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Integration } from '@sentry/types';\nimport { fill, severityFromString } from '@sentry/utils';\nimport * as util from 'util';\n\n/** Console module integration */\nexport class Console implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Console';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Console.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    for (const level of ['debug', 'info', 'warn', 'error', 'log']) {\n      fill(console, level, createConsoleWrapper(level));\n    }\n  }\n}\n\n/**\n * Wrapper function that'll be used for every console level\n */\nfunction createConsoleWrapper(level: string): (originalConsoleMethod: () => void) => void {\n  return function consoleWrapper(originalConsoleMethod: () => void): () => void {\n    const sentryLevel = severityFromString(level);\n\n    /* eslint-disable prefer-rest-params */\n    return function (this: typeof console): void {\n      if (getCurrentHub().getIntegration(Console)) {\n        getCurrentHub().addBreadcrumb(\n          {\n            category: 'console',\n            level: sentryLevel,\n            message: util.format.apply(undefined, arguments),\n          },\n          {\n            input: [...arguments],\n            level,\n          },\n        );\n      }\n\n      originalConsoleMethod.apply(this, arguments);\n    };\n    /* eslint-enable prefer-rest-params */\n  };\n}\n"]}import { Event, EventProcessor, Integration, StackFrame } from '@sentry/types';
/**
 * Resets the file cache. Exists for testing purposes.
 * @hidden
 */
export declare function resetFileContentCache(): void;
interface ContextLinesOptions {
    /**
     * Sets the number of context lines for each frame when loading a file.
     * Defaults to 7.
     *
     * Set to 0 to disable loading and inclusion of source files.
     **/
    frameContextLines?: number;
}
/** Add node modules / packages to the event */
export declare class ContextLines implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    constructor(_options?: ContextLinesOptions);
    /** Get's the number of context lines to add */
    private get _contextLines();
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void;
    /** Processes an event and adds context lines */
    addSourceContext(event: Event): Promise<Event>;
    /** Adds context lines to frames */
    addSourceContextToFrames(frames: StackFrame[]): Promise<void>;
}
export {};
//# sourceMappingURL=contextlines.d.ts.map{"version":3,"file":"contextlines.d.ts","sourceRoot":"","sources":["../../../src/integrations/contextlines.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,WAAW,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAoB/E;;;GAGG;AACH,wBAAgB,qBAAqB,IAAI,IAAI,CAE5C;AAED,UAAU,mBAAmB;IAC3B;;;;;QAKI;IACJ,iBAAiB,CAAC,EAAE,MAAM,CAAC;CAC5B;AAED,+CAA+C;AAC/C,qBAAa,YAAa,YAAW,WAAW;IAW3B,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAV5C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAmB;gBAEF,QAAQ,GAAE,mBAAwB;IAEtE,+CAA+C;IAC/C,OAAO,KAAK,aAAa,GAYxB;IAED;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,GAAG,IAAI;IAInF,gDAAgD;IACnC,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;IAY3D,mCAAmC;IACtB,wBAAwB,CAAC,MAAM,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC;CAoB3E"}import { __awaiter, __generator, __values } from "tslib";
import { getCurrentHub } from '@sentry/core';
import { addContextToFrame } from '@sentry/utils';
import { readFile } from 'fs';
import { LRUMap } from 'lru_map';
var FILE_CONTENT_CACHE = new LRUMap(100);
var DEFAULT_LINES_OF_CONTEXT = 7;
// TODO: Replace with promisify when minimum supported node >= v8
function readTextFileAsync(path) {
    return new Promise(function (resolve, reject) {
        readFile(path, 'utf8', function (err, data) {
            if (err)
                reject(err);
            else
                resolve(data);
        });
    });
}
/**
 * Resets the file cache. Exists for testing purposes.
 * @hidden
 */
export function resetFileContentCache() {
    FILE_CONTENT_CACHE.clear();
}
/** Add node modules / packages to the event */
var ContextLines = /** @class */ (function () {
    function ContextLines(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = ContextLines.id;
    }
    Object.defineProperty(ContextLines.prototype, "_contextLines", {
        /** Get's the number of context lines to add */
        get: function () {
            var _a, _b;
            // This is only here to copy frameContextLines from init options if it hasn't
            // been set via this integrations constructor.
            //
            // TODO: Remove on next major!
            if (this._options.frameContextLines === undefined) {
                var initOptions = (_a = getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
                // eslint-disable-next-line deprecation/deprecation
                this._options.frameContextLines = (_b = initOptions) === null || _b === void 0 ? void 0 : _b.frameContextLines;
            }
            return this._options.frameContextLines !== undefined ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ContextLines.prototype.setupOnce = function (addGlobalEventProcessor) {
        var _this = this;
        addGlobalEventProcessor(function (event) { return _this.addSourceContext(event); });
    };
    /** Processes an event and adds context lines */
    ContextLines.prototype.addSourceContext = function (event) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var _c, _d, exception, e_1_1;
            var e_1, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!(this._contextLines > 0 && ((_a = event.exception) === null || _a === void 0 ? void 0 : _a.values))) return [3 /*break*/, 8];
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 6, 7, 8]);
                        _c = __values(event.exception.values), _d = _c.next();
                        _f.label = 2;
                    case 2:
                        if (!!_d.done) return [3 /*break*/, 5];
                        exception = _d.value;
                        if (!((_b = exception.stacktrace) === null || _b === void 0 ? void 0 : _b.frames)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.addSourceContextToFrames(exception.stacktrace.frames)];
                    case 3:
                        _f.sent();
                        _f.label = 4;
                    case 4:
                        _d = _c.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _f.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, event];
                }
            });
        });
    };
    /** Adds context lines to frames */
    ContextLines.prototype.addSourceContextToFrames = function (frames) {
        return __awaiter(this, void 0, void 0, function () {
            var contextLines, frames_1, frames_1_1, frame, sourceFile, lines, e_2_1;
            var e_2, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        contextLines = this._contextLines;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        frames_1 = __values(frames), frames_1_1 = frames_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!frames_1_1.done) return [3 /*break*/, 5];
                        frame = frames_1_1.value;
                        if (!(frame.filename && frame.context_line === undefined)) return [3 /*break*/, 4];
                        return [4 /*yield*/, _readSourceFile(frame.filename)];
                    case 3:
                        sourceFile = _b.sent();
                        if (sourceFile) {
                            try {
                                lines = sourceFile.split('\n');
                                addContextToFrame(lines, frame, contextLines);
                            }
                            catch (e) {
                                // anomaly, being defensive in case
                                // unlikely to ever happen in practice but can definitely happen in theory
                            }
                        }
                        _b.label = 4;
                    case 4:
                        frames_1_1 = frames_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (frames_1_1 && !frames_1_1.done && (_a = frames_1.return)) _a.call(frames_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @inheritDoc
     */
    ContextLines.id = 'ContextLines';
    return ContextLines;
}());
export { ContextLines };
/**
 * Reads file contents and caches them in a global LRU cache.
 *
 * @param filename filepath to read content from.
 */
function _readSourceFile(filename) {
    return __awaiter(this, void 0, void 0, function () {
        var cachedFile, content, _1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cachedFile = FILE_CONTENT_CACHE.get(filename);
                    // We have a cache hit
                    if (cachedFile !== undefined) {
                        return [2 /*return*/, cachedFile];
                    }
                    content = null;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, readTextFileAsync(filename)];
                case 2:
                    content = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    _1 = _a.sent();
                    return [3 /*break*/, 4];
                case 4:
                    FILE_CONTENT_CACHE.set(filename, content);
                    return [2 /*return*/, content];
            }
        });
    });
}
//# sourceMappingURL=contextlines.js.map{"version":3,"file":"contextlines.js","sourceRoot":"","sources":["../../../src/integrations/contextlines.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Event, EventProcessor, Integration, StackFrame } from '@sentry/types';\nimport { addContextToFrame } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nimport { NodeClient } from '../client';\n\nconst FILE_CONTENT_CACHE = new LRUMap<string, string | null>(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\ninterface ContextLinesOptions {\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   * Defaults to 7.\n   *\n   * Set to 0 to disable loading and inclusion of source files.\n   **/\n  frameContextLines?: number;\n}\n\n/** Add node modules / packages to the event */\nexport class ContextLines implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'ContextLines';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = ContextLines.id;\n\n  public constructor(private readonly _options: ContextLinesOptions = {}) {}\n\n  /** Get's the number of context lines to add */\n  private get _contextLines(): number {\n    // This is only here to copy frameContextLines from init options if it hasn't\n    // been set via this integrations constructor.\n    //\n    // TODO: Remove on next major!\n    if (this._options.frameContextLines === undefined) {\n      const initOptions = getCurrentHub().getClient<NodeClient>()?.getOptions();\n      // eslint-disable-next-line deprecation/deprecation\n      this._options.frameContextLines = initOptions?.frameContextLines;\n    }\n\n    return this._options.frameContextLines !== undefined ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void {\n    addGlobalEventProcessor(event => this.addSourceContext(event));\n  }\n\n  /** Processes an event and adds context lines */\n  public async addSourceContext(event: Event): Promise<Event> {\n    if (this._contextLines > 0 && event.exception?.values) {\n      for (const exception of event.exception.values) {\n        if (exception.stacktrace?.frames) {\n          await this.addSourceContextToFrames(exception.stacktrace.frames);\n        }\n      }\n    }\n\n    return event;\n  }\n\n  /** Adds context lines to frames */\n  public async addSourceContextToFrames(frames: StackFrame[]): Promise<void> {\n    const contextLines = this._contextLines;\n\n    for (const frame of frames) {\n      // Only add context if we have a filename and it hasn't already been added\n      if (frame.filename && frame.context_line === undefined) {\n        const sourceFile = await _readSourceFile(frame.filename);\n\n        if (sourceFile) {\n          try {\n            const lines = sourceFile.split('\\n');\n            addContextToFrame(lines, frame, contextLines);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Reads file contents and caches them in a global LRU cache.\n *\n * @param filename filepath to read content from.\n */\nasync function _readSourceFile(filename: string): Promise<string | null> {\n  const cachedFile = FILE_CONTENT_CACHE.get(filename);\n  // We have a cache hit\n  if (cachedFile !== undefined) {\n    return cachedFile;\n  }\n\n  let content: string | null = null;\n  try {\n    content = await readTextFileAsync(filename);\n  } catch (_) {\n    //\n  }\n\n  FILE_CONTENT_CACHE.set(filename, content);\n  return content;\n}\n"]}import { Integration } from '@sentry/types';
/** http module integration */
export declare class Http implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    private readonly _breadcrumbs;
    /**
     * @inheritDoc
     */
    private readonly _tracing;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        breadcrumbs?: boolean;
        tracing?: boolean;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/integrations/http.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAQ,MAAM,eAAe,CAAC;AAiBlD,8BAA8B;AAC9B,qBAAa,IAAK,YAAW,WAAW;IACtC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAU;IAElC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAW;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAU;IAEvC;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAU;IAEnC;;OAEG;gBACgB,OAAO,GAAE;QAAE,WAAW,CAAC,EAAE,OAAO,CAAC;QAAC,OAAO,CAAC,EAAE,OAAO,CAAA;KAAO;IAK7E;;OAEG;IACI,SAAS,IAAI,IAAI;CAuBzB"}import { __assign } from "tslib";
import { getCurrentHub } from '@sentry/core';
import { fill, logger, parseSemver } from '@sentry/utils';
import { IS_DEBUG_BUILD } from '../flags';
import { cleanSpanDescription, extractUrl, isSentryRequest, normalizeRequestArgs, } from './utils/http';
var NODE_VERSION = parseSemver(process.versions.node);
/** http module integration */
var Http = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function Http(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Http.id;
        this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
        this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;
    }
    /**
     * @inheritDoc
     */
    Http.prototype.setupOnce = function () {
        // No need to instrument if we don't want to track anything
        if (!this._breadcrumbs && !this._tracing) {
            return;
        }
        var wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var httpModule = require('http');
        fill(httpModule, 'get', wrappedHandlerMaker);
        fill(httpModule, 'request', wrappedHandlerMaker);
        // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.
        // If we do, we'd get double breadcrumbs and double spans for `https` calls.
        // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.
        if (NODE_VERSION.major && NODE_VERSION.major > 8) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            var httpsModule = require('https');
            fill(httpsModule, 'get', wrappedHandlerMaker);
            fill(httpsModule, 'request', wrappedHandlerMaker);
        }
    };
    /**
     * @inheritDoc
     */
    Http.id = 'Http';
    return Http;
}());
export { Http };
/**
 * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`
 * and `https` modules. (NB: Not a typo - this is a creator^2!)
 *
 * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs
 * @param tracingEnabled Whether or not to record outgoing requests as tracing spans
 *
 * @returns A function which accepts the exiting handler and returns a wrapped handler
 */
function _createWrappedRequestMethodFactory(breadcrumbsEnabled, tracingEnabled) {
    return function wrappedRequestMethodFactory(originalRequestMethod) {
        return function wrappedMethod() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var httpModule = this;
            var requestArgs = normalizeRequestArgs(this, args);
            var requestOptions = requestArgs[0];
            var requestUrl = extractUrl(requestOptions);
            // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method
            if (isSentryRequest(requestUrl)) {
                return originalRequestMethod.apply(httpModule, requestArgs);
            }
            var span;
            var parentSpan;
            var scope = getCurrentHub().getScope();
            if (scope && tracingEnabled) {
                parentSpan = scope.getSpan();
                if (parentSpan) {
                    span = parentSpan.startChild({
                        description: (requestOptions.method || 'GET') + " " + requestUrl,
                        op: 'http.client',
                    });
                    var sentryTraceHeader = span.toTraceparent();
                    IS_DEBUG_BUILD &&
                        logger.log("[Tracing] Adding sentry-trace header " + sentryTraceHeader + " to outgoing request to " + requestUrl + ": ");
                    requestOptions.headers = __assign(__assign({}, requestOptions.headers), { 'sentry-trace': sentryTraceHeader });
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            return originalRequestMethod
                .apply(httpModule, requestArgs)
                .once('response', function (res) {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var req = this;
                if (breadcrumbsEnabled) {
                    addRequestBreadcrumb('response', requestUrl, req, res);
                }
                if (tracingEnabled && span) {
                    if (res.statusCode) {
                        span.setHttpStatus(res.statusCode);
                    }
                    span.description = cleanSpanDescription(span.description, requestOptions, req);
                    span.finish();
                }
            })
                .once('error', function () {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var req = this;
                if (breadcrumbsEnabled) {
                    addRequestBreadcrumb('error', requestUrl, req);
                }
                if (tracingEnabled && span) {
                    span.setHttpStatus(500);
                    span.description = cleanSpanDescription(span.description, requestOptions, req);
                    span.finish();
                }
            });
        };
    };
}
/**
 * Captures Breadcrumb based on provided request/response pair
 */
function addRequestBreadcrumb(event, url, req, res) {
    if (!getCurrentHub().getIntegration(Http)) {
        return;
    }
    getCurrentHub().addBreadcrumb({
        category: 'http',
        data: {
            method: req.method,
            status_code: res && res.statusCode,
            url: url,
        },
        type: 'http',
    }, {
        event: event,
        request: req,
        response: res,
    });
}
//# sourceMappingURL=http.js.map{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../src/integrations/http.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Integration, Span } from '@sentry/types';\nimport { fill, logger, parseSemver } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\n\nimport { IS_DEBUG_BUILD } from '../flags';\nimport {\n  cleanSpanDescription,\n  extractUrl,\n  isSentryRequest,\n  normalizeRequestArgs,\n  RequestMethod,\n  RequestMethodArgs,\n} from './utils/http';\n\nconst NODE_VERSION = parseSemver(process.versions.node);\n\n/** http module integration */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Http';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Http.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _breadcrumbs: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _tracing: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { breadcrumbs?: boolean; tracing?: boolean } = {}) {\n    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;\n    this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    // No need to instrument if we don't want to track anything\n    if (!this._breadcrumbs && !this._tracing) {\n      return;\n    }\n\n    const wrappedHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, this._tracing);\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const httpModule = require('http');\n    fill(httpModule, 'get', wrappedHandlerMaker);\n    fill(httpModule, 'request', wrappedHandlerMaker);\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // If we do, we'd get double breadcrumbs and double spans for `https` calls.\n    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.\n    if (NODE_VERSION.major && NODE_VERSION.major > 8) {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const httpsModule = require('https');\n      fill(httpsModule, 'get', wrappedHandlerMaker);\n      fill(httpsModule, 'request', wrappedHandlerMaker);\n    }\n  }\n}\n\n// for ease of reading below\ntype OriginalRequestMethod = RequestMethod;\ntype WrappedRequestMethod = RequestMethod;\ntype WrappedRequestMethodFactory = (original: OriginalRequestMethod) => WrappedRequestMethod;\n\n/**\n * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`\n * and `https` modules. (NB: Not a typo - this is a creator^2!)\n *\n * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs\n * @param tracingEnabled Whether or not to record outgoing requests as tracing spans\n *\n * @returns A function which accepts the exiting handler and returns a wrapped handler\n */\nfunction _createWrappedRequestMethodFactory(\n  breadcrumbsEnabled: boolean,\n  tracingEnabled: boolean,\n): WrappedRequestMethodFactory {\n  return function wrappedRequestMethodFactory(originalRequestMethod: OriginalRequestMethod): WrappedRequestMethod {\n    return function wrappedMethod(this: typeof http | typeof https, ...args: RequestMethodArgs): http.ClientRequest {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const httpModule = this;\n\n      const requestArgs = normalizeRequestArgs(this, args);\n      const requestOptions = requestArgs[0];\n      const requestUrl = extractUrl(requestOptions);\n\n      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method\n      if (isSentryRequest(requestUrl)) {\n        return originalRequestMethod.apply(httpModule, requestArgs);\n      }\n\n      let span: Span | undefined;\n      let parentSpan: Span | undefined;\n\n      const scope = getCurrentHub().getScope();\n      if (scope && tracingEnabled) {\n        parentSpan = scope.getSpan();\n        if (parentSpan) {\n          span = parentSpan.startChild({\n            description: `${requestOptions.method || 'GET'} ${requestUrl}`,\n            op: 'http.client',\n          });\n\n          const sentryTraceHeader = span.toTraceparent();\n          IS_DEBUG_BUILD &&\n            logger.log(\n              `[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to ${requestUrl}: `,\n            );\n          requestOptions.headers = { ...requestOptions.headers, 'sentry-trace': sentryTraceHeader };\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalRequestMethod\n        .apply(httpModule, requestArgs)\n        .once('response', function (this: http.ClientRequest, res: http.IncomingMessage): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('response', requestUrl, req, res);\n          }\n          if (tracingEnabled && span) {\n            if (res.statusCode) {\n              span.setHttpStatus(res.statusCode);\n            }\n            span.description = cleanSpanDescription(span.description, requestOptions, req);\n            span.finish();\n          }\n        })\n        .once('error', function (this: http.ClientRequest): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('error', requestUrl, req);\n          }\n          if (tracingEnabled && span) {\n            span.setHttpStatus(500);\n            span.description = cleanSpanDescription(span.description, requestOptions, req);\n            span.finish();\n          }\n        });\n    };\n  };\n}\n\n/**\n * Captures Breadcrumb based on provided request/response pair\n */\nfunction addRequestBreadcrumb(event: string, url: string, req: http.ClientRequest, res?: http.IncomingMessage): void {\n  if (!getCurrentHub().getIntegration(Http)) {\n    return;\n  }\n\n  getCurrentHub().addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        method: req.method,\n        status_code: res && res.statusCode,\n        url,\n      },\n      type: 'http',\n    },\n    {\n      event,\n      request: req,\n      response: res,\n    },\n  );\n}\n"]}export { Console } from './console';
export { Http } from './http';
export { OnUncaughtException } from './onuncaughtexception';
export { OnUnhandledRejection } from './onunhandledrejection';
export { LinkedErrors } from './linkederrors';
export { Modules } from './modules';
export { ContextLines } from './contextlines';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC"}export { Console } from './console';
export { Http } from './http';
export { OnUncaughtException } from './onuncaughtexception';
export { OnUnhandledRejection } from './onunhandledrejection';
export { LinkedErrors } from './linkederrors';
export { Modules } from './modules';
export { ContextLines } from './contextlines';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC","sourcesContent":["export { Console } from './console';\nexport { Http } from './http';\nexport { OnUncaughtException } from './onuncaughtexception';\nexport { OnUnhandledRejection } from './onunhandledrejection';\nexport { LinkedErrors } from './linkederrors';\nexport { Modules } from './modules';\nexport { ContextLines } from './contextlines';\n"]}import { Integration } from '@sentry/types';
/** Adds SDK info to an event. */
export declare class LinkedErrors implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    readonly name: string;
    /**
     * @inheritDoc
     */
    private readonly _key;
    /**
     * @inheritDoc
     */
    private readonly _limit;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        key?: string;
        limit?: number;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @inheritDoc
     */
    private _handler;
    /**
     * @inheritDoc
     */
    private _walkErrorTree;
}
//# sourceMappingURL=linkederrors.d.ts.map{"version":3,"file":"linkederrors.d.ts","sourceRoot":"","sources":["../../../src/integrations/linkederrors.ts"],"names":[],"mappings":"AACA,OAAO,EAA8C,WAAW,EAAE,MAAM,eAAe,CAAC;AASxF,iCAAiC;AACjC,qBAAa,YAAa,YAAW,WAAW;IAC9C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACH,SAAgB,IAAI,EAAE,MAAM,CAAmB;IAE/C;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAS;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAS;IAEhC;;OAEG;gBACgB,OAAO,GAAE;QAAE,GAAG,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAO;IAKjE;;OAEG;IACI,SAAS,IAAI,IAAI;IAWxB;;OAEG;IACH,OAAO,CAAC,QAAQ;IAmBhB;;OAEG;YACW,cAAc;CAsB7B"}import { __awaiter, __generator, __read, __spread } from "tslib";
import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';
import { isInstanceOf, resolvedSyncPromise, SyncPromise } from '@sentry/utils';
import { exceptionFromError } from '../eventbuilder';
import { ContextLines } from './contextlines';
var DEFAULT_KEY = 'cause';
var DEFAULT_LIMIT = 5;
/** Adds SDK info to an event. */
var LinkedErrors = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function LinkedErrors(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = LinkedErrors.id;
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
    }
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype.setupOnce = function () {
        addGlobalEventProcessor(function (event, hint) {
            var self = getCurrentHub().getIntegration(LinkedErrors);
            if (self) {
                var handler = self._handler && self._handler.bind(self);
                return typeof handler === 'function' ? handler(event, hint) : event;
            }
            return event;
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype._handler = function (event, hint) {
        var _this = this;
        if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
            return resolvedSyncPromise(event);
        }
        return new SyncPromise(function (resolve) {
            void _this._walkErrorTree(hint.originalException, _this._key)
                .then(function (linkedErrors) {
                if (event && event.exception && event.exception.values) {
                    event.exception.values = __spread(linkedErrors, event.exception.values);
                }
                resolve(event);
            })
                .then(null, function () {
                resolve(event);
            });
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.prototype._walkErrorTree = function (error, key, stack) {
        if (stack === void 0) { stack = []; }
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var exception, contextLines;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
                            return [2 /*return*/, Promise.resolve(stack)];
                        }
                        exception = exceptionFromError(error[key]);
                        contextLines = getCurrentHub().getIntegration(ContextLines);
                        if (!(contextLines && ((_a = exception.stacktrace) === null || _a === void 0 ? void 0 : _a.frames))) return [3 /*break*/, 2];
                        return [4 /*yield*/, contextLines.addSourceContextToFrames(exception.stacktrace.frames)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                            void _this._walkErrorTree(error[key], key, __spread([exception], stack))
                                .then(resolve)
                                .then(null, function () {
                                reject();
                            });
                        })];
                }
            });
        });
    };
    /**
     * @inheritDoc
     */
    LinkedErrors.id = 'LinkedErrors';
    return LinkedErrors;
}());
export { LinkedErrors };
//# sourceMappingURL=linkederrors.js.map{"version":3,"file":"linkederrors.js","sourceRoot":"","sources":["../../../src/integrations/linkederrors.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,uBAAuB,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAEtE,OAAO,EAAE,YAAY,EAAE,mBAAmB,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAE/E,OAAO,EAAE,kBAAkB,EAAE,MAAM,iBAAiB,CAAC;AACrD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAE9C,IAAM,WAAW,GAAG,OAAO,CAAC;AAC5B,IAAM,aAAa,GAAG,CAAC,CAAC;AAExB,iCAAiC;AACjC;IAqBE;;OAEG;IACH,sBAAmB,OAA8C;QAA9C,wBAAA,EAAA,YAA8C;QAlBjE;;WAEG;QACa,SAAI,GAAW,YAAY,CAAC,EAAE,CAAC;QAgB7C,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,GAAG,IAAI,WAAW,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,IAAI,aAAa,CAAC;IAC/C,CAAC;IAED;;OAEG;IACI,gCAAS,GAAhB;QACE,uBAAuB,CAAC,UAAC,KAAY,EAAE,IAAgB;YACrD,IAAM,IAAI,GAAG,aAAa,EAAE,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;YAC1D,IAAI,IAAI,EAAE;gBACR,IAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC1D,OAAO,OAAO,OAAO,KAAK,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;aACrE;YACD,OAAO,KAAK,CAAC;QACf,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,+BAAQ,GAAhB,UAAiB,KAAY,EAAE,IAAgB;QAA/C,iBAiBC;QAhBC,IAAI,CAAC,KAAK,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,iBAAiB,EAAE,KAAK,CAAC,EAAE;YACxG,OAAO,mBAAmB,CAAC,KAAK,CAAC,CAAC;SACnC;QAED,OAAO,IAAI,WAAW,CAAQ,UAAA,OAAO;YACnC,KAAK,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC,iBAA0B,EAAE,KAAI,CAAC,IAAI,CAAC;iBACjE,IAAI,CAAC,UAAC,YAAyB;gBAC9B,IAAI,KAAK,IAAI,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE;oBACtD,KAAK,CAAC,SAAS,CAAC,MAAM,YAAO,YAAY,EAAK,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;iBACvE;gBACD,OAAO,CAAC,KAAK,CAAC,CAAC;YACjB,CAAC,CAAC;iBACD,IAAI,CAAC,IAAI,EAAE;gBACV,OAAO,CAAC,KAAK,CAAC,CAAC;YACjB,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACW,qCAAc,GAA5B,UAA6B,KAAoB,EAAE,GAAW,EAAE,KAAuB;QAAvB,sBAAA,EAAA,UAAuB;;;;;;;;wBACrF,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE;4BACvE,sBAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAC;yBAC/B;wBAEK,SAAS,GAAG,kBAAkB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;wBAI3C,YAAY,GAAG,aAAa,EAAE,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;6BAC9D,CAAA,YAAY,WAAI,SAAS,CAAC,UAAU,0CAAE,MAAM,CAAA,CAAA,EAA5C,wBAA4C;wBAC9C,qBAAM,YAAY,CAAC,wBAAwB,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,EAAA;;wBAAxE,SAAwE,CAAC;;4BAG3E,sBAAO,IAAI,OAAO,CAAc,UAAC,OAAO,EAAE,MAAM;4BAC9C,KAAK,KAAI,CAAC,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,GAAG,YAAG,SAAS,GAAK,KAAK,EAAE;iCAC7D,IAAI,CAAC,OAAO,CAAC;iCACb,IAAI,CAAC,IAAI,EAAE;gCACV,MAAM,EAAE,CAAC;4BACX,CAAC,CAAC,CAAC;wBACP,CAAC,CAAC,EAAC;;;;KACJ;IAxFD;;OAEG;IACW,eAAE,GAAW,cAAc,CAAC;IAsF5C,mBAAC;CAAA,AA1FD,IA0FC;SA1FY,YAAY","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Exception, ExtendedError, Integration } from '@sentry/types';\nimport { isInstanceOf, resolvedSyncPromise, SyncPromise } from '@sentry/utils';\n\nimport { exceptionFromError } from '../eventbuilder';\nimport { ContextLines } from './contextlines';\n\nconst DEFAULT_KEY = 'cause';\nconst DEFAULT_LIMIT = 5;\n\n/** Adds SDK info to an event. */\nexport class LinkedErrors implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'LinkedErrors';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string = LinkedErrors.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _key: string;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _limit: number;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { key?: string; limit?: number } = {}) {\n    this._key = options.key || DEFAULT_KEY;\n    this._limit = options.limit || DEFAULT_LIMIT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    addGlobalEventProcessor((event: Event, hint?: EventHint) => {\n      const self = getCurrentHub().getIntegration(LinkedErrors);\n      if (self) {\n        const handler = self._handler && self._handler.bind(self);\n        return typeof handler === 'function' ? handler(event, hint) : event;\n      }\n      return event;\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  private _handler(event: Event, hint?: EventHint): PromiseLike<Event> {\n    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n      return resolvedSyncPromise(event);\n    }\n\n    return new SyncPromise<Event>(resolve => {\n      void this._walkErrorTree(hint.originalException as Error, this._key)\n        .then((linkedErrors: Exception[]) => {\n          if (event && event.exception && event.exception.values) {\n            event.exception.values = [...linkedErrors, ...event.exception.values];\n          }\n          resolve(event);\n        })\n        .then(null, () => {\n          resolve(event);\n        });\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  private async _walkErrorTree(error: ExtendedError, key: string, stack: Exception[] = []): Promise<Exception[]> {\n    if (!isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {\n      return Promise.resolve(stack);\n    }\n\n    const exception = exceptionFromError(error[key]);\n\n    // If the ContextLines integration is enabled, we add source code context to linked errors\n    // because we can't guarantee the order that integrations are run.\n    const contextLines = getCurrentHub().getIntegration(ContextLines);\n    if (contextLines && exception.stacktrace?.frames) {\n      await contextLines.addSourceContextToFrames(exception.stacktrace.frames);\n    }\n\n    return new Promise<Exception[]>((resolve, reject) => {\n      void this._walkErrorTree(error[key], key, [exception, ...stack])\n        .then(resolve)\n        .then(null, () => {\n          reject();\n        });\n    });\n  }\n}\n"]}import { EventProcessor, Hub, Integration } from '@sentry/types';
/** Add node modules / packages to the event */
export declare class Modules implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    private _getModules;
}
//# sourceMappingURL=modules.d.ts.map{"version":3,"file":"modules.d.ts","sourceRoot":"","sources":["../../../src/integrations/modules.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAmEjE,+CAA+C;AAC/C,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;IAY7G,kGAAkG;IAClG,OAAO,CAAC,WAAW;CAMpB"}import { __assign } from "tslib";
import { existsSync, readFileSync } from 'fs';
import { dirname, join } from 'path';
var moduleCache;
/** Extract information about paths */
function getPaths() {
    try {
        return require.cache ? Object.keys(require.cache) : [];
    }
    catch (e) {
        return [];
    }
}
/** Extract information about package.json modules */
function collectModules() {
    var mainPaths = (require.main && require.main.paths) || [];
    var paths = getPaths();
    var infos = {};
    var seen = {};
    paths.forEach(function (path) {
        var dir = path;
        /** Traverse directories upward in the search of package.json file */
        var updir = function () {
            var orig = dir;
            dir = dirname(orig);
            if (!dir || orig === dir || seen[orig]) {
                return undefined;
            }
            if (mainPaths.indexOf(dir) < 0) {
                return updir();
            }
            var pkgfile = join(orig, 'package.json');
            seen[orig] = true;
            if (!existsSync(pkgfile)) {
                return updir();
            }
            try {
                var info = JSON.parse(readFileSync(pkgfile, 'utf8'));
                infos[info.name] = info.version;
            }
            catch (_oO) {
                // no-empty
            }
        };
        updir();
    });
    return infos;
}
/** Add node modules / packages to the event */
var Modules = /** @class */ (function () {
    function Modules() {
        /**
         * @inheritDoc
         */
        this.name = Modules.id;
    }
    /**
     * @inheritDoc
     */
    Modules.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        var _this = this;
        addGlobalEventProcessor(function (event) {
            if (!getCurrentHub().getIntegration(Modules)) {
                return event;
            }
            return __assign(__assign({}, event), { modules: _this._getModules() });
        });
    };
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    Modules.prototype._getModules = function () {
        if (!moduleCache) {
            moduleCache = collectModules();
        }
        return moduleCache;
    };
    /**
     * @inheritDoc
     */
    Modules.id = 'Modules';
    return Modules;
}());
export { Modules };
//# sourceMappingURL=modules.js.map{"version":3,"file":"modules.js","sourceRoot":"","sources":["../../../src/integrations/modules.ts"],"names":[],"mappings":";AACA,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,MAAM,IAAI,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAErC,IAAI,WAAsC,CAAC;AAE3C,sCAAsC;AACtC,SAAS,QAAQ;IACf,IAAI;QACF,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAgC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;KACnF;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,EAAE,CAAC;KACX;AACH,CAAC;AAED,qDAAqD;AACrD,SAAS,cAAc;IAGrB,IAAM,SAAS,GAAG,CAAC,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IAC7D,IAAM,KAAK,GAAG,QAAQ,EAAE,CAAC;IACzB,IAAM,KAAK,GAEP,EAAE,CAAC;IACP,IAAM,IAAI,GAEN,EAAE,CAAC;IAEP,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;QAChB,IAAI,GAAG,GAAG,IAAI,CAAC;QAEf,qEAAqE;QACrE,IAAM,KAAK,GAAG;YACZ,IAAM,IAAI,GAAG,GAAG,CAAC;YACjB,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;YAEpB,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE;gBACtC,OAAO,SAAS,CAAC;aAClB;YACD,IAAI,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBAC9B,OAAO,KAAK,EAAE,CAAC;aAChB;YAED,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;YAC3C,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAElB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;gBACxB,OAAO,KAAK,EAAE,CAAC;aAChB;YAED,IAAI;gBACF,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,CAAC,CAGpD,CAAC;gBACF,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;aACjC;YAAC,OAAO,GAAG,EAAE;gBACZ,WAAW;aACZ;QACH,CAAC,CAAC;QAEF,KAAK,EAAE,CAAC;IACV,CAAC,CAAC,CAAC;IAEH,OAAO,KAAK,CAAC;AACf,CAAC;AAED,+CAA+C;AAC/C;IAAA;QAME;;WAEG;QACI,SAAI,GAAW,OAAO,CAAC,EAAE,CAAC;IAwBnC,CAAC;IAtBC;;OAEG;IACI,2BAAS,GAAhB,UAAiB,uBAA2D,EAAE,aAAwB;QAAtG,iBAUC;QATC,uBAAuB,CAAC,UAAA,KAAK;YAC3B,IAAI,CAAC,aAAa,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;gBAC5C,OAAO,KAAK,CAAC;aACd;YACD,6BACK,KAAK,KACR,OAAO,EAAE,KAAI,CAAC,WAAW,EAAE,IAC3B;QACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAED,kGAAkG;IAC1F,6BAAW,GAAnB;QACE,IAAI,CAAC,WAAW,EAAE;YAChB,WAAW,GAAG,cAAc,EAAE,CAAC;SAChC;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IA/BD;;OAEG;IACW,UAAE,GAAW,SAAS,CAAC;IA6BvC,cAAC;CAAA,AAjCD,IAiCC;SAjCY,OAAO","sourcesContent":["import { EventProcessor, Hub, Integration } from '@sentry/types';\nimport { existsSync, readFileSync } from 'fs';\nimport { dirname, join } from 'path';\n\nlet moduleCache: { [key: string]: string };\n\n/** Extract information about paths */\nfunction getPaths(): string[] {\n  try {\n    return require.cache ? Object.keys(require.cache as Record<string, unknown>) : [];\n  } catch (e) {\n    return [];\n  }\n}\n\n/** Extract information about package.json modules */\nfunction collectModules(): {\n  [name: string]: string;\n} {\n  const mainPaths = (require.main && require.main.paths) || [];\n  const paths = getPaths();\n  const infos: {\n    [name: string]: string;\n  } = {};\n  const seen: {\n    [path: string]: boolean;\n  } = {};\n\n  paths.forEach(path => {\n    let dir = path;\n\n    /** Traverse directories upward in the search of package.json file */\n    const updir = (): void | (() => void) => {\n      const orig = dir;\n      dir = dirname(orig);\n\n      if (!dir || orig === dir || seen[orig]) {\n        return undefined;\n      }\n      if (mainPaths.indexOf(dir) < 0) {\n        return updir();\n      }\n\n      const pkgfile = join(orig, 'package.json');\n      seen[orig] = true;\n\n      if (!existsSync(pkgfile)) {\n        return updir();\n      }\n\n      try {\n        const info = JSON.parse(readFileSync(pkgfile, 'utf8')) as {\n          name: string;\n          version: string;\n        };\n        infos[info.name] = info.version;\n      } catch (_oO) {\n        // no-empty\n      }\n    };\n\n    updir();\n  });\n\n  return infos;\n}\n\n/** Add node modules / packages to the event */\nexport class Modules implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Modules';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Modules.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor(event => {\n      if (!getCurrentHub().getIntegration(Modules)) {\n        return event;\n      }\n      return {\n        ...event,\n        modules: this._getModules(),\n      };\n    });\n  }\n\n  /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */\n  private _getModules(): { [key: string]: string } {\n    if (!moduleCache) {\n      moduleCache = collectModules();\n    }\n    return moduleCache;\n  }\n}\n"]}import { Integration } from '@sentry/types';
/** Global Promise Rejection handler */
export declare class OnUncaughtException implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    readonly handler: (error: Error) => void;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Default onFatalError handler
         * @param firstError Error that has been thrown
         * @param secondError If this was called multiple times this will be set
         */
        onFatalError?(firstError: Error, secondError?: Error): void;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @hidden
     */
    private _makeErrorHandler;
}
//# sourceMappingURL=onuncaughtexception.d.ts.map{"version":3,"file":"onuncaughtexception.d.ts","sourceRoot":"","sources":["../../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAY,MAAM,eAAe,CAAC;AAStD,uCAAuC;AACvC,qBAAa,mBAAoB,YAAW,WAAW;IAoBnD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAnB3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAyB;IAEjD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA0B;IAE7C;;OAEG;IACH,SAAgB,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,CAA4B;IAE3E;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;;WAIG;QACH,YAAY,CAAC,CAAC,UAAU,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;KACxD;IAER;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;OAEG;IACH,OAAO,CAAC,iBAAiB;CA+E1B"}import { getCurrentHub } from '@sentry/core';
import { Severity } from '@sentry/types';
import { logger } from '@sentry/utils';
import { IS_DEBUG_BUILD } from '../flags';
import { logAndExitProcess } from './utils/errorhandling';
/** Global Promise Rejection handler */
var OnUncaughtException = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUncaughtException(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUncaughtException.id;
        /**
         * @inheritDoc
         */
        this.handler = this._makeErrorHandler();
    }
    /**
     * @inheritDoc
     */
    OnUncaughtException.prototype.setupOnce = function () {
        global.process.on('uncaughtException', this.handler.bind(this));
    };
    /**
     * @hidden
     */
    OnUncaughtException.prototype._makeErrorHandler = function () {
        var _this = this;
        var timeout = 2000;
        var caughtFirstError = false;
        var caughtSecondError = false;
        var calledFatalError = false;
        var firstError;
        return function (error) {
            var onFatalError = logAndExitProcess;
            var client = getCurrentHub().getClient();
            if (_this._options.onFatalError) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                onFatalError = _this._options.onFatalError;
            }
            else if (client && client.getOptions().onFatalError) {
                // eslint-disable-next-line @typescript-eslint/unbound-method
                onFatalError = client.getOptions().onFatalError;
            }
            if (!caughtFirstError) {
                var hub_1 = getCurrentHub();
                // this is the first uncaught error and the ultimate reason for shutting down
                // we want to do absolutely everything possible to ensure it gets captured
                // also we want to make sure we don't go recursion crazy if more errors happen after this one
                firstError = error;
                caughtFirstError = true;
                if (hub_1.getIntegration(OnUncaughtException)) {
                    hub_1.withScope(function (scope) {
                        scope.setLevel(Severity.Fatal);
                        hub_1.captureException(error, {
                            originalException: error,
                            data: { mechanism: { handled: false, type: 'onuncaughtexception' } },
                        });
                        if (!calledFatalError) {
                            calledFatalError = true;
                            onFatalError(error);
                        }
                    });
                }
                else {
                    if (!calledFatalError) {
                        calledFatalError = true;
                        onFatalError(error);
                    }
                }
            }
            else if (calledFatalError) {
                // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down
                IS_DEBUG_BUILD &&
                    logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');
                logAndExitProcess(error);
            }
            else if (!caughtSecondError) {
                // two cases for how we can hit this branch:
                //   - capturing of first error blew up and we just caught the exception from that
                //     - quit trying to capture, proceed with shutdown
                //   - a second independent error happened while waiting for first error to capture
                //     - want to avoid causing premature shutdown before first error capture finishes
                // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff
                // so let's instead just delay a bit before we proceed with our action here
                // in case 1, we just wait a bit unnecessarily but ultimately do the same thing
                // in case 2, the delay hopefully made us wait long enough for the capture to finish
                // two potential nonideal outcomes:
                //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError
                //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error
                // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)
                //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish
                caughtSecondError = true;
                setTimeout(function () {
                    if (!calledFatalError) {
                        // it was probably case 1, let's treat err as the sendErr and call onFatalError
                        calledFatalError = true;
                        onFatalError(firstError, error);
                    }
                    else {
                        // it was probably case 2, our first error finished capturing while we waited, cool, do nothing
                    }
                }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc
            }
        };
    };
    /**
     * @inheritDoc
     */
    OnUncaughtException.id = 'OnUncaughtException';
    return OnUncaughtException;
}());
export { OnUncaughtException };
//# sourceMappingURL=onuncaughtexception.js.map{"version":3,"file":"onuncaughtexception.js","sourceRoot":"","sources":["../../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, Scope } from '@sentry/core';\nimport { Integration, Severity } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { NodeClient } from '../client';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { logAndExitProcess } from './utils/errorhandling';\n\ntype OnFatalErrorHandler = (firstError: Error, secondError?: Error) => void;\n\n/** Global Promise Rejection handler */\nexport class OnUncaughtException implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUncaughtException';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUncaughtException.id;\n\n  /**\n   * @inheritDoc\n   */\n  public readonly handler: (error: Error) => void = this._makeErrorHandler();\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly _options: {\n      /**\n       * Default onFatalError handler\n       * @param firstError Error that has been thrown\n       * @param secondError If this was called multiple times this will be set\n       */\n      onFatalError?(firstError: Error, secondError?: Error): void;\n    } = {},\n  ) {}\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('uncaughtException', this.handler.bind(this));\n  }\n\n  /**\n   * @hidden\n   */\n  private _makeErrorHandler(): (error: Error) => void {\n    const timeout = 2000;\n    let caughtFirstError: boolean = false;\n    let caughtSecondError: boolean = false;\n    let calledFatalError: boolean = false;\n    let firstError: Error;\n\n    return (error: Error): void => {\n      let onFatalError: OnFatalErrorHandler = logAndExitProcess;\n      const client = getCurrentHub().getClient<NodeClient>();\n\n      if (this._options.onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = this._options.onFatalError;\n      } else if (client && client.getOptions().onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = client.getOptions().onFatalError as OnFatalErrorHandler;\n      }\n\n      if (!caughtFirstError) {\n        const hub = getCurrentHub();\n\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (hub.getIntegration(OnUncaughtException)) {\n          hub.withScope((scope: Scope) => {\n            scope.setLevel(Severity.Fatal);\n            hub.captureException(error, {\n              originalException: error,\n              data: { mechanism: { handled: false, type: 'onuncaughtexception' } },\n            });\n            if (!calledFatalError) {\n              calledFatalError = true;\n              onFatalError(error);\n            }\n          });\n        } else {\n          if (!calledFatalError) {\n            calledFatalError = true;\n            onFatalError(error);\n          }\n        }\n      } else if (calledFatalError) {\n        // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n        IS_DEBUG_BUILD &&\n          logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n        logAndExitProcess(error);\n      } else if (!caughtSecondError) {\n        // two cases for how we can hit this branch:\n        //   - capturing of first error blew up and we just caught the exception from that\n        //     - quit trying to capture, proceed with shutdown\n        //   - a second independent error happened while waiting for first error to capture\n        //     - want to avoid causing premature shutdown before first error capture finishes\n        // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n        // so let's instead just delay a bit before we proceed with our action here\n        // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n        // in case 2, the delay hopefully made us wait long enough for the capture to finish\n        // two potential nonideal outcomes:\n        //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n        //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n        // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n        //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n        caughtSecondError = true;\n        setTimeout(() => {\n          if (!calledFatalError) {\n            // it was probably case 1, let's treat err as the sendErr and call onFatalError\n            calledFatalError = true;\n            onFatalError(firstError, error);\n          } else {\n            // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n          }\n        }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n      }\n    };\n  }\n}\n"]}import { Integration } from '@sentry/types';
declare type UnhandledRejectionMode = 'none' | 'warn' | 'strict';
/** Global Promise Rejection handler */
export declare class OnUnhandledRejection implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Option deciding what to do after capturing unhandledRejection,
         * that mimicks behavior of node's --unhandled-rejection flag.
         */
        mode: UnhandledRejectionMode;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    sendUnhandledPromise(reason: any, promise: any): void;
    /**
     * Handler for `mode` option
     */
    private _handleRejection;
}
export {};
//# sourceMappingURL=onunhandledrejection.d.ts.map{"version":3,"file":"onunhandledrejection.d.ts","sourceRoot":"","sources":["../../../src/integrations/onunhandledrejection.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAK5C,aAAK,sBAAsB,GAAG,MAAM,GAAG,MAAM,GAAG,QAAQ,CAAC;AAEzD,uCAAuC;AACvC,qBAAa,oBAAqB,YAAW,WAAW;IAepD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAd3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAA0B;IAElD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA2B;IAE9C;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;WAGG;QACH,IAAI,EAAE,sBAAsB,CAAC;KACX;IAGtB;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;;;OAIG;IAEI,oBAAoB,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG,IAAI;IAmC5D;;OAEG;IAEH,OAAO,CAAC,gBAAgB;CAuBzB"}import { getCurrentHub } from '@sentry/core';
import { consoleSandbox } from '@sentry/utils';
import { logAndExitProcess } from './utils/errorhandling';
/** Global Promise Rejection handler */
var OnUnhandledRejection = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUnhandledRejection(_options) {
        if (_options === void 0) { _options = { mode: 'warn' }; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUnhandledRejection.id;
    }
    /**
     * @inheritDoc
     */
    OnUnhandledRejection.prototype.setupOnce = function () {
        global.process.on('unhandledRejection', this.sendUnhandledPromise.bind(this));
    };
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
    OnUnhandledRejection.prototype.sendUnhandledPromise = function (reason, promise) {
        var hub = getCurrentHub();
        if (!hub.getIntegration(OnUnhandledRejection)) {
            this._handleRejection(reason);
            return;
        }
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        var context = (promise.domain && promise.domain.sentryContext) || {};
        hub.withScope(function (scope) {
            scope.setExtra('unhandledPromiseRejection', true);
            // Preserve backwards compatibility with raven-node for now
            if (context.user) {
                scope.setUser(context.user);
            }
            if (context.tags) {
                scope.setTags(context.tags);
            }
            if (context.extra) {
                scope.setExtras(context.extra);
            }
            hub.captureException(reason, {
                originalException: promise,
                data: { mechanism: { handled: false, type: 'onunhandledrejection' } },
            });
        });
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        this._handleRejection(reason);
    };
    /**
     * Handler for `mode` option
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    OnUnhandledRejection.prototype._handleRejection = function (reason) {
        // https://github.com/nodejs/node/blob/7cf6f9e964aa00772965391c23acda6d71972a9a/lib/internal/process/promises.js#L234-L240
        var rejectionWarning = 'This error originated either by ' +
            'throwing inside of an async function without a catch block, ' +
            'or by rejecting a promise which was not handled with .catch().' +
            ' The promise rejected with the reason:';
        /* eslint-disable no-console */
        if (this._options.mode === 'warn') {
            consoleSandbox(function () {
                console.warn(rejectionWarning);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                console.error(reason && reason.stack ? reason.stack : reason);
            });
        }
        else if (this._options.mode === 'strict') {
            consoleSandbox(function () {
                console.warn(rejectionWarning);
            });
            logAndExitProcess(reason);
        }
        /* eslint-enable no-console */
    };
    /**
     * @inheritDoc
     */
    OnUnhandledRejection.id = 'OnUnhandledRejection';
    return OnUnhandledRejection;
}());
export { OnUnhandledRejection };
//# sourceMappingURL=onunhandledrejection.js.map{"version":3,"file":"onunhandledrejection.js","sourceRoot":"","sources":["../../../src/integrations/onunhandledrejection.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, Scope } from '@sentry/core';\nimport { Integration } from '@sentry/types';\nimport { consoleSandbox } from '@sentry/utils';\n\nimport { logAndExitProcess } from './utils/errorhandling';\n\ntype UnhandledRejectionMode = 'none' | 'warn' | 'strict';\n\n/** Global Promise Rejection handler */\nexport class OnUnhandledRejection implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUnhandledRejection';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUnhandledRejection.id;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly _options: {\n      /**\n       * Option deciding what to do after capturing unhandledRejection,\n       * that mimicks behavior of node's --unhandled-rejection flag.\n       */\n      mode: UnhandledRejectionMode;\n    } = { mode: 'warn' },\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('unhandledRejection', this.sendUnhandledPromise.bind(this));\n  }\n\n  /**\n   * Send an exception with reason\n   * @param reason string\n   * @param promise promise\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n  public sendUnhandledPromise(reason: any, promise: any): void {\n    const hub = getCurrentHub();\n\n    if (!hub.getIntegration(OnUnhandledRejection)) {\n      this._handleRejection(reason);\n      return;\n    }\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    const context = (promise.domain && promise.domain.sentryContext) || {};\n\n    hub.withScope((scope: Scope) => {\n      scope.setExtra('unhandledPromiseRejection', true);\n\n      // Preserve backwards compatibility with raven-node for now\n      if (context.user) {\n        scope.setUser(context.user);\n      }\n      if (context.tags) {\n        scope.setTags(context.tags);\n      }\n      if (context.extra) {\n        scope.setExtras(context.extra);\n      }\n\n      hub.captureException(reason, {\n        originalException: promise,\n        data: { mechanism: { handled: false, type: 'onunhandledrejection' } },\n      });\n    });\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n    this._handleRejection(reason);\n  }\n\n  /**\n   * Handler for `mode` option\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _handleRejection(reason: any): void {\n    // https://github.com/nodejs/node/blob/7cf6f9e964aa00772965391c23acda6d71972a9a/lib/internal/process/promises.js#L234-L240\n    const rejectionWarning =\n      'This error originated either by ' +\n      'throwing inside of an async function without a catch block, ' +\n      'or by rejecting a promise which was not handled with .catch().' +\n      ' The promise rejected with the reason:';\n\n    /* eslint-disable no-console */\n    if (this._options.mode === 'warn') {\n      consoleSandbox(() => {\n        console.warn(rejectionWarning);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        console.error(reason && reason.stack ? reason.stack : reason);\n      });\n    } else if (this._options.mode === 'strict') {\n      consoleSandbox(() => {\n        console.warn(rejectionWarning);\n      });\n      logAndExitProcess(reason);\n    }\n    /* eslint-enable no-console */\n  }\n}\n"]}/**
 * @hidden
 */
export declare function logAndExitProcess(error: Error): void;
//# sourceMappingURL=errorhandling.d.ts.map{"version":3,"file":"errorhandling.d.ts","sourceRoot":"","sources":["../../../../src/integrations/utils/errorhandling.ts"],"names":[],"mappings":"AAQA;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAuBpD"}import { getCurrentHub } from '@sentry/core';
import { forget, logger } from '@sentry/utils';
import { IS_DEBUG_BUILD } from '../../flags';
var DEFAULT_SHUTDOWN_TIMEOUT = 2000;
/**
 * @hidden
 */
export function logAndExitProcess(error) {
    // eslint-disable-next-line no-console
    console.error(error && error.stack ? error.stack : error);
    var client = getCurrentHub().getClient();
    if (client === undefined) {
        IS_DEBUG_BUILD && logger.warn('No NodeClient was defined, we are exiting the process now.');
        global.process.exit(1);
    }
    var options = client.getOptions();
    var timeout = (options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout) ||
        DEFAULT_SHUTDOWN_TIMEOUT;
    forget(client.close(timeout).then(function (result) {
        if (!result) {
            IS_DEBUG_BUILD && logger.warn('We reached the timeout for emptying the request buffer, still exiting now!');
        }
        global.process.exit(1);
    }));
}
//# sourceMappingURL=errorhandling.js.map{"version":3,"file":"errorhandling.js","sourceRoot":"","sources":["../../../../src/integrations/utils/errorhandling.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAC7C,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;AAG/C,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAE7C,IAAM,wBAAwB,GAAG,IAAI,CAAC;AAEtC;;GAEG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAY;IAC5C,sCAAsC;IACtC,OAAO,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAE1D,IAAM,MAAM,GAAG,aAAa,EAAE,CAAC,SAAS,EAAc,CAAC;IAEvD,IAAI,MAAM,KAAK,SAAS,EAAE;QACxB,cAAc,IAAI,MAAM,CAAC,IAAI,CAAC,4DAA4D,CAAC,CAAC;QAC5F,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACxB;IAED,IAAM,OAAO,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;IACpC,IAAM,OAAO,GACX,CAAC,OAAO,IAAI,OAAO,CAAC,eAAe,IAAI,OAAO,CAAC,eAAe,GAAG,CAAC,IAAI,OAAO,CAAC,eAAe,CAAC;QAC9F,wBAAwB,CAAC;IAC3B,MAAM,CACJ,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,MAAe;QACzC,IAAI,CAAC,MAAM,EAAE;YACX,cAAc,IAAI,MAAM,CAAC,IAAI,CAAC,4EAA4E,CAAC,CAAC;SAC7G;QACD,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CACH,CAAC;AACJ,CAAC","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { forget, logger } from '@sentry/utils';\n\nimport { NodeClient } from '../../client';\nimport { IS_DEBUG_BUILD } from '../../flags';\n\nconst DEFAULT_SHUTDOWN_TIMEOUT = 2000;\n\n/**\n * @hidden\n */\nexport function logAndExitProcess(error: Error): void {\n  // eslint-disable-next-line no-console\n  console.error(error && error.stack ? error.stack : error);\n\n  const client = getCurrentHub().getClient<NodeClient>();\n\n  if (client === undefined) {\n    IS_DEBUG_BUILD && logger.warn('No NodeClient was defined, we are exiting the process now.');\n    global.process.exit(1);\n  }\n\n  const options = client.getOptions();\n  const timeout =\n    (options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout) ||\n    DEFAULT_SHUTDOWN_TIMEOUT;\n  forget(\n    client.close(timeout).then((result: boolean) => {\n      if (!result) {\n        IS_DEBUG_BUILD && logger.warn('We reached the timeout for emptying the request buffer, still exiting now!');\n      }\n      global.process.exit(1);\n    }),\n  );\n}\n"]}/// <reference types="node" />
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
/**
 * Checks whether given url points to Sentry server
 * @param url url to verify
 */
export declare function isSentryRequest(url: string): boolean;
/**
 * Assemble a URL to be used for breadcrumbs and spans.
 *
 * @param requestOptions RequestOptions object containing the component parts for a URL
 * @returns Fully-formed URL
 */
export declare function extractUrl(requestOptions: RequestOptions): string;
/**
 * Handle various edge cases in the span description (for spans representing http(s) requests).
 *
 * @param description current `description` property of the span representing the request
 * @param requestOptions Configuration data for the request
 * @param Request Request object
 *
 * @returns The cleaned description
 */
export declare function cleanSpanDescription(description: string | undefined, requestOptions: RequestOptions, request: http.ClientRequest): string | undefined;
export declare type RequestOptions = http.RequestOptions & {
    hash?: string;
    search?: string;
    pathname?: string;
    href?: string;
};
declare type RequestCallback = (response: http.IncomingMessage) => void;
export declare type RequestMethodArgs = [RequestOptions | string | URL, RequestCallback?] | [string | URL, RequestOptions, RequestCallback?];
export declare type RequestMethod = (...args: RequestMethodArgs) => http.ClientRequest;
/**
 * Convert a URL object into a RequestOptions object.
 *
 * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the
 * RequestOptions type above.
 *
 * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.
 */
export declare function urlToOptions(url: URL): RequestOptions;
/**
 * Normalize inputs to `http(s).request()` and `http(s).get()`.
 *
 * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:
 *     [ RequestOptions | string | URL ],
 *     [ RequestOptions | string | URL, RequestCallback ],
 *     [ string | URL, RequestOptions ], and
 *     [ string | URL, RequestOptions, RequestCallback ].
 *
 * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is
 * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact
 * with the args in a standard way.
 *
 * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.
 *
 * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].
 */
export declare function normalizeRequestArgs(httpModule: typeof http | typeof https, requestArgs: RequestMethodArgs): [RequestOptions] | [RequestOptions, RequestCallback];
export {};
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../../src/integrations/utils/http.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAI1B;;;GAGG;AACH,wBAAgB,eAAe,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAGpD;AAED;;;;;GAKG;AACH,wBAAgB,UAAU,CAAC,cAAc,EAAE,cAAc,GAAG,MAAM,CASjE;AAED;;;;;;;;GAQG;AACH,wBAAgB,oBAAoB,CAClC,WAAW,EAAE,MAAM,GAAG,SAAS,EAC/B,cAAc,EAAE,cAAc,EAC9B,OAAO,EAAE,IAAI,CAAC,aAAa,GAC1B,MAAM,GAAG,SAAS,CAuBpB;AAGD,oBAAY,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,MAAM,CAAC,EAAE,MAAM,CAAC;IAAC,QAAQ,CAAC,EAAE,MAAM,CAAC;IAAC,IAAI,CAAC,EAAE,MAAM,CAAA;CAAE,CAAC;AACxH,aAAK,eAAe,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,eAAe,KAAK,IAAI,CAAC;AAChE,oBAAY,iBAAiB,GACzB,CAAC,cAAc,GAAG,MAAM,GAAG,GAAG,EAAE,eAAe,CAAC,CAAC,GACjD,CAAC,MAAM,GAAG,GAAG,EAAE,cAAc,EAAE,eAAe,CAAC,CAAC,CAAC;AACrD,oBAAY,aAAa,GAAG,CAAC,GAAG,IAAI,EAAE,iBAAiB,KAAK,IAAI,CAAC,aAAa,CAAC;AAE/E;;;;;;;GAOG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,GAAG,GAAG,cAAc,CAkBrD;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,oBAAoB,CAClC,UAAU,EAAE,OAAO,IAAI,GAAG,OAAO,KAAK,EACtC,WAAW,EAAE,iBAAiB,GAC7B,CAAC,cAAc,CAAC,GAAG,CAAC,cAAc,EAAE,eAAe,CAAC,CAoDtD"}import { __assign, __read } from "tslib";
import { getCurrentHub } from '@sentry/core';
import { parseSemver } from '@sentry/utils';
import { URL } from 'url';
var NODE_VERSION = parseSemver(process.versions.node);
/**
 * Checks whether given url points to Sentry server
 * @param url url to verify
 */
export function isSentryRequest(url) {
    var _a;
    var dsn = (_a = getCurrentHub().getClient()) === null || _a === void 0 ? void 0 : _a.getDsn();
    return dsn ? url.includes(dsn.host) : false;
}
/**
 * Assemble a URL to be used for breadcrumbs and spans.
 *
 * @param requestOptions RequestOptions object containing the component parts for a URL
 * @returns Fully-formed URL
 */
export function extractUrl(requestOptions) {
    var protocol = requestOptions.protocol || '';
    var hostname = requestOptions.hostname || requestOptions.host || '';
    // Don't log standard :80 (http) and :443 (https) ports to reduce the noise
    var port = !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? '' : ":" + requestOptions.port;
    var path = requestOptions.path ? requestOptions.path : '/';
    return protocol + "//" + hostname + port + path;
}
/**
 * Handle various edge cases in the span description (for spans representing http(s) requests).
 *
 * @param description current `description` property of the span representing the request
 * @param requestOptions Configuration data for the request
 * @param Request Request object
 *
 * @returns The cleaned description
 */
export function cleanSpanDescription(description, requestOptions, request) {
    var _a, _b, _c;
    // nothing to clean
    if (!description) {
        return description;
    }
    // eslint-disable-next-line prefer-const
    var _d = __read(description.split(' '), 2), method = _d[0], requestUrl = _d[1];
    // superagent sticks the protocol in a weird place (we check for host because if both host *and* protocol are missing,
    // we're likely dealing with an internal route and this doesn't apply)
    if (requestOptions.host && !requestOptions.protocol) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
        requestOptions.protocol = (_b = (_a = request) === null || _a === void 0 ? void 0 : _a.agent) === null || _b === void 0 ? void 0 : _b.protocol; // worst comes to worst, this is undefined and nothing changes
        requestUrl = extractUrl(requestOptions);
    }
    // internal routes can end up starting with a triple slash rather than a single one
    if ((_c = requestUrl) === null || _c === void 0 ? void 0 : _c.startsWith('///')) {
        requestUrl = requestUrl.slice(2);
    }
    return method + " " + requestUrl;
}
/**
 * Convert a URL object into a RequestOptions object.
 *
 * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the
 * RequestOptions type above.
 *
 * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.
 */
export function urlToOptions(url) {
    var options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: "" + (url.pathname || '') + (url.search || ''),
        href: url.href,
    };
    if (url.port !== '') {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = url.username + ":" + url.password;
    }
    return options;
}
/**
 * Normalize inputs to `http(s).request()` and `http(s).get()`.
 *
 * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:
 *     [ RequestOptions | string | URL ],
 *     [ RequestOptions | string | URL, RequestCallback ],
 *     [ string | URL, RequestOptions ], and
 *     [ string | URL, RequestOptions, RequestCallback ].
 *
 * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is
 * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact
 * with the args in a standard way.
 *
 * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.
 *
 * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].
 */
export function normalizeRequestArgs(httpModule, requestArgs) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var callback, requestOptions;
    // pop off the callback, if there is one
    if (typeof requestArgs[requestArgs.length - 1] === 'function') {
        callback = requestArgs.pop();
    }
    // create a RequestOptions object of whatever's at index 0
    if (typeof requestArgs[0] === 'string') {
        requestOptions = urlToOptions(new URL(requestArgs[0]));
    }
    else if (requestArgs[0] instanceof URL) {
        requestOptions = urlToOptions(requestArgs[0]);
    }
    else {
        requestOptions = requestArgs[0];
    }
    // if the options were given separately from the URL, fold them in
    if (requestArgs.length === 2) {
        requestOptions = __assign(__assign({}, requestOptions), requestArgs[1]);
    }
    // Figure out the protocol if it's currently missing
    if (requestOptions.protocol === undefined) {
        // Worst case we end up populating protocol with undefined, which it already is
        /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
        // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.
        // Because of that, we cannot rely on `httpModule` to provide us with valid protocol,
        // as it will always return `http`, even when using `https` module.
        //
        // See test/integrations/http.test.ts for more details on Node <=v8 protocol issue.
        if (NODE_VERSION.major && NODE_VERSION.major > 8) {
            requestOptions.protocol =
                ((_b = (_a = httpModule) === null || _a === void 0 ? void 0 : _a.globalAgent) === null || _b === void 0 ? void 0 : _b.protocol) || ((_c = requestOptions.agent) === null || _c === void 0 ? void 0 : _c.protocol) || ((_d = requestOptions._defaultAgent) === null || _d === void 0 ? void 0 : _d.protocol);
        }
        else {
            requestOptions.protocol =
                ((_e = requestOptions.agent) === null || _e === void 0 ? void 0 : _e.protocol) || ((_f = requestOptions._defaultAgent) === null || _f === void 0 ? void 0 : _f.protocol) || ((_h = (_g = httpModule) === null || _g === void 0 ? void 0 : _g.globalAgent) === null || _h === void 0 ? void 0 : _h.protocol);
        }
        /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */
    }
    // return args in standardized form
    if (callback) {
        return [requestOptions, callback];
    }
    else {
        return [requestOptions];
    }
}
//# sourceMappingURL=http.js.map{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../../src/integrations/utils/http.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { parseSemver } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\n\nconst NODE_VERSION = parseSemver(process.versions.node);\n\n/**\n * Checks whether given url points to Sentry server\n * @param url url to verify\n */\nexport function isSentryRequest(url: string): boolean {\n  const dsn = getCurrentHub().getClient()?.getDsn();\n  return dsn ? url.includes(dsn.host) : false;\n}\n\n/**\n * Assemble a URL to be used for breadcrumbs and spans.\n *\n * @param requestOptions RequestOptions object containing the component parts for a URL\n * @returns Fully-formed URL\n */\nexport function extractUrl(requestOptions: RequestOptions): string {\n  const protocol = requestOptions.protocol || '';\n  const hostname = requestOptions.hostname || requestOptions.host || '';\n  // Don't log standard :80 (http) and :443 (https) ports to reduce the noise\n  const port =\n    !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 ? '' : `:${requestOptions.port}`;\n  const path = requestOptions.path ? requestOptions.path : '/';\n\n  return `${protocol}//${hostname}${port}${path}`;\n}\n\n/**\n * Handle various edge cases in the span description (for spans representing http(s) requests).\n *\n * @param description current `description` property of the span representing the request\n * @param requestOptions Configuration data for the request\n * @param Request Request object\n *\n * @returns The cleaned description\n */\nexport function cleanSpanDescription(\n  description: string | undefined,\n  requestOptions: RequestOptions,\n  request: http.ClientRequest,\n): string | undefined {\n  // nothing to clean\n  if (!description) {\n    return description;\n  }\n\n  // eslint-disable-next-line prefer-const\n  let [method, requestUrl] = description.split(' ');\n\n  // superagent sticks the protocol in a weird place (we check for host because if both host *and* protocol are missing,\n  // we're likely dealing with an internal route and this doesn't apply)\n  if (requestOptions.host && !requestOptions.protocol) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    requestOptions.protocol = (request as any)?.agent?.protocol; // worst comes to worst, this is undefined and nothing changes\n    requestUrl = extractUrl(requestOptions);\n  }\n\n  // internal routes can end up starting with a triple slash rather than a single one\n  if (requestUrl?.startsWith('///')) {\n    requestUrl = requestUrl.slice(2);\n  }\n\n  return `${method} ${requestUrl}`;\n}\n\n// the node types are missing a few properties which node's `urlToOptions` function spits out\nexport type RequestOptions = http.RequestOptions & { hash?: string; search?: string; pathname?: string; href?: string };\ntype RequestCallback = (response: http.IncomingMessage) => void;\nexport type RequestMethodArgs =\n  | [RequestOptions | string | URL, RequestCallback?]\n  | [string | URL, RequestOptions, RequestCallback?];\nexport type RequestMethod = (...args: RequestMethodArgs) => http.ClientRequest;\n\n/**\n * Convert a URL object into a RequestOptions object.\n *\n * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the\n * RequestOptions type above.\n *\n * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.\n */\nexport function urlToOptions(url: URL): RequestOptions {\n  const options: RequestOptions = {\n    protocol: url.protocol,\n    hostname:\n      typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || ''}${url.search || ''}`,\n    href: url.href,\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\n/**\n * Normalize inputs to `http(s).request()` and `http(s).get()`.\n *\n * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:\n *     [ RequestOptions | string | URL ],\n *     [ RequestOptions | string | URL, RequestCallback ],\n *     [ string | URL, RequestOptions ], and\n *     [ string | URL, RequestOptions, RequestCallback ].\n *\n * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is\n * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact\n * with the args in a standard way.\n *\n * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.\n *\n * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].\n */\nexport function normalizeRequestArgs(\n  httpModule: typeof http | typeof https,\n  requestArgs: RequestMethodArgs,\n): [RequestOptions] | [RequestOptions, RequestCallback] {\n  let callback, requestOptions;\n\n  // pop off the callback, if there is one\n  if (typeof requestArgs[requestArgs.length - 1] === 'function') {\n    callback = requestArgs.pop() as RequestCallback;\n  }\n\n  // create a RequestOptions object of whatever's at index 0\n  if (typeof requestArgs[0] === 'string') {\n    requestOptions = urlToOptions(new URL(requestArgs[0]));\n  } else if (requestArgs[0] instanceof URL) {\n    requestOptions = urlToOptions(requestArgs[0]);\n  } else {\n    requestOptions = requestArgs[0];\n  }\n\n  // if the options were given separately from the URL, fold them in\n  if (requestArgs.length === 2) {\n    requestOptions = { ...requestOptions, ...requestArgs[1] };\n  }\n\n  // Figure out the protocol if it's currently missing\n  if (requestOptions.protocol === undefined) {\n    // Worst case we end up populating protocol with undefined, which it already is\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // Because of that, we cannot rely on `httpModule` to provide us with valid protocol,\n    // as it will always return `http`, even when using `https` module.\n    //\n    // See test/integrations/http.test.ts for more details on Node <=v8 protocol issue.\n    if (NODE_VERSION.major && NODE_VERSION.major > 8) {\n      requestOptions.protocol =\n        (httpModule?.globalAgent as any)?.protocol ||\n        (requestOptions.agent as any)?.protocol ||\n        (requestOptions._defaultAgent as any)?.protocol;\n    } else {\n      requestOptions.protocol =\n        (requestOptions.agent as any)?.protocol ||\n        (requestOptions._defaultAgent as any)?.protocol ||\n        (httpModule?.globalAgent as any)?.protocol;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\n  }\n\n  // return args in standardized form\n  if (callback) {\n    return [requestOptions, callback];\n  } else {\n    return [requestOptions];\n  }\n}\n"]}import { Integrations as CoreIntegrations } from '@sentry/core';
import { NodeClient } from './client';
import { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';
import { NodeOptions } from './types';
export declare const defaultIntegrations: (CoreIntegrations.FunctionToString | CoreIntegrations.InboundFilters | Console | Http | OnUncaughtException | OnUnhandledRejection | ContextLines | LinkedErrors)[];
/**
 * The Sentry Node SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible in the
 * main entry module. To set context information or send manual events, use the
 * provided methods.
 *
 * @example
 * ```
 *
 * const { init } = require('@sentry/node');
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { configureScope } = require('@sentry/node');
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { addBreadcrumb } = require('@sentry/node');
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const Sentry = require('@sentry/node');
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link NodeOptions} for documentation on configuration options.
 */
export declare function init(options?: NodeOptions): void;
/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
export declare function lastEventId(): string | undefined;
/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export declare function flush(timeout?: number): Promise<boolean>;
/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export declare function close(timeout?: number): Promise<boolean>;
/**
 * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client
 */
export declare function isAutoSessionTrackingEnabled(client?: NodeClient): boolean;
/**
 * Returns a release dynamically from environment variables.
 */
export declare function getSentryRelease(fallback?: string): string | undefined;
//# sourceMappingURL=sdk.d.ts.map{"version":3,"file":"sdk.d.ts","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AAAA,OAAO,EAA8B,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAM5F,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAEtC,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,IAAI,EAAE,YAAY,EAAE,mBAAmB,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AACtH,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC,eAAO,MAAM,mBAAmB,qKAa/B,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsDG;AACH,wBAAgB,IAAI,CAAC,OAAO,GAAE,WAAgB,GAAG,IAAI,CAmDpD;AAED;;;;GAIG;AACH,wBAAgB,WAAW,IAAI,MAAM,GAAG,SAAS,CAEhD;AAED;;;;;;;GAOG;AACH,wBAAsB,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAO9D;AAED;;;;;;;GAOG;AACH,wBAAsB,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAO9D;AAED;;GAEG;AACH,wBAAgB,4BAA4B,CAAC,MAAM,CAAC,EAAE,UAAU,GAAG,OAAO,CASzE;AAED;;GAEG;AACH,wBAAgB,gBAAgB,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CA4BtE"}import { __awaiter, __generator, __read, __spread } from "tslib";
import { getCurrentHub, initAndBind, Integrations as CoreIntegrations } from '@sentry/core';
import { getMainCarrier, setHubOnCarrier } from '@sentry/hub';
import { getGlobalObject, logger } from '@sentry/utils';
import * as domain from 'domain';
import { NodeClient } from './client';
import { IS_DEBUG_BUILD } from './flags';
import { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';
export var defaultIntegrations = [
    // Common
    new CoreIntegrations.InboundFilters(),
    new CoreIntegrations.FunctionToString(),
    new ContextLines(),
    // Native Wrappers
    new Console(),
    new Http(),
    // Global Handlers
    new OnUncaughtException(),
    new OnUnhandledRejection(),
    // Misc
    new LinkedErrors(),
];
/**
 * The Sentry Node SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible in the
 * main entry module. To set context information or send manual events, use the
 * provided methods.
 *
 * @example
 * ```
 *
 * const { init } = require('@sentry/node');
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { configureScope } = require('@sentry/node');
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { addBreadcrumb } = require('@sentry/node');
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const Sentry = require('@sentry/node');
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link NodeOptions} for documentation on configuration options.
 */
export function init(options) {
    if (options === void 0) { options = {}; }
    var _a;
    var carrier = getMainCarrier();
    var autoloadedIntegrations = ((_a = carrier.__SENTRY__) === null || _a === void 0 ? void 0 : _a.integrations) || [];
    options.defaultIntegrations =
        options.defaultIntegrations === false
            ? []
            : __spread((Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations), autoloadedIntegrations);
    if (options.dsn === undefined && process.env.SENTRY_DSN) {
        options.dsn = process.env.SENTRY_DSN;
    }
    if (options.tracesSampleRate === undefined && process.env.SENTRY_TRACES_SAMPLE_RATE) {
        var tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);
        if (isFinite(tracesSampleRate)) {
            options.tracesSampleRate = tracesSampleRate;
        }
    }
    if (options.release === undefined) {
        var detectedRelease = getSentryRelease();
        if (detectedRelease !== undefined) {
            options.release = detectedRelease;
        }
        else {
            // If release is not provided, then we should disable autoSessionTracking
            options.autoSessionTracking = false;
        }
    }
    if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {
        options.environment = process.env.SENTRY_ENVIRONMENT;
    }
    if (options.autoSessionTracking === undefined && options.dsn !== undefined) {
        options.autoSessionTracking = true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    if (domain.active) {
        setHubOnCarrier(carrier, getCurrentHub());
    }
    initAndBind(NodeClient, options);
    if (options.autoSessionTracking) {
        startSessionTracking();
    }
}
/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
export function lastEventId() {
    return getCurrentHub().lastEventId();
}
/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export function flush(timeout) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = getCurrentHub().getClient();
            if (client) {
                return [2 /*return*/, client.flush(timeout)];
            }
            IS_DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');
            return [2 /*return*/, Promise.resolve(false)];
        });
    });
}
/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export function close(timeout) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = getCurrentHub().getClient();
            if (client) {
                return [2 /*return*/, client.close(timeout)];
            }
            IS_DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');
            return [2 /*return*/, Promise.resolve(false)];
        });
    });
}
/**
 * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client
 */
export function isAutoSessionTrackingEnabled(client) {
    if (client === undefined) {
        return false;
    }
    var clientOptions = client && client.getOptions();
    if (clientOptions && clientOptions.autoSessionTracking !== undefined) {
        return clientOptions.autoSessionTracking;
    }
    return false;
}
/**
 * Returns a release dynamically from environment variables.
 */
export function getSentryRelease(fallback) {
    // Always read first as Sentry takes this as precedence
    if (process.env.SENTRY_RELEASE) {
        return process.env.SENTRY_RELEASE;
    }
    // This supports the variable that sentry-webpack-plugin injects
    var global = getGlobalObject();
    if (global.SENTRY_RELEASE && global.SENTRY_RELEASE.id) {
        return global.SENTRY_RELEASE.id;
    }
    return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env.GITHUB_SHA ||
        // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
        process.env.COMMIT_REF ||
        // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
        process.env.VERCEL_GIT_COMMIT_SHA ||
        process.env.VERCEL_GITHUB_COMMIT_SHA ||
        process.env.VERCEL_GITLAB_COMMIT_SHA ||
        process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
        // Zeit (now known as Vercel)
        process.env.ZEIT_GITHUB_COMMIT_SHA ||
        process.env.ZEIT_GITLAB_COMMIT_SHA ||
        process.env.ZEIT_BITBUCKET_COMMIT_SHA ||
        fallback);
}
/**
 * Enable automatic Session Tracking for the node process.
 */
function startSessionTracking() {
    var hub = getCurrentHub();
    hub.startSession();
    // Emitted in the case of healthy sessions, error of `mechanism.handled: true` and unhandledrejections because
    // The 'beforeExit' event is not emitted for conditions causing explicit termination,
    // such as calling process.exit() or uncaught exceptions.
    // Ref: https://nodejs.org/api/process.html#process_event_beforeexit
    process.on('beforeExit', function () {
        var _a;
        var session = (_a = hub.getScope()) === null || _a === void 0 ? void 0 : _a.getSession();
        var terminalStates = ['exited', 'crashed'];
        // Only call endSession, if the Session exists on Scope and SessionStatus is not a
        // Terminal Status i.e. Exited or Crashed because
        // "When a session is moved away from ok it must not be updated anymore."
        // Ref: https://develop.sentry.dev/sdk/sessions/
        if (session && !terminalStates.includes(session.status))
            hub.endSession();
    });
}
//# sourceMappingURL=sdk.js.map{"version":3,"file":"sdk.js","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, initAndBind, Integrations as CoreIntegrations } from '@sentry/core';\nimport { getMainCarrier, setHubOnCarrier } from '@sentry/hub';\nimport { SessionStatus } from '@sentry/types';\nimport { getGlobalObject, logger } from '@sentry/utils';\nimport * as domain from 'domain';\n\nimport { NodeClient } from './client';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';\nimport { NodeOptions } from './types';\n\nexport const defaultIntegrations = [\n  // Common\n  new CoreIntegrations.InboundFilters(),\n  new CoreIntegrations.FunctionToString(),\n  new ContextLines(),\n  // Native Wrappers\n  new Console(),\n  new Http(),\n  // Global Handlers\n  new OnUncaughtException(),\n  new OnUnhandledRejection(),\n  // Misc\n  new LinkedErrors(),\n];\n\n/**\n * The Sentry Node SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible in the\n * main entry module. To set context information or send manual events, use the\n * provided methods.\n *\n * @example\n * ```\n *\n * const { init } = require('@sentry/node');\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * const { configureScope } = require('@sentry/node');\n * configureScope((scope: Scope) => {\n *   scope.setExtra({ battery: 0.7 });\n *   scope.setTag({ user_mode: 'admin' });\n *   scope.setUser({ id: '4711' });\n * });\n * ```\n *\n * @example\n * ```\n *\n * const { addBreadcrumb } = require('@sentry/node');\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * const Sentry = require('@sentry/node');\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link NodeOptions} for documentation on configuration options.\n */\nexport function init(options: NodeOptions = {}): void {\n  const carrier = getMainCarrier();\n  const autoloadedIntegrations = carrier.__SENTRY__?.integrations || [];\n\n  options.defaultIntegrations =\n    options.defaultIntegrations === false\n      ? []\n      : [\n          ...(Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations),\n          ...autoloadedIntegrations,\n        ];\n\n  if (options.dsn === undefined && process.env.SENTRY_DSN) {\n    options.dsn = process.env.SENTRY_DSN;\n  }\n\n  if (options.tracesSampleRate === undefined && process.env.SENTRY_TRACES_SAMPLE_RATE) {\n    const tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);\n    if (isFinite(tracesSampleRate)) {\n      options.tracesSampleRate = tracesSampleRate;\n    }\n  }\n\n  if (options.release === undefined) {\n    const detectedRelease = getSentryRelease();\n    if (detectedRelease !== undefined) {\n      options.release = detectedRelease;\n    } else {\n      // If release is not provided, then we should disable autoSessionTracking\n      options.autoSessionTracking = false;\n    }\n  }\n\n  if (options.environment === undefined && process.env.SENTRY_ENVIRONMENT) {\n    options.environment = process.env.SENTRY_ENVIRONMENT;\n  }\n\n  if (options.autoSessionTracking === undefined && options.dsn !== undefined) {\n    options.autoSessionTracking = true;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  if ((domain as any).active) {\n    setHubOnCarrier(carrier, getCurrentHub());\n  }\n\n  initAndBind(NodeClient, options);\n\n  if (options.autoSessionTracking) {\n    startSessionTracking();\n  }\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nexport function lastEventId(): string | undefined {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.flush(timeout);\n  }\n  IS_DEBUG_BUILD && logger.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<NodeClient>();\n  if (client) {\n    return client.close(timeout);\n  }\n  IS_DEBUG_BUILD && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client\n */\nexport function isAutoSessionTrackingEnabled(client?: NodeClient): boolean {\n  if (client === undefined) {\n    return false;\n  }\n  const clientOptions: NodeOptions = client && client.getOptions();\n  if (clientOptions && clientOptions.autoSessionTracking !== undefined) {\n    return clientOptions.autoSessionTracking;\n  }\n  return false;\n}\n\n/**\n * Returns a release dynamically from environment variables.\n */\nexport function getSentryRelease(fallback?: string): string | undefined {\n  // Always read first as Sentry takes this as precedence\n  if (process.env.SENTRY_RELEASE) {\n    return process.env.SENTRY_RELEASE;\n  }\n\n  // This supports the variable that sentry-webpack-plugin injects\n  const global = getGlobalObject();\n  if (global.SENTRY_RELEASE && global.SENTRY_RELEASE.id) {\n    return global.SENTRY_RELEASE.id;\n  }\n\n  return (\n    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables\n    process.env.GITHUB_SHA ||\n    // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata\n    process.env.COMMIT_REF ||\n    // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables\n    process.env.VERCEL_GIT_COMMIT_SHA ||\n    process.env.VERCEL_GITHUB_COMMIT_SHA ||\n    process.env.VERCEL_GITLAB_COMMIT_SHA ||\n    process.env.VERCEL_BITBUCKET_COMMIT_SHA ||\n    // Zeit (now known as Vercel)\n    process.env.ZEIT_GITHUB_COMMIT_SHA ||\n    process.env.ZEIT_GITLAB_COMMIT_SHA ||\n    process.env.ZEIT_BITBUCKET_COMMIT_SHA ||\n    fallback\n  );\n}\n\n/**\n * Enable automatic Session Tracking for the node process.\n */\nfunction startSessionTracking(): void {\n  const hub = getCurrentHub();\n  hub.startSession();\n  // Emitted in the case of healthy sessions, error of `mechanism.handled: true` and unhandledrejections because\n  // The 'beforeExit' event is not emitted for conditions causing explicit termination,\n  // such as calling process.exit() or uncaught exceptions.\n  // Ref: https://nodejs.org/api/process.html#process_event_beforeexit\n  process.on('beforeExit', () => {\n    const session = hub.getScope()?.getSession();\n    const terminalStates: SessionStatus[] = ['exited', 'crashed'];\n    // Only call endSession, if the Session exists on Scope and SessionStatus is not a\n    // Terminal Status i.e. Exited or Crashed because\n    // \"When a session is moved away from ok it must not be updated anymore.\"\n    // Ref: https://develop.sentry.dev/sdk/sessions/\n    if (session && !terminalStates.includes(session.status)) hub.endSession();\n  });\n}\n"]}import { StackLineParser } from '@sentry/utils';
export declare const nodeStackParser: StackLineParser;
//# sourceMappingURL=stack-parser.d.ts.map{"version":3,"file":"stack-parser.d.ts","sourceRoot":"","sources":["../../src/stack-parser.ts"],"names":[],"mappings":"AAAA,OAAO,EAAqB,eAAe,EAAqB,MAAM,eAAe,CAAC;AAmHtF,eAAO,MAAM,eAAe,EAAE,eAA4B,CAAC"}import { basename, dirname } from '@sentry/utils';
/** Gets the module */
function getModule(filename) {
    if (!filename) {
        return;
    }
    // We could use optional chaining here but webpack does like that mixed with require
    var base = ((require && require.main && require.main.filename && dirname(require.main.filename)) || global.process.cwd()) + "/";
    // It's specifically a module
    var file = basename(filename, '.js');
    var path = dirname(filename);
    var n = path.lastIndexOf('/node_modules/');
    if (n > -1) {
        // /node_modules/ is 14 chars
        return path.substr(n + 14).replace(/\//g, '.') + ":" + file;
    }
    // Let's see if it's a part of the main module
    // To be a part of main module, it has to share the same base
    n = (path + "/").lastIndexOf(base, 0);
    if (n === 0) {
        var moduleName = path.substr(base.length).replace(/\//g, '.');
        if (moduleName) {
            moduleName += ':';
        }
        moduleName += file;
        return moduleName;
    }
    return file;
}
var FILENAME_MATCH = /^\s*[-]{4,}$/;
var FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
// eslint-disable-next-line complexity
var node = function (line) {
    var _a;
    if (line.match(FILENAME_MATCH)) {
        return {
            filename: line,
        };
    }
    var lineMatch = line.match(FULL_MATCH);
    if (!lineMatch) {
        return undefined;
    }
    var object;
    var method;
    var functionName;
    var typeName;
    var methodName;
    if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf('.');
        if (functionName[methodStart - 1] === '.') {
            // eslint-disable-next-line no-plusplus
            methodStart--;
        }
        if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf('.Module');
            if (objectEnd > 0) {
                functionName = functionName.substr(objectEnd + 1);
                object = object.substr(0, objectEnd);
            }
        }
        typeName = undefined;
    }
    if (method) {
        typeName = object;
        methodName = method;
    }
    if (method === '<anonymous>') {
        methodName = undefined;
        functionName = undefined;
    }
    if (functionName === undefined) {
        methodName = methodName || '<anonymous>';
        functionName = typeName ? typeName + "." + methodName : methodName;
    }
    var filename = ((_a = lineMatch[2]) === null || _a === void 0 ? void 0 : _a.startsWith('file://')) ? lineMatch[2].substr(7) : lineMatch[2];
    var isNative = lineMatch[5] === 'native';
    var isInternal = isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\') !== 1);
    // in_app is all that's not an internal Node function or a module within node_modules
    // note that isNative appears to return true even for node core libraries
    // see https://github.com/getsentry/raven-node/issues/176
    var in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');
    return {
        filename: filename,
        module: getModule(filename),
        function: functionName,
        lineno: parseInt(lineMatch[3], 10) || undefined,
        colno: parseInt(lineMatch[4], 10) || undefined,
        in_app: in_app,
    };
};
export var nodeStackParser = [90, node];
//# sourceMappingURL=stack-parser.js.map{"version":3,"file":"stack-parser.js","sourceRoot":"","sources":["../../src/stack-parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { basename, dirname, StackLineParser, StackLineParserFn } from '@sentry/utils';\n\n/** Gets the module */\nfunction getModule(filename: string | undefined): string | undefined {\n  if (!filename) {\n    return;\n  }\n\n  // We could use optional chaining here but webpack does like that mixed with require\n  const base = `${\n    (require && require.main && require.main.filename && dirname(require.main.filename)) || global.process.cwd()\n  }/`;\n\n  // It's specifically a module\n  const file = basename(filename, '.js');\n\n  const path = dirname(filename);\n  let n = path.lastIndexOf('/node_modules/');\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return `${path.substr(n + 14).replace(/\\//g, '.')}:${file}`;\n  }\n  // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n  n = `${path}/`.lastIndexOf(base, 0);\n\n  if (n === 0) {\n    let moduleName = path.substr(base.length).replace(/\\//g, '.');\n    if (moduleName) {\n      moduleName += ':';\n    }\n    moduleName += file;\n    return moduleName;\n  }\n  return file;\n}\n\nconst FILENAME_MATCH = /^\\s*[-]{4,}$/;\nconst FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\n\n// eslint-disable-next-line complexity\nconst node: StackLineParserFn = (line: string) => {\n  if (line.match(FILENAME_MATCH)) {\n    return {\n      filename: line,\n    };\n  }\n\n  const lineMatch = line.match(FULL_MATCH);\n  if (!lineMatch) {\n    return undefined;\n  }\n\n  let object: string | undefined;\n  let method: string | undefined;\n  let functionName: string | undefined;\n  let typeName: string | undefined;\n  let methodName: string | undefined;\n\n  if (lineMatch[1]) {\n    functionName = lineMatch[1];\n\n    let methodStart = functionName.lastIndexOf('.');\n    if (functionName[methodStart - 1] === '.') {\n      // eslint-disable-next-line no-plusplus\n      methodStart--;\n    }\n\n    if (methodStart > 0) {\n      object = functionName.substr(0, methodStart);\n      method = functionName.substr(methodStart + 1);\n      const objectEnd = object.indexOf('.Module');\n      if (objectEnd > 0) {\n        functionName = functionName.substr(objectEnd + 1);\n        object = object.substr(0, objectEnd);\n      }\n    }\n    typeName = undefined;\n  }\n\n  if (method) {\n    typeName = object;\n    methodName = method;\n  }\n\n  if (method === '<anonymous>') {\n    methodName = undefined;\n    functionName = undefined;\n  }\n\n  if (functionName === undefined) {\n    methodName = methodName || '<anonymous>';\n    functionName = typeName ? `${typeName}.${methodName}` : methodName;\n  }\n\n  const filename = lineMatch[2]?.startsWith('file://') ? lineMatch[2].substr(7) : lineMatch[2];\n  const isNative = lineMatch[5] === 'native';\n  const isInternal =\n    isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n  // in_app is all that's not an internal Node function or a module within node_modules\n  // note that isNative appears to return true even for node core libraries\n  // see https://github.com/getsentry/raven-node/issues/176\n  const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n  return {\n    filename,\n    module: getModule(filename),\n    function: functionName,\n    lineno: parseInt(lineMatch[3], 10) || undefined,\n    colno: parseInt(lineMatch[4], 10) || undefined,\n    in_app,\n  };\n};\n\nexport const nodeStackParser: StackLineParser = [90, node];\n"]}/// <reference types="node" />
import { IncomingHttpHeaders, RequestOptions as HTTPRequestOptions } from 'http';
import { RequestOptions as HTTPSRequestOptions } from 'https';
import { URL } from 'url';
export declare type HTTPModuleRequestOptions = HTTPRequestOptions | HTTPSRequestOptions | string | URL;
/**
 * Cut version of http.IncomingMessage.
 * Some transports work in a special Javascript environment where http.IncomingMessage is not available.
 */
export interface HTTPModuleRequestIncomingMessage {
    headers: IncomingHttpHeaders;
    statusCode?: number;
    on(event: 'data' | 'end', listener: () => void): void;
    setEncoding(encoding: string): void;
}
/**
 * Cut version of http.ClientRequest.
 * Some transports work in a special Javascript environment where http.IncomingMessage is not available.
 */
export interface HTTPModuleClientRequest {
    end(chunk: string): void;
    on(event: 'error', listener: () => void): void;
}
/**
 * Internal used interface for typescript.
 * @hidden
 */
export interface HTTPModule {
    /**
     * Request wrapper
     * @param options These are {@see TransportOptions}
     * @param callback Callback when request is finished
     */
    request(options: HTTPModuleRequestOptions, callback?: (res: HTTPModuleRequestIncomingMessage) => void): HTTPModuleClientRequest;
}
//# sourceMappingURL=http-module.d.ts.map{"version":3,"file":"http-module.d.ts","sourceRoot":"","sources":["../../../../src/transports/base/http-module.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,mBAAmB,EAAE,cAAc,IAAI,kBAAkB,EAAE,MAAM,MAAM,CAAC;AACjF,OAAO,EAAE,cAAc,IAAI,mBAAmB,EAAE,MAAM,OAAO,CAAC;AAC9D,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAE1B,oBAAY,wBAAwB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,MAAM,GAAG,GAAG,CAAC;AAE/F;;;GAGG;AACH,MAAM,WAAW,gCAAgC;IAC/C,OAAO,EAAE,mBAAmB,CAAC;IAC7B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,EAAE,CAAC,KAAK,EAAE,MAAM,GAAG,KAAK,EAAE,QAAQ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;IACtD,WAAW,CAAC,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;CACrC;AAED;;;GAGG;AACH,MAAM,WAAW,uBAAuB;IACtC,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;CAChD;AAED;;;GAGG;AACH,MAAM,WAAW,UAAU;IACzB;;;;OAIG;IACH,OAAO,CACL,OAAO,EAAE,wBAAwB,EACjC,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE,gCAAgC,KAAK,IAAI,GACzD,uBAAuB,CAAC;CAW5B"}//# sourceMappingURL=http-module.js.map{"version":3,"file":"http-module.js","sourceRoot":"","sources":["../../../../src/transports/base/http-module.ts"],"names":[],"mappings":"","sourcesContent":["import { IncomingHttpHeaders, RequestOptions as HTTPRequestOptions } from 'http';\nimport { RequestOptions as HTTPSRequestOptions } from 'https';\nimport { URL } from 'url';\n\nexport type HTTPModuleRequestOptions = HTTPRequestOptions | HTTPSRequestOptions | string | URL;\n\n/**\n * Cut version of http.IncomingMessage.\n * Some transports work in a special Javascript environment where http.IncomingMessage is not available.\n */\nexport interface HTTPModuleRequestIncomingMessage {\n  headers: IncomingHttpHeaders;\n  statusCode?: number;\n  on(event: 'data' | 'end', listener: () => void): void;\n  setEncoding(encoding: string): void;\n}\n\n/**\n * Cut version of http.ClientRequest.\n * Some transports work in a special Javascript environment where http.IncomingMessage is not available.\n */\nexport interface HTTPModuleClientRequest {\n  end(chunk: string): void;\n  on(event: 'error', listener: () => void): void;\n}\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPModule {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: HTTPModuleRequestOptions,\n    callback?: (res: HTTPModuleRequestIncomingMessage) => void,\n  ): HTTPModuleClientRequest;\n\n  // This is the type for nodejs versions that handle the URL argument\n  // (v10.9.0+), but we do not use it just yet because we support older node\n  // versions:\n\n  // request(\n  //   url: string | URL,\n  //   options: http.RequestOptions | https.RequestOptions,\n  //   callback?: (res: http.IncomingMessage) => void,\n  // ): http.ClientRequest;\n}\n"]}/// <reference types="node" />
import { APIDetails } from '@sentry/core';
import { DsnProtocol, Event, Response, SentryRequest, SentryRequestType, Session, SessionAggregates, Transport, TransportOptions } from '@sentry/types';
import { PromiseBuffer } from '@sentry/utils';
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
import { HTTPModule } from './http-module';
export declare type URLParts = Pick<URL, 'hostname' | 'pathname' | 'port' | 'protocol'>;
export declare type UrlParser = (url: string) => URLParts;
/** Base Transport class implementation */
export declare abstract class BaseTransport implements Transport {
    options: TransportOptions;
    /** The Agent used for corresponding transport */
    module?: HTTPModule;
    /** The Agent used for corresponding transport */
    client?: http.Agent | https.Agent;
    /** API object */
    protected _api: APIDetails;
    /** A simple buffer holding all requests. */
    protected readonly _buffer: PromiseBuffer<Response>;
    /** Locks transport after receiving rate limits in a response */
    protected readonly _rateLimits: Record<string, Date>;
    /** Create instance and set this.dsn */
    constructor(options: TransportOptions);
    /** Default function used to parse URLs */
    urlParser: UrlParser;
    /**
     * @inheritDoc
     */
    sendEvent(_: Event): PromiseLike<Response>;
    /**
     * @inheritDoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Extracts proxy settings from client options and env variables.
     *
     * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.
     *
     * An order of priority for available protocols is:
     * `http`  => `options.httpProxy` | `process.env.http_proxy`
     * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`
     */
    protected _getProxy(protocol: DsnProtocol): string | undefined;
    /** Returns a build request option object used by request */
    protected _getRequestOptions(urlParts: URLParts): http.RequestOptions | https.RequestOptions;
    /**
     * Gets the time that given category is disabled until for rate limiting
     */
    protected _disabledUntil(requestType: SentryRequestType): Date;
    /**
     * Checks if a category is rate limited
     */
    protected _isRateLimited(requestType: SentryRequestType): boolean;
    /**
     * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.
     */
    protected _handleRateLimit(headers: Record<string, string | null>): boolean;
    /** JSDoc */
    protected _send(sentryRequest: SentryRequest, originalPayload?: Event | Session | SessionAggregates): Promise<Response>;
}
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/transports/base/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAkD,MAAM,cAAc,CAAC;AAC1F,OAAO,EACL,WAAW,EACX,KAAK,EACL,QAAQ,EACR,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,SAAS,EACT,gBAAgB,EACjB,MAAM,eAAe,CAAC;AACvB,OAAO,EAKL,aAAa,EAEd,MAAM,eAAe,CAAC;AAEvB,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAI1B,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAE3C,oBAAY,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,GAAG,MAAM,GAAG,UAAU,CAAC,CAAC;AAChF,oBAAY,SAAS,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,QAAQ,CAAC;AAWlD,0CAA0C;AAC1C,8BAAsB,aAAc,YAAW,SAAS;IAiB5B,OAAO,EAAE,gBAAgB;IAhBnD,iDAAiD;IAC1C,MAAM,CAAC,EAAE,UAAU,CAAC;IAE3B,iDAAiD;IAC1C,MAAM,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;IAEzC,iBAAiB;IACjB,SAAS,CAAC,IAAI,EAAE,UAAU,CAAC;IAE3B,4CAA4C;IAC5C,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAyB;IAE5E,gEAAgE;IAChE,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAM;IAE1D,uCAAuC;gBACb,OAAO,EAAE,gBAAgB;IAKnD,0CAA0C;IACnC,SAAS,EAAE,SAAS,CAAuB;IAElD;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAIpD;;;;;;;;OAQG;IACH,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,WAAW,GAAG,MAAM,GAAG,SAAS;IAmB9D,4DAA4D;IAC5D,SAAS,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,GAAG,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,cAAc;IAwB5F;;OAEG;IACH,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,iBAAiB,GAAG,IAAI;IAK9D;;OAEG;IACH,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,iBAAiB,GAAG,OAAO;IAIjE;;OAEG;IACH,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC,GAAG,OAAO;IAsC3E,YAAY;cACI,KAAK,CACnB,aAAa,EAAE,aAAa,EAC5B,eAAe,CAAC,EAAE,KAAK,GAAG,OAAO,GAAG,iBAAiB,GACpD,OAAO,CAAC,QAAQ,CAAC;CA2ErB"}import { __assign, __awaiter, __generator, __read, __spread, __values } from "tslib";
import { getRequestHeaders, initAPIDetails, SDK_VERSION } from '@sentry/core';
import { eventStatusFromHttpCode, logger, makePromiseBuffer, parseRetryAfterHeader, SentryError, } from '@sentry/utils';
import * as fs from 'fs';
import { URL } from 'url';
import { IS_DEBUG_BUILD } from '../../flags';
import { SDK_NAME } from '../../version';
var CATEGORY_MAPPING = {
    event: 'error',
    transaction: 'transaction',
    session: 'session',
    attachment: 'attachment',
};
/** Base Transport class implementation */
var BaseTransport = /** @class */ (function () {
    /** Create instance and set this.dsn */
    function BaseTransport(options) {
        this.options = options;
        /** A simple buffer holding all requests. */
        this._buffer = makePromiseBuffer(30);
        /** Locks transport after receiving rate limits in a response */
        this._rateLimits = {};
        /** Default function used to parse URLs */
        this.urlParser = function (url) { return new URL(url); };
        // eslint-disable-next-line deprecation/deprecation
        this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);
    }
    /**
     * @inheritDoc
     */
    BaseTransport.prototype.sendEvent = function (_) {
        throw new SentryError('Transport Class has to implement `sendEvent` method.');
    };
    /**
     * @inheritDoc
     */
    BaseTransport.prototype.close = function (timeout) {
        return this._buffer.drain(timeout);
    };
    /**
     * Extracts proxy settings from client options and env variables.
     *
     * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.
     *
     * An order of priority for available protocols is:
     * `http`  => `options.httpProxy` | `process.env.http_proxy`
     * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`
     */
    BaseTransport.prototype._getProxy = function (protocol) {
        var e_1, _a;
        var _b = process.env, no_proxy = _b.no_proxy, http_proxy = _b.http_proxy, https_proxy = _b.https_proxy;
        var _c = this.options, httpProxy = _c.httpProxy, httpsProxy = _c.httpsProxy;
        var proxy = protocol === 'http' ? httpProxy || http_proxy : httpsProxy || httpProxy || https_proxy || http_proxy;
        if (!no_proxy) {
            return proxy;
        }
        var _d = this._api.dsn, host = _d.host, port = _d.port;
        try {
            for (var _e = __values(no_proxy.split(',')), _f = _e.next(); !_f.done; _f = _e.next()) {
                var np = _f.value;
                if (host.endsWith(np) || (host + ":" + port).endsWith(np)) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return proxy;
    };
    /** Returns a build request option object used by request */
    BaseTransport.prototype._getRequestOptions = function (urlParts) {
        var headers = __assign(__assign({}, getRequestHeaders(this._api.dsn, SDK_NAME, SDK_VERSION)), this.options.headers);
        var hostname = urlParts.hostname, pathname = urlParts.pathname, port = urlParts.port, protocol = urlParts.protocol;
        // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290
        // We ignore the query string on purpose
        var path = "" + pathname;
        return __assign({ agent: this.client, headers: headers,
            hostname: hostname, method: 'POST', path: path,
            port: port,
            protocol: protocol }, (this.options.caCerts && {
            ca: fs.readFileSync(this.options.caCerts),
        }));
    };
    /**
     * Gets the time that given category is disabled until for rate limiting
     */
    BaseTransport.prototype._disabledUntil = function (requestType) {
        var category = CATEGORY_MAPPING[requestType];
        return this._rateLimits[category] || this._rateLimits.all;
    };
    /**
     * Checks if a category is rate limited
     */
    BaseTransport.prototype._isRateLimited = function (requestType) {
        return this._disabledUntil(requestType) > new Date(Date.now());
    };
    /**
     * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.
     */
    BaseTransport.prototype._handleRateLimit = function (headers) {
        var e_2, _a, e_3, _b;
        var now = Date.now();
        var rlHeader = headers['x-sentry-rate-limits'];
        var raHeader = headers['retry-after'];
        if (rlHeader) {
            try {
                // rate limit headers are of the form
                //     <header>,<header>,..
                // where each <header> is of the form
                //     <retry_after>: <categories>: <scope>: <reason_code>
                // where
                //     <retry_after> is a delay in ms
                //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
                //         <category>;<category>;...
                //     <scope> is what's being limited (org, project, or key) - ignored by SDK
                //     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
                for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var limit = _d.value;
                    var parameters = limit.split(':', 2);
                    var headerDelay = parseInt(parameters[0], 10);
                    var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
                    try {
                        for (var _e = (e_3 = void 0, __values((parameters[1] && parameters[1].split(';')) || ['all'])), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var category = _f.value;
                            // categoriesAllowed is added here to ensure we are only storing rate limits for categories we support in this
                            // sdk and any categories that are not supported will not be added redundantly to the rateLimits object
                            var categoriesAllowed = __spread(Object.keys(CATEGORY_MAPPING).map(function (k) { return CATEGORY_MAPPING[k]; }), [
                                'all',
                            ]);
                            if (categoriesAllowed.includes(category))
                                this._rateLimits[category] = new Date(now + delay);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return true;
        }
        else if (raHeader) {
            this._rateLimits.all = new Date(now + parseRetryAfterHeader(raHeader, now));
            return true;
        }
        return false;
    };
    /** JSDoc */
    BaseTransport.prototype._send = function (sentryRequest, originalPayload) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!this.module) {
                    throw new SentryError('No module available');
                }
                if (originalPayload && this._isRateLimited(sentryRequest.type)) {
                    return [2 /*return*/, Promise.reject({
                            payload: originalPayload,
                            type: sentryRequest.type,
                            reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
                            status: 429,
                        })];
                }
                return [2 /*return*/, this._buffer.add(function () {
                        return new Promise(function (resolve, reject) {
                            if (!_this.module) {
                                throw new SentryError('No module available');
                            }
                            var options = _this._getRequestOptions(_this.urlParser(sentryRequest.url));
                            var req = _this.module.request(options, function (res) {
                                var statusCode = res.statusCode || 500;
                                var status = eventStatusFromHttpCode(statusCode);
                                res.setEncoding('utf8');
                                /**
                                 * "Key-value pairs of header names and values. Header names are lower-cased."
                                 * https://nodejs.org/api/http.html#http_message_headers
                                 */
                                var retryAfterHeader = res.headers ? res.headers['retry-after'] : '';
                                retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader);
                                var rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';
                                rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader);
                                var headers = {
                                    'x-sentry-rate-limits': rlHeader,
                                    'retry-after': retryAfterHeader,
                                };
                                var limited = _this._handleRateLimit(headers);
                                if (limited)
                                    IS_DEBUG_BUILD &&
                                        logger.warn("Too many " + sentryRequest.type + " requests, backing off until: " + _this._disabledUntil(sentryRequest.type));
                                if (status === 'success') {
                                    resolve({ status: status });
                                }
                                else {
                                    var rejectionMessage = "HTTP Error (" + statusCode + ")";
                                    if (res.headers && res.headers['x-sentry-error']) {
                                        rejectionMessage += ": " + res.headers['x-sentry-error'];
                                    }
                                    reject(new SentryError(rejectionMessage));
                                }
                                // Force the socket to drain
                                res.on('data', function () {
                                    // Drain
                                });
                                res.on('end', function () {
                                    // Drain
                                });
                            });
                            req.on('error', reject);
                            req.end(sentryRequest.body);
                        });
                    })];
            });
        });
    };
    return BaseTransport;
}());
export { BaseTransport };
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/transports/base/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { APIDetails, getRequestHeaders, initAPIDetails, SDK_VERSION } from '@sentry/core';\nimport {\n  DsnProtocol,\n  Event,\n  Response,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  SessionAggregates,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport {\n  eventStatusFromHttpCode,\n  logger,\n  makePromiseBuffer,\n  parseRetryAfterHeader,\n  PromiseBuffer,\n  SentryError,\n} from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\nimport { SDK_NAME } from '../../version';\nimport { HTTPModule } from './http-module';\n\nexport type URLParts = Pick<URL, 'hostname' | 'pathname' | 'port' | 'protocol'>;\nexport type UrlParser = (url: string) => URLParts;\n\nconst CATEGORY_MAPPING: {\n  [key in SentryRequestType]: string;\n} = {\n  event: 'error',\n  transaction: 'transaction',\n  session: 'session',\n  attachment: 'attachment',\n};\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPModule;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** API object */\n  protected _api: APIDetails;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = makePromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected readonly _rateLimits: Record<string, Date> = {};\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {\n    // eslint-disable-next-line deprecation/deprecation\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n  }\n\n  /** Default function used to parse URLs */\n  public urlParser: UrlParser = url => new URL(url);\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * Extracts proxy settings from client options and env variables.\n   *\n   * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.\n   *\n   * An order of priority for available protocols is:\n   * `http`  => `options.httpProxy` | `process.env.http_proxy`\n   * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`\n   */\n  protected _getProxy(protocol: DsnProtocol): string | undefined {\n    const { no_proxy, http_proxy, https_proxy } = process.env;\n    const { httpProxy, httpsProxy } = this.options;\n    const proxy = protocol === 'http' ? httpProxy || http_proxy : httpsProxy || httpProxy || https_proxy || http_proxy;\n\n    if (!no_proxy) {\n      return proxy;\n    }\n\n    const { host, port } = this._api.dsn;\n    for (const np of no_proxy.split(',')) {\n      if (host.endsWith(np) || `${host}:${port}`.endsWith(np)) {\n        return;\n      }\n    }\n\n    return proxy;\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(urlParts: URLParts): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...getRequestHeaders(this._api.dsn, SDK_NAME, SDK_VERSION),\n      ...this.options.headers,\n    };\n    const { hostname, pathname, port, protocol } = urlParts;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    const path = `${pathname}`;\n\n    return {\n      agent: this.client,\n      headers,\n      hostname,\n      method: 'POST',\n      path,\n      port,\n      protocol,\n      ...(this.options.caCerts && {\n        ca: fs.readFileSync(this.options.caCerts),\n      }),\n    };\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = CATEGORY_MAPPING[requestType];\n    return this._rateLimits[category] || this._rateLimits.all;\n  }\n\n  /**\n   * Checks if a category is rate limited\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  protected _handleRateLimit(headers: Record<string, string | null>): boolean {\n    const now = Date.now();\n    const rlHeader = headers['x-sentry-rate-limits'];\n    const raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      // rate limit headers are of the form\n      //     <header>,<header>,..\n      // where each <header> is of the form\n      //     <retry_after>: <categories>: <scope>: <reason_code>\n      // where\n      //     <retry_after> is a delay in ms\n      //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n      //         <category>;<category>;...\n      //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n      //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n      for (const limit of rlHeader.trim().split(',')) {\n        const parameters = limit.split(':', 2);\n        const headerDelay = parseInt(parameters[0], 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        for (const category of (parameters[1] && parameters[1].split(';')) || ['all']) {\n          // categoriesAllowed is added here to ensure we are only storing rate limits for categories we support in this\n          // sdk and any categories that are not supported will not be added redundantly to the rateLimits object\n          const categoriesAllowed = [\n            ...(Object.keys(CATEGORY_MAPPING) as [SentryRequestType]).map(k => CATEGORY_MAPPING[k]),\n            'all',\n          ];\n          if (categoriesAllowed.includes(category)) this._rateLimits[category] = new Date(now + delay);\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(raHeader, now));\n      return true;\n    }\n    return false;\n  }\n\n  /** JSDoc */\n  protected async _send(\n    sentryRequest: SentryRequest,\n    originalPayload?: Event | Session | SessionAggregates,\n  ): Promise<Response> {\n    if (!this.module) {\n      throw new SentryError('No module available');\n    }\n    if (originalPayload && this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        payload: originalPayload,\n        type: sentryRequest.type,\n        reason: `Transport for ${sentryRequest.type} requests locked till ${this._disabledUntil(\n          sentryRequest.type,\n        )} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    return this._buffer.add(\n      () =>\n        new Promise<Response>((resolve, reject) => {\n          if (!this.module) {\n            throw new SentryError('No module available');\n          }\n          const options = this._getRequestOptions(this.urlParser(sentryRequest.url));\n          const req = this.module.request(options, res => {\n            const statusCode = res.statusCode || 500;\n            const status = eventStatusFromHttpCode(statusCode);\n\n            res.setEncoding('utf8');\n\n            /**\n             * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n             * https://nodejs.org/api/http.html#http_message_headers\n             */\n            let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n            retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n\n            let rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';\n            rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader) as string;\n\n            const headers = {\n              'x-sentry-rate-limits': rlHeader,\n              'retry-after': retryAfterHeader,\n            };\n\n            const limited = this._handleRateLimit(headers);\n            if (limited)\n              IS_DEBUG_BUILD &&\n                logger.warn(\n                  `Too many ${sentryRequest.type} requests, backing off until: ${this._disabledUntil(\n                    sentryRequest.type,\n                  )}`,\n                );\n\n            if (status === 'success') {\n              resolve({ status });\n            } else {\n              let rejectionMessage = `HTTP Error (${statusCode})`;\n              if (res.headers && res.headers['x-sentry-error']) {\n                rejectionMessage += `: ${res.headers['x-sentry-error']}`;\n              }\n              reject(new SentryError(rejectionMessage));\n            }\n\n            // Force the socket to drain\n            res.on('data', () => {\n              // Drain\n            });\n            res.on('end', () => {\n              // Drain\n            });\n          });\n          req.on('error', reject);\n          req.end(sentryRequest.body);\n        }),\n    );\n  }\n}\n"]}import { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';
import { BaseTransport } from './base';
/** Node http module transport */
export declare class HTTPTransport extends BaseTransport {
    options: TransportOptions;
    /** Create a new instance and set this.agent */
    constructor(options: TransportOptions);
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): Promise<Response>;
    /**
     * @inheritDoc
     */
    sendSession(session: Session | SessionAggregates): PromiseLike<Response>;
}
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/transports/http.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAG9F,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,iCAAiC;AACjC,qBAAa,aAAc,SAAQ,aAAa;IAEpB,OAAO,EAAE,gBAAgB;IADnD,+CAA+C;gBACrB,OAAO,EAAE,gBAAgB;IASnD;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC;CAGhF"}import { __extends } from "tslib";
import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';
import * as http from 'http';
import { BaseTransport } from './base';
/** Node http module transport */
var HTTPTransport = /** @class */ (function (_super) {
    __extends(HTTPTransport, _super);
    /** Create a new instance and set this.agent */
    function HTTPTransport(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        var proxy = _this._getProxy('http');
        _this.module = http;
        _this.client = proxy
            ? new (require('https-proxy-agent'))(proxy)
            : new http.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });
        return _this;
    }
    /**
     * @inheritDoc
     */
    HTTPTransport.prototype.sendEvent = function (event) {
        return this._send(eventToSentryRequest(event, this._api), event);
    };
    /**
     * @inheritDoc
     */
    HTTPTransport.prototype.sendSession = function (session) {
        return this._send(sessionToSentryRequest(session, this._api), session);
    };
    return HTTPTransport;
}(BaseTransport));
export { HTTPTransport };
//# sourceMappingURL=http.js.map{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../src/transports/http.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,MAAM,cAAc,CAAC;AAE5E,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAE7B,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,iCAAiC;AACjC;IAAmC,iCAAa;IAC9C,+CAA+C;IAC/C,uBAA0B,OAAyB;QAAnD,YACE,kBAAM,OAAO,CAAC,SAMf;QAPyB,aAAO,GAAP,OAAO,CAAkB;QAEjD,IAAM,KAAK,GAAG,KAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QACrC,KAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,KAAI,CAAC,MAAM,GAAG,KAAK;YACjB,CAAC,CAAE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAgB;YAC3D,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;;IAC1E,CAAC;IAED;;OAEG;IACI,iCAAS,GAAhB,UAAiB,KAAY;QAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,mCAAW,GAAlB,UAAmB,OAAoC;QACrD,OAAO,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IACzE,CAAC;IACH,oBAAC;AAAD,CAAC,AAxBD,CAAmC,aAAa,GAwB/C","sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';\nimport * as http from 'http';\n\nimport { BaseTransport } from './base';\n\n/** Node http module transport */\nexport class HTTPTransport extends BaseTransport {\n  /** Create a new instance and set this.agent */\n  public constructor(public options: TransportOptions) {\n    super(options);\n    const proxy = this._getProxy('http');\n    this.module = http;\n    this.client = proxy\n      ? (new (require('https-proxy-agent'))(proxy) as http.Agent)\n      : new http.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): Promise<Response> {\n    return this._send(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): PromiseLike<Response> {\n    return this._send(sessionToSentryRequest(session, this._api), session);\n  }\n}\n"]}import { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';
import { BaseTransport } from './base';
/** Node https module transport */
export declare class HTTPSTransport extends BaseTransport {
    options: TransportOptions;
    /** Create a new instance and set this.agent */
    constructor(options: TransportOptions);
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): Promise<Response>;
    /**
     * @inheritDoc
     */
    sendSession(session: Session | SessionAggregates): PromiseLike<Response>;
}
//# sourceMappingURL=https.d.ts.map{"version":3,"file":"https.d.ts","sourceRoot":"","sources":["../../../src/transports/https.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAG9F,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,kCAAkC;AAClC,qBAAa,cAAe,SAAQ,aAAa;IAErB,OAAO,EAAE,gBAAgB;IADnD,+CAA+C;gBACrB,OAAO,EAAE,gBAAgB;IASnD;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC;CAGhF"}import { __extends } from "tslib";
import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';
import * as https from 'https';
import { BaseTransport } from './base';
/** Node https module transport */
var HTTPSTransport = /** @class */ (function (_super) {
    __extends(HTTPSTransport, _super);
    /** Create a new instance and set this.agent */
    function HTTPSTransport(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        var proxy = _this._getProxy('https');
        _this.module = https;
        _this.client = proxy
            ? new (require('https-proxy-agent'))(proxy)
            : new https.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });
        return _this;
    }
    /**
     * @inheritDoc
     */
    HTTPSTransport.prototype.sendEvent = function (event) {
        return this._send(eventToSentryRequest(event, this._api), event);
    };
    /**
     * @inheritDoc
     */
    HTTPSTransport.prototype.sendSession = function (session) {
        return this._send(sessionToSentryRequest(session, this._api), session);
    };
    return HTTPSTransport;
}(BaseTransport));
export { HTTPSTransport };
//# sourceMappingURL=https.js.map{"version":3,"file":"https.js","sourceRoot":"","sources":["../../../src/transports/https.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,oBAAoB,EAAE,sBAAsB,EAAE,MAAM,cAAc,CAAC;AAE5E,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAE/B,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,kCAAkC;AAClC;IAAoC,kCAAa;IAC/C,+CAA+C;IAC/C,wBAA0B,OAAyB;QAAnD,YACE,kBAAM,OAAO,CAAC,SAMf;QAPyB,aAAO,GAAP,OAAO,CAAkB;QAEjD,IAAM,KAAK,GAAG,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QACtC,KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,KAAI,CAAC,MAAM,GAAG,KAAK;YACjB,CAAC,CAAE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAiB;YAC5D,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;;IAC3E,CAAC;IAED;;OAEG;IACI,kCAAS,GAAhB,UAAiB,KAAY;QAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,oCAAW,GAAlB,UAAmB,OAAoC;QACrD,OAAO,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IACzE,CAAC;IACH,qBAAC;AAAD,CAAC,AAxBD,CAAoC,aAAa,GAwBhD","sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';\nimport * as https from 'https';\n\nimport { BaseTransport } from './base';\n\n/** Node https module transport */\nexport class HTTPSTransport extends BaseTransport {\n  /** Create a new instance and set this.agent */\n  public constructor(public options: TransportOptions) {\n    super(options);\n    const proxy = this._getProxy('https');\n    this.module = https;\n    this.client = proxy\n      ? (new (require('https-proxy-agent'))(proxy) as https.Agent)\n      : new https.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): Promise<Response> {\n    return this._send(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session | SessionAggregates): PromiseLike<Response> {\n    return this._send(sessionToSentryRequest(session, this._api), session);\n  }\n}\n"]}export { BaseTransport } from './base';
export { HTTPTransport } from './http';
export { HTTPSTransport } from './https';
export { makeNodeTransport, NodeTransportOptions } from './new';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/transports/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,MAAM,OAAO,CAAC"}export { BaseTransport } from './base';
export { HTTPTransport } from './http';
export { HTTPSTransport } from './https';
export { makeNodeTransport } from './new';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/transports/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,iBAAiB,EAAwB,MAAM,OAAO,CAAC","sourcesContent":["export { BaseTransport } from './base';\nexport { HTTPTransport } from './http';\nexport { HTTPSTransport } from './https';\nexport { makeNodeTransport, NodeTransportOptions } from './new';\n"]}/// <reference types="node" />
import { BaseTransportOptions, NewTransport } from '@sentry/core';
import { HTTPModule } from './base/http-module';
export interface NodeTransportOptions extends BaseTransportOptions {
    /** Define custom headers */
    headers?: Record<string, string>;
    /** Set a proxy that should be used for outbound requests. */
    proxy?: string;
    /** HTTPS proxy CA certificates */
    caCerts?: string | Buffer | Array<string | Buffer>;
    /** Custom HTTP module. Defaults to the native 'http' and 'https' modules. */
    httpModule?: HTTPModule;
}
/**
 * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.
 */
export declare function makeNodeTransport(options: NodeTransportOptions): NewTransport;
//# sourceMappingURL=new.d.ts.map{"version":3,"file":"new.d.ts","sourceRoot":"","sources":["../../../src/transports/new.ts"],"names":[],"mappings":";AAAA,OAAO,EACL,oBAAoB,EAEpB,YAAY,EAIb,MAAM,cAAc,CAAC;AAMtB,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAShD,MAAM,WAAW,oBAAqB,SAAQ,oBAAoB;IAChE,4BAA4B;IAC5B,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACjC,6DAA6D;IAC7D,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,kCAAkC;IAClC,OAAO,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACnD,6EAA6E;IAC7E,UAAU,CAAC,EAAE,UAAU,CAAC;CACzB;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,OAAO,EAAE,oBAAoB,GAAG,YAAY,CAqB7E"}import { createTransport, } from '@sentry/core';
import { eventStatusFromHttpCode } from '@sentry/utils';
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
/**
 * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.
 */
export function makeNodeTransport(options) {
    var _a;
    var urlSegments = new URL(options.url);
    var isHttps = urlSegments.protocol === 'https:';
    // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`
    // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`
    var proxy = applyNoProxyOption(urlSegments, options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy);
    var nativeHttpModule = isHttps ? https : http;
    // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node
    // versions(>= 8) as they had memory leaks when using it: #2555
    var agent = proxy
        ? new (require('https-proxy-agent'))(proxy)
        : new nativeHttpModule.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });
    var requestExecutor = createRequestExecutor(options, (_a = options.httpModule, (_a !== null && _a !== void 0 ? _a : nativeHttpModule)), agent);
    return createTransport({ bufferSize: options.bufferSize }, requestExecutor);
}
/**
 * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.
 *
 * @param transportUrl The URL the transport intends to send events to.
 * @param proxy The client configured proxy.
 * @returns A proxy the transport should use.
 */
function applyNoProxyOption(transportUrlSegments, proxy) {
    var no_proxy = process.env.no_proxy;
    var urlIsExemptFromProxy = no_proxy &&
        no_proxy
            .split(',')
            .some(function (exemption) { return transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption); });
    if (urlIsExemptFromProxy) {
        return undefined;
    }
    else {
        return proxy;
    }
}
/**
 * Creates a RequestExecutor to be used with `createTransport`.
 */
function createRequestExecutor(options, httpModule, agent) {
    var _a = new URL(options.url), hostname = _a.hostname, pathname = _a.pathname, port = _a.port, protocol = _a.protocol, search = _a.search;
    return function makeRequest(request) {
        return new Promise(function (resolve, reject) {
            var req = httpModule.request({
                method: 'POST',
                agent: agent,
                headers: options.headers,
                hostname: hostname,
                path: "" + pathname + search,
                port: port,
                protocol: protocol,
                ca: options.caCerts,
            }, function (res) {
                var _a, _b, _c;
                res.on('data', function () {
                    // Drain socket
                });
                res.on('end', function () {
                    // Drain socket
                });
                var statusCode = (_a = res.statusCode, (_a !== null && _a !== void 0 ? _a : 500));
                var status = eventStatusFromHttpCode(statusCode);
                res.setEncoding('utf8');
                // "Key-value pairs of header names and values. Header names are lower-cased."
                // https://nodejs.org/api/http.html#http_message_headers
                var retryAfterHeader = (_b = res.headers['retry-after'], (_b !== null && _b !== void 0 ? _b : null));
                var rateLimitsHeader = (_c = res.headers['x-sentry-rate-limits'], (_c !== null && _c !== void 0 ? _c : null));
                resolve({
                    headers: {
                        'retry-after': retryAfterHeader,
                        'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader,
                    },
                    reason: status,
                    statusCode: statusCode,
                });
            });
            req.on('error', reject);
            req.end(request.body);
        });
    };
}
//# sourceMappingURL=new.js.map{"version":3,"file":"new.js","sourceRoot":"","sources":["../../../src/transports/new.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BaseTransportOptions,\n  createTransport,\n  NewTransport,\n  TransportMakeRequestResponse,\n  TransportRequest,\n  TransportRequestExecutor,\n} from '@sentry/core';\nimport { eventStatusFromHttpCode } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\n\nimport { HTTPModule } from './base/http-module';\n\n// TODO(v7):\n// - Rename this file \"transport.ts\"\n// - Move this file one folder upwards\n// - Delete \"transports\" folder\n// OR\n// - Split this file up and leave it in the transports folder\n\nexport interface NodeTransportOptions extends BaseTransportOptions {\n  /** Define custom headers */\n  headers?: Record<string, string>;\n  /** Set a proxy that should be used for outbound requests. */\n  proxy?: string;\n  /** HTTPS proxy CA certificates */\n  caCerts?: string | Buffer | Array<string | Buffer>;\n  /** Custom HTTP module. Defaults to the native 'http' and 'https' modules. */\n  httpModule?: HTTPModule;\n}\n\n/**\n * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.\n */\nexport function makeNodeTransport(options: NodeTransportOptions): NewTransport {\n  const urlSegments = new URL(options.url);\n  const isHttps = urlSegments.protocol === 'https:';\n\n  // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`\n  // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`\n  const proxy = applyNoProxyOption(\n    urlSegments,\n    options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy,\n  );\n\n  const nativeHttpModule = isHttps ? https : http;\n\n  // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node\n  // versions(>= 8) as they had memory leaks when using it: #2555\n  const agent = proxy\n    ? (new (require('https-proxy-agent'))(proxy) as http.Agent)\n    : new nativeHttpModule.Agent({ keepAlive: false, maxSockets: 30, timeout: 2000 });\n\n  const requestExecutor = createRequestExecutor(options, options.httpModule ?? nativeHttpModule, agent);\n  return createTransport({ bufferSize: options.bufferSize }, requestExecutor);\n}\n\n/**\n * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.\n *\n * @param transportUrl The URL the transport intends to send events to.\n * @param proxy The client configured proxy.\n * @returns A proxy the transport should use.\n */\nfunction applyNoProxyOption(transportUrlSegments: URL, proxy: string | undefined): string | undefined {\n  const { no_proxy } = process.env;\n\n  const urlIsExemptFromProxy =\n    no_proxy &&\n    no_proxy\n      .split(',')\n      .some(\n        exemption => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption),\n      );\n\n  if (urlIsExemptFromProxy) {\n    return undefined;\n  } else {\n    return proxy;\n  }\n}\n\n/**\n * Creates a RequestExecutor to be used with `createTransport`.\n */\nfunction createRequestExecutor(\n  options: NodeTransportOptions,\n  httpModule: HTTPModule,\n  agent: http.Agent,\n): TransportRequestExecutor {\n  const { hostname, pathname, port, protocol, search } = new URL(options.url);\n\n  return function makeRequest(request: TransportRequest): Promise<TransportMakeRequestResponse> {\n    return new Promise((resolve, reject) => {\n      const req = httpModule.request(\n        {\n          method: 'POST',\n          agent,\n          headers: options.headers,\n          hostname,\n          path: `${pathname}${search}`,\n          port,\n          protocol,\n          ca: options.caCerts,\n        },\n        res => {\n          res.on('data', () => {\n            // Drain socket\n          });\n\n          res.on('end', () => {\n            // Drain socket\n          });\n\n          const statusCode = res.statusCode ?? 500;\n          const status = eventStatusFromHttpCode(statusCode);\n\n          res.setEncoding('utf8');\n\n          // \"Key-value pairs of header names and values. Header names are lower-cased.\"\n          // https://nodejs.org/api/http.html#http_message_headers\n          const retryAfterHeader = res.headers['retry-after'] ?? null;\n          const rateLimitsHeader = res.headers['x-sentry-rate-limits'] ?? null;\n\n          resolve({\n            headers: {\n              'retry-after': retryAfterHeader,\n              'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader,\n            },\n            reason: status,\n            statusCode: statusCode,\n          });\n        },\n      );\n\n      req.on('error', reject);\n      req.end(request.body);\n    });\n  };\n}\n"]}import { Options } from '@sentry/types';
/**
 * Configuration options for the Sentry Node SDK.
 * @see NodeClient for more information.
 */
export interface NodeOptions extends Options {
    /** Sets an optional server name (device name) */
    serverName?: string;
    /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */
    shutdownTimeout?: number;
    /** Set a HTTP proxy that should be used for outbound requests. */
    httpProxy?: string;
    /** Set a HTTPS proxy that should be used for outbound requests. */
    httpsProxy?: string;
    /** HTTPS proxy certificates path */
    caCerts?: string;
    /**
     * Sets the number of context lines for each frame when loading a file.
     *
     * @deprecated Context lines configuration has moved to the `ContextLines` integration, and can be used like this:
     *
     * ```
     * init({
     *   dsn: '__DSN__',
     *   integrations: [new ContextLines({ frameContextLines: 10 })]
     * })
     * ```
     *
     * */
    frameContextLines?: number;
    /** Callback that is executed when a fatal global error occurs. */
    onFatalError?(error: Error): void;
}
//# sourceMappingURL=types.d.ts.map{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAExC;;;GAGG;AACH,MAAM,WAAW,WAAY,SAAQ,OAAO;IAC1C,iDAAiD;IACjD,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,8GAA8G;IAC9G,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB,kEAAkE;IAClE,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB,mEAAmE;IACnE,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,oCAAoC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;;;;;;;;;;SAYK;IACL,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B,kEAAkE;IAClE,YAAY,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;CACnC"}//# sourceMappingURL=types.js.map{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import { Options } from '@sentry/types';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   *\n   * @deprecated Context lines configuration has moved to the `ContextLines` integration, and can be used like this:\n   *\n   * ```\n   * init({\n   *   dsn: '__DSN__',\n   *   integrations: [new ContextLines({ frameContextLines: 10 })]\n   * })\n   * ```\n   *\n   * */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n"]}/**
 * Recursively read the contents of a directory.
 *
 * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this
 * directory.
 * @returns Array holding all relative paths
 */
export declare function deepReadDirSync(targetDir: string): string[];
//# sourceMappingURL=utils.d.ts.map{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"AAGA;;;;;;GAMG;AACH,wBAAgB,eAAe,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,CA2B3D"}import { __read, __spread } from "tslib";
import * as fs from 'fs';
import * as path from 'path';
/**
 * Recursively read the contents of a directory.
 *
 * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this
 * directory.
 * @returns Array holding all relative paths
 */
export function deepReadDirSync(targetDir) {
    var targetDirAbsPath = path.resolve(targetDir);
    if (!fs.existsSync(targetDirAbsPath)) {
        throw new Error("Cannot read contents of " + targetDirAbsPath + ". Directory does not exist.");
    }
    if (!fs.statSync(targetDirAbsPath).isDirectory()) {
        throw new Error("Cannot read contents of " + targetDirAbsPath + ", because it is not a directory.");
    }
    // This does the same thing as its containing function, `deepReadDirSync` (except that - purely for convenience - it
    // deals in absolute paths rather than relative ones). We need this to be separate from the outer function to preserve
    // the difference between `targetDirAbsPath` and `currentDirAbsPath`.
    var deepReadCurrentDir = function (currentDirAbsPath) {
        return fs.readdirSync(currentDirAbsPath).reduce(function (absPaths, itemName) {
            var itemAbsPath = path.join(currentDirAbsPath, itemName);
            if (fs.statSync(itemAbsPath).isDirectory()) {
                return __spread(absPaths, deepReadCurrentDir(itemAbsPath));
            }
            return __spread(absPaths, [itemAbsPath]);
        }, []);
    };
    return deepReadCurrentDir(targetDirAbsPath).map(function (absPath) { return path.relative(targetDirAbsPath, absPath); });
}
//# sourceMappingURL=utils.js.map{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,MAAM,IAAI,CAAC;AACzB,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAE7B;;;;;;GAMG;AACH,MAAM,UAAU,eAAe,CAAC,SAAiB;IAC/C,IAAM,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAEjD,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,EAAE;QACpC,MAAM,IAAI,KAAK,CAAC,6BAA2B,gBAAgB,gCAA6B,CAAC,CAAC;KAC3F;IAED,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,WAAW,EAAE,EAAE;QAChD,MAAM,IAAI,KAAK,CAAC,6BAA2B,gBAAgB,qCAAkC,CAAC,CAAC;KAChG;IAED,oHAAoH;IACpH,sHAAsH;IACtH,qEAAqE;IACrE,IAAM,kBAAkB,GAAG,UAAC,iBAAyB;QACnD,OAAO,EAAE,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC,MAAM,CAAC,UAAC,QAAkB,EAAE,QAAgB;YACnF,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;YAE3D,IAAI,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,EAAE;gBAC1C,gBAAW,QAAQ,EAAK,kBAAkB,CAAC,WAAW,CAAC,EAAE;aAC1D;YAED,gBAAW,QAAQ,GAAE,WAAW,GAAE;QACpC,CAAC,EAAE,EAAE,CAAC,CAAC;IACT,CAAC,CAAC;IAEF,OAAO,kBAAkB,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,UAAA,OAAO,IAAI,OAAA,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,OAAO,CAAC,EAAxC,CAAwC,CAAC,CAAC;AACvG,CAAC","sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * Recursively read the contents of a directory.\n *\n * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this\n * directory.\n * @returns Array holding all relative paths\n */\nexport function deepReadDirSync(targetDir: string): string[] {\n  const targetDirAbsPath = path.resolve(targetDir);\n\n  if (!fs.existsSync(targetDirAbsPath)) {\n    throw new Error(`Cannot read contents of ${targetDirAbsPath}. Directory does not exist.`);\n  }\n\n  if (!fs.statSync(targetDirAbsPath).isDirectory()) {\n    throw new Error(`Cannot read contents of ${targetDirAbsPath}, because it is not a directory.`);\n  }\n\n  // This does the same thing as its containing function, `deepReadDirSync` (except that - purely for convenience - it\n  // deals in absolute paths rather than relative ones). We need this to be separate from the outer function to preserve\n  // the difference between `targetDirAbsPath` and `currentDirAbsPath`.\n  const deepReadCurrentDir = (currentDirAbsPath: string): string[] => {\n    return fs.readdirSync(currentDirAbsPath).reduce((absPaths: string[], itemName: string) => {\n      const itemAbsPath = path.join(currentDirAbsPath, itemName);\n\n      if (fs.statSync(itemAbsPath).isDirectory()) {\n        return [...absPaths, ...deepReadCurrentDir(itemAbsPath)];\n      }\n\n      return [...absPaths, itemAbsPath];\n    }, []);\n  };\n\n  return deepReadCurrentDir(targetDirAbsPath).map(absPath => path.relative(targetDirAbsPath, absPath));\n}\n"]}export declare const SDK_NAME = "sentry.javascript.node";
//# sourceMappingURL=version.d.ts.map{"version":3,"file":"version.d.ts","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AACA,eAAO,MAAM,QAAQ,2BAA2B,CAAC"}// TODO: Remove in the next major release and rely only on @sentry/core SDK_VERSION and SdkMetadata
export var SDK_NAME = 'sentry.javascript.node';
//# sourceMappingURL=version.js.map{"version":3,"file":"version.js","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AAAA,mGAAmG;AACnG,MAAM,CAAC,IAAM,QAAQ,GAAG,wBAAwB,CAAC","sourcesContent":["// TODO: Remove in the next major release and rely only on @sentry/core SDK_VERSION and SdkMetadata\nexport const SDK_NAME = 'sentry.javascript.node';\n"]}BSD 3-Clause License

Copyright (c) 2019, Sentry
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@sentry/node",
  "version": "6.19.7",
  "description": "Official Sentry SDK for Node.js",
  "repository": "git://github.com/getsentry/sentry-javascript.git",
  "homepage": "https://github.com/getsentry/sentry-javascript/tree/master/packages/node",
  "author": "Sentry",
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=6"
  },
  "main": "dist/index.js",
  "module": "esm/index.js",
  "types": "types/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@sentry/core": "6.19.7",
    "@sentry/hub": "6.19.7",
    "@sentry/types": "6.19.7",
    "@sentry/utils": "6.19.7",
    "cookie": "^0.4.1",
    "https-proxy-agent": "^5.0.0",
    "lru_map": "^0.3.3",
    "tslib": "^1.9.3"
  },
  "devDependencies": {
    "@types/cookie": "0.3.2",
    "@types/express": "^4.17.2",
    "@types/lru-cache": "^5.1.0",
    "@types/node": "~10.17.0",
    "express": "^4.17.1",
    "nock": "^13.0.5"
  }
}<p align="center">
  <a href="https://sentry.io" target="_blank" align="center">
    <img src="https://sentry-brand.storage.googleapis.com/sentry-logo-black.png" width="280">
  </a>
  <br />
</p>

# Official Sentry SDK for NodeJS

[![npm version](https://img.shields.io/npm/v/@sentry/node.svg)](https://www.npmjs.com/package/@sentry/node)
[![npm dm](https://img.shields.io/npm/dm/@sentry/node.svg)](https://www.npmjs.com/package/@sentry/node)
[![npm dt](https://img.shields.io/npm/dt/@sentry/node.svg)](https://www.npmjs.com/package/@sentry/node)
[![typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](http://getsentry.github.io/sentry-javascript/)

## Links

- [Official SDK Docs](https://docs.sentry.io/quickstart/)
- [TypeDoc](http://getsentry.github.io/sentry-javascript/)

## Usage

To use this SDK, call `init(options)` as early as possible in the main entry module. This will initialize the SDK and
hook into the environment. Note that you can turn off almost all side effects using the respective options.

```javascript
// ES5 Syntax
const Sentry = require('@sentry/node');
// ES6 Syntax
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: '__DSN__',
  // ...
});
```

To set context information or send manual events, use the exported functions of `@sentry/node`. Note that these
functions will not perform any action before you have called `init()`:

```javascript
// Set user information, as well as tags and further extras
Sentry.configureScope(scope => {
  scope.setExtra('battery', 0.7);
  scope.setTag('user_mode', 'admin');
  scope.setUser({ id: '4711' });
  // scope.clear();
});

// Add a breadcrumb for future events
Sentry.addBreadcrumb({
  message: 'My Breadcrumb',
  // ...
});

// Capture exceptions, messages or manual events
Sentry.captureMessage('Hello, world!');
Sentry.captureException(new Error('Good bye'));
Sentry.captureEvent({
  message: 'Manual',
  stacktrace: [
    // ...
  ],
});
```
import { BaseBackend } from '@sentry/core';
import { Event, EventHint, Severity, Transport } from '@sentry/types';
import { NodeOptions } from './types';
/**
 * The Sentry Node SDK Backend.
 * @hidden
 */
export declare class NodeBackend extends BaseBackend<NodeOptions> {
    /**
     * @inheritDoc
     */
    eventFromException(exception: any, hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    eventFromMessage(message: string, level?: Severity, hint?: EventHint): PromiseLike<Event>;
    /**
     * @inheritDoc
     */
    protected _setupTransport(): Transport;
}
//# sourceMappingURL=backend.d.ts.map{"version":3,"file":"backend.d.ts","sourceRoot":"","sources":["../../src/backend.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAyD,MAAM,cAAc,CAAC;AAClG,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAoB,MAAM,eAAe,CAAC;AAKxF,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC;;;GAGG;AACH,qBAAa,WAAY,SAAQ,WAAW,CAAC,WAAW,CAAC;IACvD;;OAEG;IAEI,kBAAkB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAI/E;;OAEG;IACI,gBAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,GAAE,QAAwB,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC;IAI/G;;OAEG;IACH,SAAS,CAAC,eAAe,IAAI,SAAS;CAqCvC"}import { BaseClient, Scope } from '@sentry/core';
import { SessionFlusher } from '@sentry/hub';
import { Event, EventHint } from '@sentry/types';
import { NodeBackend } from './backend';
import { NodeOptions } from './types';
/**
 * The Sentry Node SDK Client.
 *
 * @see NodeOptions for documentation on configuration options.
 * @see SentryClient for usage documentation.
 */
export declare class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
    protected _sessionFlusher: SessionFlusher | undefined;
    /**
     * Creates a new Node SDK instance.
     * @param options Configuration options for this SDK.
     */
    constructor(options: NodeOptions);
    /**
     * @inheritDoc
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * @inheritDoc
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     *
     * @inheritdoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /** Method that initialises an instance of SessionFlusher on Client */
    initSessionFlusher(): void;
    /**
     * @inheritDoc
     */
    protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null>;
    /**
     * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
     * appropriate session aggregates bucket
     */
    protected _captureRequestSession(): void;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,KAAK,EAAe,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAGjD,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC;;;;;GAKG;AACH,qBAAa,UAAW,SAAQ,UAAU,CAAC,WAAW,EAAE,WAAW,CAAC;IAClE,SAAS,CAAC,eAAe,EAAE,cAAc,GAAG,SAAS,CAAC;IAEtD;;;OAGG;gBACgB,OAAO,EAAE,WAAW;IAgBvC;;OAEG;IAEI,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAiB5F;;OAEG;IACI,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS;IAwBtF;;;OAGG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAKpD,sEAAsE;IAC/D,kBAAkB,IAAI,IAAI;IAYjC;;OAEG;IACH,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC;IAQjG;;;OAGG;IACH,SAAS,CAAC,sBAAsB,IAAI,IAAI;CAOzC"}import { Event, EventHint, Exception, Severity, StackFrame } from '@sentry/types';
/**
 * Extracts stack frames from the error.stack string
 */
export declare function parseStackFrames(error: Error): StackFrame[];
/**
 * Extracts stack frames from the error and builds a Sentry Exception
 */
export declare function exceptionFromError(error: Error): Exception;
/**
 * Builds and Event from a Exception
 * @hidden
 */
export declare function eventFromUnknownInput(exception: unknown, hint?: EventHint): Event;
/**
 * Builds and Event from a Message
 * @hidden
 */
export declare function eventFromMessage(message: string, level?: Severity, hint?: EventHint, attachStacktrace?: boolean): Event;
//# sourceMappingURL=eventbuilder.d.ts.map{"version":3,"file":"eventbuilder.d.ts","sourceRoot":"","sources":["../../src/eventbuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAa,QAAQ,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAa7F;;GAEG;AACH,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,UAAU,EAAE,CAE3D;AAED;;GAEG;AACH,wBAAgB,kBAAkB,CAAC,KAAK,EAAE,KAAK,GAAG,SAAS,CAY1D;AAED;;;GAGG;AACH,wBAAgB,qBAAqB,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,SAAS,GAAG,KAAK,CA4CjF;AAED;;;GAGG;AACH,wBAAgB,gBAAgB,CAC9B,OAAO,EAAE,MAAM,EACf,KAAK,GAAE,QAAwB,EAC/B,IAAI,CAAC,EAAE,SAAS,EAChB,gBAAgB,CAAC,EAAE,OAAO,GACzB,KAAK,CAeP"}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/// <reference types="node" />
import { Event, ExtractedNodeRequestData } from '@sentry/types';
import * as http from 'http';
export interface ExpressRequest {
    baseUrl?: string;
    connection?: {
        remoteAddress?: string;
    };
    ip?: string;
    method?: string;
    originalUrl?: string;
    route?: {
        path: string;
        stack: [{
            name: string;
        }];
    };
    query?: {
        [key: string]: unknown;
    };
    url?: string;
    user?: {
        [key: string]: any;
    };
}
/**
 * Express-compatible tracing handler.
 * @see Exposed as `Handlers.tracingHandler`
 */
export declare function tracingHandler(): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void;
declare type TransactionNamingScheme = 'path' | 'methodPath' | 'handler';
/**
 * Normalizes data from the request object, accounting for framework differences.
 *
 * @param req The request object from which to extract data
 * @param keys An optional array of keys to include in the normalized data. Defaults to DEFAULT_REQUEST_KEYS if not
 * provided.
 * @returns An object containing normalized request data
 */
export declare function extractRequestData(req: {
    [key: string]: any;
}, keys?: string[]): ExtractedNodeRequestData;
/**
 * Options deciding what parts of the request to use when enhancing an event
 */
export interface ParseRequestOptions {
    ip?: boolean;
    request?: boolean | string[];
    serverName?: boolean;
    transaction?: boolean | TransactionNamingScheme;
    user?: boolean | string[];
    version?: boolean;
}
/**
 * Enriches passed event with request data.
 *
 * @param event Will be mutated and enriched with req data
 * @param req Request object
 * @param options object containing flags to enable functionality
 * @hidden
 */
export declare function parseRequest(event: Event, req: ExpressRequest, options?: ParseRequestOptions): Event;
export declare type RequestHandlerOptions = ParseRequestOptions & {
    flushTimeout?: number;
};
/**
 * Express compatible request handler.
 * @see Exposed as `Handlers.requestHandler`
 */
export declare function requestHandler(options?: RequestHandlerOptions): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void;
/** JSDoc */
interface MiddlewareError extends Error {
    status?: number | string;
    statusCode?: number | string;
    status_code?: number | string;
    output?: {
        statusCode?: number | string;
    };
}
/**
 * Express compatible error handler.
 * @see Exposed as `Handlers.errorHandler`
 */
export declare function errorHandler(options?: {
    /**
     * Callback method deciding whether error should be captured and sent to Sentry
     * @param error Captured middleware error
     */
    shouldHandleError?(error: MiddlewareError): boolean;
}): (error: MiddlewareError, req: http.IncomingMessage, res: http.ServerResponse, next: (error: MiddlewareError) => void) => void;
export {};
//# sourceMappingURL=handlers.d.ts.map{"version":3,"file":"handlers.d.ts","sourceRoot":"","sources":["../../src/handlers.ts"],"names":[],"mappings":"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"}export { Breadcrumb, BreadcrumbHint, Request, SdkInfo, Event, EventHint, EventStatus, Exception, Response, Severity, StackFrame, Stacktrace, Thread, User, } from '@sentry/types';
export { SeverityLevel } from '@sentry/utils';
export { addGlobalEventProcessor, addBreadcrumb, captureException, captureEvent, captureMessage, configureScope, getHubFromCarrier, getCurrentHub, Hub, makeMain, Scope, Session, startTransaction, SDK_VERSION, setContext, setExtra, setExtras, setTag, setTags, setUser, withScope, } from '@sentry/core';
export { NodeOptions } from './types';
export { NodeBackend } from './backend';
export { NodeClient } from './client';
export { defaultIntegrations, init, lastEventId, flush, close, getSentryRelease } from './sdk';
export { deepReadDirSync } from './utils';
export { SDK_NAME } from './version';
import { Integrations as CoreIntegrations } from '@sentry/core';
import * as Handlers from './handlers';
import * as NodeIntegrations from './integrations';
import * as Transports from './transports';
declare const INTEGRATIONS: {
    Console: typeof NodeIntegrations.Console;
    Http: typeof NodeIntegrations.Http;
    OnUncaughtException: typeof NodeIntegrations.OnUncaughtException;
    OnUnhandledRejection: typeof NodeIntegrations.OnUnhandledRejection;
    LinkedErrors: typeof NodeIntegrations.LinkedErrors;
    Modules: typeof NodeIntegrations.Modules;
    ContextLines: typeof NodeIntegrations.ContextLines;
    FunctionToString: typeof CoreIntegrations.FunctionToString;
    InboundFilters: typeof CoreIntegrations.InboundFilters;
};
export { INTEGRATIONS as Integrations, Transports, Handlers };
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,UAAU,EACV,cAAc,EACd,OAAO,EACP,OAAO,EACP,KAAK,EACL,SAAS,EACT,WAAW,EACX,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,UAAU,EACV,UAAU,EACV,MAAM,EACN,IAAI,GACL,MAAM,eAAe,CAAC;AAEvB,OAAO,EAAE,aAAa,EAAE,MAAM,eAAe,CAAC;AAE9C,OAAO,EACL,uBAAuB,EACvB,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,iBAAiB,EACjB,aAAa,EACb,GAAG,EACH,QAAQ,EACR,KAAK,EACL,OAAO,EACP,gBAAgB,EAChB,WAAW,EACX,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,cAAc,CAAC;AAEtB,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AACtC,OAAO,EAAE,mBAAmB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,KAAK,EAAE,gBAAgB,EAAE,MAAM,OAAO,CAAC;AAC/F,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAErC,OAAO,EAAE,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAIhE,OAAO,KAAK,QAAQ,MAAM,YAAY,CAAC;AACvC,OAAO,KAAK,gBAAgB,MAAM,gBAAgB,CAAC;AACnD,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAE3C,QAAA,MAAM,YAAY;;;;;;;;;;CAGjB,CAAC;AAEF,OAAO,EAAE,YAAY,IAAI,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC"}import { Integration } from '@sentry/types';
/** Console module integration */
export declare class Console implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=console.d.ts.map{"version":3,"file":"console.d.ts","sourceRoot":"","sources":["../../../src/integrations/console.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAI5C,iCAAiC;AACjC,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,IAAI,IAAI;CAKzB"}import { Event, EventProcessor, Integration, StackFrame } from '@sentry/types';
/**
 * Resets the file cache. Exists for testing purposes.
 * @hidden
 */
export declare function resetFileContentCache(): void;
interface ContextLinesOptions {
    /**
     * Sets the number of context lines for each frame when loading a file.
     * Defaults to 7.
     *
     * Set to 0 to disable loading and inclusion of source files.
     **/
    frameContextLines?: number;
}
/** Add node modules / packages to the event */
export declare class ContextLines implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    constructor(_options?: ContextLinesOptions);
    /** Get's the number of context lines to add */
    private get _contextLines();
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void;
    /** Processes an event and adds context lines */
    addSourceContext(event: Event): Promise<Event>;
    /** Adds context lines to frames */
    addSourceContextToFrames(frames: StackFrame[]): Promise<void>;
}
export {};
//# sourceMappingURL=contextlines.d.ts.map{"version":3,"file":"contextlines.d.ts","sourceRoot":"","sources":["../../../src/integrations/contextlines.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,WAAW,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAoB/E;;;GAGG;AACH,wBAAgB,qBAAqB,IAAI,IAAI,CAE5C;AAED,UAAU,mBAAmB;IAC3B;;;;;QAKI;IACJ,iBAAiB,CAAC,EAAE,MAAM,CAAC;CAC5B;AAED,+CAA+C;AAC/C,qBAAa,YAAa,YAAW,WAAW;IAW3B,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAV5C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACI,IAAI,EAAE,MAAM,CAAmB;gBAEF,QAAQ,GAAE,mBAAwB;IAEtE,+CAA+C;IAC/C,OAAO,KAAK,aAAa,GAYxB;IAED;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,GAAG,IAAI;IAInF,gDAAgD;IACnC,gBAAgB,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;IAY3D,mCAAmC;IACtB,wBAAwB,CAAC,MAAM,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC;CAoB3E"}import { Integration } from '@sentry/types';
/** http module integration */
export declare class Http implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    private readonly _breadcrumbs;
    /**
     * @inheritDoc
     */
    private readonly _tracing;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        breadcrumbs?: boolean;
        tracing?: boolean;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
}
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/integrations/http.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAQ,MAAM,eAAe,CAAC;AAiBlD,8BAA8B;AAC9B,qBAAa,IAAK,YAAW,WAAW;IACtC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAU;IAElC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAW;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAU;IAEvC;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAU;IAEnC;;OAEG;gBACgB,OAAO,GAAE;QAAE,WAAW,CAAC,EAAE,OAAO,CAAC;QAAC,OAAO,CAAC,EAAE,OAAO,CAAA;KAAO;IAK7E;;OAEG;IACI,SAAS,IAAI,IAAI;CAuBzB"}export { Console } from './console';
export { Http } from './http';
export { OnUncaughtException } from './onuncaughtexception';
export { OnUnhandledRejection } from './onunhandledrejection';
export { LinkedErrors } from './linkederrors';
export { Modules } from './modules';
export { ContextLines } from './contextlines';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/integrations/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,OAAO,EAAE,oBAAoB,EAAE,MAAM,wBAAwB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC"}import { Integration } from '@sentry/types';
/** Adds SDK info to an event. */
export declare class LinkedErrors implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    readonly name: string;
    /**
     * @inheritDoc
     */
    private readonly _key;
    /**
     * @inheritDoc
     */
    private readonly _limit;
    /**
     * @inheritDoc
     */
    constructor(options?: {
        key?: string;
        limit?: number;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @inheritDoc
     */
    private _handler;
    /**
     * @inheritDoc
     */
    private _walkErrorTree;
}
//# sourceMappingURL=linkederrors.d.ts.map{"version":3,"file":"linkederrors.d.ts","sourceRoot":"","sources":["../../../src/integrations/linkederrors.ts"],"names":[],"mappings":"AACA,OAAO,EAA8C,WAAW,EAAE,MAAM,eAAe,CAAC;AASxF,iCAAiC;AACjC,qBAAa,YAAa,YAAW,WAAW;IAC9C;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAkB;IAE1C;;OAEG;IACH,SAAgB,IAAI,EAAE,MAAM,CAAmB;IAE/C;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAS;IAE9B;;OAEG;IACH,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAS;IAEhC;;OAEG;gBACgB,OAAO,GAAE;QAAE,GAAG,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAA;KAAO;IAKjE;;OAEG;IACI,SAAS,IAAI,IAAI;IAWxB;;OAEG;IACH,OAAO,CAAC,QAAQ;IAmBhB;;OAEG;YACW,cAAc;CAsB7B"}import { EventProcessor, Hub, Integration } from '@sentry/types';
/** Add node modules / packages to the event */
export declare class Modules implements Integration {
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
    /** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
    private _getModules;
}
//# sourceMappingURL=modules.d.ts.map{"version":3,"file":"modules.d.ts","sourceRoot":"","sources":["../../../src/integrations/modules.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAmEjE,+CAA+C;AAC/C,qBAAa,OAAQ,YAAW,WAAW;IACzC;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAa;IAErC;;OAEG;IACI,IAAI,EAAE,MAAM,CAAc;IAEjC;;OAEG;IACI,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI;IAY7G,kGAAkG;IAClG,OAAO,CAAC,WAAW;CAMpB"}import { Integration } from '@sentry/types';
/** Global Promise Rejection handler */
export declare class OnUncaughtException implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    readonly handler: (error: Error) => void;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Default onFatalError handler
         * @param firstError Error that has been thrown
         * @param secondError If this was called multiple times this will be set
         */
        onFatalError?(firstError: Error, secondError?: Error): void;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * @hidden
     */
    private _makeErrorHandler;
}
//# sourceMappingURL=onuncaughtexception.d.ts.map{"version":3,"file":"onuncaughtexception.d.ts","sourceRoot":"","sources":["../../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAY,MAAM,eAAe,CAAC;AAStD,uCAAuC;AACvC,qBAAa,mBAAoB,YAAW,WAAW;IAoBnD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAnB3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAAyB;IAEjD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA0B;IAE7C;;OAEG;IACH,SAAgB,OAAO,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,IAAI,CAA4B;IAE3E;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;;WAIG;QACH,YAAY,CAAC,CAAC,UAAU,EAAE,KAAK,EAAE,WAAW,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;KACxD;IAER;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;OAEG;IACH,OAAO,CAAC,iBAAiB;CA+E1B"}import { Integration } from '@sentry/types';
declare type UnhandledRejectionMode = 'none' | 'warn' | 'strict';
/** Global Promise Rejection handler */
export declare class OnUnhandledRejection implements Integration {
    private readonly _options;
    /**
     * @inheritDoc
     */
    static id: string;
    /**
     * @inheritDoc
     */
    name: string;
    /**
     * @inheritDoc
     */
    constructor(_options?: {
        /**
         * Option deciding what to do after capturing unhandledRejection,
         * that mimicks behavior of node's --unhandled-rejection flag.
         */
        mode: UnhandledRejectionMode;
    });
    /**
     * @inheritDoc
     */
    setupOnce(): void;
    /**
     * Send an exception with reason
     * @param reason string
     * @param promise promise
     */
    sendUnhandledPromise(reason: any, promise: any): void;
    /**
     * Handler for `mode` option
     */
    private _handleRejection;
}
export {};
//# sourceMappingURL=onunhandledrejection.d.ts.map{"version":3,"file":"onunhandledrejection.d.ts","sourceRoot":"","sources":["../../../src/integrations/onunhandledrejection.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAK5C,aAAK,sBAAsB,GAAG,MAAM,GAAG,MAAM,GAAG,QAAQ,CAAC;AAEzD,uCAAuC;AACvC,qBAAa,oBAAqB,YAAW,WAAW;IAepD,OAAO,CAAC,QAAQ,CAAC,QAAQ;IAd3B;;OAEG;IACH,OAAc,EAAE,EAAE,MAAM,CAA0B;IAElD;;OAEG;IACI,IAAI,EAAE,MAAM,CAA2B;IAE9C;;OAEG;gBAEgB,QAAQ,GAAE;QACzB;;;WAGG;QACH,IAAI,EAAE,sBAAsB,CAAC;KACX;IAGtB;;OAEG;IACI,SAAS,IAAI,IAAI;IAIxB;;;;OAIG;IAEI,oBAAoB,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,GAAG,IAAI;IAmC5D;;OAEG;IAEH,OAAO,CAAC,gBAAgB;CAuBzB"}/**
 * @hidden
 */
export declare function logAndExitProcess(error: Error): void;
//# sourceMappingURL=errorhandling.d.ts.map{"version":3,"file":"errorhandling.d.ts","sourceRoot":"","sources":["../../../../src/integrations/utils/errorhandling.ts"],"names":[],"mappings":"AAQA;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAuBpD"}/// <reference types="node" />
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
/**
 * Checks whether given url points to Sentry server
 * @param url url to verify
 */
export declare function isSentryRequest(url: string): boolean;
/**
 * Assemble a URL to be used for breadcrumbs and spans.
 *
 * @param requestOptions RequestOptions object containing the component parts for a URL
 * @returns Fully-formed URL
 */
export declare function extractUrl(requestOptions: RequestOptions): string;
/**
 * Handle various edge cases in the span description (for spans representing http(s) requests).
 *
 * @param description current `description` property of the span representing the request
 * @param requestOptions Configuration data for the request
 * @param Request Request object
 *
 * @returns The cleaned description
 */
export declare function cleanSpanDescription(description: string | undefined, requestOptions: RequestOptions, request: http.ClientRequest): string | undefined;
export declare type RequestOptions = http.RequestOptions & {
    hash?: string;
    search?: string;
    pathname?: string;
    href?: string;
};
declare type RequestCallback = (response: http.IncomingMessage) => void;
export declare type RequestMethodArgs = [RequestOptions | string | URL, RequestCallback?] | [string | URL, RequestOptions, RequestCallback?];
export declare type RequestMethod = (...args: RequestMethodArgs) => http.ClientRequest;
/**
 * Convert a URL object into a RequestOptions object.
 *
 * Copied from Node's internals (where it's used in http(s).request() and http(s).get()), modified only to use the
 * RequestOptions type above.
 *
 * See https://github.com/nodejs/node/blob/master/lib/internal/url.js.
 */
export declare function urlToOptions(url: URL): RequestOptions;
/**
 * Normalize inputs to `http(s).request()` and `http(s).get()`.
 *
 * Legal inputs to `http(s).request()` and `http(s).get()` can take one of ten forms:
 *     [ RequestOptions | string | URL ],
 *     [ RequestOptions | string | URL, RequestCallback ],
 *     [ string | URL, RequestOptions ], and
 *     [ string | URL, RequestOptions, RequestCallback ].
 *
 * This standardizes to one of two forms: [ RequestOptions ] and [ RequestOptions, RequestCallback ]. A similar thing is
 * done as the first step of `http(s).request()` and `http(s).get()`; this just does it early so that we can interact
 * with the args in a standard way.
 *
 * @param requestArgs The inputs to `http(s).request()` or `http(s).get()`, as an array.
 *
 * @returns Equivalent args of the form [ RequestOptions ] or [ RequestOptions, RequestCallback ].
 */
export declare function normalizeRequestArgs(httpModule: typeof http | typeof https, requestArgs: RequestMethodArgs): [RequestOptions] | [RequestOptions, RequestCallback];
export {};
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../../src/integrations/utils/http.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAI1B;;;GAGG;AACH,wBAAgB,eAAe,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAGpD;AAED;;;;;GAKG;AACH,wBAAgB,UAAU,CAAC,cAAc,EAAE,cAAc,GAAG,MAAM,CASjE;AAED;;;;;;;;GAQG;AACH,wBAAgB,oBAAoB,CAClC,WAAW,EAAE,MAAM,GAAG,SAAS,EAC/B,cAAc,EAAE,cAAc,EAC9B,OAAO,EAAE,IAAI,CAAC,aAAa,GAC1B,MAAM,GAAG,SAAS,CAuBpB;AAGD,oBAAY,cAAc,GAAG,IAAI,CAAC,cAAc,GAAG;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,MAAM,CAAC,EAAE,MAAM,CAAC;IAAC,QAAQ,CAAC,EAAE,MAAM,CAAC;IAAC,IAAI,CAAC,EAAE,MAAM,CAAA;CAAE,CAAC;AACxH,aAAK,eAAe,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,eAAe,KAAK,IAAI,CAAC;AAChE,oBAAY,iBAAiB,GACzB,CAAC,cAAc,GAAG,MAAM,GAAG,GAAG,EAAE,eAAe,CAAC,CAAC,GACjD,CAAC,MAAM,GAAG,GAAG,EAAE,cAAc,EAAE,eAAe,CAAC,CAAC,CAAC;AACrD,oBAAY,aAAa,GAAG,CAAC,GAAG,IAAI,EAAE,iBAAiB,KAAK,IAAI,CAAC,aAAa,CAAC;AAE/E;;;;;;;GAOG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,GAAG,GAAG,cAAc,CAkBrD;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,wBAAgB,oBAAoB,CAClC,UAAU,EAAE,OAAO,IAAI,GAAG,OAAO,KAAK,EACtC,WAAW,EAAE,iBAAiB,GAC7B,CAAC,cAAc,CAAC,GAAG,CAAC,cAAc,EAAE,eAAe,CAAC,CAoDtD"}import { Integrations as CoreIntegrations } from '@sentry/core';
import { NodeClient } from './client';
import { Console, ContextLines, Http, LinkedErrors, OnUncaughtException, OnUnhandledRejection } from './integrations';
import { NodeOptions } from './types';
export declare const defaultIntegrations: (CoreIntegrations.FunctionToString | CoreIntegrations.InboundFilters | Console | Http | OnUncaughtException | OnUnhandledRejection | ContextLines | LinkedErrors)[];
/**
 * The Sentry Node SDK Client.
 *
 * To use this SDK, call the {@link init} function as early as possible in the
 * main entry module. To set context information or send manual events, use the
 * provided methods.
 *
 * @example
 * ```
 *
 * const { init } = require('@sentry/node');
 *
 * init({
 *   dsn: '__DSN__',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { configureScope } = require('@sentry/node');
 * configureScope((scope: Scope) => {
 *   scope.setExtra({ battery: 0.7 });
 *   scope.setTag({ user_mode: 'admin' });
 *   scope.setUser({ id: '4711' });
 * });
 * ```
 *
 * @example
 * ```
 *
 * const { addBreadcrumb } = require('@sentry/node');
 * addBreadcrumb({
 *   message: 'My Breadcrumb',
 *   // ...
 * });
 * ```
 *
 * @example
 * ```
 *
 * const Sentry = require('@sentry/node');
 * Sentry.captureMessage('Hello, world!');
 * Sentry.captureException(new Error('Good bye'));
 * Sentry.captureEvent({
 *   message: 'Manual',
 *   stacktrace: [
 *     // ...
 *   ],
 * });
 * ```
 *
 * @see {@link NodeOptions} for documentation on configuration options.
 */
export declare function init(options?: NodeOptions): void;
/**
 * This is the getter for lastEventId.
 *
 * @returns The last event id of a captured event.
 */
export declare function lastEventId(): string | undefined;
/**
 * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
 * the client to wait until all events are sent before resolving the promise.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export declare function flush(timeout?: number): Promise<boolean>;
/**
 * Call `close()` on the current client, if there is one. See {@link Client.close}.
 *
 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
 * parameter will cause the client to wait until all events are sent before disabling itself.
 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
 * doesn't (or if there's no client defined).
 */
export declare function close(timeout?: number): Promise<boolean>;
/**
 * Function that takes an instance of NodeClient and checks if autoSessionTracking option is enabled for that client
 */
export declare function isAutoSessionTrackingEnabled(client?: NodeClient): boolean;
/**
 * Returns a release dynamically from environment variables.
 */
export declare function getSentryRelease(fallback?: string): string | undefined;
//# sourceMappingURL=sdk.d.ts.map{"version":3,"file":"sdk.d.ts","sourceRoot":"","sources":["../../src/sdk.ts"],"names":[],"mappings":"AAAA,OAAO,EAA8B,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAM5F,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAEtC,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,IAAI,EAAE,YAAY,EAAE,mBAAmB,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AACtH,OAAO,EAAE,WAAW,EAAE,MAAM,SAAS,CAAC;AAEtC,eAAO,MAAM,mBAAmB,qKAa/B,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsDG;AACH,wBAAgB,IAAI,CAAC,OAAO,GAAE,WAAgB,GAAG,IAAI,CAmDpD;AAED;;;;GAIG;AACH,wBAAgB,WAAW,IAAI,MAAM,GAAG,SAAS,CAEhD;AAED;;;;;;;GAOG;AACH,wBAAsB,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAO9D;AAED;;;;;;;GAOG;AACH,wBAAsB,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAO9D;AAED;;GAEG;AACH,wBAAgB,4BAA4B,CAAC,MAAM,CAAC,EAAE,UAAU,GAAG,OAAO,CASzE;AAED;;GAEG;AACH,wBAAgB,gBAAgB,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CA4BtE"}import { StackLineParser } from '@sentry/utils';
export declare const nodeStackParser: StackLineParser;
//# sourceMappingURL=stack-parser.d.ts.map{"version":3,"file":"stack-parser.d.ts","sourceRoot":"","sources":["../../src/stack-parser.ts"],"names":[],"mappings":"AAAA,OAAO,EAAqB,eAAe,EAAqB,MAAM,eAAe,CAAC;AAmHtF,eAAO,MAAM,eAAe,EAAE,eAA4B,CAAC"}/// <reference types="node" />
import { IncomingHttpHeaders, RequestOptions as HTTPRequestOptions } from 'http';
import { RequestOptions as HTTPSRequestOptions } from 'https';
import { URL } from 'url';
export declare type HTTPModuleRequestOptions = HTTPRequestOptions | HTTPSRequestOptions | string | URL;
/**
 * Cut version of http.IncomingMessage.
 * Some transports work in a special Javascript environment where http.IncomingMessage is not available.
 */
export interface HTTPModuleRequestIncomingMessage {
    headers: IncomingHttpHeaders;
    statusCode?: number;
    on(event: 'data' | 'end', listener: () => void): void;
    setEncoding(encoding: string): void;
}
/**
 * Cut version of http.ClientRequest.
 * Some transports work in a special Javascript environment where http.IncomingMessage is not available.
 */
export interface HTTPModuleClientRequest {
    end(chunk: string): void;
    on(event: 'error', listener: () => void): void;
}
/**
 * Internal used interface for typescript.
 * @hidden
 */
export interface HTTPModule {
    /**
     * Request wrapper
     * @param options These are {@see TransportOptions}
     * @param callback Callback when request is finished
     */
    request(options: HTTPModuleRequestOptions, callback?: (res: HTTPModuleRequestIncomingMessage) => void): HTTPModuleClientRequest;
}
//# sourceMappingURL=http-module.d.ts.map{"version":3,"file":"http-module.d.ts","sourceRoot":"","sources":["../../../../src/transports/base/http-module.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,mBAAmB,EAAE,cAAc,IAAI,kBAAkB,EAAE,MAAM,MAAM,CAAC;AACjF,OAAO,EAAE,cAAc,IAAI,mBAAmB,EAAE,MAAM,OAAO,CAAC;AAC9D,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAE1B,oBAAY,wBAAwB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,MAAM,GAAG,GAAG,CAAC;AAE/F;;;GAGG;AACH,MAAM,WAAW,gCAAgC;IAC/C,OAAO,EAAE,mBAAmB,CAAC;IAC7B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,EAAE,CAAC,KAAK,EAAE,MAAM,GAAG,KAAK,EAAE,QAAQ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;IACtD,WAAW,CAAC,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;CACrC;AAED;;;GAGG;AACH,MAAM,WAAW,uBAAuB;IACtC,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC;CAChD;AAED;;;GAGG;AACH,MAAM,WAAW,UAAU;IACzB;;;;OAIG;IACH,OAAO,CACL,OAAO,EAAE,wBAAwB,EACjC,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE,gCAAgC,KAAK,IAAI,GACzD,uBAAuB,CAAC;CAW5B"}/// <reference types="node" />
import { APIDetails } from '@sentry/core';
import { DsnProtocol, Event, Response, SentryRequest, SentryRequestType, Session, SessionAggregates, Transport, TransportOptions } from '@sentry/types';
import { PromiseBuffer } from '@sentry/utils';
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
import { HTTPModule } from './http-module';
export declare type URLParts = Pick<URL, 'hostname' | 'pathname' | 'port' | 'protocol'>;
export declare type UrlParser = (url: string) => URLParts;
/** Base Transport class implementation */
export declare abstract class BaseTransport implements Transport {
    options: TransportOptions;
    /** The Agent used for corresponding transport */
    module?: HTTPModule;
    /** The Agent used for corresponding transport */
    client?: http.Agent | https.Agent;
    /** API object */
    protected _api: APIDetails;
    /** A simple buffer holding all requests. */
    protected readonly _buffer: PromiseBuffer<Response>;
    /** Locks transport after receiving rate limits in a response */
    protected readonly _rateLimits: Record<string, Date>;
    /** Create instance and set this.dsn */
    constructor(options: TransportOptions);
    /** Default function used to parse URLs */
    urlParser: UrlParser;
    /**
     * @inheritDoc
     */
    sendEvent(_: Event): PromiseLike<Response>;
    /**
     * @inheritDoc
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Extracts proxy settings from client options and env variables.
     *
     * Honors `no_proxy` env variable with the highest priority to allow for hosts exclusion.
     *
     * An order of priority for available protocols is:
     * `http`  => `options.httpProxy` | `process.env.http_proxy`
     * `https` => `options.httpsProxy` | `options.httpProxy` | `process.env.https_proxy` | `process.env.http_proxy`
     */
    protected _getProxy(protocol: DsnProtocol): string | undefined;
    /** Returns a build request option object used by request */
    protected _getRequestOptions(urlParts: URLParts): http.RequestOptions | https.RequestOptions;
    /**
     * Gets the time that given category is disabled until for rate limiting
     */
    protected _disabledUntil(requestType: SentryRequestType): Date;
    /**
     * Checks if a category is rate limited
     */
    protected _isRateLimited(requestType: SentryRequestType): boolean;
    /**
     * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.
     */
    protected _handleRateLimit(headers: Record<string, string | null>): boolean;
    /** JSDoc */
    protected _send(sentryRequest: SentryRequest, originalPayload?: Event | Session | SessionAggregates): Promise<Response>;
}
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/transports/base/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAkD,MAAM,cAAc,CAAC;AAC1F,OAAO,EACL,WAAW,EACX,KAAK,EACL,QAAQ,EACR,aAAa,EACb,iBAAiB,EACjB,OAAO,EACP,iBAAiB,EACjB,SAAS,EACT,gBAAgB,EACjB,MAAM,eAAe,CAAC;AACvB,OAAO,EAKL,aAAa,EAEd,MAAM,eAAe,CAAC;AAEvB,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAC;AAI1B,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAE3C,oBAAY,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,UAAU,GAAG,UAAU,GAAG,MAAM,GAAG,UAAU,CAAC,CAAC;AAChF,oBAAY,SAAS,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,QAAQ,CAAC;AAWlD,0CAA0C;AAC1C,8BAAsB,aAAc,YAAW,SAAS;IAiB5B,OAAO,EAAE,gBAAgB;IAhBnD,iDAAiD;IAC1C,MAAM,CAAC,EAAE,UAAU,CAAC;IAE3B,iDAAiD;IAC1C,MAAM,CAAC,EAAE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;IAEzC,iBAAiB;IACjB,SAAS,CAAC,IAAI,EAAE,UAAU,CAAC;IAE3B,4CAA4C;IAC5C,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAyB;IAE5E,gEAAgE;IAChE,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAM;IAE1D,uCAAuC;gBACb,OAAO,EAAE,gBAAgB;IAKnD,0CAA0C;IACnC,SAAS,EAAE,SAAS,CAAuB;IAElD;;OAEG;IACI,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC;IAIpD;;;;;;;;OAQG;IACH,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,WAAW,GAAG,MAAM,GAAG,SAAS;IAmB9D,4DAA4D;IAC5D,SAAS,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,GAAG,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,cAAc;IAwB5F;;OAEG;IACH,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,iBAAiB,GAAG,IAAI;IAK9D;;OAEG;IACH,SAAS,CAAC,cAAc,CAAC,WAAW,EAAE,iBAAiB,GAAG,OAAO;IAIjE;;OAEG;IACH,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC,GAAG,OAAO;IAsC3E,YAAY;cACI,KAAK,CACnB,aAAa,EAAE,aAAa,EAC5B,eAAe,CAAC,EAAE,KAAK,GAAG,OAAO,GAAG,iBAAiB,GACpD,OAAO,CAAC,QAAQ,CAAC;CA2ErB"}import { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';
import { BaseTransport } from './base';
/** Node http module transport */
export declare class HTTPTransport extends BaseTransport {
    options: TransportOptions;
    /** Create a new instance and set this.agent */
    constructor(options: TransportOptions);
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): Promise<Response>;
    /**
     * @inheritDoc
     */
    sendSession(session: Session | SessionAggregates): PromiseLike<Response>;
}
//# sourceMappingURL=http.d.ts.map{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/transports/http.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAG9F,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,iCAAiC;AACjC,qBAAa,aAAc,SAAQ,aAAa;IAEpB,OAAO,EAAE,gBAAgB;IADnD,+CAA+C;gBACrB,OAAO,EAAE,gBAAgB;IASnD;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC;CAGhF"}import { Event, Response, Session, SessionAggregates, TransportOptions } from '@sentry/types';
import { BaseTransport } from './base';
/** Node https module transport */
export declare class HTTPSTransport extends BaseTransport {
    options: TransportOptions;
    /** Create a new instance and set this.agent */
    constructor(options: TransportOptions);
    /**
     * @inheritDoc
     */
    sendEvent(event: Event): Promise<Response>;
    /**
     * @inheritDoc
     */
    sendSession(session: Session | SessionAggregates): PromiseLike<Response>;
}
//# sourceMappingURL=https.d.ts.map{"version":3,"file":"https.d.ts","sourceRoot":"","sources":["../../../src/transports/https.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAG9F,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAEvC,kCAAkC;AAClC,qBAAa,cAAe,SAAQ,aAAa;IAErB,OAAO,EAAE,gBAAgB;IADnD,+CAA+C;gBACrB,OAAO,EAAE,gBAAgB;IASnD;;OAEG;IACI,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,OAAO,CAAC,QAAQ,CAAC;IAIjD;;OAEG;IACI,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC;CAGhF"}export { BaseTransport } from './base';
export { HTTPTransport } from './http';
export { HTTPSTransport } from './https';
export { makeNodeTransport, NodeTransportOptions } from './new';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/transports/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AACvC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,MAAM,OAAO,CAAC"}/// <reference types="node" />
import { BaseTransportOptions, NewTransport } from '@sentry/core';
import { HTTPModule } from './base/http-module';
export interface NodeTransportOptions extends BaseTransportOptions {
    /** Define custom headers */
    headers?: Record<string, string>;
    /** Set a proxy that should be used for outbound requests. */
    proxy?: string;
    /** HTTPS proxy CA certificates */
    caCerts?: string | Buffer | Array<string | Buffer>;
    /** Custom HTTP module. Defaults to the native 'http' and 'https' modules. */
    httpModule?: HTTPModule;
}
/**
 * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.
 */
export declare function makeNodeTransport(options: NodeTransportOptions): NewTransport;
//# sourceMappingURL=new.d.ts.map{"version":3,"file":"new.d.ts","sourceRoot":"","sources":["../../../src/transports/new.ts"],"names":[],"mappings":";AAAA,OAAO,EACL,oBAAoB,EAEpB,YAAY,EAIb,MAAM,cAAc,CAAC;AAMtB,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAShD,MAAM,WAAW,oBAAqB,SAAQ,oBAAoB;IAChE,4BAA4B;IAC5B,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACjC,6DAA6D;IAC7D,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,kCAAkC;IAClC,OAAO,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACnD,6EAA6E;IAC7E,UAAU,CAAC,EAAE,UAAU,CAAC;CACzB;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,OAAO,EAAE,oBAAoB,GAAG,YAAY,CAqB7E"}import { Options } from '@sentry/types';
/**
 * Configuration options for the Sentry Node SDK.
 * @see NodeClient for more information.
 */
export interface NodeOptions extends Options {
    /** Sets an optional server name (device name) */
    serverName?: string;
    /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */
    shutdownTimeout?: number;
    /** Set a HTTP proxy that should be used for outbound requests. */
    httpProxy?: string;
    /** Set a HTTPS proxy that should be used for outbound requests. */
    httpsProxy?: string;
    /** HTTPS proxy certificates path */
    caCerts?: string;
    /**
     * Sets the number of context lines for each frame when loading a file.
     *
     * @deprecated Context lines configuration has moved to the `ContextLines` integration, and can be used like this:
     *
     * ```
     * init({
     *   dsn: '__DSN__',
     *   integrations: [new ContextLines({ frameContextLines: 10 })]
     * })
     * ```
     *
     * */
    frameContextLines?: number;
    /** Callback that is executed when a fatal global error occurs. */
    onFatalError?(error: Error): void;
}
//# sourceMappingURL=types.d.ts.map{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAExC;;;GAGG;AACH,MAAM,WAAW,WAAY,SAAQ,OAAO;IAC1C,iDAAiD;IACjD,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,8GAA8G;IAC9G,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB,kEAAkE;IAClE,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB,mEAAmE;IACnE,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,oCAAoC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;;;;;;;;;;SAYK;IACL,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B,kEAAkE;IAClE,YAAY,CAAC,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC;CACnC"}/**
 * Recursively read the contents of a directory.
 *
 * @param targetDir Absolute or relative path of the directory to scan. All returned paths will be relative to this
 * directory.
 * @returns Array holding all relative paths
 */
export declare function deepReadDirSync(targetDir: string): string[];
//# sourceMappingURL=utils.d.ts.map{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"AAGA;;;;;;GAMG;AACH,wBAAgB,eAAe,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,CA2B3D"}export declare const SDK_NAME = "sentry.javascript.node";
//# sourceMappingURL=version.d.ts.map{"version":3,"file":"version.d.ts","sourceRoot":"","sources":["../../src/version.ts"],"names":[],"mappings":"AACA,eAAO,MAAM,QAAQ,2BAA2B,CAAC"}import { Severity } from './severity';
/** JSDoc */
export interface Breadcrumb {
    type?: string;
    level?: Severity;
    event_id?: string;
    category?: string;
    message?: string;
    data?: {
        [key: string]: any;
    };
    timestamp?: number;
}
/** JSDoc */
export interface BreadcrumbHint {
    [key: string]: any;
}
//# sourceMappingURL=breadcrumb.d.ts.map{"version":3,"file":"breadcrumb.d.ts","sourceRoot":"","sources":["../../src/breadcrumb.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,QAAQ,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAC9B,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,YAAY;AACZ,MAAM,WAAW,cAAc;IAC7B,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=breadcrumb.js.map{"version":3,"file":"breadcrumb.js","sourceRoot":"","sources":["../../src/breadcrumb.ts"],"names":[],"mappings":"","sourcesContent":["import { Severity } from './severity';\n\n/** JSDoc */\nexport interface Breadcrumb {\n  type?: string;\n  level?: Severity;\n  event_id?: string;\n  category?: string;\n  message?: string;\n  data?: { [key: string]: any };\n  timestamp?: number;\n}\n\n/** JSDoc */\nexport interface BreadcrumbHint {\n  [key: string]: any;\n}\n"]}import { DsnComponents } from './dsn';
import { Event, EventHint } from './event';
import { Integration, IntegrationClass } from './integration';
import { Options } from './options';
import { Scope } from './scope';
import { Session } from './session';
import { Severity } from './severity';
import { Transport } from './transport';
/**
 * User-Facing Sentry SDK Client.
 *
 * This interface contains all methods to interface with the SDK once it has
 * been installed. It allows to send events to Sentry, record breadcrumbs and
 * set a context included in every event. Since the SDK mutates its environment,
 * there will only be one instance during runtime.
 *
 */
export interface Client<O extends Options = Options> {
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param level Define the level of the message.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /** Captures a session
     *
     * @param session Session to be delivered
     */
    captureSession?(session: Session): void;
    /** Returns the current Dsn. */
    getDsn(): DsnComponents | undefined;
    /** Returns the current options. */
    getOptions(): O;
    /** Returns clients transport. */
    getTransport?(): Transport;
    /**
     * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
     *
     * @param timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
     *   the client to wait until all events are sent before disabling itself.
     * @returns A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
     * it doesn't.
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Wait for all events to be sent or the timeout to expire, whichever comes first.
     *
     * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
     *   cause the client to wait until all events are sent before resolving the promise.
     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
     * still events in the queue when the timeout is reached.
     */
    flush(timeout?: number): PromiseLike<boolean>;
    /** Returns an array of installed integrations on the client. */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** This is an internal function to setup all integrations that should run on the client */
    setupIntegrations(): void;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,OAAO,CAAC;AACtC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAExC;;;;;;;;GAQG;AACH,MAAM,WAAW,MAAM,CAAC,CAAC,SAAS,OAAO,GAAG,OAAO;IACjD;;;;;;;OAOG;IACH,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEtF;;;;;;;;OAQG;IACH,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEvG;;;;;;;OAOG;IACH,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEhF;;;OAGG;IACH,cAAc,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC;IAExC,+BAA+B;IAC/B,MAAM,IAAI,aAAa,GAAG,SAAS,CAAC;IAEpC,mCAAmC;IACnC,UAAU,IAAI,CAAC,CAAC;IAEhB,iCAAiC;IACjC,YAAY,CAAC,IAAI,SAAS,CAAC;IAE3B;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C,gEAAgE;IAChE,cAAc,CAAC,CAAC,SAAS,WAAW,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;IAElF,2FAA2F;IAC3F,iBAAiB,IAAI,IAAI,CAAC;CAC3B"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"","sourcesContent":["import { DsnComponents } from './dsn';\nimport { Event, EventHint } from './event';\nimport { Integration, IntegrationClass } from './integration';\nimport { Options } from './options';\nimport { Scope } from './scope';\nimport { Session } from './session';\nimport { Severity } from './severity';\nimport { Transport } from './transport';\n\n/**\n * User-Facing Sentry SDK Client.\n *\n * This interface contains all methods to interface with the SDK once it has\n * been installed. It allows to send events to Sentry, record breadcrumbs and\n * set a context included in every event. Since the SDK mutates its environment,\n * there will only be one instance during runtime.\n *\n */\nexport interface Client<O extends Options = Options> {\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * @param exception An exception-like object.\n   * @param hint May contain additional information about the original exception.\n   * @param scope An optional scope containing event metadata.\n   * @returns The event id\n   */\n  captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * @param message The message to send to Sentry.\n   * @param level Define the level of the message.\n   * @param hint May contain additional information about the original exception.\n   * @param scope An optional scope containing event metadata.\n   * @returns The event id\n   */\n  captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope An optional scope containing event metadata.\n   * @returns The event id\n   */\n  captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;\n\n  /** Captures a session\n   *\n   * @param session Session to be delivered\n   */\n  captureSession?(session: Session): void;\n\n  /** Returns the current Dsn. */\n  getDsn(): DsnComponents | undefined;\n\n  /** Returns the current options. */\n  getOptions(): O;\n\n  /** Returns clients transport. */\n  getTransport?(): Transport;\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n  close(timeout?: number): PromiseLike<boolean>;\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  flush(timeout?: number): PromiseLike<boolean>;\n\n  /** Returns an array of installed integrations on the client. */\n  getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;\n\n  /** This is an internal function to setup all integrations that should run on the client */\n  setupIntegrations(): void;\n}\n"]}import { SentryRequestType } from './request';
import { Outcome } from './transport';
export declare type ClientReport = {
    timestamp: number;
    discarded_events: Array<{
        reason: Outcome;
        category: SentryRequestType;
        quantity: number;
    }>;
};
//# sourceMappingURL=clientreport.d.ts.map{"version":3,"file":"clientreport.d.ts","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AAEtC,oBAAY,YAAY,GAAG;IACzB,SAAS,EAAE,MAAM,CAAC;IAClB,gBAAgB,EAAE,KAAK,CAAC;QAAE,MAAM,EAAE,OAAO,CAAC;QAAC,QAAQ,EAAE,iBAAiB,CAAC;QAAC,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAC7F,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=clientreport.js.map{"version":3,"file":"clientreport.js","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"","sourcesContent":["import { SentryRequestType } from './request';\nimport { Outcome } from './transport';\n\nexport type ClientReport = {\n  timestamp: number;\n  discarded_events: Array<{ reason: Outcome; category: SentryRequestType; quantity: number }>;\n};\n"]}export declare type Context = Record<string, unknown>;
export declare type Contexts = Record<string, Context>;
//# sourceMappingURL=context.d.ts.map{"version":3,"file":"context.d.ts","sourceRoot":"","sources":["../../src/context.ts"],"names":[],"mappings":"AAAA,oBAAY,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC9C,oBAAY,QAAQ,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=context.js.map{"version":3,"file":"context.js","sourceRoot":"","sources":["../../src/context.ts"],"names":[],"mappings":"","sourcesContent":["export type Context = Record<string, unknown>;\nexport type Contexts = Record<string, Context>;\n"]}/**
 * Holds meta information to customize the behavior of Sentry's server-side event processing.
 **/
export interface DebugMeta {
    images?: Array<DebugImage>;
}
/**
 * Possible choices for debug images.
 */
export declare type DebugImageType = 'wasm' | 'macho' | 'elf' | 'pe';
/**
 * References to debug images.
 */
export interface DebugImage {
    type: DebugImageType;
    debug_id: string;
    code_id?: string | null;
    code_file: string;
    debug_file?: string | null;
}
//# sourceMappingURL=debugMeta.d.ts.map{"version":3,"file":"debugMeta.d.ts","sourceRoot":"","sources":["../../src/debugMeta.ts"],"names":[],"mappings":"AAAA;;IAEI;AACJ,MAAM,WAAW,SAAS;IACxB,MAAM,CAAC,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;CAC5B;AAED;;GAEG;AACH,oBAAY,cAAc,GAAG,MAAM,GAAG,OAAO,GAAG,KAAK,GAAG,IAAI,CAAC;AAE7D;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB,IAAI,EAAE,cAAc,CAAC;IACrB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACxB,SAAS,EAAE,MAAM,CAAC;IAClB,UAAU,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;CAC5B"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=debugMeta.js.map{"version":3,"file":"debugMeta.js","sourceRoot":"","sources":["../../src/debugMeta.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Holds meta information to customize the behavior of Sentry's server-side event processing.\n **/\nexport interface DebugMeta {\n  images?: Array<DebugImage>;\n}\n\n/**\n * Possible choices for debug images.\n */\nexport type DebugImageType = 'wasm' | 'macho' | 'elf' | 'pe';\n\n/**\n * References to debug images.\n */\nexport interface DebugImage {\n  type: DebugImageType;\n  debug_id: string;\n  code_id?: string | null;\n  code_file: string;\n  debug_file?: string | null;\n}\n"]}/** Supported Sentry transport protocols in a Dsn. */
export declare type DsnProtocol = 'http' | 'https';
/** Primitive components of a Dsn. */
export interface DsnComponents {
    /** Protocol used to connect to Sentry. */
    protocol: DsnProtocol;
    /** Public authorization key (deprecated, renamed to publicKey). */
    user?: string;
    /** Public authorization key. */
    publicKey?: string;
    /** Private authorization key (deprecated, optional). */
    pass?: string;
    /** Hostname of the Sentry instance. */
    host: string;
    /** Port of the Sentry instance. */
    port?: string;
    /** Sub path/ */
    path?: string;
    /** Project ID */
    projectId: string;
}
/** Anything that can be parsed into a Dsn. */
export declare type DsnLike = string | DsnComponents;
//# sourceMappingURL=dsn.d.ts.map{"version":3,"file":"dsn.d.ts","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"AAAA,qDAAqD;AACrD,oBAAY,WAAW,GAAG,MAAM,GAAG,OAAO,CAAC;AAE3C,qCAAqC;AACrC,MAAM,WAAW,aAAa;IAC5B,0CAA0C;IAC1C,QAAQ,EAAE,WAAW,CAAC;IACtB,mEAAmE;IACnE,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gCAAgC;IAChC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,wDAAwD;IACxD,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,uCAAuC;IACvC,IAAI,EAAE,MAAM,CAAC;IACb,mCAAmC;IACnC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gBAAgB;IAChB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,iBAAiB;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,8CAA8C;AAC9C,oBAAY,OAAO,GAAG,MAAM,GAAG,aAAa,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=dsn.js.map{"version":3,"file":"dsn.js","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"","sourcesContent":["/** Supported Sentry transport protocols in a Dsn. */\nexport type DsnProtocol = 'http' | 'https';\n\n/** Primitive components of a Dsn. */\nexport interface DsnComponents {\n  /** Protocol used to connect to Sentry. */\n  protocol: DsnProtocol;\n  /** Public authorization key (deprecated, renamed to publicKey). */\n  user?: string;\n  /** Public authorization key. */\n  publicKey?: string;\n  /** Private authorization key (deprecated, optional). */\n  pass?: string;\n  /** Hostname of the Sentry instance. */\n  host: string;\n  /** Port of the Sentry instance. */\n  port?: string;\n  /** Sub path/ */\n  path?: string;\n  /** Project ID */\n  projectId: string;\n}\n\n/** Anything that can be parsed into a Dsn. */\nexport type DsnLike = string | DsnComponents;\n"]}import { ClientReport } from './clientreport';
import { Event } from './event';
import { SdkInfo } from './sdkinfo';
import { Session, SessionAggregates } from './session';
import { TransactionSamplingMethod } from './transaction';
import { UserFeedback } from './user';
export declare type BaseEnvelopeHeaders = {
    [key: string]: unknown;
    dsn?: string;
    sdk?: SdkInfo;
};
export declare type BaseEnvelopeItemHeaders = {
    [key: string]: unknown;
    type: string;
    length?: number;
};
declare type BaseEnvelopeItem<IH extends BaseEnvelopeItemHeaders, P extends unknown> = [IH, P];
declare type BaseEnvelope<EH extends BaseEnvelopeHeaders, I extends BaseEnvelopeItem<BaseEnvelopeItemHeaders, unknown>> = [EH, I[]];
declare type EventItemHeaders = {
    type: 'event' | 'transaction';
    sample_rates?: [{
        id?: TransactionSamplingMethod;
        rate?: number;
    }];
};
declare type AttachmentItemHeaders = {
    type: 'attachment';
    filename: string;
};
declare type UserFeedbackItemHeaders = {
    type: 'user_report';
};
declare type SessionItemHeaders = {
    type: 'session';
};
declare type SessionAggregatesItemHeaders = {
    type: 'sessions';
};
declare type ClientReportItemHeaders = {
    type: 'client_report';
};
export declare type EventItem = BaseEnvelopeItem<EventItemHeaders, Event | string>;
export declare type AttachmentItem = BaseEnvelopeItem<AttachmentItemHeaders, unknown>;
export declare type UserFeedbackItem = BaseEnvelopeItem<UserFeedbackItemHeaders, UserFeedback>;
export declare type SessionItem = BaseEnvelopeItem<SessionItemHeaders, Session> | BaseEnvelopeItem<SessionAggregatesItemHeaders, SessionAggregates>;
export declare type ClientReportItem = BaseEnvelopeItem<ClientReportItemHeaders, ClientReport>;
declare type EventEnvelopeHeaders = {
    event_id: string;
    sent_at: string;
};
declare type SessionEnvelopeHeaders = {
    sent_at: string;
};
declare type ClientReportEnvelopeHeaders = BaseEnvelopeHeaders;
export declare type EventEnvelope = BaseEnvelope<EventEnvelopeHeaders, EventItem | AttachmentItem | UserFeedbackItem>;
export declare type SessionEnvelope = BaseEnvelope<SessionEnvelopeHeaders, SessionItem>;
export declare type ClientReportEnvelope = BaseEnvelope<ClientReportEnvelopeHeaders, ClientReportItem>;
export declare type Envelope = EventEnvelope | SessionEnvelope | ClientReportEnvelope;
export {};
//# sourceMappingURL=envelope.d.ts.map{"version":3,"file":"envelope.d.ts","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=envelope.js.map{"version":3,"file":"envelope.js","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"","sourcesContent":["import { ClientReport } from './clientreport';\nimport { Event } from './event';\nimport { SdkInfo } from './sdkinfo';\nimport { Session, SessionAggregates } from './session';\nimport { TransactionSamplingMethod } from './transaction';\nimport { UserFeedback } from './user';\n\n// Based on: https://develop.sentry.dev/sdk/envelopes/\n\nexport type BaseEnvelopeHeaders = {\n  [key: string]: unknown;\n  dsn?: string;\n  sdk?: SdkInfo;\n};\n\nexport type BaseEnvelopeItemHeaders = {\n  [key: string]: unknown;\n  type: string;\n  length?: number;\n};\n\ntype BaseEnvelopeItem<IH extends BaseEnvelopeItemHeaders, P extends unknown> = [IH, P]; // P is for payload\n\ntype BaseEnvelope<EH extends BaseEnvelopeHeaders, I extends BaseEnvelopeItem<BaseEnvelopeItemHeaders, unknown>> = [\n  EH,\n  I[],\n];\n\ntype EventItemHeaders = {\n  type: 'event' | 'transaction';\n  sample_rates?: [{ id?: TransactionSamplingMethod; rate?: number }];\n};\ntype AttachmentItemHeaders = { type: 'attachment'; filename: string };\ntype UserFeedbackItemHeaders = { type: 'user_report' };\ntype SessionItemHeaders = { type: 'session' };\ntype SessionAggregatesItemHeaders = { type: 'sessions' };\ntype ClientReportItemHeaders = { type: 'client_report' };\n\n// TODO(v7): Remove the string union from `Event | string`\n// We have to allow this hack for now as we pre-serialize events because we support\n// both store and envelope endpoints.\nexport type EventItem = BaseEnvelopeItem<EventItemHeaders, Event | string>;\nexport type AttachmentItem = BaseEnvelopeItem<AttachmentItemHeaders, unknown>;\nexport type UserFeedbackItem = BaseEnvelopeItem<UserFeedbackItemHeaders, UserFeedback>;\nexport type SessionItem =\n  | BaseEnvelopeItem<SessionItemHeaders, Session>\n  | BaseEnvelopeItem<SessionAggregatesItemHeaders, SessionAggregates>;\nexport type ClientReportItem = BaseEnvelopeItem<ClientReportItemHeaders, ClientReport>;\n\ntype EventEnvelopeHeaders = { event_id: string; sent_at: string };\ntype SessionEnvelopeHeaders = { sent_at: string };\ntype ClientReportEnvelopeHeaders = BaseEnvelopeHeaders;\n\nexport type EventEnvelope = BaseEnvelope<EventEnvelopeHeaders, EventItem | AttachmentItem | UserFeedbackItem>;\nexport type SessionEnvelope = BaseEnvelope<SessionEnvelopeHeaders, SessionItem>;\nexport type ClientReportEnvelope = BaseEnvelope<ClientReportEnvelopeHeaders, ClientReportItem>;\n\nexport type Envelope = EventEnvelope | SessionEnvelope | ClientReportEnvelope;\n"]}/**
 * Just an Error object with arbitrary attributes attached to it.
 */
export interface ExtendedError extends Error {
    [key: string]: any;
}
//# sourceMappingURL=error.d.ts.map{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,WAAW,aAAc,SAAQ,KAAK;IAC1C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=error.js.map{"version":3,"file":"error.js","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Just an Error object with arbitrary attributes attached to it.\n */\nexport interface ExtendedError extends Error {\n  [key: string]: any;\n}\n"]}import { Breadcrumb } from './breadcrumb';
import { Contexts } from './context';
import { DebugMeta } from './debugMeta';
import { Exception } from './exception';
import { Extras } from './extra';
import { Primitive } from './misc';
import { Request } from './request';
import { CaptureContext } from './scope';
import { SdkInfo } from './sdkinfo';
import { Severity } from './severity';
import { Span } from './span';
import { Stacktrace } from './stacktrace';
import { Measurements } from './transaction';
import { User } from './user';
/** JSDoc */
export interface Event {
    event_id?: string;
    message?: string;
    timestamp?: number;
    start_timestamp?: number;
    level?: Severity;
    platform?: string;
    logger?: string;
    server_name?: string;
    release?: string;
    dist?: string;
    environment?: string;
    sdk?: SdkInfo;
    request?: Request;
    transaction?: string;
    modules?: {
        [key: string]: string;
    };
    fingerprint?: string[];
    exception?: {
        values?: Exception[];
    };
    stacktrace?: Stacktrace;
    breadcrumbs?: Breadcrumb[];
    contexts?: Contexts;
    tags?: {
        [key: string]: Primitive;
    };
    extra?: Extras;
    user?: User;
    type?: EventType;
    spans?: Span[];
    measurements?: Measurements;
    debug_meta?: DebugMeta;
    sdkProcessingMetadata?: {
        [key: string]: any;
    };
}
/** JSDoc */
export declare type EventType = 'transaction';
/** JSDoc */
export interface EventHint {
    event_id?: string;
    captureContext?: CaptureContext;
    syntheticException?: Error | null;
    originalException?: Error | string | null;
    data?: any;
}
//# sourceMappingURL=event.d.ts.map{"version":3,"file":"event.d.ts","sourceRoot":"","sources":["../../src/event.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AACrC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACjC,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B,YAAY;AACZ,MAAM,WAAW,KAAK;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,KAAK,CAAC,EAAE,QAAQ,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,GAAG,CAAC,EAAE,OAAO,CAAC;IACd,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IACvB,SAAS,CAAC,EAAE;QACV,MAAM,CAAC,EAAE,SAAS,EAAE,CAAC;KACtB,CAAC;IACF,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,WAAW,CAAC,EAAE,UAAU,EAAE,CAAC;IAC3B,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IACpC,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,IAAI,CAAC,EAAE,IAAI,CAAC;IACZ,IAAI,CAAC,EAAE,SAAS,CAAC;IACjB,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC;IACf,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,UAAU,CAAC,EAAE,SAAS,CAAC;IAEvB,qBAAqB,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CAChD;AAED,YAAY;AACZ,oBAAY,SAAS,GAAG,aAAa,CAAC;AAEtC,YAAY;AACZ,MAAM,WAAW,SAAS;IACxB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,cAAc,CAAC,EAAE,cAAc,CAAC;IAChC,kBAAkB,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;IAClC,iBAAiB,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC;IAC1C,IAAI,CAAC,EAAE,GAAG,CAAC;CACZ"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=event.js.map{"version":3,"file":"event.js","sourceRoot":"","sources":["../../src/event.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb } from './breadcrumb';\nimport { Contexts } from './context';\nimport { DebugMeta } from './debugMeta';\nimport { Exception } from './exception';\nimport { Extras } from './extra';\nimport { Primitive } from './misc';\nimport { Request } from './request';\nimport { CaptureContext } from './scope';\nimport { SdkInfo } from './sdkinfo';\nimport { Severity } from './severity';\nimport { Span } from './span';\nimport { Stacktrace } from './stacktrace';\nimport { Measurements } from './transaction';\nimport { User } from './user';\n\n/** JSDoc */\nexport interface Event {\n  event_id?: string;\n  message?: string;\n  timestamp?: number;\n  start_timestamp?: number;\n  level?: Severity;\n  platform?: string;\n  logger?: string;\n  server_name?: string;\n  release?: string;\n  dist?: string;\n  environment?: string;\n  sdk?: SdkInfo;\n  request?: Request;\n  transaction?: string;\n  modules?: { [key: string]: string };\n  fingerprint?: string[];\n  exception?: {\n    values?: Exception[];\n  };\n  stacktrace?: Stacktrace;\n  breadcrumbs?: Breadcrumb[];\n  contexts?: Contexts;\n  tags?: { [key: string]: Primitive };\n  extra?: Extras;\n  user?: User;\n  type?: EventType;\n  spans?: Span[];\n  measurements?: Measurements;\n  debug_meta?: DebugMeta;\n  // A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get sent to Sentry\n  sdkProcessingMetadata?: { [key: string]: any };\n}\n\n/** JSDoc */\nexport type EventType = 'transaction';\n\n/** JSDoc */\nexport interface EventHint {\n  event_id?: string;\n  captureContext?: CaptureContext;\n  syntheticException?: Error | null;\n  originalException?: Error | string | null;\n  data?: any;\n}\n"]}import { Event, EventHint } from './event';
/**
 * Event processors are used to change the event before it will be send.
 * We strongly advise to make this function sync.
 * Returning a PromiseLike<Event | null> will work just fine, but better be sure that you know what you are doing.
 * Event processing will be deferred until your Promise is resolved.
 */
export declare type EventProcessor = (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;
//# sourceMappingURL=eventprocessor.d.ts.map{"version":3,"file":"eventprocessor.d.ts","sourceRoot":"","sources":["../../src/eventprocessor.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAE3C;;;;;GAKG;AACH,oBAAY,cAAc,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,KAAK,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=eventprocessor.js.map{"version":3,"file":"eventprocessor.js","sourceRoot":"","sources":["../../src/eventprocessor.ts"],"names":[],"mappings":"","sourcesContent":["import { Event, EventHint } from './event';\n\n/**\n * Event processors are used to change the event before it will be send.\n * We strongly advise to make this function sync.\n * Returning a PromiseLike<Event | null> will work just fine, but better be sure that you know what you are doing.\n * Event processing will be deferred until your Promise is resolved.\n */\nexport type EventProcessor = (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;\n"]}export declare type EventStatus = 
/** The status could not be determined. */
'unknown'
/** The event was skipped due to configuration or callbacks. */
 | 'skipped'
/** The event was sent to Sentry successfully. */
 | 'rate_limit'
/** The client is currently rate limited and will try again later. */
 | 'invalid'
/** The event could not be processed. */
 | 'failed'
/** A server-side error occurred during submission. */
 | 'success';
//# sourceMappingURL=eventstatus.d.ts.map{"version":3,"file":"eventstatus.d.ts","sourceRoot":"","sources":["../../src/eventstatus.ts"],"names":[],"mappings":"AAAA,oBAAY,WAAW;AACrB,0CAA0C;AACxC,SAAS;AACX,+DAA+D;GAC7D,SAAS;AACX,iDAAiD;GAC/C,YAAY;AACd,qEAAqE;GACnE,SAAS;AACX,wCAAwC;GACtC,QAAQ;AACV,sDAAsD;GACpD,SAAS,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=eventstatus.js.map{"version":3,"file":"eventstatus.js","sourceRoot":"","sources":["../../src/eventstatus.ts"],"names":[],"mappings":"","sourcesContent":["export type EventStatus =\n  /** The status could not be determined. */\n  | 'unknown'\n  /** The event was skipped due to configuration or callbacks. */\n  | 'skipped'\n  /** The event was sent to Sentry successfully. */\n  | 'rate_limit'\n  /** The client is currently rate limited and will try again later. */\n  | 'invalid'\n  /** The event could not be processed. */\n  | 'failed'\n  /** A server-side error occurred during submission. */\n  | 'success';\n"]}import { Mechanism } from './mechanism';
import { Stacktrace } from './stacktrace';
/** JSDoc */
export interface Exception {
    type?: string;
    value?: string;
    mechanism?: Mechanism;
    module?: string;
    thread_id?: number;
    stacktrace?: Stacktrace;
}
//# sourceMappingURL=exception.d.ts.map{"version":3,"file":"exception.d.ts","sourceRoot":"","sources":["../../src/exception.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,SAAS;IACxB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,SAAS,CAAC,EAAE,SAAS,CAAC;IACtB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,UAAU,CAAC,EAAE,UAAU,CAAC;CACzB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=exception.js.map{"version":3,"file":"exception.js","sourceRoot":"","sources":["../../src/exception.ts"],"names":[],"mappings":"","sourcesContent":["import { Mechanism } from './mechanism';\nimport { Stacktrace } from './stacktrace';\n\n/** JSDoc */\nexport interface Exception {\n  type?: string;\n  value?: string;\n  mechanism?: Mechanism;\n  module?: string;\n  thread_id?: number;\n  stacktrace?: Stacktrace;\n}\n"]}export declare type Extra = unknown;
export declare type Extras = Record<string, Extra>;
//# sourceMappingURL=extra.d.ts.map{"version":3,"file":"extra.d.ts","sourceRoot":"","sources":["../../src/extra.ts"],"names":[],"mappings":"AAAA,oBAAY,KAAK,GAAG,OAAO,CAAC;AAC5B,oBAAY,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=extra.js.map{"version":3,"file":"extra.js","sourceRoot":"","sources":["../../src/extra.ts"],"names":[],"mappings":"","sourcesContent":["export type Extra = unknown;\nexport type Extras = Record<string, Extra>;\n"]}import { Breadcrumb, BreadcrumbHint } from './breadcrumb';
import { Client } from './client';
import { Event, EventHint } from './event';
import { Extra, Extras } from './extra';
import { Integration, IntegrationClass } from './integration';
import { Primitive } from './misc';
import { Scope } from './scope';
import { Session, SessionContext } from './session';
import { Severity } from './severity';
import { Span, SpanContext } from './span';
import { CustomSamplingContext, Transaction, TransactionContext } from './transaction';
import { User } from './user';
/**
 * Internal class used to make sure we always have the latest internal functions
 * working in case we have a version conflict.
 */
export interface Hub {
    /**
     * Checks if this hub's version is older than the given version.
     *
     * @param version A version number to compare to.
     * @return True if the given version is newer; otherwise false.
     *
     * @hidden
     */
    isOlderThan(version: number): boolean;
    /**
     * This binds the given client to the current scope.
     * @param client An SDK client (client) instance.
     */
    bindClient(client?: Client): void;
    /**
     * Create a new scope to store context information.
     *
     * The scope will be layered on top of the current one. It is isolated, i.e. all
     * breadcrumbs and context information added to this scope will be removed once
     * the scope ends. Be sure to always remove this scope with {@link this.popScope}
     * when the operation finishes or throws.
     *
     * @returns Scope, the new cloned scope
     */
    pushScope(): Scope;
    /**
     * Removes a previously pushed scope from the stack.
     *
     * This restores the state before the scope was pushed. All breadcrumbs and
     * context information added since the last call to {@link this.pushScope} are
     * discarded.
     */
    popScope(): boolean;
    /**
     * Creates a new scope with and executes the given operation within.
     * The scope is automatically removed once the operation
     * finishes or throws.
     *
     * This is essentially a convenience function for:
     *
     *     pushScope();
     *     callback();
     *     popScope();
     *
     * @param callback that will be enclosed into push/popScope.
     */
    withScope(callback: (scope: Scope) => void): void;
    /** Returns the client of the top stack. */
    getClient(): Client | undefined;
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @param hint May contain additional information about the original exception.
     * @returns The generated eventId.
     */
    captureException(exception: any, hint?: EventHint): string;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param level Define the level of the message.
     * @param hint May contain additional information about the original exception.
     * @returns The generated eventId.
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint): string;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     */
    captureEvent(event: Event, hint?: EventHint): string;
    /**
     * This is the getter for lastEventId.
     *
     * @returns The last event id of a captured event.
     */
    lastEventId(): string | undefined;
    /**
     * Records a new breadcrumb which will be attached to future events.
     *
     * Breadcrumbs will be added to subsequent events to provide more context on
     * user's actions prior to an error or crash.
     *
     * @param breadcrumb The breadcrumb to record.
     * @param hint May contain additional information about the original breadcrumb.
     */
    addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    setUser(user: User | null): void;
    /**
     * Set an object that will be merged sent as tags data with the event.
     *
     * @param tags Tags context object to merge into current context.
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): void;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    setTag(key: string, value: Primitive): void;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    setExtra(key: string, extra: Extra): void;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    setExtras(extras: Extras): void;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context Any kind of data. This data will be normalized.
     */
    setContext(name: string, context: {
        [key: string]: any;
    } | null): void;
    /**
     * Callback to set context information onto the scope.
     *
     * @param callback Callback function that receives Scope.
     */
    configureScope(callback: (scope: Scope) => void): void;
    /**
     * For the duration of the callback, this hub will be set as the global current Hub.
     * This function is useful if you want to run your own client and hook into an already initialized one
     * e.g.: Reporting issues to your own sentry when running in your component while still using the users configuration.
     */
    run(callback: (hub: Hub) => void): void;
    /** Returns the integration if installed on the current client. */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** Returns all trace headers that are currently on the top scope. */
    traceHeaders(): {
        [key: string]: string;
    };
    /**
     * @deprecated No longer does anything. Use use {@link Transaction.startChild} instead.
     */
    startSpan(context: SpanContext): Span;
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     */
    startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
    /**
     * Starts a new `Session`, sets on the current scope and returns it.
     *
     * To finish a `session`, it has to be passed directly to `client.captureSession`, which is done automatically
     * when using `hub.endSession()` for the session currently stored on the scope.
     *
     * When there's already an existing session on the scope, it'll be automatically ended.
     *
     * @param context Optional properties of the new `Session`.
     *
     * @returns The session which was just started
     */
    startSession(context?: SessionContext): Session;
    /**
     * Ends the session that lives on the current scope and sends it to Sentry
     */
    endSession(): void;
    /**
     * Sends the current session on the scope to Sentry
     * @param endSession If set the session will be marked as exited and removed from the scope
     */
    captureSession(endSession?: boolean): void;
}
//# sourceMappingURL=hub.d.ts.map{"version":3,"file":"hub.d.ts","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=hub.js.map{"version":3,"file":"hub.js","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb, BreadcrumbHint } from './breadcrumb';\nimport { Client } from './client';\nimport { Event, EventHint } from './event';\nimport { Extra, Extras } from './extra';\nimport { Integration, IntegrationClass } from './integration';\nimport { Primitive } from './misc';\nimport { Scope } from './scope';\nimport { Session, SessionContext } from './session';\nimport { Severity } from './severity';\nimport { Span, SpanContext } from './span';\nimport { CustomSamplingContext, Transaction, TransactionContext } from './transaction';\nimport { User } from './user';\n\n/**\n * Internal class used to make sure we always have the latest internal functions\n * working in case we have a version conflict.\n */\nexport interface Hub {\n  /**\n   * Checks if this hub's version is older than the given version.\n   *\n   * @param version A version number to compare to.\n   * @return True if the given version is newer; otherwise false.\n   *\n   * @hidden\n   */\n  isOlderThan(version: number): boolean;\n\n  /**\n   * This binds the given client to the current scope.\n   * @param client An SDK client (client) instance.\n   */\n  bindClient(client?: Client): void;\n\n  /**\n   * Create a new scope to store context information.\n   *\n   * The scope will be layered on top of the current one. It is isolated, i.e. all\n   * breadcrumbs and context information added to this scope will be removed once\n   * the scope ends. Be sure to always remove this scope with {@link this.popScope}\n   * when the operation finishes or throws.\n   *\n   * @returns Scope, the new cloned scope\n   */\n  pushScope(): Scope;\n\n  /**\n   * Removes a previously pushed scope from the stack.\n   *\n   * This restores the state before the scope was pushed. All breadcrumbs and\n   * context information added since the last call to {@link this.pushScope} are\n   * discarded.\n   */\n  popScope(): boolean;\n\n  /**\n   * Creates a new scope with and executes the given operation within.\n   * The scope is automatically removed once the operation\n   * finishes or throws.\n   *\n   * This is essentially a convenience function for:\n   *\n   *     pushScope();\n   *     callback();\n   *     popScope();\n   *\n   * @param callback that will be enclosed into push/popScope.\n   */\n  withScope(callback: (scope: Scope) => void): void;\n\n  /** Returns the client of the top stack. */\n  getClient(): Client | undefined;\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * @param exception An exception-like object.\n   * @param hint May contain additional information about the original exception.\n   * @returns The generated eventId.\n   */\n  captureException(exception: any, hint?: EventHint): string;\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * @param message The message to send to Sentry.\n   * @param level Define the level of the message.\n   * @param hint May contain additional information about the original exception.\n   * @returns The generated eventId.\n   */\n  captureMessage(message: string, level?: Severity, hint?: EventHint): string;\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   */\n  captureEvent(event: Event, hint?: EventHint): string;\n\n  /**\n   * This is the getter for lastEventId.\n   *\n   * @returns The last event id of a captured event.\n   */\n  lastEventId(): string | undefined;\n\n  /**\n   * Records a new breadcrumb which will be attached to future events.\n   *\n   * Breadcrumbs will be added to subsequent events to provide more context on\n   * user's actions prior to an error or crash.\n   *\n   * @param breadcrumb The breadcrumb to record.\n   * @param hint May contain additional information about the original breadcrumb.\n   */\n  addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;\n\n  /**\n   * Updates user context information for future events.\n   *\n   * @param user User context object to be set in the current context. Pass `null` to unset the user.\n   */\n  setUser(user: User | null): void;\n\n  /**\n   * Set an object that will be merged sent as tags data with the event.\n   *\n   * @param tags Tags context object to merge into current context.\n   */\n  setTags(tags: { [key: string]: Primitive }): void;\n\n  /**\n   * Set key:value that will be sent as tags data with the event.\n   *\n   * Can also be used to unset a tag, by passing `undefined`.\n   *\n   * @param key String key of tag\n   * @param value Value of tag\n   */\n  setTag(key: string, value: Primitive): void;\n\n  /**\n   * Set key:value that will be sent as extra data with the event.\n   * @param key String of extra\n   * @param extra Any kind of data. This data will be normalized.\n   */\n  setExtra(key: string, extra: Extra): void;\n\n  /**\n   * Set an object that will be merged sent as extra data with the event.\n   * @param extras Extras object to merge into current context.\n   */\n  setExtras(extras: Extras): void;\n\n  /**\n   * Sets context data with the given name.\n   * @param name of the context\n   * @param context Any kind of data. This data will be normalized.\n   */\n  setContext(name: string, context: { [key: string]: any } | null): void;\n\n  /**\n   * Callback to set context information onto the scope.\n   *\n   * @param callback Callback function that receives Scope.\n   */\n  configureScope(callback: (scope: Scope) => void): void;\n\n  /**\n   * For the duration of the callback, this hub will be set as the global current Hub.\n   * This function is useful if you want to run your own client and hook into an already initialized one\n   * e.g.: Reporting issues to your own sentry when running in your component while still using the users configuration.\n   */\n  run(callback: (hub: Hub) => void): void;\n\n  /** Returns the integration if installed on the current client. */\n  getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;\n\n  /** Returns all trace headers that are currently on the top scope. */\n  traceHeaders(): { [key: string]: string };\n\n  /**\n   * @deprecated No longer does anything. Use use {@link Transaction.startChild} instead.\n   */\n  startSpan(context: SpanContext): Span;\n\n  /**\n   * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n   *\n   * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n   * new child span within the transaction or any span, call the respective `.startChild()` method.\n   *\n   * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n   *\n   * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n   * finished child spans will be sent to Sentry.\n   *\n   * @param context Properties of the new `Transaction`.\n   * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n   * default values). See {@link Options.tracesSampler}.\n   *\n   * @returns The transaction which was just started\n   */\n  startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;\n\n  /**\n   * Starts a new `Session`, sets on the current scope and returns it.\n   *\n   * To finish a `session`, it has to be passed directly to `client.captureSession`, which is done automatically\n   * when using `hub.endSession()` for the session currently stored on the scope.\n   *\n   * When there's already an existing session on the scope, it'll be automatically ended.\n   *\n   * @param context Optional properties of the new `Session`.\n   *\n   * @returns The session which was just started\n   */\n  startSession(context?: SessionContext): Session;\n\n  /**\n   * Ends the session that lives on the current scope and sends it to Sentry\n   */\n  endSession(): void;\n\n  /**\n   * Sends the current session on the scope to Sentry\n   * @param endSession If set the session will be marked as exited and removed from the scope\n   */\n  captureSession(endSession?: boolean): void;\n}\n"]}export { Breadcrumb, BreadcrumbHint } from './breadcrumb';
export { Client } from './client';
export { ClientReport } from './clientreport';
export { Context, Contexts } from './context';
export { DsnComponents, DsnLike, DsnProtocol } from './dsn';
export { DebugImage, DebugImageType, DebugMeta } from './debugMeta';
export { AttachmentItem, BaseEnvelopeHeaders, BaseEnvelopeItemHeaders, ClientReportEnvelope, ClientReportItem, Envelope, EventEnvelope, EventItem, SessionEnvelope, SessionItem, UserFeedbackItem, } from './envelope';
export { ExtendedError } from './error';
export { Event, EventHint } from './event';
export { EventStatus } from './eventstatus';
export { EventProcessor } from './eventprocessor';
export { Exception } from './exception';
export { Extra, Extras } from './extra';
export { Hub } from './hub';
export { Integration, IntegrationClass } from './integration';
export { Mechanism } from './mechanism';
export { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';
export { Options } from './options';
export { Package } from './package';
export { QueryParams, Request, SentryRequest, SentryRequestType } from './request';
export { Response } from './response';
export { Runtime } from './runtime';
export { CaptureContext, Scope, ScopeContext } from './scope';
export { SdkInfo } from './sdkinfo';
export { SdkMetadata } from './sdkmetadata';
export { SessionAggregates, AggregationCounts, Session, SessionContext, SessionStatus, RequestSession, RequestSessionStatus, SessionFlusherLike, } from './session';
export { Severity } from './severity';
export { SeverityLevel, SeverityLevels } from './severity';
export { Span, SpanContext } from './span';
export { StackFrame } from './stackframe';
export { Stacktrace } from './stacktrace';
export { CustomSamplingContext, Measurements, SamplingContext, TraceparentData, Transaction, TransactionContext, TransactionMetadata, TransactionSamplingMethod, } from './transaction';
export { Thread } from './thread';
export { Outcome, Transport, TransportOptions, TransportClass } from './transport';
export { User, UserFeedback } from './user';
export { WrappedFunction } from './wrappedfunction';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AAC5D,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACpE,OAAO,EACL,cAAc,EACd,mBAAmB,EACnB,uBAAuB,EACvB,oBAAoB,EACpB,gBAAgB,EAChB,QAAQ,EACR,aAAa,EACb,SAAS,EACT,eAAe,EACf,WAAW,EACX,gBAAgB,GACjB,MAAM,YAAY,CAAC;AACpB,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAC5B,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,wBAAwB,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAC7E,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AACnF,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,KAAK,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EACL,iBAAiB,EACjB,iBAAiB,EACjB,OAAO,EACP,cAAc,EACd,aAAa,EACb,cAAc,EACd,oBAAoB,EACpB,kBAAkB,GACnB,MAAM,WAAW,CAAC;AAEnB,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,aAAa,EAAE,cAAc,EAAE,MAAM,YAAY,CAAC;AAC3D,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAC3C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EACL,qBAAqB,EACrB,YAAY,EACZ,eAAe,EACf,eAAe,EACf,WAAW,EACX,kBAAkB,EAClB,mBAAmB,EACnB,yBAAyB,GAC1B,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,gBAAgB,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AACnF,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var severity_1 = require("./severity");
exports.Severity = severity_1.Severity;
var severity_2 = require("./severity");
exports.SeverityLevels = severity_2.SeverityLevels;
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAgDA,uCAAsC;AAA7B,8BAAA,QAAQ,CAAA;AACjB,uCAA2D;AAAnC,oCAAA,cAAc,CAAA","sourcesContent":["export { Breadcrumb, BreadcrumbHint } from './breadcrumb';\nexport { Client } from './client';\nexport { ClientReport } from './clientreport';\nexport { Context, Contexts } from './context';\nexport { DsnComponents, DsnLike, DsnProtocol } from './dsn';\nexport { DebugImage, DebugImageType, DebugMeta } from './debugMeta';\nexport {\n  AttachmentItem,\n  BaseEnvelopeHeaders,\n  BaseEnvelopeItemHeaders,\n  ClientReportEnvelope,\n  ClientReportItem,\n  Envelope,\n  EventEnvelope,\n  EventItem,\n  SessionEnvelope,\n  SessionItem,\n  UserFeedbackItem,\n} from './envelope';\nexport { ExtendedError } from './error';\nexport { Event, EventHint } from './event';\nexport { EventStatus } from './eventstatus';\nexport { EventProcessor } from './eventprocessor';\nexport { Exception } from './exception';\nexport { Extra, Extras } from './extra';\nexport { Hub } from './hub';\nexport { Integration, IntegrationClass } from './integration';\nexport { Mechanism } from './mechanism';\nexport { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';\nexport { Options } from './options';\nexport { Package } from './package';\nexport { QueryParams, Request, SentryRequest, SentryRequestType } from './request';\nexport { Response } from './response';\nexport { Runtime } from './runtime';\nexport { CaptureContext, Scope, ScopeContext } from './scope';\nexport { SdkInfo } from './sdkinfo';\nexport { SdkMetadata } from './sdkmetadata';\nexport {\n  SessionAggregates,\n  AggregationCounts,\n  Session,\n  SessionContext,\n  SessionStatus,\n  RequestSession,\n  RequestSessionStatus,\n  SessionFlusherLike,\n} from './session';\n\nexport { Severity } from './severity';\nexport { SeverityLevel, SeverityLevels } from './severity';\nexport { Span, SpanContext } from './span';\nexport { StackFrame } from './stackframe';\nexport { Stacktrace } from './stacktrace';\nexport {\n  CustomSamplingContext,\n  Measurements,\n  SamplingContext,\n  TraceparentData,\n  Transaction,\n  TransactionContext,\n  TransactionMetadata,\n  TransactionSamplingMethod,\n} from './transaction';\nexport { Thread } from './thread';\nexport { Outcome, Transport, TransportOptions, TransportClass } from './transport';\nexport { User, UserFeedback } from './user';\nexport { WrappedFunction } from './wrappedfunction';\n"]}import { EventProcessor } from './eventprocessor';
import { Hub } from './hub';
/** Integration Class Interface */
export interface IntegrationClass<T> {
    /**
     * Property that holds the integration name
     */
    id: string;
    new (...args: any[]): T;
}
/** Integration interface */
export interface Integration {
    /**
     * Returns {@link IntegrationClass.id}
     */
    name: string;
    /**
     * Sets the integration up only once.
     * This takes no options on purpose, options should be passed in the constructor
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
}
//# sourceMappingURL=integration.d.ts.map{"version":3,"file":"integration.d.ts","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAE5B,kCAAkC;AAClC,MAAM,WAAW,gBAAgB,CAAC,CAAC;IACjC;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX,KAAK,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;CACzB;AAED,4BAA4B;AAC5B,MAAM,WAAW,WAAW;IAC1B;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;OAGG;IACH,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI,CAAC;CACxG"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=integration.js.map{"version":3,"file":"integration.js","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"","sourcesContent":["import { EventProcessor } from './eventprocessor';\nimport { Hub } from './hub';\n\n/** Integration Class Interface */\nexport interface IntegrationClass<T> {\n  /**\n   * Property that holds the integration name\n   */\n  id: string;\n\n  new (...args: any[]): T;\n}\n\n/** Integration interface */\nexport interface Integration {\n  /**\n   * Returns {@link IntegrationClass.id}\n   */\n  name: string;\n\n  /**\n   * Sets the integration up only once.\n   * This takes no options on purpose, options should be passed in the constructor\n   */\n  setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;\n}\n"]}/**
 * Metadata about a captured exception, intended to provide a hint as to the means by which it was captured.
 */
export interface Mechanism {
    /**
     * For now, restricted to `onerror`, `onunhandledrejection` (both obvious), `instrument` (the result of
     * auto-instrumentation), and `generic` (everything else). Converted to a tag on ingest.
     */
    type: string;
    /**
     * In theory, whether or not the exception has been handled by the user. In practice, whether or not we see it before
     * it hits the global error/rejection handlers, whether through explicit handling by the user or auto instrumentation.
     * Converted to a tag on ingest and used in various ways in the UI.
     */
    handled: boolean;
    /**
     * Arbitrary data to be associated with the mechanism (for example, errors coming from event handlers include the
     * handler name and the event target. Will show up in the UI directly above the stacktrace.
     */
    data?: {
        [key: string]: string | boolean;
    };
    /**
     * True when `captureException` is called with anything other than an instance of `Error` (or, in the case of browser,
     * an instance of `ErrorEvent`, `DOMError`, or `DOMException`). causing us to create a synthetic error in an attempt
     * to recreate the stacktrace.
     */
    synthetic?: boolean;
}
//# sourceMappingURL=mechanism.d.ts.map{"version":3,"file":"mechanism.d.ts","sourceRoot":"","sources":["../../src/mechanism.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,WAAW,SAAS;IACxB;;;OAGG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;;OAIG;IACH,OAAO,EAAE,OAAO,CAAC;IAEjB;;;OAGG;IACH,IAAI,CAAC,EAAE;QACL,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;KACjC,CAAC;IAEF;;;;OAIG;IACH,SAAS,CAAC,EAAE,OAAO,CAAC;CACrB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=mechanism.js.map{"version":3,"file":"mechanism.js","sourceRoot":"","sources":["../../src/mechanism.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Metadata about a captured exception, intended to provide a hint as to the means by which it was captured.\n */\nexport interface Mechanism {\n  /**\n   * For now, restricted to `onerror`, `onunhandledrejection` (both obvious), `instrument` (the result of\n   * auto-instrumentation), and `generic` (everything else). Converted to a tag on ingest.\n   */\n  type: string;\n\n  /**\n   * In theory, whether or not the exception has been handled by the user. In practice, whether or not we see it before\n   * it hits the global error/rejection handlers, whether through explicit handling by the user or auto instrumentation.\n   * Converted to a tag on ingest and used in various ways in the UI.\n   */\n  handled: boolean;\n\n  /**\n   * Arbitrary data to be associated with the mechanism (for example, errors coming from event handlers include the\n   * handler name and the event target. Will show up in the UI directly above the stacktrace.\n   */\n  data?: {\n    [key: string]: string | boolean;\n  };\n\n  /**\n   * True when `captureException` is called with anything other than an instance of `Error` (or, in the case of browser,\n   * an instance of `ErrorEvent`, `DOMError`, or `DOMException`). causing us to create a synthetic error in an attempt\n   * to recreate the stacktrace.\n   */\n  synthetic?: boolean;\n}\n"]}import { QueryParams } from './request';
/**
 * Data extracted from an incoming request to a node server
 */
export interface ExtractedNodeRequestData {
    [key: string]: any;
    /** Specific headers from the request */
    headers?: {
        [key: string]: string;
    };
    /**  The request's method */
    method?: string;
    /** The request's URL, including query string */
    url?: string;
    /** String representing the cookies sent along with the request */
    cookies?: {
        [key: string]: string;
    };
    /** The request's query params */
    query_string?: QueryParams;
    /** Any data sent in the request's body, as a JSON string */
    data?: string;
}
/**
 * Location object on a service worker's `self` object.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WorkerLocation.
 */
export interface WorkerLocation {
    /** The protocol scheme of the URL of the script executed in the Worker, including the final ':'. */
    readonly protocol: string;
    /** The host, that is the hostname, a ':', and the port of the URL of the script executed in the Worker. */
    readonly host: string;
    /** The domain of the URL of the script executed in the Worker. */
    readonly hostname: string;
    /** The canonical form of the origin of the specific location. */
    readonly origin: string;
    /** The port number of the URL of the script executed in the Worker. */
    readonly port: string;
    /** The path of the URL of the script executed in the Worker, beginning with a '/'. */
    readonly pathname: string;
    /** The parameters (query string) of the URL of the script executed in the Worker, beginning with a '?'. */
    readonly search: string;
    /** The fragment identifier of the URL of the script executed in the Worker, beginning with a '#'. */
    readonly hash: string;
    /** Stringifier that returns the whole URL of the script executed in the Worker. */
    readonly href: string;
    /** Synonym for `href` attribute */
    toString(): string;
}
export declare type Primitive = number | string | boolean | bigint | symbol | null | undefined;
//# sourceMappingURL=misc.d.ts.map{"version":3,"file":"misc.d.ts","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC;;GAEG;AACH,MAAM,WAAW,wBAAwB;IACvC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IAEnB,wCAAwC;IACxC,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAEpC,4BAA4B;IAC5B,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB,gDAAgD;IAChD,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb,kEAAkE;IAClE,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAEpC,iCAAiC;IACjC,YAAY,CAAC,EAAE,WAAW,CAAC;IAE3B,4DAA4D;IAC5D,IAAI,CAAC,EAAE,MAAM,CAAC;CACf;AAED;;;;GAIG;AACH,MAAM,WAAW,cAAc;IAC7B,oGAAoG;IACpG,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,2GAA2G;IAC3G,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,kEAAkE;IAClE,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,iEAAiE;IACjE,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAExB,uEAAuE;IACvE,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,sFAAsF;IACtF,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,2GAA2G;IAC3G,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAExB,qGAAqG;IACrG,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,mFAAmF;IACnF,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,mCAAmC;IACnC,QAAQ,IAAI,MAAM,CAAC;CACpB;AAED,oBAAY,SAAS,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=misc.js.map{"version":3,"file":"misc.js","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"","sourcesContent":["import { QueryParams } from './request';\n\n/**\n * Data extracted from an incoming request to a node server\n */\nexport interface ExtractedNodeRequestData {\n  [key: string]: any;\n\n  /** Specific headers from the request */\n  headers?: { [key: string]: string };\n\n  /**  The request's method */\n  method?: string;\n\n  /** The request's URL, including query string */\n  url?: string;\n\n  /** String representing the cookies sent along with the request */\n  cookies?: { [key: string]: string };\n\n  /** The request's query params */\n  query_string?: QueryParams;\n\n  /** Any data sent in the request's body, as a JSON string */\n  data?: string;\n}\n\n/**\n * Location object on a service worker's `self` object.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/WorkerLocation.\n */\nexport interface WorkerLocation {\n  /** The protocol scheme of the URL of the script executed in the Worker, including the final ':'. */\n  readonly protocol: string;\n\n  /** The host, that is the hostname, a ':', and the port of the URL of the script executed in the Worker. */\n  readonly host: string;\n\n  /** The domain of the URL of the script executed in the Worker. */\n  readonly hostname: string;\n\n  /** The canonical form of the origin of the specific location. */\n  readonly origin: string;\n\n  /** The port number of the URL of the script executed in the Worker. */\n  readonly port: string;\n\n  /** The path of the URL of the script executed in the Worker, beginning with a '/'. */\n  readonly pathname: string;\n\n  /** The parameters (query string) of the URL of the script executed in the Worker, beginning with a '?'. */\n  readonly search: string;\n\n  /** The fragment identifier of the URL of the script executed in the Worker, beginning with a '#'. */\n  readonly hash: string;\n\n  /** Stringifier that returns the whole URL of the script executed in the Worker. */\n  readonly href: string;\n\n  /** Synonym for `href` attribute */\n  toString(): string;\n}\n\nexport type Primitive = number | string | boolean | bigint | symbol | null | undefined;\n"]}import { Breadcrumb, BreadcrumbHint } from './breadcrumb';
import { Event, EventHint } from './event';
import { Integration } from './integration';
import { CaptureContext } from './scope';
import { SdkMetadata } from './sdkmetadata';
import { SamplingContext } from './transaction';
import { Transport, TransportClass, TransportOptions } from './transport';
/** Base configuration options for every SDK. */
export interface Options {
    /**
     * Enable debug functionality in the SDK itself
     */
    debug?: boolean;
    /**
     * Specifies whether this SDK should send events to Sentry.
     * Defaults to true.
     */
    enabled?: boolean;
    /**
     * The Dsn used to connect to Sentry and identify the project. If omitted, the
     * SDK will not send any data to Sentry.
     */
    dsn?: string;
    /**
     * If this is set to false, default integrations will not be added, otherwise this will internally be set to the
     * recommended default integrations.
     * TODO: We should consider changing this to `boolean | Integration[]`
     */
    defaultIntegrations?: false | Integration[];
    /**
     * List of integrations that should be installed after SDK was initialized.
     * Accepts either a list of integrations or a function that receives
     * default integrations and returns a new, updated list.
     */
    integrations?: Integration[] | ((integrations: Integration[]) => Integration[]);
    /**
     * A pattern for error messages which should not be sent to Sentry.
     * By default, all errors will be sent.
     */
    ignoreErrors?: Array<string | RegExp>;
    /**
     * Transport object that should be used to send events to Sentry
     */
    transport?: TransportClass<Transport>;
    /**
     * Options for the default transport that the SDK uses.
     */
    transportOptions?: TransportOptions;
    /**
     * A URL to an envelope tunnel endpoint. An envelope tunnel is an HTTP endpoint
     * that accepts Sentry envelopes for forwarding. This can be used to force data
     * through a custom server independent of the type of data.
     */
    tunnel?: string;
    /**
     * The release identifier used when uploading respective source maps. Specify
     * this value to allow Sentry to resolve the correct source maps when
     * processing events.
     */
    release?: string;
    /** The current environment of your application (e.g. "production"). */
    environment?: string;
    /** Sets the distribution for all events */
    dist?: string;
    /**
     * The maximum number of breadcrumbs sent with events. Defaults to 100.
     * Values over 100 will be ignored and 100 used instead.
     */
    maxBreadcrumbs?: number;
    /** A global sample rate to apply to all events (0 - 1). */
    sampleRate?: number;
    /** Attaches stacktraces to pure capture message / log integrations */
    attachStacktrace?: boolean;
    /** Maximum number of chars a single value can have before it will be truncated. */
    maxValueLength?: number;
    /**
     * Maximum number of levels that normalization algorithm will traverse in objects and arrays.
     * Used when normalizing an event before sending, on all of the listed attributes:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * Defaults to `3`. Set to `0` to disable.
     */
    normalizeDepth?: number;
    /**
     * Maximum number of properties or elements that the normalization algorithm will output in any single array or object included in the normalized event.
     * Used when normalizing an event before sending, on all of the listed attributes:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * Defaults to `1000`
     */
    normalizeMaxBreadth?: number;
    /**
     * Controls how many milliseconds to wait before shutting down. The default is
     * SDK-specific but typically around 2 seconds. Setting this too low can cause
     * problems for sending events from command line applications. Setting it too
     * high can cause the application to block for users with network connectivity
     * problems.
     */
    shutdownTimeout?: number;
    /**
     * Sample rate to determine trace sampling.
     *
     * 0.0 = 0% chance of a given trace being sent (send no traces) 1.0 = 100% chance of a given trace being sent (send
     * all traces)
     *
     * Tracing is enabled if either this or `tracesSampler` is defined. If both are defined, `tracesSampleRate` is
     * ignored.
     */
    tracesSampleRate?: number;
    /**
     * A flag enabling Sessions Tracking feature.
     * By default, Sessions Tracking is enabled.
     */
    autoSessionTracking?: boolean;
    /**
     * Send SDK Client Reports.
     * By default, Client Reports are enabled.
     */
    sendClientReports?: boolean;
    /**
     * Initial data to populate scope.
     */
    initialScope?: CaptureContext;
    /**
     * Set of metadata about the SDK that can be internally used to enhance envelopes and events,
     * and provide additional data about every request.
     * */
    _metadata?: SdkMetadata;
    /**
     * Options which are in beta, or otherwise not guaranteed to be stable.
     */
    _experiments?: {
        [key: string]: any;
    };
    /**
     * Function to compute tracing sample rate dynamically and filter unwanted traces.
     *
     * Tracing is enabled if either this or `tracesSampleRate` is defined. If both are defined, `tracesSampleRate` is
     * ignored.
     *
     * Will automatically be passed a context object of default and optional custom data. See
     * {@link Transaction.samplingContext} and {@link Hub.startTransaction}.
     *
     * @returns A sample rate between 0 and 1 (0 drops the trace, 1 guarantees it will be sent). Returning `true` is
     * equivalent to returning 1 and returning `false` is equivalent to returning 0.
     */
    tracesSampler?: (samplingContext: SamplingContext) => number | boolean;
    /**
     * A callback invoked during event submission, allowing to optionally modify
     * the event before it is sent to Sentry.
     *
     * Note that you must return a valid event from this callback. If you do not
     * wish to modify the event, simply return it at the end.
     * Returning null will cause the event to be dropped.
     *
     * @param event The error or message event generated by the SDK.
     * @param hint May contain additional information about the original exception.
     * @returns A new event that will be sent | null.
     */
    beforeSend?: (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;
    /**
     * A callback invoked when adding a breadcrumb, allowing to optionally modify
     * it before adding it to future events.
     *
     * Note that you must return a valid breadcrumb from this callback. If you do
     * not wish to modify the breadcrumb, simply return it at the end.
     * Returning null will cause the breadcrumb to be dropped.
     *
     * @param breadcrumb The breadcrumb as created by the SDK.
     * @returns The breadcrumb that will be added | null.
     */
    beforeBreadcrumb?: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => Breadcrumb | null;
}
//# sourceMappingURL=options.d.ts.map{"version":3,"file":"options.d.ts","sourceRoot":"","sources":["../../src/options.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAChD,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAE1E,gDAAgD;AAChD,MAAM,WAAW,OAAO;IACtB;;OAEG;IACH,KAAK,CAAC,EAAE,OAAO,CAAC;IAEhB;;;OAGG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;;OAGG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;;;OAIG;IACH,mBAAmB,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,CAAC;IAE5C;;;;OAIG;IACH,YAAY,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC,YAAY,EAAE,WAAW,EAAE,KAAK,WAAW,EAAE,CAAC,CAAC;IAEhF;;;OAGG;IACH,YAAY,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IAEtC;;OAEG;IACH,SAAS,CAAC,EAAE,cAAc,CAAC,SAAS,CAAC,CAAC;IAEtC;;OAEG;IACH,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;IAEpC;;;;OAIG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;;;OAIG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB,uEAAuE;IACvE,WAAW,CAAC,EAAE,MAAM,CAAC;IAErB,2CAA2C;IAC3C,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;;OAGG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB,2DAA2D;IAC3D,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,sEAAsE;IACtE,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAE3B,mFAAmF;IACnF,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;;;;;;;OAQG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;;;;;;;OAQG;IACH,mBAAmB,CAAC,EAAE,MAAM,CAAC;IAE7B;;;;;;OAMG;IACH,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB;;;;;;;;OAQG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;;OAGG;IACH,mBAAmB,CAAC,EAAE,OAAO,CAAC;IAE9B;;;OAGG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAE5B;;OAEG;IACH,YAAY,CAAC,EAAE,cAAc,CAAC;IAE9B;;;SAGK;IACL,SAAS,CAAC,EAAE,WAAW,CAAC;IAExB;;OAEG;IACH,YAAY,CAAC,EAAE;QACb,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;KACpB,CAAC;IAEF;;;;;;;;;;;OAWG;IACH,aAAa,CAAC,EAAE,CAAC,eAAe,EAAE,eAAe,KAAK,MAAM,GAAG,OAAO,CAAC;IAEvE;;;;;;;;;;;OAWG;IACH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,KAAK,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC;IAE1F;;;;;;;;;;OAUG;IACH,gBAAgB,CAAC,EAAE,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,EAAE,cAAc,KAAK,UAAU,GAAG,IAAI,CAAC;CACzF"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=options.js.map{"version":3,"file":"options.js","sourceRoot":"","sources":["../../src/options.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb, BreadcrumbHint } from './breadcrumb';\nimport { Event, EventHint } from './event';\nimport { Integration } from './integration';\nimport { CaptureContext } from './scope';\nimport { SdkMetadata } from './sdkmetadata';\nimport { SamplingContext } from './transaction';\nimport { Transport, TransportClass, TransportOptions } from './transport';\n\n/** Base configuration options for every SDK. */\nexport interface Options {\n  /**\n   * Enable debug functionality in the SDK itself\n   */\n  debug?: boolean;\n\n  /**\n   * Specifies whether this SDK should send events to Sentry.\n   * Defaults to true.\n   */\n  enabled?: boolean;\n\n  /**\n   * The Dsn used to connect to Sentry and identify the project. If omitted, the\n   * SDK will not send any data to Sentry.\n   */\n  dsn?: string;\n\n  /**\n   * If this is set to false, default integrations will not be added, otherwise this will internally be set to the\n   * recommended default integrations.\n   * TODO: We should consider changing this to `boolean | Integration[]`\n   */\n  defaultIntegrations?: false | Integration[];\n\n  /**\n   * List of integrations that should be installed after SDK was initialized.\n   * Accepts either a list of integrations or a function that receives\n   * default integrations and returns a new, updated list.\n   */\n  integrations?: Integration[] | ((integrations: Integration[]) => Integration[]);\n\n  /**\n   * A pattern for error messages which should not be sent to Sentry.\n   * By default, all errors will be sent.\n   */\n  ignoreErrors?: Array<string | RegExp>;\n\n  /**\n   * Transport object that should be used to send events to Sentry\n   */\n  transport?: TransportClass<Transport>;\n\n  /**\n   * Options for the default transport that the SDK uses.\n   */\n  transportOptions?: TransportOptions;\n\n  /**\n   * A URL to an envelope tunnel endpoint. An envelope tunnel is an HTTP endpoint\n   * that accepts Sentry envelopes for forwarding. This can be used to force data\n   * through a custom server independent of the type of data.\n   */\n  tunnel?: string;\n\n  /**\n   * The release identifier used when uploading respective source maps. Specify\n   * this value to allow Sentry to resolve the correct source maps when\n   * processing events.\n   */\n  release?: string;\n\n  /** The current environment of your application (e.g. \"production\"). */\n  environment?: string;\n\n  /** Sets the distribution for all events */\n  dist?: string;\n\n  /**\n   * The maximum number of breadcrumbs sent with events. Defaults to 100.\n   * Values over 100 will be ignored and 100 used instead.\n   */\n  maxBreadcrumbs?: number;\n\n  /** A global sample rate to apply to all events (0 - 1). */\n  sampleRate?: number;\n\n  /** Attaches stacktraces to pure capture message / log integrations */\n  attachStacktrace?: boolean;\n\n  /** Maximum number of chars a single value can have before it will be truncated. */\n  maxValueLength?: number;\n\n  /**\n   * Maximum number of levels that normalization algorithm will traverse in objects and arrays.\n   * Used when normalizing an event before sending, on all of the listed attributes:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * Defaults to `3`. Set to `0` to disable.\n   */\n  normalizeDepth?: number;\n\n  /**\n   * Maximum number of properties or elements that the normalization algorithm will output in any single array or object included in the normalized event.\n   * Used when normalizing an event before sending, on all of the listed attributes:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * Defaults to `1000`\n   */\n  normalizeMaxBreadth?: number;\n\n  /**\n   * Controls how many milliseconds to wait before shutting down. The default is\n   * SDK-specific but typically around 2 seconds. Setting this too low can cause\n   * problems for sending events from command line applications. Setting it too\n   * high can cause the application to block for users with network connectivity\n   * problems.\n   */\n  shutdownTimeout?: number;\n\n  /**\n   * Sample rate to determine trace sampling.\n   *\n   * 0.0 = 0% chance of a given trace being sent (send no traces) 1.0 = 100% chance of a given trace being sent (send\n   * all traces)\n   *\n   * Tracing is enabled if either this or `tracesSampler` is defined. If both are defined, `tracesSampleRate` is\n   * ignored.\n   */\n  tracesSampleRate?: number;\n\n  /**\n   * A flag enabling Sessions Tracking feature.\n   * By default, Sessions Tracking is enabled.\n   */\n  autoSessionTracking?: boolean;\n\n  /**\n   * Send SDK Client Reports.\n   * By default, Client Reports are enabled.\n   */\n  sendClientReports?: boolean;\n\n  /**\n   * Initial data to populate scope.\n   */\n  initialScope?: CaptureContext;\n\n  /**\n   * Set of metadata about the SDK that can be internally used to enhance envelopes and events,\n   * and provide additional data about every request.\n   * */\n  _metadata?: SdkMetadata;\n\n  /**\n   * Options which are in beta, or otherwise not guaranteed to be stable.\n   */\n  _experiments?: {\n    [key: string]: any;\n  };\n\n  /**\n   * Function to compute tracing sample rate dynamically and filter unwanted traces.\n   *\n   * Tracing is enabled if either this or `tracesSampleRate` is defined. If both are defined, `tracesSampleRate` is\n   * ignored.\n   *\n   * Will automatically be passed a context object of default and optional custom data. See\n   * {@link Transaction.samplingContext} and {@link Hub.startTransaction}.\n   *\n   * @returns A sample rate between 0 and 1 (0 drops the trace, 1 guarantees it will be sent). Returning `true` is\n   * equivalent to returning 1 and returning `false` is equivalent to returning 0.\n   */\n  tracesSampler?: (samplingContext: SamplingContext) => number | boolean;\n\n  /**\n   * A callback invoked during event submission, allowing to optionally modify\n   * the event before it is sent to Sentry.\n   *\n   * Note that you must return a valid event from this callback. If you do not\n   * wish to modify the event, simply return it at the end.\n   * Returning null will cause the event to be dropped.\n   *\n   * @param event The error or message event generated by the SDK.\n   * @param hint May contain additional information about the original exception.\n   * @returns A new event that will be sent | null.\n   */\n  beforeSend?: (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;\n\n  /**\n   * A callback invoked when adding a breadcrumb, allowing to optionally modify\n   * it before adding it to future events.\n   *\n   * Note that you must return a valid breadcrumb from this callback. If you do\n   * not wish to modify the breadcrumb, simply return it at the end.\n   * Returning null will cause the breadcrumb to be dropped.\n   *\n   * @param breadcrumb The breadcrumb as created by the SDK.\n   * @returns The breadcrumb that will be added | null.\n   */\n  beforeBreadcrumb?: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => Breadcrumb | null;\n}\n"]}/** JSDoc */
export interface Package {
    name: string;
    version: string;
}
//# sourceMappingURL=package.d.ts.map{"version":3,"file":"package.d.ts","sourceRoot":"","sources":["../../src/package.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,OAAO;IACtB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;CACjB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=package.js.map{"version":3,"file":"package.js","sourceRoot":"","sources":["../../src/package.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface Package {\n  name: string;\n  version: string;\n}\n"]}/** Possible SentryRequest types that can be used to make a distinction between Sentry features */
export declare type SentryRequestType = 'event' | 'transaction' | 'session' | 'attachment';
/** A generic client request. */
export interface SentryRequest {
    body: string;
    type: SentryRequestType;
    url: string;
}
/** Request data included in an event as sent to Sentry */
export interface Request {
    url?: string;
    method?: string;
    data?: any;
    query_string?: QueryParams;
    cookies?: {
        [key: string]: string;
    };
    env?: {
        [key: string]: string;
    };
    headers?: {
        [key: string]: string;
    };
}
export declare type QueryParams = string | {
    [key: string]: string;
} | Array<[string, string]>;
//# sourceMappingURL=request.d.ts.map{"version":3,"file":"request.d.ts","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"AAAA,kGAAkG;AAElG,oBAAY,iBAAiB,GAAG,OAAO,GAAG,aAAa,GAAG,SAAS,GAAG,YAAY,CAAC;AAEnF,gCAAgC;AAChC,MAAM,WAAW,aAAa;IAC5B,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,iBAAiB,CAAC;IACxB,GAAG,EAAE,MAAM,CAAC;CACb;AAED,0DAA0D;AAC1D,MAAM,WAAW,OAAO;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,GAAG,CAAC;IACX,YAAY,CAAC,EAAE,WAAW,CAAC;IAC3B,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,GAAG,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAChC,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;CACrC;AAED,oBAAY,WAAW,GAAG,MAAM,GAAG;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;CAAE,GAAG,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=request.js.map{"version":3,"file":"request.js","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"","sourcesContent":["/** Possible SentryRequest types that can be used to make a distinction between Sentry features */\n// NOTE(kamil): It would be nice if we make it a valid enum instead\nexport type SentryRequestType = 'event' | 'transaction' | 'session' | 'attachment';\n\n/** A generic client request. */\nexport interface SentryRequest {\n  body: string;\n  type: SentryRequestType;\n  url: string;\n}\n\n/** Request data included in an event as sent to Sentry */\nexport interface Request {\n  url?: string;\n  method?: string;\n  data?: any;\n  query_string?: QueryParams;\n  cookies?: { [key: string]: string };\n  env?: { [key: string]: string };\n  headers?: { [key: string]: string };\n}\n\nexport type QueryParams = string | { [key: string]: string } | Array<[string, string]>;\n"]}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type
 */
export declare enum RequestSessionStatus {
    /** JSDoc */
    Ok = "ok",
    /** JSDoc */
    Errored = "errored",
    /** JSDoc */
    Crashed = "crashed"
}
//# sourceMappingURL=requestsessionstatus.d.ts.map{"version":3,"file":"requestsessionstatus.d.ts","sourceRoot":"","sources":["../../src/requestsessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,oBAAoB;IAC9B,YAAY;IACZ,EAAE,OAAO;IACT,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,OAAO,YAAY;CACpB"}Object.defineProperty(exports, "__esModule", { value: true });
/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type
 */
var RequestSessionStatus;
(function (RequestSessionStatus) {
    /** JSDoc */
    RequestSessionStatus["Ok"] = "ok";
    /** JSDoc */
    RequestSessionStatus["Errored"] = "errored";
    /** JSDoc */
    RequestSessionStatus["Crashed"] = "crashed";
})(RequestSessionStatus = exports.RequestSessionStatus || (exports.RequestSessionStatus = {}));
//# sourceMappingURL=requestsessionstatus.js.map{"version":3,"file":"requestsessionstatus.js","sourceRoot":"","sources":["../../src/requestsessionstatus.ts"],"names":[],"mappings":";AAAA;;GAEG;AACH,IAAY,oBAOX;AAPD,WAAY,oBAAoB;IAC9B,YAAY;IACZ,iCAAS,CAAA;IACT,YAAY;IACZ,2CAAmB,CAAA;IACnB,YAAY;IACZ,2CAAmB,CAAA;AACrB,CAAC,EAPW,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAO/B","sourcesContent":["/** JSDoc\n * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type\n */\nexport enum RequestSessionStatus {\n  /** JSDoc */\n  Ok = 'ok',\n  /** JSDoc */\n  Errored = 'errored',\n  /** JSDoc */\n  Crashed = 'crashed',\n}\n"]}import { Event, EventType } from './event';
import { EventStatus } from './eventstatus';
import { Session } from './session';
/** JSDoc */
export interface Response {
    status: EventStatus;
    event?: Event | Session;
    type?: EventType;
    reason?: string;
}
//# sourceMappingURL=response.d.ts.map{"version":3,"file":"response.d.ts","sourceRoot":"","sources":["../../src/response.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,YAAY;AACZ,MAAM,WAAW,QAAQ;IACvB,MAAM,EAAE,WAAW,CAAC;IACpB,KAAK,CAAC,EAAE,KAAK,GAAG,OAAO,CAAC;IACxB,IAAI,CAAC,EAAE,SAAS,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=response.js.map{"version":3,"file":"response.js","sourceRoot":"","sources":["../../src/response.ts"],"names":[],"mappings":"","sourcesContent":["import { Event, EventType } from './event';\nimport { EventStatus } from './eventstatus';\nimport { Session } from './session';\n\n/** JSDoc */\nexport interface Response {\n  status: EventStatus;\n  event?: Event | Session;\n  type?: EventType;\n  reason?: string;\n}\n"]}/** Runtime Context. */
export interface Runtime {
    name?: string;
    version?: string;
}
//# sourceMappingURL=runtime.d.ts.map{"version":3,"file":"runtime.d.ts","sourceRoot":"","sources":["../../src/runtime.ts"],"names":[],"mappings":"AAAA,uBAAuB;AACvB,MAAM,WAAW,OAAO;IACtB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=runtime.js.map{"version":3,"file":"runtime.js","sourceRoot":"","sources":["../../src/runtime.ts"],"names":[],"mappings":"","sourcesContent":["/** Runtime Context. */\nexport interface Runtime {\n  name?: string;\n  version?: string;\n}\n"]}import { Breadcrumb } from './breadcrumb';
import { Context, Contexts } from './context';
import { EventProcessor } from './eventprocessor';
import { Extra, Extras } from './extra';
import { Primitive } from './misc';
import { RequestSession, Session } from './session';
import { Severity } from './severity';
import { Span } from './span';
import { Transaction } from './transaction';
import { User } from './user';
/** JSDocs */
export declare type CaptureContext = Scope | Partial<ScopeContext> | ((scope: Scope) => Scope);
/** JSDocs */
export interface ScopeContext {
    user: User;
    level: Severity;
    extra: Extras;
    contexts: Contexts;
    tags: {
        [key: string]: Primitive;
    };
    fingerprint: string[];
    requestSession: RequestSession;
}
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be called by the client before an event is sent.
 */
export interface Scope {
    /** Add new event processor that will be called after {@link applyToEvent}. */
    addEventProcessor(callback: EventProcessor): this;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    setUser(user: User | null): this;
    /**
     * Returns the `User` if there is one
     */
    getUser(): User | undefined;
    /**
     * Set an object that will be merged sent as tags data with the event.
     * @param tags Tags context object to merge into current context.
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): this;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    setExtras(extras: Extras): this;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    setExtra(key: string, extra: Extra): this;
    /**
     * Sets the fingerprint on the scope to send with the events.
     * @param fingerprint string[] to group events in Sentry.
     */
    setFingerprint(fingerprint: string[]): this;
    /**
     * Sets the level on the scope for future events.
     * @param level string {@link Severity}
     */
    setLevel(level: Severity): this;
    /**
     * Sets the transaction name on the scope for future events.
     */
    setTransactionName(name?: string): this;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context an object containing context data. This data will be normalized. Pass `null` to unset the context.
     */
    setContext(name: string, context: Context | null): this;
    /**
     * Sets the Span on the scope.
     * @param span Span
     */
    setSpan(span?: Span): this;
    /**
     * Returns the `Span` if there is one
     */
    getSpan(): Span | undefined;
    /**
     * Returns the `Transaction` attached to the scope (if there is one)
     */
    getTransaction(): Transaction | undefined;
    /**
     * Returns the `Session` if there is one
     */
    getSession(): Session | undefined;
    /**
     * Sets the `Session` on the scope
     */
    setSession(session?: Session): this;
    /**
     * Returns the `RequestSession` if there is one
     */
    getRequestSession(): RequestSession | undefined;
    /**
     * Sets the `RequestSession` on the scope
     */
    setRequestSession(requestSession?: RequestSession): this;
    /**
     * Updates the scope with provided data. Can work in three variations:
     * - plain object containing updatable attributes
     * - Scope instance that'll extract the attributes from
     * - callback function that'll receive the current scope as an argument and allow for modifications
     * @param captureContext scope modifier to be used
     */
    update(captureContext?: CaptureContext): this;
    /** Clears the current scope and resets its properties. */
    clear(): this;
    /**
     * Sets the breadcrumbs in the scope
     * @param breadcrumbs Breadcrumb
     * @param maxBreadcrumbs number of max breadcrumbs to merged into event.
     */
    addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;
    /**
     * Clears all currently set Breadcrumbs.
     */
    clearBreadcrumbs(): this;
}
//# sourceMappingURL=scope.d.ts.map{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=scope.js.map{"version":3,"file":"scope.js","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb } from './breadcrumb';\nimport { Context, Contexts } from './context';\nimport { EventProcessor } from './eventprocessor';\nimport { Extra, Extras } from './extra';\nimport { Primitive } from './misc';\nimport { RequestSession, Session } from './session';\nimport { Severity } from './severity';\nimport { Span } from './span';\nimport { Transaction } from './transaction';\nimport { User } from './user';\n\n/** JSDocs */\nexport type CaptureContext = Scope | Partial<ScopeContext> | ((scope: Scope) => Scope);\n\n/** JSDocs */\nexport interface ScopeContext {\n  user: User;\n  level: Severity;\n  extra: Extras;\n  contexts: Contexts;\n  tags: { [key: string]: Primitive };\n  fingerprint: string[];\n  requestSession: RequestSession;\n}\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be called by the client before an event is sent.\n */\nexport interface Scope {\n  /** Add new event processor that will be called after {@link applyToEvent}. */\n  addEventProcessor(callback: EventProcessor): this;\n\n  /**\n   * Updates user context information for future events.\n   *\n   * @param user User context object to be set in the current context. Pass `null` to unset the user.\n   */\n  setUser(user: User | null): this;\n\n  /**\n   * Returns the `User` if there is one\n   */\n  getUser(): User | undefined;\n\n  /**\n   * Set an object that will be merged sent as tags data with the event.\n   * @param tags Tags context object to merge into current context.\n   */\n  setTags(tags: { [key: string]: Primitive }): this;\n\n  /**\n   * Set key:value that will be sent as tags data with the event.\n   *\n   * Can also be used to unset a tag by passing `undefined`.\n   *\n   * @param key String key of tag\n   * @param value Value of tag\n   */\n  setTag(key: string, value: Primitive): this;\n\n  /**\n   * Set an object that will be merged sent as extra data with the event.\n   * @param extras Extras object to merge into current context.\n   */\n  setExtras(extras: Extras): this;\n\n  /**\n   * Set key:value that will be sent as extra data with the event.\n   * @param key String of extra\n   * @param extra Any kind of data. This data will be normalized.\n   */\n  setExtra(key: string, extra: Extra): this;\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param fingerprint string[] to group events in Sentry.\n   */\n  setFingerprint(fingerprint: string[]): this;\n\n  /**\n   * Sets the level on the scope for future events.\n   * @param level string {@link Severity}\n   */\n  setLevel(level: Severity): this;\n\n  /**\n   * Sets the transaction name on the scope for future events.\n   */\n  setTransactionName(name?: string): this;\n\n  /**\n   * Sets context data with the given name.\n   * @param name of the context\n   * @param context an object containing context data. This data will be normalized. Pass `null` to unset the context.\n   */\n  setContext(name: string, context: Context | null): this;\n\n  /**\n   * Sets the Span on the scope.\n   * @param span Span\n   */\n  setSpan(span?: Span): this;\n\n  /**\n   * Returns the `Span` if there is one\n   */\n  getSpan(): Span | undefined;\n\n  /**\n   * Returns the `Transaction` attached to the scope (if there is one)\n   */\n  getTransaction(): Transaction | undefined;\n\n  /**\n   * Returns the `Session` if there is one\n   */\n  getSession(): Session | undefined;\n\n  /**\n   * Sets the `Session` on the scope\n   */\n  setSession(session?: Session): this;\n\n  /**\n   * Returns the `RequestSession` if there is one\n   */\n  getRequestSession(): RequestSession | undefined;\n\n  /**\n   * Sets the `RequestSession` on the scope\n   */\n  setRequestSession(requestSession?: RequestSession): this;\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   * @param captureContext scope modifier to be used\n   */\n  update(captureContext?: CaptureContext): this;\n\n  /** Clears the current scope and resets its properties. */\n  clear(): this;\n\n  /**\n   * Sets the breadcrumbs in the scope\n   * @param breadcrumbs Breadcrumb\n   * @param maxBreadcrumbs number of max breadcrumbs to merged into event.\n   */\n  addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;\n\n  /**\n   * Clears all currently set Breadcrumbs.\n   */\n  clearBreadcrumbs(): this;\n}\n"]}import { Package } from './package';
export interface SdkInfo {
    name?: string;
    version?: string;
    integrations?: string[];
    packages?: Package[];
}
//# sourceMappingURL=sdkinfo.d.ts.map{"version":3,"file":"sdkinfo.d.ts","sourceRoot":"","sources":["../../src/sdkinfo.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,MAAM,WAAW,OAAO;IACtB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,QAAQ,CAAC,EAAE,OAAO,EAAE,CAAC;CACtB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=sdkinfo.js.map{"version":3,"file":"sdkinfo.js","sourceRoot":"","sources":["../../src/sdkinfo.ts"],"names":[],"mappings":"","sourcesContent":["import { Package } from './package';\n\nexport interface SdkInfo {\n  name?: string;\n  version?: string;\n  integrations?: string[];\n  packages?: Package[];\n}\n"]}import { SdkInfo } from './sdkinfo';
export interface SdkMetadata {
    sdk?: SdkInfo;
}
//# sourceMappingURL=sdkmetadata.d.ts.map{"version":3,"file":"sdkmetadata.d.ts","sourceRoot":"","sources":["../../src/sdkmetadata.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,MAAM,WAAW,WAAW;IAC1B,GAAG,CAAC,EAAE,OAAO,CAAC;CACf"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=sdkmetadata.js.map{"version":3,"file":"sdkmetadata.js","sourceRoot":"","sources":["../../src/sdkmetadata.ts"],"names":[],"mappings":"","sourcesContent":["import { SdkInfo } from './sdkinfo';\n\nexport interface SdkMetadata {\n  sdk?: SdkInfo;\n}\n"]}import { User } from './user';
/**
 * @inheritdoc
 */
export interface Session extends SessionContext {
    /** JSDoc */
    update(context?: SessionContext): void;
    /** JSDoc */
    close(status?: SessionStatus): void;
    /** JSDoc */
    toJSON(): {
        init: boolean;
        sid: string;
        did?: string;
        timestamp: string;
        started: string;
        duration?: number;
        status: SessionStatus;
        errors: number;
        attrs?: {
            release?: string;
            environment?: string;
            user_agent?: string;
            ip_address?: string;
        };
    };
}
export interface RequestSession {
    status?: RequestSessionStatus;
}
/**
 * Session Context
 */
export interface SessionContext {
    sid?: string;
    did?: string;
    init?: boolean;
    timestamp?: number;
    started?: number;
    duration?: number;
    status?: SessionStatus;
    release?: string;
    environment?: string;
    userAgent?: string;
    ipAddress?: string;
    errors?: number;
    user?: User | null;
    ignoreDuration?: boolean;
}
export declare type SessionStatus = 'ok' | 'exited' | 'crashed' | 'abnormal';
export declare type RequestSessionStatus = 'ok' | 'errored' | 'crashed';
/** JSDoc */
export interface SessionAggregates {
    attrs?: {
        environment?: string;
        release?: string;
    };
    aggregates: Array<AggregationCounts>;
}
export interface SessionFlusherLike {
    /**
     * Increments the Session Status bucket in SessionAggregates Object corresponding to the status of the session
     * captured
     */
    incrementSessionStatusCount(): void;
    /** Submits the aggregates request mode sessions to Sentry */
    sendSessionAggregates(sessionAggregates: SessionAggregates): void;
    /** Empties Aggregate Buckets and Sends them to Transport Buffer */
    flush(): void;
    /** Clears setInterval and calls flush */
    close(): void;
}
export interface AggregationCounts {
    started: string;
    errored?: number;
    exited?: number;
    crashed?: number;
}
//# sourceMappingURL=session.d.ts.map{"version":3,"file":"session.d.ts","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B;;GAEG;AACH,MAAM,WAAW,OAAQ,SAAQ,cAAc;IAC7C,YAAY;IACZ,MAAM,CAAC,OAAO,CAAC,EAAE,cAAc,GAAG,IAAI,CAAC;IAEvC,YAAY;IACZ,KAAK,CAAC,MAAM,CAAC,EAAE,aAAa,GAAG,IAAI,CAAC;IAEpC,YAAY;IACZ,MAAM,IAAI;QACR,IAAI,EAAE,OAAO,CAAC;QACd,GAAG,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,MAAM,CAAC;QAClB,OAAO,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,MAAM,EAAE,aAAa,CAAC;QACtB,MAAM,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE;YACN,OAAO,CAAC,EAAE,MAAM,CAAC;YACjB,WAAW,CAAC,EAAE,MAAM,CAAC;YACrB,UAAU,CAAC,EAAE,MAAM,CAAC;YACpB,UAAU,CAAC,EAAE,MAAM,CAAC;SACrB,CAAC;KACH,CAAC;CACH;AAED,MAAM,WAAW,cAAc;IAC7B,MAAM,CAAC,EAAE,oBAAoB,CAAC;CAC/B;AAED;;GAEG;AACH,MAAM,WAAW,cAAc;IAC7B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,OAAO,CAAC;IAEf,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,aAAa,CAAC;IACvB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,IAAI,GAAG,IAAI,CAAC;IACnB,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B;AAED,oBAAY,aAAa,GAAG,IAAI,GAAG,QAAQ,GAAG,SAAS,GAAG,UAAU,CAAC;AACrE,oBAAY,oBAAoB,GAAG,IAAI,GAAG,SAAS,GAAG,SAAS,CAAC;AAEhE,YAAY;AACZ,MAAM,WAAW,iBAAiB;IAChC,KAAK,CAAC,EAAE;QACN,WAAW,CAAC,EAAE,MAAM,CAAC;QACrB,OAAO,CAAC,EAAE,MAAM,CAAC;KAClB,CAAC;IACF,UAAU,EAAE,KAAK,CAAC,iBAAiB,CAAC,CAAC;CACtC;AAED,MAAM,WAAW,kBAAkB;IACjC;;;OAGG;IACH,2BAA2B,IAAI,IAAI,CAAC;IAEpC,6DAA6D;IAC7D,qBAAqB,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,IAAI,CAAC;IAElE,mEAAmE;IACnE,KAAK,IAAI,IAAI,CAAC;IAEd,yCAAyC;IACzC,KAAK,IAAI,IAAI,CAAC;CACf;AAED,MAAM,WAAW,iBAAiB;IAChC,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=session.js.map{"version":3,"file":"session.js","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"","sourcesContent":["import { User } from './user';\n\n/**\n * @inheritdoc\n */\nexport interface Session extends SessionContext {\n  /** JSDoc */\n  update(context?: SessionContext): void;\n\n  /** JSDoc */\n  close(status?: SessionStatus): void;\n\n  /** JSDoc */\n  toJSON(): {\n    init: boolean;\n    sid: string;\n    did?: string;\n    timestamp: string;\n    started: string;\n    duration?: number;\n    status: SessionStatus;\n    errors: number;\n    attrs?: {\n      release?: string;\n      environment?: string;\n      user_agent?: string;\n      ip_address?: string;\n    };\n  };\n}\n\nexport interface RequestSession {\n  status?: RequestSessionStatus;\n}\n\n/**\n * Session Context\n */\nexport interface SessionContext {\n  sid?: string;\n  did?: string;\n  init?: boolean;\n  // seconds since the UNIX epoch\n  timestamp?: number;\n  // seconds since the UNIX epoch\n  started?: number;\n  duration?: number;\n  status?: SessionStatus;\n  release?: string;\n  environment?: string;\n  userAgent?: string;\n  ipAddress?: string;\n  errors?: number;\n  user?: User | null;\n  ignoreDuration?: boolean;\n}\n\nexport type SessionStatus = 'ok' | 'exited' | 'crashed' | 'abnormal';\nexport type RequestSessionStatus = 'ok' | 'errored' | 'crashed';\n\n/** JSDoc */\nexport interface SessionAggregates {\n  attrs?: {\n    environment?: string;\n    release?: string;\n  };\n  aggregates: Array<AggregationCounts>;\n}\n\nexport interface SessionFlusherLike {\n  /**\n   * Increments the Session Status bucket in SessionAggregates Object corresponding to the status of the session\n   * captured\n   */\n  incrementSessionStatusCount(): void;\n\n  /** Submits the aggregates request mode sessions to Sentry */\n  sendSessionAggregates(sessionAggregates: SessionAggregates): void;\n\n  /** Empties Aggregate Buckets and Sends them to Transport Buffer */\n  flush(): void;\n\n  /** Clears setInterval and calls flush */\n  close(): void;\n}\n\nexport interface AggregationCounts {\n  started: string;\n  errored?: number;\n  exited?: number;\n  crashed?: number;\n}\n"]}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to SessionStatus type
 */
export declare enum SessionStatus {
    /** JSDoc */
    Ok = "ok",
    /** JSDoc */
    Exited = "exited",
    /** JSDoc */
    Crashed = "crashed",
    /** JSDoc */
    Abnormal = "abnormal"
}
//# sourceMappingURL=sessionstatus.d.ts.map{"version":3,"file":"sessionstatus.d.ts","sourceRoot":"","sources":["../../src/sessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,aAAa;IACvB,YAAY;IACZ,EAAE,OAAO;IACT,YAAY;IACZ,MAAM,WAAW;IACjB,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,QAAQ,aAAa;CACtB"}Object.defineProperty(exports, "__esModule", { value: true });
/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to SessionStatus type
 */
var SessionStatus;
(function (SessionStatus) {
    /** JSDoc */
    SessionStatus["Ok"] = "ok";
    /** JSDoc */
    SessionStatus["Exited"] = "exited";
    /** JSDoc */
    SessionStatus["Crashed"] = "crashed";
    /** JSDoc */
    SessionStatus["Abnormal"] = "abnormal";
})(SessionStatus = exports.SessionStatus || (exports.SessionStatus = {}));
//# sourceMappingURL=sessionstatus.js.map{"version":3,"file":"sessionstatus.js","sourceRoot":"","sources":["../../src/sessionstatus.ts"],"names":[],"mappings":";AAAA;;GAEG;AACH,IAAY,aASX;AATD,WAAY,aAAa;IACvB,YAAY;IACZ,0BAAS,CAAA;IACT,YAAY;IACZ,kCAAiB,CAAA;IACjB,YAAY;IACZ,oCAAmB,CAAA;IACnB,YAAY;IACZ,sCAAqB,CAAA;AACvB,CAAC,EATW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QASxB","sourcesContent":["/** JSDoc\n * @deprecated Use string literals - if you require type casting, cast to SessionStatus type\n */\nexport enum SessionStatus {\n  /** JSDoc */\n  Ok = 'ok',\n  /** JSDoc */\n  Exited = 'exited',\n  /** JSDoc */\n  Crashed = 'crashed',\n  /** JSDoc */\n  Abnormal = 'abnormal',\n}\n"]}/**
 * TODO(v7): Remove this enum and replace with SeverityLevel
 */
export declare enum Severity {
    /** JSDoc */
    Fatal = "fatal",
    /** JSDoc */
    Error = "error",
    /** JSDoc */
    Warning = "warning",
    /** JSDoc */
    Log = "log",
    /** JSDoc */
    Info = "info",
    /** JSDoc */
    Debug = "debug",
    /** JSDoc */
    Critical = "critical"
}
export declare const SeverityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug", "critical"];
export declare type SeverityLevel = typeof SeverityLevels[number];
//# sourceMappingURL=severity.d.ts.map{"version":3,"file":"severity.d.ts","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,QAAQ;IAClB,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,GAAG,QAAQ;IACX,YAAY;IACZ,IAAI,SAAS;IACb,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,QAAQ,aAAa;CACtB;AAID,eAAO,MAAM,cAAc,4EAA6E,CAAC;AACzG,oBAAY,aAAa,GAAG,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
/**
 * TODO(v7): Remove this enum and replace with SeverityLevel
 */
var Severity;
(function (Severity) {
    /** JSDoc */
    Severity["Fatal"] = "fatal";
    /** JSDoc */
    Severity["Error"] = "error";
    /** JSDoc */
    Severity["Warning"] = "warning";
    /** JSDoc */
    Severity["Log"] = "log";
    /** JSDoc */
    Severity["Info"] = "info";
    /** JSDoc */
    Severity["Debug"] = "debug";
    /** JSDoc */
    Severity["Critical"] = "critical";
})(Severity = exports.Severity || (exports.Severity = {}));
// TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here
// is nice because then it enforces the idea that only types are exported from `@sentry/types`.)
exports.SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];
//# sourceMappingURL=severity.js.map{"version":3,"file":"severity.js","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":";AAAA;;GAEG;AACH,IAAY,QAeX;AAfD,WAAY,QAAQ;IAClB,YAAY;IACZ,2BAAe,CAAA;IACf,YAAY;IACZ,2BAAe,CAAA;IACf,YAAY;IACZ,+BAAmB,CAAA;IACnB,YAAY;IACZ,uBAAW,CAAA;IACX,YAAY;IACZ,yBAAa,CAAA;IACb,YAAY;IACZ,2BAAe,CAAA;IACf,YAAY;IACZ,iCAAqB,CAAA;AACvB,CAAC,EAfW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAenB;AAED,wHAAwH;AACxH,gGAAgG;AACnF,QAAA,cAAc,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,CAAU,CAAC","sourcesContent":["/**\n * TODO(v7): Remove this enum and replace with SeverityLevel\n */\nexport enum Severity {\n  /** JSDoc */\n  Fatal = 'fatal',\n  /** JSDoc */\n  Error = 'error',\n  /** JSDoc */\n  Warning = 'warning',\n  /** JSDoc */\n  Log = 'log',\n  /** JSDoc */\n  Info = 'info',\n  /** JSDoc */\n  Debug = 'debug',\n  /** JSDoc */\n  Critical = 'critical',\n}\n\n// TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here\n// is nice because then it enforces the idea that only types are exported from `@sentry/types`.)\nexport const SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'] as const;\nexport type SeverityLevel = typeof SeverityLevels[number];\n"]}import { Primitive } from './misc';
import { Transaction } from './transaction';
/** Interface holding all properties that can be set on a Span on creation. */
export interface SpanContext {
    /**
     * Description of the Span.
     */
    description?: string;
    /**
     * Operation of the Span.
     */
    op?: string;
    /**
     * Completion status of the Span.
     * See: {@sentry/tracing SpanStatus} for possible values
     */
    status?: string;
    /**
     * Parent Span ID
     */
    parentSpanId?: string;
    /**
     * Was this span chosen to be sent as part of the sample?
     */
    sampled?: boolean;
    /**
     * Span ID
     */
    spanId?: string;
    /**
     * Trace ID
     */
    traceId?: string;
    /**
     * Tags of the Span.
     */
    tags?: {
        [key: string]: Primitive;
    };
    /**
     * Data of the Span.
     */
    data?: {
        [key: string]: any;
    };
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     */
    startTimestamp?: number;
    /**
     * Timestamp in seconds (epoch time) indicating when the span ended.
     */
    endTimestamp?: number;
}
/** Span holding trace_id, span_id */
export interface Span extends SpanContext {
    /**
     * @inheritDoc
     */
    spanId: string;
    /**
     * @inheritDoc
     */
    traceId: string;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * The transaction containing this span
     */
    transaction?: Transaction;
    /**
     * Sets the finish timestamp on the current span.
     * @param endTimestamp Takes an endTimestamp if the end should not be the time when you call this function.
     */
    finish(endTimestamp?: number): void;
    /**
     * Sets the tag attribute on the current span.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key Tag key
     * @param value Tag value
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Sets the data attribute on the current span
     * @param key Data key
     * @param value Data value
     */
    setData(key: string, value: any): this;
    /**
     * Sets the status attribute on the current span
     * See: {@sentry/tracing SpanStatus} for possible values
     * @param status http code used to set the status
     */
    setStatus(status: string): this;
    /**
     * Sets the status attribute on the current span based on the http code
     * @param httpStatus http code used to set the status
     */
    setHttpStatus(httpStatus: number): this;
    /**
     * Use {@link startChild}
     * @deprecated
     */
    child(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
     * Also the `sampled` decision will be inherited.
     */
    startChild(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Determines whether span was successful (HTTP200)
     */
    isSuccess(): boolean;
    /** Return a traceparent compatible header string */
    toTraceparent(): string;
    /** Returns the current span properties as a `SpanContext` */
    toContext(): SpanContext;
    /** Updates the current span with a new `SpanContext` */
    updateWithContext(spanContext: SpanContext): this;
    /** Convert the object to JSON for w. spans array info only */
    getTraceContext(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        status?: string;
        tags?: {
            [key: string]: Primitive;
        };
        trace_id: string;
    };
    /** Convert the object to JSON */
    toJSON(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        start_timestamp: number;
        status?: string;
        tags?: {
            [key: string]: Primitive;
        };
        timestamp?: number;
        trace_id: string;
    };
}
//# sourceMappingURL=span.d.ts.map{"version":3,"file":"span.d.ts","sourceRoot":"","sources":["../../src/span.ts"],"names":[],"mappings":"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"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=span.js.map{"version":3,"file":"span.js","sourceRoot":"","sources":["../../src/span.ts"],"names":[],"mappings":"","sourcesContent":["import { Primitive } from './misc';\nimport { Transaction } from './transaction';\n\n/** Interface holding all properties that can be set on a Span on creation. */\nexport interface SpanContext {\n  /**\n   * Description of the Span.\n   */\n  description?: string;\n\n  /**\n   * Operation of the Span.\n   */\n  op?: string;\n\n  /**\n   * Completion status of the Span.\n   * See: {@sentry/tracing SpanStatus} for possible values\n   */\n  status?: string;\n\n  /**\n   * Parent Span ID\n   */\n  parentSpanId?: string;\n\n  /**\n   * Was this span chosen to be sent as part of the sample?\n   */\n  sampled?: boolean;\n\n  /**\n   * Span ID\n   */\n  spanId?: string;\n\n  /**\n   * Trace ID\n   */\n  traceId?: string;\n\n  /**\n   * Tags of the Span.\n   */\n  tags?: { [key: string]: Primitive };\n\n  /**\n   * Data of the Span.\n   */\n  data?: { [key: string]: any };\n\n  /**\n   * Timestamp in seconds (epoch time) indicating when the span started.\n   */\n  startTimestamp?: number;\n\n  /**\n   * Timestamp in seconds (epoch time) indicating when the span ended.\n   */\n  endTimestamp?: number;\n}\n\n/** Span holding trace_id, span_id */\nexport interface Span extends SpanContext {\n  /**\n   * @inheritDoc\n   */\n  spanId: string;\n\n  /**\n   * @inheritDoc\n   */\n  traceId: string;\n\n  /**\n   * @inheritDoc\n   */\n  startTimestamp: number;\n\n  /**\n   * @inheritDoc\n   */\n  tags: { [key: string]: Primitive };\n\n  /**\n   * @inheritDoc\n   */\n  data: { [key: string]: any };\n\n  /**\n   * The transaction containing this span\n   */\n  transaction?: Transaction;\n\n  /**\n   * Sets the finish timestamp on the current span.\n   * @param endTimestamp Takes an endTimestamp if the end should not be the time when you call this function.\n   */\n  finish(endTimestamp?: number): void;\n\n  /**\n   * Sets the tag attribute on the current span.\n   *\n   * Can also be used to unset a tag, by passing `undefined`.\n   *\n   * @param key Tag key\n   * @param value Tag value\n   */\n  setTag(key: string, value: Primitive): this;\n\n  /**\n   * Sets the data attribute on the current span\n   * @param key Data key\n   * @param value Data value\n   */\n  setData(key: string, value: any): this;\n\n  /**\n   * Sets the status attribute on the current span\n   * See: {@sentry/tracing SpanStatus} for possible values\n   * @param status http code used to set the status\n   */\n  setStatus(status: string): this;\n\n  /**\n   * Sets the status attribute on the current span based on the http code\n   * @param httpStatus http code used to set the status\n   */\n  setHttpStatus(httpStatus: number): this;\n\n  /**\n   * Use {@link startChild}\n   * @deprecated\n   */\n  child(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span;\n\n  /**\n   * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n   * Also the `sampled` decision will be inherited.\n   */\n  startChild(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span;\n\n  /**\n   * Determines whether span was successful (HTTP200)\n   */\n  isSuccess(): boolean;\n\n  /** Return a traceparent compatible header string */\n  toTraceparent(): string;\n\n  /** Returns the current span properties as a `SpanContext` */\n  toContext(): SpanContext;\n\n  /** Updates the current span with a new `SpanContext` */\n  updateWithContext(spanContext: SpanContext): this;\n\n  /** Convert the object to JSON for w. spans array info only */\n  getTraceContext(): {\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    trace_id: string;\n  };\n  /** Convert the object to JSON */\n  toJSON(): {\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    start_timestamp: number;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    timestamp?: number;\n    trace_id: string;\n  };\n}\n"]}/** JSDoc */
export interface StackFrame {
    filename?: string;
    function?: string;
    module?: string;
    platform?: string;
    lineno?: number;
    colno?: number;
    abs_path?: string;
    context_line?: string;
    pre_context?: string[];
    post_context?: string[];
    in_app?: boolean;
    instruction_addr?: string;
    addr_mode?: string;
    vars?: {
        [key: string]: any;
    };
}
//# sourceMappingURL=stackframe.d.ts.map{"version":3,"file":"stackframe.d.ts","sourceRoot":"","sources":["../../src/stackframe.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CAC/B"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=stackframe.js.map{"version":3,"file":"stackframe.js","sourceRoot":"","sources":["../../src/stackframe.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface StackFrame {\n  filename?: string;\n  function?: string;\n  module?: string;\n  platform?: string;\n  lineno?: number;\n  colno?: number;\n  abs_path?: string;\n  context_line?: string;\n  pre_context?: string[];\n  post_context?: string[];\n  in_app?: boolean;\n  instruction_addr?: string;\n  addr_mode?: string;\n  vars?: { [key: string]: any };\n}\n"]}import { StackFrame } from './stackframe';
/** JSDoc */
export interface Stacktrace {
    frames?: StackFrame[];
    frames_omitted?: [number, number];
}
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,MAAM,CAAC,EAAE,UAAU,EAAE,CAAC;IACtB,cAAc,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CACnC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=stacktrace.js.map{"version":3,"file":"stacktrace.js","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"","sourcesContent":["import { StackFrame } from './stackframe';\n\n/** JSDoc */\nexport interface Stacktrace {\n  frames?: StackFrame[];\n  frames_omitted?: [number, number];\n}\n"]}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to EventStatus type
 */
export declare enum Status {
    /** The status could not be determined. */
    Unknown = "unknown",
    /** The event was skipped due to configuration or callbacks. */
    Skipped = "skipped",
    /** The event was sent to Sentry successfully. */
    Success = "success",
    /** The client is currently rate limited and will try again later. */
    RateLimit = "rate_limit",
    /** The event could not be processed. */
    Invalid = "invalid",
    /** A server-side error occurred during submission. */
    Failed = "failed"
}
//# sourceMappingURL=status.d.ts.map{"version":3,"file":"status.d.ts","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,MAAM;IAChB,0CAA0C;IAC1C,OAAO,YAAY;IACnB,+DAA+D;IAC/D,OAAO,YAAY;IACnB,iDAAiD;IACjD,OAAO,YAAY;IACnB,qEAAqE;IACrE,SAAS,eAAe;IACxB,wCAAwC;IACxC,OAAO,YAAY;IACnB,sDAAsD;IACtD,MAAM,WAAW;CAClB"}Object.defineProperty(exports, "__esModule", { value: true });
/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to EventStatus type
 */
var Status;
(function (Status) {
    /** The status could not be determined. */
    Status["Unknown"] = "unknown";
    /** The event was skipped due to configuration or callbacks. */
    Status["Skipped"] = "skipped";
    /** The event was sent to Sentry successfully. */
    Status["Success"] = "success";
    /** The client is currently rate limited and will try again later. */
    Status["RateLimit"] = "rate_limit";
    /** The event could not be processed. */
    Status["Invalid"] = "invalid";
    /** A server-side error occurred during submission. */
    Status["Failed"] = "failed";
})(Status = exports.Status || (exports.Status = {}));
//# sourceMappingURL=status.js.map{"version":3,"file":"status.js","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":";AAAA;;GAEG;AACH,IAAY,MAaX;AAbD,WAAY,MAAM;IAChB,0CAA0C;IAC1C,6BAAmB,CAAA;IACnB,+DAA+D;IAC/D,6BAAmB,CAAA;IACnB,iDAAiD;IACjD,6BAAmB,CAAA;IACnB,qEAAqE;IACrE,kCAAwB,CAAA;IACxB,wCAAwC;IACxC,6BAAmB,CAAA;IACnB,sDAAsD;IACtD,2BAAiB,CAAA;AACnB,CAAC,EAbW,MAAM,GAAN,cAAM,KAAN,cAAM,QAajB","sourcesContent":["/** JSDoc\n * @deprecated Use string literals - if you require type casting, cast to EventStatus type\n */\nexport enum Status {\n  /** The status could not be determined. */\n  Unknown = 'unknown',\n  /** The event was skipped due to configuration or callbacks. */\n  Skipped = 'skipped',\n  /** The event was sent to Sentry successfully. */\n  Success = 'success',\n  /** The client is currently rate limited and will try again later. */\n  RateLimit = 'rate_limit',\n  /** The event could not be processed. */\n  Invalid = 'invalid',\n  /** A server-side error occurred during submission. */\n  Failed = 'failed',\n}\n"]}import { Stacktrace } from './stacktrace';
/** JSDoc */
export interface Thread {
    id?: number;
    name?: string;
    stacktrace?: Stacktrace;
    crashed?: boolean;
    current?: boolean;
}
//# sourceMappingURL=thread.d.ts.map{"version":3,"file":"thread.d.ts","sourceRoot":"","sources":["../../src/thread.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,MAAM;IACrB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,OAAO,CAAC,EAAE,OAAO,CAAC;CACnB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=thread.js.map{"version":3,"file":"thread.js","sourceRoot":"","sources":["../../src/thread.ts"],"names":[],"mappings":"","sourcesContent":["import { Stacktrace } from './stacktrace';\n\n/** JSDoc */\nexport interface Thread {\n  id?: number;\n  name?: string;\n  stacktrace?: Stacktrace;\n  crashed?: boolean;\n  current?: boolean;\n}\n"]}import { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';
import { Span, SpanContext } from './span';
/**
 * Interface holding Transaction-specific properties
 */
export interface TransactionContext extends SpanContext {
    /**
     * Human-readable identifier for the transaction
     */
    name: string;
    /**
     * If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming
     * the duration of the transaction. This is useful to discard extra time in the transaction that is not
     * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the
     * transaction after a given "idle time" and we don't want this "idle time" to be part of the transaction.
     */
    trimEnd?: boolean;
    /**
     * If this transaction has a parent, the parent's sampling decision
     */
    parentSampled?: boolean;
    /**
     * Metadata associated with the transaction, for internal SDK use.
     */
    metadata?: TransactionMetadata;
}
/**
 * Data pulled from a `sentry-trace` header
 */
export declare type TraceparentData = Pick<TransactionContext, 'traceId' | 'parentSpanId' | 'parentSampled'>;
/**
 * Transaction "Class", inherits Span only has `setName`
 */
export interface Transaction extends TransactionContext, Span {
    /**
     * @inheritDoc
     */
    spanId: string;
    /**
     * @inheritDoc
     */
    traceId: string;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * Metadata about the transaction
     */
    metadata: TransactionMetadata;
    /**
     * Set the name of the transaction
     */
    setName(name: string): void;
    /** Returns the current transaction properties as a `TransactionContext` */
    toContext(): TransactionContext;
    /** Updates the current transaction with a new `TransactionContext` */
    updateWithContext(transactionContext: TransactionContext): this;
}
/**
 * Context data passed by the user when starting a transaction, to be used by the tracesSampler method.
 */
export interface CustomSamplingContext {
    [key: string]: any;
}
/**
 * Data passed to the `tracesSampler` function, which forms the basis for whatever decisions it might make.
 *
 * Adds default data to data provided by the user. See {@link Hub.startTransaction}
 */
export interface SamplingContext extends CustomSamplingContext {
    /**
     * Context data with which transaction being sampled was created
     */
    transactionContext: TransactionContext;
    /**
     * Sampling decision from the parent transaction, if any.
     */
    parentSampled?: boolean;
    /**
     * Object representing the URL of the current page or worker script. Passed by default when using the `BrowserTracing`
     * integration.
     */
    location?: WorkerLocation;
    /**
     * Object representing the incoming request to a node server. Passed by default when using the TracingHandler.
     */
    request?: ExtractedNodeRequestData;
}
export declare type Measurements = Record<string, {
    value: number;
}>;
export declare type TransactionSamplingMethod = 'explicitly_set' | 'client_sampler' | 'client_rate' | 'inheritance';
export interface TransactionMetadata {
    transactionSampling?: {
        rate?: number;
        method: TransactionSamplingMethod;
    };
    /** The two halves (sentry and third-party) of a transaction's tracestate header, used for dynamic sampling */
    tracestate?: {
        sentry?: string;
        thirdparty?: string;
    };
    /** For transactions tracing server-side request handling, the path of the request being tracked. */
    requestPath?: string;
}
//# sourceMappingURL=transaction.d.ts.map{"version":3,"file":"transaction.d.ts","sourceRoot":"","sources":["../../src/transaction.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,wBAAwB,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAC7E,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAE3C;;GAEG;AACH,MAAM,WAAW,kBAAmB,SAAQ,WAAW;IACrD;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;;;OAKG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;OAEG;IACH,aAAa,CAAC,EAAE,OAAO,CAAC;IAExB;;OAEG;IACH,QAAQ,CAAC,EAAE,mBAAmB,CAAC;CAChC;AAED;;GAEG;AACH,oBAAY,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,SAAS,GAAG,cAAc,GAAG,eAAe,CAAC,CAAC;AAErG;;GAEG;AACH,MAAM,WAAW,WAAY,SAAQ,kBAAkB,EAAE,IAAI;IAC3D;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,cAAc,EAAE,MAAM,CAAC;IAEvB;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IAEnC;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAE7B;;OAEG;IACH,QAAQ,EAAE,mBAAmB,CAAC;IAE9B;;OAEG;IACH,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IAE5B,2EAA2E;IAC3E,SAAS,IAAI,kBAAkB,CAAC;IAEhC,sEAAsE;IACtE,iBAAiB,CAAC,kBAAkB,EAAE,kBAAkB,GAAG,IAAI,CAAC;CACjE;AAED;;GAEG;AACH,MAAM,WAAW,qBAAqB;IACpC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB;AAED;;;;GAIG;AACH,MAAM,WAAW,eAAgB,SAAQ,qBAAqB;IAC5D;;OAEG;IACH,kBAAkB,EAAE,kBAAkB,CAAC;IAEvC;;OAEG;IACH,aAAa,CAAC,EAAE,OAAO,CAAC;IAExB;;;OAGG;IACH,QAAQ,CAAC,EAAE,cAAc,CAAC;IAE1B;;OAEG;IACH,OAAO,CAAC,EAAE,wBAAwB,CAAC;CACpC;AAED,oBAAY,YAAY,GAAG,MAAM,CAAC,MAAM,EAAE;IAAE,KAAK,EAAE,MAAM,CAAA;CAAE,CAAC,CAAC;AAE7D,oBAAY,yBAAyB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,aAAa,GAAG,aAAa,CAAC;AAE5G,MAAM,WAAW,mBAAmB;IAClC,mBAAmB,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE,MAAM,CAAC;QAAC,MAAM,EAAE,yBAAyB,CAAA;KAAE,CAAC;IAE3E,8GAA8G;IAC9G,UAAU,CAAC,EAAE;QACX,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,UAAU,CAAC,EAAE,MAAM,CAAC;KACrB,CAAC;IAEF,oGAAoG;IACpG,WAAW,CAAC,EAAE,MAAM,CAAC;CACtB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=transaction.js.map{"version":3,"file":"transaction.js","sourceRoot":"","sources":["../../src/transaction.ts"],"names":[],"mappings":"","sourcesContent":["import { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';\nimport { Span, SpanContext } from './span';\n\n/**\n * Interface holding Transaction-specific properties\n */\nexport interface TransactionContext extends SpanContext {\n  /**\n   * Human-readable identifier for the transaction\n   */\n  name: string;\n\n  /**\n   * If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming\n   * the duration of the transaction. This is useful to discard extra time in the transaction that is not\n   * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the\n   * transaction after a given \"idle time\" and we don't want this \"idle time\" to be part of the transaction.\n   */\n  trimEnd?: boolean;\n\n  /**\n   * If this transaction has a parent, the parent's sampling decision\n   */\n  parentSampled?: boolean;\n\n  /**\n   * Metadata associated with the transaction, for internal SDK use.\n   */\n  metadata?: TransactionMetadata;\n}\n\n/**\n * Data pulled from a `sentry-trace` header\n */\nexport type TraceparentData = Pick<TransactionContext, 'traceId' | 'parentSpanId' | 'parentSampled'>;\n\n/**\n * Transaction \"Class\", inherits Span only has `setName`\n */\nexport interface Transaction extends TransactionContext, Span {\n  /**\n   * @inheritDoc\n   */\n  spanId: string;\n\n  /**\n   * @inheritDoc\n   */\n  traceId: string;\n\n  /**\n   * @inheritDoc\n   */\n  startTimestamp: number;\n\n  /**\n   * @inheritDoc\n   */\n  tags: { [key: string]: Primitive };\n\n  /**\n   * @inheritDoc\n   */\n  data: { [key: string]: any };\n\n  /**\n   * Metadata about the transaction\n   */\n  metadata: TransactionMetadata;\n\n  /**\n   * Set the name of the transaction\n   */\n  setName(name: string): void;\n\n  /** Returns the current transaction properties as a `TransactionContext` */\n  toContext(): TransactionContext;\n\n  /** Updates the current transaction with a new `TransactionContext` */\n  updateWithContext(transactionContext: TransactionContext): this;\n}\n\n/**\n * Context data passed by the user when starting a transaction, to be used by the tracesSampler method.\n */\nexport interface CustomSamplingContext {\n  [key: string]: any;\n}\n\n/**\n * Data passed to the `tracesSampler` function, which forms the basis for whatever decisions it might make.\n *\n * Adds default data to data provided by the user. See {@link Hub.startTransaction}\n */\nexport interface SamplingContext extends CustomSamplingContext {\n  /**\n   * Context data with which transaction being sampled was created\n   */\n  transactionContext: TransactionContext;\n\n  /**\n   * Sampling decision from the parent transaction, if any.\n   */\n  parentSampled?: boolean;\n\n  /**\n   * Object representing the URL of the current page or worker script. Passed by default when using the `BrowserTracing`\n   * integration.\n   */\n  location?: WorkerLocation;\n\n  /**\n   * Object representing the incoming request to a node server. Passed by default when using the TracingHandler.\n   */\n  request?: ExtractedNodeRequestData;\n}\n\nexport type Measurements = Record<string, { value: number }>;\n\nexport type TransactionSamplingMethod = 'explicitly_set' | 'client_sampler' | 'client_rate' | 'inheritance';\n\nexport interface TransactionMetadata {\n  transactionSampling?: { rate?: number; method: TransactionSamplingMethod };\n\n  /** The two halves (sentry and third-party) of a transaction's tracestate header, used for dynamic sampling */\n  tracestate?: {\n    sentry?: string;\n    thirdparty?: string;\n  };\n\n  /** For transactions tracing server-side request handling, the path of the request being tracked. */\n  requestPath?: string;\n}\n"]}import { DsnLike } from './dsn';
import { Event } from './event';
import { SentryRequestType } from './request';
import { Response } from './response';
import { SdkMetadata } from './sdkmetadata';
import { Session, SessionAggregates } from './session';
export declare type Outcome = 'before_send' | 'event_processor' | 'network_error' | 'queue_overflow' | 'ratelimit_backoff' | 'sample_rate';
/** Transport used sending data to Sentry */
export interface Transport {
    /**
     * Sends the event to the Store endpoint in Sentry.
     *
     * @param event Event that should be sent to Sentry.
     */
    sendEvent(event: Event): PromiseLike<Response>;
    /**
     * Sends the session to the Envelope endpoint in Sentry.
     *
     * @param session Session that should be sent to Sentry | Session Aggregates that should be sent to Sentry.
     */
    sendSession?(session: Session | SessionAggregates): PromiseLike<Response>;
    /**
     * Wait for all events to be sent or the timeout to expire, whichever comes first.
     *
     * @param timeout Maximum time in ms the transport should wait for events to be flushed. Omitting this parameter will
     *   cause the transport to wait until all events are sent before resolving the promise.
     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
     * still events in the queue when the timeout is reached.
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Increment the counter for the specific client outcome
     */
    recordLostEvent?(type: Outcome, category: SentryRequestType): void;
}
/** JSDoc */
export declare type TransportClass<T extends Transport> = new (options: TransportOptions) => T;
/** JSDoc */
export interface TransportOptions {
    /** Sentry DSN */
    dsn: DsnLike;
    /** Define custom headers */
    headers?: {
        [key: string]: string;
    };
    /** Set a HTTP proxy that should be used for outbound requests. */
    httpProxy?: string;
    /** Set a HTTPS proxy that should be used for outbound requests. */
    httpsProxy?: string;
    /** HTTPS proxy certificates path */
    caCerts?: string;
    /** Fetch API init parameters */
    fetchParameters?: {
        [key: string]: string;
    };
    /** The envelope tunnel to use. */
    tunnel?: string;
    /** Send SDK Client Reports. Enabled by default. */
    sendClientReports?: boolean;
    /**
     * Set of metadata about the SDK that can be internally used to enhance envelopes and events,
     * and provide additional data about every request.
     * */
    _metadata?: SdkMetadata;
}
//# sourceMappingURL=transport.d.ts.map{"version":3,"file":"transport.d.ts","sourceRoot":"","sources":["../../src/transport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,OAAO,CAAC;AAChC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAEvD,oBAAY,OAAO,GACf,aAAa,GACb,iBAAiB,GACjB,eAAe,GACf,gBAAgB,GAChB,mBAAmB,GACnB,aAAa,CAAC;AAElB,4CAA4C;AAC5C,MAAM,WAAW,SAAS;IACxB;;;;OAIG;IACH,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAE/C;;;;OAIG;IACH,WAAW,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAE1E;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C;;OAEG;IACH,eAAe,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,iBAAiB,GAAG,IAAI,CAAC;CACpE;AAED,YAAY;AACZ,oBAAY,cAAc,CAAC,CAAC,SAAS,SAAS,IAAI,KAAK,OAAO,EAAE,gBAAgB,KAAK,CAAC,CAAC;AAEvF,YAAY;AACZ,MAAM,WAAW,gBAAgB;IAC/B,iBAAiB;IACjB,GAAG,EAAE,OAAO,CAAC;IACb,4BAA4B;IAC5B,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,kEAAkE;IAClE,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,mEAAmE;IACnE,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,oCAAoC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,gCAAgC;IAChC,eAAe,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAC5C,kCAAkC;IAClC,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,mDAAmD;IACnD,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAC5B;;;SAGK;IACL,SAAS,CAAC,EAAE,WAAW,CAAC;CACzB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=transport.js.map{"version":3,"file":"transport.js","sourceRoot":"","sources":["../../src/transport.ts"],"names":[],"mappings":"","sourcesContent":["import { DsnLike } from './dsn';\nimport { Event } from './event';\nimport { SentryRequestType } from './request';\nimport { Response } from './response';\nimport { SdkMetadata } from './sdkmetadata';\nimport { Session, SessionAggregates } from './session';\n\nexport type Outcome =\n  | 'before_send'\n  | 'event_processor'\n  | 'network_error'\n  | 'queue_overflow'\n  | 'ratelimit_backoff'\n  | 'sample_rate';\n\n/** Transport used sending data to Sentry */\nexport interface Transport {\n  /**\n   * Sends the event to the Store endpoint in Sentry.\n   *\n   * @param event Event that should be sent to Sentry.\n   */\n  sendEvent(event: Event): PromiseLike<Response>;\n\n  /**\n   * Sends the session to the Envelope endpoint in Sentry.\n   *\n   * @param session Session that should be sent to Sentry | Session Aggregates that should be sent to Sentry.\n   */\n  sendSession?(session: Session | SessionAggregates): PromiseLike<Response>;\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the transport should wait for events to be flushed. Omitting this parameter will\n   *   cause the transport to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  close(timeout?: number): PromiseLike<boolean>;\n\n  /**\n   * Increment the counter for the specific client outcome\n   */\n  recordLostEvent?(type: Outcome, category: SentryRequestType): void;\n}\n\n/** JSDoc */\nexport type TransportClass<T extends Transport> = new (options: TransportOptions) => T;\n\n/** JSDoc */\nexport interface TransportOptions {\n  /** Sentry DSN */\n  dsn: DsnLike;\n  /** Define custom headers */\n  headers?: { [key: string]: string };\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n  /** Fetch API init parameters */\n  fetchParameters?: { [key: string]: string };\n  /** The envelope tunnel to use. */\n  tunnel?: string;\n  /** Send SDK Client Reports. Enabled by default. */\n  sendClientReports?: boolean;\n  /**\n   * Set of metadata about the SDK that can be internally used to enhance envelopes and events,\n   * and provide additional data about every request.\n   * */\n  _metadata?: SdkMetadata;\n}\n"]}/** JSDoc */
export interface User {
    [key: string]: any;
    id?: string;
    ip_address?: string;
    email?: string;
    username?: string;
}
export interface UserFeedback {
    event_id: string;
    email: User['email'];
    name: string;
    comments: string;
}
//# sourceMappingURL=user.d.ts.map{"version":3,"file":"user.d.ts","sourceRoot":"","sources":["../../src/user.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,IAAI;IACnB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB;AAED,MAAM,WAAW,YAAY;IAC3B,QAAQ,EAAE,MAAM,CAAC;IACjB,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;IACrB,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,MAAM,CAAC;CAClB"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=user.js.map{"version":3,"file":"user.js","sourceRoot":"","sources":["../../src/user.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface User {\n  [key: string]: any;\n  id?: string;\n  ip_address?: string;\n  email?: string;\n  username?: string;\n}\n\nexport interface UserFeedback {\n  event_id: string;\n  email: User['email'];\n  name: string;\n  comments: string;\n}\n"]}/** JSDoc */
export interface WrappedFunction extends Function {
    [key: string]: any;
    __sentry_wrapped__?: WrappedFunction;
    __sentry_original__?: WrappedFunction;
}
//# sourceMappingURL=wrappedfunction.d.ts.map{"version":3,"file":"wrappedfunction.d.ts","sourceRoot":"","sources":["../../src/wrappedfunction.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,eAAgB,SAAQ,QAAQ;IAC/C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,kBAAkB,CAAC,EAAE,eAAe,CAAC;IACrC,mBAAmB,CAAC,EAAE,eAAe,CAAC;CACvC"}Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=wrappedfunction.js.map{"version":3,"file":"wrappedfunction.js","sourceRoot":"","sources":["../../src/wrappedfunction.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface WrappedFunction extends Function {\n  [key: string]: any;\n  __sentry_wrapped__?: WrappedFunction;\n  __sentry_original__?: WrappedFunction;\n}\n"]}import { Severity } from './severity';
/** JSDoc */
export interface Breadcrumb {
    type?: string;
    level?: Severity;
    event_id?: string;
    category?: string;
    message?: string;
    data?: {
        [key: string]: any;
    };
    timestamp?: number;
}
/** JSDoc */
export interface BreadcrumbHint {
    [key: string]: any;
}
//# sourceMappingURL=breadcrumb.d.ts.map{"version":3,"file":"breadcrumb.d.ts","sourceRoot":"","sources":["../../src/breadcrumb.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,QAAQ,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAC9B,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,YAAY;AACZ,MAAM,WAAW,cAAc;IAC7B,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB"}//# sourceMappingURL=breadcrumb.js.map{"version":3,"file":"breadcrumb.js","sourceRoot":"","sources":["../../src/breadcrumb.ts"],"names":[],"mappings":"","sourcesContent":["import { Severity } from './severity';\n\n/** JSDoc */\nexport interface Breadcrumb {\n  type?: string;\n  level?: Severity;\n  event_id?: string;\n  category?: string;\n  message?: string;\n  data?: { [key: string]: any };\n  timestamp?: number;\n}\n\n/** JSDoc */\nexport interface BreadcrumbHint {\n  [key: string]: any;\n}\n"]}import { DsnComponents } from './dsn';
import { Event, EventHint } from './event';
import { Integration, IntegrationClass } from './integration';
import { Options } from './options';
import { Scope } from './scope';
import { Session } from './session';
import { Severity } from './severity';
import { Transport } from './transport';
/**
 * User-Facing Sentry SDK Client.
 *
 * This interface contains all methods to interface with the SDK once it has
 * been installed. It allows to send events to Sentry, record breadcrumbs and
 * set a context included in every event. Since the SDK mutates its environment,
 * there will only be one instance during runtime.
 *
 */
export interface Client<O extends Options = Options> {
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param level Define the level of the message.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /** Captures a session
     *
     * @param session Session to be delivered
     */
    captureSession?(session: Session): void;
    /** Returns the current Dsn. */
    getDsn(): DsnComponents | undefined;
    /** Returns the current options. */
    getOptions(): O;
    /** Returns clients transport. */
    getTransport?(): Transport;
    /**
     * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
     *
     * @param timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
     *   the client to wait until all events are sent before disabling itself.
     * @returns A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
     * it doesn't.
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Wait for all events to be sent or the timeout to expire, whichever comes first.
     *
     * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
     *   cause the client to wait until all events are sent before resolving the promise.
     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
     * still events in the queue when the timeout is reached.
     */
    flush(timeout?: number): PromiseLike<boolean>;
    /** Returns an array of installed integrations on the client. */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** This is an internal function to setup all integrations that should run on the client */
    setupIntegrations(): void;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,OAAO,CAAC;AACtC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAExC;;;;;;;;GAQG;AACH,MAAM,WAAW,MAAM,CAAC,CAAC,SAAS,OAAO,GAAG,OAAO;IACjD;;;;;;;OAOG;IACH,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEtF;;;;;;;;OAQG;IACH,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEvG;;;;;;;OAOG;IACH,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEhF;;;OAGG;IACH,cAAc,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC;IAExC,+BAA+B;IAC/B,MAAM,IAAI,aAAa,GAAG,SAAS,CAAC;IAEpC,mCAAmC;IACnC,UAAU,IAAI,CAAC,CAAC;IAEhB,iCAAiC;IACjC,YAAY,CAAC,IAAI,SAAS,CAAC;IAE3B;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C,gEAAgE;IAChE,cAAc,CAAC,CAAC,SAAS,WAAW,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;IAElF,2FAA2F;IAC3F,iBAAiB,IAAI,IAAI,CAAC;CAC3B"}//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"","sourcesContent":["import { DsnComponents } from './dsn';\nimport { Event, EventHint } from './event';\nimport { Integration, IntegrationClass } from './integration';\nimport { Options } from './options';\nimport { Scope } from './scope';\nimport { Session } from './session';\nimport { Severity } from './severity';\nimport { Transport } from './transport';\n\n/**\n * User-Facing Sentry SDK Client.\n *\n * This interface contains all methods to interface with the SDK once it has\n * been installed. It allows to send events to Sentry, record breadcrumbs and\n * set a context included in every event. Since the SDK mutates its environment,\n * there will only be one instance during runtime.\n *\n */\nexport interface Client<O extends Options = Options> {\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * @param exception An exception-like object.\n   * @param hint May contain additional information about the original exception.\n   * @param scope An optional scope containing event metadata.\n   * @returns The event id\n   */\n  captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * @param message The message to send to Sentry.\n   * @param level Define the level of the message.\n   * @param hint May contain additional information about the original exception.\n   * @param scope An optional scope containing event metadata.\n   * @returns The event id\n   */\n  captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope An optional scope containing event metadata.\n   * @returns The event id\n   */\n  captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;\n\n  /** Captures a session\n   *\n   * @param session Session to be delivered\n   */\n  captureSession?(session: Session): void;\n\n  /** Returns the current Dsn. */\n  getDsn(): DsnComponents | undefined;\n\n  /** Returns the current options. */\n  getOptions(): O;\n\n  /** Returns clients transport. */\n  getTransport?(): Transport;\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n  close(timeout?: number): PromiseLike<boolean>;\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  flush(timeout?: number): PromiseLike<boolean>;\n\n  /** Returns an array of installed integrations on the client. */\n  getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;\n\n  /** This is an internal function to setup all integrations that should run on the client */\n  setupIntegrations(): void;\n}\n"]}import { SentryRequestType } from './request';
import { Outcome } from './transport';
export declare type ClientReport = {
    timestamp: number;
    discarded_events: Array<{
        reason: Outcome;
        category: SentryRequestType;
        quantity: number;
    }>;
};
//# sourceMappingURL=clientreport.d.ts.map{"version":3,"file":"clientreport.d.ts","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AAEtC,oBAAY,YAAY,GAAG;IACzB,SAAS,EAAE,MAAM,CAAC;IAClB,gBAAgB,EAAE,KAAK,CAAC;QAAE,MAAM,EAAE,OAAO,CAAC;QAAC,QAAQ,EAAE,iBAAiB,CAAC;QAAC,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAC7F,CAAC"}//# sourceMappingURL=clientreport.js.map{"version":3,"file":"clientreport.js","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"","sourcesContent":["import { SentryRequestType } from './request';\nimport { Outcome } from './transport';\n\nexport type ClientReport = {\n  timestamp: number;\n  discarded_events: Array<{ reason: Outcome; category: SentryRequestType; quantity: number }>;\n};\n"]}export declare type Context = Record<string, unknown>;
export declare type Contexts = Record<string, Context>;
//# sourceMappingURL=context.d.ts.map{"version":3,"file":"context.d.ts","sourceRoot":"","sources":["../../src/context.ts"],"names":[],"mappings":"AAAA,oBAAY,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC9C,oBAAY,QAAQ,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC"}//# sourceMappingURL=context.js.map{"version":3,"file":"context.js","sourceRoot":"","sources":["../../src/context.ts"],"names":[],"mappings":"","sourcesContent":["export type Context = Record<string, unknown>;\nexport type Contexts = Record<string, Context>;\n"]}/**
 * Holds meta information to customize the behavior of Sentry's server-side event processing.
 **/
export interface DebugMeta {
    images?: Array<DebugImage>;
}
/**
 * Possible choices for debug images.
 */
export declare type DebugImageType = 'wasm' | 'macho' | 'elf' | 'pe';
/**
 * References to debug images.
 */
export interface DebugImage {
    type: DebugImageType;
    debug_id: string;
    code_id?: string | null;
    code_file: string;
    debug_file?: string | null;
}
//# sourceMappingURL=debugMeta.d.ts.map{"version":3,"file":"debugMeta.d.ts","sourceRoot":"","sources":["../../src/debugMeta.ts"],"names":[],"mappings":"AAAA;;IAEI;AACJ,MAAM,WAAW,SAAS;IACxB,MAAM,CAAC,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;CAC5B;AAED;;GAEG;AACH,oBAAY,cAAc,GAAG,MAAM,GAAG,OAAO,GAAG,KAAK,GAAG,IAAI,CAAC;AAE7D;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB,IAAI,EAAE,cAAc,CAAC;IACrB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACxB,SAAS,EAAE,MAAM,CAAC;IAClB,UAAU,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;CAC5B"}//# sourceMappingURL=debugMeta.js.map{"version":3,"file":"debugMeta.js","sourceRoot":"","sources":["../../src/debugMeta.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Holds meta information to customize the behavior of Sentry's server-side event processing.\n **/\nexport interface DebugMeta {\n  images?: Array<DebugImage>;\n}\n\n/**\n * Possible choices for debug images.\n */\nexport type DebugImageType = 'wasm' | 'macho' | 'elf' | 'pe';\n\n/**\n * References to debug images.\n */\nexport interface DebugImage {\n  type: DebugImageType;\n  debug_id: string;\n  code_id?: string | null;\n  code_file: string;\n  debug_file?: string | null;\n}\n"]}/** Supported Sentry transport protocols in a Dsn. */
export declare type DsnProtocol = 'http' | 'https';
/** Primitive components of a Dsn. */
export interface DsnComponents {
    /** Protocol used to connect to Sentry. */
    protocol: DsnProtocol;
    /** Public authorization key (deprecated, renamed to publicKey). */
    user?: string;
    /** Public authorization key. */
    publicKey?: string;
    /** Private authorization key (deprecated, optional). */
    pass?: string;
    /** Hostname of the Sentry instance. */
    host: string;
    /** Port of the Sentry instance. */
    port?: string;
    /** Sub path/ */
    path?: string;
    /** Project ID */
    projectId: string;
}
/** Anything that can be parsed into a Dsn. */
export declare type DsnLike = string | DsnComponents;
//# sourceMappingURL=dsn.d.ts.map{"version":3,"file":"dsn.d.ts","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"AAAA,qDAAqD;AACrD,oBAAY,WAAW,GAAG,MAAM,GAAG,OAAO,CAAC;AAE3C,qCAAqC;AACrC,MAAM,WAAW,aAAa;IAC5B,0CAA0C;IAC1C,QAAQ,EAAE,WAAW,CAAC;IACtB,mEAAmE;IACnE,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gCAAgC;IAChC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,wDAAwD;IACxD,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,uCAAuC;IACvC,IAAI,EAAE,MAAM,CAAC;IACb,mCAAmC;IACnC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gBAAgB;IAChB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,iBAAiB;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,8CAA8C;AAC9C,oBAAY,OAAO,GAAG,MAAM,GAAG,aAAa,CAAC"}//# sourceMappingURL=dsn.js.map{"version":3,"file":"dsn.js","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"","sourcesContent":["/** Supported Sentry transport protocols in a Dsn. */\nexport type DsnProtocol = 'http' | 'https';\n\n/** Primitive components of a Dsn. */\nexport interface DsnComponents {\n  /** Protocol used to connect to Sentry. */\n  protocol: DsnProtocol;\n  /** Public authorization key (deprecated, renamed to publicKey). */\n  user?: string;\n  /** Public authorization key. */\n  publicKey?: string;\n  /** Private authorization key (deprecated, optional). */\n  pass?: string;\n  /** Hostname of the Sentry instance. */\n  host: string;\n  /** Port of the Sentry instance. */\n  port?: string;\n  /** Sub path/ */\n  path?: string;\n  /** Project ID */\n  projectId: string;\n}\n\n/** Anything that can be parsed into a Dsn. */\nexport type DsnLike = string | DsnComponents;\n"]}import { ClientReport } from './clientreport';
import { Event } from './event';
import { SdkInfo } from './sdkinfo';
import { Session, SessionAggregates } from './session';
import { TransactionSamplingMethod } from './transaction';
import { UserFeedback } from './user';
export declare type BaseEnvelopeHeaders = {
    [key: string]: unknown;
    dsn?: string;
    sdk?: SdkInfo;
};
export declare type BaseEnvelopeItemHeaders = {
    [key: string]: unknown;
    type: string;
    length?: number;
};
declare type BaseEnvelopeItem<IH extends BaseEnvelopeItemHeaders, P extends unknown> = [IH, P];
declare type BaseEnvelope<EH extends BaseEnvelopeHeaders, I extends BaseEnvelopeItem<BaseEnvelopeItemHeaders, unknown>> = [EH, I[]];
declare type EventItemHeaders = {
    type: 'event' | 'transaction';
    sample_rates?: [{
        id?: TransactionSamplingMethod;
        rate?: number;
    }];
};
declare type AttachmentItemHeaders = {
    type: 'attachment';
    filename: string;
};
declare type UserFeedbackItemHeaders = {
    type: 'user_report';
};
declare type SessionItemHeaders = {
    type: 'session';
};
declare type SessionAggregatesItemHeaders = {
    type: 'sessions';
};
declare type ClientReportItemHeaders = {
    type: 'client_report';
};
export declare type EventItem = BaseEnvelopeItem<EventItemHeaders, Event | string>;
export declare type AttachmentItem = BaseEnvelopeItem<AttachmentItemHeaders, unknown>;
export declare type UserFeedbackItem = BaseEnvelopeItem<UserFeedbackItemHeaders, UserFeedback>;
export declare type SessionItem = BaseEnvelopeItem<SessionItemHeaders, Session> | BaseEnvelopeItem<SessionAggregatesItemHeaders, SessionAggregates>;
export declare type ClientReportItem = BaseEnvelopeItem<ClientReportItemHeaders, ClientReport>;
declare type EventEnvelopeHeaders = {
    event_id: string;
    sent_at: string;
};
declare type SessionEnvelopeHeaders = {
    sent_at: string;
};
declare type ClientReportEnvelopeHeaders = BaseEnvelopeHeaders;
export declare type EventEnvelope = BaseEnvelope<EventEnvelopeHeaders, EventItem | AttachmentItem | UserFeedbackItem>;
export declare type SessionEnvelope = BaseEnvelope<SessionEnvelopeHeaders, SessionItem>;
export declare type ClientReportEnvelope = BaseEnvelope<ClientReportEnvelopeHeaders, ClientReportItem>;
export declare type Envelope = EventEnvelope | SessionEnvelope | ClientReportEnvelope;
export {};
//# sourceMappingURL=envelope.d.ts.map{"version":3,"file":"envelope.d.ts","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"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"}//# sourceMappingURL=envelope.js.map{"version":3,"file":"envelope.js","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"","sourcesContent":["import { ClientReport } from './clientreport';\nimport { Event } from './event';\nimport { SdkInfo } from './sdkinfo';\nimport { Session, SessionAggregates } from './session';\nimport { TransactionSamplingMethod } from './transaction';\nimport { UserFeedback } from './user';\n\n// Based on: https://develop.sentry.dev/sdk/envelopes/\n\nexport type BaseEnvelopeHeaders = {\n  [key: string]: unknown;\n  dsn?: string;\n  sdk?: SdkInfo;\n};\n\nexport type BaseEnvelopeItemHeaders = {\n  [key: string]: unknown;\n  type: string;\n  length?: number;\n};\n\ntype BaseEnvelopeItem<IH extends BaseEnvelopeItemHeaders, P extends unknown> = [IH, P]; // P is for payload\n\ntype BaseEnvelope<EH extends BaseEnvelopeHeaders, I extends BaseEnvelopeItem<BaseEnvelopeItemHeaders, unknown>> = [\n  EH,\n  I[],\n];\n\ntype EventItemHeaders = {\n  type: 'event' | 'transaction';\n  sample_rates?: [{ id?: TransactionSamplingMethod; rate?: number }];\n};\ntype AttachmentItemHeaders = { type: 'attachment'; filename: string };\ntype UserFeedbackItemHeaders = { type: 'user_report' };\ntype SessionItemHeaders = { type: 'session' };\ntype SessionAggregatesItemHeaders = { type: 'sessions' };\ntype ClientReportItemHeaders = { type: 'client_report' };\n\n// TODO(v7): Remove the string union from `Event | string`\n// We have to allow this hack for now as we pre-serialize events because we support\n// both store and envelope endpoints.\nexport type EventItem = BaseEnvelopeItem<EventItemHeaders, Event | string>;\nexport type AttachmentItem = BaseEnvelopeItem<AttachmentItemHeaders, unknown>;\nexport type UserFeedbackItem = BaseEnvelopeItem<UserFeedbackItemHeaders, UserFeedback>;\nexport type SessionItem =\n  | BaseEnvelopeItem<SessionItemHeaders, Session>\n  | BaseEnvelopeItem<SessionAggregatesItemHeaders, SessionAggregates>;\nexport type ClientReportItem = BaseEnvelopeItem<ClientReportItemHeaders, ClientReport>;\n\ntype EventEnvelopeHeaders = { event_id: string; sent_at: string };\ntype SessionEnvelopeHeaders = { sent_at: string };\ntype ClientReportEnvelopeHeaders = BaseEnvelopeHeaders;\n\nexport type EventEnvelope = BaseEnvelope<EventEnvelopeHeaders, EventItem | AttachmentItem | UserFeedbackItem>;\nexport type SessionEnvelope = BaseEnvelope<SessionEnvelopeHeaders, SessionItem>;\nexport type ClientReportEnvelope = BaseEnvelope<ClientReportEnvelopeHeaders, ClientReportItem>;\n\nexport type Envelope = EventEnvelope | SessionEnvelope | ClientReportEnvelope;\n"]}/**
 * Just an Error object with arbitrary attributes attached to it.
 */
export interface ExtendedError extends Error {
    [key: string]: any;
}
//# sourceMappingURL=error.d.ts.map{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,WAAW,aAAc,SAAQ,KAAK;IAC1C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB"}//# sourceMappingURL=error.js.map{"version":3,"file":"error.js","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Just an Error object with arbitrary attributes attached to it.\n */\nexport interface ExtendedError extends Error {\n  [key: string]: any;\n}\n"]}import { Breadcrumb } from './breadcrumb';
import { Contexts } from './context';
import { DebugMeta } from './debugMeta';
import { Exception } from './exception';
import { Extras } from './extra';
import { Primitive } from './misc';
import { Request } from './request';
import { CaptureContext } from './scope';
import { SdkInfo } from './sdkinfo';
import { Severity } from './severity';
import { Span } from './span';
import { Stacktrace } from './stacktrace';
import { Measurements } from './transaction';
import { User } from './user';
/** JSDoc */
export interface Event {
    event_id?: string;
    message?: string;
    timestamp?: number;
    start_timestamp?: number;
    level?: Severity;
    platform?: string;
    logger?: string;
    server_name?: string;
    release?: string;
    dist?: string;
    environment?: string;
    sdk?: SdkInfo;
    request?: Request;
    transaction?: string;
    modules?: {
        [key: string]: string;
    };
    fingerprint?: string[];
    exception?: {
        values?: Exception[];
    };
    stacktrace?: Stacktrace;
    breadcrumbs?: Breadcrumb[];
    contexts?: Contexts;
    tags?: {
        [key: string]: Primitive;
    };
    extra?: Extras;
    user?: User;
    type?: EventType;
    spans?: Span[];
    measurements?: Measurements;
    debug_meta?: DebugMeta;
    sdkProcessingMetadata?: {
        [key: string]: any;
    };
}
/** JSDoc */
export declare type EventType = 'transaction';
/** JSDoc */
export interface EventHint {
    event_id?: string;
    captureContext?: CaptureContext;
    syntheticException?: Error | null;
    originalException?: Error | string | null;
    data?: any;
}
//# sourceMappingURL=event.d.ts.map{"version":3,"file":"event.d.ts","sourceRoot":"","sources":["../../src/event.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AACrC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACjC,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B,YAAY;AACZ,MAAM,WAAW,KAAK;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,KAAK,CAAC,EAAE,QAAQ,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,GAAG,CAAC,EAAE,OAAO,CAAC;IACd,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IACvB,SAAS,CAAC,EAAE;QACV,MAAM,CAAC,EAAE,SAAS,EAAE,CAAC;KACtB,CAAC;IACF,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,WAAW,CAAC,EAAE,UAAU,EAAE,CAAC;IAC3B,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IACpC,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,IAAI,CAAC,EAAE,IAAI,CAAC;IACZ,IAAI,CAAC,EAAE,SAAS,CAAC;IACjB,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC;IACf,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,UAAU,CAAC,EAAE,SAAS,CAAC;IAEvB,qBAAqB,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CAChD;AAED,YAAY;AACZ,oBAAY,SAAS,GAAG,aAAa,CAAC;AAEtC,YAAY;AACZ,MAAM,WAAW,SAAS;IACxB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,cAAc,CAAC,EAAE,cAAc,CAAC;IAChC,kBAAkB,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;IAClC,iBAAiB,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC;IAC1C,IAAI,CAAC,EAAE,GAAG,CAAC;CACZ"}//# sourceMappingURL=event.js.map{"version":3,"file":"event.js","sourceRoot":"","sources":["../../src/event.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb } from './breadcrumb';\nimport { Contexts } from './context';\nimport { DebugMeta } from './debugMeta';\nimport { Exception } from './exception';\nimport { Extras } from './extra';\nimport { Primitive } from './misc';\nimport { Request } from './request';\nimport { CaptureContext } from './scope';\nimport { SdkInfo } from './sdkinfo';\nimport { Severity } from './severity';\nimport { Span } from './span';\nimport { Stacktrace } from './stacktrace';\nimport { Measurements } from './transaction';\nimport { User } from './user';\n\n/** JSDoc */\nexport interface Event {\n  event_id?: string;\n  message?: string;\n  timestamp?: number;\n  start_timestamp?: number;\n  level?: Severity;\n  platform?: string;\n  logger?: string;\n  server_name?: string;\n  release?: string;\n  dist?: string;\n  environment?: string;\n  sdk?: SdkInfo;\n  request?: Request;\n  transaction?: string;\n  modules?: { [key: string]: string };\n  fingerprint?: string[];\n  exception?: {\n    values?: Exception[];\n  };\n  stacktrace?: Stacktrace;\n  breadcrumbs?: Breadcrumb[];\n  contexts?: Contexts;\n  tags?: { [key: string]: Primitive };\n  extra?: Extras;\n  user?: User;\n  type?: EventType;\n  spans?: Span[];\n  measurements?: Measurements;\n  debug_meta?: DebugMeta;\n  // A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get sent to Sentry\n  sdkProcessingMetadata?: { [key: string]: any };\n}\n\n/** JSDoc */\nexport type EventType = 'transaction';\n\n/** JSDoc */\nexport interface EventHint {\n  event_id?: string;\n  captureContext?: CaptureContext;\n  syntheticException?: Error | null;\n  originalException?: Error | string | null;\n  data?: any;\n}\n"]}import { Event, EventHint } from './event';
/**
 * Event processors are used to change the event before it will be send.
 * We strongly advise to make this function sync.
 * Returning a PromiseLike<Event | null> will work just fine, but better be sure that you know what you are doing.
 * Event processing will be deferred until your Promise is resolved.
 */
export declare type EventProcessor = (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;
//# sourceMappingURL=eventprocessor.d.ts.map{"version":3,"file":"eventprocessor.d.ts","sourceRoot":"","sources":["../../src/eventprocessor.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAE3C;;;;;GAKG;AACH,oBAAY,cAAc,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,KAAK,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC"}//# sourceMappingURL=eventprocessor.js.map{"version":3,"file":"eventprocessor.js","sourceRoot":"","sources":["../../src/eventprocessor.ts"],"names":[],"mappings":"","sourcesContent":["import { Event, EventHint } from './event';\n\n/**\n * Event processors are used to change the event before it will be send.\n * We strongly advise to make this function sync.\n * Returning a PromiseLike<Event | null> will work just fine, but better be sure that you know what you are doing.\n * Event processing will be deferred until your Promise is resolved.\n */\nexport type EventProcessor = (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;\n"]}export declare type EventStatus = 
/** The status could not be determined. */
'unknown'
/** The event was skipped due to configuration or callbacks. */
 | 'skipped'
/** The event was sent to Sentry successfully. */
 | 'rate_limit'
/** The client is currently rate limited and will try again later. */
 | 'invalid'
/** The event could not be processed. */
 | 'failed'
/** A server-side error occurred during submission. */
 | 'success';
//# sourceMappingURL=eventstatus.d.ts.map{"version":3,"file":"eventstatus.d.ts","sourceRoot":"","sources":["../../src/eventstatus.ts"],"names":[],"mappings":"AAAA,oBAAY,WAAW;AACrB,0CAA0C;AACxC,SAAS;AACX,+DAA+D;GAC7D,SAAS;AACX,iDAAiD;GAC/C,YAAY;AACd,qEAAqE;GACnE,SAAS;AACX,wCAAwC;GACtC,QAAQ;AACV,sDAAsD;GACpD,SAAS,CAAC"}//# sourceMappingURL=eventstatus.js.map{"version":3,"file":"eventstatus.js","sourceRoot":"","sources":["../../src/eventstatus.ts"],"names":[],"mappings":"","sourcesContent":["export type EventStatus =\n  /** The status could not be determined. */\n  | 'unknown'\n  /** The event was skipped due to configuration or callbacks. */\n  | 'skipped'\n  /** The event was sent to Sentry successfully. */\n  | 'rate_limit'\n  /** The client is currently rate limited and will try again later. */\n  | 'invalid'\n  /** The event could not be processed. */\n  | 'failed'\n  /** A server-side error occurred during submission. */\n  | 'success';\n"]}import { Mechanism } from './mechanism';
import { Stacktrace } from './stacktrace';
/** JSDoc */
export interface Exception {
    type?: string;
    value?: string;
    mechanism?: Mechanism;
    module?: string;
    thread_id?: number;
    stacktrace?: Stacktrace;
}
//# sourceMappingURL=exception.d.ts.map{"version":3,"file":"exception.d.ts","sourceRoot":"","sources":["../../src/exception.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,SAAS;IACxB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,SAAS,CAAC,EAAE,SAAS,CAAC;IACtB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,UAAU,CAAC,EAAE,UAAU,CAAC;CACzB"}//# sourceMappingURL=exception.js.map{"version":3,"file":"exception.js","sourceRoot":"","sources":["../../src/exception.ts"],"names":[],"mappings":"","sourcesContent":["import { Mechanism } from './mechanism';\nimport { Stacktrace } from './stacktrace';\n\n/** JSDoc */\nexport interface Exception {\n  type?: string;\n  value?: string;\n  mechanism?: Mechanism;\n  module?: string;\n  thread_id?: number;\n  stacktrace?: Stacktrace;\n}\n"]}export declare type Extra = unknown;
export declare type Extras = Record<string, Extra>;
//# sourceMappingURL=extra.d.ts.map{"version":3,"file":"extra.d.ts","sourceRoot":"","sources":["../../src/extra.ts"],"names":[],"mappings":"AAAA,oBAAY,KAAK,GAAG,OAAO,CAAC;AAC5B,oBAAY,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC"}//# sourceMappingURL=extra.js.map{"version":3,"file":"extra.js","sourceRoot":"","sources":["../../src/extra.ts"],"names":[],"mappings":"","sourcesContent":["export type Extra = unknown;\nexport type Extras = Record<string, Extra>;\n"]}import { Breadcrumb, BreadcrumbHint } from './breadcrumb';
import { Client } from './client';
import { Event, EventHint } from './event';
import { Extra, Extras } from './extra';
import { Integration, IntegrationClass } from './integration';
import { Primitive } from './misc';
import { Scope } from './scope';
import { Session, SessionContext } from './session';
import { Severity } from './severity';
import { Span, SpanContext } from './span';
import { CustomSamplingContext, Transaction, TransactionContext } from './transaction';
import { User } from './user';
/**
 * Internal class used to make sure we always have the latest internal functions
 * working in case we have a version conflict.
 */
export interface Hub {
    /**
     * Checks if this hub's version is older than the given version.
     *
     * @param version A version number to compare to.
     * @return True if the given version is newer; otherwise false.
     *
     * @hidden
     */
    isOlderThan(version: number): boolean;
    /**
     * This binds the given client to the current scope.
     * @param client An SDK client (client) instance.
     */
    bindClient(client?: Client): void;
    /**
     * Create a new scope to store context information.
     *
     * The scope will be layered on top of the current one. It is isolated, i.e. all
     * breadcrumbs and context information added to this scope will be removed once
     * the scope ends. Be sure to always remove this scope with {@link this.popScope}
     * when the operation finishes or throws.
     *
     * @returns Scope, the new cloned scope
     */
    pushScope(): Scope;
    /**
     * Removes a previously pushed scope from the stack.
     *
     * This restores the state before the scope was pushed. All breadcrumbs and
     * context information added since the last call to {@link this.pushScope} are
     * discarded.
     */
    popScope(): boolean;
    /**
     * Creates a new scope with and executes the given operation within.
     * The scope is automatically removed once the operation
     * finishes or throws.
     *
     * This is essentially a convenience function for:
     *
     *     pushScope();
     *     callback();
     *     popScope();
     *
     * @param callback that will be enclosed into push/popScope.
     */
    withScope(callback: (scope: Scope) => void): void;
    /** Returns the client of the top stack. */
    getClient(): Client | undefined;
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @param hint May contain additional information about the original exception.
     * @returns The generated eventId.
     */
    captureException(exception: any, hint?: EventHint): string;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param level Define the level of the message.
     * @param hint May contain additional information about the original exception.
     * @returns The generated eventId.
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint): string;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     */
    captureEvent(event: Event, hint?: EventHint): string;
    /**
     * This is the getter for lastEventId.
     *
     * @returns The last event id of a captured event.
     */
    lastEventId(): string | undefined;
    /**
     * Records a new breadcrumb which will be attached to future events.
     *
     * Breadcrumbs will be added to subsequent events to provide more context on
     * user's actions prior to an error or crash.
     *
     * @param breadcrumb The breadcrumb to record.
     * @param hint May contain additional information about the original breadcrumb.
     */
    addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    setUser(user: User | null): void;
    /**
     * Set an object that will be merged sent as tags data with the event.
     *
     * @param tags Tags context object to merge into current context.
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): void;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    setTag(key: string, value: Primitive): void;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    setExtra(key: string, extra: Extra): void;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    setExtras(extras: Extras): void;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context Any kind of data. This data will be normalized.
     */
    setContext(name: string, context: {
        [key: string]: any;
    } | null): void;
    /**
     * Callback to set context information onto the scope.
     *
     * @param callback Callback function that receives Scope.
     */
    configureScope(callback: (scope: Scope) => void): void;
    /**
     * For the duration of the callback, this hub will be set as the global current Hub.
     * This function is useful if you want to run your own client and hook into an already initialized one
     * e.g.: Reporting issues to your own sentry when running in your component while still using the users configuration.
     */
    run(callback: (hub: Hub) => void): void;
    /** Returns the integration if installed on the current client. */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** Returns all trace headers that are currently on the top scope. */
    traceHeaders(): {
        [key: string]: string;
    };
    /**
     * @deprecated No longer does anything. Use use {@link Transaction.startChild} instead.
     */
    startSpan(context: SpanContext): Span;
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     */
    startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
    /**
     * Starts a new `Session`, sets on the current scope and returns it.
     *
     * To finish a `session`, it has to be passed directly to `client.captureSession`, which is done automatically
     * when using `hub.endSession()` for the session currently stored on the scope.
     *
     * When there's already an existing session on the scope, it'll be automatically ended.
     *
     * @param context Optional properties of the new `Session`.
     *
     * @returns The session which was just started
     */
    startSession(context?: SessionContext): Session;
    /**
     * Ends the session that lives on the current scope and sends it to Sentry
     */
    endSession(): void;
    /**
     * Sends the current session on the scope to Sentry
     * @param endSession If set the session will be marked as exited and removed from the scope
     */
    captureSession(endSession?: boolean): void;
}
//# sourceMappingURL=hub.d.ts.map{"version":3,"file":"hub.d.ts","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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"}//# sourceMappingURL=hub.js.map{"version":3,"file":"hub.js","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb, BreadcrumbHint } from './breadcrumb';\nimport { Client } from './client';\nimport { Event, EventHint } from './event';\nimport { Extra, Extras } from './extra';\nimport { Integration, IntegrationClass } from './integration';\nimport { Primitive } from './misc';\nimport { Scope } from './scope';\nimport { Session, SessionContext } from './session';\nimport { Severity } from './severity';\nimport { Span, SpanContext } from './span';\nimport { CustomSamplingContext, Transaction, TransactionContext } from './transaction';\nimport { User } from './user';\n\n/**\n * Internal class used to make sure we always have the latest internal functions\n * working in case we have a version conflict.\n */\nexport interface Hub {\n  /**\n   * Checks if this hub's version is older than the given version.\n   *\n   * @param version A version number to compare to.\n   * @return True if the given version is newer; otherwise false.\n   *\n   * @hidden\n   */\n  isOlderThan(version: number): boolean;\n\n  /**\n   * This binds the given client to the current scope.\n   * @param client An SDK client (client) instance.\n   */\n  bindClient(client?: Client): void;\n\n  /**\n   * Create a new scope to store context information.\n   *\n   * The scope will be layered on top of the current one. It is isolated, i.e. all\n   * breadcrumbs and context information added to this scope will be removed once\n   * the scope ends. Be sure to always remove this scope with {@link this.popScope}\n   * when the operation finishes or throws.\n   *\n   * @returns Scope, the new cloned scope\n   */\n  pushScope(): Scope;\n\n  /**\n   * Removes a previously pushed scope from the stack.\n   *\n   * This restores the state before the scope was pushed. All breadcrumbs and\n   * context information added since the last call to {@link this.pushScope} are\n   * discarded.\n   */\n  popScope(): boolean;\n\n  /**\n   * Creates a new scope with and executes the given operation within.\n   * The scope is automatically removed once the operation\n   * finishes or throws.\n   *\n   * This is essentially a convenience function for:\n   *\n   *     pushScope();\n   *     callback();\n   *     popScope();\n   *\n   * @param callback that will be enclosed into push/popScope.\n   */\n  withScope(callback: (scope: Scope) => void): void;\n\n  /** Returns the client of the top stack. */\n  getClient(): Client | undefined;\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * @param exception An exception-like object.\n   * @param hint May contain additional information about the original exception.\n   * @returns The generated eventId.\n   */\n  captureException(exception: any, hint?: EventHint): string;\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * @param message The message to send to Sentry.\n   * @param level Define the level of the message.\n   * @param hint May contain additional information about the original exception.\n   * @returns The generated eventId.\n   */\n  captureMessage(message: string, level?: Severity, hint?: EventHint): string;\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   */\n  captureEvent(event: Event, hint?: EventHint): string;\n\n  /**\n   * This is the getter for lastEventId.\n   *\n   * @returns The last event id of a captured event.\n   */\n  lastEventId(): string | undefined;\n\n  /**\n   * Records a new breadcrumb which will be attached to future events.\n   *\n   * Breadcrumbs will be added to subsequent events to provide more context on\n   * user's actions prior to an error or crash.\n   *\n   * @param breadcrumb The breadcrumb to record.\n   * @param hint May contain additional information about the original breadcrumb.\n   */\n  addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;\n\n  /**\n   * Updates user context information for future events.\n   *\n   * @param user User context object to be set in the current context. Pass `null` to unset the user.\n   */\n  setUser(user: User | null): void;\n\n  /**\n   * Set an object that will be merged sent as tags data with the event.\n   *\n   * @param tags Tags context object to merge into current context.\n   */\n  setTags(tags: { [key: string]: Primitive }): void;\n\n  /**\n   * Set key:value that will be sent as tags data with the event.\n   *\n   * Can also be used to unset a tag, by passing `undefined`.\n   *\n   * @param key String key of tag\n   * @param value Value of tag\n   */\n  setTag(key: string, value: Primitive): void;\n\n  /**\n   * Set key:value that will be sent as extra data with the event.\n   * @param key String of extra\n   * @param extra Any kind of data. This data will be normalized.\n   */\n  setExtra(key: string, extra: Extra): void;\n\n  /**\n   * Set an object that will be merged sent as extra data with the event.\n   * @param extras Extras object to merge into current context.\n   */\n  setExtras(extras: Extras): void;\n\n  /**\n   * Sets context data with the given name.\n   * @param name of the context\n   * @param context Any kind of data. This data will be normalized.\n   */\n  setContext(name: string, context: { [key: string]: any } | null): void;\n\n  /**\n   * Callback to set context information onto the scope.\n   *\n   * @param callback Callback function that receives Scope.\n   */\n  configureScope(callback: (scope: Scope) => void): void;\n\n  /**\n   * For the duration of the callback, this hub will be set as the global current Hub.\n   * This function is useful if you want to run your own client and hook into an already initialized one\n   * e.g.: Reporting issues to your own sentry when running in your component while still using the users configuration.\n   */\n  run(callback: (hub: Hub) => void): void;\n\n  /** Returns the integration if installed on the current client. */\n  getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;\n\n  /** Returns all trace headers that are currently on the top scope. */\n  traceHeaders(): { [key: string]: string };\n\n  /**\n   * @deprecated No longer does anything. Use use {@link Transaction.startChild} instead.\n   */\n  startSpan(context: SpanContext): Span;\n\n  /**\n   * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n   *\n   * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n   * new child span within the transaction or any span, call the respective `.startChild()` method.\n   *\n   * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n   *\n   * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n   * finished child spans will be sent to Sentry.\n   *\n   * @param context Properties of the new `Transaction`.\n   * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n   * default values). See {@link Options.tracesSampler}.\n   *\n   * @returns The transaction which was just started\n   */\n  startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;\n\n  /**\n   * Starts a new `Session`, sets on the current scope and returns it.\n   *\n   * To finish a `session`, it has to be passed directly to `client.captureSession`, which is done automatically\n   * when using `hub.endSession()` for the session currently stored on the scope.\n   *\n   * When there's already an existing session on the scope, it'll be automatically ended.\n   *\n   * @param context Optional properties of the new `Session`.\n   *\n   * @returns The session which was just started\n   */\n  startSession(context?: SessionContext): Session;\n\n  /**\n   * Ends the session that lives on the current scope and sends it to Sentry\n   */\n  endSession(): void;\n\n  /**\n   * Sends the current session on the scope to Sentry\n   * @param endSession If set the session will be marked as exited and removed from the scope\n   */\n  captureSession(endSession?: boolean): void;\n}\n"]}export { Breadcrumb, BreadcrumbHint } from './breadcrumb';
export { Client } from './client';
export { ClientReport } from './clientreport';
export { Context, Contexts } from './context';
export { DsnComponents, DsnLike, DsnProtocol } from './dsn';
export { DebugImage, DebugImageType, DebugMeta } from './debugMeta';
export { AttachmentItem, BaseEnvelopeHeaders, BaseEnvelopeItemHeaders, ClientReportEnvelope, ClientReportItem, Envelope, EventEnvelope, EventItem, SessionEnvelope, SessionItem, UserFeedbackItem, } from './envelope';
export { ExtendedError } from './error';
export { Event, EventHint } from './event';
export { EventStatus } from './eventstatus';
export { EventProcessor } from './eventprocessor';
export { Exception } from './exception';
export { Extra, Extras } from './extra';
export { Hub } from './hub';
export { Integration, IntegrationClass } from './integration';
export { Mechanism } from './mechanism';
export { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';
export { Options } from './options';
export { Package } from './package';
export { QueryParams, Request, SentryRequest, SentryRequestType } from './request';
export { Response } from './response';
export { Runtime } from './runtime';
export { CaptureContext, Scope, ScopeContext } from './scope';
export { SdkInfo } from './sdkinfo';
export { SdkMetadata } from './sdkmetadata';
export { SessionAggregates, AggregationCounts, Session, SessionContext, SessionStatus, RequestSession, RequestSessionStatus, SessionFlusherLike, } from './session';
export { Severity } from './severity';
export { SeverityLevel, SeverityLevels } from './severity';
export { Span, SpanContext } from './span';
export { StackFrame } from './stackframe';
export { Stacktrace } from './stacktrace';
export { CustomSamplingContext, Measurements, SamplingContext, TraceparentData, Transaction, TransactionContext, TransactionMetadata, TransactionSamplingMethod, } from './transaction';
export { Thread } from './thread';
export { Outcome, Transport, TransportOptions, TransportClass } from './transport';
export { User, UserFeedback } from './user';
export { WrappedFunction } from './wrappedfunction';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AAC5D,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACpE,OAAO,EACL,cAAc,EACd,mBAAmB,EACnB,uBAAuB,EACvB,oBAAoB,EACpB,gBAAgB,EAChB,QAAQ,EACR,aAAa,EACb,SAAS,EACT,eAAe,EACf,WAAW,EACX,gBAAgB,GACjB,MAAM,YAAY,CAAC;AACpB,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAC5B,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,wBAAwB,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAC7E,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AACnF,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,KAAK,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EACL,iBAAiB,EACjB,iBAAiB,EACjB,OAAO,EACP,cAAc,EACd,aAAa,EACb,cAAc,EACd,oBAAoB,EACpB,kBAAkB,GACnB,MAAM,WAAW,CAAC;AAEnB,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,aAAa,EAAE,cAAc,EAAE,MAAM,YAAY,CAAC;AAC3D,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAC3C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EACL,qBAAqB,EACrB,YAAY,EACZ,eAAe,EACf,eAAe,EACf,WAAW,EACX,kBAAkB,EAClB,mBAAmB,EACnB,yBAAyB,GAC1B,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,gBAAgB,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AACnF,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC"}export { Severity } from './severity';
export { SeverityLevels } from './severity';
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAgDA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAiB,cAAc,EAAE,MAAM,YAAY,CAAC","sourcesContent":["export { Breadcrumb, BreadcrumbHint } from './breadcrumb';\nexport { Client } from './client';\nexport { ClientReport } from './clientreport';\nexport { Context, Contexts } from './context';\nexport { DsnComponents, DsnLike, DsnProtocol } from './dsn';\nexport { DebugImage, DebugImageType, DebugMeta } from './debugMeta';\nexport {\n  AttachmentItem,\n  BaseEnvelopeHeaders,\n  BaseEnvelopeItemHeaders,\n  ClientReportEnvelope,\n  ClientReportItem,\n  Envelope,\n  EventEnvelope,\n  EventItem,\n  SessionEnvelope,\n  SessionItem,\n  UserFeedbackItem,\n} from './envelope';\nexport { ExtendedError } from './error';\nexport { Event, EventHint } from './event';\nexport { EventStatus } from './eventstatus';\nexport { EventProcessor } from './eventprocessor';\nexport { Exception } from './exception';\nexport { Extra, Extras } from './extra';\nexport { Hub } from './hub';\nexport { Integration, IntegrationClass } from './integration';\nexport { Mechanism } from './mechanism';\nexport { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';\nexport { Options } from './options';\nexport { Package } from './package';\nexport { QueryParams, Request, SentryRequest, SentryRequestType } from './request';\nexport { Response } from './response';\nexport { Runtime } from './runtime';\nexport { CaptureContext, Scope, ScopeContext } from './scope';\nexport { SdkInfo } from './sdkinfo';\nexport { SdkMetadata } from './sdkmetadata';\nexport {\n  SessionAggregates,\n  AggregationCounts,\n  Session,\n  SessionContext,\n  SessionStatus,\n  RequestSession,\n  RequestSessionStatus,\n  SessionFlusherLike,\n} from './session';\n\nexport { Severity } from './severity';\nexport { SeverityLevel, SeverityLevels } from './severity';\nexport { Span, SpanContext } from './span';\nexport { StackFrame } from './stackframe';\nexport { Stacktrace } from './stacktrace';\nexport {\n  CustomSamplingContext,\n  Measurements,\n  SamplingContext,\n  TraceparentData,\n  Transaction,\n  TransactionContext,\n  TransactionMetadata,\n  TransactionSamplingMethod,\n} from './transaction';\nexport { Thread } from './thread';\nexport { Outcome, Transport, TransportOptions, TransportClass } from './transport';\nexport { User, UserFeedback } from './user';\nexport { WrappedFunction } from './wrappedfunction';\n"]}import { EventProcessor } from './eventprocessor';
import { Hub } from './hub';
/** Integration Class Interface */
export interface IntegrationClass<T> {
    /**
     * Property that holds the integration name
     */
    id: string;
    new (...args: any[]): T;
}
/** Integration interface */
export interface Integration {
    /**
     * Returns {@link IntegrationClass.id}
     */
    name: string;
    /**
     * Sets the integration up only once.
     * This takes no options on purpose, options should be passed in the constructor
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
}
//# sourceMappingURL=integration.d.ts.map{"version":3,"file":"integration.d.ts","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAE5B,kCAAkC;AAClC,MAAM,WAAW,gBAAgB,CAAC,CAAC;IACjC;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX,KAAK,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;CACzB;AAED,4BAA4B;AAC5B,MAAM,WAAW,WAAW;IAC1B;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;OAGG;IACH,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI,CAAC;CACxG"}//# sourceMappingURL=integration.js.map{"version":3,"file":"integration.js","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"","sourcesContent":["import { EventProcessor } from './eventprocessor';\nimport { Hub } from './hub';\n\n/** Integration Class Interface */\nexport interface IntegrationClass<T> {\n  /**\n   * Property that holds the integration name\n   */\n  id: string;\n\n  new (...args: any[]): T;\n}\n\n/** Integration interface */\nexport interface Integration {\n  /**\n   * Returns {@link IntegrationClass.id}\n   */\n  name: string;\n\n  /**\n   * Sets the integration up only once.\n   * This takes no options on purpose, options should be passed in the constructor\n   */\n  setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;\n}\n"]}/**
 * Metadata about a captured exception, intended to provide a hint as to the means by which it was captured.
 */
export interface Mechanism {
    /**
     * For now, restricted to `onerror`, `onunhandledrejection` (both obvious), `instrument` (the result of
     * auto-instrumentation), and `generic` (everything else). Converted to a tag on ingest.
     */
    type: string;
    /**
     * In theory, whether or not the exception has been handled by the user. In practice, whether or not we see it before
     * it hits the global error/rejection handlers, whether through explicit handling by the user or auto instrumentation.
     * Converted to a tag on ingest and used in various ways in the UI.
     */
    handled: boolean;
    /**
     * Arbitrary data to be associated with the mechanism (for example, errors coming from event handlers include the
     * handler name and the event target. Will show up in the UI directly above the stacktrace.
     */
    data?: {
        [key: string]: string | boolean;
    };
    /**
     * True when `captureException` is called with anything other than an instance of `Error` (or, in the case of browser,
     * an instance of `ErrorEvent`, `DOMError`, or `DOMException`). causing us to create a synthetic error in an attempt
     * to recreate the stacktrace.
     */
    synthetic?: boolean;
}
//# sourceMappingURL=mechanism.d.ts.map{"version":3,"file":"mechanism.d.ts","sourceRoot":"","sources":["../../src/mechanism.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,WAAW,SAAS;IACxB;;;OAGG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;;OAIG;IACH,OAAO,EAAE,OAAO,CAAC;IAEjB;;;OAGG;IACH,IAAI,CAAC,EAAE;QACL,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;KACjC,CAAC;IAEF;;;;OAIG;IACH,SAAS,CAAC,EAAE,OAAO,CAAC;CACrB"}//# sourceMappingURL=mechanism.js.map{"version":3,"file":"mechanism.js","sourceRoot":"","sources":["../../src/mechanism.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Metadata about a captured exception, intended to provide a hint as to the means by which it was captured.\n */\nexport interface Mechanism {\n  /**\n   * For now, restricted to `onerror`, `onunhandledrejection` (both obvious), `instrument` (the result of\n   * auto-instrumentation), and `generic` (everything else). Converted to a tag on ingest.\n   */\n  type: string;\n\n  /**\n   * In theory, whether or not the exception has been handled by the user. In practice, whether or not we see it before\n   * it hits the global error/rejection handlers, whether through explicit handling by the user or auto instrumentation.\n   * Converted to a tag on ingest and used in various ways in the UI.\n   */\n  handled: boolean;\n\n  /**\n   * Arbitrary data to be associated with the mechanism (for example, errors coming from event handlers include the\n   * handler name and the event target. Will show up in the UI directly above the stacktrace.\n   */\n  data?: {\n    [key: string]: string | boolean;\n  };\n\n  /**\n   * True when `captureException` is called with anything other than an instance of `Error` (or, in the case of browser,\n   * an instance of `ErrorEvent`, `DOMError`, or `DOMException`). causing us to create a synthetic error in an attempt\n   * to recreate the stacktrace.\n   */\n  synthetic?: boolean;\n}\n"]}import { QueryParams } from './request';
/**
 * Data extracted from an incoming request to a node server
 */
export interface ExtractedNodeRequestData {
    [key: string]: any;
    /** Specific headers from the request */
    headers?: {
        [key: string]: string;
    };
    /**  The request's method */
    method?: string;
    /** The request's URL, including query string */
    url?: string;
    /** String representing the cookies sent along with the request */
    cookies?: {
        [key: string]: string;
    };
    /** The request's query params */
    query_string?: QueryParams;
    /** Any data sent in the request's body, as a JSON string */
    data?: string;
}
/**
 * Location object on a service worker's `self` object.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WorkerLocation.
 */
export interface WorkerLocation {
    /** The protocol scheme of the URL of the script executed in the Worker, including the final ':'. */
    readonly protocol: string;
    /** The host, that is the hostname, a ':', and the port of the URL of the script executed in the Worker. */
    readonly host: string;
    /** The domain of the URL of the script executed in the Worker. */
    readonly hostname: string;
    /** The canonical form of the origin of the specific location. */
    readonly origin: string;
    /** The port number of the URL of the script executed in the Worker. */
    readonly port: string;
    /** The path of the URL of the script executed in the Worker, beginning with a '/'. */
    readonly pathname: string;
    /** The parameters (query string) of the URL of the script executed in the Worker, beginning with a '?'. */
    readonly search: string;
    /** The fragment identifier of the URL of the script executed in the Worker, beginning with a '#'. */
    readonly hash: string;
    /** Stringifier that returns the whole URL of the script executed in the Worker. */
    readonly href: string;
    /** Synonym for `href` attribute */
    toString(): string;
}
export declare type Primitive = number | string | boolean | bigint | symbol | null | undefined;
//# sourceMappingURL=misc.d.ts.map{"version":3,"file":"misc.d.ts","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC;;GAEG;AACH,MAAM,WAAW,wBAAwB;IACvC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IAEnB,wCAAwC;IACxC,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAEpC,4BAA4B;IAC5B,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB,gDAAgD;IAChD,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb,kEAAkE;IAClE,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAEpC,iCAAiC;IACjC,YAAY,CAAC,EAAE,WAAW,CAAC;IAE3B,4DAA4D;IAC5D,IAAI,CAAC,EAAE,MAAM,CAAC;CACf;AAED;;;;GAIG;AACH,MAAM,WAAW,cAAc;IAC7B,oGAAoG;IACpG,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,2GAA2G;IAC3G,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,kEAAkE;IAClE,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,iEAAiE;IACjE,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAExB,uEAAuE;IACvE,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,sFAAsF;IACtF,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,2GAA2G;IAC3G,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAExB,qGAAqG;IACrG,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,mFAAmF;IACnF,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,mCAAmC;IACnC,QAAQ,IAAI,MAAM,CAAC;CACpB;AAED,oBAAY,SAAS,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC"}//# sourceMappingURL=misc.js.map{"version":3,"file":"misc.js","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"","sourcesContent":["import { QueryParams } from './request';\n\n/**\n * Data extracted from an incoming request to a node server\n */\nexport interface ExtractedNodeRequestData {\n  [key: string]: any;\n\n  /** Specific headers from the request */\n  headers?: { [key: string]: string };\n\n  /**  The request's method */\n  method?: string;\n\n  /** The request's URL, including query string */\n  url?: string;\n\n  /** String representing the cookies sent along with the request */\n  cookies?: { [key: string]: string };\n\n  /** The request's query params */\n  query_string?: QueryParams;\n\n  /** Any data sent in the request's body, as a JSON string */\n  data?: string;\n}\n\n/**\n * Location object on a service worker's `self` object.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/WorkerLocation.\n */\nexport interface WorkerLocation {\n  /** The protocol scheme of the URL of the script executed in the Worker, including the final ':'. */\n  readonly protocol: string;\n\n  /** The host, that is the hostname, a ':', and the port of the URL of the script executed in the Worker. */\n  readonly host: string;\n\n  /** The domain of the URL of the script executed in the Worker. */\n  readonly hostname: string;\n\n  /** The canonical form of the origin of the specific location. */\n  readonly origin: string;\n\n  /** The port number of the URL of the script executed in the Worker. */\n  readonly port: string;\n\n  /** The path of the URL of the script executed in the Worker, beginning with a '/'. */\n  readonly pathname: string;\n\n  /** The parameters (query string) of the URL of the script executed in the Worker, beginning with a '?'. */\n  readonly search: string;\n\n  /** The fragment identifier of the URL of the script executed in the Worker, beginning with a '#'. */\n  readonly hash: string;\n\n  /** Stringifier that returns the whole URL of the script executed in the Worker. */\n  readonly href: string;\n\n  /** Synonym for `href` attribute */\n  toString(): string;\n}\n\nexport type Primitive = number | string | boolean | bigint | symbol | null | undefined;\n"]}import { Breadcrumb, BreadcrumbHint } from './breadcrumb';
import { Event, EventHint } from './event';
import { Integration } from './integration';
import { CaptureContext } from './scope';
import { SdkMetadata } from './sdkmetadata';
import { SamplingContext } from './transaction';
import { Transport, TransportClass, TransportOptions } from './transport';
/** Base configuration options for every SDK. */
export interface Options {
    /**
     * Enable debug functionality in the SDK itself
     */
    debug?: boolean;
    /**
     * Specifies whether this SDK should send events to Sentry.
     * Defaults to true.
     */
    enabled?: boolean;
    /**
     * The Dsn used to connect to Sentry and identify the project. If omitted, the
     * SDK will not send any data to Sentry.
     */
    dsn?: string;
    /**
     * If this is set to false, default integrations will not be added, otherwise this will internally be set to the
     * recommended default integrations.
     * TODO: We should consider changing this to `boolean | Integration[]`
     */
    defaultIntegrations?: false | Integration[];
    /**
     * List of integrations that should be installed after SDK was initialized.
     * Accepts either a list of integrations or a function that receives
     * default integrations and returns a new, updated list.
     */
    integrations?: Integration[] | ((integrations: Integration[]) => Integration[]);
    /**
     * A pattern for error messages which should not be sent to Sentry.
     * By default, all errors will be sent.
     */
    ignoreErrors?: Array<string | RegExp>;
    /**
     * Transport object that should be used to send events to Sentry
     */
    transport?: TransportClass<Transport>;
    /**
     * Options for the default transport that the SDK uses.
     */
    transportOptions?: TransportOptions;
    /**
     * A URL to an envelope tunnel endpoint. An envelope tunnel is an HTTP endpoint
     * that accepts Sentry envelopes for forwarding. This can be used to force data
     * through a custom server independent of the type of data.
     */
    tunnel?: string;
    /**
     * The release identifier used when uploading respective source maps. Specify
     * this value to allow Sentry to resolve the correct source maps when
     * processing events.
     */
    release?: string;
    /** The current environment of your application (e.g. "production"). */
    environment?: string;
    /** Sets the distribution for all events */
    dist?: string;
    /**
     * The maximum number of breadcrumbs sent with events. Defaults to 100.
     * Values over 100 will be ignored and 100 used instead.
     */
    maxBreadcrumbs?: number;
    /** A global sample rate to apply to all events (0 - 1). */
    sampleRate?: number;
    /** Attaches stacktraces to pure capture message / log integrations */
    attachStacktrace?: boolean;
    /** Maximum number of chars a single value can have before it will be truncated. */
    maxValueLength?: number;
    /**
     * Maximum number of levels that normalization algorithm will traverse in objects and arrays.
     * Used when normalizing an event before sending, on all of the listed attributes:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * Defaults to `3`. Set to `0` to disable.
     */
    normalizeDepth?: number;
    /**
     * Maximum number of properties or elements that the normalization algorithm will output in any single array or object included in the normalized event.
     * Used when normalizing an event before sending, on all of the listed attributes:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * Defaults to `1000`
     */
    normalizeMaxBreadth?: number;
    /**
     * Controls how many milliseconds to wait before shutting down. The default is
     * SDK-specific but typically around 2 seconds. Setting this too low can cause
     * problems for sending events from command line applications. Setting it too
     * high can cause the application to block for users with network connectivity
     * problems.
     */
    shutdownTimeout?: number;
    /**
     * Sample rate to determine trace sampling.
     *
     * 0.0 = 0% chance of a given trace being sent (send no traces) 1.0 = 100% chance of a given trace being sent (send
     * all traces)
     *
     * Tracing is enabled if either this or `tracesSampler` is defined. If both are defined, `tracesSampleRate` is
     * ignored.
     */
    tracesSampleRate?: number;
    /**
     * A flag enabling Sessions Tracking feature.
     * By default, Sessions Tracking is enabled.
     */
    autoSessionTracking?: boolean;
    /**
     * Send SDK Client Reports.
     * By default, Client Reports are enabled.
     */
    sendClientReports?: boolean;
    /**
     * Initial data to populate scope.
     */
    initialScope?: CaptureContext;
    /**
     * Set of metadata about the SDK that can be internally used to enhance envelopes and events,
     * and provide additional data about every request.
     * */
    _metadata?: SdkMetadata;
    /**
     * Options which are in beta, or otherwise not guaranteed to be stable.
     */
    _experiments?: {
        [key: string]: any;
    };
    /**
     * Function to compute tracing sample rate dynamically and filter unwanted traces.
     *
     * Tracing is enabled if either this or `tracesSampleRate` is defined. If both are defined, `tracesSampleRate` is
     * ignored.
     *
     * Will automatically be passed a context object of default and optional custom data. See
     * {@link Transaction.samplingContext} and {@link Hub.startTransaction}.
     *
     * @returns A sample rate between 0 and 1 (0 drops the trace, 1 guarantees it will be sent). Returning `true` is
     * equivalent to returning 1 and returning `false` is equivalent to returning 0.
     */
    tracesSampler?: (samplingContext: SamplingContext) => number | boolean;
    /**
     * A callback invoked during event submission, allowing to optionally modify
     * the event before it is sent to Sentry.
     *
     * Note that you must return a valid event from this callback. If you do not
     * wish to modify the event, simply return it at the end.
     * Returning null will cause the event to be dropped.
     *
     * @param event The error or message event generated by the SDK.
     * @param hint May contain additional information about the original exception.
     * @returns A new event that will be sent | null.
     */
    beforeSend?: (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;
    /**
     * A callback invoked when adding a breadcrumb, allowing to optionally modify
     * it before adding it to future events.
     *
     * Note that you must return a valid breadcrumb from this callback. If you do
     * not wish to modify the breadcrumb, simply return it at the end.
     * Returning null will cause the breadcrumb to be dropped.
     *
     * @param breadcrumb The breadcrumb as created by the SDK.
     * @returns The breadcrumb that will be added | null.
     */
    beforeBreadcrumb?: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => Breadcrumb | null;
}
//# sourceMappingURL=options.d.ts.map{"version":3,"file":"options.d.ts","sourceRoot":"","sources":["../../src/options.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAChD,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAE1E,gDAAgD;AAChD,MAAM,WAAW,OAAO;IACtB;;OAEG;IACH,KAAK,CAAC,EAAE,OAAO,CAAC;IAEhB;;;OAGG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;;OAGG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;;;OAIG;IACH,mBAAmB,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,CAAC;IAE5C;;;;OAIG;IACH,YAAY,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC,YAAY,EAAE,WAAW,EAAE,KAAK,WAAW,EAAE,CAAC,CAAC;IAEhF;;;OAGG;IACH,YAAY,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IAEtC;;OAEG;IACH,SAAS,CAAC,EAAE,cAAc,CAAC,SAAS,CAAC,CAAC;IAEtC;;OAEG;IACH,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;IAEpC;;;;OAIG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;;;OAIG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB,uEAAuE;IACvE,WAAW,CAAC,EAAE,MAAM,CAAC;IAErB,2CAA2C;IAC3C,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;;OAGG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB,2DAA2D;IAC3D,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,sEAAsE;IACtE,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAE3B,mFAAmF;IACnF,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;;;;;;;OAQG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;;;;;;;OAQG;IACH,mBAAmB,CAAC,EAAE,MAAM,CAAC;IAE7B;;;;;;OAMG;IACH,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB;;;;;;;;OAQG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;;OAGG;IACH,mBAAmB,CAAC,EAAE,OAAO,CAAC;IAE9B;;;OAGG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAE5B;;OAEG;IACH,YAAY,CAAC,EAAE,cAAc,CAAC;IAE9B;;;SAGK;IACL,SAAS,CAAC,EAAE,WAAW,CAAC;IAExB;;OAEG;IACH,YAAY,CAAC,EAAE;QACb,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;KACpB,CAAC;IAEF;;;;;;;;;;;OAWG;IACH,aAAa,CAAC,EAAE,CAAC,eAAe,EAAE,eAAe,KAAK,MAAM,GAAG,OAAO,CAAC;IAEvE;;;;;;;;;;;OAWG;IACH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,KAAK,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC;IAE1F;;;;;;;;;;OAUG;IACH,gBAAgB,CAAC,EAAE,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,EAAE,cAAc,KAAK,UAAU,GAAG,IAAI,CAAC;CACzF"}//# sourceMappingURL=options.js.map{"version":3,"file":"options.js","sourceRoot":"","sources":["../../src/options.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb, BreadcrumbHint } from './breadcrumb';\nimport { Event, EventHint } from './event';\nimport { Integration } from './integration';\nimport { CaptureContext } from './scope';\nimport { SdkMetadata } from './sdkmetadata';\nimport { SamplingContext } from './transaction';\nimport { Transport, TransportClass, TransportOptions } from './transport';\n\n/** Base configuration options for every SDK. */\nexport interface Options {\n  /**\n   * Enable debug functionality in the SDK itself\n   */\n  debug?: boolean;\n\n  /**\n   * Specifies whether this SDK should send events to Sentry.\n   * Defaults to true.\n   */\n  enabled?: boolean;\n\n  /**\n   * The Dsn used to connect to Sentry and identify the project. If omitted, the\n   * SDK will not send any data to Sentry.\n   */\n  dsn?: string;\n\n  /**\n   * If this is set to false, default integrations will not be added, otherwise this will internally be set to the\n   * recommended default integrations.\n   * TODO: We should consider changing this to `boolean | Integration[]`\n   */\n  defaultIntegrations?: false | Integration[];\n\n  /**\n   * List of integrations that should be installed after SDK was initialized.\n   * Accepts either a list of integrations or a function that receives\n   * default integrations and returns a new, updated list.\n   */\n  integrations?: Integration[] | ((integrations: Integration[]) => Integration[]);\n\n  /**\n   * A pattern for error messages which should not be sent to Sentry.\n   * By default, all errors will be sent.\n   */\n  ignoreErrors?: Array<string | RegExp>;\n\n  /**\n   * Transport object that should be used to send events to Sentry\n   */\n  transport?: TransportClass<Transport>;\n\n  /**\n   * Options for the default transport that the SDK uses.\n   */\n  transportOptions?: TransportOptions;\n\n  /**\n   * A URL to an envelope tunnel endpoint. An envelope tunnel is an HTTP endpoint\n   * that accepts Sentry envelopes for forwarding. This can be used to force data\n   * through a custom server independent of the type of data.\n   */\n  tunnel?: string;\n\n  /**\n   * The release identifier used when uploading respective source maps. Specify\n   * this value to allow Sentry to resolve the correct source maps when\n   * processing events.\n   */\n  release?: string;\n\n  /** The current environment of your application (e.g. \"production\"). */\n  environment?: string;\n\n  /** Sets the distribution for all events */\n  dist?: string;\n\n  /**\n   * The maximum number of breadcrumbs sent with events. Defaults to 100.\n   * Values over 100 will be ignored and 100 used instead.\n   */\n  maxBreadcrumbs?: number;\n\n  /** A global sample rate to apply to all events (0 - 1). */\n  sampleRate?: number;\n\n  /** Attaches stacktraces to pure capture message / log integrations */\n  attachStacktrace?: boolean;\n\n  /** Maximum number of chars a single value can have before it will be truncated. */\n  maxValueLength?: number;\n\n  /**\n   * Maximum number of levels that normalization algorithm will traverse in objects and arrays.\n   * Used when normalizing an event before sending, on all of the listed attributes:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * Defaults to `3`. Set to `0` to disable.\n   */\n  normalizeDepth?: number;\n\n  /**\n   * Maximum number of properties or elements that the normalization algorithm will output in any single array or object included in the normalized event.\n   * Used when normalizing an event before sending, on all of the listed attributes:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * Defaults to `1000`\n   */\n  normalizeMaxBreadth?: number;\n\n  /**\n   * Controls how many milliseconds to wait before shutting down. The default is\n   * SDK-specific but typically around 2 seconds. Setting this too low can cause\n   * problems for sending events from command line applications. Setting it too\n   * high can cause the application to block for users with network connectivity\n   * problems.\n   */\n  shutdownTimeout?: number;\n\n  /**\n   * Sample rate to determine trace sampling.\n   *\n   * 0.0 = 0% chance of a given trace being sent (send no traces) 1.0 = 100% chance of a given trace being sent (send\n   * all traces)\n   *\n   * Tracing is enabled if either this or `tracesSampler` is defined. If both are defined, `tracesSampleRate` is\n   * ignored.\n   */\n  tracesSampleRate?: number;\n\n  /**\n   * A flag enabling Sessions Tracking feature.\n   * By default, Sessions Tracking is enabled.\n   */\n  autoSessionTracking?: boolean;\n\n  /**\n   * Send SDK Client Reports.\n   * By default, Client Reports are enabled.\n   */\n  sendClientReports?: boolean;\n\n  /**\n   * Initial data to populate scope.\n   */\n  initialScope?: CaptureContext;\n\n  /**\n   * Set of metadata about the SDK that can be internally used to enhance envelopes and events,\n   * and provide additional data about every request.\n   * */\n  _metadata?: SdkMetadata;\n\n  /**\n   * Options which are in beta, or otherwise not guaranteed to be stable.\n   */\n  _experiments?: {\n    [key: string]: any;\n  };\n\n  /**\n   * Function to compute tracing sample rate dynamically and filter unwanted traces.\n   *\n   * Tracing is enabled if either this or `tracesSampleRate` is defined. If both are defined, `tracesSampleRate` is\n   * ignored.\n   *\n   * Will automatically be passed a context object of default and optional custom data. See\n   * {@link Transaction.samplingContext} and {@link Hub.startTransaction}.\n   *\n   * @returns A sample rate between 0 and 1 (0 drops the trace, 1 guarantees it will be sent). Returning `true` is\n   * equivalent to returning 1 and returning `false` is equivalent to returning 0.\n   */\n  tracesSampler?: (samplingContext: SamplingContext) => number | boolean;\n\n  /**\n   * A callback invoked during event submission, allowing to optionally modify\n   * the event before it is sent to Sentry.\n   *\n   * Note that you must return a valid event from this callback. If you do not\n   * wish to modify the event, simply return it at the end.\n   * Returning null will cause the event to be dropped.\n   *\n   * @param event The error or message event generated by the SDK.\n   * @param hint May contain additional information about the original exception.\n   * @returns A new event that will be sent | null.\n   */\n  beforeSend?: (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;\n\n  /**\n   * A callback invoked when adding a breadcrumb, allowing to optionally modify\n   * it before adding it to future events.\n   *\n   * Note that you must return a valid breadcrumb from this callback. If you do\n   * not wish to modify the breadcrumb, simply return it at the end.\n   * Returning null will cause the breadcrumb to be dropped.\n   *\n   * @param breadcrumb The breadcrumb as created by the SDK.\n   * @returns The breadcrumb that will be added | null.\n   */\n  beforeBreadcrumb?: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => Breadcrumb | null;\n}\n"]}/** JSDoc */
export interface Package {
    name: string;
    version: string;
}
//# sourceMappingURL=package.d.ts.map{"version":3,"file":"package.d.ts","sourceRoot":"","sources":["../../src/package.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,OAAO;IACtB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;CACjB"}//# sourceMappingURL=package.js.map{"version":3,"file":"package.js","sourceRoot":"","sources":["../../src/package.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface Package {\n  name: string;\n  version: string;\n}\n"]}/** Possible SentryRequest types that can be used to make a distinction between Sentry features */
export declare type SentryRequestType = 'event' | 'transaction' | 'session' | 'attachment';
/** A generic client request. */
export interface SentryRequest {
    body: string;
    type: SentryRequestType;
    url: string;
}
/** Request data included in an event as sent to Sentry */
export interface Request {
    url?: string;
    method?: string;
    data?: any;
    query_string?: QueryParams;
    cookies?: {
        [key: string]: string;
    };
    env?: {
        [key: string]: string;
    };
    headers?: {
        [key: string]: string;
    };
}
export declare type QueryParams = string | {
    [key: string]: string;
} | Array<[string, string]>;
//# sourceMappingURL=request.d.ts.map{"version":3,"file":"request.d.ts","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"AAAA,kGAAkG;AAElG,oBAAY,iBAAiB,GAAG,OAAO,GAAG,aAAa,GAAG,SAAS,GAAG,YAAY,CAAC;AAEnF,gCAAgC;AAChC,MAAM,WAAW,aAAa;IAC5B,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,iBAAiB,CAAC;IACxB,GAAG,EAAE,MAAM,CAAC;CACb;AAED,0DAA0D;AAC1D,MAAM,WAAW,OAAO;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,GAAG,CAAC;IACX,YAAY,CAAC,EAAE,WAAW,CAAC;IAC3B,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,GAAG,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAChC,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;CACrC;AAED,oBAAY,WAAW,GAAG,MAAM,GAAG;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;CAAE,GAAG,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC"}//# sourceMappingURL=request.js.map{"version":3,"file":"request.js","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"","sourcesContent":["/** Possible SentryRequest types that can be used to make a distinction between Sentry features */\n// NOTE(kamil): It would be nice if we make it a valid enum instead\nexport type SentryRequestType = 'event' | 'transaction' | 'session' | 'attachment';\n\n/** A generic client request. */\nexport interface SentryRequest {\n  body: string;\n  type: SentryRequestType;\n  url: string;\n}\n\n/** Request data included in an event as sent to Sentry */\nexport interface Request {\n  url?: string;\n  method?: string;\n  data?: any;\n  query_string?: QueryParams;\n  cookies?: { [key: string]: string };\n  env?: { [key: string]: string };\n  headers?: { [key: string]: string };\n}\n\nexport type QueryParams = string | { [key: string]: string } | Array<[string, string]>;\n"]}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type
 */
export declare enum RequestSessionStatus {
    /** JSDoc */
    Ok = "ok",
    /** JSDoc */
    Errored = "errored",
    /** JSDoc */
    Crashed = "crashed"
}
//# sourceMappingURL=requestsessionstatus.d.ts.map{"version":3,"file":"requestsessionstatus.d.ts","sourceRoot":"","sources":["../../src/requestsessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,oBAAoB;IAC9B,YAAY;IACZ,EAAE,OAAO;IACT,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,OAAO,YAAY;CACpB"}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type
 */
export var RequestSessionStatus;
(function (RequestSessionStatus) {
    /** JSDoc */
    RequestSessionStatus["Ok"] = "ok";
    /** JSDoc */
    RequestSessionStatus["Errored"] = "errored";
    /** JSDoc */
    RequestSessionStatus["Crashed"] = "crashed";
})(RequestSessionStatus || (RequestSessionStatus = {}));
//# sourceMappingURL=requestsessionstatus.js.map{"version":3,"file":"requestsessionstatus.js","sourceRoot":"","sources":["../../src/requestsessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,CAAN,IAAY,oBAOX;AAPD,WAAY,oBAAoB;IAC9B,YAAY;IACZ,iCAAS,CAAA;IACT,YAAY;IACZ,2CAAmB,CAAA;IACnB,YAAY;IACZ,2CAAmB,CAAA;AACrB,CAAC,EAPW,oBAAoB,KAApB,oBAAoB,QAO/B","sourcesContent":["/** JSDoc\n * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type\n */\nexport enum RequestSessionStatus {\n  /** JSDoc */\n  Ok = 'ok',\n  /** JSDoc */\n  Errored = 'errored',\n  /** JSDoc */\n  Crashed = 'crashed',\n}\n"]}import { Event, EventType } from './event';
import { EventStatus } from './eventstatus';
import { Session } from './session';
/** JSDoc */
export interface Response {
    status: EventStatus;
    event?: Event | Session;
    type?: EventType;
    reason?: string;
}
//# sourceMappingURL=response.d.ts.map{"version":3,"file":"response.d.ts","sourceRoot":"","sources":["../../src/response.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,YAAY;AACZ,MAAM,WAAW,QAAQ;IACvB,MAAM,EAAE,WAAW,CAAC;IACpB,KAAK,CAAC,EAAE,KAAK,GAAG,OAAO,CAAC;IACxB,IAAI,CAAC,EAAE,SAAS,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB"}//# sourceMappingURL=response.js.map{"version":3,"file":"response.js","sourceRoot":"","sources":["../../src/response.ts"],"names":[],"mappings":"","sourcesContent":["import { Event, EventType } from './event';\nimport { EventStatus } from './eventstatus';\nimport { Session } from './session';\n\n/** JSDoc */\nexport interface Response {\n  status: EventStatus;\n  event?: Event | Session;\n  type?: EventType;\n  reason?: string;\n}\n"]}/** Runtime Context. */
export interface Runtime {
    name?: string;
    version?: string;
}
//# sourceMappingURL=runtime.d.ts.map{"version":3,"file":"runtime.d.ts","sourceRoot":"","sources":["../../src/runtime.ts"],"names":[],"mappings":"AAAA,uBAAuB;AACvB,MAAM,WAAW,OAAO;IACtB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB"}//# sourceMappingURL=runtime.js.map{"version":3,"file":"runtime.js","sourceRoot":"","sources":["../../src/runtime.ts"],"names":[],"mappings":"","sourcesContent":["/** Runtime Context. */\nexport interface Runtime {\n  name?: string;\n  version?: string;\n}\n"]}import { Breadcrumb } from './breadcrumb';
import { Context, Contexts } from './context';
import { EventProcessor } from './eventprocessor';
import { Extra, Extras } from './extra';
import { Primitive } from './misc';
import { RequestSession, Session } from './session';
import { Severity } from './severity';
import { Span } from './span';
import { Transaction } from './transaction';
import { User } from './user';
/** JSDocs */
export declare type CaptureContext = Scope | Partial<ScopeContext> | ((scope: Scope) => Scope);
/** JSDocs */
export interface ScopeContext {
    user: User;
    level: Severity;
    extra: Extras;
    contexts: Contexts;
    tags: {
        [key: string]: Primitive;
    };
    fingerprint: string[];
    requestSession: RequestSession;
}
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be called by the client before an event is sent.
 */
export interface Scope {
    /** Add new event processor that will be called after {@link applyToEvent}. */
    addEventProcessor(callback: EventProcessor): this;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    setUser(user: User | null): this;
    /**
     * Returns the `User` if there is one
     */
    getUser(): User | undefined;
    /**
     * Set an object that will be merged sent as tags data with the event.
     * @param tags Tags context object to merge into current context.
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): this;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    setExtras(extras: Extras): this;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    setExtra(key: string, extra: Extra): this;
    /**
     * Sets the fingerprint on the scope to send with the events.
     * @param fingerprint string[] to group events in Sentry.
     */
    setFingerprint(fingerprint: string[]): this;
    /**
     * Sets the level on the scope for future events.
     * @param level string {@link Severity}
     */
    setLevel(level: Severity): this;
    /**
     * Sets the transaction name on the scope for future events.
     */
    setTransactionName(name?: string): this;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context an object containing context data. This data will be normalized. Pass `null` to unset the context.
     */
    setContext(name: string, context: Context | null): this;
    /**
     * Sets the Span on the scope.
     * @param span Span
     */
    setSpan(span?: Span): this;
    /**
     * Returns the `Span` if there is one
     */
    getSpan(): Span | undefined;
    /**
     * Returns the `Transaction` attached to the scope (if there is one)
     */
    getTransaction(): Transaction | undefined;
    /**
     * Returns the `Session` if there is one
     */
    getSession(): Session | undefined;
    /**
     * Sets the `Session` on the scope
     */
    setSession(session?: Session): this;
    /**
     * Returns the `RequestSession` if there is one
     */
    getRequestSession(): RequestSession | undefined;
    /**
     * Sets the `RequestSession` on the scope
     */
    setRequestSession(requestSession?: RequestSession): this;
    /**
     * Updates the scope with provided data. Can work in three variations:
     * - plain object containing updatable attributes
     * - Scope instance that'll extract the attributes from
     * - callback function that'll receive the current scope as an argument and allow for modifications
     * @param captureContext scope modifier to be used
     */
    update(captureContext?: CaptureContext): this;
    /** Clears the current scope and resets its properties. */
    clear(): this;
    /**
     * Sets the breadcrumbs in the scope
     * @param breadcrumbs Breadcrumb
     * @param maxBreadcrumbs number of max breadcrumbs to merged into event.
     */
    addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;
    /**
     * Clears all currently set Breadcrumbs.
     */
    clearBreadcrumbs(): this;
}
//# sourceMappingURL=scope.d.ts.map{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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"}//# sourceMappingURL=scope.js.map{"version":3,"file":"scope.js","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"","sourcesContent":["import { Breadcrumb } from './breadcrumb';\nimport { Context, Contexts } from './context';\nimport { EventProcessor } from './eventprocessor';\nimport { Extra, Extras } from './extra';\nimport { Primitive } from './misc';\nimport { RequestSession, Session } from './session';\nimport { Severity } from './severity';\nimport { Span } from './span';\nimport { Transaction } from './transaction';\nimport { User } from './user';\n\n/** JSDocs */\nexport type CaptureContext = Scope | Partial<ScopeContext> | ((scope: Scope) => Scope);\n\n/** JSDocs */\nexport interface ScopeContext {\n  user: User;\n  level: Severity;\n  extra: Extras;\n  contexts: Contexts;\n  tags: { [key: string]: Primitive };\n  fingerprint: string[];\n  requestSession: RequestSession;\n}\n\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be called by the client before an event is sent.\n */\nexport interface Scope {\n  /** Add new event processor that will be called after {@link applyToEvent}. */\n  addEventProcessor(callback: EventProcessor): this;\n\n  /**\n   * Updates user context information for future events.\n   *\n   * @param user User context object to be set in the current context. Pass `null` to unset the user.\n   */\n  setUser(user: User | null): this;\n\n  /**\n   * Returns the `User` if there is one\n   */\n  getUser(): User | undefined;\n\n  /**\n   * Set an object that will be merged sent as tags data with the event.\n   * @param tags Tags context object to merge into current context.\n   */\n  setTags(tags: { [key: string]: Primitive }): this;\n\n  /**\n   * Set key:value that will be sent as tags data with the event.\n   *\n   * Can also be used to unset a tag by passing `undefined`.\n   *\n   * @param key String key of tag\n   * @param value Value of tag\n   */\n  setTag(key: string, value: Primitive): this;\n\n  /**\n   * Set an object that will be merged sent as extra data with the event.\n   * @param extras Extras object to merge into current context.\n   */\n  setExtras(extras: Extras): this;\n\n  /**\n   * Set key:value that will be sent as extra data with the event.\n   * @param key String of extra\n   * @param extra Any kind of data. This data will be normalized.\n   */\n  setExtra(key: string, extra: Extra): this;\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param fingerprint string[] to group events in Sentry.\n   */\n  setFingerprint(fingerprint: string[]): this;\n\n  /**\n   * Sets the level on the scope for future events.\n   * @param level string {@link Severity}\n   */\n  setLevel(level: Severity): this;\n\n  /**\n   * Sets the transaction name on the scope for future events.\n   */\n  setTransactionName(name?: string): this;\n\n  /**\n   * Sets context data with the given name.\n   * @param name of the context\n   * @param context an object containing context data. This data will be normalized. Pass `null` to unset the context.\n   */\n  setContext(name: string, context: Context | null): this;\n\n  /**\n   * Sets the Span on the scope.\n   * @param span Span\n   */\n  setSpan(span?: Span): this;\n\n  /**\n   * Returns the `Span` if there is one\n   */\n  getSpan(): Span | undefined;\n\n  /**\n   * Returns the `Transaction` attached to the scope (if there is one)\n   */\n  getTransaction(): Transaction | undefined;\n\n  /**\n   * Returns the `Session` if there is one\n   */\n  getSession(): Session | undefined;\n\n  /**\n   * Sets the `Session` on the scope\n   */\n  setSession(session?: Session): this;\n\n  /**\n   * Returns the `RequestSession` if there is one\n   */\n  getRequestSession(): RequestSession | undefined;\n\n  /**\n   * Sets the `RequestSession` on the scope\n   */\n  setRequestSession(requestSession?: RequestSession): this;\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   * @param captureContext scope modifier to be used\n   */\n  update(captureContext?: CaptureContext): this;\n\n  /** Clears the current scope and resets its properties. */\n  clear(): this;\n\n  /**\n   * Sets the breadcrumbs in the scope\n   * @param breadcrumbs Breadcrumb\n   * @param maxBreadcrumbs number of max breadcrumbs to merged into event.\n   */\n  addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;\n\n  /**\n   * Clears all currently set Breadcrumbs.\n   */\n  clearBreadcrumbs(): this;\n}\n"]}import { Package } from './package';
export interface SdkInfo {
    name?: string;
    version?: string;
    integrations?: string[];
    packages?: Package[];
}
//# sourceMappingURL=sdkinfo.d.ts.map{"version":3,"file":"sdkinfo.d.ts","sourceRoot":"","sources":["../../src/sdkinfo.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,MAAM,WAAW,OAAO;IACtB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,QAAQ,CAAC,EAAE,OAAO,EAAE,CAAC;CACtB"}//# sourceMappingURL=sdkinfo.js.map{"version":3,"file":"sdkinfo.js","sourceRoot":"","sources":["../../src/sdkinfo.ts"],"names":[],"mappings":"","sourcesContent":["import { Package } from './package';\n\nexport interface SdkInfo {\n  name?: string;\n  version?: string;\n  integrations?: string[];\n  packages?: Package[];\n}\n"]}import { SdkInfo } from './sdkinfo';
export interface SdkMetadata {
    sdk?: SdkInfo;
}
//# sourceMappingURL=sdkmetadata.d.ts.map{"version":3,"file":"sdkmetadata.d.ts","sourceRoot":"","sources":["../../src/sdkmetadata.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,MAAM,WAAW,WAAW;IAC1B,GAAG,CAAC,EAAE,OAAO,CAAC;CACf"}//# sourceMappingURL=sdkmetadata.js.map{"version":3,"file":"sdkmetadata.js","sourceRoot":"","sources":["../../src/sdkmetadata.ts"],"names":[],"mappings":"","sourcesContent":["import { SdkInfo } from './sdkinfo';\n\nexport interface SdkMetadata {\n  sdk?: SdkInfo;\n}\n"]}import { User } from './user';
/**
 * @inheritdoc
 */
export interface Session extends SessionContext {
    /** JSDoc */
    update(context?: SessionContext): void;
    /** JSDoc */
    close(status?: SessionStatus): void;
    /** JSDoc */
    toJSON(): {
        init: boolean;
        sid: string;
        did?: string;
        timestamp: string;
        started: string;
        duration?: number;
        status: SessionStatus;
        errors: number;
        attrs?: {
            release?: string;
            environment?: string;
            user_agent?: string;
            ip_address?: string;
        };
    };
}
export interface RequestSession {
    status?: RequestSessionStatus;
}
/**
 * Session Context
 */
export interface SessionContext {
    sid?: string;
    did?: string;
    init?: boolean;
    timestamp?: number;
    started?: number;
    duration?: number;
    status?: SessionStatus;
    release?: string;
    environment?: string;
    userAgent?: string;
    ipAddress?: string;
    errors?: number;
    user?: User | null;
    ignoreDuration?: boolean;
}
export declare type SessionStatus = 'ok' | 'exited' | 'crashed' | 'abnormal';
export declare type RequestSessionStatus = 'ok' | 'errored' | 'crashed';
/** JSDoc */
export interface SessionAggregates {
    attrs?: {
        environment?: string;
        release?: string;
    };
    aggregates: Array<AggregationCounts>;
}
export interface SessionFlusherLike {
    /**
     * Increments the Session Status bucket in SessionAggregates Object corresponding to the status of the session
     * captured
     */
    incrementSessionStatusCount(): void;
    /** Submits the aggregates request mode sessions to Sentry */
    sendSessionAggregates(sessionAggregates: SessionAggregates): void;
    /** Empties Aggregate Buckets and Sends them to Transport Buffer */
    flush(): void;
    /** Clears setInterval and calls flush */
    close(): void;
}
export interface AggregationCounts {
    started: string;
    errored?: number;
    exited?: number;
    crashed?: number;
}
//# sourceMappingURL=session.d.ts.map{"version":3,"file":"session.d.ts","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B;;GAEG;AACH,MAAM,WAAW,OAAQ,SAAQ,cAAc;IAC7C,YAAY;IACZ,MAAM,CAAC,OAAO,CAAC,EAAE,cAAc,GAAG,IAAI,CAAC;IAEvC,YAAY;IACZ,KAAK,CAAC,MAAM,CAAC,EAAE,aAAa,GAAG,IAAI,CAAC;IAEpC,YAAY;IACZ,MAAM,IAAI;QACR,IAAI,EAAE,OAAO,CAAC;QACd,GAAG,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,MAAM,CAAC;QAClB,OAAO,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,MAAM,EAAE,aAAa,CAAC;QACtB,MAAM,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE;YACN,OAAO,CAAC,EAAE,MAAM,CAAC;YACjB,WAAW,CAAC,EAAE,MAAM,CAAC;YACrB,UAAU,CAAC,EAAE,MAAM,CAAC;YACpB,UAAU,CAAC,EAAE,MAAM,CAAC;SACrB,CAAC;KACH,CAAC;CACH;AAED,MAAM,WAAW,cAAc;IAC7B,MAAM,CAAC,EAAE,oBAAoB,CAAC;CAC/B;AAED;;GAEG;AACH,MAAM,WAAW,cAAc;IAC7B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,OAAO,CAAC;IAEf,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,aAAa,CAAC;IACvB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,IAAI,GAAG,IAAI,CAAC;IACnB,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B;AAED,oBAAY,aAAa,GAAG,IAAI,GAAG,QAAQ,GAAG,SAAS,GAAG,UAAU,CAAC;AACrE,oBAAY,oBAAoB,GAAG,IAAI,GAAG,SAAS,GAAG,SAAS,CAAC;AAEhE,YAAY;AACZ,MAAM,WAAW,iBAAiB;IAChC,KAAK,CAAC,EAAE;QACN,WAAW,CAAC,EAAE,MAAM,CAAC;QACrB,OAAO,CAAC,EAAE,MAAM,CAAC;KAClB,CAAC;IACF,UAAU,EAAE,KAAK,CAAC,iBAAiB,CAAC,CAAC;CACtC;AAED,MAAM,WAAW,kBAAkB;IACjC;;;OAGG;IACH,2BAA2B,IAAI,IAAI,CAAC;IAEpC,6DAA6D;IAC7D,qBAAqB,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,IAAI,CAAC;IAElE,mEAAmE;IACnE,KAAK,IAAI,IAAI,CAAC;IAEd,yCAAyC;IACzC,KAAK,IAAI,IAAI,CAAC;CACf;AAED,MAAM,WAAW,iBAAiB;IAChC,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB"}//# sourceMappingURL=session.js.map{"version":3,"file":"session.js","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"","sourcesContent":["import { User } from './user';\n\n/**\n * @inheritdoc\n */\nexport interface Session extends SessionContext {\n  /** JSDoc */\n  update(context?: SessionContext): void;\n\n  /** JSDoc */\n  close(status?: SessionStatus): void;\n\n  /** JSDoc */\n  toJSON(): {\n    init: boolean;\n    sid: string;\n    did?: string;\n    timestamp: string;\n    started: string;\n    duration?: number;\n    status: SessionStatus;\n    errors: number;\n    attrs?: {\n      release?: string;\n      environment?: string;\n      user_agent?: string;\n      ip_address?: string;\n    };\n  };\n}\n\nexport interface RequestSession {\n  status?: RequestSessionStatus;\n}\n\n/**\n * Session Context\n */\nexport interface SessionContext {\n  sid?: string;\n  did?: string;\n  init?: boolean;\n  // seconds since the UNIX epoch\n  timestamp?: number;\n  // seconds since the UNIX epoch\n  started?: number;\n  duration?: number;\n  status?: SessionStatus;\n  release?: string;\n  environment?: string;\n  userAgent?: string;\n  ipAddress?: string;\n  errors?: number;\n  user?: User | null;\n  ignoreDuration?: boolean;\n}\n\nexport type SessionStatus = 'ok' | 'exited' | 'crashed' | 'abnormal';\nexport type RequestSessionStatus = 'ok' | 'errored' | 'crashed';\n\n/** JSDoc */\nexport interface SessionAggregates {\n  attrs?: {\n    environment?: string;\n    release?: string;\n  };\n  aggregates: Array<AggregationCounts>;\n}\n\nexport interface SessionFlusherLike {\n  /**\n   * Increments the Session Status bucket in SessionAggregates Object corresponding to the status of the session\n   * captured\n   */\n  incrementSessionStatusCount(): void;\n\n  /** Submits the aggregates request mode sessions to Sentry */\n  sendSessionAggregates(sessionAggregates: SessionAggregates): void;\n\n  /** Empties Aggregate Buckets and Sends them to Transport Buffer */\n  flush(): void;\n\n  /** Clears setInterval and calls flush */\n  close(): void;\n}\n\nexport interface AggregationCounts {\n  started: string;\n  errored?: number;\n  exited?: number;\n  crashed?: number;\n}\n"]}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to SessionStatus type
 */
export declare enum SessionStatus {
    /** JSDoc */
    Ok = "ok",
    /** JSDoc */
    Exited = "exited",
    /** JSDoc */
    Crashed = "crashed",
    /** JSDoc */
    Abnormal = "abnormal"
}
//# sourceMappingURL=sessionstatus.d.ts.map{"version":3,"file":"sessionstatus.d.ts","sourceRoot":"","sources":["../../src/sessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,aAAa;IACvB,YAAY;IACZ,EAAE,OAAO;IACT,YAAY;IACZ,MAAM,WAAW;IACjB,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,QAAQ,aAAa;CACtB"}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to SessionStatus type
 */
export var SessionStatus;
(function (SessionStatus) {
    /** JSDoc */
    SessionStatus["Ok"] = "ok";
    /** JSDoc */
    SessionStatus["Exited"] = "exited";
    /** JSDoc */
    SessionStatus["Crashed"] = "crashed";
    /** JSDoc */
    SessionStatus["Abnormal"] = "abnormal";
})(SessionStatus || (SessionStatus = {}));
//# sourceMappingURL=sessionstatus.js.map{"version":3,"file":"sessionstatus.js","sourceRoot":"","sources":["../../src/sessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,CAAN,IAAY,aASX;AATD,WAAY,aAAa;IACvB,YAAY;IACZ,0BAAS,CAAA;IACT,YAAY;IACZ,kCAAiB,CAAA;IACjB,YAAY;IACZ,oCAAmB,CAAA;IACnB,YAAY;IACZ,sCAAqB,CAAA;AACvB,CAAC,EATW,aAAa,KAAb,aAAa,QASxB","sourcesContent":["/** JSDoc\n * @deprecated Use string literals - if you require type casting, cast to SessionStatus type\n */\nexport enum SessionStatus {\n  /** JSDoc */\n  Ok = 'ok',\n  /** JSDoc */\n  Exited = 'exited',\n  /** JSDoc */\n  Crashed = 'crashed',\n  /** JSDoc */\n  Abnormal = 'abnormal',\n}\n"]}/**
 * TODO(v7): Remove this enum and replace with SeverityLevel
 */
export declare enum Severity {
    /** JSDoc */
    Fatal = "fatal",
    /** JSDoc */
    Error = "error",
    /** JSDoc */
    Warning = "warning",
    /** JSDoc */
    Log = "log",
    /** JSDoc */
    Info = "info",
    /** JSDoc */
    Debug = "debug",
    /** JSDoc */
    Critical = "critical"
}
export declare const SeverityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug", "critical"];
export declare type SeverityLevel = typeof SeverityLevels[number];
//# sourceMappingURL=severity.d.ts.map{"version":3,"file":"severity.d.ts","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,QAAQ;IAClB,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,GAAG,QAAQ;IACX,YAAY;IACZ,IAAI,SAAS;IACb,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,QAAQ,aAAa;CACtB;AAID,eAAO,MAAM,cAAc,4EAA6E,CAAC;AACzG,oBAAY,aAAa,GAAG,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC"}/**
 * TODO(v7): Remove this enum and replace with SeverityLevel
 */
export var Severity;
(function (Severity) {
    /** JSDoc */
    Severity["Fatal"] = "fatal";
    /** JSDoc */
    Severity["Error"] = "error";
    /** JSDoc */
    Severity["Warning"] = "warning";
    /** JSDoc */
    Severity["Log"] = "log";
    /** JSDoc */
    Severity["Info"] = "info";
    /** JSDoc */
    Severity["Debug"] = "debug";
    /** JSDoc */
    Severity["Critical"] = "critical";
})(Severity || (Severity = {}));
// TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here
// is nice because then it enforces the idea that only types are exported from `@sentry/types`.)
export var SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];
//# sourceMappingURL=severity.js.map{"version":3,"file":"severity.js","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,CAAN,IAAY,QAeX;AAfD,WAAY,QAAQ;IAClB,YAAY;IACZ,2BAAe,CAAA;IACf,YAAY;IACZ,2BAAe,CAAA;IACf,YAAY;IACZ,+BAAmB,CAAA;IACnB,YAAY;IACZ,uBAAW,CAAA;IACX,YAAY;IACZ,yBAAa,CAAA;IACb,YAAY;IACZ,2BAAe,CAAA;IACf,YAAY;IACZ,iCAAqB,CAAA;AACvB,CAAC,EAfW,QAAQ,KAAR,QAAQ,QAenB;AAED,wHAAwH;AACxH,gGAAgG;AAChG,MAAM,CAAC,IAAM,cAAc,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,CAAU,CAAC","sourcesContent":["/**\n * TODO(v7): Remove this enum and replace with SeverityLevel\n */\nexport enum Severity {\n  /** JSDoc */\n  Fatal = 'fatal',\n  /** JSDoc */\n  Error = 'error',\n  /** JSDoc */\n  Warning = 'warning',\n  /** JSDoc */\n  Log = 'log',\n  /** JSDoc */\n  Info = 'info',\n  /** JSDoc */\n  Debug = 'debug',\n  /** JSDoc */\n  Critical = 'critical',\n}\n\n// TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here\n// is nice because then it enforces the idea that only types are exported from `@sentry/types`.)\nexport const SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'] as const;\nexport type SeverityLevel = typeof SeverityLevels[number];\n"]}import { Primitive } from './misc';
import { Transaction } from './transaction';
/** Interface holding all properties that can be set on a Span on creation. */
export interface SpanContext {
    /**
     * Description of the Span.
     */
    description?: string;
    /**
     * Operation of the Span.
     */
    op?: string;
    /**
     * Completion status of the Span.
     * See: {@sentry/tracing SpanStatus} for possible values
     */
    status?: string;
    /**
     * Parent Span ID
     */
    parentSpanId?: string;
    /**
     * Was this span chosen to be sent as part of the sample?
     */
    sampled?: boolean;
    /**
     * Span ID
     */
    spanId?: string;
    /**
     * Trace ID
     */
    traceId?: string;
    /**
     * Tags of the Span.
     */
    tags?: {
        [key: string]: Primitive;
    };
    /**
     * Data of the Span.
     */
    data?: {
        [key: string]: any;
    };
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     */
    startTimestamp?: number;
    /**
     * Timestamp in seconds (epoch time) indicating when the span ended.
     */
    endTimestamp?: number;
}
/** Span holding trace_id, span_id */
export interface Span extends SpanContext {
    /**
     * @inheritDoc
     */
    spanId: string;
    /**
     * @inheritDoc
     */
    traceId: string;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * The transaction containing this span
     */
    transaction?: Transaction;
    /**
     * Sets the finish timestamp on the current span.
     * @param endTimestamp Takes an endTimestamp if the end should not be the time when you call this function.
     */
    finish(endTimestamp?: number): void;
    /**
     * Sets the tag attribute on the current span.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key Tag key
     * @param value Tag value
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Sets the data attribute on the current span
     * @param key Data key
     * @param value Data value
     */
    setData(key: string, value: any): this;
    /**
     * Sets the status attribute on the current span
     * See: {@sentry/tracing SpanStatus} for possible values
     * @param status http code used to set the status
     */
    setStatus(status: string): this;
    /**
     * Sets the status attribute on the current span based on the http code
     * @param httpStatus http code used to set the status
     */
    setHttpStatus(httpStatus: number): this;
    /**
     * Use {@link startChild}
     * @deprecated
     */
    child(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
     * Also the `sampled` decision will be inherited.
     */
    startChild(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Determines whether span was successful (HTTP200)
     */
    isSuccess(): boolean;
    /** Return a traceparent compatible header string */
    toTraceparent(): string;
    /** Returns the current span properties as a `SpanContext` */
    toContext(): SpanContext;
    /** Updates the current span with a new `SpanContext` */
    updateWithContext(spanContext: SpanContext): this;
    /** Convert the object to JSON for w. spans array info only */
    getTraceContext(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        status?: string;
        tags?: {
            [key: string]: Primitive;
        };
        trace_id: string;
    };
    /** Convert the object to JSON */
    toJSON(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        start_timestamp: number;
        status?: string;
        tags?: {
            [key: string]: Primitive;
        };
        timestamp?: number;
        trace_id: string;
    };
}
//# sourceMappingURL=span.d.ts.map{"version":3,"file":"span.d.ts","sourceRoot":"","sources":["../../src/span.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAE5C,8EAA8E;AAC9E,MAAM,WAAW,WAAW;IAC1B;;OAEG;IACH,WAAW,CAAC,EAAE,MAAM,CAAC;IAErB;;OAEG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ;;;OAGG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;OAEG;IACH,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IAEpC;;OAEG;IACH,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAE9B;;OAEG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;CACvB;AAED,qCAAqC;AACrC,MAAM,WAAW,IAAK,SAAQ,WAAW;IACvC;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,cAAc,EAAE,MAAM,CAAC;IAEvB;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IAEnC;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAE7B;;OAEG;IACH,WAAW,CAAC,EAAE,WAAW,CAAC;IAE1B;;;OAGG;IACH,MAAM,CAAC,YAAY,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAEpC;;;;;;;OAOG;IACH,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,GAAG,IAAI,CAAC;IAE5C;;;;OAIG;IACH,OAAO,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,GAAG,IAAI,CAAC;IAEvC;;;;OAIG;IACH,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC;IAEhC;;;OAGG;IACH,aAAa,CAAC,UAAU,EAAE,MAAM,GAAG,IAAI,CAAC;IAExC;;;OAGG;IACH,KAAK,CACH,WAAW,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,MAAM,WAAW,EAAE,QAAQ,GAAG,SAAS,GAAG,SAAS,GAAG,cAAc,CAAC,CAAC,GAC7G,IAAI,CAAC;IAER;;;OAGG;IACH,UAAU,CACR,WAAW,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,MAAM,WAAW,EAAE,QAAQ,GAAG,SAAS,GAAG,SAAS,GAAG,cAAc,CAAC,CAAC,GAC7G,IAAI,CAAC;IAER;;OAEG;IACH,SAAS,IAAI,OAAO,CAAC;IAErB,oDAAoD;IACpD,aAAa,IAAI,MAAM,CAAC;IAExB,6DAA6D;IAC7D,SAAS,IAAI,WAAW,CAAC;IAEzB,wDAAwD;IACxD,iBAAiB,CAAC,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;IAElD,8DAA8D;IAC9D,eAAe,IAAI;QACjB,IAAI,CAAC,EAAE;YAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;SAAE,CAAC;QAC9B,WAAW,CAAC,EAAE,MAAM,CAAC;QACrB,EAAE,CAAC,EAAE,MAAM,CAAC;QACZ,cAAc,CAAC,EAAE,MAAM,CAAC;QACxB,OAAO,EAAE,MAAM,CAAC;QAChB,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,IAAI,CAAC,EAAE;YAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;SAAE,CAAC;QACpC,QAAQ,EAAE,MAAM,CAAC;KAClB,CAAC;IACF,iCAAiC;IACjC,MAAM,IAAI;QACR,IAAI,CAAC,EAAE;YAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;SAAE,CAAC;QAC9B,WAAW,CAAC,EAAE,MAAM,CAAC;QACrB,EAAE,CAAC,EAAE,MAAM,CAAC;QACZ,cAAc,CAAC,EAAE,MAAM,CAAC;QACxB,OAAO,EAAE,MAAM,CAAC;QAChB,eAAe,EAAE,MAAM,CAAC;QACxB,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,IAAI,CAAC,EAAE;YAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;SAAE,CAAC;QACpC,SAAS,CAAC,EAAE,MAAM,CAAC;QACnB,QAAQ,EAAE,MAAM,CAAC;KAClB,CAAC;CACH"}//# sourceMappingURL=span.js.map{"version":3,"file":"span.js","sourceRoot":"","sources":["../../src/span.ts"],"names":[],"mappings":"","sourcesContent":["import { Primitive } from './misc';\nimport { Transaction } from './transaction';\n\n/** Interface holding all properties that can be set on a Span on creation. */\nexport interface SpanContext {\n  /**\n   * Description of the Span.\n   */\n  description?: string;\n\n  /**\n   * Operation of the Span.\n   */\n  op?: string;\n\n  /**\n   * Completion status of the Span.\n   * See: {@sentry/tracing SpanStatus} for possible values\n   */\n  status?: string;\n\n  /**\n   * Parent Span ID\n   */\n  parentSpanId?: string;\n\n  /**\n   * Was this span chosen to be sent as part of the sample?\n   */\n  sampled?: boolean;\n\n  /**\n   * Span ID\n   */\n  spanId?: string;\n\n  /**\n   * Trace ID\n   */\n  traceId?: string;\n\n  /**\n   * Tags of the Span.\n   */\n  tags?: { [key: string]: Primitive };\n\n  /**\n   * Data of the Span.\n   */\n  data?: { [key: string]: any };\n\n  /**\n   * Timestamp in seconds (epoch time) indicating when the span started.\n   */\n  startTimestamp?: number;\n\n  /**\n   * Timestamp in seconds (epoch time) indicating when the span ended.\n   */\n  endTimestamp?: number;\n}\n\n/** Span holding trace_id, span_id */\nexport interface Span extends SpanContext {\n  /**\n   * @inheritDoc\n   */\n  spanId: string;\n\n  /**\n   * @inheritDoc\n   */\n  traceId: string;\n\n  /**\n   * @inheritDoc\n   */\n  startTimestamp: number;\n\n  /**\n   * @inheritDoc\n   */\n  tags: { [key: string]: Primitive };\n\n  /**\n   * @inheritDoc\n   */\n  data: { [key: string]: any };\n\n  /**\n   * The transaction containing this span\n   */\n  transaction?: Transaction;\n\n  /**\n   * Sets the finish timestamp on the current span.\n   * @param endTimestamp Takes an endTimestamp if the end should not be the time when you call this function.\n   */\n  finish(endTimestamp?: number): void;\n\n  /**\n   * Sets the tag attribute on the current span.\n   *\n   * Can also be used to unset a tag, by passing `undefined`.\n   *\n   * @param key Tag key\n   * @param value Tag value\n   */\n  setTag(key: string, value: Primitive): this;\n\n  /**\n   * Sets the data attribute on the current span\n   * @param key Data key\n   * @param value Data value\n   */\n  setData(key: string, value: any): this;\n\n  /**\n   * Sets the status attribute on the current span\n   * See: {@sentry/tracing SpanStatus} for possible values\n   * @param status http code used to set the status\n   */\n  setStatus(status: string): this;\n\n  /**\n   * Sets the status attribute on the current span based on the http code\n   * @param httpStatus http code used to set the status\n   */\n  setHttpStatus(httpStatus: number): this;\n\n  /**\n   * Use {@link startChild}\n   * @deprecated\n   */\n  child(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span;\n\n  /**\n   * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n   * Also the `sampled` decision will be inherited.\n   */\n  startChild(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span;\n\n  /**\n   * Determines whether span was successful (HTTP200)\n   */\n  isSuccess(): boolean;\n\n  /** Return a traceparent compatible header string */\n  toTraceparent(): string;\n\n  /** Returns the current span properties as a `SpanContext` */\n  toContext(): SpanContext;\n\n  /** Updates the current span with a new `SpanContext` */\n  updateWithContext(spanContext: SpanContext): this;\n\n  /** Convert the object to JSON for w. spans array info only */\n  getTraceContext(): {\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    trace_id: string;\n  };\n  /** Convert the object to JSON */\n  toJSON(): {\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    start_timestamp: number;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    timestamp?: number;\n    trace_id: string;\n  };\n}\n"]}/** JSDoc */
export interface StackFrame {
    filename?: string;
    function?: string;
    module?: string;
    platform?: string;
    lineno?: number;
    colno?: number;
    abs_path?: string;
    context_line?: string;
    pre_context?: string[];
    post_context?: string[];
    in_app?: boolean;
    instruction_addr?: string;
    addr_mode?: string;
    vars?: {
        [key: string]: any;
    };
}
//# sourceMappingURL=stackframe.d.ts.map{"version":3,"file":"stackframe.d.ts","sourceRoot":"","sources":["../../src/stackframe.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CAC/B"}//# sourceMappingURL=stackframe.js.map{"version":3,"file":"stackframe.js","sourceRoot":"","sources":["../../src/stackframe.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface StackFrame {\n  filename?: string;\n  function?: string;\n  module?: string;\n  platform?: string;\n  lineno?: number;\n  colno?: number;\n  abs_path?: string;\n  context_line?: string;\n  pre_context?: string[];\n  post_context?: string[];\n  in_app?: boolean;\n  instruction_addr?: string;\n  addr_mode?: string;\n  vars?: { [key: string]: any };\n}\n"]}import { StackFrame } from './stackframe';
/** JSDoc */
export interface Stacktrace {
    frames?: StackFrame[];
    frames_omitted?: [number, number];
}
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,MAAM,CAAC,EAAE,UAAU,EAAE,CAAC;IACtB,cAAc,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CACnC"}//# sourceMappingURL=stacktrace.js.map{"version":3,"file":"stacktrace.js","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"","sourcesContent":["import { StackFrame } from './stackframe';\n\n/** JSDoc */\nexport interface Stacktrace {\n  frames?: StackFrame[];\n  frames_omitted?: [number, number];\n}\n"]}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to EventStatus type
 */
export declare enum Status {
    /** The status could not be determined. */
    Unknown = "unknown",
    /** The event was skipped due to configuration or callbacks. */
    Skipped = "skipped",
    /** The event was sent to Sentry successfully. */
    Success = "success",
    /** The client is currently rate limited and will try again later. */
    RateLimit = "rate_limit",
    /** The event could not be processed. */
    Invalid = "invalid",
    /** A server-side error occurred during submission. */
    Failed = "failed"
}
//# sourceMappingURL=status.d.ts.map{"version":3,"file":"status.d.ts","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,MAAM;IAChB,0CAA0C;IAC1C,OAAO,YAAY;IACnB,+DAA+D;IAC/D,OAAO,YAAY;IACnB,iDAAiD;IACjD,OAAO,YAAY;IACnB,qEAAqE;IACrE,SAAS,eAAe;IACxB,wCAAwC;IACxC,OAAO,YAAY;IACnB,sDAAsD;IACtD,MAAM,WAAW;CAClB"}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to EventStatus type
 */
export var Status;
(function (Status) {
    /** The status could not be determined. */
    Status["Unknown"] = "unknown";
    /** The event was skipped due to configuration or callbacks. */
    Status["Skipped"] = "skipped";
    /** The event was sent to Sentry successfully. */
    Status["Success"] = "success";
    /** The client is currently rate limited and will try again later. */
    Status["RateLimit"] = "rate_limit";
    /** The event could not be processed. */
    Status["Invalid"] = "invalid";
    /** A server-side error occurred during submission. */
    Status["Failed"] = "failed";
})(Status || (Status = {}));
//# sourceMappingURL=status.js.map{"version":3,"file":"status.js","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,CAAN,IAAY,MAaX;AAbD,WAAY,MAAM;IAChB,0CAA0C;IAC1C,6BAAmB,CAAA;IACnB,+DAA+D;IAC/D,6BAAmB,CAAA;IACnB,iDAAiD;IACjD,6BAAmB,CAAA;IACnB,qEAAqE;IACrE,kCAAwB,CAAA;IACxB,wCAAwC;IACxC,6BAAmB,CAAA;IACnB,sDAAsD;IACtD,2BAAiB,CAAA;AACnB,CAAC,EAbW,MAAM,KAAN,MAAM,QAajB","sourcesContent":["/** JSDoc\n * @deprecated Use string literals - if you require type casting, cast to EventStatus type\n */\nexport enum Status {\n  /** The status could not be determined. */\n  Unknown = 'unknown',\n  /** The event was skipped due to configuration or callbacks. */\n  Skipped = 'skipped',\n  /** The event was sent to Sentry successfully. */\n  Success = 'success',\n  /** The client is currently rate limited and will try again later. */\n  RateLimit = 'rate_limit',\n  /** The event could not be processed. */\n  Invalid = 'invalid',\n  /** A server-side error occurred during submission. */\n  Failed = 'failed',\n}\n"]}import { Stacktrace } from './stacktrace';
/** JSDoc */
export interface Thread {
    id?: number;
    name?: string;
    stacktrace?: Stacktrace;
    crashed?: boolean;
    current?: boolean;
}
//# sourceMappingURL=thread.d.ts.map{"version":3,"file":"thread.d.ts","sourceRoot":"","sources":["../../src/thread.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,MAAM;IACrB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,OAAO,CAAC,EAAE,OAAO,CAAC;CACnB"}//# sourceMappingURL=thread.js.map{"version":3,"file":"thread.js","sourceRoot":"","sources":["../../src/thread.ts"],"names":[],"mappings":"","sourcesContent":["import { Stacktrace } from './stacktrace';\n\n/** JSDoc */\nexport interface Thread {\n  id?: number;\n  name?: string;\n  stacktrace?: Stacktrace;\n  crashed?: boolean;\n  current?: boolean;\n}\n"]}import { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';
import { Span, SpanContext } from './span';
/**
 * Interface holding Transaction-specific properties
 */
export interface TransactionContext extends SpanContext {
    /**
     * Human-readable identifier for the transaction
     */
    name: string;
    /**
     * If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming
     * the duration of the transaction. This is useful to discard extra time in the transaction that is not
     * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the
     * transaction after a given "idle time" and we don't want this "idle time" to be part of the transaction.
     */
    trimEnd?: boolean;
    /**
     * If this transaction has a parent, the parent's sampling decision
     */
    parentSampled?: boolean;
    /**
     * Metadata associated with the transaction, for internal SDK use.
     */
    metadata?: TransactionMetadata;
}
/**
 * Data pulled from a `sentry-trace` header
 */
export declare type TraceparentData = Pick<TransactionContext, 'traceId' | 'parentSpanId' | 'parentSampled'>;
/**
 * Transaction "Class", inherits Span only has `setName`
 */
export interface Transaction extends TransactionContext, Span {
    /**
     * @inheritDoc
     */
    spanId: string;
    /**
     * @inheritDoc
     */
    traceId: string;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * Metadata about the transaction
     */
    metadata: TransactionMetadata;
    /**
     * Set the name of the transaction
     */
    setName(name: string): void;
    /** Returns the current transaction properties as a `TransactionContext` */
    toContext(): TransactionContext;
    /** Updates the current transaction with a new `TransactionContext` */
    updateWithContext(transactionContext: TransactionContext): this;
}
/**
 * Context data passed by the user when starting a transaction, to be used by the tracesSampler method.
 */
export interface CustomSamplingContext {
    [key: string]: any;
}
/**
 * Data passed to the `tracesSampler` function, which forms the basis for whatever decisions it might make.
 *
 * Adds default data to data provided by the user. See {@link Hub.startTransaction}
 */
export interface SamplingContext extends CustomSamplingContext {
    /**
     * Context data with which transaction being sampled was created
     */
    transactionContext: TransactionContext;
    /**
     * Sampling decision from the parent transaction, if any.
     */
    parentSampled?: boolean;
    /**
     * Object representing the URL of the current page or worker script. Passed by default when using the `BrowserTracing`
     * integration.
     */
    location?: WorkerLocation;
    /**
     * Object representing the incoming request to a node server. Passed by default when using the TracingHandler.
     */
    request?: ExtractedNodeRequestData;
}
export declare type Measurements = Record<string, {
    value: number;
}>;
export declare type TransactionSamplingMethod = 'explicitly_set' | 'client_sampler' | 'client_rate' | 'inheritance';
export interface TransactionMetadata {
    transactionSampling?: {
        rate?: number;
        method: TransactionSamplingMethod;
    };
    /** The two halves (sentry and third-party) of a transaction's tracestate header, used for dynamic sampling */
    tracestate?: {
        sentry?: string;
        thirdparty?: string;
    };
    /** For transactions tracing server-side request handling, the path of the request being tracked. */
    requestPath?: string;
}
//# sourceMappingURL=transaction.d.ts.map{"version":3,"file":"transaction.d.ts","sourceRoot":"","sources":["../../src/transaction.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,wBAAwB,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAC7E,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAE3C;;GAEG;AACH,MAAM,WAAW,kBAAmB,SAAQ,WAAW;IACrD;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;;;OAKG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;OAEG;IACH,aAAa,CAAC,EAAE,OAAO,CAAC;IAExB;;OAEG;IACH,QAAQ,CAAC,EAAE,mBAAmB,CAAC;CAChC;AAED;;GAEG;AACH,oBAAY,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,SAAS,GAAG,cAAc,GAAG,eAAe,CAAC,CAAC;AAErG;;GAEG;AACH,MAAM,WAAW,WAAY,SAAQ,kBAAkB,EAAE,IAAI;IAC3D;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,cAAc,EAAE,MAAM,CAAC;IAEvB;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IAEnC;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAE7B;;OAEG;IACH,QAAQ,EAAE,mBAAmB,CAAC;IAE9B;;OAEG;IACH,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IAE5B,2EAA2E;IAC3E,SAAS,IAAI,kBAAkB,CAAC;IAEhC,sEAAsE;IACtE,iBAAiB,CAAC,kBAAkB,EAAE,kBAAkB,GAAG,IAAI,CAAC;CACjE;AAED;;GAEG;AACH,MAAM,WAAW,qBAAqB;IACpC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB;AAED;;;;GAIG;AACH,MAAM,WAAW,eAAgB,SAAQ,qBAAqB;IAC5D;;OAEG;IACH,kBAAkB,EAAE,kBAAkB,CAAC;IAEvC;;OAEG;IACH,aAAa,CAAC,EAAE,OAAO,CAAC;IAExB;;;OAGG;IACH,QAAQ,CAAC,EAAE,cAAc,CAAC;IAE1B;;OAEG;IACH,OAAO,CAAC,EAAE,wBAAwB,CAAC;CACpC;AAED,oBAAY,YAAY,GAAG,MAAM,CAAC,MAAM,EAAE;IAAE,KAAK,EAAE,MAAM,CAAA;CAAE,CAAC,CAAC;AAE7D,oBAAY,yBAAyB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,aAAa,GAAG,aAAa,CAAC;AAE5G,MAAM,WAAW,mBAAmB;IAClC,mBAAmB,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE,MAAM,CAAC;QAAC,MAAM,EAAE,yBAAyB,CAAA;KAAE,CAAC;IAE3E,8GAA8G;IAC9G,UAAU,CAAC,EAAE;QACX,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,UAAU,CAAC,EAAE,MAAM,CAAC;KACrB,CAAC;IAEF,oGAAoG;IACpG,WAAW,CAAC,EAAE,MAAM,CAAC;CACtB"}//# sourceMappingURL=transaction.js.map{"version":3,"file":"transaction.js","sourceRoot":"","sources":["../../src/transaction.ts"],"names":[],"mappings":"","sourcesContent":["import { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';\nimport { Span, SpanContext } from './span';\n\n/**\n * Interface holding Transaction-specific properties\n */\nexport interface TransactionContext extends SpanContext {\n  /**\n   * Human-readable identifier for the transaction\n   */\n  name: string;\n\n  /**\n   * If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming\n   * the duration of the transaction. This is useful to discard extra time in the transaction that is not\n   * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the\n   * transaction after a given \"idle time\" and we don't want this \"idle time\" to be part of the transaction.\n   */\n  trimEnd?: boolean;\n\n  /**\n   * If this transaction has a parent, the parent's sampling decision\n   */\n  parentSampled?: boolean;\n\n  /**\n   * Metadata associated with the transaction, for internal SDK use.\n   */\n  metadata?: TransactionMetadata;\n}\n\n/**\n * Data pulled from a `sentry-trace` header\n */\nexport type TraceparentData = Pick<TransactionContext, 'traceId' | 'parentSpanId' | 'parentSampled'>;\n\n/**\n * Transaction \"Class\", inherits Span only has `setName`\n */\nexport interface Transaction extends TransactionContext, Span {\n  /**\n   * @inheritDoc\n   */\n  spanId: string;\n\n  /**\n   * @inheritDoc\n   */\n  traceId: string;\n\n  /**\n   * @inheritDoc\n   */\n  startTimestamp: number;\n\n  /**\n   * @inheritDoc\n   */\n  tags: { [key: string]: Primitive };\n\n  /**\n   * @inheritDoc\n   */\n  data: { [key: string]: any };\n\n  /**\n   * Metadata about the transaction\n   */\n  metadata: TransactionMetadata;\n\n  /**\n   * Set the name of the transaction\n   */\n  setName(name: string): void;\n\n  /** Returns the current transaction properties as a `TransactionContext` */\n  toContext(): TransactionContext;\n\n  /** Updates the current transaction with a new `TransactionContext` */\n  updateWithContext(transactionContext: TransactionContext): this;\n}\n\n/**\n * Context data passed by the user when starting a transaction, to be used by the tracesSampler method.\n */\nexport interface CustomSamplingContext {\n  [key: string]: any;\n}\n\n/**\n * Data passed to the `tracesSampler` function, which forms the basis for whatever decisions it might make.\n *\n * Adds default data to data provided by the user. See {@link Hub.startTransaction}\n */\nexport interface SamplingContext extends CustomSamplingContext {\n  /**\n   * Context data with which transaction being sampled was created\n   */\n  transactionContext: TransactionContext;\n\n  /**\n   * Sampling decision from the parent transaction, if any.\n   */\n  parentSampled?: boolean;\n\n  /**\n   * Object representing the URL of the current page or worker script. Passed by default when using the `BrowserTracing`\n   * integration.\n   */\n  location?: WorkerLocation;\n\n  /**\n   * Object representing the incoming request to a node server. Passed by default when using the TracingHandler.\n   */\n  request?: ExtractedNodeRequestData;\n}\n\nexport type Measurements = Record<string, { value: number }>;\n\nexport type TransactionSamplingMethod = 'explicitly_set' | 'client_sampler' | 'client_rate' | 'inheritance';\n\nexport interface TransactionMetadata {\n  transactionSampling?: { rate?: number; method: TransactionSamplingMethod };\n\n  /** The two halves (sentry and third-party) of a transaction's tracestate header, used for dynamic sampling */\n  tracestate?: {\n    sentry?: string;\n    thirdparty?: string;\n  };\n\n  /** For transactions tracing server-side request handling, the path of the request being tracked. */\n  requestPath?: string;\n}\n"]}import { DsnLike } from './dsn';
import { Event } from './event';
import { SentryRequestType } from './request';
import { Response } from './response';
import { SdkMetadata } from './sdkmetadata';
import { Session, SessionAggregates } from './session';
export declare type Outcome = 'before_send' | 'event_processor' | 'network_error' | 'queue_overflow' | 'ratelimit_backoff' | 'sample_rate';
/** Transport used sending data to Sentry */
export interface Transport {
    /**
     * Sends the event to the Store endpoint in Sentry.
     *
     * @param event Event that should be sent to Sentry.
     */
    sendEvent(event: Event): PromiseLike<Response>;
    /**
     * Sends the session to the Envelope endpoint in Sentry.
     *
     * @param session Session that should be sent to Sentry | Session Aggregates that should be sent to Sentry.
     */
    sendSession?(session: Session | SessionAggregates): PromiseLike<Response>;
    /**
     * Wait for all events to be sent or the timeout to expire, whichever comes first.
     *
     * @param timeout Maximum time in ms the transport should wait for events to be flushed. Omitting this parameter will
     *   cause the transport to wait until all events are sent before resolving the promise.
     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
     * still events in the queue when the timeout is reached.
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Increment the counter for the specific client outcome
     */
    recordLostEvent?(type: Outcome, category: SentryRequestType): void;
}
/** JSDoc */
export declare type TransportClass<T extends Transport> = new (options: TransportOptions) => T;
/** JSDoc */
export interface TransportOptions {
    /** Sentry DSN */
    dsn: DsnLike;
    /** Define custom headers */
    headers?: {
        [key: string]: string;
    };
    /** Set a HTTP proxy that should be used for outbound requests. */
    httpProxy?: string;
    /** Set a HTTPS proxy that should be used for outbound requests. */
    httpsProxy?: string;
    /** HTTPS proxy certificates path */
    caCerts?: string;
    /** Fetch API init parameters */
    fetchParameters?: {
        [key: string]: string;
    };
    /** The envelope tunnel to use. */
    tunnel?: string;
    /** Send SDK Client Reports. Enabled by default. */
    sendClientReports?: boolean;
    /**
     * Set of metadata about the SDK that can be internally used to enhance envelopes and events,
     * and provide additional data about every request.
     * */
    _metadata?: SdkMetadata;
}
//# sourceMappingURL=transport.d.ts.map{"version":3,"file":"transport.d.ts","sourceRoot":"","sources":["../../src/transport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,OAAO,CAAC;AAChC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAEvD,oBAAY,OAAO,GACf,aAAa,GACb,iBAAiB,GACjB,eAAe,GACf,gBAAgB,GAChB,mBAAmB,GACnB,aAAa,CAAC;AAElB,4CAA4C;AAC5C,MAAM,WAAW,SAAS;IACxB;;;;OAIG;IACH,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAE/C;;;;OAIG;IACH,WAAW,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAE1E;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C;;OAEG;IACH,eAAe,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,iBAAiB,GAAG,IAAI,CAAC;CACpE;AAED,YAAY;AACZ,oBAAY,cAAc,CAAC,CAAC,SAAS,SAAS,IAAI,KAAK,OAAO,EAAE,gBAAgB,KAAK,CAAC,CAAC;AAEvF,YAAY;AACZ,MAAM,WAAW,gBAAgB;IAC/B,iBAAiB;IACjB,GAAG,EAAE,OAAO,CAAC;IACb,4BAA4B;IAC5B,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,kEAAkE;IAClE,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,mEAAmE;IACnE,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,oCAAoC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,gCAAgC;IAChC,eAAe,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAC5C,kCAAkC;IAClC,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,mDAAmD;IACnD,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAC5B;;;SAGK;IACL,SAAS,CAAC,EAAE,WAAW,CAAC;CACzB"}//# sourceMappingURL=transport.js.map{"version":3,"file":"transport.js","sourceRoot":"","sources":["../../src/transport.ts"],"names":[],"mappings":"","sourcesContent":["import { DsnLike } from './dsn';\nimport { Event } from './event';\nimport { SentryRequestType } from './request';\nimport { Response } from './response';\nimport { SdkMetadata } from './sdkmetadata';\nimport { Session, SessionAggregates } from './session';\n\nexport type Outcome =\n  | 'before_send'\n  | 'event_processor'\n  | 'network_error'\n  | 'queue_overflow'\n  | 'ratelimit_backoff'\n  | 'sample_rate';\n\n/** Transport used sending data to Sentry */\nexport interface Transport {\n  /**\n   * Sends the event to the Store endpoint in Sentry.\n   *\n   * @param event Event that should be sent to Sentry.\n   */\n  sendEvent(event: Event): PromiseLike<Response>;\n\n  /**\n   * Sends the session to the Envelope endpoint in Sentry.\n   *\n   * @param session Session that should be sent to Sentry | Session Aggregates that should be sent to Sentry.\n   */\n  sendSession?(session: Session | SessionAggregates): PromiseLike<Response>;\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the transport should wait for events to be flushed. Omitting this parameter will\n   *   cause the transport to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  close(timeout?: number): PromiseLike<boolean>;\n\n  /**\n   * Increment the counter for the specific client outcome\n   */\n  recordLostEvent?(type: Outcome, category: SentryRequestType): void;\n}\n\n/** JSDoc */\nexport type TransportClass<T extends Transport> = new (options: TransportOptions) => T;\n\n/** JSDoc */\nexport interface TransportOptions {\n  /** Sentry DSN */\n  dsn: DsnLike;\n  /** Define custom headers */\n  headers?: { [key: string]: string };\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n  /** Fetch API init parameters */\n  fetchParameters?: { [key: string]: string };\n  /** The envelope tunnel to use. */\n  tunnel?: string;\n  /** Send SDK Client Reports. Enabled by default. */\n  sendClientReports?: boolean;\n  /**\n   * Set of metadata about the SDK that can be internally used to enhance envelopes and events,\n   * and provide additional data about every request.\n   * */\n  _metadata?: SdkMetadata;\n}\n"]}/** JSDoc */
export interface User {
    [key: string]: any;
    id?: string;
    ip_address?: string;
    email?: string;
    username?: string;
}
export interface UserFeedback {
    event_id: string;
    email: User['email'];
    name: string;
    comments: string;
}
//# sourceMappingURL=user.d.ts.map{"version":3,"file":"user.d.ts","sourceRoot":"","sources":["../../src/user.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,IAAI;IACnB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB;AAED,MAAM,WAAW,YAAY;IAC3B,QAAQ,EAAE,MAAM,CAAC;IACjB,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;IACrB,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,MAAM,CAAC;CAClB"}//# sourceMappingURL=user.js.map{"version":3,"file":"user.js","sourceRoot":"","sources":["../../src/user.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface User {\n  [key: string]: any;\n  id?: string;\n  ip_address?: string;\n  email?: string;\n  username?: string;\n}\n\nexport interface UserFeedback {\n  event_id: string;\n  email: User['email'];\n  name: string;\n  comments: string;\n}\n"]}/** JSDoc */
export interface WrappedFunction extends Function {
    [key: string]: any;
    __sentry_wrapped__?: WrappedFunction;
    __sentry_original__?: WrappedFunction;
}
//# sourceMappingURL=wrappedfunction.d.ts.map{"version":3,"file":"wrappedfunction.d.ts","sourceRoot":"","sources":["../../src/wrappedfunction.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,eAAgB,SAAQ,QAAQ;IAC/C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,kBAAkB,CAAC,EAAE,eAAe,CAAC;IACrC,mBAAmB,CAAC,EAAE,eAAe,CAAC;CACvC"}//# sourceMappingURL=wrappedfunction.js.map{"version":3,"file":"wrappedfunction.js","sourceRoot":"","sources":["../../src/wrappedfunction.ts"],"names":[],"mappings":"","sourcesContent":["/** JSDoc */\nexport interface WrappedFunction extends Function {\n  [key: string]: any;\n  __sentry_wrapped__?: WrappedFunction;\n  __sentry_original__?: WrappedFunction;\n}\n"]}BSD 3-Clause License

Copyright (c) 2019, Sentry
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{
  "name": "@sentry/types",
  "version": "6.19.7",
  "description": "Types for all Sentry JavaScript SDKs",
  "repository": "git://github.com/getsentry/sentry-javascript.git",
  "homepage": "https://github.com/getsentry/sentry-javascript/tree/master/packages/types",
  "author": "Sentry",
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=6"
  },
  "main": "dist/index.js",
  "module": "esm/index.js",
  "types": "types/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "sideEffects": false
}<p align="center">
  <a href="https://sentry.io" target="_blank" align="center">
    <img src="https://sentry-brand.storage.googleapis.com/sentry-logo-black.png" width="280">
  </a>
  <br />
</p>

# Sentry JavaScript SDK Types

[![npm version](https://img.shields.io/npm/v/@sentry/types.svg)](https://www.npmjs.com/package/@sentry/types)
[![npm dm](https://img.shields.io/npm/dm/@sentry/types.svg)](https://www.npmjs.com/package/@sentry/types)
[![npm dt](https://img.shields.io/npm/dt/@sentry/types.svg)](https://www.npmjs.com/package/@sentry/types)
[![typedoc](https://img.shields.io/badge/docs-typedoc-blue.svg)](http://getsentry.github.io/sentry-javascript/)

## Links

- [Official SDK Docs](https://docs.sentry.io/quickstart/)
- [TypeDoc](http://getsentry.github.io/sentry-javascript/)

## General

Common types used by the Sentry JavaScript SDKs.
import { Severity } from './severity';
/** JSDoc */
export interface Breadcrumb {
    type?: string;
    level?: Severity;
    event_id?: string;
    category?: string;
    message?: string;
    data?: {
        [key: string]: any;
    };
    timestamp?: number;
}
/** JSDoc */
export interface BreadcrumbHint {
    [key: string]: any;
}
//# sourceMappingURL=breadcrumb.d.ts.map{"version":3,"file":"breadcrumb.d.ts","sourceRoot":"","sources":["../../src/breadcrumb.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,QAAQ,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAC9B,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,YAAY;AACZ,MAAM,WAAW,cAAc;IAC7B,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB"}import { DsnComponents } from './dsn';
import { Event, EventHint } from './event';
import { Integration, IntegrationClass } from './integration';
import { Options } from './options';
import { Scope } from './scope';
import { Session } from './session';
import { Severity } from './severity';
import { Transport } from './transport';
/**
 * User-Facing Sentry SDK Client.
 *
 * This interface contains all methods to interface with the SDK once it has
 * been installed. It allows to send events to Sentry, record breadcrumbs and
 * set a context included in every event. Since the SDK mutates its environment,
 * there will only be one instance during runtime.
 *
 */
export interface Client<O extends Options = Options> {
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param level Define the level of the message.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope An optional scope containing event metadata.
     * @returns The event id
     */
    captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined;
    /** Captures a session
     *
     * @param session Session to be delivered
     */
    captureSession?(session: Session): void;
    /** Returns the current Dsn. */
    getDsn(): DsnComponents | undefined;
    /** Returns the current options. */
    getOptions(): O;
    /** Returns clients transport. */
    getTransport?(): Transport;
    /**
     * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.
     *
     * @param timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause
     *   the client to wait until all events are sent before disabling itself.
     * @returns A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if
     * it doesn't.
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Wait for all events to be sent or the timeout to expire, whichever comes first.
     *
     * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will
     *   cause the client to wait until all events are sent before resolving the promise.
     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
     * still events in the queue when the timeout is reached.
     */
    flush(timeout?: number): PromiseLike<boolean>;
    /** Returns an array of installed integrations on the client. */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** This is an internal function to setup all integrations that should run on the client */
    setupIntegrations(): void;
}
//# sourceMappingURL=client.d.ts.map{"version":3,"file":"client.d.ts","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,OAAO,CAAC;AACtC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAExC;;;;;;;;GAQG;AACH,MAAM,WAAW,MAAM,CAAC,CAAC,SAAS,OAAO,GAAG,OAAO;IACjD;;;;;;;OAOG;IACH,gBAAgB,CAAC,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEtF;;;;;;;;OAQG;IACH,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEvG;;;;;;;OAOG;IACH,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;IAEhF;;;OAGG;IACH,cAAc,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI,CAAC;IAExC,+BAA+B;IAC/B,MAAM,IAAI,aAAa,GAAG,SAAS,CAAC;IAEpC,mCAAmC;IACnC,UAAU,IAAI,CAAC,CAAC;IAEhB,iCAAiC;IACjC,YAAY,CAAC,IAAI,SAAS,CAAC;IAE3B;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C,gEAAgE;IAChE,cAAc,CAAC,CAAC,SAAS,WAAW,EAAE,WAAW,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;IAElF,2FAA2F;IAC3F,iBAAiB,IAAI,IAAI,CAAC;CAC3B"}import { SentryRequestType } from './request';
import { Outcome } from './transport';
export declare type ClientReport = {
    timestamp: number;
    discarded_events: Array<{
        reason: Outcome;
        category: SentryRequestType;
        quantity: number;
    }>;
};
//# sourceMappingURL=clientreport.d.ts.map{"version":3,"file":"clientreport.d.ts","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AAEtC,oBAAY,YAAY,GAAG;IACzB,SAAS,EAAE,MAAM,CAAC;IAClB,gBAAgB,EAAE,KAAK,CAAC;QAAE,MAAM,EAAE,OAAO,CAAC;QAAC,QAAQ,EAAE,iBAAiB,CAAC;QAAC,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC,CAAC;CAC7F,CAAC"}export declare type Context = Record<string, unknown>;
export declare type Contexts = Record<string, Context>;
//# sourceMappingURL=context.d.ts.map{"version":3,"file":"context.d.ts","sourceRoot":"","sources":["../../src/context.ts"],"names":[],"mappings":"AAAA,oBAAY,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC9C,oBAAY,QAAQ,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC"}/**
 * Holds meta information to customize the behavior of Sentry's server-side event processing.
 **/
export interface DebugMeta {
    images?: Array<DebugImage>;
}
/**
 * Possible choices for debug images.
 */
export declare type DebugImageType = 'wasm' | 'macho' | 'elf' | 'pe';
/**
 * References to debug images.
 */
export interface DebugImage {
    type: DebugImageType;
    debug_id: string;
    code_id?: string | null;
    code_file: string;
    debug_file?: string | null;
}
//# sourceMappingURL=debugMeta.d.ts.map{"version":3,"file":"debugMeta.d.ts","sourceRoot":"","sources":["../../src/debugMeta.ts"],"names":[],"mappings":"AAAA;;IAEI;AACJ,MAAM,WAAW,SAAS;IACxB,MAAM,CAAC,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;CAC5B;AAED;;GAEG;AACH,oBAAY,cAAc,GAAG,MAAM,GAAG,OAAO,GAAG,KAAK,GAAG,IAAI,CAAC;AAE7D;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB,IAAI,EAAE,cAAc,CAAC;IACrB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACxB,SAAS,EAAE,MAAM,CAAC;IAClB,UAAU,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;CAC5B"}/** Supported Sentry transport protocols in a Dsn. */
export declare type DsnProtocol = 'http' | 'https';
/** Primitive components of a Dsn. */
export interface DsnComponents {
    /** Protocol used to connect to Sentry. */
    protocol: DsnProtocol;
    /** Public authorization key (deprecated, renamed to publicKey). */
    user?: string;
    /** Public authorization key. */
    publicKey?: string;
    /** Private authorization key (deprecated, optional). */
    pass?: string;
    /** Hostname of the Sentry instance. */
    host: string;
    /** Port of the Sentry instance. */
    port?: string;
    /** Sub path/ */
    path?: string;
    /** Project ID */
    projectId: string;
}
/** Anything that can be parsed into a Dsn. */
export declare type DsnLike = string | DsnComponents;
//# sourceMappingURL=dsn.d.ts.map{"version":3,"file":"dsn.d.ts","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"AAAA,qDAAqD;AACrD,oBAAY,WAAW,GAAG,MAAM,GAAG,OAAO,CAAC;AAE3C,qCAAqC;AACrC,MAAM,WAAW,aAAa;IAC5B,0CAA0C;IAC1C,QAAQ,EAAE,WAAW,CAAC;IACtB,mEAAmE;IACnE,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gCAAgC;IAChC,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,wDAAwD;IACxD,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,uCAAuC;IACvC,IAAI,EAAE,MAAM,CAAC;IACb,mCAAmC;IACnC,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,gBAAgB;IAChB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,iBAAiB;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,8CAA8C;AAC9C,oBAAY,OAAO,GAAG,MAAM,GAAG,aAAa,CAAC"}import { ClientReport } from './clientreport';
import { Event } from './event';
import { SdkInfo } from './sdkinfo';
import { Session, SessionAggregates } from './session';
import { TransactionSamplingMethod } from './transaction';
import { UserFeedback } from './user';
export declare type BaseEnvelopeHeaders = {
    [key: string]: unknown;
    dsn?: string;
    sdk?: SdkInfo;
};
export declare type BaseEnvelopeItemHeaders = {
    [key: string]: unknown;
    type: string;
    length?: number;
};
declare type BaseEnvelopeItem<IH extends BaseEnvelopeItemHeaders, P extends unknown> = [IH, P];
declare type BaseEnvelope<EH extends BaseEnvelopeHeaders, I extends BaseEnvelopeItem<BaseEnvelopeItemHeaders, unknown>> = [EH, I[]];
declare type EventItemHeaders = {
    type: 'event' | 'transaction';
    sample_rates?: [{
        id?: TransactionSamplingMethod;
        rate?: number;
    }];
};
declare type AttachmentItemHeaders = {
    type: 'attachment';
    filename: string;
};
declare type UserFeedbackItemHeaders = {
    type: 'user_report';
};
declare type SessionItemHeaders = {
    type: 'session';
};
declare type SessionAggregatesItemHeaders = {
    type: 'sessions';
};
declare type ClientReportItemHeaders = {
    type: 'client_report';
};
export declare type EventItem = BaseEnvelopeItem<EventItemHeaders, Event | string>;
export declare type AttachmentItem = BaseEnvelopeItem<AttachmentItemHeaders, unknown>;
export declare type UserFeedbackItem = BaseEnvelopeItem<UserFeedbackItemHeaders, UserFeedback>;
export declare type SessionItem = BaseEnvelopeItem<SessionItemHeaders, Session> | BaseEnvelopeItem<SessionAggregatesItemHeaders, SessionAggregates>;
export declare type ClientReportItem = BaseEnvelopeItem<ClientReportItemHeaders, ClientReport>;
declare type EventEnvelopeHeaders = {
    event_id: string;
    sent_at: string;
};
declare type SessionEnvelopeHeaders = {
    sent_at: string;
};
declare type ClientReportEnvelopeHeaders = BaseEnvelopeHeaders;
export declare type EventEnvelope = BaseEnvelope<EventEnvelopeHeaders, EventItem | AttachmentItem | UserFeedbackItem>;
export declare type SessionEnvelope = BaseEnvelope<SessionEnvelopeHeaders, SessionItem>;
export declare type ClientReportEnvelope = BaseEnvelope<ClientReportEnvelopeHeaders, ClientReportItem>;
export declare type Envelope = EventEnvelope | SessionEnvelope | ClientReportEnvelope;
export {};
//# sourceMappingURL=envelope.d.ts.map{"version":3,"file":"envelope.d.ts","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"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"}/**
 * Just an Error object with arbitrary attributes attached to it.
 */
export interface ExtendedError extends Error {
    [key: string]: any;
}
//# sourceMappingURL=error.d.ts.map{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,WAAW,aAAc,SAAQ,KAAK;IAC1C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB"}import { Breadcrumb } from './breadcrumb';
import { Contexts } from './context';
import { DebugMeta } from './debugMeta';
import { Exception } from './exception';
import { Extras } from './extra';
import { Primitive } from './misc';
import { Request } from './request';
import { CaptureContext } from './scope';
import { SdkInfo } from './sdkinfo';
import { Severity } from './severity';
import { Span } from './span';
import { Stacktrace } from './stacktrace';
import { Measurements } from './transaction';
import { User } from './user';
/** JSDoc */
export interface Event {
    event_id?: string;
    message?: string;
    timestamp?: number;
    start_timestamp?: number;
    level?: Severity;
    platform?: string;
    logger?: string;
    server_name?: string;
    release?: string;
    dist?: string;
    environment?: string;
    sdk?: SdkInfo;
    request?: Request;
    transaction?: string;
    modules?: {
        [key: string]: string;
    };
    fingerprint?: string[];
    exception?: {
        values?: Exception[];
    };
    stacktrace?: Stacktrace;
    breadcrumbs?: Breadcrumb[];
    contexts?: Contexts;
    tags?: {
        [key: string]: Primitive;
    };
    extra?: Extras;
    user?: User;
    type?: EventType;
    spans?: Span[];
    measurements?: Measurements;
    debug_meta?: DebugMeta;
    sdkProcessingMetadata?: {
        [key: string]: any;
    };
}
/** JSDoc */
export declare type EventType = 'transaction';
/** JSDoc */
export interface EventHint {
    event_id?: string;
    captureContext?: CaptureContext;
    syntheticException?: Error | null;
    originalException?: Error | string | null;
    data?: any;
}
//# sourceMappingURL=event.d.ts.map{"version":3,"file":"event.d.ts","sourceRoot":"","sources":["../../src/event.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AACrC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACjC,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B,YAAY;AACZ,MAAM,WAAW,KAAK;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,KAAK,CAAC,EAAE,QAAQ,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,GAAG,CAAC,EAAE,OAAO,CAAC;IACd,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IACvB,SAAS,CAAC,EAAE;QACV,MAAM,CAAC,EAAE,SAAS,EAAE,CAAC;KACtB,CAAC;IACF,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,WAAW,CAAC,EAAE,UAAU,EAAE,CAAC;IAC3B,QAAQ,CAAC,EAAE,QAAQ,CAAC;IACpB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IACpC,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,IAAI,CAAC,EAAE,IAAI,CAAC;IACZ,IAAI,CAAC,EAAE,SAAS,CAAC;IACjB,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC;IACf,YAAY,CAAC,EAAE,YAAY,CAAC;IAC5B,UAAU,CAAC,EAAE,SAAS,CAAC;IAEvB,qBAAqB,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CAChD;AAED,YAAY;AACZ,oBAAY,SAAS,GAAG,aAAa,CAAC;AAEtC,YAAY;AACZ,MAAM,WAAW,SAAS;IACxB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,cAAc,CAAC,EAAE,cAAc,CAAC;IAChC,kBAAkB,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;IAClC,iBAAiB,CAAC,EAAE,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC;IAC1C,IAAI,CAAC,EAAE,GAAG,CAAC;CACZ"}import { Event, EventHint } from './event';
/**
 * Event processors are used to change the event before it will be send.
 * We strongly advise to make this function sync.
 * Returning a PromiseLike<Event | null> will work just fine, but better be sure that you know what you are doing.
 * Event processing will be deferred until your Promise is resolved.
 */
export declare type EventProcessor = (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;
//# sourceMappingURL=eventprocessor.d.ts.map{"version":3,"file":"eventprocessor.d.ts","sourceRoot":"","sources":["../../src/eventprocessor.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAE3C;;;;;GAKG;AACH,oBAAY,cAAc,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,KAAK,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC"}export declare type EventStatus = 
/** The status could not be determined. */
'unknown'
/** The event was skipped due to configuration or callbacks. */
 | 'skipped'
/** The event was sent to Sentry successfully. */
 | 'rate_limit'
/** The client is currently rate limited and will try again later. */
 | 'invalid'
/** The event could not be processed. */
 | 'failed'
/** A server-side error occurred during submission. */
 | 'success';
//# sourceMappingURL=eventstatus.d.ts.map{"version":3,"file":"eventstatus.d.ts","sourceRoot":"","sources":["../../src/eventstatus.ts"],"names":[],"mappings":"AAAA,oBAAY,WAAW;AACrB,0CAA0C;AACxC,SAAS;AACX,+DAA+D;GAC7D,SAAS;AACX,iDAAiD;GAC/C,YAAY;AACd,qEAAqE;GACnE,SAAS;AACX,wCAAwC;GACtC,QAAQ;AACV,sDAAsD;GACpD,SAAS,CAAC"}import { Mechanism } from './mechanism';
import { Stacktrace } from './stacktrace';
/** JSDoc */
export interface Exception {
    type?: string;
    value?: string;
    mechanism?: Mechanism;
    module?: string;
    thread_id?: number;
    stacktrace?: Stacktrace;
}
//# sourceMappingURL=exception.d.ts.map{"version":3,"file":"exception.d.ts","sourceRoot":"","sources":["../../src/exception.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,SAAS;IACxB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,SAAS,CAAC,EAAE,SAAS,CAAC;IACtB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,UAAU,CAAC,EAAE,UAAU,CAAC;CACzB"}export declare type Extra = unknown;
export declare type Extras = Record<string, Extra>;
//# sourceMappingURL=extra.d.ts.map{"version":3,"file":"extra.d.ts","sourceRoot":"","sources":["../../src/extra.ts"],"names":[],"mappings":"AAAA,oBAAY,KAAK,GAAG,OAAO,CAAC;AAC5B,oBAAY,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC"}import { Breadcrumb, BreadcrumbHint } from './breadcrumb';
import { Client } from './client';
import { Event, EventHint } from './event';
import { Extra, Extras } from './extra';
import { Integration, IntegrationClass } from './integration';
import { Primitive } from './misc';
import { Scope } from './scope';
import { Session, SessionContext } from './session';
import { Severity } from './severity';
import { Span, SpanContext } from './span';
import { CustomSamplingContext, Transaction, TransactionContext } from './transaction';
import { User } from './user';
/**
 * Internal class used to make sure we always have the latest internal functions
 * working in case we have a version conflict.
 */
export interface Hub {
    /**
     * Checks if this hub's version is older than the given version.
     *
     * @param version A version number to compare to.
     * @return True if the given version is newer; otherwise false.
     *
     * @hidden
     */
    isOlderThan(version: number): boolean;
    /**
     * This binds the given client to the current scope.
     * @param client An SDK client (client) instance.
     */
    bindClient(client?: Client): void;
    /**
     * Create a new scope to store context information.
     *
     * The scope will be layered on top of the current one. It is isolated, i.e. all
     * breadcrumbs and context information added to this scope will be removed once
     * the scope ends. Be sure to always remove this scope with {@link this.popScope}
     * when the operation finishes or throws.
     *
     * @returns Scope, the new cloned scope
     */
    pushScope(): Scope;
    /**
     * Removes a previously pushed scope from the stack.
     *
     * This restores the state before the scope was pushed. All breadcrumbs and
     * context information added since the last call to {@link this.pushScope} are
     * discarded.
     */
    popScope(): boolean;
    /**
     * Creates a new scope with and executes the given operation within.
     * The scope is automatically removed once the operation
     * finishes or throws.
     *
     * This is essentially a convenience function for:
     *
     *     pushScope();
     *     callback();
     *     popScope();
     *
     * @param callback that will be enclosed into push/popScope.
     */
    withScope(callback: (scope: Scope) => void): void;
    /** Returns the client of the top stack. */
    getClient(): Client | undefined;
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @param hint May contain additional information about the original exception.
     * @returns The generated eventId.
     */
    captureException(exception: any, hint?: EventHint): string;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param level Define the level of the message.
     * @param hint May contain additional information about the original exception.
     * @returns The generated eventId.
     */
    captureMessage(message: string, level?: Severity, hint?: EventHint): string;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     */
    captureEvent(event: Event, hint?: EventHint): string;
    /**
     * This is the getter for lastEventId.
     *
     * @returns The last event id of a captured event.
     */
    lastEventId(): string | undefined;
    /**
     * Records a new breadcrumb which will be attached to future events.
     *
     * Breadcrumbs will be added to subsequent events to provide more context on
     * user's actions prior to an error or crash.
     *
     * @param breadcrumb The breadcrumb to record.
     * @param hint May contain additional information about the original breadcrumb.
     */
    addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    setUser(user: User | null): void;
    /**
     * Set an object that will be merged sent as tags data with the event.
     *
     * @param tags Tags context object to merge into current context.
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): void;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    setTag(key: string, value: Primitive): void;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    setExtra(key: string, extra: Extra): void;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    setExtras(extras: Extras): void;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context Any kind of data. This data will be normalized.
     */
    setContext(name: string, context: {
        [key: string]: any;
    } | null): void;
    /**
     * Callback to set context information onto the scope.
     *
     * @param callback Callback function that receives Scope.
     */
    configureScope(callback: (scope: Scope) => void): void;
    /**
     * For the duration of the callback, this hub will be set as the global current Hub.
     * This function is useful if you want to run your own client and hook into an already initialized one
     * e.g.: Reporting issues to your own sentry when running in your component while still using the users configuration.
     */
    run(callback: (hub: Hub) => void): void;
    /** Returns the integration if installed on the current client. */
    getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null;
    /** Returns all trace headers that are currently on the top scope. */
    traceHeaders(): {
        [key: string]: string;
    };
    /**
     * @deprecated No longer does anything. Use use {@link Transaction.startChild} instead.
     */
    startSpan(context: SpanContext): Span;
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     */
    startTransaction(context: TransactionContext, customSamplingContext?: CustomSamplingContext): Transaction;
    /**
     * Starts a new `Session`, sets on the current scope and returns it.
     *
     * To finish a `session`, it has to be passed directly to `client.captureSession`, which is done automatically
     * when using `hub.endSession()` for the session currently stored on the scope.
     *
     * When there's already an existing session on the scope, it'll be automatically ended.
     *
     * @param context Optional properties of the new `Session`.
     *
     * @returns The session which was just started
     */
    startSession(context?: SessionContext): Session;
    /**
     * Ends the session that lives on the current scope and sends it to Sentry
     */
    endSession(): void;
    /**
     * Sends the current session on the scope to Sentry
     * @param endSession If set the session will be marked as exited and removed from the scope
     */
    captureSession(endSession?: boolean): void;
}
//# sourceMappingURL=hub.d.ts.map{"version":3,"file":"hub.d.ts","sourceRoot":"","sources":["../../src/hub.ts"],"names":[],"mappings":"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"}export { Breadcrumb, BreadcrumbHint } from './breadcrumb';
export { Client } from './client';
export { ClientReport } from './clientreport';
export { Context, Contexts } from './context';
export { DsnComponents, DsnLike, DsnProtocol } from './dsn';
export { DebugImage, DebugImageType, DebugMeta } from './debugMeta';
export { AttachmentItem, BaseEnvelopeHeaders, BaseEnvelopeItemHeaders, ClientReportEnvelope, ClientReportItem, Envelope, EventEnvelope, EventItem, SessionEnvelope, SessionItem, UserFeedbackItem, } from './envelope';
export { ExtendedError } from './error';
export { Event, EventHint } from './event';
export { EventStatus } from './eventstatus';
export { EventProcessor } from './eventprocessor';
export { Exception } from './exception';
export { Extra, Extras } from './extra';
export { Hub } from './hub';
export { Integration, IntegrationClass } from './integration';
export { Mechanism } from './mechanism';
export { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';
export { Options } from './options';
export { Package } from './package';
export { QueryParams, Request, SentryRequest, SentryRequestType } from './request';
export { Response } from './response';
export { Runtime } from './runtime';
export { CaptureContext, Scope, ScopeContext } from './scope';
export { SdkInfo } from './sdkinfo';
export { SdkMetadata } from './sdkmetadata';
export { SessionAggregates, AggregationCounts, Session, SessionContext, SessionStatus, RequestSession, RequestSessionStatus, SessionFlusherLike, } from './session';
export { Severity } from './severity';
export { SeverityLevel, SeverityLevels } from './severity';
export { Span, SpanContext } from './span';
export { StackFrame } from './stackframe';
export { Stacktrace } from './stacktrace';
export { CustomSamplingContext, Measurements, SamplingContext, TraceparentData, Transaction, TransactionContext, TransactionMetadata, TransactionSamplingMethod, } from './transaction';
export { Thread } from './thread';
export { Outcome, Transport, TransportOptions, TransportClass } from './transport';
export { User, UserFeedback } from './user';
export { WrappedFunction } from './wrappedfunction';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAC9C,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AAC5D,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACpE,OAAO,EACL,cAAc,EACd,mBAAmB,EACnB,uBAAuB,EACvB,oBAAoB,EACpB,gBAAgB,EAChB,QAAQ,EACR,aAAa,EACb,SAAS,EACT,eAAe,EACf,WAAW,EACX,gBAAgB,GACjB,MAAM,YAAY,CAAC;AACpB,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAC5B,OAAO,EAAE,WAAW,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAC9D,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,wBAAwB,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAC7E,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AACnF,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,cAAc,EAAE,KAAK,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAC9D,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EACL,iBAAiB,EACjB,iBAAiB,EACjB,OAAO,EACP,cAAc,EACd,aAAa,EACb,cAAc,EACd,oBAAoB,EACpB,kBAAkB,GACnB,MAAM,WAAW,CAAC;AAEnB,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,aAAa,EAAE,cAAc,EAAE,MAAM,YAAY,CAAC;AAC3D,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAC3C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EACL,qBAAqB,EACrB,YAAY,EACZ,eAAe,EACf,eAAe,EACf,WAAW,EACX,kBAAkB,EAClB,mBAAmB,EACnB,yBAAyB,GAC1B,MAAM,eAAe,CAAC;AACvB,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,gBAAgB,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AACnF,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC"}import { EventProcessor } from './eventprocessor';
import { Hub } from './hub';
/** Integration Class Interface */
export interface IntegrationClass<T> {
    /**
     * Property that holds the integration name
     */
    id: string;
    new (...args: any[]): T;
}
/** Integration interface */
export interface Integration {
    /**
     * Returns {@link IntegrationClass.id}
     */
    name: string;
    /**
     * Sets the integration up only once.
     * This takes no options on purpose, options should be passed in the constructor
     */
    setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void;
}
//# sourceMappingURL=integration.d.ts.map{"version":3,"file":"integration.d.ts","sourceRoot":"","sources":["../../src/integration.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,GAAG,EAAE,MAAM,OAAO,CAAC;AAE5B,kCAAkC;AAClC,MAAM,WAAW,gBAAgB,CAAC,CAAC;IACjC;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX,KAAK,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;CACzB;AAED,4BAA4B;AAC5B,MAAM,WAAW,WAAW;IAC1B;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;OAGG;IACH,SAAS,CAAC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,cAAc,KAAK,IAAI,EAAE,aAAa,EAAE,MAAM,GAAG,GAAG,IAAI,CAAC;CACxG"}/**
 * Metadata about a captured exception, intended to provide a hint as to the means by which it was captured.
 */
export interface Mechanism {
    /**
     * For now, restricted to `onerror`, `onunhandledrejection` (both obvious), `instrument` (the result of
     * auto-instrumentation), and `generic` (everything else). Converted to a tag on ingest.
     */
    type: string;
    /**
     * In theory, whether or not the exception has been handled by the user. In practice, whether or not we see it before
     * it hits the global error/rejection handlers, whether through explicit handling by the user or auto instrumentation.
     * Converted to a tag on ingest and used in various ways in the UI.
     */
    handled: boolean;
    /**
     * Arbitrary data to be associated with the mechanism (for example, errors coming from event handlers include the
     * handler name and the event target. Will show up in the UI directly above the stacktrace.
     */
    data?: {
        [key: string]: string | boolean;
    };
    /**
     * True when `captureException` is called with anything other than an instance of `Error` (or, in the case of browser,
     * an instance of `ErrorEvent`, `DOMError`, or `DOMException`). causing us to create a synthetic error in an attempt
     * to recreate the stacktrace.
     */
    synthetic?: boolean;
}
//# sourceMappingURL=mechanism.d.ts.map{"version":3,"file":"mechanism.d.ts","sourceRoot":"","sources":["../../src/mechanism.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,WAAW,SAAS;IACxB;;;OAGG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;;OAIG;IACH,OAAO,EAAE,OAAO,CAAC;IAEjB;;;OAGG;IACH,IAAI,CAAC,EAAE;QACL,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;KACjC,CAAC;IAEF;;;;OAIG;IACH,SAAS,CAAC,EAAE,OAAO,CAAC;CACrB"}import { QueryParams } from './request';
/**
 * Data extracted from an incoming request to a node server
 */
export interface ExtractedNodeRequestData {
    [key: string]: any;
    /** Specific headers from the request */
    headers?: {
        [key: string]: string;
    };
    /**  The request's method */
    method?: string;
    /** The request's URL, including query string */
    url?: string;
    /** String representing the cookies sent along with the request */
    cookies?: {
        [key: string]: string;
    };
    /** The request's query params */
    query_string?: QueryParams;
    /** Any data sent in the request's body, as a JSON string */
    data?: string;
}
/**
 * Location object on a service worker's `self` object.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WorkerLocation.
 */
export interface WorkerLocation {
    /** The protocol scheme of the URL of the script executed in the Worker, including the final ':'. */
    readonly protocol: string;
    /** The host, that is the hostname, a ':', and the port of the URL of the script executed in the Worker. */
    readonly host: string;
    /** The domain of the URL of the script executed in the Worker. */
    readonly hostname: string;
    /** The canonical form of the origin of the specific location. */
    readonly origin: string;
    /** The port number of the URL of the script executed in the Worker. */
    readonly port: string;
    /** The path of the URL of the script executed in the Worker, beginning with a '/'. */
    readonly pathname: string;
    /** The parameters (query string) of the URL of the script executed in the Worker, beginning with a '?'. */
    readonly search: string;
    /** The fragment identifier of the URL of the script executed in the Worker, beginning with a '#'. */
    readonly hash: string;
    /** Stringifier that returns the whole URL of the script executed in the Worker. */
    readonly href: string;
    /** Synonym for `href` attribute */
    toString(): string;
}
export declare type Primitive = number | string | boolean | bigint | symbol | null | undefined;
//# sourceMappingURL=misc.d.ts.map{"version":3,"file":"misc.d.ts","sourceRoot":"","sources":["../../src/misc.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC;;GAEG;AACH,MAAM,WAAW,wBAAwB;IACvC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IAEnB,wCAAwC;IACxC,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAEpC,4BAA4B;IAC5B,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB,gDAAgD;IAChD,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb,kEAAkE;IAClE,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAEpC,iCAAiC;IACjC,YAAY,CAAC,EAAE,WAAW,CAAC;IAE3B,4DAA4D;IAC5D,IAAI,CAAC,EAAE,MAAM,CAAC;CACf;AAED;;;;GAIG;AACH,MAAM,WAAW,cAAc;IAC7B,oGAAoG;IACpG,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,2GAA2G;IAC3G,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,kEAAkE;IAClE,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,iEAAiE;IACjE,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAExB,uEAAuE;IACvE,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,sFAAsF;IACtF,QAAQ,CAAC,QAAQ,EAAE,MAAM,CAAC;IAE1B,2GAA2G;IAC3G,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;IAExB,qGAAqG;IACrG,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,mFAAmF;IACnF,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IAEtB,mCAAmC;IACnC,QAAQ,IAAI,MAAM,CAAC;CACpB;AAED,oBAAY,SAAS,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC"}import { Breadcrumb, BreadcrumbHint } from './breadcrumb';
import { Event, EventHint } from './event';
import { Integration } from './integration';
import { CaptureContext } from './scope';
import { SdkMetadata } from './sdkmetadata';
import { SamplingContext } from './transaction';
import { Transport, TransportClass, TransportOptions } from './transport';
/** Base configuration options for every SDK. */
export interface Options {
    /**
     * Enable debug functionality in the SDK itself
     */
    debug?: boolean;
    /**
     * Specifies whether this SDK should send events to Sentry.
     * Defaults to true.
     */
    enabled?: boolean;
    /**
     * The Dsn used to connect to Sentry and identify the project. If omitted, the
     * SDK will not send any data to Sentry.
     */
    dsn?: string;
    /**
     * If this is set to false, default integrations will not be added, otherwise this will internally be set to the
     * recommended default integrations.
     * TODO: We should consider changing this to `boolean | Integration[]`
     */
    defaultIntegrations?: false | Integration[];
    /**
     * List of integrations that should be installed after SDK was initialized.
     * Accepts either a list of integrations or a function that receives
     * default integrations and returns a new, updated list.
     */
    integrations?: Integration[] | ((integrations: Integration[]) => Integration[]);
    /**
     * A pattern for error messages which should not be sent to Sentry.
     * By default, all errors will be sent.
     */
    ignoreErrors?: Array<string | RegExp>;
    /**
     * Transport object that should be used to send events to Sentry
     */
    transport?: TransportClass<Transport>;
    /**
     * Options for the default transport that the SDK uses.
     */
    transportOptions?: TransportOptions;
    /**
     * A URL to an envelope tunnel endpoint. An envelope tunnel is an HTTP endpoint
     * that accepts Sentry envelopes for forwarding. This can be used to force data
     * through a custom server independent of the type of data.
     */
    tunnel?: string;
    /**
     * The release identifier used when uploading respective source maps. Specify
     * this value to allow Sentry to resolve the correct source maps when
     * processing events.
     */
    release?: string;
    /** The current environment of your application (e.g. "production"). */
    environment?: string;
    /** Sets the distribution for all events */
    dist?: string;
    /**
     * The maximum number of breadcrumbs sent with events. Defaults to 100.
     * Values over 100 will be ignored and 100 used instead.
     */
    maxBreadcrumbs?: number;
    /** A global sample rate to apply to all events (0 - 1). */
    sampleRate?: number;
    /** Attaches stacktraces to pure capture message / log integrations */
    attachStacktrace?: boolean;
    /** Maximum number of chars a single value can have before it will be truncated. */
    maxValueLength?: number;
    /**
     * Maximum number of levels that normalization algorithm will traverse in objects and arrays.
     * Used when normalizing an event before sending, on all of the listed attributes:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * Defaults to `3`. Set to `0` to disable.
     */
    normalizeDepth?: number;
    /**
     * Maximum number of properties or elements that the normalization algorithm will output in any single array or object included in the normalized event.
     * Used when normalizing an event before sending, on all of the listed attributes:
     * - `breadcrumbs.data`
     * - `user`
     * - `contexts`
     * - `extra`
     * Defaults to `1000`
     */
    normalizeMaxBreadth?: number;
    /**
     * Controls how many milliseconds to wait before shutting down. The default is
     * SDK-specific but typically around 2 seconds. Setting this too low can cause
     * problems for sending events from command line applications. Setting it too
     * high can cause the application to block for users with network connectivity
     * problems.
     */
    shutdownTimeout?: number;
    /**
     * Sample rate to determine trace sampling.
     *
     * 0.0 = 0% chance of a given trace being sent (send no traces) 1.0 = 100% chance of a given trace being sent (send
     * all traces)
     *
     * Tracing is enabled if either this or `tracesSampler` is defined. If both are defined, `tracesSampleRate` is
     * ignored.
     */
    tracesSampleRate?: number;
    /**
     * A flag enabling Sessions Tracking feature.
     * By default, Sessions Tracking is enabled.
     */
    autoSessionTracking?: boolean;
    /**
     * Send SDK Client Reports.
     * By default, Client Reports are enabled.
     */
    sendClientReports?: boolean;
    /**
     * Initial data to populate scope.
     */
    initialScope?: CaptureContext;
    /**
     * Set of metadata about the SDK that can be internally used to enhance envelopes and events,
     * and provide additional data about every request.
     * */
    _metadata?: SdkMetadata;
    /**
     * Options which are in beta, or otherwise not guaranteed to be stable.
     */
    _experiments?: {
        [key: string]: any;
    };
    /**
     * Function to compute tracing sample rate dynamically and filter unwanted traces.
     *
     * Tracing is enabled if either this or `tracesSampleRate` is defined. If both are defined, `tracesSampleRate` is
     * ignored.
     *
     * Will automatically be passed a context object of default and optional custom data. See
     * {@link Transaction.samplingContext} and {@link Hub.startTransaction}.
     *
     * @returns A sample rate between 0 and 1 (0 drops the trace, 1 guarantees it will be sent). Returning `true` is
     * equivalent to returning 1 and returning `false` is equivalent to returning 0.
     */
    tracesSampler?: (samplingContext: SamplingContext) => number | boolean;
    /**
     * A callback invoked during event submission, allowing to optionally modify
     * the event before it is sent to Sentry.
     *
     * Note that you must return a valid event from this callback. If you do not
     * wish to modify the event, simply return it at the end.
     * Returning null will cause the event to be dropped.
     *
     * @param event The error or message event generated by the SDK.
     * @param hint May contain additional information about the original exception.
     * @returns A new event that will be sent | null.
     */
    beforeSend?: (event: Event, hint?: EventHint) => PromiseLike<Event | null> | Event | null;
    /**
     * A callback invoked when adding a breadcrumb, allowing to optionally modify
     * it before adding it to future events.
     *
     * Note that you must return a valid breadcrumb from this callback. If you do
     * not wish to modify the breadcrumb, simply return it at the end.
     * Returning null will cause the breadcrumb to be dropped.
     *
     * @param breadcrumb The breadcrumb as created by the SDK.
     * @returns The breadcrumb that will be added | null.
     */
    beforeBreadcrumb?: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => Breadcrumb | null;
}
//# sourceMappingURL=options.d.ts.map{"version":3,"file":"options.d.ts","sourceRoot":"","sources":["../../src/options.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAChD,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,gBAAgB,EAAE,MAAM,aAAa,CAAC;AAE1E,gDAAgD;AAChD,MAAM,WAAW,OAAO;IACtB;;OAEG;IACH,KAAK,CAAC,EAAE,OAAO,CAAC;IAEhB;;;OAGG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;;OAGG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;;;OAIG;IACH,mBAAmB,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,CAAC;IAE5C;;;;OAIG;IACH,YAAY,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC,YAAY,EAAE,WAAW,EAAE,KAAK,WAAW,EAAE,CAAC,CAAC;IAEhF;;;OAGG;IACH,YAAY,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IAEtC;;OAEG;IACH,SAAS,CAAC,EAAE,cAAc,CAAC,SAAS,CAAC,CAAC;IAEtC;;OAEG;IACH,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;IAEpC;;;;OAIG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;;;OAIG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB,uEAAuE;IACvE,WAAW,CAAC,EAAE,MAAM,CAAC;IAErB,2CAA2C;IAC3C,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;;OAGG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB,2DAA2D;IAC3D,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,sEAAsE;IACtE,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAE3B,mFAAmF;IACnF,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;;;;;;;OAQG;IACH,cAAc,CAAC,EAAE,MAAM,CAAC;IAExB;;;;;;;;OAQG;IACH,mBAAmB,CAAC,EAAE,MAAM,CAAC;IAE7B;;;;;;OAMG;IACH,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB;;;;;;;;OAQG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;;OAGG;IACH,mBAAmB,CAAC,EAAE,OAAO,CAAC;IAE9B;;;OAGG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAE5B;;OAEG;IACH,YAAY,CAAC,EAAE,cAAc,CAAC;IAE9B;;;SAGK;IACL,SAAS,CAAC,EAAE,WAAW,CAAC;IAExB;;OAEG;IACH,YAAY,CAAC,EAAE;QACb,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;KACpB,CAAC;IAEF;;;;;;;;;;;OAWG;IACH,aAAa,CAAC,EAAE,CAAC,eAAe,EAAE,eAAe,KAAK,MAAM,GAAG,OAAO,CAAC;IAEvE;;;;;;;;;;;OAWG;IACH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,EAAE,SAAS,KAAK,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC;IAE1F;;;;;;;;;;OAUG;IACH,gBAAgB,CAAC,EAAE,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,EAAE,cAAc,KAAK,UAAU,GAAG,IAAI,CAAC;CACzF"}/** JSDoc */
export interface Package {
    name: string;
    version: string;
}
//# sourceMappingURL=package.d.ts.map{"version":3,"file":"package.d.ts","sourceRoot":"","sources":["../../src/package.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,OAAO;IACtB,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;CACjB"}/** Possible SentryRequest types that can be used to make a distinction between Sentry features */
export declare type SentryRequestType = 'event' | 'transaction' | 'session' | 'attachment';
/** A generic client request. */
export interface SentryRequest {
    body: string;
    type: SentryRequestType;
    url: string;
}
/** Request data included in an event as sent to Sentry */
export interface Request {
    url?: string;
    method?: string;
    data?: any;
    query_string?: QueryParams;
    cookies?: {
        [key: string]: string;
    };
    env?: {
        [key: string]: string;
    };
    headers?: {
        [key: string]: string;
    };
}
export declare type QueryParams = string | {
    [key: string]: string;
} | Array<[string, string]>;
//# sourceMappingURL=request.d.ts.map{"version":3,"file":"request.d.ts","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"AAAA,kGAAkG;AAElG,oBAAY,iBAAiB,GAAG,OAAO,GAAG,aAAa,GAAG,SAAS,GAAG,YAAY,CAAC;AAEnF,gCAAgC;AAChC,MAAM,WAAW,aAAa;IAC5B,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,iBAAiB,CAAC;IACxB,GAAG,EAAE,MAAM,CAAC;CACb;AAED,0DAA0D;AAC1D,MAAM,WAAW,OAAO;IACtB,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,GAAG,CAAC;IACX,YAAY,CAAC,EAAE,WAAW,CAAC;IAC3B,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,GAAG,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAChC,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;CACrC;AAED,oBAAY,WAAW,GAAG,MAAM,GAAG;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;CAAE,GAAG,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC"}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to RequestSessionStatus type
 */
export declare enum RequestSessionStatus {
    /** JSDoc */
    Ok = "ok",
    /** JSDoc */
    Errored = "errored",
    /** JSDoc */
    Crashed = "crashed"
}
//# sourceMappingURL=requestsessionstatus.d.ts.map{"version":3,"file":"requestsessionstatus.d.ts","sourceRoot":"","sources":["../../src/requestsessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,oBAAoB;IAC9B,YAAY;IACZ,EAAE,OAAO;IACT,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,OAAO,YAAY;CACpB"}import { Event, EventType } from './event';
import { EventStatus } from './eventstatus';
import { Session } from './session';
/** JSDoc */
export interface Response {
    status: EventStatus;
    event?: Event | Session;
    type?: EventType;
    reason?: string;
}
//# sourceMappingURL=response.d.ts.map{"version":3,"file":"response.d.ts","sourceRoot":"","sources":["../../src/response.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,YAAY;AACZ,MAAM,WAAW,QAAQ;IACvB,MAAM,EAAE,WAAW,CAAC;IACpB,KAAK,CAAC,EAAE,KAAK,GAAG,OAAO,CAAC;IACxB,IAAI,CAAC,EAAE,SAAS,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB"}/** Runtime Context. */
export interface Runtime {
    name?: string;
    version?: string;
}
//# sourceMappingURL=runtime.d.ts.map{"version":3,"file":"runtime.d.ts","sourceRoot":"","sources":["../../src/runtime.ts"],"names":[],"mappings":"AAAA,uBAAuB;AACvB,MAAM,WAAW,OAAO;IACtB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB"}import { Breadcrumb } from './breadcrumb';
import { Context, Contexts } from './context';
import { EventProcessor } from './eventprocessor';
import { Extra, Extras } from './extra';
import { Primitive } from './misc';
import { RequestSession, Session } from './session';
import { Severity } from './severity';
import { Span } from './span';
import { Transaction } from './transaction';
import { User } from './user';
/** JSDocs */
export declare type CaptureContext = Scope | Partial<ScopeContext> | ((scope: Scope) => Scope);
/** JSDocs */
export interface ScopeContext {
    user: User;
    level: Severity;
    extra: Extras;
    contexts: Contexts;
    tags: {
        [key: string]: Primitive;
    };
    fingerprint: string[];
    requestSession: RequestSession;
}
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be called by the client before an event is sent.
 */
export interface Scope {
    /** Add new event processor that will be called after {@link applyToEvent}. */
    addEventProcessor(callback: EventProcessor): this;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    setUser(user: User | null): this;
    /**
     * Returns the `User` if there is one
     */
    getUser(): User | undefined;
    /**
     * Set an object that will be merged sent as tags data with the event.
     * @param tags Tags context object to merge into current context.
     */
    setTags(tags: {
        [key: string]: Primitive;
    }): this;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    setExtras(extras: Extras): this;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    setExtra(key: string, extra: Extra): this;
    /**
     * Sets the fingerprint on the scope to send with the events.
     * @param fingerprint string[] to group events in Sentry.
     */
    setFingerprint(fingerprint: string[]): this;
    /**
     * Sets the level on the scope for future events.
     * @param level string {@link Severity}
     */
    setLevel(level: Severity): this;
    /**
     * Sets the transaction name on the scope for future events.
     */
    setTransactionName(name?: string): this;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context an object containing context data. This data will be normalized. Pass `null` to unset the context.
     */
    setContext(name: string, context: Context | null): this;
    /**
     * Sets the Span on the scope.
     * @param span Span
     */
    setSpan(span?: Span): this;
    /**
     * Returns the `Span` if there is one
     */
    getSpan(): Span | undefined;
    /**
     * Returns the `Transaction` attached to the scope (if there is one)
     */
    getTransaction(): Transaction | undefined;
    /**
     * Returns the `Session` if there is one
     */
    getSession(): Session | undefined;
    /**
     * Sets the `Session` on the scope
     */
    setSession(session?: Session): this;
    /**
     * Returns the `RequestSession` if there is one
     */
    getRequestSession(): RequestSession | undefined;
    /**
     * Sets the `RequestSession` on the scope
     */
    setRequestSession(requestSession?: RequestSession): this;
    /**
     * Updates the scope with provided data. Can work in three variations:
     * - plain object containing updatable attributes
     * - Scope instance that'll extract the attributes from
     * - callback function that'll receive the current scope as an argument and allow for modifications
     * @param captureContext scope modifier to be used
     */
    update(captureContext?: CaptureContext): this;
    /** Clears the current scope and resets its properties. */
    clear(): this;
    /**
     * Sets the breadcrumbs in the scope
     * @param breadcrumbs Breadcrumb
     * @param maxBreadcrumbs number of max breadcrumbs to merged into event.
     */
    addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this;
    /**
     * Clears all currently set Breadcrumbs.
     */
    clearBreadcrumbs(): this;
}
//# sourceMappingURL=scope.d.ts.map{"version":3,"file":"scope.d.ts","sourceRoot":"","sources":["../../src/scope.ts"],"names":[],"mappings":"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"}import { Package } from './package';
export interface SdkInfo {
    name?: string;
    version?: string;
    integrations?: string[];
    packages?: Package[];
}
//# sourceMappingURL=sdkinfo.d.ts.map{"version":3,"file":"sdkinfo.d.ts","sourceRoot":"","sources":["../../src/sdkinfo.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,MAAM,WAAW,OAAO;IACtB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,QAAQ,CAAC,EAAE,OAAO,EAAE,CAAC;CACtB"}import { SdkInfo } from './sdkinfo';
export interface SdkMetadata {
    sdk?: SdkInfo;
}
//# sourceMappingURL=sdkmetadata.d.ts.map{"version":3,"file":"sdkmetadata.d.ts","sourceRoot":"","sources":["../../src/sdkmetadata.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AAEpC,MAAM,WAAW,WAAW;IAC1B,GAAG,CAAC,EAAE,OAAO,CAAC;CACf"}import { User } from './user';
/**
 * @inheritdoc
 */
export interface Session extends SessionContext {
    /** JSDoc */
    update(context?: SessionContext): void;
    /** JSDoc */
    close(status?: SessionStatus): void;
    /** JSDoc */
    toJSON(): {
        init: boolean;
        sid: string;
        did?: string;
        timestamp: string;
        started: string;
        duration?: number;
        status: SessionStatus;
        errors: number;
        attrs?: {
            release?: string;
            environment?: string;
            user_agent?: string;
            ip_address?: string;
        };
    };
}
export interface RequestSession {
    status?: RequestSessionStatus;
}
/**
 * Session Context
 */
export interface SessionContext {
    sid?: string;
    did?: string;
    init?: boolean;
    timestamp?: number;
    started?: number;
    duration?: number;
    status?: SessionStatus;
    release?: string;
    environment?: string;
    userAgent?: string;
    ipAddress?: string;
    errors?: number;
    user?: User | null;
    ignoreDuration?: boolean;
}
export declare type SessionStatus = 'ok' | 'exited' | 'crashed' | 'abnormal';
export declare type RequestSessionStatus = 'ok' | 'errored' | 'crashed';
/** JSDoc */
export interface SessionAggregates {
    attrs?: {
        environment?: string;
        release?: string;
    };
    aggregates: Array<AggregationCounts>;
}
export interface SessionFlusherLike {
    /**
     * Increments the Session Status bucket in SessionAggregates Object corresponding to the status of the session
     * captured
     */
    incrementSessionStatusCount(): void;
    /** Submits the aggregates request mode sessions to Sentry */
    sendSessionAggregates(sessionAggregates: SessionAggregates): void;
    /** Empties Aggregate Buckets and Sends them to Transport Buffer */
    flush(): void;
    /** Clears setInterval and calls flush */
    close(): void;
}
export interface AggregationCounts {
    started: string;
    errored?: number;
    exited?: number;
    crashed?: number;
}
//# sourceMappingURL=session.d.ts.map{"version":3,"file":"session.d.ts","sourceRoot":"","sources":["../../src/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAE9B;;GAEG;AACH,MAAM,WAAW,OAAQ,SAAQ,cAAc;IAC7C,YAAY;IACZ,MAAM,CAAC,OAAO,CAAC,EAAE,cAAc,GAAG,IAAI,CAAC;IAEvC,YAAY;IACZ,KAAK,CAAC,MAAM,CAAC,EAAE,aAAa,GAAG,IAAI,CAAC;IAEpC,YAAY;IACZ,MAAM,IAAI;QACR,IAAI,EAAE,OAAO,CAAC;QACd,GAAG,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,SAAS,EAAE,MAAM,CAAC;QAClB,OAAO,EAAE,MAAM,CAAC;QAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,MAAM,EAAE,aAAa,CAAC;QACtB,MAAM,EAAE,MAAM,CAAC;QACf,KAAK,CAAC,EAAE;YACN,OAAO,CAAC,EAAE,MAAM,CAAC;YACjB,WAAW,CAAC,EAAE,MAAM,CAAC;YACrB,UAAU,CAAC,EAAE,MAAM,CAAC;YACpB,UAAU,CAAC,EAAE,MAAM,CAAC;SACrB,CAAC;KACH,CAAC;CACH;AAED,MAAM,WAAW,cAAc;IAC7B,MAAM,CAAC,EAAE,oBAAoB,CAAC;CAC/B;AAED;;GAEG;AACH,MAAM,WAAW,cAAc;IAC7B,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,OAAO,CAAC;IAEf,SAAS,CAAC,EAAE,MAAM,CAAC;IAEnB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,aAAa,CAAC;IACvB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,IAAI,CAAC,EAAE,IAAI,GAAG,IAAI,CAAC;IACnB,cAAc,CAAC,EAAE,OAAO,CAAC;CAC1B;AAED,oBAAY,aAAa,GAAG,IAAI,GAAG,QAAQ,GAAG,SAAS,GAAG,UAAU,CAAC;AACrE,oBAAY,oBAAoB,GAAG,IAAI,GAAG,SAAS,GAAG,SAAS,CAAC;AAEhE,YAAY;AACZ,MAAM,WAAW,iBAAiB;IAChC,KAAK,CAAC,EAAE;QACN,WAAW,CAAC,EAAE,MAAM,CAAC;QACrB,OAAO,CAAC,EAAE,MAAM,CAAC;KAClB,CAAC;IACF,UAAU,EAAE,KAAK,CAAC,iBAAiB,CAAC,CAAC;CACtC;AAED,MAAM,WAAW,kBAAkB;IACjC;;;OAGG;IACH,2BAA2B,IAAI,IAAI,CAAC;IAEpC,6DAA6D;IAC7D,qBAAqB,CAAC,iBAAiB,EAAE,iBAAiB,GAAG,IAAI,CAAC;IAElE,mEAAmE;IACnE,KAAK,IAAI,IAAI,CAAC;IAEd,yCAAyC;IACzC,KAAK,IAAI,IAAI,CAAC;CACf;AAED,MAAM,WAAW,iBAAiB;IAChC,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB"}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to SessionStatus type
 */
export declare enum SessionStatus {
    /** JSDoc */
    Ok = "ok",
    /** JSDoc */
    Exited = "exited",
    /** JSDoc */
    Crashed = "crashed",
    /** JSDoc */
    Abnormal = "abnormal"
}
//# sourceMappingURL=sessionstatus.d.ts.map{"version":3,"file":"sessionstatus.d.ts","sourceRoot":"","sources":["../../src/sessionstatus.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,aAAa;IACvB,YAAY;IACZ,EAAE,OAAO;IACT,YAAY;IACZ,MAAM,WAAW;IACjB,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,QAAQ,aAAa;CACtB"}/**
 * TODO(v7): Remove this enum and replace with SeverityLevel
 */
export declare enum Severity {
    /** JSDoc */
    Fatal = "fatal",
    /** JSDoc */
    Error = "error",
    /** JSDoc */
    Warning = "warning",
    /** JSDoc */
    Log = "log",
    /** JSDoc */
    Info = "info",
    /** JSDoc */
    Debug = "debug",
    /** JSDoc */
    Critical = "critical"
}
export declare const SeverityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug", "critical"];
export declare type SeverityLevel = typeof SeverityLevels[number];
//# sourceMappingURL=severity.d.ts.map{"version":3,"file":"severity.d.ts","sourceRoot":"","sources":["../../src/severity.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,QAAQ;IAClB,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,OAAO,YAAY;IACnB,YAAY;IACZ,GAAG,QAAQ;IACX,YAAY;IACZ,IAAI,SAAS;IACb,YAAY;IACZ,KAAK,UAAU;IACf,YAAY;IACZ,QAAQ,aAAa;CACtB;AAID,eAAO,MAAM,cAAc,4EAA6E,CAAC;AACzG,oBAAY,aAAa,GAAG,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC"}import { Primitive } from './misc';
import { Transaction } from './transaction';
/** Interface holding all properties that can be set on a Span on creation. */
export interface SpanContext {
    /**
     * Description of the Span.
     */
    description?: string;
    /**
     * Operation of the Span.
     */
    op?: string;
    /**
     * Completion status of the Span.
     * See: {@sentry/tracing SpanStatus} for possible values
     */
    status?: string;
    /**
     * Parent Span ID
     */
    parentSpanId?: string;
    /**
     * Was this span chosen to be sent as part of the sample?
     */
    sampled?: boolean;
    /**
     * Span ID
     */
    spanId?: string;
    /**
     * Trace ID
     */
    traceId?: string;
    /**
     * Tags of the Span.
     */
    tags?: {
        [key: string]: Primitive;
    };
    /**
     * Data of the Span.
     */
    data?: {
        [key: string]: any;
    };
    /**
     * Timestamp in seconds (epoch time) indicating when the span started.
     */
    startTimestamp?: number;
    /**
     * Timestamp in seconds (epoch time) indicating when the span ended.
     */
    endTimestamp?: number;
}
/** Span holding trace_id, span_id */
export interface Span extends SpanContext {
    /**
     * @inheritDoc
     */
    spanId: string;
    /**
     * @inheritDoc
     */
    traceId: string;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * The transaction containing this span
     */
    transaction?: Transaction;
    /**
     * Sets the finish timestamp on the current span.
     * @param endTimestamp Takes an endTimestamp if the end should not be the time when you call this function.
     */
    finish(endTimestamp?: number): void;
    /**
     * Sets the tag attribute on the current span.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key Tag key
     * @param value Tag value
     */
    setTag(key: string, value: Primitive): this;
    /**
     * Sets the data attribute on the current span
     * @param key Data key
     * @param value Data value
     */
    setData(key: string, value: any): this;
    /**
     * Sets the status attribute on the current span
     * See: {@sentry/tracing SpanStatus} for possible values
     * @param status http code used to set the status
     */
    setStatus(status: string): this;
    /**
     * Sets the status attribute on the current span based on the http code
     * @param httpStatus http code used to set the status
     */
    setHttpStatus(httpStatus: number): this;
    /**
     * Use {@link startChild}
     * @deprecated
     */
    child(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
     * Also the `sampled` decision will be inherited.
     */
    startChild(spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>): Span;
    /**
     * Determines whether span was successful (HTTP200)
     */
    isSuccess(): boolean;
    /** Return a traceparent compatible header string */
    toTraceparent(): string;
    /** Returns the current span properties as a `SpanContext` */
    toContext(): SpanContext;
    /** Updates the current span with a new `SpanContext` */
    updateWithContext(spanContext: SpanContext): this;
    /** Convert the object to JSON for w. spans array info only */
    getTraceContext(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        status?: string;
        tags?: {
            [key: string]: Primitive;
        };
        trace_id: string;
    };
    /** Convert the object to JSON */
    toJSON(): {
        data?: {
            [key: string]: any;
        };
        description?: string;
        op?: string;
        parent_span_id?: string;
        span_id: string;
        start_timestamp: number;
        status?: string;
        tags?: {
            [key: string]: Primitive;
        };
        timestamp?: number;
        trace_id: string;
    };
}
//# sourceMappingURL=span.d.ts.map{"version":3,"file":"span.d.ts","sourceRoot":"","sources":["../../src/span.ts"],"names":[],"mappings":"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"}/** JSDoc */
export interface StackFrame {
    filename?: string;
    function?: string;
    module?: string;
    platform?: string;
    lineno?: number;
    colno?: number;
    abs_path?: string;
    context_line?: string;
    pre_context?: string[];
    post_context?: string[];
    in_app?: boolean;
    instruction_addr?: string;
    addr_mode?: string;
    vars?: {
        [key: string]: any;
    };
}
//# sourceMappingURL=stackframe.d.ts.map{"version":3,"file":"stackframe.d.ts","sourceRoot":"","sources":["../../src/stackframe.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IACvB,YAAY,CAAC,EAAE,MAAM,EAAE,CAAC;IACxB,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,IAAI,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;CAC/B"}import { StackFrame } from './stackframe';
/** JSDoc */
export interface Stacktrace {
    frames?: StackFrame[];
    frames_omitted?: [number, number];
}
//# sourceMappingURL=stacktrace.d.ts.map{"version":3,"file":"stacktrace.d.ts","sourceRoot":"","sources":["../../src/stacktrace.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,UAAU;IACzB,MAAM,CAAC,EAAE,UAAU,EAAE,CAAC;IACtB,cAAc,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CACnC"}/** JSDoc
 * @deprecated Use string literals - if you require type casting, cast to EventStatus type
 */
export declare enum Status {
    /** The status could not be determined. */
    Unknown = "unknown",
    /** The event was skipped due to configuration or callbacks. */
    Skipped = "skipped",
    /** The event was sent to Sentry successfully. */
    Success = "success",
    /** The client is currently rate limited and will try again later. */
    RateLimit = "rate_limit",
    /** The event could not be processed. */
    Invalid = "invalid",
    /** A server-side error occurred during submission. */
    Failed = "failed"
}
//# sourceMappingURL=status.d.ts.map{"version":3,"file":"status.d.ts","sourceRoot":"","sources":["../../src/status.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,oBAAY,MAAM;IAChB,0CAA0C;IAC1C,OAAO,YAAY;IACnB,+DAA+D;IAC/D,OAAO,YAAY;IACnB,iDAAiD;IACjD,OAAO,YAAY;IACnB,qEAAqE;IACrE,SAAS,eAAe;IACxB,wCAAwC;IACxC,OAAO,YAAY;IACnB,sDAAsD;IACtD,MAAM,WAAW;CAClB"}import { Stacktrace } from './stacktrace';
/** JSDoc */
export interface Thread {
    id?: number;
    name?: string;
    stacktrace?: Stacktrace;
    crashed?: boolean;
    current?: boolean;
}
//# sourceMappingURL=thread.d.ts.map{"version":3,"file":"thread.d.ts","sourceRoot":"","sources":["../../src/thread.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAE1C,YAAY;AACZ,MAAM,WAAW,MAAM;IACrB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,UAAU,CAAC,EAAE,UAAU,CAAC;IACxB,OAAO,CAAC,EAAE,OAAO,CAAC;IAClB,OAAO,CAAC,EAAE,OAAO,CAAC;CACnB"}import { ExtractedNodeRequestData, Primitive, WorkerLocation } from './misc';
import { Span, SpanContext } from './span';
/**
 * Interface holding Transaction-specific properties
 */
export interface TransactionContext extends SpanContext {
    /**
     * Human-readable identifier for the transaction
     */
    name: string;
    /**
     * If true, sets the end timestamp of the transaction to the highest timestamp of child spans, trimming
     * the duration of the transaction. This is useful to discard extra time in the transaction that is not
     * accounted for in child spans, like what happens in the idle transaction Tracing integration, where we finish the
     * transaction after a given "idle time" and we don't want this "idle time" to be part of the transaction.
     */
    trimEnd?: boolean;
    /**
     * If this transaction has a parent, the parent's sampling decision
     */
    parentSampled?: boolean;
    /**
     * Metadata associated with the transaction, for internal SDK use.
     */
    metadata?: TransactionMetadata;
}
/**
 * Data pulled from a `sentry-trace` header
 */
export declare type TraceparentData = Pick<TransactionContext, 'traceId' | 'parentSpanId' | 'parentSampled'>;
/**
 * Transaction "Class", inherits Span only has `setName`
 */
export interface Transaction extends TransactionContext, Span {
    /**
     * @inheritDoc
     */
    spanId: string;
    /**
     * @inheritDoc
     */
    traceId: string;
    /**
     * @inheritDoc
     */
    startTimestamp: number;
    /**
     * @inheritDoc
     */
    tags: {
        [key: string]: Primitive;
    };
    /**
     * @inheritDoc
     */
    data: {
        [key: string]: any;
    };
    /**
     * Metadata about the transaction
     */
    metadata: TransactionMetadata;
    /**
     * Set the name of the transaction
     */
    setName(name: string): void;
    /** Returns the current transaction properties as a `TransactionContext` */
    toContext(): TransactionContext;
    /** Updates the current transaction with a new `TransactionContext` */
    updateWithContext(transactionContext: TransactionContext): this;
}
/**
 * Context data passed by the user when starting a transaction, to be used by the tracesSampler method.
 */
export interface CustomSamplingContext {
    [key: string]: any;
}
/**
 * Data passed to the `tracesSampler` function, which forms the basis for whatever decisions it might make.
 *
 * Adds default data to data provided by the user. See {@link Hub.startTransaction}
 */
export interface SamplingContext extends CustomSamplingContext {
    /**
     * Context data with which transaction being sampled was created
     */
    transactionContext: TransactionContext;
    /**
     * Sampling decision from the parent transaction, if any.
     */
    parentSampled?: boolean;
    /**
     * Object representing the URL of the current page or worker script. Passed by default when using the `BrowserTracing`
     * integration.
     */
    location?: WorkerLocation;
    /**
     * Object representing the incoming request to a node server. Passed by default when using the TracingHandler.
     */
    request?: ExtractedNodeRequestData;
}
export declare type Measurements = Record<string, {
    value: number;
}>;
export declare type TransactionSamplingMethod = 'explicitly_set' | 'client_sampler' | 'client_rate' | 'inheritance';
export interface TransactionMetadata {
    transactionSampling?: {
        rate?: number;
        method: TransactionSamplingMethod;
    };
    /** The two halves (sentry and third-party) of a transaction's tracestate header, used for dynamic sampling */
    tracestate?: {
        sentry?: string;
        thirdparty?: string;
    };
    /** For transactions tracing server-side request handling, the path of the request being tracked. */
    requestPath?: string;
}
//# sourceMappingURL=transaction.d.ts.map{"version":3,"file":"transaction.d.ts","sourceRoot":"","sources":["../../src/transaction.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,wBAAwB,EAAE,SAAS,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AAC7E,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAE3C;;GAEG;AACH,MAAM,WAAW,kBAAmB,SAAQ,WAAW;IACrD;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;;;;OAKG;IACH,OAAO,CAAC,EAAE,OAAO,CAAC;IAElB;;OAEG;IACH,aAAa,CAAC,EAAE,OAAO,CAAC;IAExB;;OAEG;IACH,QAAQ,CAAC,EAAE,mBAAmB,CAAC;CAChC;AAED;;GAEG;AACH,oBAAY,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,SAAS,GAAG,cAAc,GAAG,eAAe,CAAC,CAAC;AAErG;;GAEG;AACH,MAAM,WAAW,WAAY,SAAQ,kBAAkB,EAAE,IAAI;IAC3D;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,OAAO,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,cAAc,EAAE,MAAM,CAAC;IAEvB;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,CAAA;KAAE,CAAC;IAEnC;;OAEG;IACH,IAAI,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE,CAAC;IAE7B;;OAEG;IACH,QAAQ,EAAE,mBAAmB,CAAC;IAE9B;;OAEG;IACH,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IAE5B,2EAA2E;IAC3E,SAAS,IAAI,kBAAkB,CAAC;IAEhC,sEAAsE;IACtE,iBAAiB,CAAC,kBAAkB,EAAE,kBAAkB,GAAG,IAAI,CAAC;CACjE;AAED;;GAEG;AACH,MAAM,WAAW,qBAAqB;IACpC,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;CACpB;AAED;;;;GAIG;AACH,MAAM,WAAW,eAAgB,SAAQ,qBAAqB;IAC5D;;OAEG;IACH,kBAAkB,EAAE,kBAAkB,CAAC;IAEvC;;OAEG;IACH,aAAa,CAAC,EAAE,OAAO,CAAC;IAExB;;;OAGG;IACH,QAAQ,CAAC,EAAE,cAAc,CAAC;IAE1B;;OAEG;IACH,OAAO,CAAC,EAAE,wBAAwB,CAAC;CACpC;AAED,oBAAY,YAAY,GAAG,MAAM,CAAC,MAAM,EAAE;IAAE,KAAK,EAAE,MAAM,CAAA;CAAE,CAAC,CAAC;AAE7D,oBAAY,yBAAyB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,aAAa,GAAG,aAAa,CAAC;AAE5G,MAAM,WAAW,mBAAmB;IAClC,mBAAmB,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE,MAAM,CAAC;QAAC,MAAM,EAAE,yBAAyB,CAAA;KAAE,CAAC;IAE3E,8GAA8G;IAC9G,UAAU,CAAC,EAAE;QACX,MAAM,CAAC,EAAE,MAAM,CAAC;QAChB,UAAU,CAAC,EAAE,MAAM,CAAC;KACrB,CAAC;IAEF,oGAAoG;IACpG,WAAW,CAAC,EAAE,MAAM,CAAC;CACtB"}import { DsnLike } from './dsn';
import { Event } from './event';
import { SentryRequestType } from './request';
import { Response } from './response';
import { SdkMetadata } from './sdkmetadata';
import { Session, SessionAggregates } from './session';
export declare type Outcome = 'before_send' | 'event_processor' | 'network_error' | 'queue_overflow' | 'ratelimit_backoff' | 'sample_rate';
/** Transport used sending data to Sentry */
export interface Transport {
    /**
     * Sends the event to the Store endpoint in Sentry.
     *
     * @param event Event that should be sent to Sentry.
     */
    sendEvent(event: Event): PromiseLike<Response>;
    /**
     * Sends the session to the Envelope endpoint in Sentry.
     *
     * @param session Session that should be sent to Sentry | Session Aggregates that should be sent to Sentry.
     */
    sendSession?(session: Session | SessionAggregates): PromiseLike<Response>;
    /**
     * Wait for all events to be sent or the timeout to expire, whichever comes first.
     *
     * @param timeout Maximum time in ms the transport should wait for events to be flushed. Omitting this parameter will
     *   cause the transport to wait until all events are sent before resolving the promise.
     * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are
     * still events in the queue when the timeout is reached.
     */
    close(timeout?: number): PromiseLike<boolean>;
    /**
     * Increment the counter for the specific client outcome
     */
    recordLostEvent?(type: Outcome, category: SentryRequestType): void;
}
/** JSDoc */
export declare type TransportClass<T extends Transport> = new (options: TransportOptions) => T;
/** JSDoc */
export interface TransportOptions {
    /** Sentry DSN */
    dsn: DsnLike;
    /** Define custom headers */
    headers?: {
        [key: string]: string;
    };
    /** Set a HTTP proxy that should be used for outbound requests. */
    httpProxy?: string;
    /** Set a HTTPS proxy that should be used for outbound requests. */
    httpsProxy?: string;
    /** HTTPS proxy certificates path */
    caCerts?: string;
    /** Fetch API init parameters */
    fetchParameters?: {
        [key: string]: string;
    };
    /** The envelope tunnel to use. */
    tunnel?: string;
    /** Send SDK Client Reports. Enabled by default. */
    sendClientReports?: boolean;
    /**
     * Set of metadata about the SDK that can be internally used to enhance envelopes and events,
     * and provide additional data about every request.
     * */
    _metadata?: SdkMetadata;
}
//# sourceMappingURL=transport.d.ts.map{"version":3,"file":"transport.d.ts","sourceRoot":"","sources":["../../src/transport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,OAAO,CAAC;AAChC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAEvD,oBAAY,OAAO,GACf,aAAa,GACb,iBAAiB,GACjB,eAAe,GACf,gBAAgB,GAChB,mBAAmB,GACnB,aAAa,CAAC;AAElB,4CAA4C;AAC5C,MAAM,WAAW,SAAS;IACxB;;;;OAIG;IACH,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAE/C;;;;OAIG;IACH,WAAW,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,iBAAiB,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;IAE1E;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;IAE9C;;OAEG;IACH,eAAe,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,iBAAiB,GAAG,IAAI,CAAC;CACpE;AAED,YAAY;AACZ,oBAAY,cAAc,CAAC,CAAC,SAAS,SAAS,IAAI,KAAK,OAAO,EAAE,gBAAgB,KAAK,CAAC,CAAC;AAEvF,YAAY;AACZ,MAAM,WAAW,gBAAgB;IAC/B,iBAAiB;IACjB,GAAG,EAAE,OAAO,CAAC;IACb,4BAA4B;IAC5B,OAAO,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IACpC,kEAAkE;IAClE,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,mEAAmE;IACnE,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,oCAAoC;IACpC,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,gCAAgC;IAChC,eAAe,CAAC,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;IAC5C,kCAAkC;IAClC,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,mDAAmD;IACnD,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAC5B;;;SAGK;IACL,SAAS,CAAC,EAAE,WAAW,CAAC;CACzB"}/** JSDoc */
export interface User {
    [key: string]: any;
    id?: string;
    ip_address?: string;
    email?: string;
    username?: string;
}
export interface UserFeedback {
    event_id: string;
    email: User['email'];
    name: string;
    comments: string;
}
//# sourceMappingURL=user.d.ts.map{"version":3,"file":"user.d.ts","sourceRoot":"","sources":["../../src/user.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,IAAI;IACnB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB;AAED,MAAM,WAAW,YAAY;IAC3B,QAAQ,EAAE,MAAM,CAAC;IACjB,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;IACrB,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,MAAM,CAAC;CAClB"}/** JSDoc */
export interface WrappedFunction extends Function {
    [key: string]: any;
    __sentry_wrapped__?: WrappedFunction;
    __sentry_original__?: WrappedFunction;
}
//# sourceMappingURL=wrappedfunction.d.ts.map{"version":3,"file":"wrappedfunction.d.ts","sourceRoot":"","sources":["../../src/wrappedfunction.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,MAAM,WAAW,eAAgB,SAAQ,QAAQ;IAC/C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;IACnB,kBAAkB,CAAC,EAAE,eAAe,CAAC;IACrC,mBAAmB,CAAC,EAAE,eAAe,CAAC;CACvC"}/**
 * Consumes the promise and logs the error when it rejects.
 * @param promise A promise to forget.
 */
export declare function forget(promise: PromiseLike<any>): void;
//# sourceMappingURL=async.d.ts.map{"version":3,"file":"async.d.ts","sourceRoot":"","sources":["../../src/async.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,wBAAgB,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,GAAG,CAAC,GAAG,IAAI,CAMtD"}Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Consumes the promise and logs the error when it rejects.
 * @param promise A promise to forget.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function forget(promise) {
    void promise.then(null, function (e) {
        // TODO: Use a better logging mechanism
        // eslint-disable-next-line no-console
        console.error(e);
    });
}
exports.forget = forget;
//# sourceMappingURL=async.js.map{"version":3,"file":"async.js","sourceRoot":"","sources":["../../src/async.ts"],"names":[],"mappings":";AAAA;;;GAGG;AACH,8DAA8D;AAC9D,SAAgB,MAAM,CAAC,OAAyB;IAC9C,KAAK,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,UAAA,CAAC;QACvB,uCAAuC;QACvC,sCAAsC;QACtC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AACL,CAAC;AAND,wBAMC","sourcesContent":["/**\n * Consumes the promise and logs the error when it rejects.\n * @param promise A promise to forget.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function forget(promise: PromiseLike<any>): void {\n  void promise.then(null, e => {\n    // TODO: Use a better logging mechanism\n    // eslint-disable-next-line no-console\n    console.error(e);\n  });\n}\n"]}/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
export declare function htmlTreeAsString(elem: unknown, keyAttrs?: string[]): string;
/**
 * A safe form of location.href
 */
export declare function getLocationHref(): string;
//# sourceMappingURL=browser.d.ts.map{"version":3,"file":"browser.d.ts","sourceRoot":"","sources":["../../src/browser.ts"],"names":[],"mappings":"AAGA;;;;;GAKG;AACH,wBAAgB,gBAAgB,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,MAAM,EAAE,GAAG,MAAM,CAyC3E;AA+DD;;GAEG;AACH,wBAAgB,eAAe,IAAI,MAAM,CAOxC"}Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = require("./global");
var is_1 = require("./is");
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem, keyAttrs) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        // eslint-disable-next-line no-plusplus
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem, keyAttrs);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return '<unknown>';
    }
}
exports.htmlTreeAsString = htmlTreeAsString;
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el, keyAttrs) {
    var elem = el;
    var out = [];
    var className;
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
    var keyAttrPairs = keyAttrs && keyAttrs.length
        ? keyAttrs.filter(function (keyAttr) { return elem.getAttribute(keyAttr); }).map(function (keyAttr) { return [keyAttr, elem.getAttribute(keyAttr)]; })
        : null;
    if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach(function (keyAttrPair) {
            out.push("[" + keyAttrPair[0] + "=\"" + keyAttrPair[1] + "\"]");
        });
    }
    else {
        if (elem.id) {
            out.push("#" + elem.id);
        }
        // eslint-disable-next-line prefer-const
        className = elem.className;
        if (className && is_1.isString(className)) {
            classes = className.split(/\s+/);
            for (i = 0; i < classes.length; i++) {
                out.push("." + classes[i]);
            }
        }
    }
    var allowedAttrs = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < allowedAttrs.length; i++) {
        key = allowedAttrs[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    return out.join('');
}
/**
 * A safe form of location.href
 */
function getLocationHref() {
    var global = global_1.getGlobalObject();
    try {
        return global.document.location.href;
    }
    catch (oO) {
        return '';
    }
}
exports.getLocationHref = getLocationHref;
//# sourceMappingURL=browser.js.map{"version":3,"file":"browser.js","sourceRoot":"","sources":["../../src/browser.ts"],"names":[],"mappings":"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","sourcesContent":["import { getGlobalObject } from './global';\nimport { isString } from './is';\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nexport function htmlTreeAsString(elem: unknown, keyAttrs?: string[]): string {\n  type SimpleNode = {\n    parentNode: SimpleNode;\n  } | null;\n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem as SimpleNode;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    const MAX_OUTPUT_LEN = 80;\n    const out = [];\n    let height = 0;\n    let len = 0;\n    const separator = ' > ';\n    const sepLength = separator.length;\n    let nextStr;\n\n    // eslint-disable-next-line no-plusplus\n    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el: unknown, keyAttrs?: string[]): string {\n  const elem = el as {\n    tagName?: string;\n    id?: string;\n    className?: string;\n    getAttribute(key: string): string;\n  };\n\n  const out = [];\n  let className;\n  let classes;\n  let key;\n  let attr;\n  let i;\n\n  if (!elem || !elem.tagName) {\n    return '';\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  const keyAttrPairs =\n    keyAttrs && keyAttrs.length\n      ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n      : null;\n\n  if (keyAttrPairs && keyAttrPairs.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n    // eslint-disable-next-line prefer-const\n    className = elem.className;\n    if (className && isString(className)) {\n      classes = className.split(/\\s+/);\n      for (i = 0; i < classes.length; i++) {\n        out.push(`.${classes[i]}`);\n      }\n    }\n  }\n  const allowedAttrs = ['type', 'name', 'title', 'alt'];\n  for (i = 0; i < allowedAttrs.length; i++) {\n    key = allowedAttrs[i];\n    attr = elem.getAttribute(key);\n    if (attr) {\n      out.push(`[${key}=\"${attr}\"]`);\n    }\n  }\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nexport function getLocationHref(): string {\n  const global = getGlobalObject<Window>();\n  try {\n    return global.document.location.href;\n  } catch (oO) {\n    return '';\n  }\n}\n"]}import { ClientReport, ClientReportEnvelope } from '@sentry/types';
/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
export declare function createClientReportEnvelope(discarded_events: ClientReport['discarded_events'], dsn?: string, timestamp?: number): ClientReportEnvelope;
//# sourceMappingURL=clientreport.d.ts.map{"version":3,"file":"clientreport.d.ts","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAoB,MAAM,eAAe,CAAC;AAKrF;;;;GAIG;AACH,wBAAgB,0BAA0B,CACxC,gBAAgB,EAAE,YAAY,CAAC,kBAAkB,CAAC,EAClD,GAAG,CAAC,EAAE,MAAM,EACZ,SAAS,CAAC,EAAE,MAAM,GACjB,oBAAoB,CAStB"}Object.defineProperty(exports, "__esModule", { value: true });
var envelope_1 = require("./envelope");
var time_1 = require("./time");
/**
 * Creates client report envelope
 * @param discarded_events An array of discard events
 * @param dsn A DSN that can be set on the header. Optional.
 */
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    var clientReportItem = [
        { type: 'client_report' },
        {
            timestamp: timestamp || time_1.dateTimestampInSeconds(),
            discarded_events: discarded_events,
        },
    ];
    return envelope_1.createEnvelope(dsn ? { dsn: dsn } : {}, [clientReportItem]);
}
exports.createClientReportEnvelope = createClientReportEnvelope;
//# sourceMappingURL=clientreport.js.map{"version":3,"file":"clientreport.js","sourceRoot":"","sources":["../../src/clientreport.ts"],"names":[],"mappings":";AAEA,uCAA4C;AAC5C,+BAAgD;AAEhD;;;;GAIG;AACH,SAAgB,0BAA0B,CACxC,gBAAkD,EAClD,GAAY,EACZ,SAAkB;IAElB,IAAM,gBAAgB,GAAqB;QACzC,EAAE,IAAI,EAAE,eAAe,EAAE;QACzB;YACE,SAAS,EAAE,SAAS,IAAI,6BAAsB,EAAE;YAChD,gBAAgB,kBAAA;SACjB;KACF,CAAC;IACF,OAAO,yBAAc,CAAuB,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,KAAA,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,CAAC,CAAC;AACtF,CAAC;AAbD,gEAaC","sourcesContent":["import { ClientReport, ClientReportEnvelope, ClientReportItem } from '@sentry/types';\n\nimport { createEnvelope } from './envelope';\nimport { dateTimestampInSeconds } from './time';\n\n/**\n * Creates client report envelope\n * @param discarded_events An array of discard events\n * @param dsn A DSN that can be set on the header. Optional.\n */\nexport function createClientReportEnvelope(\n  discarded_events: ClientReport['discarded_events'],\n  dsn?: string,\n  timestamp?: number,\n): ClientReportEnvelope {\n  const clientReportItem: ClientReportItem = [\n    { type: 'client_report' },\n    {\n      timestamp: timestamp || dateTimestampInSeconds(),\n      discarded_events,\n    },\n  ];\n  return createEnvelope<ClientReportEnvelope>(dsn ? { dsn } : {}, [clientReportItem]);\n}\n"]}import { DsnComponents, DsnLike } from '@sentry/types';
/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
export declare function dsnToString(dsn: DsnComponents, withPassword?: boolean): string;
/** The Sentry Dsn, identifying a Sentry instance and project. */
export declare function makeDsn(from: DsnLike): DsnComponents;
//# sourceMappingURL=dsn.d.ts.map{"version":3,"file":"dsn.d.ts","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAe,MAAM,eAAe,CAAC;AAYpE;;;;;;;;GAQG;AACH,wBAAgB,WAAW,CAAC,GAAG,EAAE,aAAa,EAAE,YAAY,GAAE,OAAe,GAAG,MAAM,CAMrF;AA4ED,iEAAiE;AACjE,wBAAgB,OAAO,CAAC,IAAI,EAAE,OAAO,GAAG,aAAa,CAMpD"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var error_1 = require("./error");
var flags_1 = require("./flags");
/** Regular expression used to parse a Dsn. */
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
    return protocol === 'http' || protocol === 'https';
}
/**
 * Renders the string representation of this Dsn.
 *
 * By default, this will render the public representation without the password
 * component. To get the deprecated private representation, set `withPassword`
 * to true.
 *
 * @param withPassword When set to true, the password will be included.
 */
function dsnToString(dsn, withPassword) {
    if (withPassword === void 0) { withPassword = false; }
    var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
    return (protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : '') +
        ("@" + host + (port ? ":" + port : '') + "/" + (path ? path + "/" : path) + projectId));
}
exports.dsnToString = dsnToString;
function dsnFromString(str) {
    var match = DSN_REGEX.exec(str);
    if (!match) {
        throw new error_1.SentryError("Invalid Sentry Dsn: " + str);
    }
    var _a = tslib_1.__read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? '' : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? '' : _c, lastPath = _a[5];
    var path = '';
    var projectId = lastPath;
    var split = projectId.split('/');
    if (split.length > 1) {
        path = split.slice(0, -1).join('/');
        projectId = split.pop();
    }
    if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
            projectId = projectMatch[0];
        }
    }
    return dsnFromComponents({ host: host, pass: pass, path: path, projectId: projectId, port: port, protocol: protocol, publicKey: publicKey });
}
function dsnFromComponents(components) {
    // TODO this is for backwards compatibility, and can be removed in a future version
    if ('user' in components && !('publicKey' in components)) {
        components.publicKey = components.user;
    }
    return {
        user: components.publicKey || '',
        protocol: components.protocol,
        publicKey: components.publicKey || '',
        pass: components.pass || '',
        host: components.host,
        port: components.port || '',
        path: components.path || '',
        projectId: components.projectId,
    };
}
function validateDsn(dsn) {
    if (!flags_1.IS_DEBUG_BUILD) {
        return;
    }
    var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
    var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
    requiredComponents.forEach(function (component) {
        if (!dsn[component]) {
            throw new error_1.SentryError("Invalid Sentry Dsn: " + component + " missing");
        }
    });
    if (!projectId.match(/^\d+$/)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
    }
    if (!isValidProtocol(protocol)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
    }
    if (port && isNaN(parseInt(port, 10))) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid port " + port);
    }
    return true;
}
/** The Sentry Dsn, identifying a Sentry instance and project. */
function makeDsn(from) {
    var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
    validateDsn(components);
    return components;
}
exports.makeDsn = makeDsn;
//# sourceMappingURL=dsn.js.map{"version":3,"file":"dsn.js","sourceRoot":"","sources":["../../src/dsn.ts"],"names":[],"mappings":"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","sourcesContent":["import { DsnComponents, DsnLike, DsnProtocol } from '@sentry/types';\n\nimport { SentryError } from './error';\nimport { IS_DEBUG_BUILD } from './flags';\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+))?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol?: string): protocol is DsnProtocol {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nexport function dsnToString(dsn: DsnComponents, withPassword: boolean = false): string {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\nfunction dsnFromString(str: string): DsnComponents {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() as string;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol as DsnProtocol, publicKey });\n}\n\nfunction dsnFromComponents(components: DsnComponents): DsnComponents {\n  // TODO this is for backwards compatibility, and can be removed in a future version\n  if ('user' in components && !('publicKey' in components)) {\n    components.publicKey = components.user;\n  }\n\n  return {\n    user: components.publicKey || '',\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn: DsnComponents): boolean | void {\n  if (!IS_DEBUG_BUILD) {\n    return;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents: ReadonlyArray<keyof DsnComponents> = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nexport function makeDsn(from: DsnLike): DsnComponents {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n\n  validateDsn(components);\n\n  return components;\n}\n"]}export declare const SeverityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug", "critical"];
export declare type SeverityLevel = typeof SeverityLevels[number];
//# sourceMappingURL=enums.d.ts.map{"version":3,"file":"enums.d.ts","sourceRoot":"","sources":["../../src/enums.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,4EAA6E,CAAC;AACzG,oBAAY,aAAa,GAAG,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
exports.SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];
//# sourceMappingURL=enums.js.map{"version":3,"file":"enums.js","sourceRoot":"","sources":["../../src/enums.ts"],"names":[],"mappings":";AAAa,QAAA,cAAc,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,CAAU,CAAC","sourcesContent":["export const SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'] as const;\nexport type SeverityLevel = typeof SeverityLevels[number];\n"]}/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
export declare function isBrowserBundle(): boolean;
//# sourceMappingURL=env.d.ts.map{"version":3,"file":"env.d.ts","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":"AAiBA;;;;GAIG;AACH,wBAAgB,eAAe,IAAI,OAAO,CAEzC"}/*
 * This module exists for optimizations in the build process through rollup and terser.  We define some global
 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
 * `logger` and preventing node-related code from appearing in browser bundles.
 *
 * Attention:
 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
 * having issues tree-shaking these constants across package boundaries.
 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
 * users to be able to shake away expressions that it guards.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
}
exports.isBrowserBundle = isBrowserBundle;
//# sourceMappingURL=env.js.map{"version":3,"file":"env.js","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;;AAIH;;;;GAIG;AACH,SAAgB,eAAe;IAC7B,OAAO,OAAO,yBAAyB,KAAK,WAAW,IAAI,CAAC,CAAC,yBAAyB,CAAC;AACzF,CAAC;AAFD,0CAEC","sourcesContent":["/*\n * This module exists for optimizations in the build process through rollup and terser.  We define some global\n * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these\n * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will\n * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to\n * `logger` and preventing node-related code from appearing in browser bundles.\n *\n * Attention:\n * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by\n * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)\n * having issues tree-shaking these constants across package boundaries.\n * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want\n * users to be able to shake away expressions that it guards.\n */\n\ndeclare const __SENTRY_BROWSER_BUNDLE__: boolean | undefined;\n\n/**\n * Figures out if we're building a browser bundle.\n *\n * @returns true if this is a browser bundle build.\n */\nexport function isBrowserBundle(): boolean {\n  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;\n}\n"]}import { Envelope } from '@sentry/types';
/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export declare function createEnvelope<E extends Envelope>(headers: E[0], items?: E[1]): E;
/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
export declare function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E;
/**
 * Get the type of the envelope. Grabs the type from the first envelope item.
 */
export declare function getEnvelopeType<E extends Envelope>(envelope: E): string;
/**
 * Serializes an envelope into a string.
 */
export declare function serializeEnvelope(envelope: Envelope): string;
//# sourceMappingURL=envelope.d.ts.map{"version":3,"file":"envelope.d.ts","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AAIzC;;;;GAIG;AACH,wBAAgB,cAAc,CAAC,CAAC,SAAS,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,GAAE,CAAC,CAAC,CAAC,CAAM,GAAG,CAAC,CAErF;AAED;;;;GAIG;AACH,wBAAgB,iBAAiB,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAG3F;AAED;;GAEG;AACH,wBAAgB,eAAe,CAAC,CAAC,SAAS,QAAQ,EAAE,QAAQ,EAAE,CAAC,GAAG,MAAM,CAGvE;AAED;;GAEG;AACH,wBAAgB,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,GAAG,MAAM,CAe5D"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var is_1 = require("./is");
/**
 * Creates an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function createEnvelope(headers, items) {
    if (items === void 0) { items = []; }
    return [headers, items];
}
exports.createEnvelope = createEnvelope;
/**
 * Add an item to an envelope.
 * Make sure to always explicitly provide the generic to this function
 * so that the envelope types resolve correctly.
 */
function addItemToEnvelope(envelope, newItem) {
    var _a = tslib_1.__read(envelope, 2), headers = _a[0], items = _a[1];
    return [headers, tslib_1.__spread(items, [newItem])];
}
exports.addItemToEnvelope = addItemToEnvelope;
/**
 * Get the type of the envelope. Grabs the type from the first envelope item.
 */
function getEnvelopeType(envelope) {
    var _a = tslib_1.__read(envelope, 2), _b = tslib_1.__read(_a[1], 1), _c = tslib_1.__read(_b[0], 1), firstItemHeader = _c[0];
    return firstItemHeader.type;
}
exports.getEnvelopeType = getEnvelopeType;
/**
 * Serializes an envelope into a string.
 */
function serializeEnvelope(envelope) {
    var _a = tslib_1.__read(envelope, 2), headers = _a[0], items = _a[1];
    var serializedHeaders = JSON.stringify(headers);
    // Have to cast items to any here since Envelope is a union type
    // Fixed in Typescript 4.2
    // TODO: Remove any[] cast when we upgrade to TS 4.2
    // https://github.com/microsoft/TypeScript/issues/36390
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return items.reduce(function (acc, item) {
        var _a = tslib_1.__read(item, 2), itemHeaders = _a[0], payload = _a[1];
        // We do not serialize payloads that are primitives
        var serializedPayload = is_1.isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
        return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
    }, serializedHeaders);
}
exports.serializeEnvelope = serializeEnvelope;
//# sourceMappingURL=envelope.js.map{"version":3,"file":"envelope.js","sourceRoot":"","sources":["../../src/envelope.ts"],"names":[],"mappings":";;AAEA,2BAAmC;AAEnC;;;;GAIG;AACH,SAAgB,cAAc,CAAqB,OAAa,EAAE,KAAgB;IAAhB,sBAAA,EAAA,UAAgB;IAChF,OAAO,CAAC,OAAO,EAAE,KAAK,CAAM,CAAC;AAC/B,CAAC;AAFD,wCAEC;AAED;;;;GAIG;AACH,SAAgB,iBAAiB,CAAqB,QAAW,EAAE,OAAqB;IAChF,IAAA,gCAA2B,EAA1B,eAAO,EAAE,aAAiB,CAAC;IAClC,OAAO,CAAC,OAAO,mBAAM,KAAK,GAAE,OAAO,GAAO,CAAC;AAC7C,CAAC;AAHD,8CAGC;AAED;;GAEG;AACH,SAAgB,eAAe,CAAqB,QAAW;IACvD,IAAA,gCAAkC,EAA/B,6BAAmB,EAAlB,6BAAiB,EAAhB,uBAA6B,CAAC;IACzC,OAAO,eAAe,CAAC,IAAI,CAAC;AAC9B,CAAC;AAHD,0CAGC;AAED;;GAEG;AACH,SAAgB,iBAAiB,CAAC,QAAkB;IAC5C,IAAA,gCAA2B,EAA1B,eAAO,EAAE,aAAiB,CAAC;IAClC,IAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAElD,gEAAgE;IAChE,0BAA0B;IAC1B,oDAAoD;IACpD,uDAAuD;IACvD,8DAA8D;IAC9D,OAAQ,KAAe,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,IAA0B;QACvD,IAAA,4BAA6B,EAA5B,mBAAW,EAAE,eAAe,CAAC;QACpC,mDAAmD;QACnD,IAAM,iBAAiB,GAAG,gBAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QAC3F,OAAU,GAAG,UAAK,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,UAAK,iBAAmB,CAAC;IACxE,CAAC,EAAE,iBAAiB,CAAC,CAAC;AACxB,CAAC;AAfD,8CAeC","sourcesContent":["import { Envelope } from '@sentry/types';\n\nimport { isPrimitive } from './is';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function createEnvelope<E extends Envelope>(headers: E[0], items: E[1] = []): E {\n  return [headers, items] as E;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nexport function addItemToEnvelope<E extends Envelope>(envelope: E, newItem: E[1][number]): E {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] as E;\n}\n\n/**\n * Get the type of the envelope. Grabs the type from the first envelope item.\n */\nexport function getEnvelopeType<E extends Envelope>(envelope: E): string {\n  const [, [[firstItemHeader]]] = envelope;\n  return firstItemHeader.type;\n}\n\n/**\n * Serializes an envelope into a string.\n */\nexport function serializeEnvelope(envelope: Envelope): string {\n  const [headers, items] = envelope;\n  const serializedHeaders = JSON.stringify(headers);\n\n  // Have to cast items to any here since Envelope is a union type\n  // Fixed in Typescript 4.2\n  // TODO: Remove any[] cast when we upgrade to TS 4.2\n  // https://github.com/microsoft/TypeScript/issues/36390\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (items as any[]).reduce((acc, item: typeof items[number]) => {\n    const [itemHeaders, payload] = item;\n    // We do not serialize payloads that are primitives\n    const serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);\n    return `${acc}\\n${JSON.stringify(itemHeaders)}\\n${serializedPayload}`;\n  }, serializedHeaders);\n}\n"]}/** An error emitted by Sentry SDKs and related utilities. */
export declare class SentryError extends Error {
    message: string;
    /** Display name of this error instance. */
    name: string;
    constructor(message: string);
}
//# sourceMappingURL=error.d.ts.map{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":"AAEA,6DAA6D;AAC7D,qBAAa,WAAY,SAAQ,KAAK;IAIV,OAAO,EAAE,MAAM;IAHzC,2CAA2C;IACpC,IAAI,EAAE,MAAM,CAAC;gBAEM,OAAO,EAAE,MAAM;CAM1C"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var polyfill_1 = require("./polyfill");
/** An error emitted by Sentry SDKs and related utilities. */
var SentryError = /** @class */ (function (_super) {
    tslib_1.__extends(SentryError, _super);
    function SentryError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _newTarget.prototype.constructor.name;
        polyfill_1.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return SentryError;
}(Error));
exports.SentryError = SentryError;
//# sourceMappingURL=error.js.map{"version":3,"file":"error.js","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":";;AAAA,uCAA4C;AAE5C,6DAA6D;AAC7D;IAAiC,uCAAK;IAIpC,qBAA0B,OAAe;;QAAzC,YACE,kBAAM,OAAO,CAAC,SAIf;QALyB,aAAO,GAAP,OAAO,CAAQ;QAGvC,KAAI,CAAC,IAAI,GAAG,WAAW,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC;QAClD,yBAAc,CAAC,KAAI,EAAE,WAAW,SAAS,CAAC,CAAC;;IAC7C,CAAC;IACH,kBAAC;AAAD,CAAC,AAVD,CAAiC,KAAK,GAUrC;AAVY,kCAAW","sourcesContent":["import { setPrototypeOf } from './polyfill';\n\n/** An error emitted by Sentry SDKs and related utilities. */\nexport class SentryError extends Error {\n  /** Display name of this error instance. */\n  public name: string;\n\n  public constructor(public message: string) {\n    super(message);\n\n    this.name = new.target.prototype.constructor.name;\n    setPrototypeOf(this, new.target.prototype);\n  }\n}\n"]}/** Flag that is true for debug builds, false otherwise. */
export declare const IS_DEBUG_BUILD: boolean;
//# sourceMappingURL=flags.d.ts.map{"version":3,"file":"flags.d.ts","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAgBA,2DAA2D;AAC3D,eAAO,MAAM,cAAc,SAAoE,CAAC"}/*
 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
 * for users.
 *
 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
 * because some build tools have trouble tree-shaking imported guards.
 *
 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
 *
 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
 * replaced.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** Flag that is true for debug builds, false otherwise. */
exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;
//# sourceMappingURL=flags.js.map{"version":3,"file":"flags.js","sourceRoot":"","sources":["../../src/flags.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;AAIH,2DAA2D;AAC9C,QAAA,cAAc,GAAG,OAAO,gBAAgB,KAAK,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,gBAAgB,CAAC","sourcesContent":["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n"]}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
import { Integration } from '@sentry/types';
/** Internal */
interface SentryGlobal {
    Sentry?: {
        Integrations?: Integration[];
    };
    SENTRY_ENVIRONMENT?: string;
    SENTRY_DSN?: string;
    SENTRY_RELEASE?: {
        id?: string;
    };
    __SENTRY__: {
        globalEventProcessors: any;
        hub: any;
        logger: any;
    };
}
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
export declare function getGlobalObject<T>(): T & SentryGlobal;
/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
export declare function getGlobalSingleton<T>(name: keyof SentryGlobal['__SENTRY__'], creator: () => T, obj?: unknown): T;
export {};
//# sourceMappingURL=global.d.ts.map{"version":3,"file":"global.d.ts","sourceRoot":"","sources":["../../src/global.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAI5C,eAAe;AACf,UAAU,YAAY;IACpB,MAAM,CAAC,EAAE;QACP,YAAY,CAAC,EAAE,WAAW,EAAE,CAAC;KAC9B,CAAC;IACF,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,cAAc,CAAC,EAAE;QACf,EAAE,CAAC,EAAE,MAAM,CAAC;KACb,CAAC;IACF,UAAU,EAAE;QACV,qBAAqB,EAAE,GAAG,CAAC;QAC3B,GAAG,EAAE,GAAG,CAAC;QACT,MAAM,EAAE,GAAG,CAAC;KACb,CAAC;CACH;AAID;;;;GAIG;AACH,wBAAgB,eAAe,CAAC,CAAC,KAAK,CAAC,GAAG,YAAY,CAUrD;AAED;;;;;;;;;;GAUG;AACH,wBAAgB,kBAAkB,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,YAAY,CAAC,YAAY,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,EAAE,GAAG,CAAC,EAAE,OAAO,GAAG,CAAC,CAKhH"}/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var node_1 = require("./node");
var fallbackGlobalObject = {};
/**
 * Safely get global scope object
 *
 * @returns Global scope object
 */
function getGlobalObject() {
    return (node_1.isNodeEnv()
        ? global
        : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
            ? window // eslint-disable-line no-restricted-globals
            : typeof self !== 'undefined'
                ? self
                : fallbackGlobalObject);
}
exports.getGlobalObject = getGlobalObject;
/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
 * @returns the singleton
 */
function getGlobalSingleton(name, creator, obj) {
    var global = (obj || getGlobalObject());
    var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});
    var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
}
exports.getGlobalSingleton = getGlobalSingleton;
//# sourceMappingURL=global.js.map{"version":3,"file":"global.js","sourceRoot":"","sources":["../../src/global.ts"],"names":[],"mappings":"AAAA;;;GAGG;;AAMH,+BAAmC;AAmBnC,IAAM,oBAAoB,GAAG,EAAE,CAAC;AAEhC;;;;GAIG;AACH,SAAgB,eAAe;IAC7B,OAAO,CACL,gBAAS,EAAE;QACT,CAAC,CAAC,MAAM;QACR,CAAC,CAAC,OAAO,MAAM,KAAK,WAAW,CAAC,4CAA4C;YAC5E,CAAC,CAAC,MAAM,CAAC,4CAA4C;YACrD,CAAC,CAAC,OAAO,IAAI,KAAK,WAAW;gBAC7B,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,oBAAoB,CACL,CAAC;AACxB,CAAC;AAVD,0CAUC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,kBAAkB,CAAI,IAAsC,EAAE,OAAgB,EAAE,GAAa;IAC3G,IAAM,MAAM,GAAG,CAAC,GAAG,IAAI,eAAe,EAAE,CAAiB,CAAC;IAC1D,IAAM,UAAU,GAAG,CAAC,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC;IACjE,IAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,OAAO,EAAE,CAAC,CAAC;IACrE,OAAO,SAAS,CAAC;AACnB,CAAC;AALD,gDAKC","sourcesContent":["/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { Integration } from '@sentry/types';\n\nimport { isNodeEnv } from './node';\n\n/** Internal */\ninterface SentryGlobal {\n  Sentry?: {\n    Integrations?: Integration[];\n  };\n  SENTRY_ENVIRONMENT?: string;\n  SENTRY_DSN?: string;\n  SENTRY_RELEASE?: {\n    id?: string;\n  };\n  __SENTRY__: {\n    globalEventProcessors: any;\n    hub: any;\n    logger: any;\n  };\n}\n\nconst fallbackGlobalObject = {};\n\n/**\n * Safely get global scope object\n *\n * @returns Global scope object\n */\nexport function getGlobalObject<T>(): T & SentryGlobal {\n  return (\n    isNodeEnv()\n      ? global\n      : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals\n      ? window // eslint-disable-line no-restricted-globals\n      : typeof self !== 'undefined'\n      ? self\n      : fallbackGlobalObject\n  ) as T & SentryGlobal;\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value\n * @returns the singleton\n */\nexport function getGlobalSingleton<T>(name: keyof SentryGlobal['__SENTRY__'], creator: () => T, obj?: unknown): T {\n  const global = (obj || getGlobalObject()) as SentryGlobal;\n  const __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});\n  const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n  return singleton;\n}\n"]}export * from './async';
export * from './browser';
export * from './dsn';
export * from './enums';
export * from './error';
export * from './global';
export * from './instrument';
export * from './is';
export * from './logger';
export * from './memo';
export * from './misc';
export * from './node';
export * from './normalize';
export * from './object';
export * from './path';
export * from './promisebuffer';
export * from './severity';
export * from './stacktrace';
export * from './status';
export * from './string';
export * from './supports';
export * from './syncpromise';
export * from './time';
export * from './tracing';
export * from './env';
export * from './envelope';
export * from './clientreport';
export * from './ratelimit';
//# sourceMappingURL=index.d.ts.map{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,SAAS,CAAC;AACxB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,SAAS,CAAC;AACxB,cAAc,SAAS,CAAC;AACxB,cAAc,UAAU,CAAC;AACzB,cAAc,cAAc,CAAC;AAC7B,cAAc,MAAM,CAAC;AACrB,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,QAAQ,CAAC;AACvB,cAAc,aAAa,CAAC;AAC5B,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC;AACvB,cAAc,iBAAiB,CAAC;AAChC,cAAc,YAAY,CAAC;AAC3B,cAAc,cAAc,CAAC;AAC7B,cAAc,UAAU,CAAC;AACzB,cAAc,UAAU,CAAC;AACzB,cAAc,YAAY,CAAC;AAC3B,cAAc,eAAe,CAAC;AAC9B,cAAc,QAAQ,CAAC;AACvB,cAAc,WAAW,CAAC;AAC1B,cAAc,OAAO,CAAC;AACtB,cAAc,YAAY,CAAC;AAC3B,cAAc,gBAAgB,CAAC;AAC/B,cAAc,aAAa,CAAC"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./async"), exports);
tslib_1.__exportStar(require("./browser"), exports);
tslib_1.__exportStar(require("./dsn"), exports);
tslib_1.__exportStar(require("./enums"), exports);
tslib_1.__exportStar(require("./error"), exports);
tslib_1.__exportStar(require("./global"), exports);
tslib_1.__exportStar(require("./instrument"), exports);
tslib_1.__exportStar(require("./is"), exports);
tslib_1.__exportStar(require("./logger"), exports);
tslib_1.__exportStar(require("./memo"), exports);
tslib_1.__exportStar(require("./misc"), exports);
tslib_1.__exportStar(require("./node"), exports);
tslib_1.__exportStar(require("./normalize"), exports);
tslib_1.__exportStar(require("./object"), exports);
tslib_1.__exportStar(require("./path"), exports);
tslib_1.__exportStar(require("./promisebuffer"), exports);
tslib_1.__exportStar(require("./severity"), exports);
tslib_1.__exportStar(require("./stacktrace"), exports);
tslib_1.__exportStar(require("./status"), exports);
tslib_1.__exportStar(require("./string"), exports);
tslib_1.__exportStar(require("./supports"), exports);
tslib_1.__exportStar(require("./syncpromise"), exports);
tslib_1.__exportStar(require("./time"), exports);
tslib_1.__exportStar(require("./tracing"), exports);
tslib_1.__exportStar(require("./env"), exports);
tslib_1.__exportStar(require("./envelope"), exports);
tslib_1.__exportStar(require("./clientreport"), exports);
tslib_1.__exportStar(require("./ratelimit"), exports);
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;AAAA,kDAAwB;AACxB,oDAA0B;AAC1B,gDAAsB;AACtB,kDAAwB;AACxB,kDAAwB;AACxB,mDAAyB;AACzB,uDAA6B;AAC7B,+CAAqB;AACrB,mDAAyB;AACzB,iDAAuB;AACvB,iDAAuB;AACvB,iDAAuB;AACvB,sDAA4B;AAC5B,mDAAyB;AACzB,iDAAuB;AACvB,0DAAgC;AAChC,qDAA2B;AAC3B,uDAA6B;AAC7B,mDAAyB;AACzB,mDAAyB;AACzB,qDAA2B;AAC3B,wDAA8B;AAC9B,iDAAuB;AACvB,oDAA0B;AAC1B,gDAAsB;AACtB,qDAA2B;AAC3B,yDAA+B;AAC/B,sDAA4B","sourcesContent":["export * from './async';\nexport * from './browser';\nexport * from './dsn';\nexport * from './enums';\nexport * from './error';\nexport * from './global';\nexport * from './instrument';\nexport * from './is';\nexport * from './logger';\nexport * from './memo';\nexport * from './misc';\nexport * from './node';\nexport * from './normalize';\nexport * from './object';\nexport * from './path';\nexport * from './promisebuffer';\nexport * from './severity';\nexport * from './stacktrace';\nexport * from './status';\nexport * from './string';\nexport * from './supports';\nexport * from './syncpromise';\nexport * from './time';\nexport * from './tracing';\nexport * from './env';\nexport * from './envelope';\nexport * from './clientreport';\nexport * from './ratelimit';\n"]}declare type InstrumentHandlerType = 'console' | 'dom' | 'fetch' | 'history' | 'sentry' | 'xhr' | 'error' | 'unhandledrejection';
declare type InstrumentHandlerCallback = (data: any) => void;
/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
export declare function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void;
export {};
//# sourceMappingURL=instrument.d.ts.map{"version":3,"file":"instrument.d.ts","sourceRoot":"","sources":["../../src/instrument.ts"],"names":[],"mappings":"AAeA,aAAK,qBAAqB,GACtB,SAAS,GACT,KAAK,GACL,OAAO,GACP,SAAS,GACT,QAAQ,GACR,KAAK,GACL,OAAO,GACP,oBAAoB,CAAC;AACzB,aAAK,yBAAyB,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,IAAI,CAAC;AAoDrD;;;;GAIG;AACH,wBAAgB,yBAAyB,CAAC,IAAI,EAAE,qBAAqB,EAAE,QAAQ,EAAE,yBAAyB,GAAG,IAAI,CAIhH"}Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var flags_1 = require("./flags");
var global_1 = require("./global");
var is_1 = require("./is");
var logger_1 = require("./logger");
var object_1 = require("./object");
var stacktrace_1 = require("./stacktrace");
var supports_1 = require("./supports");
var global = global_1.getGlobalObject();
/**
 * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
 *  - Console API
 *  - Fetch API
 *  - XHR API
 *  - History API
 *  - DOM API (click/typing)
 *  - Error API
 *  - UnhandledRejection API
 */
var handlers = {};
var instrumented = {};
/** Instruments given API */
function instrument(type) {
    if (instrumented[type]) {
        return;
    }
    instrumented[type] = true;
    switch (type) {
        case 'console':
            instrumentConsole();
            break;
        case 'dom':
            instrumentDOM();
            break;
        case 'xhr':
            instrumentXHR();
            break;
        case 'fetch':
            instrumentFetch();
            break;
        case 'history':
            instrumentHistory();
            break;
        case 'error':
            instrumentError();
            break;
        case 'unhandledrejection':
            instrumentUnhandledRejection();
            break;
        default:
            flags_1.IS_DEBUG_BUILD && logger_1.logger.warn('unknown instrumentation type:', type);
            return;
    }
}
/**
 * Add handler that will be called when given type of instrumentation triggers.
 * Use at your own risk, this might break without changelog notice, only used internally.
 * @hidden
 */
function addInstrumentationHandler(type, callback) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(callback);
    instrument(type);
}
exports.addInstrumentationHandler = addInstrumentationHandler;
/** JSDoc */
function triggerHandlers(type, data) {
    var e_1, _a;
    if (!type || !handlers[type]) {
        return;
    }
    try {
        for (var _b = tslib_1.__values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var handler = _c.value;
            try {
                handler(data);
            }
            catch (e) {
                flags_1.IS_DEBUG_BUILD &&
                    logger_1.logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + stacktrace_1.getFunctionName(handler) + "\nError:", e);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/** JSDoc */
function instrumentConsole() {
    if (!('console' in global)) {
        return;
    }
    logger_1.CONSOLE_LEVELS.forEach(function (level) {
        if (!(level in global.console)) {
            return;
        }
        object_1.fill(global.console, level, function (originalConsoleMethod) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                triggerHandlers('console', { args: args, level: level });
                // this fails for some browsers. :(
                if (originalConsoleMethod) {
                    originalConsoleMethod.apply(global.console, args);
                }
            };
        });
    });
}
/** JSDoc */
function instrumentFetch() 