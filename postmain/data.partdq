dentity = (host, cert) => {
                        return originalCheckServerIdentity(sslTargetNameOverride, cert);
                    };
                    connectionOptions.servername = sslTargetNameOverride;
                }
                else {
                    const authorityHostname = (_d = (_c = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c === void 0 ? void 0 : _c.host) !== null && _d !== void 0 ? _d : 'localhost';
                    // We want to always set servername to support SNI
                    connectionOptions.servername = authorityHostname;
                }
                if (proxyConnectionResult.socket) {
                    /* This is part of the workaround for
                     * https://github.com/nodejs/node/issues/32922. Without that bug,
                     * proxyConnectionResult.socket would always be a plaintext socket and
                     * this would say
                     * connectionOptions.socket = proxyConnectionResult.socket; */
                    connectionOptions.createConnection = (authority, option) => {
                        return proxyConnectionResult.socket;
                    };
                }
            }
            else {
                /* In all but the most recent versions of Node, http2.connect does not use
                 * the options when establishing plaintext connections, so we need to
                 * establish that connection explicitly. */
                connectionOptions.createConnection = (authority, option) => {
                    if (proxyConnectionResult.socket) {
                        return proxyConnectionResult.socket;
                    }
                    else {
                        /* net.NetConnectOpts is declared in a way that is more restrictive
                         * than what net.connect will actually accept, so we use the type
                         * assertion to work around that. */
                        return net.connect(address);
                    }
                };
            }
            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });
            /* http2.connect uses the options here:
             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
             * The spread operator overides earlier values with later ones, so any port
             * or host values in the options will be used rather than any values extracted
             * from the first argument. In addition, the path overrides the host and port,
             * as documented for plaintext connections here:
             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
             * and for TLS connections here:
             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
             * earlier versions of Node, http2.connect passes these options to
             * tls.connect but not net.connect, so in the insecure case we still need
             * to set the createConnection option above to create the connection
             * explicitly. We cannot do that in the TLS case because http2.connect
             * passes necessary additional options to tls.connect.
             * The first argument just needs to be parseable as a URL and the scheme
             * determines whether the connection will be established over TLS or not.
             */
            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
            this.session = session;
            let errorMessage = 'Failed to connect';
            session.unref();
            session.once('connect', () => {
                session.removeAllListeners();
                resolve(new Http2Transport(session, address, options, remoteName));
                this.session = null;
            });
            session.once('close', () => {
                this.session = null;
                // Leave time for error event to happen before rejecting
                setImmediate(() => {
                    reject(`${errorMessage} (${new Date().toISOString()})`);
                });
            });
            session.once('error', error => {
                errorMessage = error.message;
                this.trace('connection failed with error ' + errorMessage);
            });
        });
    }
    connect(address, credentials, options) {
        var _a, _b, _c;
        if (this.isShutdown) {
            return Promise.reject();
        }
        /* Pass connection options through to the proxy so that it's able to
         * upgrade it's connection to support tls if needed.
         * This is a workaround for https://github.com/nodejs/node/issues/32922
         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
        const connectionOptions = credentials._getConnectionOptions() || {};
        if ('secureContext' in connectionOptions) {
            connectionOptions.ALPNProtocols = ['h2'];
            // If provided, the value of grpc.ssl_target_name_override should be used
            // to override the target hostname when checking server identity.
            // This option is used for testing only.
            if (options['grpc.ssl_target_name_override']) {
                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
                const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== void 0 ? _a : tls_1.checkServerIdentity;
                connectionOptions.checkServerIdentity = (host, cert) => {
                    return originalCheckServerIdentity(sslTargetNameOverride, cert);
                };
                connectionOptions.servername = sslTargetNameOverride;
            }
            else {
                if ('grpc.http_connect_target' in options) {
                    /* This is more or less how servername will be set in createSession
                     * if a connection is successfully established through the proxy.
                     * If the proxy is not used, these connectionOptions are discarded
                     * anyway */
                    const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== void 0 ? _b : {
                        path: 'localhost',
                    });
                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
                    connectionOptions.servername = (_c = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c !== void 0 ? _c : targetPath;
                }
            }
            if (options['grpc-node.tls_enable_trace']) {
                connectionOptions.enableTrace = true;
            }
        }
        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));
    }
    shutdown() {
        var _a;
        this.isShutdown = true;
        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();
        this.session = null;
    }
}
exports.Http2SubchannelConnector = Http2SubchannelConnector;
//# sourceMappingURL=transport.js.map{"version":3,"file":"transport.js","sourceRoot":"","sources":["../../src/transport.ts"],"names":[],"mappings":"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"}export interface GrpcUri {
    scheme?: string;
    authority?: string;
    path: string;
}
export declare function parseUri(uriString: string): GrpcUri | null;
export interface HostPort {
    host: string;
    port?: number;
}
export declare function splitHostPort(path: string): HostPort | null;
export declare function combineHostPort(hostPort: HostPort): string;
export declare function uriToString(uri: GrpcUri): string;
"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUri = parseUri;
exports.splitHostPort = splitHostPort;
exports.combineHostPort = combineHostPort;
exports.uriToString = uriToString;
/*
 * The groups correspond to URI parts as follows:
 * 1. scheme
 * 2. authority
 * 3. path
 */
const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
function parseUri(uriString) {
    const parsedUri = URI_REGEX.exec(uriString);
    if (parsedUri === null) {
        return null;
    }
    return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3],
    };
}
const NUMBER_REGEX = /^\d+$/;
function splitHostPort(path) {
    if (path.startsWith('[')) {
        const hostEnd = path.indexOf(']');
        if (hostEnd === -1) {
            return null;
        }
        const host = path.substring(1, hostEnd);
        /* Only an IPv6 address should be in bracketed notation, and an IPv6
         * address should have at least one colon */
        if (host.indexOf(':') === -1) {
            return null;
        }
        if (path.length > hostEnd + 1) {
            if (path[hostEnd + 1] === ':') {
                const portString = path.substring(hostEnd + 2);
                if (NUMBER_REGEX.test(portString)) {
                    return {
                        host: host,
                        port: +portString,
                    };
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        else {
            return {
                host,
            };
        }
    }
    else {
        const splitPath = path.split(':');
        /* Exactly one colon means that this is host:port. Zero colons means that
         * there is no port. And multiple colons means that this is a bare IPv6
         * address with no port */
        if (splitPath.length === 2) {
            if (NUMBER_REGEX.test(splitPath[1])) {
                return {
                    host: splitPath[0],
                    port: +splitPath[1],
                };
            }
            else {
                return null;
            }
        }
        else {
            return {
                host: path,
            };
        }
    }
}
function combineHostPort(hostPort) {
    if (hostPort.port === undefined) {
        return hostPort.host;
    }
    else {
        // Only an IPv6 host should include a colon
        if (hostPort.host.includes(':')) {
            return `[${hostPort.host}]:${hostPort.port}`;
        }
        else {
            return `${hostPort.host}:${hostPort.port}`;
        }
    }
}
function uriToString(uri) {
    let result = '';
    if (uri.scheme !== undefined) {
        result += uri.scheme + ':';
    }
    if (uri.authority !== undefined) {
        result += '//' + uri.authority + '/';
    }
    result += uri.path;
    return result;
}
//# sourceMappingURL=uri-parser.js.map{"version":3,"file":"uri-parser.js","sourceRoot":"","sources":["../../src/uri-parser.ts"],"names":[],"mappings":"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"}                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
{
  "name": "@postman/grpc-js",
  "version": "1.11.0-postman.1",
  "description": "gRPC Library for Node - pure JS implementation",
  "homepage": "https://grpc.io/",
  "repository": "https://github.com/postmanlabs/grpc-node/tree/master/packages/grpc-js",
  "main": "build/src/index.js",
  "engines": {
    "node": ">=12.10.0"
  },
  "keywords": [],
  "author": {
    "name": "Google Inc."
  },
  "types": "build/src/index.d.ts",
  "license": "Apache-2.0",
  "devDependencies": {
    "@postman/proto-loader": "file:../proto-loader",
    "@types/gulp": "^4.0.17",
    "@types/gulp-mocha": "0.0.37",
    "@types/lodash": "^4.14.202",
    "@types/mocha": "^10.0.6",
    "@types/ncp": "^2.0.8",
    "@types/node": ">=20.11.20",
    "@types/pify": "^5.0.4",
    "@types/semver": "^7.5.8",
    "@typescript-eslint/eslint-plugin": "^7.1.0",
    "@typescript-eslint/parser": "^7.1.0",
    "@typescript-eslint/typescript-estree": "^7.1.0",
    "clang-format": "^1.8.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^8.8.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^4.2.1",
    "execa": "^2.0.3",
    "gulp": "^4.0.2",
    "gulp-mocha": "^6.0.0",
    "lodash": "^4.17.21",
    "madge": "^5.0.1",
    "mocha-jenkins-reporter": "^0.4.1",
    "ncp": "^2.0.0",
    "pify": "^4.0.1",
    "prettier": "^2.8.8",
    "rimraf": "^3.0.2",
    "semver": "^7.6.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  },
  "contributors": [
    {
      "name": "Google Inc."
    }
  ],
  "scripts": {
    "build": "npm run compile",
    "clean": "rimraf ./build",
    "compile": "tsc -p .",
    "format": "clang-format -i -style=\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\" src/*.ts test/*.ts",
    "lint": "eslint src/*.ts test/*.ts",
    "prepare": "npm run generate-types && npm run compile",
    "test": "gulp test",
    "check": "npm run lint",
    "fix": "eslint --fix src/*.ts test/*.ts",
    "pretest": "npm run generate-types && npm run generate-test-types && npm run compile",
    "posttest": "npm run check && madge -c ./build/src",
    "generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
    "generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
  },
  "dependencies": {
    "@postman/proto-loader": "^0.7.13-postman.3",
    "@js-sdsl/ordered-map": "^4.4.2"
  },
  "files": [
    "src/**/*.ts",
    "build/src/**/*.{js,d.ts,js.map}",
    "proto/*.proto",
    "LICENSE",
    "deps/envoy-api/envoy/api/v2/**/*.proto",
    "deps/envoy-api/envoy/config/**/*.proto",
    "deps/envoy-api/envoy/service/**/*.proto",
    "deps/envoy-api/envoy/type/**/*.proto",
    "deps/udpa/udpa/**/*.proto",
    "deps/googleapis/google/api/*.proto",
    "deps/googleapis/google/rpc/*.proto",
    "deps/protoc-gen-validate/validate/**/*.proto"
  ]
}
// Copyright 2018 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file defines an interface for exporting monitoring information
// out of gRPC servers.  See the full design at
// https://github.com/grpc/proposal/blob/master/A14-channelz.md
//
// The canonical version of this proto can be found at
// https://github.com/grpc/grpc-proto/blob/master/grpc/channelz/v1/channelz.proto

syntax = "proto3";

package grpc.channelz.v1;

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

option go_package = "google.golang.org/grpc/channelz/grpc_channelz_v1";
option java_multiple_files = true;
option java_package = "io.grpc.channelz.v1";
option java_outer_classname = "ChannelzProto";

// Channel is a logical grouping of channels, subchannels, and sockets.
message Channel {
  // The identifier for this channel. This should bet set.
  ChannelRef ref = 1;
  // Data specific to this channel.
  ChannelData data = 2;
  // At most one of 'channel_ref+subchannel_ref' and 'socket' is set.

  // There are no ordering guarantees on the order of channel refs.
  // There may not be cycles in the ref graph.
  // A channel ref may be present in more than one channel or subchannel.
  repeated ChannelRef channel_ref = 3;

  // At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
  // There are no ordering guarantees on the order of subchannel refs.
  // There may not be cycles in the ref graph.
  // A sub channel ref may be present in more than one channel or subchannel.
  repeated SubchannelRef subchannel_ref = 4;

  // There are no ordering guarantees on the order of sockets.
  repeated SocketRef socket_ref = 5;
}

// Subchannel is a logical grouping of channels, subchannels, and sockets.
// A subchannel is load balanced over by it's ancestor
message Subchannel {
  // The identifier for this channel.
  SubchannelRef ref = 1;
  // Data specific to this channel.
  ChannelData data = 2;
  // At most one of 'channel_ref+subchannel_ref' and 'socket' is set.

  // There are no ordering guarantees on the order of channel refs.
  // There may not be cycles in the ref graph.
  // A channel ref may be present in more than one channel or subchannel.
  repeated ChannelRef channel_ref = 3;

  // At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
  // There are no ordering guarantees on the order of subchannel refs.
  // There may not be cycles in the ref graph.
  // A sub channel ref may be present in more than one channel or subchannel.
  repeated SubchannelRef subchannel_ref = 4;

  // There are no ordering guarantees on the order of sockets.
  repeated SocketRef socket_ref = 5;
}

// These come from the specified states in this document:
// https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md
message ChannelConnectivityState {
  enum State {
    UNKNOWN = 0;
    IDLE = 1;
    CONNECTING = 2;
    READY = 3;
    TRANSIENT_FAILURE = 4;
    SHUTDOWN = 5;
  }
  State state = 1;
}

// Channel data is data related to a specific Channel or Subchannel.
message ChannelData {
  // The connectivity state of the channel or subchannel.  Implementations
  // should always set this.
  ChannelConnectivityState state = 1;

  // The target this channel originally tried to connect to.  May be absent
  string target = 2;

  // A trace of recent events on the channel.  May be absent.
  ChannelTrace trace = 3;

  // The number of calls started on the channel
  int64 calls_started = 4;
  // The number of calls that have completed with an OK status
  int64 calls_succeeded = 5;
  // The number of calls that have completed with a non-OK status
  int64 calls_failed = 6;

  // The last time a call was started on the channel.
  google.protobuf.Timestamp last_call_started_timestamp = 7;
}

// A trace event is an interesting thing that happened to a channel or
// subchannel, such as creation, address resolution, subchannel creation, etc.
message ChannelTraceEvent {
  // High level description of the event.
  string description = 1;
  // The supported severity levels of trace events.
  enum Severity {
    CT_UNKNOWN = 0;
    CT_INFO = 1;
    CT_WARNING = 2;
    CT_ERROR = 3;
  }
  // the severity of the trace event
  Severity severity = 2;
  // When this event occurred.
  google.protobuf.Timestamp timestamp = 3;
  // ref of referenced channel or subchannel.
  // Optional, only present if this event refers to a child object. For example,
  // this field would be filled if this trace event was for a subchannel being
  // created.
  oneof child_ref {
    ChannelRef channel_ref = 4;
    SubchannelRef subchannel_ref = 5;
  }
}

// ChannelTrace represents the recent events that have occurred on the channel.
message ChannelTrace {
  // Number of events ever logged in this tracing object. This can differ from
  // events.size() because events can be overwritten or garbage collected by
  // implementations.
  int64 num_events_logged = 1;
  // Time that this channel was created.
  google.protobuf.Timestamp creation_timestamp = 2;
  // List of events that have occurred on this channel.
  repeated ChannelTraceEvent events = 3;
}

// ChannelRef is a reference to a Channel.
message ChannelRef {
  // The globally unique id for this channel.  Must be a positive number.
  int64 channel_id = 1;
  // An optional name associated with the channel.
  string name = 2;
  // Intentionally don't use field numbers from other refs.
  reserved 3, 4, 5, 6, 7, 8;
}

// SubchannelRef is a reference to a Subchannel.
message SubchannelRef {
  // The globally unique id for this subchannel.  Must be a positive number.
  int64 subchannel_id = 7;
  // An optional name associated with the subchannel.
  string name = 8;
  // Intentionally don't use field numbers from other refs.
  reserved 1, 2, 3, 4, 5, 6;
}

// SocketRef is a reference to a Socket.
message SocketRef {
  // The globally unique id for this socket.  Must be a positive number.
  int64 socket_id = 3;
  // An optional name associated with the socket.
  string name = 4;
  // Intentionally don't use field numbers from other refs.
  reserved 1, 2, 5, 6, 7, 8;
}

// ServerRef is a reference to a Server.
message ServerRef {
  // A globally unique identifier for this server.  Must be a positive number.
  int64 server_id = 5;
  // An optional name associated with the server.
  string name = 6;
  // Intentionally don't use field numbers from other refs.
  reserved 1, 2, 3, 4, 7, 8;
}

// Server represents a single server.  There may be multiple servers in a single
// program.
message Server {
  // The identifier for a Server.  This should be set.
  ServerRef ref = 1;
  // The associated data of the Server.
  ServerData data = 2;

  // The sockets that the server is listening on.  There are no ordering
  // guarantees.  This may be absent.
  repeated SocketRef listen_socket = 3;
}

// ServerData is data for a specific Server.
message ServerData {
  // A trace of recent events on the server.  May be absent.
  ChannelTrace trace = 1;

  // The number of incoming calls started on the server
  int64 calls_started = 2;
  // The number of incoming calls that have completed with an OK status
  int64 calls_succeeded = 3;
  // The number of incoming calls that have a completed with a non-OK status
  int64 calls_failed = 4;

  // The last time a call was started on the server.
  google.protobuf.Timestamp last_call_started_timestamp = 5;
}

// Information about an actual connection.  Pronounced "sock-ay".
message Socket {
  // The identifier for the Socket.
  SocketRef ref = 1;

  // Data specific to this Socket.
  SocketData data = 2;
  // The locally bound address.
  Address local = 3;
  // The remote bound address.  May be absent.
  Address remote = 4;
  // Security details for this socket.  May be absent if not available, or
  // there is no security on the socket.
  Security security = 5;

  // Optional, represents the name of the remote endpoint, if different than
  // the original target name.
  string remote_name = 6;
}

// SocketData is data associated for a specific Socket.  The fields present
// are specific to the implementation, so there may be minor differences in
// the semantics.  (e.g. flow control windows)
message SocketData {
  // The number of streams that have been started.
  int64 streams_started = 1;
  // The number of streams that have ended successfully:
  // On client side, received frame with eos bit set;
  // On server side, sent frame with eos bit set.
  int64 streams_succeeded = 2;
  // The number of streams that have ended unsuccessfully:
  // On client side, ended without receiving frame with eos bit set;
  // On server side, ended without sending frame with eos bit set.
  int64 streams_failed = 3;
  // The number of grpc messages successfully sent on this socket.
  int64 messages_sent = 4;
  // The number of grpc messages received on this socket.
  int64 messages_received = 5;

  // The number of keep alives sent.  This is typically implemented with HTTP/2
  // ping messages.
  int64 keep_alives_sent = 6;

  // The last time a stream was created by this endpoint.  Usually unset for
  // servers.
  google.protobuf.Timestamp last_local_stream_created_timestamp = 7;
  // The last time a stream was created by the remote endpoint.  Usually unset
  // for clients.
  google.protobuf.Timestamp last_remote_stream_created_timestamp = 8;

  // The last time a message was sent by this endpoint.
  google.protobuf.Timestamp last_message_sent_timestamp = 9;
  // The last time a message was received by this endpoint.
  google.protobuf.Timestamp last_message_received_timestamp = 10;

  // The amount of window, granted to the local endpoint by the remote endpoint.
  // This may be slightly out of date due to network latency.  This does NOT
  // include stream level or TCP level flow control info.
  google.protobuf.Int64Value local_flow_control_window = 11;

  // The amount of window, granted to the remote endpoint by the local endpoint.
  // This may be slightly out of date due to network latency.  This does NOT
  // include stream level or TCP level flow control info.
  google.protobuf.Int64Value  remote_flow_control_window = 12;

  // Socket options set on this socket.  May be absent if 'summary' is set
  // on GetSocketRequest.
  repeated SocketOption option = 13;
}

// Address represents the address used to create the socket.
message Address {
  message TcpIpAddress {
    // Either the IPv4 or IPv6 address in bytes.  Will be either 4 bytes or 16
    // bytes in length.
    bytes ip_address = 1;
    // 0-64k, or -1 if not appropriate.
    int32 port = 2;
  }
  // A Unix Domain Socket address.
  message UdsAddress {
    string filename = 1;
  }
  // An address type not included above.
  message OtherAddress {
    // The human readable version of the value.  This value should be set.
    string name = 1;
    // The actual address message.
    google.protobuf.Any value = 2;
  }

  oneof address {
    TcpIpAddress tcpip_address = 1;
    UdsAddress uds_address = 2;
    OtherAddress other_address = 3;
  }
}

// Security represents details about how secure the socket is.
message Security {
  message Tls {
    oneof cipher_suite {
      // The cipher suite name in the RFC 4346 format:
      // https://tools.ietf.org/html/rfc4346#appendix-C
      string standard_name = 1;
      // Some other way to describe the cipher suite if
      // the RFC 4346 name is not available.
      string other_name = 2;
    }
    // the certificate used by this endpoint.
    bytes local_certificate = 3;
    // the certificate used by the remote endpoint.
    bytes remote_certificate = 4;
  }
  message OtherSecurity {
    // The human readable version of the value.
    string name = 1;
    // The actual security details message.
    google.protobuf.Any value = 2;
  }
  oneof model {
    Tls tls = 1;
    OtherSecurity other = 2;
  }
}

// SocketOption represents socket options for a socket.  Specifically, these
// are the options returned by getsockopt().
message SocketOption {
  // The full name of the socket option.  Typically this will be the upper case
  // name, such as "SO_REUSEPORT".
  string name = 1;
  // The human readable value of this socket option.  At least one of value or
  // additional will be set.
  string value = 2;
  // Additional data associated with the socket option.  At least one of value
  // or additional will be set.
  google.protobuf.Any additional = 3;
}

// For use with SocketOption's additional field.  This is primarily used for
// SO_RCVTIMEO and SO_SNDTIMEO
message SocketOptionTimeout {
  google.protobuf.Duration duration = 1;
}

// For use with SocketOption's additional field.  This is primarily used for
// SO_LINGER.
message SocketOptionLinger {
  // active maps to `struct linger.l_onoff`
  bool active = 1;
  // duration maps to `struct linger.l_linger`
  google.protobuf.Duration duration = 2;
}

// For use with SocketOption's additional field.  Tcp info for
// SOL_TCP and TCP_INFO.
message SocketOptionTcpInfo {
  uint32 tcpi_state = 1;

  uint32 tcpi_ca_state = 2;
  uint32 tcpi_retransmits = 3;
  uint32 tcpi_probes = 4;
  uint32 tcpi_backoff = 5;
  uint32 tcpi_options = 6;
  uint32 tcpi_snd_wscale = 7;
  uint32 tcpi_rcv_wscale = 8;

  uint32 tcpi_rto = 9;
  uint32 tcpi_ato = 10;
  uint32 tcpi_snd_mss = 11;
  uint32 tcpi_rcv_mss = 12;

  uint32 tcpi_unacked = 13;
  uint32 tcpi_sacked = 14;
  uint32 tcpi_lost = 15;
  uint32 tcpi_retrans = 16;
  uint32 tcpi_fackets = 17;

  uint32 tcpi_last_data_sent = 18;
  uint32 tcpi_last_ack_sent = 19;
  uint32 tcpi_last_data_recv = 20;
  uint32 tcpi_last_ack_recv = 21;

  uint32 tcpi_pmtu = 22;
  uint32 tcpi_rcv_ssthresh = 23;
  uint32 tcpi_rtt = 24;
  uint32 tcpi_rttvar = 25;
  uint32 tcpi_snd_ssthresh = 26;
  uint32 tcpi_snd_cwnd = 27;
  uint32 tcpi_advmss = 28;
  uint32 tcpi_reordering = 29;
}

// Channelz is a service exposed by gRPC servers that provides detailed debug
// information.
service Channelz {
  // Gets all root channels (i.e. channels the application has directly
  // created). This does not include subchannels nor non-top level channels.
  rpc GetTopChannels(GetTopChannelsRequest) returns (GetTopChannelsResponse);
  // Gets all servers that exist in the process.
  rpc GetServers(GetServersRequest) returns (GetServersResponse);
  // Returns a single Server, or else a NOT_FOUND code.
  rpc GetServer(GetServerRequest) returns (GetServerResponse);
  // Gets all server sockets that exist in the process.
  rpc GetServerSockets(GetServerSocketsRequest) returns (GetServerSocketsResponse);
  // Returns a single Channel, or else a NOT_FOUND code.
  rpc GetChannel(GetChannelRequest) returns (GetChannelResponse);
  // Returns a single Subchannel, or else a NOT_FOUND code.
  rpc GetSubchannel(GetSubchannelRequest) returns (GetSubchannelResponse);
  // Returns a single Socket or else a NOT_FOUND code.
  rpc GetSocket(GetSocketRequest) returns (GetSocketResponse);
}

message GetTopChannelsRequest {
  // start_channel_id indicates that only channels at or above this id should be
  // included in the results.
  // To request the first page, this should be set to 0. To request
  // subsequent pages, the client generates this value by adding 1 to
  // the highest seen result ID.
  int64 start_channel_id = 1;

  // If non-zero, the server will return a page of results containing
  // at most this many items. If zero, the server will choose a
  // reasonable page size.  Must never be negative.
  int64 max_results = 2;
}

message GetTopChannelsResponse {
  // list of channels that the connection detail service knows about.  Sorted in
  // ascending channel_id order.
  // Must contain at least 1 result, otherwise 'end' must be true.
  repeated Channel channel = 1;
  // If set, indicates that the list of channels is the final list.  Requesting
  // more channels can only return more if they are created after this RPC
  // completes.
  bool end = 2;
}

message GetServersRequest {
  // start_server_id indicates that only servers at or above this id should be
  // included in the results.
  // To request the first page, this must be set to 0. To request
  // subsequent pages, the client generates this value by adding 1 to
  // the highest seen result ID.
  int64 start_server_id = 1;

  // If non-zero, the server will return a page of results containing
  // at most this many items. If zero, the server will choose a
  // reasonable page size.  Must never be negative.
  int64 max_results = 2;
}

message GetServersResponse {
  // list of servers that the connection detail service knows about.  Sorted in
  // ascending server_id order.
  // Must contain at least 1 result, otherwise 'end' must be true.
  repeated Server server = 1;
  // If set, indicates that the list of servers is the final list.  Requesting
  // more servers will only return more if they are created after this RPC
  // completes.
  bool end = 2;
}

message GetServerRequest {
  // server_id is the identifier of the specific server to get.
  int64 server_id = 1;
}

message GetServerResponse {
  // The Server that corresponds to the requested server_id.  This field
  // should be set.
  Server server = 1;
}

message GetServerSocketsRequest {
  int64 server_id = 1;
  // start_socket_id indicates that only sockets at or above this id should be
  // included in the results.
  // To request the first page, this must be set to 0. To request
  // subsequent pages, the client generates this value by adding 1 to
  // the highest seen result ID.
  int64 start_socket_id = 2;

  // If non-zero, the server will return a page of results containing
  // at most this many items. If zero, the server will choose a
  // reasonable page size.  Must never be negative.
  int64 max_results = 3;
}

message GetServerSocketsResponse {
  // list of socket refs that the connection detail service knows about.  Sorted in
  // ascending socket_id order.
  // Must contain at least 1 result, otherwise 'end' must be true.
  repeated SocketRef socket_ref = 1;
  // If set, indicates that the list of sockets is the final list.  Requesting
  // more sockets will only return more if they are created after this RPC
  // completes.
  bool end = 2;
}

message GetChannelRequest {
  // channel_id is the identifier of the specific channel to get.
  int64 channel_id = 1;
}

message GetChannelResponse {
  // The Channel that corresponds to the requested channel_id.  This field
  // should be set.
  Channel channel = 1;
}

message GetSubchannelRequest {
  // subchannel_id is the identifier of the specific subchannel to get.
  int64 subchannel_id = 1;
}

message GetSubchannelResponse {
  // The Subchannel that corresponds to the requested subchannel_id.  This
  // field should be set.
  Subchannel subchannel = 1;
}

message GetSocketRequest {
  // socket_id is the identifier of the specific socket to get.
  int64 socket_id = 1;

  // If true, the response will contain only high level information
  // that is inexpensive to obtain. Fields thay may be omitted are
  // documented.
  bool summary = 2;
}

message GetSocketResponse {
  // The Socket that corresponds to the requested socket_id.  This field
  // should be set.
  Socket socket = 1;
}# Pure JavaScript gRPC Client

## Installation

Node 12 is recommended. The exact set of compatible Node versions can be found in the `engines` field of the `package.json` file.

```sh
npm install @grpc/grpc-js
```

## Documentation

Documentation specifically for the `@grpc/grpc-js` package is currently not available. However, [documentation is available for the `grpc` package](https://grpc.github.io/grpc/node/grpc.html), and the two packages contain mostly the same interface. There are a few notable differences, however, and these differences are noted in the "Migrating from grpc" section below.

## Features

- Clients
- Automatic reconnection
- Servers
- Streaming
- Metadata
- Partial compression support: clients can compress and decompress messages, and servers can decompress request messages
- Pick first and round robin load balancing policies
- Client Interceptors
- Connection Keepalives
- HTTP Connect support (proxies)

If you need a feature from the `grpc` package that is not provided by the `@grpc/grpc-js`, please file a feature request with that information.

This library does not directly handle `.proto` files. To use `.proto` files with this library we recommend using the `@grpc/proto-loader` package.

## Migrating from [`grpc`](https://www.npmjs.com/package/grpc)

`@grpc/grpc-js` is almost a drop-in replacement for `grpc`, but you may need to make a few code changes to use it:

- If you are currently loading `.proto` files using `grpc.load`, that function is not available in this library. You should instead load your `.proto` files using `@grpc/proto-loader` and load the resulting package definition objects into `@grpc/grpc-js` using `grpc.loadPackageDefinition`.
- If you are currently loading packages generated by `grpc-tools`, you should instead generate your files using the `generate_package_definition` option in `grpc-tools`, then load the object exported by the generated file into `@grpc/grpc-js` using `grpc.loadPackageDefinition`.
- If you have a server and you are using `Server#bind` to bind ports, you will need to use `Server#bindAsync` instead.
- If you are using any channel options supported in `grpc` but not supported in `@grpc/grpc-js`, you may need to adjust your code to handle the different behavior. Refer to [the list of supported options](#supported-channel-options) below.
- Refer to the [detailed package comparison](https://github.com/grpc/grpc-node/blob/master/PACKAGE-COMPARISON.md) for more details on the differences between `grpc` and `@grpc/grpc-js`.

## Supported Channel Options
Many channel arguments supported in `grpc` are not supported in `@grpc/grpc-js`. The channel arguments supported by `@grpc/grpc-js` are:
  - `grpc.ssl_target_name_override`
  - `grpc.primary_user_agent`
  - `grpc.secondary_user_agent`
  - `grpc.default_authority`
  - `grpc.keepalive_time_ms`
  - `grpc.keepalive_timeout_ms`
  - `grpc.keepalive_permit_without_calls`
  - `grpc.service_config`
  - `grpc.max_concurrent_streams`
  - `grpc.initial_reconnect_backoff_ms`
  - `grpc.max_reconnect_backoff_ms`
  - `grpc.use_local_subchannel_pool`
  - `grpc.max_send_message_length`
  - `grpc.max_receive_message_length`
  - `grpc.enable_http_proxy`
  - `grpc.default_compression_algorithm`
  - `grpc.enable_channelz`
  - `grpc.dns_min_time_between_resolutions_ms`
  - `grpc.enable_retries`
  - `grpc.max_connection_age_ms`
  - `grpc.max_connection_age_grace_ms`
  - `grpc.max_connection_idle_ms`
  - `grpc.per_rpc_retry_buffer_size`
  - `grpc.retry_buffer_size`
  - `grpc.service_config_disable_resolution`
  - `grpc.client_idle_timeout_ms`
  - `grpc-node.max_session_memory`
  - `grpc-node.tls_enable_trace`
  - `grpc-node.retry_max_attempts_limit`
  - `channelOverride`
  - `channelFactoryOverride`

  > **Note**: `user-agent` passed in the request metadata will take precedence over  `grpc.primary_user_agent` and `grpc.secondary_user_agent` channel options.

## Some Notes on API Guarantees

The public API of this library follows semantic versioning, with some caveats:

- Some methods are prefixed with an underscore. These methods are internal and should not be considered part of the public API.
- The class `Call` is only exposed due to limitations of TypeScript. It should not be considered part of the public API.
- In general, any API that is exposed by this library but is not exposed by the `grpc` library is likely an error and should not be considered part of the public API.
- The `grpc.experimental` namespace contains APIs that have not stabilized. Any API in that namespace may break in any minor version update.
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ServiceDefinition } from './make-client';
import { Server, UntypedServiceImplementation } from './server';

interface GetServiceDefinition {
  (): ServiceDefinition;
}

interface GetHandlers {
  (): UntypedServiceImplementation;
}

const registeredAdminServices: {
  getServiceDefinition: GetServiceDefinition;
  getHandlers: GetHandlers;
}[] = [];

export function registerAdminService(
  getServiceDefinition: GetServiceDefinition,
  getHandlers: GetHandlers
) {
  registeredAdminServices.push({ getServiceDefinition, getHandlers });
}

export function addAdminServicesToServer(server: Server): void {
  for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
    server.addService(getServiceDefinition(), getHandlers());
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

const INITIAL_BACKOFF_MS = 1000;
const BACKOFF_MULTIPLIER = 1.6;
const MAX_BACKOFF_MS = 120000;
const BACKOFF_JITTER = 0.2;

/**
 * Get a number uniformly at random in the range [min, max)
 * @param min
 * @param max
 */
function uniformRandom(min: number, max: number) {
  return Math.random() * (max - min) + min;
}

export interface BackoffOptions {
  initialDelay?: number;
  multiplier?: number;
  jitter?: number;
  maxDelay?: number;
}

export class BackoffTimeout {
  /**
   * The delay time at the start, and after each reset.
   */
  private readonly initialDelay: number = INITIAL_BACKOFF_MS;
  /**
   * The exponential backoff multiplier.
   */
  private readonly multiplier: number = BACKOFF_MULTIPLIER;
  /**
   * The maximum delay time
   */
  private readonly maxDelay: number = MAX_BACKOFF_MS;
  /**
   * The maximum fraction by which the delay time can randomly vary after
   * applying the multiplier.
   */
  private readonly jitter: number = BACKOFF_JITTER;
  /**
   * The delay time for the next time the timer runs.
   */
  private nextDelay: number;
  /**
   * The handle of the underlying timer. If running is false, this value refers
   * to an object representing a timer that has ended, but it can still be
   * interacted with without error.
   */
  private timerId: NodeJS.Timeout;
  /**
   * Indicates whether the timer is currently running.
   */
  private running = false;
  /**
   * Indicates whether the timer should keep the Node process running if no
   * other async operation is doing so.
   */
  private hasRef = true;
  /**
   * The time that the currently running timer was started. Only valid if
   * running is true.
   */
  private startTime: Date = new Date();
  /**
   * The approximate time that the currently running timer will end. Only valid
   * if running is true.
   */
  private endTime: Date = new Date();

  constructor(private callback: () => void, options?: BackoffOptions) {
    if (options) {
      if (options.initialDelay) {
        this.initialDelay = options.initialDelay;
      }
      if (options.multiplier) {
        this.multiplier = options.multiplier;
      }
      if (options.jitter) {
        this.jitter = options.jitter;
      }
      if (options.maxDelay) {
        this.maxDelay = options.maxDelay;
      }
    }
    this.nextDelay = this.initialDelay;
    this.timerId = setTimeout(() => {}, 0);
    clearTimeout(this.timerId);
  }

  private runTimer(delay: number) {
    this.endTime = this.startTime;
    this.endTime.setMilliseconds(
      this.endTime.getMilliseconds() + this.nextDelay
    );
    clearTimeout(this.timerId);
    this.timerId = setTimeout(() => {
      this.callback();
      this.running = false;
    }, delay);
    if (!this.hasRef) {
      this.timerId.unref?.();
    }
  }

  /**
   * Call the callback after the current amount of delay time
   */
  runOnce() {
    this.running = true;
    this.startTime = new Date();
    this.runTimer(this.nextDelay);
    const nextBackoff = Math.min(
      this.nextDelay * this.multiplier,
      this.maxDelay
    );
    const jitterMagnitude = nextBackoff * this.jitter;
    this.nextDelay =
      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
  }

  /**
   * Stop the timer. The callback will not be called until `runOnce` is called
   * again.
   */
  stop() {
    clearTimeout(this.timerId);
    this.running = false;
  }

  /**
   * Reset the delay time to its initial value. If the timer is still running,
   * retroactively apply that reset to the current timer.
   */
  reset() {
    this.nextDelay = this.initialDelay;
    if (this.running) {
      const now = new Date();
      const newEndTime = this.startTime;
      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
      clearTimeout(this.timerId);
      if (now < newEndTime) {
        this.runTimer(newEndTime.getTime() - now.getTime());
      } else {
        this.running = false;
      }
    }
  }

  /**
   * Check whether the timer is currently running.
   */
  isRunning() {
    return this.running;
  }

  /**
   * Set that while the timer is running, it should keep the Node process
   * running.
   */
  ref() {
    this.hasRef = true;
    this.timerId.ref?.();
  }

  /**
   * Set that while the timer is running, it should not keep the Node process
   * running.
   */
  unref() {
    this.hasRef = false;
    this.timerId.unref?.();
  }

  /**
   * Get the approximate timestamp of when the timer will fire. Only valid if
   * this.isRunning() is true.
   */
  getEndTime() {
    return this.endTime;
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { Metadata } from './metadata';

export interface CallMetadataOptions {
  service_url: string;
}

export type CallMetadataGenerator = (
  options: CallMetadataOptions,
  cb: (err: Error | null, metadata?: Metadata) => void
) => void;

// google-auth-library pre-v2.0.0 does not have getRequestHeaders
// but has getRequestMetadata, which is deprecated in v2.0.0
export interface OldOAuth2Client {
  getRequestMetadata: (
    url: string,
    callback: (
      err: Error | null,
      headers?: {
        [index: string]: string;
      }
    ) => void
  ) => void;
}

export interface CurrentOAuth2Client {
  getRequestHeaders: (url?: string) => Promise<{ [index: string]: string }>;
}

export type OAuth2Client = OldOAuth2Client | CurrentOAuth2Client;

function isCurrentOauth2Client(
  client: OAuth2Client
): client is CurrentOAuth2Client {
  return (
    'getRequestHeaders' in client &&
    typeof client.getRequestHeaders === 'function'
  );
}

/**
 * A class that represents a generic method of adding authentication-related
 * metadata on a per-request basis.
 */
export abstract class CallCredentials {
  /**
   * Asynchronously generates a new Metadata object.
   * @param options Options used in generating the Metadata object.
   */
  abstract generateMetadata(options: CallMetadataOptions): Promise<Metadata>;
  /**
   * Creates a new CallCredentials object from properties of both this and
   * another CallCredentials object. This object's metadata generator will be
   * called first.
   * @param callCredentials The other CallCredentials object.
   */
  abstract compose(callCredentials: CallCredentials): CallCredentials;

  /**
   * Check whether two call credentials objects are equal. Separate
   * SingleCallCredentials with identical metadata generator functions are
   * equal.
   * @param other The other CallCredentials object to compare with.
   */
  abstract _equals(other: CallCredentials): boolean;

  /**
   * Creates a new CallCredentials object from a given function that generates
   * Metadata objects.
   * @param metadataGenerator A function that accepts a set of options, and
   * generates a Metadata object based on these options, which is passed back
   * to the caller via a supplied (err, metadata) callback.
   */
  static createFromMetadataGenerator(
    metadataGenerator: CallMetadataGenerator
  ): CallCredentials {
    return new SingleCallCredentials(metadataGenerator);
  }

  /**
   * Create a gRPC credential from a Google credential object.
   * @param googleCredentials The authentication client to use.
   * @return The resulting CallCredentials object.
   */
  static createFromGoogleCredential(
    googleCredentials: OAuth2Client
  ): CallCredentials {
    return CallCredentials.createFromMetadataGenerator((options, callback) => {
      let getHeaders: Promise<{ [index: string]: string }>;
      if (isCurrentOauth2Client(googleCredentials)) {
        getHeaders = googleCredentials.getRequestHeaders(options.service_url);
      } else {
        getHeaders = new Promise((resolve, reject) => {
          googleCredentials.getRequestMetadata(
            options.service_url,
            (err, headers) => {
              if (err) {
                reject(err);
                return;
              }
              if (!headers) {
                reject(new Error('Headers not set by metadata plugin'));
                return;
              }
              resolve(headers);
            }
          );
        });
      }
      getHeaders.then(
        headers => {
          const metadata = new Metadata();
          for (const key of Object.keys(headers)) {
            metadata.add(key, headers[key]);
          }
          callback(null, metadata);
        },
        err => {
          callback(err);
        }
      );
    });
  }

  static createEmpty(): CallCredentials {
    return new EmptyCallCredentials();
  }
}

class ComposedCallCredentials extends CallCredentials {
  constructor(private creds: CallCredentials[]) {
    super();
  }

  async generateMetadata(options: CallMetadataOptions): Promise<Metadata> {
    const base: Metadata = new Metadata();
    const generated: Metadata[] = await Promise.all(
      this.creds.map(cred => cred.generateMetadata(options))
    );
    for (const gen of generated) {
      base.merge(gen);
    }
    return base;
  }

  compose(other: CallCredentials): CallCredentials {
    return new ComposedCallCredentials(this.creds.concat([other]));
  }

  _equals(other: CallCredentials): boolean {
    if (this === other) {
      return true;
    }
    if (other instanceof ComposedCallCredentials) {
      return this.creds.every((value, index) =>
        value._equals(other.creds[index])
      );
    } else {
      return false;
    }
  }
}

class SingleCallCredentials extends CallCredentials {
  constructor(private metadataGenerator: CallMetadataGenerator) {
    super();
  }

  generateMetadata(options: CallMetadataOptions): Promise<Metadata> {
    return new Promise<Metadata>((resolve, reject) => {
      this.metadataGenerator(options, (err, metadata) => {
        if (metadata !== undefined) {
          resolve(metadata);
        } else {
          reject(err);
        }
      });
    });
  }

  compose(other: CallCredentials): CallCredentials {
    return new ComposedCallCredentials([this, other]);
  }

  _equals(other: CallCredentials): boolean {
    if (this === other) {
      return true;
    }
    if (other instanceof SingleCallCredentials) {
      return this.metadataGenerator === other.metadataGenerator;
    } else {
      return false;
    }
  }
}

class EmptyCallCredentials extends CallCredentials {
  generateMetadata(options: CallMetadataOptions): Promise<Metadata> {
    return Promise.resolve(new Metadata());
  }

  compose(other: CallCredentials): CallCredentials {
    return other;
  }

  _equals(other: CallCredentials): boolean {
    return other instanceof EmptyCallCredentials;
  }
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { CallCredentials } from './call-credentials';
import { Status } from './constants';
import { Deadline } from './deadline';
import { Metadata } from './metadata';
import { ServerSurfaceCall } from './server-call';

export interface CallStreamOptions {
  deadline: Deadline;
  flags: number;
  host: string;
  parentCall: ServerSurfaceCall | null;
}

export type PartialCallStreamOptions = Partial<CallStreamOptions>;

export interface StatusObject {
  code: Status;
  details: string;
  metadata: Metadata;
}

export type PartialStatusObject = Pick<StatusObject, 'code' | 'details'> & {
  metadata?: Metadata | null | undefined;
};

export const enum WriteFlags {
  BufferHint = 1,
  NoCompress = 2,
  WriteThrough = 4,
}

export interface WriteObject {
  message: Buffer;
  flags?: number;
}

export interface MetadataListener {
  (metadata: Metadata, next: (metadata: Metadata) => void): void;
}

export interface MessageListener {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (message: any, next: (message: any) => void): void;
}

export interface StatusListener {
  (status: StatusObject, next: (status: StatusObject) => void): void;
}

export interface FullListener {
  onReceiveMetadata: MetadataListener;
  onReceiveMessage: MessageListener;
  onReceiveStatus: StatusListener;
}

export type Listener = Partial<FullListener>;

/**
 * An object with methods for handling the responses to a call.
 */
export interface InterceptingListener {
  onReceiveMetadata(metadata: Metadata): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onReceiveMessage(message: any): void;
  onReceiveStatus(status: StatusObject): void;
}

export function isInterceptingListener(
  listener: Listener | InterceptingListener
): listener is InterceptingListener {
  return (
    listener.onReceiveMetadata !== undefined &&
    listener.onReceiveMetadata.length === 1
  );
}

export class InterceptingListenerImpl implements InterceptingListener {
  private processingMetadata = false;
  private hasPendingMessage = false;
  private pendingMessage: any;
  private processingMessage = false;
  private pendingStatus: StatusObject | null = null;
  constructor(
    private listener: FullListener,
    private nextListener: InterceptingListener
  ) {}

  private processPendingMessage() {
    if (this.hasPendingMessage) {
      this.nextListener.onReceiveMessage(this.pendingMessage);
      this.pendingMessage = null;
      this.hasPendingMessage = false;
    }
  }

  private processPendingStatus() {
    if (this.pendingStatus) {
      this.nextListener.onReceiveStatus(this.pendingStatus);
    }
  }

  onReceiveMetadata(metadata: Metadata): void {
    this.processingMetadata = true;
    this.listener.onReceiveMetadata(metadata, metadata => {
      this.processingMetadata = false;
      this.nextListener.onReceiveMetadata(metadata);
      this.processPendingMessage();
      this.processPendingStatus();
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onReceiveMessage(message: any): void {
    /* If this listener processes messages asynchronously, the last message may
     * be reordered with respect to the status */
    this.processingMessage = true;
    this.listener.onReceiveMessage(message, msg => {
      this.processingMessage = false;
      if (this.processingMetadata) {
        this.pendingMessage = msg;
        this.hasPendingMessage = true;
      } else {
        this.nextListener.onReceiveMessage(msg);
        this.processPendingStatus();
      }
    });
  }
  onReceiveStatus(status: StatusObject): void {
    this.listener.onReceiveStatus(status, processedStatus => {
      if (this.processingMetadata || this.processingMessage) {
        this.pendingStatus = processedStatus;
      } else {
        this.nextListener.onReceiveStatus(processedStatus);
      }
    });
  }
}

export interface WriteCallback {
  (error?: Error | null): void;
}

export interface MessageContext {
  callback?: WriteCallback;
  flags?: number;
}

export interface Call {
  cancelWithStatus(status: Status, details: string): void;
  getPeer(): string;
  start(metadata: Metadata, listener: InterceptingListener): void;
  sendMessageWithContext(context: MessageContext, message: Buffer): void;
  startRead(): void;
  halfClose(): void;
  getCallNumber(): number;
  setCredentials(credentials: CallCredentials): void;
}

export interface DeadlineInfoProvider {
  getDeadlineInfo(): string[];
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

let nextCallNumber = 0;

export function getNextCallNumber() {
  return nextCallNumber++;
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { EventEmitter } from 'events';
import { Duplex, Readable, Writable } from 'stream';

import { StatusObject, MessageContext } from './call-interface';
import { Status } from './constants';
import { EmitterAugmentation1 } from './events';
import { Metadata } from './metadata';
import { ObjectReadable, ObjectWritable, WriteCallback } from './object-stream';
import { InterceptingCallInterface } from './client-interceptors';

/**
 * A type extending the built-in Error object with additional fields.
 */
export type ServiceError = StatusObject & Error;

/**
 * A base type for all user-facing values returned by client-side method calls.
 */
export type SurfaceCall = {
  call?: InterceptingCallInterface;
  cancel(): void;
  getPeer(): string;
} & EmitterAugmentation1<'metadata', Metadata> &
  EmitterAugmentation1<'status', StatusObject> &
  EventEmitter;

/**
 * A type representing the return value of a unary method call.
 */
export type ClientUnaryCall = SurfaceCall;

/**
 * A type representing the return value of a server stream method call.
 */
export type ClientReadableStream<ResponseType> = {
  deserialize: (chunk: Buffer) => ResponseType;
} & SurfaceCall &
  ObjectReadable<ResponseType>;

/**
 * A type representing the return value of a client stream method call.
 */
export type ClientWritableStream<RequestType> = {
  serialize: (value: RequestType) => Buffer;
} & SurfaceCall &
  ObjectWritable<RequestType>;

/**
 * A type representing the return value of a bidirectional stream method call.
 */
export type ClientDuplexStream<RequestType, ResponseType> =
  ClientWritableStream<RequestType> & ClientReadableStream<ResponseType>;

/**
 * Construct a ServiceError from a StatusObject. This function exists primarily
 * as an attempt to make the error stack trace clearly communicate that the
 * error is not necessarily a problem in gRPC itself.
 * @param status
 */
export function callErrorFromStatus(
  status: StatusObject,
  callerStack: string
): ServiceError {
  const message = `${status.code} ${Status[status.code]}: ${status.details}`;
  const error = new Error(message);
  const stack = `${error.stack}\nfor call at\n${callerStack}`;
  return Object.assign(new Error(message), status, { stack });
}

export class ClientUnaryCallImpl
  extends EventEmitter
  implements ClientUnaryCall
{
  public call?: InterceptingCallInterface;
  constructor() {
    super();
  }

  cancel(): void {
    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');
  }

  getPeer(): string {
    return this.call?.getPeer() ?? 'unknown';
  }
}

export class ClientReadableStreamImpl<ResponseType>
  extends Readable
  implements ClientReadableStream<ResponseType>
{
  public call?: InterceptingCallInterface;
  constructor(readonly deserialize: (chunk: Buffer) => ResponseType) {
    super({ objectMode: true });
  }

  cancel(): void {
    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');
  }

  getPeer(): string {
    return this.call?.getPeer() ?? 'unknown';
  }

  _read(_size: number): void {
    this.call?.startRead();
  }
}

export class ClientWritableStreamImpl<RequestType>
  extends Writable
  implements ClientWritableStream<RequestType>
{
  public call?: InterceptingCallInterface;
  constructor(readonly serialize: (value: RequestType) => Buffer) {
    super({ objectMode: true });
  }

  cancel(): void {
    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');
  }

  getPeer(): string {
    return this.call?.getPeer() ?? 'unknown';
  }

  _write(chunk: RequestType, encoding: string, cb: WriteCallback) {
    const context: MessageContext = {
      callback: cb,
    };
    const flags = Number(encoding);
    if (!Number.isNaN(flags)) {
      context.flags = flags;
    }
    this.call?.sendMessageWithContext(context, chunk);
  }

  _final(cb: Function) {
    this.call?.halfClose();
    cb();
  }
}

export class ClientDuplexStreamImpl<RequestType, ResponseType>
  extends Duplex
  implements ClientDuplexStream<RequestType, ResponseType>
{
  public call?: InterceptingCallInterface;
  constructor(
    readonly serialize: (value: RequestType) => Buffer,
    readonly deserialize: (chunk: Buffer) => ResponseType
  ) {
    super({ objectMode: true });
  }

  cancel(): void {
    this.call?.cancelWithStatus(Status.CANCELLED, 'Cancelled on client');
  }

  getPeer(): string {
    return this.call?.getPeer() ?? 'unknown';
  }

  _read(_size: number): void {
    this.call?.startRead();
  }

  _write(chunk: RequestType, encoding: string, cb: WriteCallback) {
    const context: MessageContext = {
      callback: cb,
    };
    const flags = Number(encoding);
    if (!Number.isNaN(flags)) {
      context.flags = flags;
    }
    this.call?.sendMessageWithContext(context, chunk);
  }

  _final(cb: Function) {
    this.call?.halfClose();
    cb();
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  ConnectionOptions,
  createSecureContext,
  PeerCertificate,
  SecureContext,
} from 'tls';

import { CallCredentials } from './call-credentials';
import { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function verifyIsBufferOrNull(obj: any, friendlyName: string): void {
  if (obj && !(obj instanceof Buffer)) {
    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
  }
}

/**
 * A callback that will receive the expected hostname and presented peer
 * certificate as parameters. The callback should return an error to
 * indicate that the presented certificate is considered invalid and
 * otherwise returned undefined.
 */
export type CheckServerIdentityCallback = (
  hostname: string,
  cert: PeerCertificate
) => Error | undefined;

/**
 * Additional peer verification options that can be set when creating
 * SSL credentials.
 */
export interface VerifyOptions {
  /**
   * If set, this callback will be invoked after the usual hostname verification
   * has been performed on the peer certificate.
   */
  checkServerIdentity?: CheckServerIdentityCallback;
}

/**
 * A class that contains credentials for communicating over a channel, as well
 * as a set of per-call credentials, which are applied to every method call made
 * over a channel initialized with an instance of this class.
 */
export abstract class ChannelCredentials {
  protected callCredentials: CallCredentials;

  protected constructor(callCredentials?: CallCredentials) {
    this.callCredentials = callCredentials || CallCredentials.createEmpty();
  }
  /**
   * Returns a copy of this object with the included set of per-call credentials
   * expanded to include callCredentials.
   * @param callCredentials A CallCredentials object to associate with this
   * instance.
   */
  abstract compose(callCredentials: CallCredentials): ChannelCredentials;

  /**
   * Gets the set of per-call credentials associated with this instance.
   */
  _getCallCredentials(): CallCredentials {
    return this.callCredentials;
  }

  /**
   * Gets a SecureContext object generated from input parameters if this
   * instance was created with createSsl, or null if this instance was created
   * with createInsecure.
   */
  abstract _getConnectionOptions(): ConnectionOptions | null;

  /**
   * Indicates whether this credentials object creates a secure channel.
   */
  abstract _isSecure(): boolean;

  /**
   * Check whether two channel credentials objects are equal. Two secure
   * credentials are equal if they were constructed with the same parameters.
   * @param other The other ChannelCredentials Object
   */
  abstract _equals(other: ChannelCredentials): boolean;

  /**
   * Return a new ChannelCredentials instance with a given set of credentials.
   * The resulting instance can be used to construct a Channel that communicates
   * over TLS.
   * @param rootCerts The root certificate data.
   * @param privateKey The client certificate private key, if available.
   * @param certChain The client certificate key chain, if available.
   * @param verifyOptions Additional options to modify certificate verification
   */
  static createSsl(
    rootCerts?: Buffer | null,
    privateKey?: Buffer | null,
    certChain?: Buffer | null,
    verifyOptions?: VerifyOptions
  ): ChannelCredentials {
    verifyIsBufferOrNull(rootCerts, 'Root certificate');
    verifyIsBufferOrNull(privateKey, 'Private key');
    verifyIsBufferOrNull(certChain, 'Certificate chain');
    if (privateKey && !certChain) {
      throw new Error(
        'Private key must be given with accompanying certificate chain'
      );
    }
    if (!privateKey && certChain) {
      throw new Error(
        'Certificate chain must be given with accompanying private key'
      );
    }
    const secureContext = createSecureContext({
      ca: rootCerts ?? getDefaultRootsData() ?? undefined,
      key: privateKey ?? undefined,
      cert: certChain ?? undefined,
      ciphers: CIPHER_SUITES,
    });
    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});
  }

  /**
   * Return a new ChannelCredentials instance with credentials created using
   * the provided secureContext. The resulting instances can be used to
   * construct a Channel that communicates over TLS. gRPC will not override
   * anything in the provided secureContext, so the environment variables
   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
   * not be applied.
   * @param secureContext The return value of tls.createSecureContext()
   * @param verifyOptions Additional options to modify certificate verification
   */
  static createFromSecureContext(
    secureContext: SecureContext,
    verifyOptions?: VerifyOptions
  ): ChannelCredentials {
    return new SecureChannelCredentialsImpl(secureContext, verifyOptions ?? {});
  }

  /**
   * Return a new ChannelCredentials instance with no credentials.
   */
  static createInsecure(): ChannelCredentials {
    return new InsecureChannelCredentialsImpl();
  }
}

class InsecureChannelCredentialsImpl extends ChannelCredentials {
  constructor() {
    super();
  }

  compose(callCredentials: CallCredentials): never {
    throw new Error('Cannot compose insecure credentials');
  }

  _getConnectionOptions(): ConnectionOptions | null {
    return null;
  }
  _isSecure(): boolean {
    return false;
  }
  _equals(other: ChannelCredentials): boolean {
    return other instanceof InsecureChannelCredentialsImpl;
  }
}

class SecureChannelCredentialsImpl extends ChannelCredentials {
  connectionOptions: ConnectionOptions;

  constructor(
    private secureContext: SecureContext,
    private verifyOptions: VerifyOptions
  ) {
    super();
    this.connectionOptions = {
      secureContext,
    };
    // Node asserts that this option is a function, so we cannot pass undefined
    if (verifyOptions?.checkServerIdentity) {
      this.connectionOptions.checkServerIdentity =
        verifyOptions.checkServerIdentity;
    }
  }

  compose(callCredentials: CallCredentials): ChannelCredentials {
    const combinedCallCredentials =
      this.callCredentials.compose(callCredentials);
    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
  }

  _getConnectionOptions(): ConnectionOptions | null {
    // Copy to prevent callers from mutating this.connectionOptions
    return { ...this.connectionOptions };
  }
  _isSecure(): boolean {
    return true;
  }
  _equals(other: ChannelCredentials): boolean {
    if (this === other) {
      return true;
    }
    if (other instanceof SecureChannelCredentialsImpl) {
      return (
        this.secureContext === other.secureContext &&
        this.verifyOptions.checkServerIdentity ===
          other.verifyOptions.checkServerIdentity
      );
    } else {
      return false;
    }
  }
}

class ComposedChannelCredentialsImpl extends ChannelCredentials {
  constructor(
    private channelCredentials: SecureChannelCredentialsImpl,
    callCreds: CallCredentials
  ) {
    super(callCreds);
  }
  compose(callCredentials: CallCredentials) {
    const combinedCallCredentials =
      this.callCredentials.compose(callCredentials);
    return new ComposedChannelCredentialsImpl(
      this.channelCredentials,
      combinedCallCredentials
    );
  }

  _getConnectionOptions(): ConnectionOptions | null {
    return this.channelCredentials._getConnectionOptions();
  }
  _isSecure(): boolean {
    return true;
  }
  _equals(other: ChannelCredentials): boolean {
    if (this === other) {
      return true;
    }
    if (other instanceof ComposedChannelCredentialsImpl) {
      return (
        this.channelCredentials._equals(other.channelCredentials) &&
        this.callCredentials._equals(other.callCredentials)
      );
    } else {
      return false;
    }
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { CompressionAlgorithms } from './compression-algorithms';

/**
 * An interface that contains options used when initializing a Channel instance.
 */
export interface ChannelOptions {
  'grpc.ssl_target_name_override'?: string;
  'grpc.primary_user_agent'?: string;
  'grpc.secondary_user_agent'?: string;
  'grpc.default_authority'?: string;
  'grpc.keepalive_time_ms'?: number;
  'grpc.keepalive_timeout_ms'?: number;
  'grpc.keepalive_permit_without_calls'?: number;
  'grpc.service_config'?: string;
  'grpc.max_concurrent_streams'?: number;
  'grpc.initial_reconnect_backoff_ms'?: number;
  'grpc.max_reconnect_backoff_ms'?: number;
  'grpc.use_local_subchannel_pool'?: number;
  'grpc.max_send_message_length'?: number;
  'grpc.max_receive_message_length'?: number;
  'grpc.enable_http_proxy'?: number;
  /* http_connect_target and http_connect_creds are used for passing data
   * around internally, and should not be documented as public-facing options
   */
  'grpc.http_connect_target'?: string;
  'grpc.http_connect_creds'?: string;
  'grpc.default_compression_algorithm'?: CompressionAlgorithms;
  'grpc.enable_channelz'?: number;
  'grpc.dns_min_time_between_resolutions_ms'?: number;
  'grpc.enable_retries'?: number;
  'grpc.per_rpc_retry_buffer_size'?: number;
  /* This option is pattered like a core option, but the core does not have
   * this option. It is closely related to the option
   * grpc.per_rpc_retry_buffer_size, which is in the core. The core will likely
   * implement this functionality using the ResourceQuota mechanism, so there
   * will probably not be any collision or other inconsistency. */
  'grpc.retry_buffer_size'?: number;
  'grpc.max_connection_age_ms'?: number;
  'grpc.max_connection_age_grace_ms'?: number;
  'grpc.max_connection_idle_ms'?: number;
  'grpc-node.max_session_memory'?: number;
  'grpc.service_config_disable_resolution'?: number;
  'grpc.client_idle_timeout_ms'?: number;
  /**
   * Set the enableTrace option in TLS clients and servers
   */
  'grpc-node.tls_enable_trace'?: number;
  'grpc.lb.ring_hash.ring_size_cap'?: number;
  'grpc-node.retry_max_attempts_limit'?: number;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any;
}

/**
 * This is for checking provided options at runtime. This is an object for
 * easier membership checking.
 */
export const recognizedOptions = {
  'grpc.ssl_target_name_override': true,
  'grpc.primary_user_agent': true,
  'grpc.secondary_user_agent': true,
  'grpc.default_authority': true,
  'grpc.keepalive_time_ms': true,
  'grpc.keepalive_timeout_ms': true,
  'grpc.keepalive_permit_without_calls': true,
  'grpc.service_config': true,
  'grpc.max_concurrent_streams': true,
  'grpc.initial_reconnect_backoff_ms': true,
  'grpc.max_reconnect_backoff_ms': true,
  'grpc.use_local_subchannel_pool': true,
  'grpc.max_send_message_length': true,
  'grpc.max_receive_message_length': true,
  'grpc.enable_http_proxy': true,
  'grpc.enable_channelz': true,
  'grpc.dns_min_time_between_resolutions_ms': true,
  'grpc.enable_retries': true,
  'grpc.per_rpc_retry_buffer_size': true,
  'grpc.retry_buffer_size': true,
  'grpc.max_connection_age_ms': true,
  'grpc.max_connection_age_grace_ms': true,
  'grpc-node.max_session_memory': true,
  'grpc.service_config_disable_resolution': true,
  'grpc.client_idle_timeout_ms': true,
  'grpc-node.tls_enable_trace': true,
  'grpc.lb.ring_hash.ring_size_cap': true,
  'grpc-node.retry_max_attempts_limit': true,
};

export function channelOptionsEqual(
  options1: ChannelOptions,
  options2: ChannelOptions
) {
  const keys1 = Object.keys(options1).sort();
  const keys2 = Object.keys(options2).sort();
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (let i = 0; i < keys1.length; i += 1) {
    if (keys1[i] !== keys2[i]) {
      return false;
    }
    if (options1[keys1[i]] !== options2[keys2[i]]) {
      return false;
    }
  }
  return true;
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { ServerSurfaceCall } from './server-call';

import { ConnectivityState } from './connectivity-state';
import type { ChannelRef } from './channelz';
import { Call } from './call-interface';
import { InternalChannel } from './internal-channel';
import { Deadline } from './deadline';

/**
 * An interface that represents a communication channel to a server specified
 * by a given address.
 */
export interface Channel {
  /**
   * Close the channel. This has the same functionality as the existing
   * grpc.Client.prototype.close
   */
  close(): void;
  /**
   * Return the target that this channel connects to
   */
  getTarget(): string;
  /**
   * Get the channel's current connectivity state. This method is here mainly
   * because it is in the existing internal Channel class, and there isn't
   * another good place to put it.
   * @param tryToConnect If true, the channel will start connecting if it is
   *     idle. Otherwise, idle channels will only start connecting when a
   *     call starts.
   */
  getConnectivityState(tryToConnect: boolean): ConnectivityState;
  /**
   * Watch for connectivity state changes. This is also here mainly because
   * it is in the existing external Channel class.
   * @param currentState The state to watch for transitions from. This should
   *     always be populated by calling getConnectivityState immediately
   *     before.
   * @param deadline A deadline for waiting for a state change
   * @param callback Called with no error when a state change, or with an
   *     error if the deadline passes without a state change.
   */
  watchConnectivityState(
    currentState: ConnectivityState,
    deadline: Date | number,
    callback: (error?: Error) => void
  ): void;
  /**
   * Get the channelz reference object for this channel. A request to the
   * channelz service for the id in this object will provide information
   * about this channel.
   */
  getChannelzRef(): ChannelRef;
  /**
   * Create a call object. Call is an opaque type that is used by the Client
   * class. This function is called by the gRPC library when starting a
   * request. Implementers should return an instance of Call that is returned
   * from calling createCall on an instance of the provided Channel class.
   * @param method The full method string to request.
   * @param deadline The call deadline
   * @param host A host string override for making the request
   * @param parentCall A server call to propagate some information from
   * @param propagateFlags A bitwise combination of elements of grpc.propagate
   *     that indicates what information to propagate from parentCall.
   */
  createCall(
    method: string,
    deadline: Deadline,
    host: string | null | undefined,
    parentCall: ServerSurfaceCall | null,
    propagateFlags: number | null | undefined
  ): Call;
}

export class ChannelImplementation implements Channel {
  private internalChannel: InternalChannel;

  constructor(
    target: string,
    credentials: ChannelCredentials,
    options: ChannelOptions
  ) {
    if (typeof target !== 'string') {
      throw new TypeError('Channel target must be a string');
    }
    if (!(credentials instanceof ChannelCredentials)) {
      throw new TypeError(
        'Channel credentials must be a ChannelCredentials object'
      );
    }
    if (options) {
      if (typeof options !== 'object') {
        throw new TypeError('Channel options must be an object');
      }
    }

    this.internalChannel = new InternalChannel(target, credentials, options);
  }

  close() {
    this.internalChannel.close();
  }

  getTarget() {
    return this.internalChannel.getTarget();
  }

  getConnectivityState(tryToConnect: boolean) {
    return this.internalChannel.getConnectivityState(tryToConnect);
  }

  watchConnectivityState(
    currentState: ConnectivityState,
    deadline: Date | number,
    callback: (error?: Error) => void
  ): void {
    this.internalChannel.watchConnectivityState(
      currentState,
      deadline,
      callback
    );
  }

  /**
   * Get the channelz reference object for this channel. The returned value is
   * garbage if channelz is disabled for this channel.
   * @returns
   */
  getChannelzRef() {
    return this.internalChannel.getChannelzRef();
  }

  createCall(
    method: string,
    deadline: Deadline,
    host: string | null | undefined,
    parentCall: ServerSurfaceCall | null,
    propagateFlags: number | null | undefined
  ): Call {
    if (typeof method !== 'string') {
      throw new TypeError('Channel#createCall: method must be a string');
    }
    if (!(typeof deadline === 'number' || deadline instanceof Date)) {
      throw new TypeError(
        'Channel#createCall: deadline must be a number or Date'
      );
    }
    return this.internalChannel.createCall(
      method,
      deadline,
      host,
      parentCall,
      propagateFlags
    );
  }
}
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { isIPv4, isIPv6 } from 'net';
import { OrderedMap, type OrderedMapIterator } from '@js-sdsl/ordered-map';
import { ConnectivityState } from './connectivity-state';
import { Status } from './constants';
import { Timestamp } from './generated/google/protobuf/Timestamp';
import { Channel as ChannelMessage } from './generated/grpc/channelz/v1/Channel';
import { ChannelConnectivityState__Output } from './generated/grpc/channelz/v1/ChannelConnectivityState';
import { ChannelRef as ChannelRefMessage } from './generated/grpc/channelz/v1/ChannelRef';
import { ChannelTrace } from './generated/grpc/channelz/v1/ChannelTrace';
import { GetChannelRequest__Output } from './generated/grpc/channelz/v1/GetChannelRequest';
import { GetChannelResponse } from './generated/grpc/channelz/v1/GetChannelResponse';
import { sendUnaryData, ServerUnaryCall } from './server-call';
import { ServerRef as ServerRefMessage } from './generated/grpc/channelz/v1/ServerRef';
import { SocketRef as SocketRefMessage } from './generated/grpc/channelz/v1/SocketRef';
import {
  isTcpSubchannelAddress,
  SubchannelAddress,
} from './subchannel-address';
import { SubchannelRef as SubchannelRefMessage } from './generated/grpc/channelz/v1/SubchannelRef';
import { GetServerRequest__Output } from './generated/grpc/channelz/v1/GetServerRequest';
import { GetServerResponse } from './generated/grpc/channelz/v1/GetServerResponse';
import { Server as ServerMessage } from './generated/grpc/channelz/v1/Server';
import { GetServersRequest__Output } from './generated/grpc/channelz/v1/GetServersRequest';
import { GetServersResponse } from './generated/grpc/channelz/v1/GetServersResponse';
import { GetTopChannelsRequest__Output } from './generated/grpc/channelz/v1/GetTopChannelsRequest';
import { GetTopChannelsResponse } from './generated/grpc/channelz/v1/GetTopChannelsResponse';
import { GetSubchannelRequest__Output } from './generated/grpc/channelz/v1/GetSubchannelRequest';
import { GetSubchannelResponse } from './generated/grpc/channelz/v1/GetSubchannelResponse';
import { Subchannel as SubchannelMessage } from './generated/grpc/channelz/v1/Subchannel';
import { GetSocketRequest__Output } from './generated/grpc/channelz/v1/GetSocketRequest';
import { GetSocketResponse } from './generated/grpc/channelz/v1/GetSocketResponse';
import { Socket as SocketMessage } from './generated/grpc/channelz/v1/Socket';
import { Address } from './generated/grpc/channelz/v1/Address';
import { Security } from './generated/grpc/channelz/v1/Security';
import { GetServerSocketsRequest__Output } from './generated/grpc/channelz/v1/GetServerSocketsRequest';
import { GetServerSocketsResponse } from './generated/grpc/channelz/v1/GetServerSocketsResponse';
import {
  ChannelzDefinition,
  ChannelzHandlers,
} from './generated/grpc/channelz/v1/Channelz';
import { ProtoGrpcType as ChannelzProtoGrpcType } from './generated/channelz';
import type { loadSync } from '@postman/proto-loader';
import { registerAdminService } from './admin';
import { loadPackageDefinition } from './make-client';

export type TraceSeverity =
  | 'CT_UNKNOWN'
  | 'CT_INFO'
  | 'CT_WARNING'
  | 'CT_ERROR';

interface Ref {
  kind: EntityTypes;
  id: number;
  name: string;
}

export interface ChannelRef extends Ref {
  kind: EntityTypes.channel;
}

export interface SubchannelRef extends Ref {
  kind: EntityTypes.subchannel;
}

export interface ServerRef extends Ref {
  kind: EntityTypes.server;
}

export interface SocketRef extends Ref {
  kind: EntityTypes.socket;
}

function channelRefToMessage(ref: ChannelRef): ChannelRefMessage {
  return {
    channel_id: ref.id,
    name: ref.name,
  };
}

function subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage {
  return {
    subchannel_id: ref.id,
    name: ref.name,
  };
}

function serverRefToMessage(ref: ServerRef): ServerRefMessage {
  return {
    server_id: ref.id,
  };
}

function socketRefToMessage(ref: SocketRef): SocketRefMessage {
  return {
    socket_id: ref.id,
    name: ref.name,
  };
}

interface TraceEvent {
  description: string;
  severity: TraceSeverity;
  timestamp: Date;
  childChannel?: ChannelRef;
  childSubchannel?: SubchannelRef;
}

/**
 * The loose upper bound on the number of events that should be retained in a
 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
 * number that should be large enough to contain the recent relevant
 * information, but small enough to not use excessive memory.
 */
const TARGET_RETAINED_TRACES = 32;

/**
 * Default number of sockets/servers/channels/subchannels to return
 */
const DEFAULT_MAX_RESULTS = 100;

export class ChannelzTraceStub {
  readonly events: TraceEvent[] = [];
  readonly creationTimestamp: Date = new Date();
  readonly eventsLogged = 0;

  addTrace(): void {}
  getTraceMessage(): ChannelTrace {
    return {
      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
      num_events_logged: this.eventsLogged,
      events: [],
    };
  }
}

export class ChannelzTrace {
  events: TraceEvent[] = [];
  creationTimestamp: Date;
  eventsLogged = 0;

  constructor() {
    this.creationTimestamp = new Date();
  }

  addTrace(
    severity: TraceSeverity,
    description: string,
    child?: ChannelRef | SubchannelRef
  ) {
    const timestamp = new Date();
    this.events.push({
      description: description,
      severity: severity,
      timestamp: timestamp,
      childChannel: child?.kind === 'channel' ? child : undefined,
      childSubchannel: child?.kind === 'subchannel' ? child : undefined,
    });
    // Whenever the trace array gets too large, discard the first half
    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
      this.events = this.events.slice(TARGET_RETAINED_TRACES);
    }
    this.eventsLogged += 1;
  }

  getTraceMessage(): ChannelTrace {
    return {
      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
      num_events_logged: this.eventsLogged,
      events: this.events.map(event => {
        return {
          description: event.description,
          severity: event.severity,
          timestamp: dateToProtoTimestamp(event.timestamp),
          channel_ref: event.childChannel
            ? channelRefToMessage(event.childChannel)
            : null,
          subchannel_ref: event.childSubchannel
            ? subchannelRefToMessage(event.childSubchannel)
            : null,
        };
      }),
    };
  }
}

type RefOrderedMap = OrderedMap<
  number,
  { ref: { id: number; kind: EntityTypes; name: string }; count: number }
>;

export class ChannelzChildrenTracker {
  private channelChildren: RefOrderedMap = new OrderedMap();
  private subchannelChildren: RefOrderedMap = new OrderedMap();
  private socketChildren: RefOrderedMap = new OrderedMap();
  private trackerMap = {
    [EntityTypes.channel]: this.channelChildren,
    [EntityTypes.subchannel]: this.subchannelChildren,
    [EntityTypes.socket]: this.socketChildren,
  } as const;

  refChild(child: ChannelRef | SubchannelRef | SocketRef) {
    const tracker = this.trackerMap[child.kind];
    const trackedChild = tracker.find(child.id);

    if (trackedChild.equals(tracker.end())) {
      tracker.setElement(
        child.id,
        {
          ref: child,
          count: 1,
        },
        trackedChild
      );
    } else {
      trackedChild.pointer[1].count += 1;
    }
  }

  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) {
    const tracker = this.trackerMap[child.kind];
    const trackedChild = tracker.getElementByKey(child.id);
    if (trackedChild !== undefined) {
      trackedChild.count -= 1;
      if (trackedChild.count === 0) {
        tracker.eraseElementByKey(child.id);
      }
    }
  }

  getChildLists(): ChannelzChildren {
    return {
      channels: this.channelChildren as ChannelzChildren['channels'],
      subchannels: this.subchannelChildren as ChannelzChildren['subchannels'],
      sockets: this.socketChildren as ChannelzChildren['sockets'],
    };
  }
}

export class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
  override refChild(): void {}
  override unrefChild(): void {}
}

export class ChannelzCallTracker {
  callsStarted = 0;
  callsSucceeded = 0;
  callsFailed = 0;
  lastCallStartedTimestamp: Date | null = null;

  addCallStarted() {
    this.callsStarted += 1;
    this.lastCallStartedTimestamp = new Date();
  }
  addCallSucceeded() {
    this.callsSucceeded += 1;
  }
  addCallFailed() {
    this.callsFailed += 1;
  }
}

export class ChannelzCallTrackerStub extends ChannelzCallTracker {
  override addCallStarted() {}
  override addCallSucceeded() {}
  override addCallFailed() {}
}

export interface ChannelzChildren {
  channels: OrderedMap<number, { ref: ChannelRef; count: number }>;
  subchannels: OrderedMap<number, { ref: SubchannelRef; count: number }>;
  sockets: OrderedMap<number, { ref: SocketRef; count: number }>;
}

export interface ChannelInfo {
  target: string;
  state: ConnectivityState;
  trace: ChannelzTrace | ChannelzTraceStub;
  callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;
  children: ChannelzChildren;
}

export type SubchannelInfo = ChannelInfo;

export interface ServerInfo {
  trace: ChannelzTrace;
  callTracker: ChannelzCallTracker;
  listenerChildren: ChannelzChildren;
  sessionChildren: ChannelzChildren;
}

export interface TlsInfo {
  cipherSuiteStandardName: string | null;
  cipherSuiteOtherName: string | null;
  localCertificate: Buffer | null;
  remoteCertificate: Buffer | null;
}

export interface SocketInfo {
  localAddress: SubchannelAddress | null;
  remoteAddress: SubchannelAddress | null;
  security: TlsInfo | null;
  remoteName: string | null;
  streamsStarted: number;
  streamsSucceeded: number;
  streamsFailed: number;
  messagesSent: number;
  messagesReceived: number;
  keepAlivesSent: number;
  lastLocalStreamCreatedTimestamp: Date | null;
  lastRemoteStreamCreatedTimestamp: Date | null;
  lastMessageSentTimestamp: Date | null;
  lastMessageReceivedTimestamp: Date | null;
  localFlowControlWindow: number | null;
  remoteFlowControlWindow: number | null;
}

interface ChannelEntry {
  ref: ChannelRef;
  getInfo(): ChannelInfo;
}

interface SubchannelEntry {
  ref: SubchannelRef;
  getInfo(): SubchannelInfo;
}

interface ServerEntry {
  ref: ServerRef;
  getInfo(): ServerInfo;
}

interface SocketEntry {
  ref: SocketRef;
  getInfo(): SocketInfo;
}

export const enum EntityTypes {
  channel = 'channel',
  subchannel = 'subchannel',
  server = 'server',
  socket = 'socket',
}

type EntryOrderedMap = OrderedMap<number, { ref: Ref; getInfo: () => any }>;

const entityMaps = {
  [EntityTypes.channel]: new OrderedMap<number, ChannelEntry>(),
  [EntityTypes.subchannel]: new OrderedMap<number, SubchannelEntry>(),
  [EntityTypes.server]: new OrderedMap<number, ServerEntry>(),
  [EntityTypes.socket]: new OrderedMap<number, SocketEntry>(),
} as const;

export type RefByType<T extends EntityTypes> = T extends EntityTypes.channel
  ? ChannelRef
  : T extends EntityTypes.server
  ? ServerRef
  : T extends EntityTypes.socket
  ? SocketRef
  : T extends EntityTypes.subchannel
  ? SubchannelRef
  : never;

export type EntryByType<T extends EntityTypes> = T extends EntityTypes.channel
  ? ChannelEntry
  : T extends EntityTypes.server
  ? ServerEntry
  : T extends EntityTypes.socket
  ? SocketEntry
  : T extends EntityTypes.subchannel
  ? SubchannelEntry
  : never;

export type InfoByType<T extends EntityTypes> = T extends EntityTypes.channel
  ? ChannelInfo
  : T extends EntityTypes.subchannel
  ? SubchannelInfo
  : T extends EntityTypes.server
  ? ServerInfo
  : T extends EntityTypes.socket
  ? SocketInfo
  : never;

const generateRegisterFn = <R extends EntityTypes>(kind: R) => {
  let nextId = 1;
  function getNextId(): number {
    return nextId++;
  }

  const entityMap: EntryOrderedMap = entityMaps[kind];

  return (
    name: string,
    getInfo: () => InfoByType<R>,
    channelzEnabled: boolean
  ): RefByType<R> => {
    const id = getNextId();
    const ref = { id, name, kind } as RefByType<R>;
    if (channelzEnabled) {
      entityMap.setElement(id, { ref, getInfo });
    }
    return ref;
  };
};

export const registerChannelzChannel = generateRegisterFn(EntityTypes.channel);
export const registerChannelzSubchannel = generateRegisterFn(
  EntityTypes.subchannel
);
export const registerChannelzServer = generateRegisterFn(EntityTypes.server);
export const registerChannelzSocket = generateRegisterFn(EntityTypes.socket);

export function unregisterChannelzRef(
  ref: ChannelRef | SubchannelRef | ServerRef | SocketRef
) {
  entityMaps[ref.kind].eraseElementByKey(ref.id);
}

/**
 * Parse a single section of an IPv6 address as two bytes
 * @param addressSection A hexadecimal string of length up to 4
 * @returns The pair of bytes representing this address section
 */
function parseIPv6Section(addressSection: string): [number, number] {
  const numberValue = Number.parseInt(addressSection, 16);
  return [(numberValue / 256) | 0, numberValue % 256];
}

/**
 * Parse a chunk of an IPv6 address string to some number of bytes
 * @param addressChunk Some number of segments of up to 4 hexadecimal
 *   characters each, joined by colons.
 * @returns The list of bytes representing this address chunk
 */
function parseIPv6Chunk(addressChunk: string): number[] {
  if (addressChunk === '') {
    return [];
  }
  const bytePairs = addressChunk
    .split(':')
    .map(section => parseIPv6Section(section));
  const result: number[] = [];
  return result.concat(...bytePairs);
}

/**
 * Converts an IPv4 or IPv6 address from string representation to binary
 * representation
 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
 * @returns
 */
function ipAddressStringToBuffer(ipAddress: string): Buffer | null {
  if (isIPv4(ipAddress)) {
    return Buffer.from(
      Uint8Array.from(
        ipAddress.split('.').map(segment => Number.parseInt(segment))
      )
    );
  } else if (isIPv6(ipAddress)) {
    let leftSection: string;
    let rightSection: string;
    const doubleColonIndex = ipAddress.indexOf('::');
    if (doubleColonIndex === -1) {
      leftSection = ipAddress;
      rightSection = '';
    } else {
      leftSection = ipAddress.substring(0, doubleColonIndex);
      rightSection = ipAddress.substring(doubleColonIndex + 2);
    }
    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
    const middleBuffer = Buffer.alloc(
      16 - leftBuffer.length - rightBuffer.length,
      0
    );
    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
  } else {
    return null;
  }
}

function connectivityStateToMessage(
  state: ConnectivityState
): ChannelConnectivityState__Output {
  switch (state) {
    case ConnectivityState.CONNECTING:
      return {
        state: 'CONNECTING',
      };
    case ConnectivityState.IDLE:
      return {
        state: 'IDLE',
      };
    case ConnectivityState.READY:
      return {
        state: 'READY',
      };
    case ConnectivityState.SHUTDOWN:
      return {
        state: 'SHUTDOWN',
      };
    case ConnectivityState.TRANSIENT_FAILURE:
      return {
        state: 'TRANSIENT_FAILURE',
      };
    default:
      return {
        state: 'UNKNOWN',
      };
  }
}

function dateToProtoTimestamp(date?: Date | null): Timestamp | null {
  if (!date) {
    return null;
  }
  const millisSinceEpoch = date.getTime();
  return {
    seconds: (millisSinceEpoch / 1000) | 0,
    nanos: (millisSinceEpoch % 1000) * 1_000_000,
  };
}

function getChannelMessage(channelEntry: ChannelEntry): ChannelMessage {
  const resolvedInfo = channelEntry.getInfo();
  const channelRef: ChannelRefMessage[] = [];
  const subchannelRef: SubchannelRefMessage[] = [];

  resolvedInfo.children.channels.forEach(el => {
    channelRef.push(channelRefToMessage(el[1].ref));
  });

  resolvedInfo.children.subchannels.forEach(el => {
    subchannelRef.push(subchannelRefToMessage(el[1].ref));
  });

  return {
    ref: channelRefToMessage(channelEntry.ref),
    data: {
      target: resolvedInfo.target,
      state: connectivityStateToMessage(resolvedInfo.state),
      calls_started: resolvedInfo.callTracker.callsStarted,
      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
      calls_failed: resolvedInfo.callTracker.callsFailed,
      last_call_started_timestamp: dateToProtoTimestamp(
        resolvedInfo.callTracker.lastCallStartedTimestamp
      ),
      trace: resolvedInfo.trace.getTraceMessage(),
    },
    channel_ref: channelRef,
    subchannel_ref: subchannelRef,
  };
}

function GetChannel(
  call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>,
  callback: sendUnaryData<GetChannelResponse>
): void {
  const channelId = parseInt(call.request.channel_id, 10);
  const channelEntry =
    entityMaps[EntityTypes.channel].getElementByKey(channelId);
  if (channelEntry === undefined) {
    callback({
      code: Status.NOT_FOUND,
      details: 'No channel data found for id ' + channelId,
    });
    return;
  }
  callback(null, { channel: getChannelMessage(channelEntry) });
}

function GetTopChannels(
  call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>,
  callback: sendUnaryData<GetTopChannelsResponse>
): void {
  const maxResults =
    parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
  const resultList: ChannelMessage[] = [];
  const startId = parseInt(call.request.start_channel_id, 10);
  const channelEntries = entityMaps[EntityTypes.channel];

  let i: OrderedMapIterator<number, ChannelEntry>;
  for (
    i = channelEntries.lowerBound(startId);
    !i.equals(channelEntries.end()) && resultList.length < maxResults;
    i = i.next()
  ) {
    resultList.push(getChannelMessage(i.pointer[1]));
  }

  callback(null, {
    channel: resultList,
    end: i.equals(channelEntries.end()),
  });
}

function getServerMessage(serverEntry: ServerEntry): ServerMessage {
  const resolvedInfo = serverEntry.getInfo();
  const listenSocket: SocketRefMessage[] = [];

  resolvedInfo.listenerChildren.sockets.forEach(el => {
    listenSocket.push(socketRefToMessage(el[1].ref));
  });

  return {
    ref: serverRefToMessage(serverEntry.ref),
    data: {
      calls_started: resolvedInfo.callTracker.callsStarted,
      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
      calls_failed: resolvedInfo.callTracker.callsFailed,
      last_call_started_timestamp: dateToProtoTimestamp(
        resolvedInfo.callTracker.lastCallStartedTimestamp
      ),
      trace: resolvedInfo.trace.getTraceMessage(),
    },
    listen_socket: listenSocket,
  };
}

function GetServer(
  call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>,
  callback: sendUnaryData<GetServerResponse>
): void {
  const serverId = parseInt(call.request.server_id, 10);
  const serverEntries = entityMaps[EntityTypes.server];
  const serverEntry = serverEntries.getElementByKey(serverId);
  if (serverEntry === undefined) {
    callback({
      code: Status.NOT_FOUND,
      details: 'No server data found for id ' + serverId,
    });
    return;
  }
  callback(null, { server: getServerMessage(serverEntry) });
}

function GetServers(
  call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>,
  callback: sendUnaryData<GetServersResponse>
): void {
  const maxResults =
    parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
  const startId = parseInt(call.request.start_server_id, 10);
  const serverEntries = entityMaps[EntityTypes.server];
  const resultList: ServerMessage[] = [];

  let i: OrderedMapIterator<number, ServerEntry>;
  for (
    i = serverEntries.lowerBound(startId);
    !i.equals(serverEntries.end()) && resultList.length < maxResults;
    i = i.next()
  ) {
    resultList.push(getServerMessage(i.pointer[1]));
  }

  callback(null, {
    server: resultList,
    end: i.equals(serverEntries.end()),
  });
}

function GetSubchannel(
  call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>,
  callback: sendUnaryData<GetSubchannelResponse>
): void {
  const subchannelId = parseInt(call.request.subchannel_id, 10);
  const subchannelEntry =
    entityMaps[EntityTypes.subchannel].getElementByKey(subchannelId);
  if (subchannelEntry === undefined) {
    callback({
      code: Status.NOT_FOUND,
      details: 'No subchannel data found for id ' + subchannelId,
    });
    return;
  }
  const resolvedInfo = subchannelEntry.getInfo();
  const listenSocket: SocketRefMessage[] = [];

  resolvedInfo.children.sockets.forEach(el => {
    listenSocket.push(socketRefToMessage(el[1].ref));
  });

  const subchannelMessage: SubchannelMessage = {
    ref: subchannelRefToMessage(subchannelEntry.ref),
    data: {
      target: resolvedInfo.target,
      state: connectivityStateToMessage(resolvedInfo.state),
      calls_started: resolvedInfo.callTracker.callsStarted,
      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
      calls_failed: resolvedInfo.callTracker.callsFailed,
      last_call_started_timestamp: dateToProtoTimestamp(
        resolvedInfo.callTracker.lastCallStartedTimestamp
      ),
      trace: resolvedInfo.trace.getTraceMessage(),
    },
    socket_ref: listenSocket,
  };
  callback(null, { subchannel: subchannelMessage });
}

function subchannelAddressToAddressMessage(
  subchannelAddress: SubchannelAddress
): Address {
  if (isTcpSubchannelAddress(subchannelAddress)) {
    return {
      address: 'tcpip_address',
      tcpip_address: {
        ip_address:
          ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,
        port: subchannelAddress.port,
      },
    };
  } else {
    return {
      address: 'uds_address',
      uds_address: {
        filename: subchannelAddress.path,
      },
    };
  }
}

function GetSocket(
  call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>,
  callback: sendUnaryData<GetSocketResponse>
): void {
  const socketId = parseInt(call.request.socket_id, 10);
  const socketEntry = entityMaps[EntityTypes.socket].getElementByKey(socketId);
  if (socketEntry === undefined) {
    callback({
      code: Status.NOT_FOUND,
      details: 'No socket data found for id ' + socketId,
    });
    return;
  }
  const resolvedInfo = socketEntry.getInfo();
  const securityMessage: Security | null = resolvedInfo.security
    ? {
        model: 'tls',
        tls: {
          cipher_suite: resolvedInfo.security.cipherSuiteStandardName
            ? 'standard_name'
            : 'other_name',
          standard_name:
            resolvedInfo.security.cipherSuiteStandardName ?? undefined,
          other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,
          local_certificate:
            resolvedInfo.security.localCertificate ?? undefined,
          remote_certificate:
            resolvedInfo.security.remoteCertificate ?? undefined,
        },
      }
    : null;
  const socketMessage: SocketMessage = {
    ref: socketRefToMessage(socketEntry.ref),
    local: resolvedInfo.localAddress
      ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)
      : null,
    remote: resolvedInfo.remoteAddress
      ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)
      : null,
    remote_name: resolvedInfo.remoteName ?? undefined,
    security: securityMessage,
    data: {
      keep_alives_sent: resolvedInfo.keepAlivesSent,
      streams_started: resolvedInfo.streamsStarted,
      streams_succeeded: resolvedInfo.streamsSucceeded,
      streams_failed: resolvedInfo.streamsFailed,
      last_local_stream_created_timestamp: dateToProtoTimestamp(
        resolvedInfo.lastLocalStreamCreatedTimestamp
      ),
      last_remote_stream_created_timestamp: dateToProtoTimestamp(
        resolvedInfo.lastRemoteStreamCreatedTimestamp
      ),
      messages_received: resolvedInfo.messagesReceived,
      messages_sent: resolvedInfo.messagesSent,
      last_message_received_timestamp: dateToProtoTimestamp(
        resolvedInfo.lastMessageReceivedTimestamp
      ),
      last_message_sent_timestamp: dateToProtoTimestamp(
        resolvedInfo.lastMessageSentTimestamp
      ),
      local_flow_control_window: resolvedInfo.localFlowControlWindow
        ? { value: resolvedInfo.localFlowControlWindow }
        : null,
      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow
        ? { value: resolvedInfo.remoteFlowControlWindow }
        : null,
    },
  };
  callback(null, { socket: socketMessage });
}

function GetServerSockets(
  call: ServerUnaryCall<
    GetServerSocketsRequest__Output,
    GetServerSocketsResponse
  >,
  callback: sendUnaryData<GetServerSocketsResponse>
): void {
  const serverId = parseInt(call.request.server_id, 10);
  const serverEntry = entityMaps[EntityTypes.server].getElementByKey(serverId);

  if (serverEntry === undefined) {
    callback({
      code: Status.NOT_FOUND,
      details: 'No server data found for id ' + serverId,
    });
    return;
  }

  const startId = parseInt(call.request.start_socket_id, 10);
  const maxResults =
    parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
  const resolvedInfo = serverEntry.getInfo();
  // If we wanted to include listener sockets in the result, this line would
  // instead say
  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
  const allSockets = resolvedInfo.sessionChildren.sockets;
  const resultList: SocketRefMessage[] = [];

  let i: OrderedMapIterator<number, { ref: SocketRef }>;
  for (
    i = allSockets.lowerBound(startId);
    !i.equals(allSockets.end()) && resultList.length < maxResults;
    i = i.next()
  ) {
    resultList.push(socketRefToMessage(i.pointer[1].ref));
  }

  callback(null, {
    socket_ref: resultList,
    end: i.equals(allSockets.end()),
  });
}

export function getChannelzHandlers(): ChannelzHandlers {
  return {
    GetChannel,
    GetTopChannels,
    GetServer,
    GetServers,
    GetSubchannel,
    GetSocket,
    GetServerSockets,
  };
}

let loadedChannelzDefinition: ChannelzDefinition | null = null;

export function getChannelzServiceDefinition(): ChannelzDefinition {
  if (loadedChannelzDefinition) {
    return loadedChannelzDefinition;
  }
  /* The purpose of this complexity is to avoid loading @postman/proto-loader at
   * runtime for users who will not use/enable channelz. */
  const loaderLoadSync = require('@postman/proto-loader')
    .loadSync as typeof loadSync;
  const loadedProto = loaderLoadSync('channelz.proto', {
    keepCase: true,
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true,
    includeDirs: [`${__dirname}/../../proto`],
  });
  const channelzGrpcObject = loadPackageDefinition(
    loadedProto
  ) as unknown as ChannelzProtoGrpcType;
  loadedChannelzDefinition =
    channelzGrpcObject.grpc.channelz.v1.Channelz.service;
  return loadedChannelzDefinition;
}

export function setup() {
  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { Metadata } from './metadata';
import {
  StatusObject,
  Listener,
  MetadataListener,
  MessageListener,
  StatusListener,
  FullListener,
  InterceptingListener,
  InterceptingListenerImpl,
  isInterceptingListener,
  MessageContext,
  Call,
} from './call-interface';
import { Status } from './constants';
import { Channel } from './channel';
import { CallOptions } from './client';
import { ClientMethodDefinition } from './make-client';
import { getErrorMessage } from './error';

/**
 * Error class associated with passing both interceptors and interceptor
 * providers to a client constructor or as call options.
 */
export class InterceptorConfigurationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InterceptorConfigurationError';
    Error.captureStackTrace(this, InterceptorConfigurationError);
  }
}

export interface MetadataRequester {
  (
    metadata: Metadata,
    listener: InterceptingListener,
    next: (
      metadata: Metadata,
      listener: InterceptingListener | Listener
    ) => void
  ): void;
}

export interface MessageRequester {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (message: any, next: (message: any) => void): void;
}

export interface CloseRequester {
  (next: () => void): void;
}

export interface CancelRequester {
  (next: () => void): void;
}

/**
 * An object with methods for intercepting and modifying outgoing call operations.
 */
export interface FullRequester {
  start: MetadataRequester;
  sendMessage: MessageRequester;
  halfClose: CloseRequester;
  cancel: CancelRequester;
}

export type Requester = Partial<FullRequester>;

export class ListenerBuilder {
  private metadata: MetadataListener | undefined = undefined;
  private message: MessageListener | undefined = undefined;
  private status: StatusListener | undefined = undefined;

  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {
    this.metadata = onReceiveMetadata;
    return this;
  }

  withOnReceiveMessage(onReceiveMessage: MessageListener): this {
    this.message = onReceiveMessage;
    return this;
  }

  withOnReceiveStatus(onReceiveStatus: StatusListener): this {
    this.status = onReceiveStatus;
    return this;
  }

  build(): Listener {
    return {
      onReceiveMetadata: this.metadata,
      onReceiveMessage: this.message,
      onReceiveStatus: this.status,
    };
  }
}

export class RequesterBuilder {
  private start: MetadataRequester | undefined = undefined;
  private message: MessageRequester | undefined = undefined;
  private halfClose: CloseRequester | undefined = undefined;
  private cancel: CancelRequester | undefined = undefined;

  withStart(start: MetadataRequester): this {
    this.start = start;
    return this;
  }

  withSendMessage(sendMessage: MessageRequester): this {
    this.message = sendMessage;
    return this;
  }

  withHalfClose(halfClose: CloseRequester): this {
    this.halfClose = halfClose;
    return this;
  }

  withCancel(cancel: CancelRequester): this {
    this.cancel = cancel;
    return this;
  }

  build(): Requester {
    return {
      start: this.start,
      sendMessage: this.message,
      halfClose: this.halfClose,
      cancel: this.cancel,
    };
  }
}

/**
 * A Listener with a default pass-through implementation of each method. Used
 * for filling out Listeners with some methods omitted.
 */
const defaultListener: FullListener = {
  onReceiveMetadata: (metadata, next) => {
    next(metadata);
  },
  onReceiveMessage: (message, next) => {
    next(message);
  },
  onReceiveStatus: (status, next) => {
    next(status);
  },
};

/**
 * A Requester with a default pass-through implementation of each method. Used
 * for filling out Requesters with some methods omitted.
 */
const defaultRequester: FullRequester = {
  start: (metadata, listener, next) => {
    next(metadata, listener);
  },
  sendMessage: (message, next) => {
    next(message);
  },
  halfClose: next => {
    next();
  },
  cancel: next => {
    next();
  },
};

export interface InterceptorOptions extends CallOptions {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  method_definition: ClientMethodDefinition<any, any>;
}

export interface InterceptingCallInterface {
  cancelWithStatus(status: Status, details: string): void;
  getPeer(): string;
  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessageWithContext(context: MessageContext, message: any): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessage(message: any): void;
  startRead(): void;
  halfClose(): void;
}

export class InterceptingCall implements InterceptingCallInterface {
  /**
   * The requester that this InterceptingCall uses to modify outgoing operations
   */
  private requester: FullRequester;
  /**
   * Indicates that metadata has been passed to the requester's start
   * method but it has not been passed to the corresponding next callback
   */
  private processingMetadata = false;
  /**
   * Message context for a pending message that is waiting for
   */
  private pendingMessageContext: MessageContext | null = null;
  private pendingMessage: any;
  /**
   * Indicates that a message has been passed to the requester's sendMessage
   * method but it has not been passed to the corresponding next callback
   */
  private processingMessage = false;
  /**
   * Indicates that a status was received but could not be propagated because
   * a message was still being processed.
   */
  private pendingHalfClose = false;
  constructor(
    private nextCall: InterceptingCallInterface,
    requester?: Requester
  ) {
    if (requester) {
      this.requester = {
        start: requester.start ?? defaultRequester.start,
        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,
        halfClose: requester.halfClose ?? defaultRequester.halfClose,
        cancel: requester.cancel ?? defaultRequester.cancel,
      };
    } else {
      this.requester = defaultRequester;
    }
  }

  cancelWithStatus(status: Status, details: string) {
    this.requester.cancel(() => {
      this.nextCall.cancelWithStatus(status, details);
    });
  }

  getPeer() {
    return this.nextCall.getPeer();
  }

  private processPendingMessage() {
    if (this.pendingMessageContext) {
      this.nextCall.sendMessageWithContext(
        this.pendingMessageContext,
        this.pendingMessage
      );
      this.pendingMessageContext = null;
      this.pendingMessage = null;
    }
  }

  private processPendingHalfClose() {
    if (this.pendingHalfClose) {
      this.nextCall.halfClose();
    }
  }

  start(
    metadata: Metadata,
    interceptingListener?: Partial<InterceptingListener>
  ): void {
    const fullInterceptingListener: InterceptingListener = {
      onReceiveMetadata:
        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??
        (metadata => {}),
      onReceiveMessage:
        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??
        (message => {}),
      onReceiveStatus:
        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??
        (status => {}),
    };
    this.processingMetadata = true;
    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
      this.processingMetadata = false;
      let finalInterceptingListener: InterceptingListener;
      if (isInterceptingListener(listener)) {
        finalInterceptingListener = listener;
      } else {
        const fullListener: FullListener = {
          onReceiveMetadata:
            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,
          onReceiveMessage:
            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,
          onReceiveStatus:
            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,
        };
        finalInterceptingListener = new InterceptingListenerImpl(
          fullListener,
          fullInterceptingListener
        );
      }
      this.nextCall.start(md, finalInterceptingListener);
      this.processPendingMessage();
      this.processPendingHalfClose();
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessageWithContext(context: MessageContext, message: any): void {
    this.processingMessage = true;
    this.requester.sendMessage(message, finalMessage => {
      this.processingMessage = false;
      if (this.processingMetadata) {
        this.pendingMessageContext = context;
        this.pendingMessage = message;
      } else {
        this.nextCall.sendMessageWithContext(context, finalMessage);
        this.processPendingHalfClose();
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessage(message: any): void {
    this.sendMessageWithContext({}, message);
  }
  startRead(): void {
    this.nextCall.startRead();
  }
  halfClose(): void {
    this.requester.halfClose(() => {
      if (this.processingMetadata || this.processingMessage) {
        this.pendingHalfClose = true;
      } else {
        this.nextCall.halfClose();
      }
    });
  }
}

function getCall(channel: Channel, path: string, options: CallOptions): Call {
  const deadline = options.deadline ?? Infinity;
  const host = options.host;
  const parent = options.parent ?? null;
  const propagateFlags = options.propagate_flags;
  const credentials = options.credentials;
  const call = channel.createCall(path, deadline, host, parent, propagateFlags);
  if (credentials) {
    call.setCredentials(credentials);
  }
  return call;
}

/**
 * InterceptingCall implementation that directly owns the underlying Call
 * object and handles serialization and deseraizliation.
 */
class BaseInterceptingCall implements InterceptingCallInterface {
  constructor(
    protected call: Call,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    protected methodDefinition: ClientMethodDefinition<any, any>
  ) {}
  cancelWithStatus(status: Status, details: string): void {
    this.call.cancelWithStatus(status, details);
  }
  getPeer(): string {
    return this.call.getPeer();
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessageWithContext(context: MessageContext, message: any): void {
    let serialized: Buffer;
    try {
      serialized = this.methodDefinition.requestSerialize(message);
    } catch (e) {
      this.call.cancelWithStatus(
        Status.INTERNAL,
        `Request message serialization failure: ${getErrorMessage(e)}`
      );
      return;
    }
    this.call.sendMessageWithContext(context, serialized);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessage(message: any) {
    this.sendMessageWithContext({}, message);
  }
  start(
    metadata: Metadata,
    interceptingListener?: Partial<InterceptingListener>
  ): void {
    let readError: StatusObject | null = null;
    this.call.start(metadata, {
      onReceiveMetadata: metadata => {
        interceptingListener?.onReceiveMetadata?.(metadata);
      },
      onReceiveMessage: message => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let deserialized: any;
        try {
          deserialized = this.methodDefinition.responseDeserialize(message);
        } catch (e) {
          readError = {
            code: Status.INTERNAL,
            details: `Response message parsing error: ${getErrorMessage(e)}`,
            metadata: new Metadata(),
          };
          this.call.cancelWithStatus(readError.code, readError.details);
          return;
        }
        interceptingListener?.onReceiveMessage?.(deserialized);
      },
      onReceiveStatus: status => {
        if (readError) {
          interceptingListener?.onReceiveStatus?.(readError);
        } else {
          interceptingListener?.onReceiveStatus?.(status);
        }
      },
    });
  }
  startRead() {
    this.call.startRead();
  }
  halfClose(): void {
    this.call.halfClose();
  }
}

/**
 * BaseInterceptingCall with special-cased behavior for methods with unary
 * responses.
 */
class BaseUnaryInterceptingCall
  extends BaseInterceptingCall
  implements InterceptingCallInterface
{
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {
    super(call, methodDefinition);
  }
  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {
    let receivedMessage = false;
    const wrapperListener: InterceptingListener = {
      onReceiveMetadata:
        listener?.onReceiveMetadata?.bind(listener) ?? (metadata => {}),
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage: (message: any) => {
        receivedMessage = true;
        listener?.onReceiveMessage?.(message);
      },
      onReceiveStatus: (status: StatusObject) => {
        if (!receivedMessage) {
          listener?.onReceiveMessage?.(null);
        }
        listener?.onReceiveStatus?.(status);
      },
    };
    super.start(metadata, wrapperListener);
    this.call.startRead();
  }
}

/**
 * BaseInterceptingCall with special-cased behavior for methods with streaming
 * responses.
 */
class BaseStreamingInterceptingCall
  extends BaseInterceptingCall
  implements InterceptingCallInterface {}

function getBottomInterceptingCall(
  channel: Channel,
  options: InterceptorOptions,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  methodDefinition: ClientMethodDefinition<any, any>
) {
  const call = getCall(channel, methodDefinition.path, options);
  if (methodDefinition.responseStream) {
    return new BaseStreamingInterceptingCall(call, methodDefinition);
  } else {
    return new BaseUnaryInterceptingCall(call, methodDefinition);
  }
}

export interface NextCall {
  (options: InterceptorOptions): InterceptingCallInterface;
}

export interface Interceptor {
  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;
}

export interface InterceptorProvider {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;
}

export interface InterceptorArguments {
  clientInterceptors: Interceptor[];
  clientInterceptorProviders: InterceptorProvider[];
  callInterceptors: Interceptor[];
  callInterceptorProviders: InterceptorProvider[];
}

export function getInterceptingCall(
  interceptorArgs: InterceptorArguments,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  methodDefinition: ClientMethodDefinition<any, any>,
  options: CallOptions,
  channel: Channel
): InterceptingCallInterface {
  if (
    interceptorArgs.clientInterceptors.length > 0 &&
    interceptorArgs.clientInterceptorProviders.length > 0
  ) {
    throw new InterceptorConfigurationError(
      'Both interceptors and interceptor_providers were passed as options ' +
        'to the client constructor. Only one of these is allowed.'
    );
  }
  if (
    interceptorArgs.callInterceptors.length > 0 &&
    interceptorArgs.callInterceptorProviders.length > 0
  ) {
    throw new InterceptorConfigurationError(
      'Both interceptors and interceptor_providers were passed as call ' +
        'options. Only one of these is allowed.'
    );
  }
  let interceptors: Interceptor[] = [];
  // Interceptors passed to the call override interceptors passed to the client constructor
  if (
    interceptorArgs.callInterceptors.length > 0 ||
    interceptorArgs.callInterceptorProviders.length > 0
  ) {
    interceptors = ([] as Interceptor[])
      .concat(
        interceptorArgs.callInterceptors,
        interceptorArgs.callInterceptorProviders.map(provider =>
          provider(methodDefinition)
        )
      )
      .filter(interceptor => interceptor);
    // Filter out falsy values when providers return nothing
  } else {
    interceptors = ([] as Interceptor[])
      .concat(
        interceptorArgs.clientInterceptors,
        interceptorArgs.clientInterceptorProviders.map(provider =>
          provider(methodDefinition)
        )
      )
      .filter(interceptor => interceptor);
    // Filter out falsy values when providers return nothing
  }
  const interceptorOptions = Object.assign({}, options, {
    method_definition: methodDefinition,
  });
  /* For each interceptor in the list, the nextCall function passed to it is
   * based on the next interceptor in the list, using a nextCall function
   * constructed with the following interceptor in the list, and so on. The
   * initialValue, which is effectively at the end of the list, is a nextCall
   * function that invokes getBottomInterceptingCall, the result of which
   * handles (de)serialization and also gets the underlying call from the
   * channel. */
  const getCall: NextCall = interceptors.reduceRight<NextCall>(
    (nextCall: NextCall, nextInterceptor: Interceptor) => {
      return currentOptions => nextInterceptor(currentOptions, nextCall);
    },
    (finalOptions: InterceptorOptions) =>
      getBottomInterceptingCall(channel, finalOptions, methodDefinition)
  );
  return getCall(interceptorOptions);
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  ClientDuplexStream,
  ClientDuplexStreamImpl,
  ClientReadableStream,
  ClientReadableStreamImpl,
  ClientUnaryCall,
  ClientUnaryCallImpl,
  ClientWritableStream,
  ClientWritableStreamImpl,
  ServiceError,
  callErrorFromStatus,
  SurfaceCall,
} from './call';
import { CallCredentials } from './call-credentials';
import { StatusObject } from './call-interface';
import { Channel, ChannelImplementation } from './channel';
import { ConnectivityState } from './connectivity-state';
import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { Status } from './constants';
import { Metadata } from './metadata';
import { ClientMethodDefinition } from './make-client';
import {
  getInterceptingCall,
  Interceptor,
  InterceptorProvider,
  InterceptorArguments,
  InterceptingCallInterface,
} from './client-interceptors';
import {
  ServerUnaryCall,
  ServerReadableStream,
  ServerWritableStream,
  ServerDuplexStream,
} from './server-call';
import { Deadline } from './deadline';

const CHANNEL_SYMBOL = Symbol();
const INTERCEPTOR_SYMBOL = Symbol();
const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();

function isFunction<ResponseType>(
  arg: Metadata | CallOptions | UnaryCallback<ResponseType> | undefined
): arg is UnaryCallback<ResponseType> {
  return typeof arg === 'function';
}

export interface UnaryCallback<ResponseType> {
  (err: ServiceError | null, value?: ResponseType): void;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
export interface CallOptions {
  deadline?: Deadline;
  host?: string;
  parent?:
    | ServerUnaryCall<any, any>
    | ServerReadableStream<any, any>
    | ServerWritableStream<any, any>
    | ServerDuplexStream<any, any>;
  propagate_flags?: number;
  credentials?: CallCredentials;
  interceptors?: Interceptor[];
  interceptor_providers?: InterceptorProvider[];
}
/* eslint-enable @typescript-eslint/no-explicit-any */

export interface CallProperties<RequestType, ResponseType> {
  argument?: RequestType;
  metadata: Metadata;
  call: SurfaceCall;
  channel: Channel;
  methodDefinition: ClientMethodDefinition<RequestType, ResponseType>;
  callOptions: CallOptions;
  callback?: UnaryCallback<ResponseType>;
}

export interface CallInvocationTransformer {
  (callProperties: CallProperties<any, any>): CallProperties<any, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
}

export type ClientOptions = Partial<ChannelOptions> & {
  channelOverride?: Channel;
  channelFactoryOverride?: (
    address: string,
    credentials: ChannelCredentials,
    options: ClientOptions
  ) => Channel;
  interceptors?: Interceptor[];
  interceptor_providers?: InterceptorProvider[];
  callInvocationTransformer?: CallInvocationTransformer;
};

function getErrorStackString(error: Error): string {
  return error.stack?.split('\n').slice(1).join('\n') || 'no stack trace available';
}

/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
export class Client {
  private readonly [CHANNEL_SYMBOL]: Channel;
  private readonly [INTERCEPTOR_SYMBOL]: Interceptor[];
  private readonly [INTERCEPTOR_PROVIDER_SYMBOL]: InterceptorProvider[];
  private readonly [CALL_INVOCATION_TRANSFORMER_SYMBOL]?: CallInvocationTransformer;
  constructor(
    address: string,
    credentials: ChannelCredentials,
    options: ClientOptions = {}
  ) {
    options = Object.assign({}, options);
    this[INTERCEPTOR_SYMBOL] = options.interceptors ?? [];
    delete options.interceptors;
    this[INTERCEPTOR_PROVIDER_SYMBOL] = options.interceptor_providers ?? [];
    delete options.interceptor_providers;
    if (
      this[INTERCEPTOR_SYMBOL].length > 0 &&
      this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0
    ) {
      throw new Error(
        'Both interceptors and interceptor_providers were passed as options ' +
          'to the client constructor. Only one of these is allowed.'
      );
    }
    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
      options.callInvocationTransformer;
    delete options.callInvocationTransformer;
    if (options.channelOverride) {
      this[CHANNEL_SYMBOL] = options.channelOverride;
    } else if (options.channelFactoryOverride) {
      const channelFactoryOverride = options.channelFactoryOverride;
      delete options.channelFactoryOverride;
      this[CHANNEL_SYMBOL] = channelFactoryOverride(
        address,
        credentials,
        options
      );
    } else {
      this[CHANNEL_SYMBOL] = new ChannelImplementation(
        address,
        credentials,
        options
      );
    }
  }

  close(): void {
    this[CHANNEL_SYMBOL].close();
  }

  getChannel(): Channel {
    return this[CHANNEL_SYMBOL];
  }

  waitForReady(deadline: Deadline, callback: (error?: Error) => void): void {
    const checkState = (err?: Error) => {
      if (err) {
        callback(new Error('Failed to connect before the deadline'));
        return;
      }
      let newState;
      try {
        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
      } catch (e) {
        callback(new Error('The channel has been closed'));
        return;
      }
      if (newState === ConnectivityState.READY) {
        callback();
      } else {
        try {
          this[CHANNEL_SYMBOL].watchConnectivityState(
            newState,
            deadline,
            checkState
          );
        } catch (e) {
          callback(new Error('The channel has been closed'));
        }
      }
    };
    setImmediate(checkState);
  }

  private checkOptionalUnaryResponseArguments<ResponseType>(
    arg1: Metadata | CallOptions | UnaryCallback<ResponseType>,
    arg2?: CallOptions | UnaryCallback<ResponseType>,
    arg3?: UnaryCallback<ResponseType>
  ): {
    metadata: Metadata;
    options: CallOptions;
    callback: UnaryCallback<ResponseType>;
  } {
    if (isFunction(arg1)) {
      return { metadata: new Metadata(), options: {}, callback: arg1 };
    } else if (isFunction(arg2)) {
      if (arg1 instanceof Metadata) {
        return { metadata: arg1, options: {}, callback: arg2 };
      } else {
        return { metadata: new Metadata(), options: arg1, callback: arg2 };
      }
    } else {
      if (
        !(
          arg1 instanceof Metadata &&
          arg2 instanceof Object &&
          isFunction(arg3)
        )
      ) {
        throw new Error('Incorrect arguments passed');
      }
      return { metadata: arg1, options: arg2, callback: arg3 };
    }
  }

  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,
    options?: CallOptions | UnaryCallback<ResponseType>,
    callback?: UnaryCallback<ResponseType>
  ): ClientUnaryCall {
    const checkedArguments =
      this.checkOptionalUnaryResponseArguments<ResponseType>(
        metadata,
        options,
        callback
      );
    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =
      {
        path: method,
        requestStream: false,
        responseStream: false,
        requestSerialize: serialize,
        responseDeserialize: deserialize,
      };
    let callProperties: CallProperties<RequestType, ResponseType> = {
      argument: argument,
      metadata: checkedArguments.metadata,
      call: new ClientUnaryCallImpl(),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
      callback: checkedArguments.callback,
    };
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
    }
    const emitter: ClientUnaryCall = callProperties.call;
    const interceptorArgs: InterceptorArguments = {
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
    };
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    emitter.call = call;
    let responseMessage: ResponseType | null = null;
    let receivedStatus = false;
    let callerStackError: Error | null = new Error();
    call.start(callProperties.metadata, {
      onReceiveMetadata: metadata => {
        emitter.emit('metadata', metadata);
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message: any) {
        if (responseMessage !== null) {
          call.cancelWithStatus(Status.UNIMPLEMENTED, 'Too many responses received');
        }
        responseMessage = message;
      },
      onReceiveStatus(status: StatusObject) {
        if (receivedStatus) {
          return;
        }
        receivedStatus = true;
        if (status.code === Status.OK) {
          if (responseMessage === null) {
            const callerStack = getErrorStackString(callerStackError!);
            callProperties.callback!(
              callErrorFromStatus(
                {
                  code: Status.UNIMPLEMENTED,
                  details: 'No message received',
                  metadata: status.metadata,
                },
                callerStack
              )
            );
          } else {
            callProperties.callback!(null, responseMessage);
          }
        } else {
          const callerStack = getErrorStackString(callerStackError!);
          callProperties.callback!(callErrorFromStatus(status, callerStack));
        }
        /* Avoid retaining the callerStackError object in the call context of
         * the status event handler. */
        callerStackError = null;
        emitter.emit('status', status);
      },
    });
    call.sendMessage(argument);
    call.halfClose();
    return emitter;
  }

  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,
    options?: CallOptions | UnaryCallback<ResponseType>,
    callback?: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType> {
    const checkedArguments =
      this.checkOptionalUnaryResponseArguments<ResponseType>(
        metadata,
        options,
        callback
      );
    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =
      {
        path: method,
        requestStream: true,
        responseStream: false,
        requestSerialize: serialize,
        responseDeserialize: deserialize,
      };
    let callProperties: CallProperties<RequestType, ResponseType> = {
      metadata: checkedArguments.metadata,
      call: new ClientWritableStreamImpl<RequestType>(serialize),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
      callback: checkedArguments.callback,
    };
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
    }
    const emitter: ClientWritableStream<RequestType> =
      callProperties.call as ClientWritableStream<RequestType>;
    const interceptorArgs: InterceptorArguments = {
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
    };
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    emitter.call = call;
    let responseMessage: ResponseType | null = null;
    let receivedStatus = false;
    let callerStackError: Error | null = new Error();
    call.start(callProperties.metadata, {
      onReceiveMetadata: metadata => {
        emitter.emit('metadata', metadata);
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message: any) {
        if (responseMessage !== null) {
          call.cancelWithStatus(Status.UNIMPLEMENTED, 'Too many responses received');
        }
        responseMessage = message;
        call.startRead();
      },
      onReceiveStatus(status: StatusObject) {
        if (receivedStatus) {
          return;
        }
        receivedStatus = true;
        if (status.code === Status.OK) {
          if (responseMessage === null) {
            const callerStack = getErrorStackString(callerStackError!);
            callProperties.callback!(
              callErrorFromStatus(
                {
                  code: Status.UNIMPLEMENTED,
                  details: 'No message received',
                  metadata: status.metadata,
                },
                callerStack
              )
            );
          } else {
            callProperties.callback!(null, responseMessage);
          }
        } else {
          const callerStack = getErrorStackString(callerStackError!);
          callProperties.callback!(callErrorFromStatus(status, callerStack));
        }
        /* Avoid retaining the callerStackError object in the call context of
         * the status event handler. */
        callerStackError = null;
        emitter.emit('status', status);
      },
    });
    return emitter;
  }

  private checkMetadataAndOptions(
    arg1?: Metadata | CallOptions,
    arg2?: CallOptions
  ): { metadata: Metadata; options: CallOptions } {
    let metadata: Metadata;
    let options: CallOptions;
    if (arg1 instanceof Metadata) {
      metadata = arg1;
      if (arg2) {
        options = arg2;
      } else {
        options = {};
      }
    } else {
      if (arg1) {
        options = arg1;
      } else {
        options = {};
      }
      metadata = new Metadata();
    }
    return { metadata, options };
  }

  makeServerStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata,
    options?: CallOptions
  ): ClientReadableStream<ResponseType>;
  makeServerStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    options?: CallOptions
  ): ClientReadableStream<ResponseType>;
  makeServerStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata?: Metadata | CallOptions,
    options?: CallOptions
  ): ClientReadableStream<ResponseType> {
    const checkedArguments = this.checkMetadataAndOptions(metadata, options);
    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =
      {
        path: method,
        requestStream: false,
        responseStream: true,
        requestSerialize: serialize,
        responseDeserialize: deserialize,
      };
    let callProperties: CallProperties<RequestType, ResponseType> = {
      argument: argument,
      metadata: checkedArguments.metadata,
      call: new ClientReadableStreamImpl<ResponseType>(deserialize),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
    };
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
    }
    const stream: ClientReadableStream<ResponseType> =
      callProperties.call as ClientReadableStream<ResponseType>;
    const interceptorArgs: InterceptorArguments = {
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
    };
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    stream.call = call;
    let receivedStatus = false;
    let callerStackError: Error | null = new Error();
    call.start(callProperties.metadata, {
      onReceiveMetadata(metadata: Metadata) {
        stream.emit('metadata', metadata);
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message: any) {
        stream.push(message);
      },
      onReceiveStatus(status: StatusObject) {
        if (receivedStatus) {
          return;
        }
        receivedStatus = true;
        stream.push(null);
        if (status.code !== Status.OK) {
          const callerStack = getErrorStackString(callerStackError!);
          stream.emit('error', callErrorFromStatus(status, callerStack));
        }
        /* Avoid retaining the callerStackError object in the call context of
         * the status event handler. */
        callerStackError = null;
        stream.emit('status', status);
      },
    });
    call.sendMessage(argument);
    call.halfClose();
    return stream;
  }

  makeBidiStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata,
    options?: CallOptions
  ): ClientDuplexStream<RequestType, ResponseType>;
  makeBidiStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    options?: CallOptions
  ): ClientDuplexStream<RequestType, ResponseType>;
  makeBidiStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata?: Metadata | CallOptions,
    options?: CallOptions
  ): ClientDuplexStream<RequestType, ResponseType> {
    const checkedArguments = this.checkMetadataAndOptions(metadata, options);
    const methodDefinition: ClientMethodDefinition<RequestType, ResponseType> =
      {
        path: method,
        requestStream: true,
        responseStream: true,
        requestSerialize: serialize,
        responseDeserialize: deserialize,
      };
    let callProperties: CallProperties<RequestType, ResponseType> = {
      metadata: checkedArguments.metadata,
      call: new ClientDuplexStreamImpl<RequestType, ResponseType>(
        serialize,
        deserialize
      ),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
    };
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
    }
    const stream: ClientDuplexStream<RequestType, ResponseType> =
      callProperties.call as ClientDuplexStream<RequestType, ResponseType>;
    const interceptorArgs: InterceptorArguments = {
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
    };
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    stream.call = call;
    let receivedStatus = false;
    let callerStackError: Error | null = new Error();
    call.start(callProperties.metadata, {
      onReceiveMetadata(metadata: Metadata) {
        stream.emit('metadata', metadata);
      },
      onReceiveMessage(message: Buffer) {
        stream.push(message);
      },
      onReceiveStatus(status: StatusObject) {
        if (receivedStatus) {
          return;
        }
        receivedStatus = true;
        stream.push(null);
        if (status.code !== Status.OK) {
          const callerStack = getErrorStackString(callerStackError!);
          stream.emit('error', callErrorFromStatus(status, callerStack));
        }
        /* Avoid retaining the callerStackError object in the call context of
         * the status event handler. */
        callerStackError = null;
        stream.emit('status', status);
      },
    });
    return stream;
  }
}
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export enum CompressionAlgorithms {
  identity = 0,
  deflate = 1,
  gzip = 2,
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as zlib from 'zlib';

import { WriteObject, WriteFlags } from './call-interface';
import { Channel } from './channel';
import { ChannelOptions } from './channel-options';
import { CompressionAlgorithms } from './compression-algorithms';
import { DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH, DEFAULT_MAX_SEND_MESSAGE_LENGTH, LogVerbosity, Status } from './constants';
import { BaseFilter, Filter, FilterFactory } from './filter';
import * as logging from './logging';
import { Metadata, MetadataValue } from './metadata';

const isCompressionAlgorithmKey = (
  key: number
): key is CompressionAlgorithms => {
  return (
    typeof key === 'number' && typeof CompressionAlgorithms[key] === 'string'
  );
};

type CompressionAlgorithm = keyof typeof CompressionAlgorithms;

type SharedCompressionFilterConfig = {
  serverSupportedEncodingHeader?: string;
};

abstract class CompressionHandler {
  protected abstract compressMessage(message: Buffer): Promise<Buffer>;
  protected abstract decompressMessage(data: Buffer): Promise<Buffer>;
  /**
   * @param message Raw uncompressed message bytes
   * @param compress Indicates whether the message should be compressed
   * @return Framed message, compressed if applicable
   */
  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {
    let messageBuffer = message;
    if (compress) {
      messageBuffer = await this.compressMessage(messageBuffer);
    }
    const output = Buffer.allocUnsafe(messageBuffer.length + 5);
    output.writeUInt8(compress ? 1 : 0, 0);
    output.writeUInt32BE(messageBuffer.length, 1);
    messageBuffer.copy(output, 5);
    return output;
  }
  /**
   * @param data Framed message, possibly compressed
   * @return Uncompressed message
   */
  async readMessage(data: Buffer): Promise<Buffer> {
    const compressed = data.readUInt8(0) === 1;
    let messageBuffer = data.slice(5);
    if (compressed) {
      messageBuffer = await this.decompressMessage(messageBuffer);
    }
    return messageBuffer;
  }
}

class IdentityHandler extends CompressionHandler {
  async compressMessage(message: Buffer) {
    return message;
  }

  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {
    const output = Buffer.allocUnsafe(message.length + 5);
    /* With "identity" compression, messages should always be marked as
     * uncompressed */
    output.writeUInt8(0, 0);
    output.writeUInt32BE(message.length, 1);
    message.copy(output, 5);
    return output;
  }

  decompressMessage(message: Buffer): Promise<Buffer> {
    return Promise.reject<Buffer>(
      new Error(
        'Received compressed message but "grpc-encoding" header was identity'
      )
    );
  }
}

class DeflateHandler extends CompressionHandler {
  constructor(private maxRecvMessageLength: number) {
    super();
  }

  compressMessage(message: Buffer) {
    return new Promise<Buffer>((resolve, reject) => {
      zlib.deflate(message, (err, output) => {
        if (err) {
          reject(err);
        } else {
          resolve(output);
        }
      });
    });
  }

  decompressMessage(message: Buffer) {
    return new Promise<Buffer>((resolve, reject) => {
      let totalLength = 0;
      const messageParts: Buffer[] = [];
      const decompresser = zlib.createInflate();
      decompresser.on('data', (chunk: Buffer) => {
        messageParts.push(chunk);
        totalLength += chunk.byteLength;
        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
          decompresser.destroy();
          reject({
            code: Status.RESOURCE_EXHAUSTED,
            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
          });
        }
      });
      decompresser.on('end', () => {
        resolve(Buffer.concat(messageParts));
      });
      decompresser.write(message);
      decompresser.end();
    });
  }
}

class GzipHandler extends CompressionHandler {
  constructor(private maxRecvMessageLength: number) {
    super();
  }

  compressMessage(message: Buffer) {
    return new Promise<Buffer>((resolve, reject) => {
      zlib.gzip(message, (err, output) => {
        if (err) {
          reject(err);
        } else {
          resolve(output);
        }
      });
    });
  }

  decompressMessage(message: Buffer) {
    return new Promise<Buffer>((resolve, reject) => {
      let totalLength = 0;
      const messageParts: Buffer[] = [];
      const decompresser = zlib.createGunzip();
      decompresser.on('data', (chunk: Buffer) => {
        messageParts.push(chunk);
        totalLength += chunk.byteLength;
        if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
          decompresser.destroy();
          reject({
            code: Status.RESOURCE_EXHAUSTED,
            details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
          });
        }
      });
      decompresser.on('end', () => {
        resolve(Buffer.concat(messageParts));
      });
      decompresser.write(message);
      decompresser.end();
    });
  }
}

class UnknownHandler extends CompressionHandler {
  constructor(private readonly compressionName: string) {
    super();
  }
  compressMessage(message: Buffer): Promise<Buffer> {
    return Promise.reject<Buffer>(
      new Error(
        `Received message compressed with unsupported compression method ${this.compressionName}`
      )
    );
  }

  decompressMessage(message: Buffer): Promise<Buffer> {
    // This should be unreachable
    return Promise.reject<Buffer>(
      new Error(`Compression method not supported: ${this.compressionName}`)
    );
  }
}

function getCompressionHandler(compressionName: string, maxReceiveMessageSize: number): CompressionHandler {
  switch (compressionName) {
    case 'identity':
      return new IdentityHandler();
    case 'deflate':
      return new DeflateHandler(maxReceiveMessageSize);
    case 'gzip':
      return new GzipHandler(maxReceiveMessageSize);
    default:
      return new UnknownHandler(compressionName);
  }
}

export class CompressionFilter extends BaseFilter implements Filter {
  private sendCompression: CompressionHandler = new IdentityHandler();
  private receiveCompression: CompressionHandler = new IdentityHandler();
  private currentCompressionAlgorithm: CompressionAlgorithm = 'identity';
  private maxReceiveMessageLength: number;
  private maxSendMessageLength: number;

  constructor(
    channelOptions: ChannelOptions,
    private sharedFilterConfig: SharedCompressionFilterConfig
  ) {
    super();

    const compressionAlgorithmKey =
      channelOptions['grpc.default_compression_algorithm'];
    this.maxReceiveMessageLength = channelOptions['grpc.max_receive_message_length'] ?? DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
    this.maxSendMessageLength = channelOptions['grpc.max_send_message_length'] ?? DEFAULT_MAX_SEND_MESSAGE_LENGTH;
    if (compressionAlgorithmKey !== undefined) {
      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
        const clientSelectedEncoding = CompressionAlgorithms[
          compressionAlgorithmKey
        ] as CompressionAlgorithm;
        const serverSupportedEncodings =
          sharedFilterConfig.serverSupportedEncodingHeader?.split(',');
        /**
         * There are two possible situations here:
         * 1) We don't have any info yet from the server about what compression it supports
         *    In that case we should just use what the client tells us to use
         * 2) We've previously received a response from the server including a grpc-accept-encoding header
         *    In that case we only want to use the encoding chosen by the client if the server supports it
         */
        if (
          !serverSupportedEncodings ||
          serverSupportedEncodings.includes(clientSelectedEncoding)
        ) {
          this.currentCompressionAlgorithm = clientSelectedEncoding;
          this.sendCompression = getCompressionHandler(
            this.currentCompressionAlgorithm,
            -1
          );
        }
      } else {
        logging.log(
          LogVerbosity.ERROR,
          `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`
        );
      }
    }
  }

  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {
    const headers: Metadata = await metadata;
    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
    headers.set('accept-encoding', 'identity');

    // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
    if (this.currentCompressionAlgorithm === 'identity') {
      headers.remove('grpc-encoding');
    } else {
      headers.set('grpc-encoding', this.currentCompressionAlgorithm);
    }

    return headers;
  }

  receiveMetadata(metadata: Metadata): Metadata {
    const receiveEncoding: MetadataValue[] = metadata.get('grpc-encoding');
    if (receiveEncoding.length > 0) {
      const encoding: MetadataValue = receiveEncoding[0];
      if (typeof encoding === 'string') {
        this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
      }
    }
    metadata.remove('grpc-encoding');

    /* Check to see if the compression we're using to send messages is supported by the server
     * If not, reset the sendCompression filter and have it use the default IdentityHandler */
    const serverSupportedEncodingsHeader = metadata.get(
      'grpc-accept-encoding'
    )[0] as string | undefined;
    if (serverSupportedEncodingsHeader) {
      this.sharedFilterConfig.serverSupportedEncodingHeader =
        serverSupportedEncodingsHeader;
      const serverSupportedEncodings =
        serverSupportedEncodingsHeader.split(',');

      if (
        !serverSupportedEncodings.includes(this.currentCompressionAlgorithm)
      ) {
        this.sendCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = 'identity';
      }
    }
    metadata.remove('grpc-accept-encoding');
    return metadata;
  }

  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {
    /* This filter is special. The input message is the bare message bytes,
     * and the output is a framed and possibly compressed message. For this
     * reason, this filter should be at the bottom of the filter stack */
    const resolvedMessage: WriteObject = await message;
    if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
      throw {
        code: Status.RESOURCE_EXHAUSTED,
        details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
      };
    }
    let compress: boolean;
    if (this.sendCompression instanceof IdentityHandler) {
      compress = false;
    } else {
      compress = ((resolvedMessage.flags ?? 0) & WriteFlags.NoCompress) === 0;
    }

    return {
      message: await this.sendCompression.writeMessage(
        resolvedMessage.message,
        compress
      ),
      flags: resolvedMessage.flags,
    };
  }

  async receiveMessage(message: Promise<Buffer>) {
    /* This filter is also special. The input message is framed and possibly
     * compressed, and the output message is deframed and uncompressed. So
     * this is another reason that this filter should be at the bottom of the
     * filter stack. */
    return this.receiveCompression.readMessage(await message);
  }
}

export class CompressionFilterFactory
  implements FilterFactory<CompressionFilter>
{
  private sharedFilterConfig: SharedCompressionFilterConfig = {};
  constructor(channel: Channel, private readonly options: ChannelOptions) {}
  createFilter(): CompressionFilter {
    return new CompressionFilter(this.options, this.sharedFilterConfig);
  }
}
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export enum ConnectivityState {
  IDLE,
  CONNECTING,
  READY,
  TRANSIENT_FAILURE,
  SHUTDOWN,
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export enum Status {
  OK = 0,
  CANCELLED,
  UNKNOWN,
  INVALID_ARGUMENT,
  DEADLINE_EXCEEDED,
  NOT_FOUND,
  ALREADY_EXISTS,
  PERMISSION_DENIED,
  RESOURCE_EXHAUSTED,
  FAILED_PRECONDITION,
  ABORTED,
  OUT_OF_RANGE,
  UNIMPLEMENTED,
  INTERNAL,
  UNAVAILABLE,
  DATA_LOSS,
  UNAUTHENTICATED,
}

export enum LogVerbosity {
  DEBUG = 0,
  INFO,
  ERROR,
  NONE,
}

/**
 * NOTE: This enum is not currently used in any implemented API in this
 * library. It is included only for type parity with the other implementation.
 */
export enum Propagate {
  DEADLINE = 1,
  CENSUS_STATS_CONTEXT = 2,
  CENSUS_TRACING_CONTEXT = 4,
  CANCELLATION = 8,
  // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43
  DEFAULTS = 0xffff |
    Propagate.DEADLINE |
    Propagate.CENSUS_STATS_CONTEXT |
    Propagate.CENSUS_TRACING_CONTEXT |
    Propagate.CANCELLATION,
}

// -1 means unlimited
export const DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;

// 4 MB default
export const DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { Status } from './constants';

const INAPPROPRIATE_CONTROL_PLANE_CODES: Status[] = [
  Status.OK,
  Status.INVALID_ARGUMENT,
  Status.NOT_FOUND,
  Status.ALREADY_EXISTS,
  Status.FAILED_PRECONDITION,
  Status.ABORTED,
  Status.OUT_OF_RANGE,
  Status.DATA_LOSS,
];

export function restrictControlPlaneStatusCode(
  code: Status,
  details: string
): { code: Status; details: string } {
  if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
    return {
      code: Status.INTERNAL,
      details: `Invalid status from control plane: ${code} ${Status[code]} ${details}`,
    };
  } else {
    return { code, details };
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export type Deadline = Date | number;

export function minDeadline(...deadlineList: Deadline[]): Deadline {
  let minValue = Infinity;
  for (const deadline of deadlineList) {
    const deadlineMsecs =
      deadline instanceof Date ? deadline.getTime() : deadline;
    if (deadlineMsecs < minValue) {
      minValue = deadlineMsecs;
    }
  }
  return minValue;
}

const units: Array<[string, number]> = [
  ['m', 1],
  ['S', 1000],
  ['M', 60 * 1000],
  ['H', 60 * 60 * 1000],
];

export function getDeadlineTimeoutString(deadline: Deadline) {
  const now = new Date().getTime();
  if (deadline instanceof Date) {
    deadline = deadline.getTime();
  }
  const timeoutMs = Math.max(deadline - now, 0);
  for (const [unit, factor] of units) {
    const amount = timeoutMs / factor;
    if (amount < 1e8) {
      return String(Math.ceil(amount)) + unit;
    }
  }
  throw new Error('Deadline is too far in the future');
}

/**
 * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args
 * In particular, "When delay is larger than 2147483647 or less than 1, the
 * delay will be set to 1. Non-integer delays are truncated to an integer."
 * This number of milliseconds is almost 25 days.
 */
const MAX_TIMEOUT_TIME = 2147483647;

/**
 * Get the timeout value that should be passed to setTimeout now for the timer
 * to end at the deadline. For any deadline before now, the timer should end
 * immediately, represented by a value of 0. For any deadline more than
 * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will
 * end at that time, so it is treated as infinitely far in the future.
 * @param deadline
 * @returns
 */
export function getRelativeTimeout(deadline: Deadline) {
  const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
  const now = new Date().getTime();
  const timeout = deadlineMs - now;
  if (timeout < 0) {
    return 0;
  } else if (timeout > MAX_TIMEOUT_TIME) {
    return Infinity;
  } else {
    return timeout;
  }
}

export function deadlineToString(deadline: Deadline): string {
  if (deadline instanceof Date) {
    return deadline.toISOString();
  } else {
    const dateDeadline = new Date(deadline);
    if (Number.isNaN(dateDeadline.getTime())) {
      return '' + deadline;
    } else {
      return dateDeadline.toISOString();
    }
  }
}

/**
 * Calculate the difference between two dates as a number of seconds and format
 * it as a string.
 * @param startDate
 * @param endDate
 * @returns
 */
export function formatDateDifference(startDate: Date, endDate: Date): string {
  return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export interface Duration {
  seconds: number;
  nanos: number;
}

export function msToDuration(millis: number): Duration {
  return {
    seconds: (millis / 1000) | 0,
    nanos: ((millis % 1000) * 1_000_000) | 0,
  };
}

export function durationToMs(duration: Duration): number {
  return (duration.seconds * 1000 + duration.nanos / 1_000_000) | 0;
}

export function isDuration(value: any): value is Duration {
  return typeof value.seconds === 'number' && typeof value.nanos === 'number';
}
/*
 * Copyright 2024 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export const GRPC_NODE_USE_ALTERNATIVE_RESOLVER =
  (process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER ?? 'false') === 'true';
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  } else {
    return String(error);
  }
}

export function getErrorCode(error: unknown): number | null {
  if (
    typeof error === 'object' &&
    error !== null &&
    'code' in error &&
    typeof (error as Record<string, unknown>).code === 'number'
  ) {
    return (error as Record<string, number>).code;
  } else {
    return null;
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export interface EmitterAugmentation1<Name extends string | symbol, Arg> {
  addListener(event: Name, listener: (arg1: Arg) => void): this;
  emit(event: Name, arg1: Arg): boolean;
  on(event: Name, listener: (arg1: Arg) => void): this;
  once(event: Name, listener: (arg1: Arg) => void): this;
  prependListener(event: Name, listener: (arg1: Arg) => void): this;
  prependOnceListener(event: Name, listener: (arg1: Arg) => void): this;
  removeListener(event: Name, listener: (arg1: Arg) => void): this;
}
export { trace, log } from './logging';
export {
  Resolver,
  ResolverListener,
  registerResolver,
  ConfigSelector,
  createResolver,
} from './resolver';
export { GrpcUri, uriToString, splitHostPort, HostPort } from './uri-parser';
export { Duration, durationToMs } from './duration';
export { BackoffTimeout } from './backoff-timeout';
export {
  LoadBalancer,
  TypedLoadBalancingConfig,
  ChannelControlHelper,
  createChildChannelControlHelper,
  registerLoadBalancerType,
  selectLbConfigFromList,
  parseLoadBalancingConfig,
  isLoadBalancerNameRegistered,
} from './load-balancer';
export { LeafLoadBalancer } from './load-balancer-pick-first';
export {
  SubchannelAddress,
  subchannelAddressToString,
  Endpoint,
  endpointToString,
  endpointHasAddress,
  EndpointMap,
} from './subchannel-address';
export { ChildLoadBalancerHandler } from './load-balancer-child-handler';
export {
  Picker,
  UnavailablePicker,
  QueuePicker,
  PickResult,
  PickArgs,
  PickResultType,
} from './picker';
export { Call as CallStream } from './call-interface';
export { Filter, BaseFilter, FilterFactory } from './filter';
export { FilterStackFactory } from './filter-stack';
export { registerAdminService } from './admin';
export {
  SubchannelInterface,
  BaseSubchannelWrapper,
  ConnectivityStateListener,
  HealthListener,
} from './subchannel-interface';
export {
  OutlierDetectionRawConfig,
  SuccessRateEjectionConfig,
  FailurePercentageEjectionConfig,
} from './load-balancer-outlier-detection';

export { createServerCredentialsWithInterceptors } from './server-credentials';
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { StatusObject, WriteObject } from './call-interface';
import { Filter, FilterFactory } from './filter';
import { Metadata } from './metadata';

export class FilterStack implements Filter {
  constructor(private readonly filters: Filter[]) {}

  sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {
    let result: Promise<Metadata> = metadata;

    for (let i = 0; i < this.filters.length; i++) {
      result = this.filters[i].sendMetadata(result);
    }

    return result;
  }

  receiveMetadata(metadata: Metadata) {
    let result: Metadata = metadata;

    for (let i = this.filters.length - 1; i >= 0; i--) {
      result = this.filters[i].receiveMetadata(result);
    }

    return result;
  }

  sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {
    let result: Promise<WriteObject> = message;

    for (let i = 0; i < this.filters.length; i++) {
      result = this.filters[i].sendMessage(result);
    }

    return result;
  }

  receiveMessage(message: Promise<Buffer>): Promise<Buffer> {
    let result: Promise<Buffer> = message;

    for (let i = this.filters.length - 1; i >= 0; i--) {
      result = this.filters[i].receiveMessage(result);
    }

    return result;
  }

  receiveTrailers(status: StatusObject): StatusObject {
    let result: StatusObject = status;

    for (let i = this.filters.length - 1; i >= 0; i--) {
      result = this.filters[i].receiveTrailers(result);
    }

    return result;
  }

  push(filters: Filter[]) {
    this.filters.unshift(...filters);
  }

  getFilters(): Filter[] {
    return this.filters;
  }
}

export class FilterStackFactory implements FilterFactory<FilterStack> {
  constructor(private readonly factories: Array<FilterFactory<Filter>>) {}

  push(filterFactories: FilterFactory<Filter>[]) {
    this.factories.unshift(...filterFactories);
  }

  clone(): FilterStackFactory {
    return new FilterStackFactory([...this.factories]);
  }

  createFilter(): FilterStack {
    return new FilterStack(
      this.factories.map(factory => factory.createFilter())
    );
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { StatusObject, WriteObject } from './call-interface';
import { Metadata } from './metadata';

/**
 * Filter classes represent related per-call logic and state that is primarily
 * used to modify incoming and outgoing data. All async filters can be
 * rejected. The rejection error must be a StatusObject, and a rejection will
 * cause the call to end with that status.
 */
export interface Filter {
  sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;

  receiveMetadata(metadata: Metadata): Metadata;

  sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;

  receiveMessage(message: Promise<Buffer>): Promise<Buffer>;

  receiveTrailers(status: StatusObject): StatusObject;
}

export abstract class BaseFilter implements Filter {
  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {
    return metadata;
  }

  receiveMetadata(metadata: Metadata): Metadata {
    return metadata;
  }

  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {
    return message;
  }

  async receiveMessage(message: Promise<Buffer>): Promise<Buffer> {
    return message;
  }

  receiveTrailers(status: StatusObject): StatusObject {
    return status;
  }
}

export interface FilterFactory<T extends Filter> {
  createFilter(): T;
}
import type * as grpc from '../index';
import type { MessageTypeDefinition } from '@postman/proto-loader';

import type { ChannelzClient as _grpc_channelz_v1_ChannelzClient, ChannelzDefinition as _grpc_channelz_v1_ChannelzDefinition } from './grpc/channelz/v1/Channelz';

type SubtypeConstructor<Constructor extends new (...args: any) => any, Subtype> = {
  new(...args: ConstructorParameters<Constructor>): Subtype;
};

export interface ProtoGrpcType {
  google: {
    protobuf: {
      Any: MessageTypeDefinition
      BoolValue: MessageTypeDefinition
      BytesValue: MessageTypeDefinition
      DoubleValue: MessageTypeDefinition
      Duration: MessageTypeDefinition
      FloatValue: MessageTypeDefinition
      Int32Value: MessageTypeDefinition
      Int64Value: MessageTypeDefinition
      StringValue: MessageTypeDefinition
      Timestamp: MessageTypeDefinition
      UInt32Value: MessageTypeDefinition
      UInt64Value: MessageTypeDefinition
    }
  }
  grpc: {
    channelz: {
      v1: {
        Address: MessageTypeDefinition
        Channel: MessageTypeDefinition
        ChannelConnectivityState: MessageTypeDefinition
        ChannelData: MessageTypeDefinition
        ChannelRef: MessageTypeDefinition
        ChannelTrace: MessageTypeDefinition
        ChannelTraceEvent: MessageTypeDefinition
        /**
         * Channelz is a service exposed by gRPC servers that provides detailed debug
         * information.
         */
        Channelz: SubtypeConstructor<typeof grpc.Client, _grpc_channelz_v1_ChannelzClient> & { service: _grpc_channelz_v1_ChannelzDefinition }
        GetChannelRequest: MessageTypeDefinition
        GetChannelResponse: MessageTypeDefinition
        GetServerRequest: MessageTypeDefinition
        GetServerResponse: MessageTypeDefinition
        GetServerSocketsRequest: MessageTypeDefinition
        GetServerSocketsResponse: MessageTypeDefinition
        GetServersRequest: MessageTypeDefinition
        GetServersResponse: MessageTypeDefinition
        GetSocketRequest: MessageTypeDefinition
        GetSocketResponse: MessageTypeDefinition
        GetSubchannelRequest: MessageTypeDefinition
        GetSubchannelResponse: MessageTypeDefinition
        GetTopChannelsRequest: MessageTypeDefinition
        GetTopChannelsResponse: MessageTypeDefinition
        Security: MessageTypeDefinition
        Server: MessageTypeDefinition
        ServerData: MessageTypeDefinition
        ServerRef: MessageTypeDefinition
        Socket: MessageTypeDefinition
        SocketData: MessageTypeDefinition
        SocketOption: MessageTypeDefinition
        SocketOptionLinger: MessageTypeDefinition
        SocketOptionTcpInfo: MessageTypeDefinition
        SocketOptionTimeout: MessageTypeDefinition
        SocketRef: MessageTypeDefinition
        Subchannel: MessageTypeDefinition
        SubchannelRef: MessageTypeDefinition
      }
    }
  }
}

// Original file: null

import type { AnyExtension } from '@postman/proto-loader';

export type Any = AnyExtension | {
  type_url: string;
  value: Buffer | Uint8Array | string;
}

export interface Any__Output {
  'type_url': (string);
  'value': (Buffer);
}
// Original file: null


export interface BoolValue {
  'value'?: (boolean);
}

export interface BoolValue__Output {
  'value': (boolean);
}
// Original file: null


export interface BytesValue {
  'value'?: (Buffer | Uint8Array | string);
}

export interface BytesValue__Output {
  'value': (Buffer);
}
// Original file: null


export interface DoubleValue {
  'value'?: (number | string);
}

export interface DoubleValue__Output {
  'value': (number);
}
// Original file: null

import type { Long } from '@postman/proto-loader';

export interface Duration {
  'seconds'?: (number | string | Long);
  'nanos'?: (number);
}

export interface Duration__Output {
  'seconds': (string);
  'nanos': (number);
}
// Original file: null


export interface FloatValue {
  'value'?: (number | string);
}

export interface FloatValue__Output {
  'value': (number);
}
// Original file: null


export interface Int32Value {
  'value'?: (number);
}

export interface Int32Value__Output {
  'value': (number);
}
// Original file: null

import type { Long } from '@postman/proto-loader';

export interface Int64Value {
  'value'?: (number | string | Long);
}

export interface Int64Value__Output {
  'value': (string);
}
// Original file: null


export interface StringValue {
  'value'?: (string);
}

export interface StringValue__Output {
  'value': (string);
}
// Original file: null

import type { Long } from '@postman/proto-loader';

export interface Timestamp {
  'seconds'?: (number | string | Long);
  'nanos'?: (number);
}

export interface Timestamp__Output {
  'seconds': (string);
  'nanos': (number);
}
// Original file: null


export interface UInt32Value {
  'value'?: (number);
}

export interface UInt32Value__Output {
  'value': (number);
}
// Original file: null

import type { Long } from '@postman/proto-loader';

export interface UInt64Value {
  'value'?: (number | string | Long);
}

export interface UInt64Value__Output {
  'value': (string);
}
// Original file: proto/channelz.proto

import type { Any as _google_protobuf_Any, Any__Output as _google_protobuf_Any__Output } from '../../../google/protobuf/Any';

/**
 * An address type not included above.
 */
export interface _grpc_channelz_v1_Address_OtherAddress {
  /**
   * The human readable version of the value.  This value should be set.
   */
  'name'?: (string);
  /**
   * The actual address message.
   */
  'value'?: (_google_protobuf_Any | null);
}

/**
 * An address type not included above.
 */
export interface _grpc_channelz_v1_Address_OtherAddress__Output {
  /**
   * The human readable version of the value.  This value should be set.
   */
  'name': (string);
  /**
   * The actual address message.
   */
  'value': (_google_protobuf_Any__Output | null);
}

export interface _grpc_channelz_v1_Address_TcpIpAddress {
  /**
   * Either the IPv4 or IPv6 address in bytes.  Will be either 4 bytes or 16
   * bytes in length.
   */
  'ip_address'?: (Buffer | Uint8Array | string);
  /**
   * 0-64k, or -1 if not appropriate.
   */
  'port'?: (number);
}

export interface _grpc_channelz_v1_Address_TcpIpAddress__Output {
  /**
   * Either the IPv4 or IPv6 address in bytes.  Will be either 4 bytes or 16
   * bytes in length.
   */
  'ip_address': (Buffer);
  /**
   * 0-64k, or -1 if not appropriate.
   */
  'port': (number);
}

/**
 * A Unix Domain Socket address.
 */
export interface _grpc_channelz_v1_Address_UdsAddress {
  'filename'?: (string);
}

/**
 * A Unix Domain Socket address.
 */
export interface _grpc_channelz_v1_Address_UdsAddress__Output {
  'filename': (string);
}

/**
 * Address represents the address used to create the socket.
 */
export interface Address {
  'tcpip_address'?: (_grpc_channelz_v1_Address_TcpIpAddress | null);
  'uds_address'?: (_grpc_channelz_v1_Address_UdsAddress | null);
  'other_address'?: (_grpc_channelz_v1_Address_OtherAddress | null);
  'address'?: "tcpip_address"|"uds_address"|"other_address";
}

/**
 * Address represents the address used to create the socket.
 */
export interface Address__Output {
  'tcpip_address'?: (_grpc_channelz_v1_Address_TcpIpAddress__Output | null);
  'uds_address'?: (_grpc_channelz_v1_Address_UdsAddress__Output | null);
  'other_address'?: (_grpc_channelz_v1_Address_OtherAddress__Output | null);
  'address': "tcpip_address"|"uds_address"|"other_address";
}
// Original file: proto/channelz.proto

import type { ChannelRef as _grpc_channelz_v1_ChannelRef, ChannelRef__Output as _grpc_channelz_v1_ChannelRef__Output } from '../../../grpc/channelz/v1/ChannelRef';
import type { ChannelData as _grpc_channelz_v1_ChannelData, ChannelData__Output as _grpc_channelz_v1_ChannelData__Output } from '../../../grpc/channelz/v1/ChannelData';
import type { SubchannelRef as _grpc_channelz_v1_SubchannelRef, SubchannelRef__Output as _grpc_channelz_v1_SubchannelRef__Output } from '../../../grpc/channelz/v1/SubchannelRef';
import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';

/**
 * Channel is a logical grouping of channels, subchannels, and sockets.
 */
export interface Channel {
  /**
   * The identifier for this channel. This should bet set.
   */
  'ref'?: (_grpc_channelz_v1_ChannelRef | null);
  /**
   * Data specific to this channel.
   */
  'data'?: (_grpc_channelz_v1_ChannelData | null);
  /**
   * There are no ordering guarantees on the order of channel refs.
   * There may not be cycles in the ref graph.
   * A channel ref may be present in more than one channel or subchannel.
   */
  'channel_ref'?: (_grpc_channelz_v1_ChannelRef)[];
  /**
   * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
   * There are no ordering guarantees on the order of subchannel refs.
   * There may not be cycles in the ref graph.
   * A sub channel ref may be present in more than one channel or subchannel.
   */
  'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef)[];
  /**
   * There are no ordering guarantees on the order of sockets.
   */
  'socket_ref'?: (_grpc_channelz_v1_SocketRef)[];
}

/**
 * Channel is a logical grouping of channels, subchannels, and sockets.
 */
export interface Channel__Output {
  /**
   * The identifier for this channel. This should bet set.
   */
  'ref': (_grpc_channelz_v1_ChannelRef__Output | null);
  /**
   * Data specific to this channel.
   */
  'data': (_grpc_channelz_v1_ChannelData__Output | null);
  /**
   * There are no ordering guarantees on the order of channel refs.
   * There may not be cycles in the ref graph.
   * A channel ref may be present in more than one channel or subchannel.
   */
  'channel_ref': (_grpc_channelz_v1_ChannelRef__Output)[];
  /**
   * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
   * There are no ordering guarantees on the order of subchannel refs.
   * There may not be cycles in the ref graph.
   * A sub channel ref may be present in more than one channel or subchannel.
   */
  'subchannel_ref': (_grpc_channelz_v1_SubchannelRef__Output)[];
  /**
   * There are no ordering guarantees on the order of sockets.
   */
  'socket_ref': (_grpc_channelz_v1_SocketRef__Output)[];
}
// Original file: proto/channelz.proto


// Original file: proto/channelz.proto

export const _grpc_channelz_v1_ChannelConnectivityState_State = {
  UNKNOWN: 'UNKNOWN',
  IDLE: 'IDLE',
  CONNECTING: 'CONNECTING',
  READY: 'READY',
  TRANSIENT_FAILURE: 'TRANSIENT_FAILURE',
  SHUTDOWN: 'SHUTDOWN',
} as const;

export type _grpc_channelz_v1_ChannelConnectivityState_State =
  | 'UNKNOWN'
  | 0
  | 'IDLE'
  | 1
  | 'CONNECTING'
  | 2
  | 'READY'
  | 3
  | 'TRANSIENT_FAILURE'
  | 4
  | 'SHUTDOWN'
  | 5

export type _grpc_channelz_v1_ChannelConnectivityState_State__Output = typeof _grpc_channelz_v1_ChannelConnectivityState_State[keyof typeof _grpc_channelz_v1_ChannelConnectivityState_State]

/**
 * These come from the specified states in this document:
 * https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md
 */
export interface ChannelConnectivityState {
  'state'?: (_grpc_channelz_v1_ChannelConnectivityState_State);
}

/**
 * These come from the specified states in this document:
 * https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md
 */
export interface ChannelConnectivityState__Output {
  'state': (_grpc_channelz_v1_ChannelConnectivityState_State__Output);
}
// Original file: proto/channelz.proto

import type { ChannelConnectivityState as _grpc_channelz_v1_ChannelConnectivityState, ChannelConnectivityState__Output as _grpc_channelz_v1_ChannelConnectivityState__Output } from '../../../grpc/channelz/v1/ChannelConnectivityState';
import type { ChannelTrace as _grpc_channelz_v1_ChannelTrace, ChannelTrace__Output as _grpc_channelz_v1_ChannelTrace__Output } from '../../../grpc/channelz/v1/ChannelTrace';
import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { Long } from '@postman/proto-loader';

/**
 * Channel data is data related to a specific Channel or Subchannel.
 */
export interface ChannelData {
  /**
   * The connectivity state of the channel or subchannel.  Implementations
   * should always set this.
   */
  'state'?: (_grpc_channelz_v1_ChannelConnectivityState | null);
  /**
   * The target this channel originally tried to connect to.  May be absent
   */
  'target'?: (string);
  /**
   * A trace of recent events on the channel.  May be absent.
   */
  'trace'?: (_grpc_channelz_v1_ChannelTrace | null);
  /**
   * The number of calls started on the channel
   */
  'calls_started'?: (number | string | Long);
  /**
   * The number of calls that have completed with an OK status
   */
  'calls_succeeded'?: (number | string | Long);
  /**
   * The number of calls that have completed with a non-OK status
   */
  'calls_failed'?: (number | string | Long);
  /**
   * The last time a call was started on the channel.
   */
  'last_call_started_timestamp'?: (_google_protobuf_Timestamp | null);
}

/**
 * Channel data is data related to a specific Channel or Subchannel.
 */
export interface ChannelData__Output {
  /**
   * The connectivity state of the channel or subchannel.  Implementations
   * should always set this.
   */
  'state': (_grpc_channelz_v1_ChannelConnectivityState__Output | null);
  /**
   * The target this channel originally tried to connect to.  May be absent
   */
  'target': (string);
  /**
   * A trace of recent events on the channel.  May be absent.
   */
  'trace': (_grpc_channelz_v1_ChannelTrace__Output | null);
  /**
   * The number of calls started on the channel
   */
  'calls_started': (string);
  /**
   * The number of calls that have completed with an OK status
   */
  'calls_succeeded': (string);
  /**
   * The number of calls that have completed with a non-OK status
   */
  'calls_failed': (string);
  /**
   * The last time a call was started on the channel.
   */
  'last_call_started_timestamp': (_google_protobuf_Timestamp__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

/**
 * ChannelRef is a reference to a Channel.
 */
export interface ChannelRef {
  /**
   * The globally unique id for this channel.  Must be a positive number.
   */
  'channel_id'?: (number | string | Long);
  /**
   * An optional name associated with the channel.
   */
  'name'?: (string);
}

/**
 * ChannelRef is a reference to a Channel.
 */
export interface ChannelRef__Output {
  /**
   * The globally unique id for this channel.  Must be a positive number.
   */
  'channel_id': (string);
  /**
   * An optional name associated with the channel.
   */
  'name': (string);
}
// Original file: proto/channelz.proto

import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { ChannelTraceEvent as _grpc_channelz_v1_ChannelTraceEvent, ChannelTraceEvent__Output as _grpc_channelz_v1_ChannelTraceEvent__Output } from '../../../grpc/channelz/v1/ChannelTraceEvent';
import type { Long } from '@postman/proto-loader';

/**
 * ChannelTrace represents the recent events that have occurred on the channel.
 */
export interface ChannelTrace {
  /**
   * Number of events ever logged in this tracing object. This can differ from
   * events.size() because events can be overwritten or garbage collected by
   * implementations.
   */
  'num_events_logged'?: (number | string | Long);
  /**
   * Time that this channel was created.
   */
  'creation_timestamp'?: (_google_protobuf_Timestamp | null);
  /**
   * List of events that have occurred on this channel.
   */
  'events'?: (_grpc_channelz_v1_ChannelTraceEvent)[];
}

/**
 * ChannelTrace represents the recent events that have occurred on the channel.
 */
export interface ChannelTrace__Output {
  /**
   * Number of events ever logged in this tracing object. This can differ from
   * events.size() because events can be overwritten or garbage collected by
   * implementations.
   */
  'num_events_logged': (string);
  /**
   * Time that this channel was created.
   */
  'creation_timestamp': (_google_protobuf_Timestamp__Output | null);
  /**
   * List of events that have occurred on this channel.
   */
  'events': (_grpc_channelz_v1_ChannelTraceEvent__Output)[];
}
// Original file: proto/channelz.proto

import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { ChannelRef as _grpc_channelz_v1_ChannelRef, ChannelRef__Output as _grpc_channelz_v1_ChannelRef__Output } from '../../../grpc/channelz/v1/ChannelRef';
import type { SubchannelRef as _grpc_channelz_v1_SubchannelRef, SubchannelRef__Output as _grpc_channelz_v1_SubchannelRef__Output } from '../../../grpc/channelz/v1/SubchannelRef';

// Original file: proto/channelz.proto

/**
 * The supported severity levels of trace events.
 */
export const _grpc_channelz_v1_ChannelTraceEvent_Severity = {
  CT_UNKNOWN: 'CT_UNKNOWN',
  CT_INFO: 'CT_INFO',
  CT_WARNING: 'CT_WARNING',
  CT_ERROR: 'CT_ERROR',
} as const;

/**
 * The supported severity levels of trace events.
 */
export type _grpc_channelz_v1_ChannelTraceEvent_Severity =
  | 'CT_UNKNOWN'
  | 0
  | 'CT_INFO'
  | 1
  | 'CT_WARNING'
  | 2
  | 'CT_ERROR'
  | 3

/**
 * The supported severity levels of trace events.
 */
export type _grpc_channelz_v1_ChannelTraceEvent_Severity__Output = typeof _grpc_channelz_v1_ChannelTraceEvent_Severity[keyof typeof _grpc_channelz_v1_ChannelTraceEvent_Severity]

/**
 * A trace event is an interesting thing that happened to a channel or
 * subchannel, such as creation, address resolution, subchannel creation, etc.
 */
export interface ChannelTraceEvent {
  /**
   * High level description of the event.
   */
  'description'?: (string);
  /**
   * the severity of the trace event
   */
  'severity'?: (_grpc_channelz_v1_ChannelTraceEvent_Severity);
  /**
   * When this event occurred.
   */
  'timestamp'?: (_google_protobuf_Timestamp | null);
  'channel_ref'?: (_grpc_channelz_v1_ChannelRef | null);
  'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef | null);
  /**
   * ref of referenced channel or subchannel.
   * Optional, only present if this event refers to a child object. For example,
   * this field would be filled if this trace event was for a subchannel being
   * created.
   */
  'child_ref'?: "channel_ref"|"subchannel_ref";
}

/**
 * A trace event is an interesting thing that happened to a channel or
 * subchannel, such as creation, address resolution, subchannel creation, etc.
 */
export interface ChannelTraceEvent__Output {
  /**
   * High level description of the event.
   */
  'description': (string);
  /**
   * the severity of the trace event
   */
  'severity': (_grpc_channelz_v1_ChannelTraceEvent_Severity__Output);
  /**
   * When this event occurred.
   */
  'timestamp': (_google_protobuf_Timestamp__Output | null);
  'channel_ref'?: (_grpc_channelz_v1_ChannelRef__Output | null);
  'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef__Output | null);
  /**
   * ref of referenced channel or subchannel.
   * Optional, only present if this event refers to a child object. For example,
   * this field would be filled if this trace event was for a subchannel being
   * created.
   */
  'child_ref': "channel_ref"|"subchannel_ref";
}
// Original file: proto/channelz.proto

import type * as grpc from '../../../../index'
import type { MethodDefinition } from '@postman/proto-loader'
import type { GetChannelRequest as _grpc_channelz_v1_GetChannelRequest, GetChannelRequest__Output as _grpc_channelz_v1_GetChannelRequest__Output } from '../../../grpc/channelz/v1/GetChannelRequest';
import type { GetChannelResponse as _grpc_channelz_v1_GetChannelResponse, GetChannelResponse__Output as _grpc_channelz_v1_GetChannelResponse__Output } from '../../../grpc/channelz/v1/GetChannelResponse';
import type { GetServerRequest as _grpc_channelz_v1_GetServerRequest, GetServerRequest__Output as _grpc_channelz_v1_GetServerRequest__Output } from '../../../grpc/channelz/v1/GetServerRequest';
import type { GetServerResponse as _grpc_channelz_v1_GetServerResponse, GetServerResponse__Output as _grpc_channelz_v1_GetServerResponse__Output } from '../../../grpc/channelz/v1/GetServerResponse';
import type { GetServerSocketsRequest as _grpc_channelz_v1_GetServerSocketsRequest, GetServerSocketsRequest__Output as _grpc_channelz_v1_GetServerSocketsRequest__Output } from '../../../grpc/channelz/v1/GetServerSocketsRequest';
import type { GetServerSocketsResponse as _grpc_channelz_v1_GetServerSocketsResponse, GetServerSocketsResponse__Output as _grpc_channelz_v1_GetServerSocketsResponse__Output } from '../../../grpc/channelz/v1/GetServerSocketsResponse';
import type { GetServersRequest as _grpc_channelz_v1_GetServersRequest, GetServersRequest__Output as _grpc_channelz_v1_GetServersRequest__Output } from '../../../grpc/channelz/v1/GetServersRequest';
import type { GetServersResponse as _grpc_channelz_v1_GetServersResponse, GetServersResponse__Output as _grpc_channelz_v1_GetServersResponse__Output } from '../../../grpc/channelz/v1/GetServersResponse';
import type { GetSocketRequest as _grpc_channelz_v1_GetSocketRequest, GetSocketRequest__Output as _grpc_channelz_v1_GetSocketRequest__Output } from '../../../grpc/channelz/v1/GetSocketRequest';
import type { GetSocketResponse as _grpc_channelz_v1_GetSocketResponse, GetSocketResponse__Output as _grpc_channelz_v1_GetSocketResponse__Output } from '../../../grpc/channelz/v1/GetSocketResponse';
import type { GetSubchannelRequest as _grpc_channelz_v1_GetSubchannelRequest, GetSubchannelRequest__Output as _grpc_channelz_v1_GetSubchannelRequest__Output } from '../../../grpc/channelz/v1/GetSubchannelRequest';
import type { GetSubchannelResponse as _grpc_channelz_v1_GetSubchannelResponse, GetSubchannelResponse__Output as _grpc_channelz_v1_GetSubchannelResponse__Output } from '../../../grpc/channelz/v1/GetSubchannelResponse';
import type { GetTopChannelsRequest as _grpc_channelz_v1_GetTopChannelsRequest, GetTopChannelsRequest__Output as _grpc_channelz_v1_GetTopChannelsRequest__Output } from '../../../grpc/channelz/v1/GetTopChannelsRequest';
import type { GetTopChannelsResponse as _grpc_channelz_v1_GetTopChannelsResponse, GetTopChannelsResponse__Output as _grpc_channelz_v1_GetTopChannelsResponse__Output } from '../../../grpc/channelz/v1/GetTopChannelsResponse';

/**
 * Channelz is a service exposed by gRPC servers that provides detailed debug
 * information.
 */
export interface ChannelzClient extends grpc.Client {
  /**
   * Returns a single Channel, or else a NOT_FOUND code.
   */
  GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
  GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
  GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
  GetChannel(argument: _grpc_channelz_v1_GetChannelRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetChannelResponse__Output>): grpc.ClientUnaryCall;
  
  /**
   * Returns a single Server, or else a NOT_FOUND code.
   */
  GetServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  GetServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  GetServer(argument: _grpc_channelz_v1_GetServerRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  GetServer(argument: _grpc_channelz_v1_GetServerRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  /**
   * Returns a single Server, or else a NOT_FOUND code.
   */
  getServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  getServer(argument: _grpc_channelz_v1_GetServerRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  getServer(argument: _grpc_channelz_v1_GetServerRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  getServer(argument: _grpc_channelz_v1_GetServerRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerResponse__Output>): grpc.ClientUnaryCall;
  
  /**
   * Gets all server sockets that exist in the process.
   */
  GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  GetServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  /**
   * Gets all server sockets that exist in the process.
   */
  getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  getServerSockets(argument: _grpc_channelz_v1_GetServerSocketsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServerSocketsResponse__Output>): grpc.ClientUnaryCall;
  
  /**
   * Gets all servers that exist in the process.
   */
  GetServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  GetServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  GetServers(argument: _grpc_channelz_v1_GetServersRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  GetServers(argument: _grpc_channelz_v1_GetServersRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  /**
   * Gets all servers that exist in the process.
   */
  getServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  getServers(argument: _grpc_channelz_v1_GetServersRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  getServers(argument: _grpc_channelz_v1_GetServersRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  getServers(argument: _grpc_channelz_v1_GetServersRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetServersResponse__Output>): grpc.ClientUnaryCall;
  
  /**
   * Returns a single Socket or else a NOT_FOUND code.
   */
  GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  GetSocket(argument: _grpc_channelz_v1_GetSocketRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  /**
   * Returns a single Socket or else a NOT_FOUND code.
   */
  getSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  getSocket(argument: _grpc_channelz_v1_GetSocketRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  getSocket(argument: _grpc_channelz_v1_GetSocketRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  getSocket(argument: _grpc_channelz_v1_GetSocketRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSocketResponse__Output>): grpc.ClientUnaryCall;
  
  /**
   * Returns a single Subchannel, or else a NOT_FOUND code.
   */
  GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  GetSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  /**
   * Returns a single Subchannel, or else a NOT_FOUND code.
   */
  getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  getSubchannel(argument: _grpc_channelz_v1_GetSubchannelRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetSubchannelResponse__Output>): grpc.ClientUnaryCall;
  
  /**
   * Gets all root channels (i.e. channels the application has directly
   * created). This does not include subchannels nor non-top level channels.
   */
  GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  GetTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  /**
   * Gets all root channels (i.e. channels the application has directly
   * created). This does not include subchannels nor non-top level channels.
   */
  getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, metadata: grpc.Metadata, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, options: grpc.CallOptions, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  getTopChannels(argument: _grpc_channelz_v1_GetTopChannelsRequest, callback: grpc.requestCallback<_grpc_channelz_v1_GetTopChannelsResponse__Output>): grpc.ClientUnaryCall;
  
}

/**
 * Channelz is a service exposed by gRPC servers that provides detailed debug
 * information.
 */
export interface ChannelzHandlers extends grpc.UntypedServiceImplementation {
  /**
   * Returns a single Channel, or else a NOT_FOUND code.
   */
  GetChannel: grpc.handleUnaryCall<_grpc_channelz_v1_GetChannelRequest__Output, _grpc_channelz_v1_GetChannelResponse>;
  
  /**
   * Returns a single Server, or else a NOT_FOUND code.
   */
  GetServer: grpc.handleUnaryCall<_grpc_channelz_v1_GetServerRequest__Output, _grpc_channelz_v1_GetServerResponse>;
  
  /**
   * Gets all server sockets that exist in the process.
   */
  GetServerSockets: grpc.handleUnaryCall<_grpc_channelz_v1_GetServerSocketsRequest__Output, _grpc_channelz_v1_GetServerSocketsResponse>;
  
  /**
   * Gets all servers that exist in the process.
   */
  GetServers: grpc.handleUnaryCall<_grpc_channelz_v1_GetServersRequest__Output, _grpc_channelz_v1_GetServersResponse>;
  
  /**
   * Returns a single Socket or else a NOT_FOUND code.
   */
  GetSocket: grpc.handleUnaryCall<_grpc_channelz_v1_GetSocketRequest__Output, _grpc_channelz_v1_GetSocketResponse>;
  
  /**
   * Returns a single Subchannel, or else a NOT_FOUND code.
   */
  GetSubchannel: grpc.handleUnaryCall<_grpc_channelz_v1_GetSubchannelRequest__Output, _grpc_channelz_v1_GetSubchannelResponse>;
  
  /**
   * Gets all root channels (i.e. channels the application has directly
   * created). This does not include subchannels nor non-top level channels.
   */
  GetTopChannels: grpc.handleUnaryCall<_grpc_channelz_v1_GetTopChannelsRequest__Output, _grpc_channelz_v1_GetTopChannelsResponse>;
  
}

export interface ChannelzDefinition extends grpc.ServiceDefinition {
  GetChannel: MethodDefinition<_grpc_channelz_v1_GetChannelRequest, _grpc_channelz_v1_GetChannelResponse, _grpc_channelz_v1_GetChannelRequest__Output, _grpc_channelz_v1_GetChannelResponse__Output>
  GetServer: MethodDefinition<_grpc_channelz_v1_GetServerRequest, _grpc_channelz_v1_GetServerResponse, _grpc_channelz_v1_GetServerRequest__Output, _grpc_channelz_v1_GetServerResponse__Output>
  GetServerSockets: MethodDefinition<_grpc_channelz_v1_GetServerSocketsRequest, _grpc_channelz_v1_GetServerSocketsResponse, _grpc_channelz_v1_GetServerSocketsRequest__Output, _grpc_channelz_v1_GetServerSocketsResponse__Output>
  GetServers: MethodDefinition<_grpc_channelz_v1_GetServersRequest, _grpc_channelz_v1_GetServersResponse, _grpc_channelz_v1_GetServersRequest__Output, _grpc_channelz_v1_GetServersResponse__Output>
  GetSocket: MethodDefinition<_grpc_channelz_v1_GetSocketRequest, _grpc_channelz_v1_GetSocketResponse, _grpc_channelz_v1_GetSocketRequest__Output, _grpc_channelz_v1_GetSocketResponse__Output>
  GetSubchannel: MethodDefinition<_grpc_channelz_v1_GetSubchannelRequest, _grpc_channelz_v1_GetSubchannelResponse, _grpc_channelz_v1_GetSubchannelRequest__Output, _grpc_channelz_v1_GetSubchannelResponse__Output>
  GetTopChannels: MethodDefinition<_grpc_channelz_v1_GetTopChannelsRequest, _grpc_channelz_v1_GetTopChannelsResponse, _grpc_channelz_v1_GetTopChannelsRequest__Output, _grpc_channelz_v1_GetTopChannelsResponse__Output>
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetChannelRequest {
  /**
   * channel_id is the identifier of the specific channel to get.
   */
  'channel_id'?: (number | string | Long);
}

export interface GetChannelRequest__Output {
  /**
   * channel_id is the identifier of the specific channel to get.
   */
  'channel_id': (string);
}
// Original file: proto/channelz.proto

import type { Channel as _grpc_channelz_v1_Channel, Channel__Output as _grpc_channelz_v1_Channel__Output } from '../../../grpc/channelz/v1/Channel';

export interface GetChannelResponse {
  /**
   * The Channel that corresponds to the requested channel_id.  This field
   * should be set.
   */
  'channel'?: (_grpc_channelz_v1_Channel | null);
}

export interface GetChannelResponse__Output {
  /**
   * The Channel that corresponds to the requested channel_id.  This field
   * should be set.
   */
  'channel': (_grpc_channelz_v1_Channel__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetServerRequest {
  /**
   * server_id is the identifier of the specific server to get.
   */
  'server_id'?: (number | string | Long);
}

export interface GetServerRequest__Output {
  /**
   * server_id is the identifier of the specific server to get.
   */
  'server_id': (string);
}
// Original file: proto/channelz.proto

import type { Server as _grpc_channelz_v1_Server, Server__Output as _grpc_channelz_v1_Server__Output } from '../../../grpc/channelz/v1/Server';

export interface GetServerResponse {
  /**
   * The Server that corresponds to the requested server_id.  This field
   * should be set.
   */
  'server'?: (_grpc_channelz_v1_Server | null);
}

export interface GetServerResponse__Output {
  /**
   * The Server that corresponds to the requested server_id.  This field
   * should be set.
   */
  'server': (_grpc_channelz_v1_Server__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetServerSocketsRequest {
  'server_id'?: (number | string | Long);
  /**
   * start_socket_id indicates that only sockets at or above this id should be
   * included in the results.
   * To request the first page, this must be set to 0. To request
   * subsequent pages, the client generates this value by adding 1 to
   * the highest seen result ID.
   */
  'start_socket_id'?: (number | string | Long);
  /**
   * If non-zero, the server will return a page of results containing
   * at most this many items. If zero, the server will choose a
   * reasonable page size.  Must never be negative.
   */
  'max_results'?: (number | string | Long);
}

export interface GetServerSocketsRequest__Output {
  'server_id': (string);
  /**
   * start_socket_id indicates that only sockets at or above this id should be
   * included in the results.
   * To request the first page, this must be set to 0. To request
   * subsequent pages, the client generates this value by adding 1 to
   * the highest seen result ID.
   */
  'start_socket_id': (string);
  /**
   * If non-zero, the server will return a page of results containing
   * at most this many items. If zero, the server will choose a
   * reasonable page size.  Must never be negative.
   */
  'max_results': (string);
}
// Original file: proto/channelz.proto

import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';

export interface GetServerSocketsResponse {
  /**
   * list of socket refs that the connection detail service knows about.  Sorted in
   * ascending socket_id order.
   * Must contain at least 1 result, otherwise 'end' must be true.
   */
  'socket_ref'?: (_grpc_channelz_v1_SocketRef)[];
  /**
   * If set, indicates that the list of sockets is the final list.  Requesting
   * more sockets will only return more if they are created after this RPC
   * completes.
   */
  'end'?: (boolean);
}

export interface GetServerSocketsResponse__Output {
  /**
   * list of socket refs that the connection detail service knows about.  Sorted in
   * ascending socket_id order.
   * Must contain at least 1 result, otherwise 'end' must be true.
   */
  'socket_ref': (_grpc_channelz_v1_SocketRef__Output)[];
  /**
   * If set, indicates that the list of sockets is the final list.  Requesting
   * more sockets will only return more if they are created after this RPC
   * completes.
   */
  'end': (boolean);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetServersRequest {
  /**
   * start_server_id indicates that only servers at or above this id should be
   * included in the results.
   * To request the first page, this must be set to 0. To request
   * subsequent pages, the client generates this value by adding 1 to
   * the highest seen result ID.
   */
  'start_server_id'?: (number | string | Long);
  /**
   * If non-zero, the server will return a page of results containing
   * at most this many items. If zero, the server will choose a
   * reasonable page size.  Must never be negative.
   */
  'max_results'?: (number | string | Long);
}

export interface GetServersRequest__Output {
  /**
   * start_server_id indicates that only servers at or above this id should be
   * included in the results.
   * To request the first page, this must be set to 0. To request
   * subsequent pages, the client generates this value by adding 1 to
   * the highest seen result ID.
   */
  'start_server_id': (string);
  /**
   * If non-zero, the server will return a page of results containing
   * at most this many items. If zero, the server will choose a
   * reasonable page size.  Must never be negative.
   */
  'max_results': (string);
}
// Original file: proto/channelz.proto

import type { Server as _grpc_channelz_v1_Server, Server__Output as _grpc_channelz_v1_Server__Output } from '../../../grpc/channelz/v1/Server';

export interface GetServersResponse {
  /**
   * list of servers that the connection detail service knows about.  Sorted in
   * ascending server_id order.
   * Must contain at least 1 result, otherwise 'end' must be true.
   */
  'server'?: (_grpc_channelz_v1_Server)[];
  /**
   * If set, indicates that the list of servers is the final list.  Requesting
   * more servers will only return more if they are created after this RPC
   * completes.
   */
  'end'?: (boolean);
}

export interface GetServersResponse__Output {
  /**
   * list of servers that the connection detail service knows about.  Sorted in
   * ascending server_id order.
   * Must contain at least 1 result, otherwise 'end' must be true.
   */
  'server': (_grpc_channelz_v1_Server__Output)[];
  /**
   * If set, indicates that the list of servers is the final list.  Requesting
   * more servers will only return more if they are created after this RPC
   * completes.
   */
  'end': (boolean);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetSocketRequest {
  /**
   * socket_id is the identifier of the specific socket to get.
   */
  'socket_id'?: (number | string | Long);
  /**
   * If true, the response will contain only high level information
   * that is inexpensive to obtain. Fields thay may be omitted are
   * documented.
   */
  'summary'?: (boolean);
}

export interface GetSocketRequest__Output {
  /**
   * socket_id is the identifier of the specific socket to get.
   */
  'socket_id': (string);
  /**
   * If true, the response will contain only high level information
   * that is inexpensive to obtain. Fields thay may be omitted are
   * documented.
   */
  'summary': (boolean);
}
// Original file: proto/channelz.proto

import type { Socket as _grpc_channelz_v1_Socket, Socket__Output as _grpc_channelz_v1_Socket__Output } from '../../../grpc/channelz/v1/Socket';

export interface GetSocketResponse {
  /**
   * The Socket that corresponds to the requested socket_id.  This field
   * should be set.
   */
  'socket'?: (_grpc_channelz_v1_Socket | null);
}

export interface GetSocketResponse__Output {
  /**
   * The Socket that corresponds to the requested socket_id.  This field
   * should be set.
   */
  'socket': (_grpc_channelz_v1_Socket__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetSubchannelRequest {
  /**
   * subchannel_id is the identifier of the specific subchannel to get.
   */
  'subchannel_id'?: (number | string | Long);
}

export interface GetSubchannelRequest__Output {
  /**
   * subchannel_id is the identifier of the specific subchannel to get.
   */
  'subchannel_id': (string);
}
// Original file: proto/channelz.proto

import type { Subchannel as _grpc_channelz_v1_Subchannel, Subchannel__Output as _grpc_channelz_v1_Subchannel__Output } from '../../../grpc/channelz/v1/Subchannel';

export interface GetSubchannelResponse {
  /**
   * The Subchannel that corresponds to the requested subchannel_id.  This
   * field should be set.
   */
  'subchannel'?: (_grpc_channelz_v1_Subchannel | null);
}

export interface GetSubchannelResponse__Output {
  /**
   * The Subchannel that corresponds to the requested subchannel_id.  This
   * field should be set.
   */
  'subchannel': (_grpc_channelz_v1_Subchannel__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

export interface GetTopChannelsRequest {
  /**
   * start_channel_id indicates that only channels at or above this id should be
   * included in the results.
   * To request the first page, this should be set to 0. To request
   * subsequent pages, the client generates this value by adding 1 to
   * the highest seen result ID.
   */
  'start_channel_id'?: (number | string | Long);
  /**
   * If non-zero, the server will return a page of results containing
   * at most this many items. If zero, the server will choose a
   * reasonable page size.  Must never be negative.
   */
  'max_results'?: (number | string | Long);
}

export interface GetTopChannelsRequest__Output {
  /**
   * start_channel_id indicates that only channels at or above this id should be
   * included in the results.
   * To request the first page, this should be set to 0. To request
   * subsequent pages, the client generates this value by adding 1 to
   * the highest seen result ID.
   */
  'start_channel_id': (string);
  /**
   * If non-zero, the server will return a page of results containing
   * at most this many items. If zero, the server will choose a
   * reasonable page size.  Must never be negative.
   */
  'max_results': (string);
}
// Original file: proto/channelz.proto

import type { Channel as _grpc_channelz_v1_Channel, Channel__Output as _grpc_channelz_v1_Channel__Output } from '../../../grpc/channelz/v1/Channel';

export interface GetTopChannelsResponse {
  /**
   * list of channels that the connection detail service knows about.  Sorted in
   * ascending channel_id order.
   * Must contain at least 1 result, otherwise 'end' must be true.
   */
  'channel'?: (_grpc_channelz_v1_Channel)[];
  /**
   * If set, indicates that the list of channels is the final list.  Requesting
   * more channels can only return more if they are created after this RPC
   * completes.
   */
  'end'?: (boolean);
}

export interface GetTopChannelsResponse__Output {
  /**
   * list of channels that the connection detail service knows about.  Sorted in
   * ascending channel_id order.
   * Must contain at least 1 result, otherwise 'end' must be true.
   */
  'channel': (_grpc_channelz_v1_Channel__Output)[];
  /**
   * If set, indicates that the list of channels is the final list.  Requesting
   * more channels can only return more if they are created after this RPC
   * completes.
   */
  'end': (boolean);
}
// Original file: proto/channelz.proto

import type { Any as _google_protobuf_Any, Any__Output as _google_protobuf_Any__Output } from '../../../google/protobuf/Any';

export interface _grpc_channelz_v1_Security_OtherSecurity {
  /**
   * The human readable version of the value.
   */
  'name'?: (string);
  /**
   * The actual security details message.
   */
  'value'?: (_google_protobuf_Any | null);
}

export interface _grpc_channelz_v1_Security_OtherSecurity__Output {
  /**
   * The human readable version of the value.
   */
  'name': (string);
  /**
   * The actual security details message.
   */
  'value': (_google_protobuf_Any__Output | null);
}

export interface _grpc_channelz_v1_Security_Tls {
  /**
   * The cipher suite name in the RFC 4346 format:
   * https://tools.ietf.org/html/rfc4346#appendix-C
   */
  'standard_name'?: (string);
  /**
   * Some other way to describe the cipher suite if
   * the RFC 4346 name is not available.
   */
  'other_name'?: (string);
  /**
   * the certificate used by this endpoint.
   */
  'local_certificate'?: (Buffer | Uint8Array | string);
  /**
   * the certificate used by the remote endpoint.
   */
  'remote_certificate'?: (Buffer | Uint8Array | string);
  'cipher_suite'?: "standard_name"|"other_name";
}

export interface _grpc_channelz_v1_Security_Tls__Output {
  /**
   * The cipher suite name in the RFC 4346 format:
   * https://tools.ietf.org/html/rfc4346#appendix-C
   */
  'standard_name'?: (string);
  /**
   * Some other way to describe the cipher suite if
   * the RFC 4346 name is not available.
   */
  'other_name'?: (string);
  /**
   * the certificate used by this endpoint.
   */
  'local_certificate': (Buffer);
  /**
   * the certificate used by the remote endpoint.
   */
  'remote_certificate': (Buffer);
  'cipher_suite': "standard_name"|"other_name";
}

/**
 * Security represents details about how secure the socket is.
 */
export interface Security {
  'tls'?: (_grpc_channelz_v1_Security_Tls | null);
  'other'?: (_grpc_channelz_v1_Security_OtherSecurity | null);
  'model'?: "tls"|"other";
}

/**
 * Security represents details about how secure the socket is.
 */
export interface Security__Output {
  'tls'?: (_grpc_channelz_v1_Security_Tls__Output | null);
  'other'?: (_grpc_channelz_v1_Security_OtherSecurity__Output | null);
  'model': "tls"|"other";
}
// Original file: proto/channelz.proto

import type { ServerRef as _grpc_channelz_v1_ServerRef, ServerRef__Output as _grpc_channelz_v1_ServerRef__Output } from '../../../grpc/channelz/v1/ServerRef';
import type { ServerData as _grpc_channelz_v1_ServerData, ServerData__Output as _grpc_channelz_v1_ServerData__Output } from '../../../grpc/channelz/v1/ServerData';
import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';

/**
 * Server represents a single server.  There may be multiple servers in a single
 * program.
 */
export interface Server {
  /**
   * The identifier for a Server.  This should be set.
   */
  'ref'?: (_grpc_channelz_v1_ServerRef | null);
  /**
   * The associated data of the Server.
   */
  'data'?: (_grpc_channelz_v1_ServerData | null);
  /**
   * The sockets that the server is listening on.  There are no ordering
   * guarantees.  This may be absent.
   */
  'listen_socket'?: (_grpc_channelz_v1_SocketRef)[];
}

/**
 * Server represents a single server.  There may be multiple servers in a single
 * program.
 */
export interface Server__Output {
  /**
   * The identifier for a Server.  This should be set.
   */
  'ref': (_grpc_channelz_v1_ServerRef__Output | null);
  /**
   * The associated data of the Server.
   */
  'data': (_grpc_channelz_v1_ServerData__Output | null);
  /**
   * The sockets that the server is listening on.  There are no ordering
   * guarantees.  This may be absent.
   */
  'listen_socket': (_grpc_channelz_v1_SocketRef__Output)[];
}
// Original file: proto/channelz.proto

import type { ChannelTrace as _grpc_channelz_v1_ChannelTrace, ChannelTrace__Output as _grpc_channelz_v1_ChannelTrace__Output } from '../../../grpc/channelz/v1/ChannelTrace';
import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { Long } from '@postman/proto-loader';

/**
 * ServerData is data for a specific Server.
 */
export interface ServerData {
  /**
   * A trace of recent events on the server.  May be absent.
   */
  'trace'?: (_grpc_channelz_v1_ChannelTrace | null);
  /**
   * The number of incoming calls started on the server
   */
  'calls_started'?: (number | string | Long);
  /**
   * The number of incoming calls that have completed with an OK status
   */
  'calls_succeeded'?: (number | string | Long);
  /**
   * The number of incoming calls that have a completed with a non-OK status
   */
  'calls_failed'?: (number | string | Long);
  /**
   * The last time a call was started on the server.
   */
  'last_call_started_timestamp'?: (_google_protobuf_Timestamp | null);
}

/**
 * ServerData is data for a specific Server.
 */
export interface ServerData__Output {
  /**
   * A trace of recent events on the server.  May be absent.
   */
  'trace': (_grpc_channelz_v1_ChannelTrace__Output | null);
  /**
   * The number of incoming calls started on the server
   */
  'calls_started': (string);
  /**
   * The number of incoming calls that have completed with an OK status
   */
  'calls_succeeded': (string);
  /**
   * The number of incoming calls that have a completed with a non-OK status
   */
  'calls_failed': (string);
  /**
   * The last time a call was started on the server.
   */
  'last_call_started_timestamp': (_google_protobuf_Timestamp__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

/**
 * ServerRef is a reference to a Server.
 */
export interface ServerRef {
  /**
   * A globally unique identifier for this server.  Must be a positive number.
   */
  'server_id'?: (number | string | Long);
  /**
   * An optional name associated with the server.
   */
  'name'?: (string);
}

/**
 * ServerRef is a reference to a Server.
 */
export interface ServerRef__Output {
  /**
   * A globally unique identifier for this server.  Must be a positive number.
   */
  'server_id': (string);
  /**
   * An optional name associated with the server.
   */
  'name': (string);
}
// Original file: proto/channelz.proto

import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';
import type { SocketData as _grpc_channelz_v1_SocketData, SocketData__Output as _grpc_channelz_v1_SocketData__Output } from '../../../grpc/channelz/v1/SocketData';
import type { Address as _grpc_channelz_v1_Address, Address__Output as _grpc_channelz_v1_Address__Output } from '../../../grpc/channelz/v1/Address';
import type { Security as _grpc_channelz_v1_Security, Security__Output as _grpc_channelz_v1_Security__Output } from '../../../grpc/channelz/v1/Security';

/**
 * Information about an actual connection.  Pronounced "sock-ay".
 */
export interface Socket {
  /**
   * The identifier for the Socket.
   */
  'ref'?: (_grpc_channelz_v1_SocketRef | null);
  /**
   * Data specific to this Socket.
   */
  'data'?: (_grpc_channelz_v1_SocketData | null);
  /**
   * The locally bound address.
   */
  'local'?: (_grpc_channelz_v1_Address | null);
  /**
   * The remote bound address.  May be absent.
   */
  'remote'?: (_grpc_channelz_v1_Address | null);
  /**
   * Security details for this socket.  May be absent if not available, or
   * there is no security on the socket.
   */
  'security'?: (_grpc_channelz_v1_Security | null);
  /**
   * Optional, represents the name of the remote endpoint, if different than
   * the original target name.
   */
  'remote_name'?: (string);
}

/**
 * Information about an actual connection.  Pronounced "sock-ay".
 */
export interface Socket__Output {
  /**
   * The identifier for the Socket.
   */
  'ref': (_grpc_channelz_v1_SocketRef__Output | null);
  /**
   * Data specific to this Socket.
   */
  'data': (_grpc_channelz_v1_SocketData__Output | null);
  /**
   * The locally bound address.
   */
  'local': (_grpc_channelz_v1_Address__Output | null);
  /**
   * The remote bound address.  May be absent.
   */
  'remote': (_grpc_channelz_v1_Address__Output | null);
  /**
   * Security details for this socket.  May be absent if not available, or
   * there is no security on the socket.
   */
  'security': (_grpc_channelz_v1_Security__Output | null);
  /**
   * Optional, represents the name of the remote endpoint, if different than
   * the original target name.
   */
  'remote_name': (string);
}
// Original file: proto/channelz.proto

import type { Timestamp as _google_protobuf_Timestamp, Timestamp__Output as _google_protobuf_Timestamp__Output } from '../../../google/protobuf/Timestamp';
import type { Int64Value as _google_protobuf_Int64Value, Int64Value__Output as _google_protobuf_Int64Value__Output } from '../../../google/protobuf/Int64Value';
import type { SocketOption as _grpc_channelz_v1_SocketOption, SocketOption__Output as _grpc_channelz_v1_SocketOption__Output } from '../../../grpc/channelz/v1/SocketOption';
import type { Long } from '@postman/proto-loader';

/**
 * SocketData is data associated for a specific Socket.  The fields present
 * are specific to the implementation, so there may be minor differences in
 * the semantics.  (e.g. flow control windows)
 */
export interface SocketData {
  /**
   * The number of streams that have been started.
   */
  'streams_started'?: (number | string | Long);
  /**
   * The number of streams that have ended successfully:
   * On client side, received frame with eos bit set;
   * On server side, sent frame with eos bit set.
   */
  'streams_succeeded'?: (number | string | Long);
  /**
   * The number of streams that have ended unsuccessfully:
   * On client side, ended without receiving frame with eos bit set;
   * On server side, ended without sending frame with eos bit set.
   */
  'streams_failed'?: (number | string | Long);
  /**
   * The number of grpc messages successfully sent on this socket.
   */
  'messages_sent'?: (number | string | Long);
  /**
   * The number of grpc messages received on this socket.
   */
  'messages_received'?: (number | string | Long);
  /**
   * The number of keep alives sent.  This is typically implemented with HTTP/2
   * ping messages.
   */
  'keep_alives_sent'?: (number | string | Long);
  /**
   * The last time a stream was created by this endpoint.  Usually unset for
   * servers.
   */
  'last_local_stream_created_timestamp'?: (_google_protobuf_Timestamp | null);
  /**
   * The last time a stream was created by the remote endpoint.  Usually unset
   * for clients.
   */
  'last_remote_stream_created_timestamp'?: (_google_protobuf_Timestamp | null);
  /**
   * The last time a message was sent by this endpoint.
   */
  'last_message_sent_timestamp'?: (_google_protobuf_Timestamp | null);
  /**
   * The last time a message was received by this endpoint.
   */
  'last_message_received_timestamp'?: (_google_protobuf_Timestamp | null);
  /**
   * The amount of window, granted to the local endpoint by the remote endpoint.
   * This may be slightly out of date due to network latency.  This does NOT
   * include stream level or TCP level flow control info.
   */
  'local_flow_control_window'?: (_google_protobuf_Int64Value | null);
  /**
   * The amount of window, granted to the remote endpoint by the local endpoint.
   * This may be slightly out of date due to network latency.  This does NOT
   * include stream level or TCP level flow control info.
   */
  'remote_flow_control_window'?: (_google_protobuf_Int64Value | null);
  /**
   * Socket options set on this socket.  May be absent if 'summary' is set
   * on GetSocketRequest.
   */
  'option'?: (_grpc_channelz_v1_SocketOption)[];
}

/**
 * SocketData is data associated for a specific Socket.  The fields present
 * are specific to the implementation, so there may be minor differences in
 * the semantics.  (e.g. flow control windows)
 */
export interface SocketData__Output {
  /**
   * The number of streams that have been started.
   */
  'streams_started': (string);
  /**
   * The number of streams that have ended successfully:
   * On client side, received frame with eos bit set;
   * On server side, sent frame with eos bit set.
   */
  'streams_succeeded': (string);
  /**
   * The number of streams that have ended unsuccessfully:
   * On client side, ended without receiving frame with eos bit set;
   * On server side, ended without sending frame with eos bit set.
   */
  'streams_failed': (string);
  /**
   * The number of grpc messages successfully sent on this socket.
   */
  'messages_sent': (string);
  /**
   * The number of grpc messages received on this socket.
   */
  'messages_received': (string);
  /**
   * The number of keep alives sent.  This is typically implemented with HTTP/2
   * ping messages.
   */
  'keep_alives_sent': (string);
  /**
   * The last time a stream was created by this endpoint.  Usually unset for
   * servers.
   */
  'last_local_stream_created_timestamp': (_google_protobuf_Timestamp__Output | null);
  /**
   * The last time a stream was created by the remote endpoint.  Usually unset
   * for clients.
   */
  'last_remote_stream_created_timestamp': (_google_protobuf_Timestamp__Output | null);
  /**
   * The last time a message was sent by this endpoint.
   */
  'last_message_sent_timestamp': (_google_protobuf_Timestamp__Output | null);
  /**
   * The last time a message was received by this endpoint.
   */
  'last_message_received_timestamp': (_google_protobuf_Timestamp__Output | null);
  /**
   * The amount of window, granted to the local endpoint by the remote endpoint.
   * This may be slightly out of date due to network latency.  This does NOT
   * include stream level or TCP level flow control info.
   */
  'local_flow_control_window': (_google_protobuf_Int64Value__Output | null);
  /**
   * The amount of window, granted to the remote endpoint by the local endpoint.
   * This may be slightly out of date due to network latency.  This does NOT
   * include stream level or TCP level flow control info.
   */
  'remote_flow_control_window': (_google_protobuf_Int64Value__Output | null);
  /**
   * Socket options set on this socket.  May be absent if 'summary' is set
   * on GetSocketRequest.
   */
  'option': (_grpc_channelz_v1_SocketOption__Output)[];
}
// Original file: proto/channelz.proto

import type { Any as _google_protobuf_Any, Any__Output as _google_protobuf_Any__Output } from '../../../google/protobuf/Any';

/**
 * SocketOption represents socket options for a socket.  Specifically, these
 * are the options returned by getsockopt().
 */
export interface SocketOption {
  /**
   * The full name of the socket option.  Typically this will be the upper case
   * name, such as "SO_REUSEPORT".
   */
  'name'?: (string);
  /**
   * The human readable value of this socket option.  At least one of value or
   * additional will be set.
   */
  'value'?: (string);
  /**
   * Additional data associated with the socket option.  At least one of value
   * or additional will be set.
   */
  'additional'?: (_google_protobuf_Any | null);
}

/**
 * SocketOption represents socket options for a socket.  Specifically, these
 * are the options returned by getsockopt().
 */
export interface SocketOption__Output {
  /**
   * The full name of the socket option.  Typically this will be the upper case
   * name, such as "SO_REUSEPORT".
   */
  'name': (string);
  /**
   * The human readable value of this socket option.  At least one of value or
   * additional will be set.
   */
  'value': (string);
  /**
   * Additional data associated with the socket option.  At least one of value
   * or additional will be set.
   */
  'additional': (_google_protobuf_Any__Output | null);
}
// Original file: proto/channelz.proto

import type { Duration as _google_protobuf_Duration, Duration__Output as _google_protobuf_Duration__Output } from '../../../google/protobuf/Duration';

/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_LINGER.
 */
export interface SocketOptionLinger {
  /**
   * active maps to `struct linger.l_onoff`
   */
  'active'?: (boolean);
  /**
   * duration maps to `struct linger.l_linger`
   */
  'duration'?: (_google_protobuf_Duration | null);
}

/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_LINGER.
 */
export interface SocketOptionLinger__Output {
  /**
   * active maps to `struct linger.l_onoff`
   */
  'active': (boolean);
  /**
   * duration maps to `struct linger.l_linger`
   */
  'duration': (_google_protobuf_Duration__Output | null);
}
// Original file: proto/channelz.proto


/**
 * For use with SocketOption's additional field.  Tcp info for
 * SOL_TCP and TCP_INFO.
 */
export interface SocketOptionTcpInfo {
  'tcpi_state'?: (number);
  'tcpi_ca_state'?: (number);
  'tcpi_retransmits'?: (number);
  'tcpi_probes'?: (number);
  'tcpi_backoff'?: (number);
  'tcpi_options'?: (number);
  'tcpi_snd_wscale'?: (number);
  'tcpi_rcv_wscale'?: (number);
  'tcpi_rto'?: (number);
  'tcpi_ato'?: (number);
  'tcpi_snd_mss'?: (number);
  'tcpi_rcv_mss'?: (number);
  'tcpi_unacked'?: (number);
  'tcpi_sacked'?: (number);
  'tcpi_lost'?: (number);
  'tcpi_retrans'?: (number);
  'tcpi_fackets'?: (number);
  'tcpi_last_data_sent'?: (number);
  'tcpi_last_ack_sent'?: (number);
  'tcpi_last_data_recv'?: (number);
  'tcpi_last_ack_recv'?: (number);
  'tcpi_pmtu'?: (number);
  'tcpi_rcv_ssthresh'?: (number);
  'tcpi_rtt'?: (number);
  'tcpi_rttvar'?: (number);
  'tcpi_snd_ssthresh'?: (number);
  'tcpi_snd_cwnd'?: (number);
  'tcpi_advmss'?: (number);
  'tcpi_reordering'?: (number);
}

/**
 * For use with SocketOption's additional field.  Tcp info for
 * SOL_TCP and TCP_INFO.
 */
export interface SocketOptionTcpInfo__Output {
  'tcpi_state': (number);
  'tcpi_ca_state': (number);
  'tcpi_retransmits': (number);
  'tcpi_probes': (number);
  'tcpi_backoff': (number);
  'tcpi_options': (number);
  'tcpi_snd_wscale': (number);
  'tcpi_rcv_wscale': (number);
  'tcpi_rto': (number);
  'tcpi_ato': (number);
  'tcpi_snd_mss': (number);
  'tcpi_rcv_mss': (number);
  'tcpi_unacked': (number);
  'tcpi_sacked': (number);
  'tcpi_lost': (number);
  'tcpi_retrans': (number);
  'tcpi_fackets': (number);
  'tcpi_last_data_sent': (number);
  'tcpi_last_ack_sent': (number);
  'tcpi_last_data_recv': (number);
  'tcpi_last_ack_recv': (number);
  'tcpi_pmtu': (number);
  'tcpi_rcv_ssthresh': (number);
  'tcpi_rtt': (number);
  'tcpi_rttvar': (number);
  'tcpi_snd_ssthresh': (number);
  'tcpi_snd_cwnd': (number);
  'tcpi_advmss': (number);
  'tcpi_reordering': (number);
}
// Original file: proto/channelz.proto

import type { Duration as _google_protobuf_Duration, Duration__Output as _google_protobuf_Duration__Output } from '../../../google/protobuf/Duration';

/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_RCVTIMEO and SO_SNDTIMEO
 */
export interface SocketOptionTimeout {
  'duration'?: (_google_protobuf_Duration | null);
}

/**
 * For use with SocketOption's additional field.  This is primarily used for
 * SO_RCVTIMEO and SO_SNDTIMEO
 */
export interface SocketOptionTimeout__Output {
  'duration': (_google_protobuf_Duration__Output | null);
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

/**
 * SocketRef is a reference to a Socket.
 */
export interface SocketRef {
  /**
   * The globally unique id for this socket.  Must be a positive number.
   */
  'socket_id'?: (number | string | Long);
  /**
   * An optional name associated with the socket.
   */
  'name'?: (string);
}

/**
 * SocketRef is a reference to a Socket.
 */
export interface SocketRef__Output {
  /**
   * The globally unique id for this socket.  Must be a positive number.
   */
  'socket_id': (string);
  /**
   * An optional name associated with the socket.
   */
  'name': (string);
}
// Original file: proto/channelz.proto

import type { SubchannelRef as _grpc_channelz_v1_SubchannelRef, SubchannelRef__Output as _grpc_channelz_v1_SubchannelRef__Output } from '../../../grpc/channelz/v1/SubchannelRef';
import type { ChannelData as _grpc_channelz_v1_ChannelData, ChannelData__Output as _grpc_channelz_v1_ChannelData__Output } from '../../../grpc/channelz/v1/ChannelData';
import type { ChannelRef as _grpc_channelz_v1_ChannelRef, ChannelRef__Output as _grpc_channelz_v1_ChannelRef__Output } from '../../../grpc/channelz/v1/ChannelRef';
import type { SocketRef as _grpc_channelz_v1_SocketRef, SocketRef__Output as _grpc_channelz_v1_SocketRef__Output } from '../../../grpc/channelz/v1/SocketRef';

/**
 * Subchannel is a logical grouping of channels, subchannels, and sockets.
 * A subchannel is load balanced over by it's ancestor
 */
export interface Subchannel {
  /**
   * The identifier for this channel.
   */
  'ref'?: (_grpc_channelz_v1_SubchannelRef | null);
  /**
   * Data specific to this channel.
   */
  'data'?: (_grpc_channelz_v1_ChannelData | null);
  /**
   * There are no ordering guarantees on the order of channel refs.
   * There may not be cycles in the ref graph.
   * A channel ref may be present in more than one channel or subchannel.
   */
  'channel_ref'?: (_grpc_channelz_v1_ChannelRef)[];
  /**
   * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
   * There are no ordering guarantees on the order of subchannel refs.
   * There may not be cycles in the ref graph.
   * A sub channel ref may be present in more than one channel or subchannel.
   */
  'subchannel_ref'?: (_grpc_channelz_v1_SubchannelRef)[];
  /**
   * There are no ordering guarantees on the order of sockets.
   */
  'socket_ref'?: (_grpc_channelz_v1_SocketRef)[];
}

/**
 * Subchannel is a logical grouping of channels, subchannels, and sockets.
 * A subchannel is load balanced over by it's ancestor
 */
export interface Subchannel__Output {
  /**
   * The identifier for this channel.
   */
  'ref': (_grpc_channelz_v1_SubchannelRef__Output | null);
  /**
   * Data specific to this channel.
   */
  'data': (_grpc_channelz_v1_ChannelData__Output | null);
  /**
   * There are no ordering guarantees on the order of channel refs.
   * There may not be cycles in the ref graph.
   * A channel ref may be present in more than one channel or subchannel.
   */
  'channel_ref': (_grpc_channelz_v1_ChannelRef__Output)[];
  /**
   * At most one of 'channel_ref+subchannel_ref' and 'socket' is set.
   * There are no ordering guarantees on the order of subchannel refs.
   * There may not be cycles in the ref graph.
   * A sub channel ref may be present in more than one channel or subchannel.
   */
  'subchannel_ref': (_grpc_channelz_v1_SubchannelRef__Output)[];
  /**
   * There are no ordering guarantees on the order of sockets.
   */
  'socket_ref': (_grpc_channelz_v1_SocketRef__Output)[];
}
// Original file: proto/channelz.proto

import type { Long } from '@postman/proto-loader';

/**
 * SubchannelRef is a reference to a Subchannel.
 */
export interface SubchannelRef {
  /**
   * The globally unique id for this subchannel.  Must be a positive number.
   */
  'subchannel_id'?: (number | string | Long);
  /**
   * An optional name associated with the subchannel.
   */
  'name'?: (string);
}

/**
 * SubchannelRef is a reference to a Subchannel.
 */
export interface SubchannelRef__Output {
  /**
   * The globally unique id for this subchannel.  Must be a positive number.
   */
  'subchannel_id': (string);
  /**
   * An optional name associated with the subchannel.
   */
  'name': (string);
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { log } from './logging';
import { LogVerbosity } from './constants';
import { getDefaultAuthority } from './resolver';
import { Socket } from 'net';
import * as http from 'http';
import * as tls from 'tls';
import * as logging from './logging';
import {
  SubchannelAddress,
  isTcpSubchannelAddress,
  subchannelAddressToString,
} from './subchannel-address';
import { ChannelOptions } from './channel-options';
import { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';
import { URL } from 'url';
import { DEFAULT_PORT } from './resolver-dns';

const TRACER_NAME = 'proxy';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

interface ProxyInfo {
  address?: string;
  creds?: string;
}

function getProxyInfo(): ProxyInfo {
  let proxyEnv = '';
  let envVar = '';
  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
   * fallback behavior can be removed if there's a demand for it.
   */
  if (process.env.grpc_proxy) {
    envVar = 'grpc_proxy';
    proxyEnv = process.env.grpc_proxy;
  } else if (process.env.https_proxy) {
    envVar = 'https_proxy';
    proxyEnv = process.env.https_proxy;
  } else if (process.env.http_proxy) {
    envVar = 'http_proxy';
    proxyEnv = process.env.http_proxy;
  } else {
    return {};
  }
  let proxyUrl: URL;
  try {
    proxyUrl = new URL(proxyEnv);
  } catch (e) {
    log(LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
    return {};
  }
  if (proxyUrl.protocol !== 'http:') {
    log(
      LogVerbosity.ERROR,
      `"${proxyUrl.protocol}" scheme not supported in proxy URI`
    );
    return {};
  }
  let userCred: string | null = null;
  if (proxyUrl.username) {
    if (proxyUrl.password) {
      log(LogVerbosity.INFO, 'userinfo found in proxy URI');
      userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
    } else {
      userCred = proxyUrl.username;
    }
  }
  const hostname = proxyUrl.hostname;
  let port = proxyUrl.port;
  /* The proxy URL uses the scheme "http:", which has a default port number of
   * 80. We need to set that explicitly here if it is omitted because otherwise
   * it will use gRPC's default port 443. */
  if (port === '') {
    port = '80';
  }
  const result: ProxyInfo = {
    address: `${hostname}:${port}`,
  };
  if (userCred) {
    result.creds = userCred;
  }
  trace(
    'Proxy server ' + result.address + ' set by environment variable ' + envVar
  );
  return result;
}

function getNoProxyHostList(): string[] {
  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
  let noProxyStr: string | undefined = process.env.no_grpc_proxy;
  let envVar = 'no_grpc_proxy';
  if (!noProxyStr) {
    noProxyStr = process.env.no_proxy;
    envVar = 'no_proxy';
  }
  if (noProxyStr) {
    trace('No proxy server list set by environment variable ' + envVar);
    return noProxyStr.split(',');
  } else {
    return [];
  }
}

export interface ProxyMapResult {
  target: GrpcUri;
  extraOptions: ChannelOptions;
}

export function mapProxyName(
  target: GrpcUri,
  options: ChannelOptions
): ProxyMapResult {
  const noProxyResult: ProxyMapResult = {
    target: target,
    extraOptions: {},
  };
  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {
    return noProxyResult;
  }
  if (target.scheme === 'unix') {
    return noProxyResult;
  }
  const proxyInfo = getProxyInfo();
  if (!proxyInfo.address) {
    return noProxyResult;
  }
  const hostPort = splitHostPort(target.path);
  if (!hostPort) {
    return noProxyResult;
  }
  const serverHost = hostPort.host;
  for (const host of getNoProxyHostList()) {
    if (host === serverHost) {
      trace(
        'Not using proxy for target in no_proxy list: ' + uriToString(target)
      );
      return noProxyResult;
    }
  }
  const extraOptions: ChannelOptions = {
    'grpc.http_connect_target': uriToString(target),
  };
  if (proxyInfo.creds) {
    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
  }
  return {
    target: {
      scheme: 'dns',
      path: proxyInfo.address,
    },
    extraOptions: extraOptions,
  };
}

export interface ProxyConnectionResult {
  socket?: Socket;
  realTarget?: GrpcUri;
}

export function getProxiedConnection(
  address: SubchannelAddress,
  channelOptions: ChannelOptions,
  connectionOptions: tls.ConnectionOptions
): Promise<ProxyConnectionResult> {
  if (!('grpc.http_connect_target' in channelOptions)) {
    return Promise.resolve<ProxyConnectionResult>({});
  }
  const realTarget = channelOptions['grpc.http_connect_target'] as string;
  const parsedTarget = parseUri(realTarget);
  if (parsedTarget === null) {
    return Promise.resolve<ProxyConnectionResult>({});
  }
  const splitHostPost = splitHostPort(parsedTarget.path);
  if (splitHostPost === null) {
    return Promise.resolve<ProxyConnectionResult>({});
  }
  const hostPort = `${splitHostPost.host}:${
    splitHostPost.port ?? DEFAULT_PORT
  }`;
  const options: http.RequestOptions = {
    method: 'CONNECT',
    path: hostPort,
  };
  const headers: http.OutgoingHttpHeaders = {
    Host: hostPort,
  };
  // Connect to the subchannel address as a proxy
  if (isTcpSubchannelAddress(address)) {
    options.host = address.host;
    options.port = address.port;
  } else {
    options.socketPath = address.path;
  }
  if ('grpc.http_connect_creds' in channelOptions) {
    headers['Proxy-Authorization'] =
      'Basic ' +
      Buffer.from(channelOptions['grpc.http_connect_creds'] as string).toString(
        'base64'
      );
  }
  options.headers = headers;
  const proxyAddressString = subchannelAddressToString(address);
  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
  return new Promise<ProxyConnectionResult>((resolve, reject) => {
    const request = http.request(options);
    request.once('connect', (res, socket, head) => {
      request.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) {
        trace(
          'Successfully connected to ' +
            options.path +
            ' through proxy ' +
            proxyAddressString
        );
        // The HTTP client may have already read a few bytes of the proxied
        // connection. If that's the case, put them back into the socket.
        // See https://github.com/grpc/grpc-node/issues/2744.
        if (head.length > 0) {
          socket.unshift(head);
        }
        if ('secureContext' in connectionOptions) {
          /* The proxy is connecting to a TLS server, so upgrade this socket
           * connection to a TLS connection.
           * This is a workaround for https://github.com/nodejs/node/issues/32922
           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
          const targetPath = getDefaultAuthority(parsedTarget);
          const hostPort = splitHostPort(targetPath);
          const remoteHost = hostPort?.host ?? targetPath;

          const cts = tls.connect(
            {
              host: remoteHost,
              servername: remoteHost,
              socket: socket,
              ...connectionOptions,
            },
            () => {
              trace(
                'Successfully established a TLS connection to ' +
                  options.path +
                  ' through proxy ' +
                  proxyAddressString
              );
              resolve({ socket: cts, realTarget: parsedTarget });
            }
          );
          cts.on('error', (error: Error) => {
            trace(
              'Failed to establish a TLS connection to ' +
                options.path +
                ' through proxy ' +
                proxyAddressString +
                ' with error ' +
                error.message
            );
            reject();
          });
        } else {
          trace(
            'Successfully established a plaintext connection to ' +
              options.path +
              ' through proxy ' +
              proxyAddressString
          );
          resolve({
            socket,
            realTarget: parsedTarget,
          });
        }
      } else {
        log(
          LogVerbosity.ERROR,
          'Failed to connect to ' +
            options.path +
            ' through proxy ' +
            proxyAddressString +
            ' with status ' +
            res.statusCode
        );
        reject();
      }
    });
    request.once('error', err => {
      request.removeAllListeners();
      log(
        LogVerbosity.ERROR,
        'Failed to connect to proxy ' +
          proxyAddressString +
          ' with error ' +
          err.message
      );
      reject();
    });
    request.end();
  });
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  ClientDuplexStream,
  ClientReadableStream,
  ClientUnaryCall,
  ClientWritableStream,
  ServiceError,
} from './call';
import { CallCredentials, OAuth2Client } from './call-credentials';
import { StatusObject } from './call-interface';
import { Channel, ChannelImplementation } from './channel';
import { CompressionAlgorithms } from './compression-algorithms';
import { ConnectivityState } from './connectivity-state';
import { ChannelCredentials, VerifyOptions } from './channel-credentials';
import {
  CallOptions,
  Client,
  ClientOptions,
  CallInvocationTransformer,
  CallProperties,
  UnaryCallback,
} from './client';
import { LogVerbosity, Status, Propagate } from './constants';
import * as logging from './logging';
import {
  Deserialize,
  loadPackageDefinition,
  makeClientConstructor,
  MethodDefinition,
  Serialize,
  ServiceDefinition,
} from './make-client';
import { Metadata, MetadataOptions, MetadataValue } from './metadata';
import {
  ConnectionInjector,
  Server,
  ServerOptions,
  UntypedHandleCall,
  UntypedServiceImplementation,
} from './server';
import { KeyCertPair, ServerCredentials } from './server-credentials';
import { StatusBuilder } from './status-builder';
import {
  handleBidiStreamingCall,
  handleServerStreamingCall,
  handleClientStreamingCall,
  handleUnaryCall,
  sendUnaryData,
  ServerUnaryCall,
  ServerReadableStream,
  ServerWritableStream,
  ServerDuplexStream,
  ServerErrorResponse,
} from './server-call';

export { OAuth2Client };

/**** Client Credentials ****/

// Using assign only copies enumerable properties, which is what we want
export const credentials = {
  /**
   * Combine a ChannelCredentials with any number of CallCredentials into a
   * single ChannelCredentials object.
   * @param channelCredentials The ChannelCredentials object.
   * @param callCredentials Any number of CallCredentials objects.
   * @return The resulting ChannelCredentials object.
   */
  combineChannelCredentials: (
    channelCredentials: ChannelCredentials,
    ...callCredentials: CallCredentials[]
  ): ChannelCredentials => {
    return callCredentials.reduce(
      (acc, other) => acc.compose(other),
      channelCredentials
    );
  },

  /**
   * Combine any number of CallCredentials into a single CallCredentials
   * object.
   * @param first The first CallCredentials object.
   * @param additional Any number of additional CallCredentials objects.
   * @return The resulting CallCredentials object.
   */
  combineCallCredentials: (
    first: CallCredentials,
    ...additional: CallCredentials[]
  ): CallCredentials => {
    return additional.reduce((acc, other) => acc.compose(other), first);
  },

  // from channel-credentials.ts
  createInsecure: ChannelCredentials.createInsecure,
  createSsl: ChannelCredentials.createSsl,
  createFromSecureContext: ChannelCredentials.createFromSecureContext,

  // from call-credentials.ts
  createFromMetadataGenerator: CallCredentials.createFromMetadataGenerator,
  createFromGoogleCredential: CallCredentials.createFromGoogleCredential,
  createEmpty: CallCredentials.createEmpty,
};

/**** Metadata ****/

export { Metadata, MetadataOptions, MetadataValue };

/**** Constants ****/

export {
  LogVerbosity as logVerbosity,
  Status as status,
  ConnectivityState as connectivityState,
  Propagate as propagate,
  CompressionAlgorithms as compressionAlgorithms,
  // TODO: Other constants as well
};

/**** Client ****/

export {
  Client,
  ClientOptions,
  loadPackageDefinition,
  makeClientConstructor,
  makeClientConstructor as makeGenericClientConstructor,
  CallProperties,
  CallInvocationTransformer,
  ChannelImplementation as Channel,
  Channel as ChannelInterface,
  UnaryCallback as requestCallback,
};

/**
 * Close a Client object.
 * @param client The client to close.
 */
export const closeClient = (client: Client) => client.close();

export const waitForClientReady = (
  client: Client,
  deadline: Date | number,
  callback: (error?: Error) => void
) => client.waitForReady(deadline, callback);

/* Interfaces */

export {
  sendUnaryData,
  ChannelCredentials,
  CallCredentials,
  Deadline,
  Serialize as serialize,
  Deserialize as deserialize,
  ClientUnaryCall,
  ClientReadableStream,
  ClientWritableStream,
  ClientDuplexStream,
  CallOptions,
  MethodDefinition,
  StatusObject,
  ServiceError,
  ServerUnaryCall,
  ServerReadableStream,
  ServerWritableStream,
  ServerDuplexStream,
  ServerErrorResponse,
  ServiceDefinition,
  UntypedHandleCall,
  UntypedServiceImplementation,
  VerifyOptions,
};

/**** Server ****/

export {
  handleBidiStreamingCall,
  handleServerStreamingCall,
  handleUnaryCall,
  handleClientStreamingCall,
};

/* eslint-disable @typescript-eslint/no-explicit-any */
export type Call =
  | ClientUnaryCall
  | ClientReadableStream<any>
  | ClientWritableStream<any>
  | ClientDuplexStream<any, any>;
/* eslint-enable @typescript-eslint/no-explicit-any */

/**** Unimplemented function stubs ****/

/* eslint-disable @typescript-eslint/no-explicit-any */

export const loadObject = (value: any, options: any): never => {
  throw new Error(
    'Not available in this library. Use @postman/proto-loader and loadPackageDefinition instead'
  );
};

export const load = (filename: any, format: any, options: any): never => {
  throw new Error(
    'Not available in this library. Use @postman/proto-loader and loadPackageDefinition instead'
  );
};

export const setLogger = (logger: Partial<Console>): void => {
  logging.setLogger(logger);
};

export const setLogVerbosity = (verbosity: LogVerbosity): void => {
  logging.setLoggerVerbosity(verbosity);
};

export { ConnectionInjector, Server, ServerOptions };
export { ServerCredentials };
export { KeyCertPair };

export const getClientChannel = (client: Client) => {
  return Client.prototype.getChannel.call(client);
};

export { StatusBuilder };

export { Listener, InterceptingListener } from './call-interface';

export {
  Requester,
  ListenerBuilder,
  RequesterBuilder,
  Interceptor,
  InterceptorOptions,
  InterceptorProvider,
  InterceptingCall,
  InterceptorConfigurationError,
  NextCall,
} from './client-interceptors';

export {
  GrpcObject,
  ServiceClientConstructor,
  ProtobufTypeDefinition,
} from './make-client';

export { ChannelOptions } from './channel-options';

export { getChannelzServiceDefinition, getChannelzHandlers } from './channelz';

export { addAdminServicesToServer } from './admin';

export {
  ServiceConfig,
  LoadBalancingConfig,
  MethodConfig,
  RetryPolicy,
} from './service-config';

export {
  ServerListener,
  FullServerListener,
  ServerListenerBuilder,
  Responder,
  FullResponder,
  ResponderBuilder,
  ServerInterceptingCallInterface,
  ServerInterceptingCall,
  ServerInterceptor,
} from './server-interceptors';

import * as experimental from './experimental';
export { experimental };

import * as resolver_dns from './resolver-dns';
import * as resolver_uds from './resolver-uds';
import * as resolver_ip from './resolver-ip';
import * as load_balancer_pick_first from './load-balancer-pick-first';
import * as load_balancer_round_robin from './load-balancer-round-robin';
import * as load_balancer_outlier_detection from './load-balancer-outlier-detection';
import * as channelz from './channelz';
import { Deadline } from './deadline';

(() => {
  resolver_dns.setup();
  resolver_uds.setup();
  resolver_ip.setup();
  load_balancer_pick_first.setup();
  load_balancer_round_robin.setup();
  load_balancer_outlier_detection.setup();
  channelz.setup();
})();
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { ResolvingLoadBalancer } from './resolving-load-balancer';
import { SubchannelPool, getSubchannelPool } from './subchannel-pool';
import { ChannelControlHelper } from './load-balancer';
import { UnavailablePicker, Picker, QueuePicker, PickArgs, PickResult, PickResultType } from './picker';
import { Metadata } from './metadata';
import { Status, LogVerbosity, Propagate } from './constants';
import { FilterStackFactory } from './filter-stack';
import { CompressionFilterFactory } from './compression-filter';
import {
  CallConfig,
  ConfigSelector,
  getDefaultAuthority,
  mapUriDefaultScheme,
} from './resolver';
import { trace } from './logging';
import { SubchannelAddress } from './subchannel-address';
import { mapProxyName } from './http_proxy';
import { GrpcUri, parseUri, uriToString } from './uri-parser';
import { ServerSurfaceCall } from './server-call';

import { ConnectivityState } from './connectivity-state';
import {
  ChannelInfo,
  ChannelRef,
  ChannelzCallTracker,
  ChannelzChildrenTracker,
  ChannelzTrace,
  registerChannelzChannel,
  SubchannelRef,
  unregisterChannelzRef,
} from './channelz';
import { LoadBalancingCall } from './load-balancing-call';
import { CallCredentials } from './call-credentials';
import { Call, CallStreamOptions, StatusObject } from './call-interface';
import { Deadline, deadlineToString } from './deadline';
import { ResolvingCall } from './resolving-call';
import { getNextCallNumber } from './call-number';
import { restrictControlPlaneStatusCode } from './control-plane-status';
import {
  MessageBufferTracker,
  RetryingCall,
  RetryThrottler,
} from './retrying-call';
import {
  BaseSubchannelWrapper,
  ConnectivityStateListener,
  SubchannelInterface,
} from './subchannel-interface';

/**
 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
 */
const MAX_TIMEOUT_TIME = 2147483647;

const MIN_IDLE_TIMEOUT_MS = 1000;

// 30 minutes
const DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;

interface ConnectivityStateWatcher {
  currentState: ConnectivityState;
  timer: NodeJS.Timeout | null;
  callback: (error?: Error) => void;
}

interface NoneConfigResult {
  type: 'NONE';
}

interface SuccessConfigResult {
  type: 'SUCCESS';
  config: CallConfig;
}

interface ErrorConfigResult {
  type: 'ERROR';
  error: StatusObject;
}

type GetConfigResult =
  | NoneConfigResult
  | SuccessConfigResult
  | ErrorConfigResult;

const RETRY_THROTTLER_MAP: Map<string, RetryThrottler> = new Map();

const DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB
const DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB

class ChannelSubchannelWrapper
  extends BaseSubchannelWrapper
  implements SubchannelInterface
{
  private refCount = 0;
  private subchannelStateListener: ConnectivityStateListener;
  constructor(
    childSubchannel: SubchannelInterface,
    private channel: InternalChannel
  ) {
    super(childSubchannel);
    this.subchannelStateListener = (
      subchannel,
      previousState,
      newState,
      keepaliveTime
    ) => {
      channel.throttleKeepalive(keepaliveTime);
    };
    childSubchannel.addConnectivityStateListener(this.subchannelStateListener);
  }

  ref(): void {
    this.child.ref();
    this.refCount += 1;
  }

  unref(): void {
    this.child.unref();
    this.refCount -= 1;
    if (this.refCount <= 0) {
      this.child.removeConnectivityStateListener(this.subchannelStateListener);
      this.channel.removeWrappedSubchannel(this);
    }
  }
}

class ShutdownPicker implements Picker {
  pick(pickArgs: PickArgs): PickResult {
    return {
      pickResultType: PickResultType.DROP,
      status: {
        code: Status.UNAVAILABLE,
        details: 'Channel closed before call started',
        metadata: new Metadata()
      },
      subchannel: null,
      onCallStarted: null,
      onCallEnded: null
    }
  }
}

export class InternalChannel {
  private readonly resolvingLoadBalancer: ResolvingLoadBalancer;
  private readonly subchannelPool: SubchannelPool;
  private connectivityState: ConnectivityState = ConnectivityState.IDLE;
  private currentPicker: Picker = new UnavailablePicker();
  /**
   * Calls queued up to get a call config. Should only be populated before the
   * first time the resolver returns a result, which includes the ConfigSelector.
   */
  private configSelectionQueue: ResolvingCall[] = [];
  private pickQueue: LoadBalancingCall[] = [];
  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];
  private readonly defaultAuthority: string;
  private readonly filterStackFactory: FilterStackFactory;
  private readonly target: GrpcUri;
  /**
   * This timer does not do anything on its own. Its purpose is to hold the
   * event loop open while there are any pending calls for the channel that
   * have not yet been assigned to specific subchannels. In other words,
   * the invariant is that callRefTimer is reffed if and only if pickQueue
   * is non-empty.
   */
  private readonly callRefTimer: NodeJS.Timeout;
  private configSelector: ConfigSelector | null = null;
  /**
   * This is the error from the name resolver if it failed most recently. It
   * is only used to end calls that start while there is no config selector
   * and the name resolver is in backoff, so it should be nulled if
   * configSelector becomes set or the channel state becomes anything other
   * than TRANSIENT_FAILURE.
   */
  private currentResolutionError: StatusObject | null = null;
  private readonly retryBufferTracker: MessageBufferTracker;
  private keepaliveTime: number;
  private readonly wrappedSubchannels: Set<ChannelSubchannelWrapper> =
    new Set();

  private callCount = 0;
  private idleTimer: NodeJS.Timeout | null = null;
  private readonly idleTimeoutMs: number;
  private lastActivityTimestamp: Date;

  // Channelz info
  private readonly channelzEnabled: boolean = true;
  private readonly originalTarget: string;
  private readonly channelzRef: ChannelRef;
  private readonly channelzTrace: ChannelzTrace;
  private readonly callTracker = new ChannelzCallTracker();
  private readonly childrenTracker = new ChannelzChildrenTracker();

  /**
   * Randomly generated ID to be passed to the config selector, for use by
   * ring_hash in xDS. An integer distributed approximately uniformly between
   * 0 and MAX_SAFE_INTEGER.
   */
  private readonly randomChannelId = Math.floor(
    Math.random() * Number.MAX_SAFE_INTEGER
  );

  constructor(
    target: string,
    private readonly credentials: ChannelCredentials,
    private readonly options: ChannelOptions
  ) {
    if (typeof target !== 'string') {
      throw new TypeError('Channel target must be a string');
    }
    if (!(credentials instanceof ChannelCredentials)) {
      throw new TypeError(
        'Channel credentials must be a ChannelCredentials object'
      );
    }
    if (options) {
      if (typeof options !== 'object') {
        throw new TypeError('Channel options must be an object');
      }
    }
    this.originalTarget = target;
    const originalTargetUri = parseUri(target);
    if (originalTargetUri === null) {
      throw new Error(`Could not parse target name "${target}"`);
    }
    /* This ensures that the target has a scheme that is registered with the
     * resolver */
    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);
    if (defaultSchemeMapResult === null) {
      throw new Error(
        `Could not find a default scheme for target name "${target}"`
      );
    }

    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);
    this.callRefTimer.unref?.();

    if (this.options['grpc.enable_channelz'] === 0) {
      this.channelzEnabled = false;
    }

    this.channelzTrace = new ChannelzTrace();
    this.channelzRef = registerChannelzChannel(
      target,
      () => this.getChannelzInfo(),
      this.channelzEnabled
    );
    if (this.channelzEnabled) {
      this.channelzTrace.addTrace('CT_INFO', 'Channel created');
    }

    if (this.options['grpc.default_authority']) {
      this.defaultAuthority = this.options['grpc.default_authority'] as string;
    } else {
      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);
    }
    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);
    this.target = proxyMapResult.target;
    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);

    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
     * the grpc.use_local_subchannel_pool channel option means. */
    this.subchannelPool = getSubchannelPool(
      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0
    );
    this.retryBufferTracker = new MessageBufferTracker(
      options['grpc.retry_buffer_size'] ?? DEFAULT_RETRY_BUFFER_SIZE_BYTES,
      options['grpc.per_rpc_retry_buffer_size'] ??
        DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES
    );
    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;
    this.idleTimeoutMs = Math.max(
      options['grpc.client_idle_timeout_ms'] ?? DEFAULT_IDLE_TIMEOUT_MS,
      MIN_IDLE_TIMEOUT_MS
    );
    const channelControlHelper: ChannelControlHelper = {
      createSubchannel: (
        subchannelAddress: SubchannelAddress,
        subchannelArgs: ChannelOptions
      ) => {
        const subchannel = this.subchannelPool.getOrCreateSubchannel(
          this.target,
          subchannelAddress,
          Object.assign({}, this.options, subchannelArgs),
          this.credentials
        );
        subchannel.throttleKeepalive(this.keepaliveTime);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace(
            'CT_INFO',
            'Created subchannel or used existing subchannel',
            subchannel.getChannelzRef()
          );
        }
        const wrappedSubchannel = new ChannelSubchannelWrapper(
          subchannel,
          this
        );
        this.wrappedSubchannels.add(wrappedSubchannel);
        return wrappedSubchannel;
      },
      updateState: (connectivityState: ConnectivityState, picker: Picker) => {
        this.currentPicker = picker;
        const queueCopy = this.pickQueue.slice();
        this.pickQueue = [];
        if (queueCopy.length > 0) {
          this.callRefTimerUnref();
        }
        for (const call of queueCopy) {
          call.doPick();
        }
        this.updateState(connectivityState);
      },
      requestReresolution: () => {
        // This should never be called.
        throw new Error(
          'Resolving load balancer should never call requestReresolution'
        );
      },
      addChannelzChild: (child: ChannelRef | SubchannelRef) => {
        if (this.channelzEnabled) {
          this.childrenTracker.refChild(child);
        }
      },
      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {
        if (this.channelzEnabled) {
          this.childrenTracker.unrefChild(child);
        }
      },
    };
    this.resolvingLoadBalancer = new ResolvingLoadBalancer(
      this.target,
      channelControlHelper,
      options,
      (serviceConfig, configSelector) => {
        if (serviceConfig.retryThrottling) {
          RETRY_THROTTLER_MAP.set(
            this.getTarget(),
            new RetryThrottler(
              serviceConfig.retryThrottling.maxTokens,
              serviceConfig.retryThrottling.tokenRatio,
              RETRY_THROTTLER_MAP.get(this.getTarget())
            )
          );
        } else {
          RETRY_THROTTLER_MAP.delete(this.getTarget());
        }
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace(
            'CT_INFO',
            'Address resolution succeeded'
          );
        }
        this.configSelector = configSelector;
        this.currentResolutionError = null;
        /* We process the queue asynchronously to ensure that the corresponding
         * load balancer update has completed. */
        process.nextTick(() => {
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          if (localQueue.length > 0) {
            this.callRefTimerUnref();
          }
          for (const call of localQueue) {
            call.getConfig();
          }
        });
      },
      status => {
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace(
            'CT_WARNING',
            'Address resolution failed with code ' +
              status.code +
              ' and details "' +
              status.details +
              '"'
          );
        }
        if (this.configSelectionQueue.length > 0) {
          this.trace(
            'Name resolution failed with calls queued for config selection'
          );
        }
        if (this.configSelector === null) {
          this.currentResolutionError = {
            ...restrictControlPlaneStatusCode(status.code, status.details),
            metadata: status.metadata,
          };
        }
        const localQueue = this.configSelectionQueue;
        this.configSelectionQueue = [];
        if (localQueue.length > 0) {
          this.callRefTimerUnref();
        }
        for (const call of localQueue) {
          call.reportResolverError(status);
        }
      }
    );
    this.filterStackFactory = new FilterStackFactory([
      new CompressionFilterFactory(this, this.options),
    ]);
    this.trace(
      'Channel constructed with options ' +
        JSON.stringify(options, undefined, 2)
    );
    const error = new Error();
    trace(
      LogVerbosity.DEBUG,
      'channel_stacktrace',
      '(' +
        this.channelzRef.id +
        ') ' +
        'Channel constructed \n' +
        error.stack?.substring(error.stack.indexOf('\n') + 1)
    );
    this.lastActivityTimestamp = new Date();
  }

  private getChannelzInfo(): ChannelInfo {
    return {
      target: this.originalTarget,
      state: this.connectivityState,
      trace: this.channelzTrace,
      callTracker: this.callTracker,
      children: this.childrenTracker.getChildLists(),
    };
  }

  private trace(text: string, verbosityOverride?: LogVerbosity) {
    trace(
      verbosityOverride ?? LogVerbosity.DEBUG,
      'channel',
      '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text
    );
  }

  private callRefTimerRef() {
    // If the hasRef function does not exist, always run the code
    if (!this.callRefTimer.hasRef?.()) {
      this.trace(
        'callRefTimer.ref | configSelectionQueue.length=' +
          this.configSelectionQueue.length +
          ' pickQueue.length=' +
          this.pickQueue.length
      );
      this.callRefTimer.ref?.();
    }
  }

  private callRefTimerUnref() {
    // If the hasRef function does not exist, always run the code
    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
      this.trace(
        'callRefTimer.unref | configSelectionQueue.length=' +
          this.configSelectionQueue.length +
          ' pickQueue.length=' +
          this.pickQueue.length
      );
      this.callRefTimer.unref?.();
    }
  }

  private removeConnectivityStateWatcher(
    watcherObject: ConnectivityStateWatcher
  ) {
    const watcherIndex = this.connectivityStateWatchers.findIndex(
      value => value === watcherObject
    );
    if (watcherIndex >= 0) {
      this.connectivityStateWatchers.splice(watcherIndex, 1);
    }
  }

  private updateState(newState: ConnectivityState): void {
    trace(
      LogVerbosity.DEBUG,
      'connectivity_state',
      '(' +
        this.channelzRef.id +
        ') ' +
        uriToString(this.target) +
        ' ' +
        ConnectivityState[this.connectivityState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    if (this.channelzEnabled) {
      this.channelzTrace.addTrace(
        'CT_INFO',
        'Connectivity state change to ' + ConnectivityState[newState]
      );
    }
    this.connectivityState = newState;
    const watchersCopy = this.connectivityStateWatchers.slice();
    for (const watcherObject of watchersCopy) {
      if (newState !== watcherObject.currentState) {
        if (watcherObject.timer) {
          clearTimeout(watcherObject.timer);
        }
        this.removeConnectivityStateWatcher(watcherObject);
        watcherObject.callback();
      }
    }
    if (newState !== ConnectivityState.TRANSIENT_FAILURE) {
      this.currentResolutionError = null;
    }
  }

  throttleKeepalive(newKeepaliveTime: number) {
    if (newKeepaliveTime > this.keepaliveTime) {
      this.keepaliveTime = newKeepaliveTime;
      for (const wrappedSubchannel of this.wrappedSubchannels) {
        wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
      }
    }
  }

  removeWrappedSubchannel(wrappedSubchannel: ChannelSubchannelWrapper) {
    this.wrappedSubchannels.delete(wrappedSubchannel);
  }

  doPick(metadata: Metadata, extraPickInfo: { [key: string]: string }) {
    return this.currentPicker.pick({
      metadata: metadata,
      extraPickInfo: extraPickInfo,
    });
  }

  queueCallForPick(call: LoadBalancingCall) {
    this.pickQueue.push(call);
    this.callRefTimerRef();
  }

  getConfig(method: string, metadata: Metadata): GetConfigResult {
    if (this.connectivityState !== ConnectivityState.SHUTDOWN) {
      this.resolvingLoadBalancer.exitIdle();
    }
    if (this.configSelector) {
      return {
        type: 'SUCCESS',
        config: this.configSelector(method, metadata, this.randomChannelId),
      };
    } else {
      if (this.currentResolutionError) {
        return {
          type: 'ERROR',
          error: this.currentResolutionError,
        };
      } else {
        return {
          type: 'NONE',
        };
      }
    }
  }

  queueCallForConfig(call: ResolvingCall) {
    this.configSelectionQueue.push(call);
    this.callRefTimerRef();
  }

  private enterIdle() {
    this.resolvingLoadBalancer.destroy();
    this.updateState(ConnectivityState.IDLE);
    this.currentPicker = new QueuePicker(this.resolvingLoadBalancer);
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
      this.idleTimer = null;
    }
  }

  private startIdleTimeout(timeoutMs: number) {
    this.idleTimer = setTimeout(() => {
      if (this.callCount > 0) {
        /* If there is currently a call, the channel will not go idle for a
         * period of at least idleTimeoutMs, so check again after that time.
         */
        this.startIdleTimeout(this.idleTimeoutMs);
        return;
      }
      const now = new Date();
      const timeSinceLastActivity =
        now.valueOf() - this.lastActivityTimestamp.valueOf();
      if (timeSinceLastActivity >= this.idleTimeoutMs) {
        this.trace(
          'Idle timer triggered after ' +
            this.idleTimeoutMs +
            'ms of inactivity'
        );
        this.enterIdle();
      } else {
        /* Whenever the timer fires with the latest activity being too recent,
         * set the timer again for the time when the time since the last
         * activity is equal to the timeout. This should result in the timer
         * firing no more than once every idleTimeoutMs/2 on average. */
        this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
      }
    }, timeoutMs);
    this.idleTimer.unref?.();
  }

  private maybeStartIdleTimer() {
    if (
      this.connectivityState !== ConnectivityState.SHUTDOWN &&
      !this.idleTimer
    ) {
      this.startIdleTimeout(this.idleTimeoutMs);
    }
  }

  private onCallStart() {
    if (this.channelzEnabled) {
      this.callTracker.addCallStarted();
    }
    this.callCount += 1;
  }

  private onCallEnd(status: StatusObject) {
    if (this.channelzEnabled) {
      if (status.code === Status.OK) {
        this.callTracker.addCallSucceeded();
      } else {
        this.callTracker.addCallFailed();
      }
    }
    this.callCount -= 1;
    this.lastActivityTimestamp = new Date();
    this.maybeStartIdleTimer();
  }

  createLoadBalancingCall(
    callConfig: CallConfig,
    method: string,
    host: string,
    credentials: CallCredentials,
    deadline: Deadline
  ): LoadBalancingCall {
    const callNumber = getNextCallNumber();
    this.trace(
      'createLoadBalancingCall [' + callNumber + '] method="' + method + '"'
    );
    return new LoadBalancingCall(
      this,
      callConfig,
      method,
      host,
      credentials,
      deadline,
      callNumber
    );
  }

  createRetryingCall(
    callConfig: CallConfig,
    method: string,
    host: string,
    credentials: CallCredentials,
    deadline: Deadline
  ): RetryingCall {
    const callNumber = getNextCallNumber();
    this.trace(
      'createRetryingCall [' + callNumber + '] method="' + method + '"'
    );
    return new RetryingCall(
      this,
      callConfig,
      method,
      host,
      credentials,
      deadline,
      callNumber,
      this.retryBufferTracker,
      RETRY_THROTTLER_MAP.get(this.getTarget())
    );
  }

  createInnerCall(
    callConfig: CallConfig,
    method: string,
    host: string,
    credentials: CallCredentials,
    deadline: Deadline
  ): LoadBalancingCall | RetryingCall {
    // Create a RetryingCall if retries are enabled
    if (this.options['grpc.enable_retries'] === 0) {
      return this.createLoadBalancingCall(
        callConfig,
        method,
        host,
        credentials,
        deadline
      );
    } else {
      return this.createRetryingCall(
        callConfig,
        method,
        host,
        credentials,
        deadline
      );
    }
  }

  createResolvingCall(
    method: string,
    deadline: Deadline,
    host: string | null | undefined,
    parentCall: ServerSurfaceCall | null,
    propagateFlags: number | null | undefined
  ): ResolvingCall {
    const callNumber = getNextCallNumber();
    this.trace(
      'createResolvingCall [' +
        callNumber +
        '] method="' +
        method +
        '", deadline=' +
        deadlineToString(deadline)
    );
    const finalOptions: CallStreamOptions = {
      deadline: deadline,
      flags: propagateFlags ?? Propagate.DEFAULTS,
      host: host ?? this.defaultAuthority,
      parentCall: parentCall,
    };

    const call = new ResolvingCall(
      this,
      method,
      finalOptions,
      this.filterStackFactory.clone(),
      this.credentials._getCallCredentials(),
      callNumber
    );

    this.onCallStart();
    call.addStatusWatcher(status => {
      this.onCallEnd(status);
    });
    return call;
  }

  close() {
    this.resolvingLoadBalancer.destroy();
    this.updateState(ConnectivityState.SHUTDOWN);
    this.currentPicker = new ShutdownPicker();
    for (const call of this.configSelectionQueue) {
      call.cancelWithStatus(Status.UNAVAILABLE, 'Channel closed before call started');
    }
    this.configSelectionQueue = [];
    for (const call of this.pickQueue) {
      call.cancelWithStatus(Status.UNAVAILABLE, 'Channel closed before call started');
    }
    this.pickQueue = [];
    clearInterval(this.callRefTimer);
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
    }
    if (this.channelzEnabled) {
      unregisterChannelzRef(this.channelzRef);
    }

    this.subchannelPool.unrefUnusedSubchannels();
  }

  getTarget() {
    return uriToString(this.target);
  }

  getConnectivityState(tryToConnect: boolean) {
    const connectivityState = this.connectivityState;
    if (tryToConnect) {
      this.resolvingLoadBalancer.exitIdle();
      this.lastActivityTimestamp = new Date();
      this.maybeStartIdleTimer();
    }
    return connectivityState;
  }

  watchConnectivityState(
    currentState: ConnectivityState,
    deadline: Date | number,
    callback: (error?: Error) => void
  ): void {
    if (this.connectivityState === ConnectivityState.SHUTDOWN) {
      throw new Error('Channel has been shut down');
    }
    let timer = null;
    if (deadline !== Infinity) {
      const deadlineDate: Date =
        deadline instanceof Date ? deadline : new Date(deadline);
      const now = new Date();
      if (deadline === -Infinity || deadlineDate <= now) {
        process.nextTick(
          callback,
          new Error('Deadline passed without connectivity state change')
        );
        return;
      }
      timer = setTimeout(() => {
        this.removeConnectivityStateWatcher(watcherObject);
        callback(
          new Error('Deadline passed without connectivity state change')
        );
      }, deadlineDate.getTime() - now.getTime());
    }
    const watcherObject = {
      currentState,
      callback,
      timer,
    };
    this.connectivityStateWatchers.push(watcherObject);
  }

  /**
   * Get the channelz reference object for this channel. The returned value is
   * garbage if channelz is disabled for this channel.
   * @returns
   */
  getChannelzRef() {
    return this.channelzRef;
  }

  createCall(
    method: string,
    deadline: Deadline,
    host: string | null | undefined,
    parentCall: ServerSurfaceCall | null,
    propagateFlags: number | null | undefined
  ): Call {
    if (typeof method !== 'string') {
      throw new TypeError('Channel#createCall: method must be a string');
    }
    if (!(typeof deadline === 'number' || deadline instanceof Date)) {
      throw new TypeError(
        'Channel#createCall: deadline must be a number or Date'
      );
    }
    if (this.connectivityState === ConnectivityState.SHUTDOWN) {
      throw new Error('Channel has been shut down');
    }
    return this.createResolvingCall(
      method,
      deadline,
      host,
      parentCall,
      propagateFlags
    );
  }

  getOptions() {
    return this.options;
  }
}
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  LoadBalancer,
  ChannelControlHelper,
  TypedLoadBalancingConfig,
  createLoadBalancer,
} from './load-balancer';
import { Endpoint, SubchannelAddress } from './subchannel-address';
import { ChannelOptions } from './channel-options';
import { ConnectivityState } from './connectivity-state';
import { Picker } from './picker';
import type { ChannelRef, SubchannelRef } from './channelz';
import { SubchannelInterface } from './subchannel-interface';

const TYPE_NAME = 'child_load_balancer_helper';

export class ChildLoadBalancerHandler implements LoadBalancer {
  private currentChild: LoadBalancer | null = null;
  private pendingChild: LoadBalancer | null = null;
  private latestConfig: TypedLoadBalancingConfig | null = null;

  private ChildPolicyHelper = class {
    private child: LoadBalancer | null = null;
    constructor(private parent: ChildLoadBalancerHandler) {}
    createSubchannel(
      subchannelAddress: SubchannelAddress,
      subchannelArgs: ChannelOptions
    ): SubchannelInterface {
      return this.parent.channelControlHelper.createSubchannel(
        subchannelAddress,
        subchannelArgs
      );
    }
    updateState(connectivityState: ConnectivityState, picker: Picker): void {
      if (this.calledByPendingChild()) {
        if (connectivityState === ConnectivityState.CONNECTING) {
          return;
        }
        this.parent.currentChild?.destroy();
        this.parent.currentChild = this.parent.pendingChild;
        this.parent.pendingChild = null;
      } else if (!this.calledByCurrentChild()) {
        return;
      }
      this.parent.channelControlHelper.updateState(connectivityState, picker);
    }
    requestReresolution(): void {
      const latestChild = this.parent.pendingChild ?? this.parent.currentChild;
      if (this.child === latestChild) {
        this.parent.channelControlHelper.requestReresolution();
      }
    }
    setChild(newChild: LoadBalancer) {
      this.child = newChild;
    }
    addChannelzChild(child: ChannelRef | SubchannelRef) {
      this.parent.channelControlHelper.addChannelzChild(child);
    }
    removeChannelzChild(child: ChannelRef | SubchannelRef) {
      this.parent.channelControlHelper.removeChannelzChild(child);
    }

    private calledByPendingChild(): boolean {
      return this.child === this.parent.pendingChild;
    }
    private calledByCurrentChild(): boolean {
      return this.child === this.parent.currentChild;
    }
  };

  constructor(
    private readonly channelControlHelper: ChannelControlHelper,
    private readonly options: ChannelOptions
  ) {}

  protected configUpdateRequiresNewPolicyInstance(
    oldConfig: TypedLoadBalancingConfig,
    newConfig: TypedLoadBalancingConfig
  ): boolean {
    return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
  }

  /**
   * Prerequisites: lbConfig !== null and lbConfig.name is registered
   * @param endpointList
   * @param lbConfig
   * @param attributes
   */
  updateAddressList(
    endpointList: Endpoint[],
    lbConfig: TypedLoadBalancingConfig,
    attributes: { [key: string]: unknown }
  ): void {
    let childToUpdate: LoadBalancer;
    if (
      this.currentChild === null ||
      this.latestConfig === null ||
      this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)
    ) {
      const newHelper = new this.ChildPolicyHelper(this);
      const newChild = createLoadBalancer(lbConfig, newHelper, this.options)!;
      newHelper.setChild(newChild);
      if (this.currentChild === null) {
        this.currentChild = newChild;
        childToUpdate = this.currentChild;
      } else {
        if (this.pendingChild) {
          this.pendingChild.destroy();
        }
        this.pendingChild = newChild;
        childToUpdate = this.pendingChild;
      }
    } else {
      if (this.pendingChild === null) {
        childToUpdate = this.currentChild;
      } else {
        childToUpdate = this.pendingChild;
      }
    }
    this.latestConfig = lbConfig;
    childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
  }
  exitIdle(): void {
    if (this.currentChild) {
      this.currentChild.exitIdle();
      if (this.pendingChild) {
        this.pendingChild.exitIdle();
      }
    }
  }
  resetBackoff(): void {
    if (this.currentChild) {
      this.currentChild.resetBackoff();
      if (this.pendingChild) {
        this.pendingChild.resetBackoff();
      }
    }
  }
  destroy(): void {
    /* Note: state updates are only propagated from the child balancer if that
     * object is equal to this.currentChild or this.pendingChild. Since this
     * function sets both of those to null, no further state updates will
     * occur after this function returns. */
    if (this.currentChild) {
      this.currentChild.destroy();
      this.currentChild = null;
    }
    if (this.pendingChild) {
      this.pendingChild.destroy();
      this.pendingChild = null;
    }
  }
  getTypeName(): string {
    return TYPE_NAME;
  }
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelOptions } from './channel-options';
import { ConnectivityState } from './connectivity-state';
import { LogVerbosity, Status } from './constants';
import { Duration, durationToMs, isDuration, msToDuration } from './duration';
import {
  ChannelControlHelper,
  createChildChannelControlHelper,
  registerLoadBalancerType,
} from './experimental';
import {
  selectLbConfigFromList,
  LoadBalancer,
  TypedLoadBalancingConfig,
} from './load-balancer';
import { ChildLoadBalancerHandler } from './load-balancer-child-handler';
import { PickArgs, Picker, PickResult, PickResultType } from './picker';
import {
  Endpoint,
  EndpointMap,
  SubchannelAddress,
  endpointToString,
} from './subchannel-address';
import {
  BaseSubchannelWrapper,
  SubchannelInterface,
} from './subchannel-interface';
import * as logging from './logging';
import { LoadBalancingConfig } from './service-config';

const TRACER_NAME = 'outlier_detection';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const TYPE_NAME = 'outlier_detection';

const OUTLIER_DETECTION_ENABLED =
  (process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION ?? 'true') === 'true';

export interface SuccessRateEjectionConfig {
  readonly stdev_factor: number;
  readonly enforcement_percentage: number;
  readonly minimum_hosts: number;
  readonly request_volume: number;
}

export interface FailurePercentageEjectionConfig {
  readonly threshold: number;
  readonly enforcement_percentage: number;
  readonly minimum_hosts: number;
  readonly request_volume: number;
}

export interface OutlierDetectionRawConfig {
  interval?: Duration;
  base_ejection_time?: Duration;
  max_ejection_time?: Duration;
  max_ejection_percent?: number;
  success_rate_ejection?: Partial<SuccessRateEjectionConfig>;
  failure_percentage_ejection?: Partial<FailurePercentageEjectionConfig>;
  child_policy: LoadBalancingConfig[];
}

const defaultSuccessRateEjectionConfig: SuccessRateEjectionConfig = {
  stdev_factor: 1900,
  enforcement_percentage: 100,
  minimum_hosts: 5,
  request_volume: 100,
};

const defaultFailurePercentageEjectionConfig: FailurePercentageEjectionConfig =
  {
    threshold: 85,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 50,
  };

type TypeofValues =
  | 'object'
  | 'boolean'
  | 'function'
  | 'number'
  | 'string'
  | 'undefined';

function validateFieldType(
  obj: any,
  fieldName: string,
  expectedType: TypeofValues,
  objectName?: string
) {
  if (
    fieldName in obj &&
    obj[fieldName] !== undefined &&
    typeof obj[fieldName] !== expectedType
  ) {
    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
    throw new Error(
      `outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[
        fieldName
      ]}`
    );
  }
}

function validatePositiveDuration(
  obj: any,
  fieldName: string,
  objectName?: string
) {
  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
  if (fieldName in obj && obj[fieldName] !== undefined) {
    if (!isDuration(obj[fieldName])) {
      throw new Error(
        `outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[
          fieldName
        ]}`
      );
    }
    if (
      !(
        obj[fieldName].seconds >= 0 &&
        obj[fieldName].seconds <= 315_576_000_000 &&
        obj[fieldName].nanos >= 0 &&
        obj[fieldName].nanos <= 999_999_999
      )
    ) {
      throw new Error(
        `outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`
      );
    }
  }
}

function validatePercentage(obj: any, fieldName: string, objectName?: string) {
  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
  validateFieldType(obj, fieldName, 'number', objectName);
  if (
    fieldName in obj &&
    obj[fieldName] !== undefined &&
    !(obj[fieldName] >= 0 && obj[fieldName] <= 100)
  ) {
    throw new Error(
      `outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`
    );
  }
}

export class OutlierDetectionLoadBalancingConfig
  implements TypedLoadBalancingConfig
{
  private readonly intervalMs: number;
  private readonly baseEjectionTimeMs: number;
  private readonly maxEjectionTimeMs: number;
  private readonly maxEjectionPercent: number;
  private readonly successRateEjection: SuccessRateEjectionConfig | null;
  private readonly failurePercentageEjection: FailurePercentageEjectionConfig | null;

  constructor(
    intervalMs: number | null,
    baseEjectionTimeMs: number | null,
    maxEjectionTimeMs: number | null,
    maxEjectionPercent: number | null,
    successRateEjection: Partial<SuccessRateEjectionConfig> | null,
    failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null,
    private readonly childPolicy: TypedLoadBalancingConfig
  ) {
    if (childPolicy.getLoadBalancerName() === 'pick_first') {
      throw new Error(
        'outlier_detection LB policy cannot have a pick_first child policy'
      );
    }
    this.intervalMs = intervalMs ?? 10_000;
    this.baseEjectionTimeMs = baseEjectionTimeMs ?? 30_000;
    this.maxEjectionTimeMs = maxEjectionTimeMs ?? 300_000;
    this.maxEjectionPercent = maxEjectionPercent ?? 10;
    this.successRateEjection = successRateEjection
      ? { ...defaultSuccessRateEjectionConfig, ...successRateEjection }
      : null;
    this.failurePercentageEjection = failurePercentageEjection
      ? {
          ...defaultFailurePercentageEjectionConfig,
          ...failurePercentageEjection,
        }
      : null;
  }
  getLoadBalancerName(): string {
    return TYPE_NAME;
  }
  toJsonObject(): object {
    return {
      outlier_detection: {
        interval: msToDuration(this.intervalMs),
        base_ejection_time: msToDuration(this.baseEjectionTimeMs),
        max_ejection_time: msToDuration(this.maxEjectionTimeMs),
        max_ejection_percent: this.maxEjectionPercent,
        success_rate_ejection: this.successRateEjection ?? undefined,
        failure_percentage_ejection:
          this.failurePercentageEjection ?? undefined,
        child_policy: [this.childPolicy.toJsonObject()],
      },
    };
  }

  getIntervalMs(): number {
    return this.intervalMs;
  }
  getBaseEjectionTimeMs(): number {
    return this.baseEjectionTimeMs;
  }
  getMaxEjectionTimeMs(): number {
    return this.maxEjectionTimeMs;
  }
  getMaxEjectionPercent(): number {
    return this.maxEjectionPercent;
  }
  getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null {
    return this.successRateEjection;
  }
  getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null {
    return this.failurePercentageEjection;
  }
  getChildPolicy(): TypedLoadBalancingConfig {
    return this.childPolicy;
  }

  static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig {
    validatePositiveDuration(obj, 'interval');
    validatePositiveDuration(obj, 'base_ejection_time');
    validatePositiveDuration(obj, 'max_ejection_time');
    validatePercentage(obj, 'max_ejection_percent');
    if (
      'success_rate_ejection' in obj &&
      obj.success_rate_ejection !== undefined
    ) {
      if (typeof obj.success_rate_ejection !== 'object') {
        throw new Error(
          'outlier detection config success_rate_ejection must be an object'
        );
      }
      validateFieldType(
        obj.success_rate_ejection,
        'stdev_factor',
        'number',
        'success_rate_ejection'
      );
      validatePercentage(
        obj.success_rate_ejection,
        'enforcement_percentage',
        'success_rate_ejection'
      );
      validateFieldType(
        obj.success_rate_ejection,
        'minimum_hosts',
        'number',
        'success_rate_ejection'
      );
      validateFieldType(
        obj.success_rate_ejection,
        'request_volume',
        'number',
        'success_rate_ejection'
      );
    }
    if (
      'failure_percentage_ejection' in obj &&
      obj.failure_percentage_ejection !== undefined
    ) {
      if (typeof obj.failure_percentage_ejection !== 'object') {
        throw new Error(
          'outlier detection config failure_percentage_ejection must be an object'
        );
      }
      validatePercentage(
        obj.failure_percentage_ejection,
        'threshold',
        'failure_percentage_ejection'
      );
      validatePercentage(
        obj.failure_percentage_ejection,
        'enforcement_percentage',
        'failure_percentage_ejection'
      );
      validateFieldType(
        obj.failure_percentage_ejection,
        'minimum_hosts',
        'number',
        'failure_percentage_ejection'
      );
      validateFieldType(
        obj.failure_percentage_ejection,
        'request_volume',
        'number',
        'failure_percentage_ejection'
      );
    }

    if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {
      throw new Error('outlier detection config child_policy must be an array');
    }
    const childPolicy = selectLbConfigFromList(obj.child_policy);
    if (!childPolicy) {
      throw new Error(
        'outlier detection config child_policy: no valid recognized policy found'
      );
    }

    return new OutlierDetectionLoadBalancingConfig(
      obj.interval ? durationToMs(obj.interval) : null,
      obj.base_ejection_time ? durationToMs(obj.base_ejection_time) : null,
      obj.max_ejection_time ? durationToMs(obj.max_ejection_time) : null,
      obj.max_ejection_percent ?? null,
      obj.success_rate_ejection,
      obj.failure_percentage_ejection,
      childPolicy
    );
  }
}

class OutlierDetectionSubchannelWrapper
  extends BaseSubchannelWrapper
  implements SubchannelInterface
{
  private refCount = 0;
  constructor(
    childSubchannel: SubchannelInterface,
    private mapEntry?: MapEntry
  ) {
    super(childSubchannel);
  }

  ref() {
    this.child.ref();
    this.refCount += 1;
  }

  unref() {
    this.child.unref();
    this.refCount -= 1;
    if (this.refCount <= 0) {
      if (this.mapEntry) {
        const index = this.mapEntry.subchannelWrappers.indexOf(this);
        if (index >= 0) {
          this.mapEntry.subchannelWrappers.splice(index, 1);
        }
      }
    }
  }

  eject() {
    this.setHealthy(false);
  }

  uneject() {
    this.setHealthy(true);
  }

  getMapEntry(): MapEntry | undefined {
    return this.mapEntry;
  }

  getWrappedSubchannel(): SubchannelInterface {
    return this.child;
  }
}

interface CallCountBucket {
  success: number;
  failure: number;
}

function createEmptyBucket(): CallCountBucket {
  return {
    success: 0,
    failure: 0,
  };
}

class CallCounter {
  private activeBucket: CallCountBucket = createEmptyBucket();
  private inactiveBucket: CallCountBucket = createEmptyBucket();
  addSuccess() {
    this.activeBucket.success += 1;
  }
  addFailure() {
    this.activeBucket.failure += 1;
  }
  switchBuckets() {
    this.inactiveBucket = this.activeBucket;
    this.activeBucket = createEmptyBucket();
  }
  getLastSuccesses() {
    return this.inactiveBucket.success;
  }
  getLastFailures() {
    return this.inactiveBucket.failure;
  }
}

class OutlierDetectionPicker implements Picker {
  constructor(private wrappedPicker: Picker, private countCalls: boolean) {}
  pick(pickArgs: PickArgs): PickResult {
    const wrappedPick = this.wrappedPicker.pick(pickArgs);
    if (wrappedPick.pickResultType === PickResultType.COMPLETE) {
      const subchannelWrapper =
        wrappedPick.subchannel as OutlierDetectionSubchannelWrapper;
      const mapEntry = subchannelWrapper.getMapEntry();
      if (mapEntry) {
        let onCallEnded = wrappedPick.onCallEnded;
        if (this.countCalls) {
          onCallEnded = statusCode => {
            if (statusCode === Status.OK) {
              mapEntry.counter.addSuccess();
            } else {
              mapEntry.counter.addFailure();
            }
            wrappedPick.onCallEnded?.(statusCode);
          };
        }
        return {
          ...wrappedPick,
          subchannel: subchannelWrapper.getWrappedSubchannel(),
          onCallEnded: onCallEnded,
        };
      } else {
        return {
          ...wrappedPick,
          subchannel: subchannelWrapper.getWrappedSubchannel(),
        };
      }
    } else {
      return wrappedPick;
    }
  }
}

interface MapEntry {
  counter: CallCounter;
  currentEjectionTimestamp: Date | null;
  ejectionTimeMultiplier: number;
  subchannelWrappers: OutlierDetectionSubchannelWrapper[];
}

export class OutlierDetectionLoadBalancer implements LoadBalancer {
  private childBalancer: ChildLoadBalancerHandler;
  private entryMap = new EndpointMap<MapEntry>();
  private latestConfig: OutlierDetectionLoadBalancingConfig | null = null;
  private ejectionTimer: NodeJS.Timeout;
  private timerStartTime: Date | null = null;

  constructor(
    channelControlHelper: ChannelControlHelper,
    options: ChannelOptions
  ) {
    this.childBalancer = new ChildLoadBalancerHandler(
      createChildChannelControlHelper(channelControlHelper, {
        createSubchannel: (
          subchannelAddress: SubchannelAddress,
          subchannelArgs: ChannelOptions
        ) => {
          const originalSubchannel = channelControlHelper.createSubchannel(
            subchannelAddress,
            subchannelArgs
          );
          const mapEntry =
            this.entryMap.getForSubchannelAddress(subchannelAddress);
          const subchannelWrapper = new OutlierDetectionSubchannelWrapper(
            originalSubchannel,
            mapEntry
          );
          if (mapEntry?.currentEjectionTimestamp !== null) {
            // If the address is ejected, propagate that to the new subchannel wrapper
            subchannelWrapper.eject();
          }
          mapEntry?.subchannelWrappers.push(subchannelWrapper);
          return subchannelWrapper;
        },
        updateState: (connectivityState: ConnectivityState, picker: Picker) => {
          if (connectivityState === ConnectivityState.READY) {
            channelControlHelper.updateState(
              connectivityState,
              new OutlierDetectionPicker(picker, this.isCountingEnabled())
            );
          } else {
            channelControlHelper.updateState(connectivityState, picker);
          }
        },
      }),
      options
    );
    this.ejectionTimer = setInterval(() => {}, 0);
    clearInterval(this.ejectionTimer);
  }

  private isCountingEnabled(): boolean {
    return (
      this.latestConfig !== null &&
      (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
        this.latestConfig.getFailurePercentageEjectionConfig() !== null)
    );
  }

  private getCurrentEjectionPercent() {
    let ejectionCount = 0;
    for (const mapEntry of this.entryMap.values()) {
      if (mapEntry.currentEjectionTimestamp !== null) {
        ejectionCount += 1;
      }
    }
    return (ejectionCount * 100) / this.entryMap.size;
  }

  private runSuccessRateCheck(ejectionTimestamp: Date) {
    if (!this.latestConfig) {
      return;
    }
    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
    if (!successRateConfig) {
      return;
    }
    trace('Running success rate check');
    // Step 1
    const targetRequestVolume = successRateConfig.request_volume;
    let addresesWithTargetVolume = 0;
    const successRates: number[] = [];
    for (const [endpoint, mapEntry] of this.entryMap.entries()) {
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      trace(
        'Stats for ' +
          endpointToString(endpoint) +
          ': successes=' +
          successes +
          ' failures=' +
          failures +
          ' targetRequestVolume=' +
          targetRequestVolume
      );
      if (successes + failures >= targetRequestVolume) {
        addresesWithTargetVolume += 1;
        successRates.push(successes / (successes + failures));
      }
    }
    trace(
      'Found ' +
        addresesWithTargetVolume +
        ' success rate candidates; currentEjectionPercent=' +
        this.getCurrentEjectionPercent() +
        ' successRates=[' +
        successRates +
        ']'
    );
    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
      return;
    }

    // Step 2
    const successRateMean =
      successRates.reduce((a, b) => a + b) / successRates.length;
    let successRateDeviationSum = 0;
    for (const rate of successRates) {
      const deviation = rate - successRateMean;
      successRateDeviationSum += deviation * deviation;
    }
    const successRateVariance = successRateDeviationSum / successRates.length;
    const successRateStdev = Math.sqrt(successRateVariance);
    const ejectionThreshold =
      successRateMean -
      successRateStdev * (successRateConfig.stdev_factor / 1000);
    trace(
      'stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold
    );

    // Step 3
    for (const [address, mapEntry] of this.entryMap.entries()) {
      // Step 3.i
      if (
        this.getCurrentEjectionPercent() >=
        this.latestConfig.getMaxEjectionPercent()
      ) {
        break;
      }
      // Step 3.ii
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      if (successes + failures < targetRequestVolume) {
        continue;
      }
      // Step 3.iii
      const successRate = successes / (successes + failures);
      trace('Checking candidate ' + address + ' successRate=' + successRate);
      if (successRate < ejectionThreshold) {
        const randomNumber = Math.random() * 100;
        trace(
          'Candidate ' +
            address +
            ' randomNumber=' +
            randomNumber +
            ' enforcement_percentage=' +
            successRateConfig.enforcement_percentage
        );
        if (randomNumber < successRateConfig.enforcement_percentage) {
          trace('Ejecting candidate ' + address);
          this.eject(mapEntry, ejectionTimestamp);
        }
      }
    }
  }

  private runFailurePercentageCheck(ejectionTimestamp: Date) {
    if (!this.latestConfig) {
      return;
    }
    const failurePercentageConfig =
      this.latestConfig.getFailurePercentageEjectionConfig();
    if (!failurePercentageConfig) {
      return;
    }
    trace(
      'Running failure percentage check. threshold=' +
        failurePercentageConfig.threshold +
        ' request volume threshold=' +
        failurePercentageConfig.request_volume
    );
    // Step 1
    let addressesWithTargetVolume = 0;
    for (const mapEntry of this.entryMap.values()) {
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      if (successes + failures >= failurePercentageConfig.request_volume) {
        addressesWithTargetVolume += 1;
      }
    }
    if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
      return;
    }

    // Step 2
    for (const [address, mapEntry] of this.entryMap.entries()) {
      // Step 2.i
      if (
        this.getCurrentEjectionPercent() >=
        this.latestConfig.getMaxEjectionPercent()
      ) {
        break;
      }
      // Step 2.ii
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      trace('Candidate successes=' + successes + ' failures=' + failures);
      if (successes + failures < failurePercentageConfig.request_volume) {
        continue;
      }
      // Step 2.iii
      const failurePercentage = (failures * 100) / (failures + successes);
      if (failurePercentage > failurePercentageConfig.threshold) {
        const randomNumber = Math.random() * 100;
        trace(
          'Candidate ' +
            address +
            ' randomNumber=' +
            randomNumber +
            ' enforcement_percentage=' +
            failurePercentageConfig.enforcement_percentage
        );
        if (randomNumber < failurePercentageConfig.enforcement_percentage) {
          trace('Ejecting candidate ' + address);
          this.eject(mapEntry, ejectionTimestamp);
        }
      }
    }
  }

  private eject(mapEntry: MapEntry, ejectionTimestamp: Date) {
    mapEntry.currentEjectionTimestamp = new Date();
    mapEntry.ejectionTimeMultiplier += 1;
    for (const subchannelWrapper of mapEntry.subchannelWrappers) {
      subchannelWrapper.eject();
    }
  }

  private uneject(mapEntry: MapEntry) {
    mapEntry.currentEjectionTimestamp = null;
    for (const subchannelWrapper of mapEntry.subchannelWrappers) {
      subchannelWrapper.uneject();
    }
  }

  private switchAllBuckets() {
    for (const mapEntry of this.entryMap.values()) {
      mapEntry.counter.switchBuckets();
    }
  }

  private startTimer(delayMs: number) {
    this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
    this.ejectionTimer.unref?.();
  }

  private runChecks() {
    const ejectionTimestamp = new Date();
    trace('Ejection timer running');

    this.switchAllBuckets();

    if (!this.latestConfig) {
      return;
    }
    this.timerStartTime = ejectionTimestamp;
    this.startTimer(this.latestConfig.getIntervalMs());

    this.runSuccessRateCheck(ejectionTimestamp);
    this.runFailurePercentageCheck(ejectionTimestamp);

    for (const [address, mapEntry] of this.entryMap.entries()) {
      if (mapEntry.currentEjectionTimestamp === null) {
        if (mapEntry.ejectionTimeMultiplier > 0) {
          mapEntry.ejectionTimeMultiplier -= 1;
        }
      } else {
        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
        const returnTime = new Date(
          mapEntry.currentEjectionTimestamp.getTime()
        );
        returnTime.setMilliseconds(
          returnTime.getMilliseconds() +
            Math.min(
              baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier,
              Math.max(baseEjectionTimeMs, maxEjectionTimeMs)
            )
        );
        if (returnTime < new Date()) {
          trace('Unejecting ' + address);
          this.uneject(mapEntry);
        }
      }
    }
  }

  updateAddressList(
    endpointList: Endpoint[],
    lbConfig: TypedLoadBalancingConfig,
    attributes: { [key: string]: unknown }
  ): void {
    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
      return;
    }
    for (const endpoint of endpointList) {
      if (!this.entryMap.has(endpoint)) {
        trace('Adding map entry for ' + endpointToString(endpoint));
        this.entryMap.set(endpoint, {
          counter: new CallCounter(),
          currentEjectionTimestamp: null,
          ejectionTimeMultiplier: 0,
          subchannelWrappers: [],
        });
      }
    }
    this.entryMap.deleteMissing(endpointList);
    const childPolicy = lbConfig.getChildPolicy();
    this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);

    if (
      lbConfig.getSuccessRateEjectionConfig() ||
      lbConfig.getFailurePercentageEjectionConfig()
    ) {
      if (this.timerStartTime) {
        trace('Previous timer existed. Replacing timer');
        clearTimeout(this.ejectionTimer);
        const remainingDelay =
          lbConfig.getIntervalMs() -
          (new Date().getTime() - this.timerStartTime.getTime());
        this.startTimer(remainingDelay);
      } else {
        trace('Starting new timer');
        this.timerStartTime = new Date();
        this.startTimer(lbConfig.getIntervalMs());
        this.switchAllBuckets();
      }
    } else {
      trace('Counting disabled. Cancelling timer.');
      this.timerStartTime = null;
      clearTimeout(this.ejectionTimer);
      for (const mapEntry of this.entryMap.values()) {
        this.uneject(mapEntry);
        mapEntry.ejectionTimeMultiplier = 0;
      }
    }

    this.latestConfig = lbConfig;
  }
  exitIdle(): void {
    this.childBalancer.exitIdle();
  }
  resetBackoff(): void {
    this.childBalancer.resetBackoff();
  }
  destroy(): void {
    clearTimeout(this.ejectionTimer);
    this.childBalancer.destroy();
  }
  getTypeName(): string {
    return TYPE_NAME;
  }
}

export function setup() {
  if (OUTLIER_DETECTION_ENABLED) {
    registerLoadBalancerType(
      TYPE_NAME,
      OutlierDetectionLoadBalancer,
      OutlierDetectionLoadBalancingConfig
    );
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  LoadBalancer,
  ChannelControlHelper,
  TypedLoadBalancingConfig,
  registerDefaultLoadBalancerType,
  registerLoadBalancerType,
  createChildChannelControlHelper,
} from './load-balancer';
import { ConnectivityState } from './connectivity-state';
import {
  QueuePicker,
  Picker,
  PickArgs,
  CompletePickResult,
  PickResultType,
  UnavailablePicker,
} from './picker';
import { Endpoint, SubchannelAddress, subchannelAddressToString } from './subchannel-address';
import * as logging from './logging';
import { LogVerbosity } from './constants';
import {
  SubchannelInterface,
  ConnectivityStateListener,
  HealthListener,
} from './subchannel-interface';
import { isTcpSubchannelAddress } from './subchannel-address';
import { isIPv6 } from 'net';
import { ChannelOptions } from './channel-options';

const TRACER_NAME = 'pick_first';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const TYPE_NAME = 'pick_first';

/**
 * Delay after starting a connection on a subchannel before starting a
 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
 */
const CONNECTION_DELAY_INTERVAL_MS = 250;

export class PickFirstLoadBalancingConfig implements TypedLoadBalancingConfig {
  constructor(private readonly shuffleAddressList: boolean) {}

  getLoadBalancerName(): string {
    return TYPE_NAME;
  }

  toJsonObject(): object {
    return {
      [TYPE_NAME]: {
        shuffleAddressList: this.shuffleAddressList,
      },
    };
  }

  getShuffleAddressList() {
    return this.shuffleAddressList;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static createFromJson(obj: any) {
    if (
      'shuffleAddressList' in obj &&
      !(typeof obj.shuffleAddressList === 'boolean')
    ) {
      throw new Error(
        'pick_first config field shuffleAddressList must be a boolean if provided'
      );
    }
    return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
  }
}

/**
 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
 * picked subchannel.
 */
class PickFirstPicker implements Picker {
  constructor(private subchannel: SubchannelInterface) {}

  pick(pickArgs: PickArgs): CompletePickResult {
    return {
      pickResultType: PickResultType.COMPLETE,
      subchannel: this.subchannel,
      status: null,
      onCallStarted: null,
      onCallEnded: null,
    };
  }
}

interface SubchannelChild {
  subchannel: SubchannelInterface;
  hasReportedTransientFailure: boolean;
}

/**
 * Return a new array with the elements of the input array in a random order
 * @param list The input array
 * @returns A shuffled array of the elements of list
 */
export function shuffled<T>(list: T[]): T[] {
  const result = list.slice();
  for (let i = result.length - 1; i > 1; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const temp = result[i];
    result[i] = result[j];
    result[j] = temp;
  }
  return result;
}

/**
 * Interleave addresses in addressList by family in accordance with RFC-8304 section 4
 * @param addressList
 * @returns
 */
function interleaveAddressFamilies(
  addressList: SubchannelAddress[]
): SubchannelAddress[] {
  const result: SubchannelAddress[] = [];
  const ipv6Addresses: SubchannelAddress[] = [];
  const ipv4Addresses: SubchannelAddress[] = [];
  const ipv6First =
    isTcpSubchannelAddress(addressList[0]) && isIPv6(addressList[0].host);
  for (const address of addressList) {
    if (isTcpSubchannelAddress(address) && isIPv6(address.host)) {
      ipv6Addresses.push(address);
    } else {
      ipv4Addresses.push(address);
    }
  }
  const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
  const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
  for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {
    if (i < firstList.length) {
      result.push(firstList[i]);
    }
    if (i < secondList.length) {
      result.push(secondList[i]);
    }
  }
  return result;
}

const REPORT_HEALTH_STATUS_OPTION_NAME =
  'grpc-node.internal.pick-first.report_health_status';

export class PickFirstLoadBalancer implements LoadBalancer {
  /**
   * The list of subchannels this load balancer is currently attempting to
   * connect to.
   */
  private children: SubchannelChild[] = [];
  /**
   * The current connectivity state of the load balancer.
   */
  private currentState: ConnectivityState = ConnectivityState.IDLE;
  /**
   * The index within the `subchannels` array of the subchannel with the most
   * recently started connection attempt.
   */
  private currentSubchannelIndex = 0;
  /**
   * The currently picked subchannel used for making calls. Populated if
   * and only if the load balancer's current state is READY. In that case,
   * the subchannel's current state is also READY.
   */
  private currentPick: SubchannelInterface | null = null;
  /**
   * Listener callback attached to each subchannel in the `subchannels` list
   * while establishing a connection.
   */
  private subchannelStateListener: ConnectivityStateListener = (
    subchannel,
    previousState,
    newState,
    keepaliveTime,
    errorMessage
  ) => {
    this.onSubchannelStateUpdate(
      subchannel,
      previousState,
      newState,
      errorMessage
    );
  };

  private pickedSubchannelHealthListener: HealthListener = () =>
    this.calculateAndReportNewState();
  /**
   * Timer reference for the timer tracking when to start
   */
  private connectionDelayTimeout: NodeJS.Timeout;

  private triedAllSubchannels = false;

  /**
   * The LB policy enters sticky TRANSIENT_FAILURE mode when all
   * subchannels have failed to connect at least once, and it stays in that
   * mode until a connection attempt is successful. While in sticky TF mode,
   * the LB policy continuously attempts to connect to all of its subchannels.
   */
  private stickyTransientFailureMode = false;

  private reportHealthStatus: boolean;

  /**
   * Indicates whether we called channelControlHelper.requestReresolution since
   * the last call to updateAddressList
   */
  private requestedResolutionSinceLastUpdate = false;

  /**
   * The most recent error reported by any subchannel as it transitioned to
   * TRANSIENT_FAILURE.
   */
  private lastError: string | null = null;

  private latestAddressList: SubchannelAddress[] | null = null;

  /**
   * Load balancer that attempts to connect to each backend in the address list
   * in order, and picks the first one that connects, using it for every
   * request.
   * @param channelControlHelper `ChannelControlHelper` instance provided by
   *     this load balancer's owner.
   */
  constructor(
    private readonly channelControlHelper: ChannelControlHelper,
    options: ChannelOptions
  ) {
    this.connectionDelayTimeout = setTimeout(() => {}, 0);
    clearTimeout(this.connectionDelayTimeout);
    this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
  }

  private allChildrenHaveReportedTF(): boolean {
    return this.children.every(child => child.hasReportedTransientFailure);
  }

  private calculateAndReportNewState() {
    if (this.currentPick) {
      if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
        this.updateState(
          ConnectivityState.TRANSIENT_FAILURE,
          new UnavailablePicker({
            details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`,
          })
        );
      } else {
        this.updateState(
          ConnectivityState.READY,
          new PickFirstPicker(this.currentPick)
        );
      }
    } else if (this.children.length === 0) {
      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
    } else {
      if (this.stickyTransientFailureMode) {
        this.updateState(
          ConnectivityState.TRANSIENT_FAILURE,
          new UnavailablePicker({
            details: `No connection established. Last error: ${this.lastError}`,
          })
        );
      } else {
        this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));
      }
    }
  }

  private requestReresolution() {
    this.requestedResolutionSinceLastUpdate = true;
    this.channelControlHelper.requestReresolution();
  }

  private maybeEnterStickyTransientFailureMode() {
    if (!this.allChildrenHaveReportedTF()) {
      return;
    }
    if (!this.requestedResolutionSinceLastUpdate) {
      /* Each time we get an update we reset each subchannel's
       * hasReportedTransientFailure flag, so the next time we get to this
       * point after that, each subchannel has reported TRANSIENT_FAILURE
       * at least once since then. That is the trigger for requesting
       * reresolution, whether or not the LB policy is already in sticky TF
       * mode. */
      this.requestReresolution();
    }
    if (this.stickyTransientFailureMode) {
      return;
    }
    this.stickyTransientFailureMode = true;
    for (const { subchannel } of this.children) {
      subchannel.startConnecting();
    }
    this.calculateAndReportNewState();
  }

  private removeCurrentPick() {
    if (this.currentPick !== null) {
      /* Unref can cause a state change, which can cause a change in the value
       * of this.currentPick, so we hold a local reference to make sure that
       * does not impact this function. */
      const currentPick = this.currentPick;
      this.currentPick = null;
      currentPick.unref();
      currentPick.removeConnectivityStateListener(this.subchannelStateListener);
      this.channelControlHelper.removeChannelzChild(
        currentPick.getChannelzRef()
      );
      if (this.reportHealthStatus) {
        currentPick.removeHealthStateWatcher(
          this.pickedSubchannelHealthListener
        );
      }
    }
  }

  private onSubchannelStateUpdate(
    subchannel: SubchannelInterface,
    previousState: ConnectivityState,
    newState: ConnectivityState,
    errorMessage?: string
  ) {
    if (this.currentPick?.realSubchannelEquals(subchannel)) {
      if (newState !== ConnectivityState.READY) {
        this.removeCurrentPick();
        this.calculateAndReportNewState();
      }
      return;
    }
    for (const [index, child] of this.children.entries()) {
      if (subchannel.realSubchannelEquals(child.subchannel)) {
        if (newState === ConnectivityState.READY) {
          this.pickSubchannel(child.subchannel);
        }
        if (newState === ConnectivityState.TRANSIENT_FAILURE) {
          child.hasReportedTransientFailure = true;
          if (errorMessage) {
            this.lastError = errorMessage;
          }
          this.maybeEnterStickyTransientFailureMode();
          if (index === this.currentSubchannelIndex) {
            this.startNextSubchannelConnecting(index + 1);
          }
        }
        child.subchannel.startConnecting();
        return;
      }
    }
  }

  private startNextSubchannelConnecting(startIndex: number) {
    clearTimeout(this.connectionDelayTimeout);
    if (this.triedAllSubchannels) {
      return;
    }
    for (const [index, child] of this.children.entries()) {
      if (index >= startIndex) {
        const subchannelState = child.subchannel.getConnectivityState();
        if (
          subchannelState === ConnectivityState.IDLE ||
          subchannelState === ConnectivityState.CONNECTING
        ) {
          this.startConnecting(index);
          return;
        }
      }
    }
    this.triedAllSubchannels = true;
    this.maybeEnterStickyTransientFailureMode();
  }

  /**
   * Have a single subchannel in the `subchannels` list start connecting.
   * @param subchannelIndex The index into the `subchannels` list.
   */
  private startConnecting(subchannelIndex: number) {
    clearTimeout(this.connectionDelayTimeout);
    this.currentSubchannelIndex = subchannelIndex;
    if (
      this.children[subchannelIndex].subchannel.getConnectivityState() ===
      ConnectivityState.IDLE
    ) {
      trace(
        'Start connecting to subchannel with address ' +
          this.children[subchannelIndex].subchannel.getAddress()
      );
      process.nextTick(() => {
        this.children[subchannelIndex]?.subchannel.startConnecting();
      });
    }
    this.connectionDelayTimeout = setTimeout(() => {
      this.startNextSubchannelConnecting(subchannelIndex + 1);
    }, CONNECTION_DELAY_INTERVAL_MS);
    this.connectionDelayTimeout.unref?.();
  }

  private pickSubchannel(subchannel: SubchannelInterface) {
    if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {
      return;
    }
    trace('Pick subchannel with address ' + subchannel.getAddress());
    this.stickyTransientFailureMode = false;
    this.removeCurrentPick();
    this.currentPick = subchannel;
    subchannel.ref();
    if (this.reportHealthStatus) {
      subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
    }
    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
    this.resetSubchannelList();
    clearTimeout(this.connectionDelayTimeout);
    this.calculateAndReportNewState();
  }

  private updateState(newState: ConnectivityState, picker: Picker) {
    trace(
      ConnectivityState[this.currentState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    this.currentState = newState;
    this.channelControlHelper.updateState(newState, picker);
  }

  private resetSubchannelList() {
    for (const child of this.children) {
      if (
        !(
          this.currentPick &&
          child.subchannel.realSubchannelEquals(this.currentPick)
        )
      ) {
        /* The connectivity state listener is the same whether the subchannel
         * is in the list of children or it is the currentPick, so if it is in
         * both, removing it here would cause problems. In particular, that
         * always happens immediately after the subchannel is picked. */
        child.subchannel.removeConnectivityStateListener(
          this.subchannelStateListener
        );
      }
      /* Refs are counted independently for the children list and the
       * currentPick, so we call unref whether or not the child is the
       * currentPick. Channelz child references are also refcounted, so
       * removeChannelzChild can be handled the same way. */
      child.subchannel.unref();
      this.channelControlHelper.removeChannelzChild(
        child.subchannel.getChannelzRef()
      );
    }
    this.currentSubchannelIndex = 0;
    this.children = [];
    this.triedAllSubchannels = false;
    this.requestedResolutionSinceLastUpdate = false;
  }

  private connectToAddressList(addressList: SubchannelAddress[]) {
    const newChildrenList = addressList.map(address => ({
      subchannel: this.channelControlHelper.createSubchannel(address, {}),
      hasReportedTransientFailure: false,
    }));
    trace('connectToAddressList([' + addressList.map(address => subchannelAddressToString(address)) + '])');
    for (const { subchannel } of newChildrenList) {
      if (subchannel.getConnectivityState() === ConnectivityState.READY) {
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        subchannel.addConnectivityStateListener(this.subchannelStateListener);
        this.pickSubchannel(subchannel);
        return;
      }
    }
    /* Ref each subchannel before resetting the list, to ensure that
     * subchannels shared between the list don't drop to 0 refs during the
     * transition. */
    for (const { subchannel } of newChildrenList) {
      subchannel.ref();
      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
    }
    this.resetSubchannelList();
    this.children = newChildrenList;
    for (const { subchannel } of this.children) {
      subchannel.addConnectivityStateListener(this.subchannelStateListener);
    }
    for (const child of this.children) {
      if (
        child.subchannel.getConnectivityState() ===
        ConnectivityState.TRANSIENT_FAILURE
      ) {
        child.hasReportedTransientFailure = true;
      }
    }
    this.startNextSubchannelConnecting(0);
    this.calculateAndReportNewState();
  }

  updateAddressList(
    endpointList: Endpoint[],
    lbConfig: TypedLoadBalancingConfig
  ): void {
    if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
      return;
    }
    /* Previously, an update would be discarded if it was identical to the
     * previous update, to minimize churn. Now the DNS resolver is
     * rate-limited, so that is less of a concern. */
    if (lbConfig.getShuffleAddressList()) {
      endpointList = shuffled(endpointList);
    }
    const rawAddressList = ([] as SubchannelAddress[]).concat(
      ...endpointList.map(endpoint => endpoint.addresses)
    );
    trace('updateAddressList([' + rawAddressList.map(address => subchannelAddressToString(address)) + '])');
    if (rawAddressList.length === 0) {
      throw new Error('No addresses in endpoint list passed to pick_first');
    }
    const addressList = interleaveAddressFamilies(rawAddressList);
    this.latestAddressList = addressList;
    this.connectToAddressList(addressList);
  }

  exitIdle() {
    if (
      this.currentState === ConnectivityState.IDLE &&
      this.latestAddressList
    ) {
      this.connectToAddressList(this.latestAddressList);
    }
  }

  resetBackoff() {
    /* The pick first load balancer does not have a connection backoff, so this
     * does nothing */
  }

  destroy() {
    this.resetSubchannelList();
    this.removeCurrentPick();
  }

  getTypeName(): string {
    return TYPE_NAME;
  }
}

const LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);

/**
 * This class handles the leaf load balancing operations for a single endpoint.
 * It is a thin wrapper around a PickFirstLoadBalancer with a different API
 * that more closely reflects how it will be used as a leaf balancer.
 */
export class LeafLoadBalancer {
  private pickFirstBalancer: PickFirstLoadBalancer;
  private latestState: ConnectivityState = ConnectivityState.IDLE;
  private latestPicker: Picker;
  constructor(
    private endpoint: Endpoint,
    channelControlHelper: ChannelControlHelper,
    options: ChannelOptions
  ) {
    const childChannelControlHelper = createChildChannelControlHelper(
      channelControlHelper,
      {
        updateState: (connectivityState, picker) => {
          this.latestState = connectivityState;
          this.latestPicker = picker;
          channelControlHelper.updateState(connectivityState, picker);
        },
      }
    );
    this.pickFirstBalancer = new PickFirstLoadBalancer(
      childChannelControlHelper,
      { ...options, [REPORT_HEALTH_STATUS_OPTION_NAME]: true }
    );
    this.latestPicker = new QueuePicker(this.pickFirstBalancer);
  }

  startConnecting() {
    this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);
  }

  /**
   * Update the endpoint associated with this LeafLoadBalancer to a new
   * endpoint. Does not trigger connection establishment if a connection
   * attempt is not already in progress.
   * @param newEndpoint
   */
  updateEndpoint(newEndpoint: Endpoint) {
    this.endpoint = newEndpoint;
    if (this.latestState !== ConnectivityState.IDLE) {
      this.startConnecting();
    }
  }

  getConnectivityState() {
    return this.latestState;
  }

  getPicker() {
    return this.latestPicker;
  }

  getEndpoint() {
    return this.endpoint;
  }

  exitIdle() {
    this.pickFirstBalancer.exitIdle();
  }

  destroy() {
    this.pickFirstBalancer.destroy();
  }
}

export function setup(): void {
  registerLoadBalancerType(
    TYPE_NAME,
    PickFirstLoadBalancer,
    PickFirstLoadBalancingConfig
  );
  registerDefaultLoadBalancerType(TYPE_NAME);
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  LoadBalancer,
  ChannelControlHelper,
  TypedLoadBalancingConfig,
  registerLoadBalancerType,
  createChildChannelControlHelper,
} from './load-balancer';
import { ConnectivityState } from './connectivity-state';
import {
  QueuePicker,
  Picker,
  PickArgs,
  UnavailablePicker,
  PickResult,
} from './picker';
import * as logging from './logging';
import { LogVerbosity } from './constants';
import {
  Endpoint,
  endpointEqual,
  endpointToString,
} from './subchannel-address';
import { LeafLoadBalancer } from './load-balancer-pick-first';
import { ChannelOptions } from './channel-options';

const TRACER_NAME = 'round_robin';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const TYPE_NAME = 'round_robin';

class RoundRobinLoadBalancingConfig implements TypedLoadBalancingConfig {
  getLoadBalancerName(): string {
    return TYPE_NAME;
  }

  constructor() {}

  toJsonObject(): object {
    return {
      [TYPE_NAME]: {},
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static createFromJson(obj: any) {
    return new RoundRobinLoadBalancingConfig();
  }
}

class RoundRobinPicker implements Picker {
  constructor(
    private readonly children: { endpoint: Endpoint; picker: Picker }[],
    private nextIndex = 0
  ) {}

  pick(pickArgs: PickArgs): PickResult {
    const childPicker = this.children[this.nextIndex].picker;
    this.nextIndex = (this.nextIndex + 1) % this.children.length;
    return childPicker.pick(pickArgs);
  }

  /**
   * Check what the next subchannel returned would be. Used by the load
   * balancer implementation to preserve this part of the picker state if
   * possible when a subchannel connects or disconnects.
   */
  peekNextEndpoint(): Endpoint {
    return this.children[this.nextIndex].endpoint;
  }
}

export class RoundRobinLoadBalancer implements LoadBalancer {
  private children: LeafLoadBalancer[] = [];

  private currentState: ConnectivityState = ConnectivityState.IDLE;

  private currentReadyPicker: RoundRobinPicker | null = null;

  private updatesPaused = false;

  private childChannelControlHelper: ChannelControlHelper;

  private lastError: string | null = null;

  constructor(
    private readonly channelControlHelper: ChannelControlHelper,
    private readonly options: ChannelOptions
  ) {
    this.childChannelControlHelper = createChildChannelControlHelper(
      channelControlHelper,
      {
        updateState: (connectivityState, picker) => {
          this.calculateAndUpdateState();
        },
      }
    );
  }

  private countChildrenWithState(state: ConnectivityState) {
    return this.children.filter(child => child.getConnectivityState() === state)
      .length;
  }

  private calculateAndUpdateState() {
    if (this.updatesPaused) {
      return;
    }
    if (this.countChildrenWithState(ConnectivityState.READY) > 0) {
      const readyChildren = this.children.filter(
        child => child.getConnectivityState() === ConnectivityState.READY
      );
      let index = 0;
      if (this.currentReadyPicker !== null) {
        const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
        index = readyChildren.findIndex(child =>
          endpointEqual(child.getEndpoint(), nextPickedEndpoint)
        );
        if (index < 0) {
          index = 0;
        }
      }
      this.updateState(
        ConnectivityState.READY,
        new RoundRobinPicker(
          readyChildren.map(child => ({
            endpoint: child.getEndpoint(),
            picker: child.getPicker(),
          })),
          index
        )
      );
    } else if (this.countChildrenWithState(ConnectivityState.CONNECTING) > 0) {
      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));
    } else if (
      this.countChildrenWithState(ConnectivityState.TRANSIENT_FAILURE) > 0
    ) {
      this.updateState(
        ConnectivityState.TRANSIENT_FAILURE,
        new UnavailablePicker({
          details: `No connection established. Last error: ${this.lastError}`,
        })
      );
    } else {
      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
    }
    /* round_robin should keep all children connected, this is how we do that.
     * We can't do this more efficiently in the individual child's updateState
     * callback because that doesn't have a reference to which child the state
     * change is associated with. */
    for (const child of this.children) {
      if (child.getConnectivityState() === ConnectivityState.IDLE) {
        child.exitIdle();
      }
    }
  }

  private updateState(newState: ConnectivityState, picker: Picker) {
    trace(
      ConnectivityState[this.currentState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    if (newState === ConnectivityState.READY) {
      this.currentReadyPicker = picker as RoundRobinPicker;
    } else {
      this.currentReadyPicker = null;
    }
    this.currentState = newState;
    this.channelControlHelper.updateState(newState, picker);
  }

  private resetSubchannelList() {
    for (const child of this.children) {
      child.destroy();
    }
  }

  updateAddressList(
    endpointList: Endpoint[],
    lbConfig: TypedLoadBalancingConfig
  ): void {
    this.resetSubchannelList();
    trace('Connect to endpoint list ' + endpointList.map(endpointToString));
    this.updatesPaused = true;
    this.children = endpointList.map(
      endpoint =>
        new LeafLoadBalancer(
          endpoint,
          this.childChannelControlHelper,
          this.options
        )
    );
    for (const child of this.children) {
      child.startConnecting();
    }
    this.updatesPaused = false;
    this.calculateAndUpdateState();
  }

  exitIdle(): void {
    /* The round_robin LB policy is only in the IDLE state if it has no
     * addresses to try to connect to and it has no picked subchannel.
     * In that case, there is no meaningful action that can be taken here. */
  }
  resetBackoff(): void {
    // This LB policy has no backoff to reset
  }
  destroy(): void {
    this.resetSubchannelList();
  }
  getTypeName(): string {
    return TYPE_NAME;
  }
}

export function setup() {
  registerLoadBalancerType(
    TYPE_NAME,
    RoundRobinLoadBalancer,
    RoundRobinLoadBalancingConfig
  );
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelOptions } from './channel-options';
import { Endpoint, SubchannelAddress } from './subchannel-address';
import { ConnectivityState } from './connectivity-state';
import { Picker } from './picker';
import type { ChannelRef, SubchannelRef } from './channelz';
import { SubchannelInterface } from './subchannel-interface';
import { LoadBalancingConfig } from './service-config';
import { log } from './logging';
import { LogVerbosity } from './constants';

/**
 * A collection of functions associated with a channel that a load balancer
 * can call as necessary.
 */
export interface ChannelControlHelper {
  /**
   * Returns a subchannel connected to the specified address.
   * @param subchannelAddress The address to connect to
   * @param subchannelArgs Extra channel arguments specified by the load balancer
   */
  createSubchannel(
    subchannelAddress: SubchannelAddress,
    subchannelArgs: ChannelOptions
  ): SubchannelInterface;
  /**
   * Passes a new subchannel picker up to the channel. This is called if either
   * the connectivity state changes or if a different picker is needed for any
   * other reason.
   * @param connectivityState New connectivity state
   * @param picker New picker
   */
  updateState(connectivityState: ConnectivityState, picker: Picker): void;
  /**
   * Request new data from the resolver.
   */
  requestReresolution(): void;
  addChannelzChild(child: ChannelRef | SubchannelRef): void;
  removeChannelzChild(child: ChannelRef | SubchannelRef): void;
}

/**
 * Create a child ChannelControlHelper that overrides some methods of the
 * parent while letting others pass through to the parent unmodified. This
 * allows other code to create these children without needing to know about
 * all of the methods to be passed through.
 * @param parent
 * @param overrides
 */
export function createChildChannelControlHelper(
  parent: ChannelControlHelper,
  overrides: Partial<ChannelControlHelper>
): ChannelControlHelper {
  return {
    createSubchannel:
      overrides.createSubchannel?.bind(overrides) ??
      parent.createSubchannel.bind(parent),
    updateState:
      overrides.updateState?.bind(overrides) ?? parent.updateState.bind(parent),
    requestReresolution:
      overrides.requestReresolution?.bind(overrides) ??
      parent.requestReresolution.bind(parent),
    addChannelzChild:
      overrides.addChannelzChild?.bind(overrides) ??
      parent.addChannelzChild.bind(parent),
    removeChannelzChild:
      overrides.removeChannelzChild?.bind(overrides) ??
      parent.removeChannelzChild.bind(parent),
  };
}

/**
 * Tracks one or more connected subchannels and determines which subchannel
 * each request should use.
 */
export interface LoadBalancer {
  /**
   * Gives the load balancer a new list of addresses to start connecting to.
   * The load balancer will start establishing connections with the new list,
   * but will continue using any existing connections until the new connections
   * are established
   * @param endpointList The new list of addresses to connect to
   * @param lbConfig The load balancing config object from the service config,
   *     if one was provided
   */
  updateAddressList(
    endpointList: Endpoint[],
    lbConfig: TypedLoadBalancingConfig,
    attributes: { [key: string]: unknown }
  ): void;
  /**
   * If the load balancer is currently in the IDLE state, start connecting.
   */
  exitIdle(): void;
  /**
   * If the load balancer is currently in the CONNECTING or TRANSIENT_FAILURE
   * state, reset the current connection backoff timeout to its base value and
   * transition to CONNECTING if in TRANSIENT_FAILURE.
   */
  resetBackoff(): void;
  /**
   * The load balancer unrefs all of its subchannels and stops calling methods
   * of its channel control helper.
   */
  destroy(): void;
  /**
   * Get the type name for this load balancer type. Must be constant across an
   * entire load balancer implementation class and must match the name that the
   * balancer implementation class was registered with.
   */
  getTypeName(): string;
}

export interface LoadBalancerConstructor {
  new (
    channelControlHelper: ChannelControlHelper,
    options: ChannelOptions
  ): LoadBalancer;
}

export interface TypedLoadBalancingConfig {
  getLoadBalancerName(): string;
  toJsonObject(): object;
}

export interface TypedLoadBalancingConfigConstructor {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new (...args: any): TypedLoadBalancingConfig;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  createFromJson(obj: any): TypedLoadBalancingConfig;
}

const registeredLoadBalancerTypes: {
  [name: string]: {
    LoadBalancer: LoadBalancerConstructor;
    LoadBalancingConfig: TypedLoadBalancingConfigConstructor;
  };
} = {};

let defaultLoadBalancerType: string | null = null;

export function registerLoadBalancerType(
  typeName: string,
  loadBalancerType: LoadBalancerConstructor,
  loadBalancingConfigType: TypedLoadBalancingConfigConstructor
) {
  registeredLoadBalancerTypes[typeName] = {
    LoadBalancer: loadBalancerType,
    LoadBalancingConfig: loadBalancingConfigType,
  };
}

export function registerDefaultLoadBalancerType(typeName: string) {
  defaultLoadBalancerType = typeName;
}

export function createLoadBalancer(
  config: TypedLoadBalancingConfig,
  channelControlHelper: ChannelControlHelper,
  options: ChannelOptions
): LoadBalancer | null {
  const typeName = config.getLoadBalancerName();
  if (typeName in registeredLoadBalancerTypes) {
    return new registeredLoadBalancerTypes[typeName].LoadBalancer(
      channelControlHelper,
      options
    );
  } else {
    return null;
  }
}

export function isLoadBalancerNameRegistered(typeName: string): boolean {
  return typeName in registeredLoadBalancerTypes;
}

export function parseLoadBalancingConfig(
  rawConfig: LoadBalancingConfig
): TypedLoadBalancingConfig {
  const keys = Object.keys(rawConfig);
  if (keys.length !== 1) {
    throw new Error(
      'Provided load balancing config has multiple conflicting entries'
    );
  }
  const typeName = keys[0];
  if (typeName in registeredLoadBalancerTypes) {
    try {
      return registeredLoadBalancerTypes[
        typeName
      ].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
    } catch (e) {
      throw new Error(`${typeName}: ${(e as Error).message}`);
    }
  } else {
    throw new Error(`Unrecognized load balancing config name ${typeName}`);
  }
}

export function getDefaultConfig() {
  if (!defaultLoadBalancerType) {
    throw new Error('No default load balancer type registered');
  }
  return new registeredLoadBalancerTypes[
    defaultLoadBalancerType
  ]!.LoadBalancingConfig();
}

export function selectLbConfigFromList(
  configs: LoadBalancingConfig[],
  fallbackTodefault = false
): TypedLoadBalancingConfig | null {
  for (const config of configs) {
    try {
      return parseLoadBalancingConfig(config);
    } catch (e) {
      log(
        LogVerbosity.DEBUG,
        'Config parsing failed with error',
        (e as Error).message
      );
      continue;
    }
  }
  if (fallbackTodefault) {
    if (defaultLoadBalancerType) {
      return new registeredLoadBalancerTypes[
        defaultLoadBalancerType
      ]!.LoadBalancingConfig();
    } else {
      return null;
    }
  } else {
    return null;
  }
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { CallCredentials } from './call-credentials';
import {
  Call,
  DeadlineInfoProvider,
  InterceptingListener,
  MessageContext,
  StatusObject,
} from './call-interface';
import { SubchannelCall } from './subchannel-call';
import { ConnectivityState } from './connectivity-state';
import { LogVerbosity, Status } from './constants';
import { Deadline, formatDateDifference, getDeadlineTimeoutString } from './deadline';
import { InternalChannel } from './internal-channel';
import { Metadata } from './metadata';
import { PickResultType } from './picker';
import { CallConfig } from './resolver';
import { splitHostPort } from './uri-parser';
import * as logging from './logging';
import { restrictControlPlaneStatusCode } from './control-plane-status';
import * as http2 from 'http2';

const TRACER_NAME = 'load_balancing_call';

export type RpcProgress = 'NOT_STARTED' | 'DROP' | 'REFUSED' | 'PROCESSED';

export interface StatusObjectWithProgress extends StatusObject {
  progress: RpcProgress;
}

export interface LoadBalancingCallInterceptingListener
  extends InterceptingListener {
  onReceiveStatus(status: StatusObjectWithProgress): void;
}

export class LoadBalancingCall implements Call, DeadlineInfoProvider {
  private child: SubchannelCall | null = null;
  private readPending = false;
  private pendingMessage: { context: MessageContext; message: Buffer } | null =
    null;
  private pendingHalfClose = false;
  private ended = false;
  private serviceUrl: string;
  private metadata: Metadata | null = null;
  private listener: InterceptingListener | null = null;
  private onCallEnded: ((statusCode: Status) => void) | null = null;
  private startTime: Date;
  private childStartTime: Date | null = null;
  constructor(
    private readonly channel: InternalChannel,
    private readonly callConfig: CallConfig,
    private readonly methodName: string,
    private readonly host: string,
    private readonly credentials: CallCredentials,
    private readonly deadline: Deadline,
    private readonly callNumber: number
  ) {
    const splitPath: string[] = this.methodName.split('/');
    let serviceName = '';
    /* The standard path format is "/{serviceName}/{methodName}", so if we split
     * by '/', the first item should be empty and the second should be the
     * service name */
    if (splitPath.length >= 2) {
      serviceName = splitPath[1];
    }
    const hostname = splitHostPort(this.host)?.host ?? 'localhost';
    /* Currently, call credentials are only allowed on HTTPS connections, so we
     * can assume that the scheme is "https" */
    this.serviceUrl = `https://${hostname}/${serviceName}`;
    this.startTime = new Date();
  }
  getDeadlineInfo(): string[] {
    const deadlineInfo: string[] = [];
    if (this.childStartTime) {
      if (this.childStartTime > this.startTime) {
        if (this.metadata?.getOptions().waitForReady) {
          deadlineInfo.push('wait_for_ready');
        }
        deadlineInfo.push(`LB pick: ${formatDateDifference(this.startTime, this.childStartTime)}`);
      }
      deadlineInfo.push(...this.child!.getDeadlineInfo());
      return deadlineInfo;
    } else {
      if (this.metadata?.getOptions().waitForReady) {
        deadlineInfo.push('wait_for_ready');
      }
      deadlineInfo.push('Waiting for LB pick');
    }
    return deadlineInfo;
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '[' + this.callNumber + '] ' + text
    );
  }

  private outputStatus(status: StatusObject, progress: RpcProgress) {
    if (!this.ended) {
      this.ended = true;
      this.trace(
        'ended with status: code=' +
          status.code +
          ' details="' +
          status.details +
          '" start time=' +
          this.startTime.toISOString()
      );
      const finalStatus = { ...status, progress };
      this.listener?.onReceiveStatus(finalStatus);
      this.onCallEnded?.(finalStatus.code);
    }
  }

  doPick() {
    if (this.ended) {
      return;
    }
    if (!this.metadata) {
      throw new Error('doPick called before start');
    }
    this.trace('Pick called');
    const finalMetadata = this.metadata.clone();
    const pickResult = this.channel.doPick(
      finalMetadata,
      this.callConfig.pickInformation
    );
    const subchannelString = pickResult.subchannel
      ? '(' +
        pickResult.subchannel.getChannelzRef().id +
        ') ' +
        pickResult.subchannel.getAddress()
      : '' + pickResult.subchannel;
    this.trace(
      'Pick result: ' +
        PickResultType[pickResult.pickResultType] +
        ' subchannel: ' +
        subchannelString +
        ' status: ' +
        pickResult.status?.code +
        ' ' +
        pickResult.status?.details
    );
    switch (pickResult.pickResultType) {
      case PickResultType.COMPLETE:
        this.credentials
          .generateMetadata({ service_url: this.serviceUrl })
          .then(
            credsMetadata => {
              /* If this call was cancelled (e.g. by the deadline) before
               * metadata generation finished, we shouldn't do anything with
               * it. */
              if (this.ended) {
                this.trace(
                  'Credentials metadata generation finished after call ended'
                );
                return;
              }
              finalMetadata.merge(credsMetadata);
              if (finalMetadata.get('authorization').length > 1) {
                this.outputStatus(
                  {
                    code: Status.INTERNAL,
                    details:
                      '"authorization" metadata cannot have multiple values',
                    metadata: new Metadata(),
                  },
                  'PROCESSED'
                );
              }
              if (
                pickResult.subchannel!.getConnectivityState() !==
                ConnectivityState.READY
              ) {
                this.trace(
                  'Picked subchannel ' +
                    subchannelString +
                    ' has state ' +
                    ConnectivityState[
                      pickResult.subchannel!.getConnectivityState()
                    ] +
                    ' after getting credentials metadata. Retrying pick'
                );
                this.doPick();
                return;
              }

              if (this.deadline !== Infinity) {
                finalMetadata.set(
                  'grpc-timeout',
                  getDeadlineTimeoutString(this.deadline)
                );
              }
              try {
                this.child = pickResult
                  .subchannel!.getRealSubchannel()
                  .createCall(finalMetadata, this.host, this.methodName, {
                    onReceiveMetadata: metadata => {
                      this.trace('Received metadata');
                      this.listener!.onReceiveMetadata(metadata);
                    },
                    onReceiveMessage: message => {
                      this.trace('Received message');
                      this.listener!.onReceiveMessage(message);
                    },
                    onReceiveStatus: status => {
                      this.trace('Received status');
                      if (
                        status.rstCode ===
                        http2.constants.NGHTTP2_REFUSED_STREAM
                      ) {
                        this.outputStatus(status, 'REFUSED');
                      } else {
                        this.outputStatus(status, 'PROCESSED');
                      }
                    },
                  });
                this.childStartTime = new Date();
              } catch (error) {
                this.trace(
                  'Failed to start call on picked subchannel ' +
                    subchannelString +
                    ' with error ' +
                    (error as Error).message
                );
                this.outputStatus(
                  {
                    code: Status.INTERNAL,
                    details:
                      'Failed to start HTTP/2 stream with error ' +
                      (error as Error).message,
                    metadata: new Metadata(),
                  },
                  'NOT_STARTED'
                );
                return;
              }
              this.callConfig.onCommitted?.();
              pickResult.onCallStarted?.();
              this.onCallEnded = pickResult.onCallEnded;
              this.trace(
                'Created child call [' + this.child.getCallNumber() + ']'
              );
              if (this.readPending) {
                this.child.startRead();
              }
              if (this.pendingMessage) {
                this.child.sendMessageWithContext(
                  this.pendingMessage.context,
                  this.pendingMessage.message
                );
              }
              if (this.pendingHalfClose) {
                this.child.halfClose();
              }
            },
            (error: Error & { code: number }) => {
              // We assume the error code isn't 0 (Status.OK)
              const { code, details } = restrictControlPlaneStatusCode(
                typeof error.code === 'number' ? error.code : Status.UNKNOWN,
                `Getting metadata from plugin failed with error: ${error.message}`
              );
              this.outputStatus(
                {
                  code: code,
                  details: details,
                  metadata: new Metadata(),
                },
                'PROCESSED'
              );
            }
          );
        break;
      case PickResultType.DROP:
        const { code, details } = restrictControlPlaneStatusCode(
          pickResult.status!.code,
          pickResult.status!.details
        );
        setImmediate(() => {
          this.outputStatus(
            { code, details, metadata: pickResult.status!.metadata },
            'DROP'
          );
        });
        break;
      case PickResultType.TRANSIENT_FAILURE:
        if (this.metadata.getOptions().waitForReady) {
          this.channel.queueCallForPick(this);
        } else {
          const { code, details } = restrictControlPlaneStatusCode(
            pickResult.status!.code,
            pickResult.status!.details
          );
          setImmediate(() => {
            this.outputStatus(
              { code, details, metadata: pickResult.status!.metadata },
              'PROCESSED'
            );
          });
        }
        break;
      case PickResultType.QUEUE:
        this.channel.queueCallForPick(this);
    }
  }

  cancelWithStatus(status: Status, details: string): void {
    this.trace(
      'cancelWithStatus code: ' + status + ' details: "' + details + '"'
    );
    this.child?.cancelWithStatus(status, details);
    this.outputStatus(
      { code: status, details: details, metadata: new Metadata() },
      'PROCESSED'
    );
  }
  getPeer(): string {
    return this.child?.getPeer() ?? this.channel.getTarget();
  }
  start(
    metadata: Metadata,
    listener: LoadBalancingCallInterceptingListener
  ): void {
    this.trace('start called');
    this.listener = listener;
    this.metadata = metadata;
    this.doPick();
  }
  sendMessageWithContext(context: MessageContext, message: Buffer): void {
    this.trace('write() called with message of length ' + message.length);
    if (this.child) {
      this.child.sendMessageWithContext(context, message);
    } else {
      this.pendingMessage = { context, message };
    }
  }
  startRead(): void {
    this.trace('startRead called');
    if (this.child) {
      this.child.startRead();
    } else {
      this.readPending = true;
    }
  }
  halfClose(): void {
    this.trace('halfClose called');
    if (this.child) {
      this.child.halfClose();
    } else {
      this.pendingHalfClose = true;
    }
  }
  setCredentials(credentials: CallCredentials): void {
    throw new Error('Method not implemented.');
  }

  getCallNumber(): number {
    return this.callNumber;
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { LogVerbosity } from './constants';
import { pid } from 'process';

const clientVersion = require('../../package.json').version;

const DEFAULT_LOGGER: Partial<Console> = {
  error: (message?: any, ...optionalParams: any[]) => {
    console.error('E ' + message, ...optionalParams);
  },
  info: (message?: any, ...optionalParams: any[]) => {
    console.error('I ' + message, ...optionalParams);
  },
  debug: (message?: any, ...optionalParams: any[]) => {
    console.error('D ' + message, ...optionalParams);
  },
};

let _logger: Partial<Console> = DEFAULT_LOGGER;
let _logVerbosity: LogVerbosity = LogVerbosity.ERROR;

const verbosityString =
  process.env.GRPC_NODE_VERBOSITY ?? process.env.GRPC_VERBOSITY ?? '';

switch (verbosityString.toUpperCase()) {
  case 'DEBUG':
    _logVerbosity = LogVerbosity.DEBUG;
    break;
  case 'INFO':
    _logVerbosity = LogVerbosity.INFO;
    break;
  case 'ERROR':
    _logVerbosity = LogVerbosity.ERROR;
    break;
  case 'NONE':
    _logVerbosity = LogVerbosity.NONE;
    break;
  default:
  // Ignore any other values
}

export const getLogger = (): Partial<Console> => {
  return _logger;
};

export const setLogger = (logger: Partial<Console>): void => {
  _logger = logger;
};

export const setLoggerVerbosity = (verbosity: LogVerbosity): void => {
  _logVerbosity = verbosity;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const log = (severity: LogVerbosity, ...args: any[]): void => {
  let logFunction: typeof DEFAULT_LOGGER.error;
  if (severity >= _logVerbosity) {
    switch (severity) {
      case LogVerbosity.DEBUG:
        logFunction = _logger.debug;
        break;
      case LogVerbosity.INFO:
        logFunction = _logger.info;
        break;
      case LogVerbosity.ERROR:
        logFunction = _logger.error;
        break;
    }
    /* Fall back to _logger.error when other methods are not available for
     * compatiblity with older behavior that always logged to _logger.error */
    if (!logFunction) {
      logFunction = _logger.error;
    }
    if (logFunction) {
      logFunction.bind(_logger)(...args);
    }
  }
};

const tracersString =
  process.env.GRPC_NODE_TRACE ?? process.env.GRPC_TRACE ?? '';
const enabledTracers = new Set<string>();
const disabledTracers = new Set<string>();
for (const tracerName of tracersString.split(',')) {
  if (tracerName.startsWith('-')) {
    disabledTracers.add(tracerName.substring(1));
  } else {
    enabledTracers.add(tracerName);
  }
}
const allEnabled = enabledTracers.has('all');

export function trace(
  severity: LogVerbosity,
  tracer: string,
  text: string
): void {
  if (isTracerEnabled(tracer)) {
    log(
      severity,
      new Date().toISOString() +
        ' | v' +
        clientVersion +
        ' ' +
        pid +
        ' | ' +
        tracer +
        ' | ' +
        text
    );
  }
}

export function isTracerEnabled(tracer: string): boolean {
  return (
    !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer))
  );
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import { Client } from './client';
import { UntypedServiceImplementation } from './server';

export interface Serialize<T> {
  (value: T): Buffer;
}

export interface Deserialize<T> {
  (bytes: Buffer): T;
}

export interface ClientMethodDefinition<RequestType, ResponseType> {
  path: string;
  requestStream: boolean;
  responseStream: boolean;
  requestSerialize: Serialize<RequestType>;
  responseDeserialize: Deserialize<ResponseType>;
  originalName?: string;
}

export interface ServerMethodDefinition<RequestType, ResponseType> {
  path: string;
  requestStream: boolean;
  responseStream: boolean;
  responseSerialize: Serialize<ResponseType>;
  requestDeserialize: Deserialize<RequestType>;
  originalName?: string;
}

export interface MethodDefinition<RequestType, ResponseType>
  extends ClientMethodDefinition<RequestType, ResponseType>,
    ServerMethodDefinition<RequestType, ResponseType> {}

/* eslint-disable @typescript-eslint/no-explicit-any */
export type ServiceDefinition<
  ImplementationType = UntypedServiceImplementation
> = {
  readonly [index in keyof ImplementationType]: MethodDefinition<any, any>;
};
/* eslint-enable @typescript-eslint/no-explicit-any */

export interface ProtobufTypeDefinition {
  format: string;
  type: object;
  fileDescriptorProtos: Buffer[];
}

export interface PackageDefinition {
  [index: string]: ServiceDefinition | ProtobufTypeDefinition;
}

/**
 * Map with short names for each of the requester maker functions. Used in
 * makeClientConstructor
 * @private
 */
const requesterFuncs = {
  unary: Client.prototype.makeUnaryRequest,
  server_stream: Client.prototype.makeServerStreamRequest,
  client_stream: Client.prototype.makeClientStreamRequest,
  bidi: Client.prototype.makeBidiStreamRequest,
};

export interface ServiceClient extends Client {
  [methodName: string]: Function;
}

export interface ServiceClientConstructor {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ChannelOptions>
  ): ServiceClient;
  service: ServiceDefinition;
  serviceName: string;
}

/**
 * Returns true, if given key is included in the blacklisted
 * keys.
 * @param key key for check, string.
 */
function isPrototypePolluted(key: string): boolean {
  return ['__proto__', 'prototype', 'constructor'].includes(key);
}

/**
 * Creates a constructor for a client with the given methods, as specified in
 * the methods argument. The resulting class will have an instance method for
 * each method in the service, which is a partial application of one of the
 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
 * arguments predefined.
 * @param methods An object mapping method names to
 *     method attributes
 * @param serviceName The fully qualified name of the service
 * @param classOptions An options object.
 * @return New client constructor, which is a subclass of
 *     {@link grpc.Client}, and has the same arguments as that constructor.
 */
export function makeClientConstructor(
  methods: ServiceDefinition,
  serviceName: string,
  classOptions?: {}
): ServiceClientConstructor {
  if (!classOptions) {
    classOptions = {};
  }

  class ServiceClientImpl extends Client implements ServiceClient {
    static service: ServiceDefinition;
    static serviceName: string;
    [methodName: string]: Function;
  }

  Object.keys(methods).forEach(name => {
    if (isPrototypePolluted(name)) {
      return;
    }
    const attrs = methods[name];
    let methodType: keyof typeof requesterFuncs;
    // TODO(murgatroid99): Verify that we don't need this anymore
    if (typeof name === 'string' && name.charAt(0) === '$') {
      throw new Error('Method names cannot start with $');
    }
    if (attrs.requestStream) {
      if (attrs.responseStream) {
        methodType = 'bidi';
      } else {
        methodType = 'client_stream';
      }
    } else {
      if (attrs.responseStream) {
        methodType = 'server_stream';
      } else {
        methodType = 'unary';
      }
    }
    const serialize = attrs.requestSerialize;
    const deserialize = attrs.responseDeserialize;
    const methodFunc = partial(
      requesterFuncs[methodType],
      attrs.path,
      serialize,
      deserialize
    );
    ServiceClientImpl.prototype[name] = methodFunc;
    // Associate all provided attributes with the method
    Object.assign(ServiceClientImpl.prototype[name], attrs);
    if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
      ServiceClientImpl.prototype[attrs.originalName] =
        ServiceClientImpl.prototype[name];
    }
  });

  ServiceClientImpl.service = methods;
  ServiceClientImpl.serviceName = serviceName;

  return ServiceClientImpl;
}

function partial(
  fn: Function,
  path: string,
  serialize: Function,
  deserialize: Function
): Function {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return function (this: any, ...args: any[]) {
    return fn.call(this, path, serialize, deserialize, ...args);
  };
}

export interface GrpcObject {
  [index: string]:
    | GrpcObject
    | ServiceClientConstructor
    | ProtobufTypeDefinition;
}

function isProtobufTypeDefinition(
  obj: ServiceDefinition | ProtobufTypeDefinition
): obj is ProtobufTypeDefinition {
  return 'format' in obj;
}

/**
 * Load a gRPC package definition as a gRPC object hierarchy.
 * @param packageDef The package definition object.
 * @return The resulting gRPC object.
 */
export function loadPackageDefinition(
  packageDef: PackageDefinition
): GrpcObject {
  const result: GrpcObject = {};
  for (const serviceFqn in packageDef) {
    if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
      const service = packageDef[serviceFqn];
      const nameComponents = serviceFqn.split('.');
      if (nameComponents.some((comp: string) => isPrototypePolluted(comp))) {
        continue;
      }
      const serviceName = nameComponents[nameComponents.length - 1];
      let current = result;
      for (const packageName of nameComponents.slice(0, -1)) {
        if (!current[packageName]) {
          current[packageName] = {};
        }
        current = current[packageName] as GrpcObject;
      }
      if (isProtobufTypeDefinition(service)) {
        current[serviceName] = service;
      } else {
        current[serviceName] = makeClientConstructor(service, serviceName, {});
      }
    }
  }
  return result;
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as http2 from 'http2';
import { log } from './logging';
import { LogVerbosity } from './constants';
import { getErrorMessage } from './error';
const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;

export type MetadataValue = string | Buffer;
export type MetadataObject = Map<string, MetadataValue[]>;

function isLegalKey(key: string): boolean {
  return LEGAL_KEY_REGEX.test(key);
}

function isLegalNonBinaryValue(value: string): boolean {
  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
}

function isBinaryKey(key: string): boolean {
  return key.endsWith('-bin');
}

function isCustomMetadata(key: string): boolean {
  return !key.startsWith('grpc-');
}

function normalizeKey(key: string): string {
  return key.toLowerCase();
}

function validate(key: string, value?: MetadataValue): void {
  if (!isLegalKey(key)) {
    throw new Error('Metadata key "' + key + '" contains illegal characters');
  }

  if (value !== null && value !== undefined) {
    if (isBinaryKey(key)) {
      if (!Buffer.isBuffer(value)) {
        throw new Error("keys that end with '-bin' must have Buffer values");
      }
    } else {
      if (Buffer.isBuffer(value)) {
        throw new Error(
          "keys that don't end with '-bin' must have String values"
        );
      }
      if (!isLegalNonBinaryValue(value)) {
        throw new Error(
          'Metadata string value "' + value + '" contains illegal characters'
        );
      }
    }
  }
}

export interface MetadataOptions {
  /* Signal that the request is idempotent. Defaults to false */
  idempotentRequest?: boolean;
  /* Signal that the call should not return UNAVAILABLE before it has
   * started. Defaults to false. */
  waitForReady?: boolean;
  /* Signal that the call is cacheable. GRPC is free to use GET verb.
   * Defaults to false */
  cacheableRequest?: boolean;
  /* Signal that the initial metadata should be corked. Defaults to false. */
  corked?: boolean;
}

/**
 * A class for storing metadata. Keys are normalized to lowercase ASCII.
 */
export class Metadata {
  protected internalRepr: MetadataObject = new Map<string, MetadataValue[]>();
  private options: MetadataOptions;

  constructor(options: MetadataOptions = {}) {
    this.options = options;
  }

  /**
   * Sets the given value for the given key by replacing any other values
   * associated with that key. Normalizes the key.
   * @param key The key to whose value should be set.
   * @param value The value to set. Must be a buffer if and only
   *   if the normalized key ends with '-bin'.
   */
  set(key: string, value: MetadataValue): void {
    key = normalizeKey(key);
    validate(key, value);
    this.internalRepr.set(key, [value]);
  }

  /**
   * Adds the given value for the given key by appending to a list of previous
   * values associated with that key. Normalizes the key.
   * @param key The key for which a new value should be appended.
   * @param value The value to add. Must be a buffer if and only
   *   if the normalized key ends with '-bin'.
   */
  add(key: string, value: MetadataValue): void {
    key = normalizeKey(key);
    validate(key, value);

    const existingValue: MetadataValue[] | undefined =
      this.internalRepr.get(key);

    if (existingValue === undefined) {
      this.internalRepr.set(key, [value]);
    } else {
      existingValue.push(value);
    }
  }

  /**
   * Removes the given key and any associated values. Normalizes the key.
   * @param key The key whose values should be removed.
   */
  remove(key: string): void {
    key = normalizeKey(key);
    // validate(key);
    this.internalRepr.delete(key);
  }

  /**
   * Gets a list of all values associated with the key. Normalizes the key.
   * @param key The key whose value should be retrieved.
   * @return A list of values associated with the given key.
   */
  get(key: string): MetadataValue[] {
    key = normalizeKey(key);
    // validate(key);
    return this.internalRepr.get(key) || [];
  }

  /**
   * Gets a plain object mapping each key to the first value associated with it.
   * This reflects the most common way that people will want to see metadata.
   * @return A key/value mapping of the metadata.
   */
  getMap(): { [key: string]: MetadataValue } {
    const result: { [key: string]: MetadataValue } = {};

    for (const [key, values] of this.internalRepr) {
      if (values.length > 0) {
        const v = values[0];
        result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
      }
    }
    return result;
  }

  /**
   * Clones the metadata object.
   * @return The newly cloned object.
   */
  clone(): Metadata {
    const newMetadata = new Metadata(this.options);
    const newInternalRepr = newMetadata.internalRepr;

    for (const [key, value] of this.internalRepr) {
      const clonedValue: MetadataValue[] = value.map(v => {
        if (Buffer.isBuffer(v)) {
          return Buffer.from(v);
        } else {
          return v;
        }
      });

      newInternalRepr.set(key, clonedValue);
    }

    return newMetadata;
  }

  /**
   * Merges all key-value pairs from a given Metadata object into this one.
   * If both this object and the given object have values in the same key,
   * values from the other Metadata object will be appended to this object's
   * values.
   * @param other A Metadata object.
   */
  merge(other: Metadata): void {
    for (const [key, values] of other.internalRepr) {
      const mergedValue: MetadataValue[] = (
        this.internalRepr.get(key) || []
      ).concat(values);

      this.internalRepr.set(key, mergedValue);
    }
  }

  setOptions(options: MetadataOptions) {
    this.options = options;
  }

  getOptions(): MetadataOptions {
    return this.options;
  }

  /**
   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
   */
  toHttp2Headers(): http2.OutgoingHttpHeaders {
    // NOTE: Node <8.9 formats http2 headers incorrectly.
    const result: http2.OutgoingHttpHeaders = {};

    for (const [key, values] of this.internalRepr) {
      // We assume that the user's interaction with this object is limited to
      // through its public API (i.e. keys and values are already validated).
      result[key] = values.map(bufToString);
    }

    return result;
  }

  /**
   * This modifies the behavior of JSON.stringify to show an object
   * representation of the metadata map.
   */
  toJSON() {
    const result: { [key: string]: MetadataValue[] } = {};
    for (const [key, values] of this.internalRepr) {
      result[key] = values;
    }
    return result;
  }

  /**
   * Returns a new Metadata object based fields in a given IncomingHttpHeaders
   * object.
   * @param headers An IncomingHttpHeaders object.
   */
  static fromHttp2Headers(headers: http2.IncomingHttpHeaders): Metadata {
    const result = new Metadata();
    for (const key of Object.keys(headers)) {
      // Reserved headers (beginning with `:`) are not valid keys.
      if (key.charAt(0) === ':') {
        continue;
      }

      const values = headers[key];

      try {
        if (isBinaryKey(key)) {
          if (Array.isArray(values)) {
            values.forEach(value => {
              result.add(key, Buffer.from(value, 'base64'));
            });
          } else if (values !== undefined) {
            if (isCustomMetadata(key)) {
              values.split(',').forEach(v => {
                result.add(key, Buffer.from(v.trim(), 'base64'));
              });
            } else {
              result.add(key, Buffer.from(values, 'base64'));
            }
          }
        } else {
          if (Array.isArray(values)) {
            values.forEach(value => {
              result.add(key, value);
            });
          } else if (values !== undefined) {
            result.add(key, values);
          }
        }
      } catch (error) {
        const message = `Failed to add metadata entry ${key}: ${values}. ${getErrorMessage(
          error
        )}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
        log(LogVerbosity.ERROR, message);
      }
    }

    return result;
  }
}

const bufToString = (val: string | Buffer): string => {
  return Buffer.isBuffer(val) ? val.toString('base64') : val;
};
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { Readable, Writable } from 'stream';
import { EmitterAugmentation1 } from './events';

/* eslint-disable @typescript-eslint/no-explicit-any */

export type WriteCallback = (error: Error | null | undefined) => void;

export interface IntermediateObjectReadable<T> extends Readable {
  read(size?: number): any & T;
}

export type ObjectReadable<T> = {
  read(size?: number): T;
} & EmitterAugmentation1<'data', T> &
  IntermediateObjectReadable<T>;

export interface IntermediateObjectWritable<T> extends Writable {
  _write(chunk: any & T, encoding: string, callback: Function): void;
  write(chunk: any & T, cb?: WriteCallback): boolean;
  write(chunk: any & T, encoding?: any, cb?: WriteCallback): boolean;
  setDefaultEncoding(encoding: string): this;
  end(): ReturnType<Writable['end']> extends Writable ? this : void;
  end(
    chunk: any & T,
    cb?: Function
  ): ReturnType<Writable['end']> extends Writable ? this : void;
  end(
    chunk: any & T,
    encoding?: any,
    cb?: Function
  ): ReturnType<Writable['end']> extends Writable ? this : void;
}

export interface ObjectWritable<T> extends IntermediateObjectWritable<T> {
  _write(chunk: T, encoding: string, callback: Function): void;
  write(chunk: T, cb?: Function): boolean;
  write(chunk: T, encoding?: any, cb?: Function): boolean;
  setDefaultEncoding(encoding: string): this;
  end(): ReturnType<Writable['end']> extends Writable ? this : void;
  end(
    chunk: T,
    cb?: Function
  ): ReturnType<Writable['end']> extends Writable ? this : void;
  end(
    chunk: T,
    encoding?: any,
    cb?: Function
  ): ReturnType<Writable['end']> extends Writable ? this : void;
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { StatusObject } from './call-interface';
import { Metadata } from './metadata';
import { Status } from './constants';
import { LoadBalancer } from './load-balancer';
import { SubchannelInterface } from './subchannel-interface';

export enum PickResultType {
  COMPLETE,
  QUEUE,
  TRANSIENT_FAILURE,
  DROP,
}

export interface PickResult {
  pickResultType: PickResultType;
  /**
   * The subchannel to use as the transport for the call. Only meaningful if
   * `pickResultType` is COMPLETE. If null, indicates that the call should be
   * dropped.
   */
  subchannel: SubchannelInterface | null;
  /**
   * The status object to end the call with. Populated if and only if
   * `pickResultType` is TRANSIENT_FAILURE.
   */
  status: StatusObject | null;
  onCallStarted: (() => void) | null;
  onCallEnded: ((statusCode: Status) => void) | null;
}

export interface CompletePickResult extends PickResult {
  pickResultType: PickResultType.COMPLETE;
  subchannel: SubchannelInterface | null;
  status: null;
  onCallStarted: (() => void) | null;
  onCallEnded: ((statusCode: Status) => void) | null;
}

export interface QueuePickResult extends PickResult {
  pickResultType: PickResultType.QUEUE;
  subchannel: null;
  status: null;
  onCallStarted: null;
  onCallEnded: null;
}

export interface TransientFailurePickResult extends PickResult {
  pickResultType: PickResultType.TRANSIENT_FAILURE;
  subchannel: null;
  status: StatusObject;
  onCallStarted: null;
  onCallEnded: null;
}

export interface DropCallPickResult extends PickResult {
  pickResultType: PickResultType.DROP;
  subchannel: null;
  status: StatusObject;
  onCallStarted: null;
  onCallEnded: null;
}

export interface PickArgs {
  metadata: Metadata;
  extraPickInfo: { [key: string]: string };
}

/**
 * A proxy object representing the momentary state of a load balancer. Picks
 * subchannels or returns other information based on that state. Should be
 * replaced every time the load balancer changes state.
 */
export interface Picker {
  pick(pickArgs: PickArgs): PickResult;
}

/**
 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
 * state. Always responds to every pick request with an UNAVAILABLE status.
 */
export class UnavailablePicker implements Picker {
  private status: StatusObject;
  constructor(status?: Partial<StatusObject>) {
    this.status = {
      code: Status.UNAVAILABLE,
      details: 'No connection established',
      metadata: new Metadata(),
      ...status,
    };
  }
  pick(pickArgs: PickArgs): TransientFailurePickResult {
    return {
      pickResultType: PickResultType.TRANSIENT_FAILURE,
      subchannel: null,
      status: this.status,
      onCallStarted: null,
      onCallEnded: null,
    };
  }
}

/**
 * A standard picker representing a load balancer in the IDLE or CONNECTING
 * state. Always responds to every pick request with a QUEUE pick result
 * indicating that the pick should be tried again with the next `Picker`. Also
 * reports back to the load balancer that a connection should be established
 * once any pick is attempted.
 * If the childPicker is provided, delegate to it instead of returning the
 * hardcoded QUEUE pick result, but still calls exitIdle.
 */
export class QueuePicker {
  private calledExitIdle = false;
  // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
  constructor(
    private loadBalancer: LoadBalancer,
    private childPicker?: Picker
  ) {}

  pick(pickArgs: PickArgs): PickResult {
    if (!this.calledExitIdle) {
      process.nextTick(() => {
        this.loadBalancer.exitIdle();
      });
      this.calledExitIdle = true;
    }
    if (this.childPicker) {
      return this.childPicker.pick(pickArgs);
    } else {
      return {
        pickResultType: PickResultType.QUEUE,
        subchannel: null,
        status: null,
        onCallStarted: null,
        onCallEnded: null,
      };
    }
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  Resolver,
  ResolverListener,
  registerResolver,
  registerDefaultScheme,
} from './resolver';
import { promises as dns } from 'node:dns';
import { extractAndSelectServiceConfig, ServiceConfig } from './service-config';
import { Status } from './constants';
import { StatusObject } from './call-interface';
import { Metadata } from './metadata';
import * as logging from './logging';
import { LogVerbosity } from './constants';
import { Endpoint, TcpSubchannelAddress } from './subchannel-address';
import { GrpcUri, uriToString, splitHostPort } from './uri-parser';
import { isIPv6, isIPv4 } from 'net';
import { ChannelOptions } from './channel-options';
import { BackoffOptions, BackoffTimeout } from './backoff-timeout';
import { GRPC_NODE_USE_ALTERNATIVE_RESOLVER } from './environment';

const TRACER_NAME = 'dns_resolver';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
export const DEFAULT_PORT = 443;

const DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30_000;

/**
 * Resolver implementation that handles DNS names and IP addresses.
 */
class DnsResolver implements Resolver {
  private readonly ipResult: Endpoint[] | null;
  private readonly dnsHostname: string | null;
  private readonly port: number | null;
  /**
   * Minimum time between resolutions, measured as the time between starting
   * successive resolution requests. Only applies to successful resolutions.
   * Failures are handled by the backoff timer.
   */
  private readonly minTimeBetweenResolutionsMs: number;
  private pendingLookupPromise: Promise<TcpSubchannelAddress[]> | null = null;
  private pendingTxtPromise: Promise<string[][]> | null = null;
  private latestLookupResult: Endpoint[] | null = null;
  private latestServiceConfig: ServiceConfig | null = null;
  private latestServiceConfigError: StatusObject | null = null;
  private percentage: number;
  private defaultResolutionError: StatusObject;
  private backoff: BackoffTimeout;
  private continueResolving = false;
  private nextResolutionTimer: NodeJS.Timeout;
  private isNextResolutionTimerRunning = false;
  private isServiceConfigEnabled = true;
  private returnedIpResult = false;
  private alternativeResolver = new dns.Resolver();

  constructor(
    private target: GrpcUri,
    private listener: ResolverListener,
    channelOptions: ChannelOptions
  ) {
    trace('Resolver constructed for target ' + uriToString(target));
    if (target.authority) {
      this.alternativeResolver.setServers([target.authority]);
    }
    const hostPort = splitHostPort(target.path);
    if (hostPort === null) {
      this.ipResult = null;
      this.dnsHostname = null;
      this.port = null;
    } else {
      if (isIPv4(hostPort.host) || isIPv6(hostPort.host)) {
        this.ipResult = [
          {
            addresses: [
              {
                host: hostPort.host,
                port: hostPort.port ?? DEFAULT_PORT,
              },
            ],
          },
        ];
        this.dnsHostname = null;
        this.port = null;
      } else {
        this.ipResult = null;
        this.dnsHostname = hostPort.host;
        this.port = hostPort.port ?? DEFAULT_PORT;
      }
    }
    this.percentage = Math.random() * 100;

    if (channelOptions['grpc.service_config_disable_resolution'] === 1) {
      this.isServiceConfigEnabled = false;
    }

    this.defaultResolutionError = {
      code: Status.UNAVAILABLE,
      details: `Name resolution failed for target ${uriToString(this.target)}`,
      metadata: new Metadata(),
    };

    const backoffOptions: BackoffOptions = {
      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
    };

    this.backoff = new BackoffTimeout(() => {
      if (this.continueResolving) {
        this.startResolutionWithBackoff();
      }
    }, backoffOptions);
    this.backoff.unref();

    this.minTimeBetweenResolutionsMs =
      channelOptions['grpc.dns_min_time_between_resolutions_ms'] ??
      DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
    this.nextResolutionTimer = setTimeout(() => {}, 0);
    clearTimeout(this.nextResolutionTimer);
  }

  /**
   * If the target is an IP address, just provide that address as a result.
   * Otherwise, initiate A, AAAA, and TXT lookups
   */
  private startResolution() {
    if (this.ipResult !== null) {
      if (!this.returnedIpResult) {
        trace('Returning IP address for target ' + uriToString(this.target));
        setImmediate(() => {
          this.listener.onSuccessfulResolution(
            this.ipResult!,
            null,
            null,
            null,
            {}
          );
        });
        this.returnedIpResult = true;
      }
      this.backoff.stop();
      this.backoff.reset();
      this.stopNextResolutionTimer();
      return;
    }
    if (this.dnsHostname === null) {
      trace('Failed to parse DNS address ' + uriToString(this.target));
      setImmediate(() => {
        this.listener.onError({
          code: Status.UNAVAILABLE,
          details: `Failed to parse DNS address ${uriToString(this.target)}`,
          metadata: new Metadata(),
        });
      });
      this.stopNextResolutionTimer();
    } else {
      if (this.pendingLookupPromise !== null) {
        return;
      }
      trace('Looking up DNS hostname ' + this.dnsHostname);
      /* We clear out latestLookupResult here to ensure that it contains the
       * latest result since the last time we started resolving. That way, the
       * TXT resolution handler can use it, but only if it finishes second. We
       * don't clear out any previous service config results because it's
       * better to use a service config that's slightly out of date than to
       * revert to an effectively blank one. */
      this.latestLookupResult = null;
      const hostname: string = this.dnsHostname;
      this.pendingLookupPromise = this.lookup(hostname);
      this.pendingLookupPromise.then(
        addressList => {
          if (this.pendingLookupPromise === null) {
            return;
          }
          this.pendingLookupPromise = null;
          this.backoff.reset();
          this.backoff.stop();
          this.latestLookupResult = addressList.map(address => ({
            addresses: [address],
          }));
          const allAddressesString: string =
            '[' +
            addressList.map(addr => addr.host + ':' + addr.port).join(',') +
            ']';
          trace(
            'Resolved addresses for target ' +
              uriToString(this.target) +
              ': ' +
              allAddressesString
          );
          if (this.latestLookupResult.length === 0) {
            this.listener.onError(this.defaultResolutionError);
            return;
          }
          /* If the TXT lookup has not yet finished, both of the last two
           * arguments will be null, which is the equivalent of getting an
           * empty TXT response. When the TXT lookup does finish, its handler
           * can update the service config by using the same address list */
          this.listener.onSuccessfulResolution(
            this.latestLookupResult,
            this.latestServiceConfig,
            this.latestServiceConfigError,
            null,
            {}
          );
        },
        err => {
          if (this.pendingLookupPromise === null) {
            return;
          }
          trace(
            'Resolution error for target ' +
              uriToString(this.target) +
              ': ' +
              (err as Error).message
          );
          this.pendingLookupPromise = null;
          this.stopNextResolutionTimer();
          this.listener.onError(this.defaultResolutionError);
        }
      );
      /* If there already is a still-pending TXT resolution, we can just use
       * that result when it comes in */
      if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
        /* We handle the TXT query promise differently than the others because
         * the name resolution attempt as a whole is a success even if the TXT
         * lookup fails */
        this.pendingTxtPromise = this.resolveTxt(hostname);
        this.pendingTxtPromise.then(
          txtRecord => {
            if (this.pendingTxtPromise === null) {
              return;
            }
            this.pendingTxtPromise = null;
            try {
              this.latestServiceConfig = extractAndSelectServiceConfig(
                txtRecord,
                this.percentage
              );
            } catch (err) {
              this.latestServiceConfigError = {
                code: Status.UNAVAILABLE,
                details: `Parsing service config failed with error ${
                  (err as Error).message
                }`,
                metadata: new Metadata(),
              };
            }
            if (this.latestLookupResult !== null) {
              /* We rely here on the assumption that calling this function with
               * identical parameters will be essentialy idempotent, and calling
               * it with the same address list and a different service config
               * should result in a fast and seamless switchover. */
              this.listener.onSuccessfulResolution(
                this.latestLookupResult,
                this.latestServiceConfig,
                this.latestServiceConfigError,
                null,
                {}
              );
            }
          },
          err => {
            /* If TXT lookup fails we should do nothing, which means that we
             * continue to use the result of the most recent successful lookup,
             * or the default null config object if there has never been a
             * successful lookup. We do not set the latestServiceConfigError
             * here because that is specifically used for response validation
             * errors. We still need to handle this error so that it does not
             * bubble up as an unhandled promise rejection. */
          }
        );
      }
    }
  }

  private async lookup(hostname: string): Promise<TcpSubchannelAddress[]> {
    if (GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
      trace('Using alternative DNS resolver.');

      const records = await Promise.allSettled([
        this.alternativeResolver.resolve4(hostname),
        this.alternativeResolver.resolve6(hostname),
      ]);

      if (records.every(result => result.status === 'rejected')) {
        throw new Error((records[0] as PromiseRejectedResult).reason);
      }

      return records
        .reduce<string[]>((acc, result) => {
          return result.status === 'fulfilled'
            ? [...acc, ...result.value]
            : acc;
        }, [])
        .map(addr => ({
          host: addr,
          port: +this.port!,
        }));
    }

    /* We lookup both address families here and then split them up later
     * because when looking up a single family, dns.lookup outputs an error
     * if the name exists but there are no records for that family, and that
     * error is indistinguishable from other kinds of errors */
    const addressList = await dns.lookup(hostname, { all: true });
    return addressList.map(addr => ({ host: addr.address, port: +this.port! }));
  }

  private async resolveTxt(hostname: string): Promise<string[][]> {
    if (GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
      trace('Using alternative DNS resolver.');
      return this.alternativeResolver.resolveTxt(hostname);
    }

    return dns.resolveTxt(hostname);
  }

  private startNextResolutionTimer() {
    clearTimeout(this.nextResolutionTimer);
    this.nextResolutionTimer = setTimeout(() => {
      this.stopNextResolutionTimer();
      if (this.continueResolving) {
        this.startResolutionWithBackoff();
      }
    }, this.minTimeBetweenResolutionsMs);
    this.nextResolutionTimer.unref?.();
    this.isNextResolutionTimerRunning = true;
  }

  private stopNextResolutionTimer() {
    clearTimeout(this.nextResolutionTimer);
    this.isNextResolutionTimerRunning = false;
  }

  private startResolutionWithBackoff() {
    if (this.pendingLookupPromise === null) {
      this.continueResolving = false;
      this.backoff.runOnce();
      this.startNextResolutionTimer();
      this.startResolution();
    }
  }

  updateResolution() {
    /* If there is a pending lookup, just let it finish. Otherwise, if the
     * nextResolutionTimer or backoff timer is running, set the
     * continueResolving flag to resolve when whichever of those timers
     * fires. Otherwise, start resolving immediately. */
    if (this.pendingLookupPromise === null) {
      if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
        if (this.isNextResolutionTimerRunning) {
          trace(
            'resolution update delayed by "min time between resolutions" rate limit'
          );
        } else {
          trace(
            'resolution update delayed by backoff timer until ' +
              this.backoff.getEndTime().toISOString()
          );
        }
        this.continueResolving = true;
      } else {
        this.startResolutionWithBackoff();
      }
    }
  }

  /**
   * Reset the resolver to the same state it had when it was created. In-flight
   * DNS requests cannot be cancelled, but they are discarded and their results
   * will be ignored.
   */
  destroy() {
    this.continueResolving = false;
    this.backoff.reset();
    this.backoff.stop();
    this.stopNextResolutionTimer();
    this.pendingLookupPromise = null;
    this.pendingTxtPromise = null;
    this.latestLookupResult = null;
    this.latestServiceConfig = null;
    this.latestServiceConfigError = null;
    this.returnedIpResult = false;
  }

  /**
   * Get the default authority for the given target. For IP targets, that is
   * the IP address. For DNS targets, it is the hostname.
   * @param target
   */
  static getDefaultAuthority(target: GrpcUri): string {
    return target.path;
  }
}

/**
 * Set up the DNS resolver class by registering it as the handler for the
 * "dns:" prefix and as the default resolver.
 */
export function setup(): void {
  registerResolver('dns', DnsResolver);
  registerDefaultScheme('dns');
}

export interface DnsUrl {
  host: string;
  port?: string;
}
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { isIPv4, isIPv6 } from 'net';
import { StatusObject } from './call-interface';
import { ChannelOptions } from './channel-options';
import { LogVerbosity, Status } from './constants';
import { Metadata } from './metadata';
import { registerResolver, Resolver, ResolverListener } from './resolver';
import { Endpoint, SubchannelAddress } from './subchannel-address';
import { GrpcUri, splitHostPort, uriToString } from './uri-parser';
import * as logging from './logging';

const TRACER_NAME = 'ip_resolver';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const IPV4_SCHEME = 'ipv4';
const IPV6_SCHEME = 'ipv6';

/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
const DEFAULT_PORT = 443;

class IpResolver implements Resolver {
  private endpoints: Endpoint[] = [];
  private error: StatusObject | null = null;
  private hasReturnedResult = false;
  constructor(
    target: GrpcUri,
    private listener: ResolverListener,
    channelOptions: ChannelOptions
  ) {
    trace('Resolver constructed for target ' + uriToString(target));
    const addresses: SubchannelAddress[] = [];
    if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
      this.error = {
        code: Status.UNAVAILABLE,
        details: `Unrecognized scheme ${target.scheme} in IP resolver`,
        metadata: new Metadata(),
      };
      return;
    }
    const pathList = target.path.split(',');
    for (const path of pathList) {
      const hostPort = splitHostPort(path);
      if (hostPort === null) {
        this.error = {
          code: Status.UNAVAILABLE,
          details: `Failed to parse ${target.scheme} address ${path}`,
          metadata: new Metadata(),
        };
        return;
      }
      if (
        (target.scheme === IPV4_SCHEME && !isIPv4(hostPort.host)) ||
        (target.scheme === IPV6_SCHEME && !isIPv6(hostPort.host))
      ) {
        this.error = {
          code: Status.UNAVAILABLE,
          details: `Failed to parse ${target.scheme} address ${path}`,
          metadata: new Metadata(),
        };
        return;
      }
      addresses.push({
        host: hostPort.host,
        port: hostPort.port ?? DEFAULT_PORT,
      });
    }
    this.endpoints = addresses.map(address => ({ addresses: [address] }));
    trace('Parsed ' + target.scheme + ' address list ' + addresses);
  }
  updateResolution(): void {
    if (!this.hasReturnedResult) {
      this.hasReturnedResult = true;
      process.nextTick(() => {
        if (this.error) {
          this.listener.onError(this.error);
        } else {
          this.listener.onSuccessfulResolution(
            this.endpoints,
            null,
            null,
            null,
            {}
          );
        }
      });
    }
  }
  destroy(): void {
    this.hasReturnedResult = false;
  }

  static getDefaultAuthority(target: GrpcUri): string {
    return target.path.split(',')[0];
  }
}

export function setup() {
  registerResolver(IPV4_SCHEME, IpResolver);
  registerResolver(IPV6_SCHEME, IpResolver);
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Resolver, ResolverListener, registerResolver } from './resolver';
import { Endpoint } from './subchannel-address';
import { GrpcUri } from './uri-parser';
import { ChannelOptions } from './channel-options';

class UdsResolver implements Resolver {
  private hasReturnedResult = false;
  private endpoints: Endpoint[] = [];
  constructor(
    target: GrpcUri,
    private listener: ResolverListener,
    channelOptions: ChannelOptions
  ) {
    let path: string;
    if (target.authority === '') {
      path = '/' + target.path;
    } else {
      path = target.path;
    }
    this.endpoints = [{ addresses: [{ path }] }];
  }
  updateResolution(): void {
    if (!this.hasReturnedResult) {
      this.hasReturnedResult = true;
      process.nextTick(
        this.listener.onSuccessfulResolution,
        this.endpoints,
        null,
        null,
        null,
        {}
      );
    }
  }

  destroy() {
    this.hasReturnedResult = false;
  }

  static getDefaultAuthority(target: GrpcUri): string {
    return 'localhost';
  }
}

export function setup() {
  registerResolver('unix', UdsResolver);
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { MethodConfig, ServiceConfig } from './service-config';
import { StatusObject } from './call-interface';
import { Endpoint } from './subchannel-address';
import { GrpcUri, uriToString } from './uri-parser';
import { ChannelOptions } from './channel-options';
import { Metadata } from './metadata';
import { Status } from './constants';
import { Filter, FilterFactory } from './filter';

export interface CallConfig {
  methodConfig: MethodConfig;
  onCommitted?: () => void;
  pickInformation: { [key: string]: string };
  status: Status;
  dynamicFilterFactories: FilterFactory<Filter>[];
}

/**
 * Selects a configuration for a method given the name and metadata. Defined in
 * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc
 */
export interface ConfigSelector {
  (methodName: string, metadata: Metadata, channelId: number): CallConfig;
}

/**
 * A listener object passed to the resolver's constructor that provides name
 * resolution updates back to the resolver's owner.
 */
export interface ResolverListener {
  /**
   * Called whenever the resolver has new name resolution results to report
   * @param addressList The new list of backend addresses
   * @param serviceConfig The new service configuration corresponding to the
   *     `addressList`. Will be `null` if no service configuration was
   *     retrieved or if the service configuration was invalid
   * @param serviceConfigError If non-`null`, indicates that the retrieved
   *     service configuration was invalid
   */
  onSuccessfulResolution(
    addressList: Endpoint[],
    serviceConfig: ServiceConfig | null,
    serviceConfigError: StatusObject | null,
    configSelector: ConfigSelector | null,
    attributes: { [key: string]: unknown }
  ): void;
  /**
   * Called whenever a name resolution attempt fails.
   * @param error Describes how resolution failed
   */
  onError(error: StatusObject): void;
}

/**
 * A resolver class that handles one or more of the name syntax schemes defined
 * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 */
export interface Resolver {
  /**
   * Indicates that the caller wants new name resolution data. Calling this
   * function may eventually result in calling one of the `ResolverListener`
   * functions, but that is not guaranteed. Those functions will never be
   * called synchronously with the constructor or updateResolution.
   */
  updateResolution(): void;

  /**
   * Discard all resources owned by the resolver. A later call to
   * `updateResolution` should reinitialize those resources.  No
   * `ResolverListener` callbacks should be called after `destroy` is called
   * until `updateResolution` is called again.
   */
  destroy(): void;
}

export interface ResolverConstructor {
  new (
    target: GrpcUri,
    listener: ResolverListener,
    channelOptions: ChannelOptions
  ): Resolver;
  /**
   * Get the default authority for a target. This loosely corresponds to that
   * target's hostname. Throws an error if this resolver class cannot parse the
   * `target`.
   * @param target
   */
  getDefaultAuthority(target: GrpcUri): string;
}

const registeredResolvers: { [scheme: string]: ResolverConstructor } = {};
let defaultScheme: string | null = null;

/**
 * Register a resolver class to handle target names prefixed with the `prefix`
 * string. This prefix should correspond to a URI scheme name listed in the
 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
 * @param prefix
 * @param resolverClass
 */
export function registerResolver(
  scheme: string,
  resolverClass: ResolverConstructor
) {
  registeredResolvers[scheme] = resolverClass;
}

/**
 * Register a default resolver to handle target names that do not start with
 * any registered prefix.
 * @param resolverClass
 */
export function registerDefaultScheme(scheme: string) {
  defaultScheme = scheme;
}

/**
 * Create a name resolver for the specified target, if possible. Throws an
 * error if no such name resolver can be created.
 * @param target
 * @param listener
 */
export function createResolver(
  target: GrpcUri,
  listener: ResolverListener,
  options: ChannelOptions
): Resolver {
  if (target.scheme !== undefined && target.scheme in registeredResolvers) {
    return new registeredResolvers[target.scheme](target, listener, options);
  } else {
    throw new Error(
      `No resolver could be created for target ${uriToString(target)}`
    );
  }
}

/**
 * Get the default authority for the specified target, if possible. Throws an
 * error if no registered name resolver can parse that target string.
 * @param target
 */
export function getDefaultAuthority(target: GrpcUri): string {
  if (target.scheme !== undefined && target.scheme in registeredResolvers) {
    return registeredResolvers[target.scheme].getDefaultAuthority(target);
  } else {
    throw new Error(`Invalid target ${uriToString(target)}`);
  }
}

export function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null {
  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
    if (defaultScheme !== null) {
      return {
        scheme: defaultScheme,
        authority: undefined,
        path: uriToString(target),
      };
    } else {
      return null;
    }
  }
  return target;
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { CallCredentials } from './call-credentials';
import {
  Call,
  CallStreamOptions,
  DeadlineInfoProvider,
  InterceptingListener,
  MessageContext,
  StatusObject,
} from './call-interface';
import { LogVerbosity, Propagate, Status } from './constants';
import {
  Deadline,
  deadlineToString,
  formatDateDifference,
  getRelativeTimeout,
  minDeadline,
} from './deadline';
import { FilterStack, FilterStackFactory } from './filter-stack';
import { InternalChannel } from './internal-channel';
import { Metadata } from './metadata';
import * as logging from './logging';
import { restrictControlPlaneStatusCode } from './control-plane-status';

const TRACER_NAME = 'resolving_call';

export class ResolvingCall implements Call {
  private child: (Call & DeadlineInfoProvider) | null = null;
  private readPending = false;
  private pendingMessage: { context: MessageContext; message: Buffer } | null =
    null;
  private pendingHalfClose = false;
  private ended = false;
  private readFilterPending = false;
  private writeFilterPending = false;
  private pendingChildStatus: StatusObject | null = null;
  private metadata: Metadata | null = null;
  private listener: InterceptingListener | null = null;
  private deadline: Deadline;
  private host: string;
  private statusWatchers: ((status: StatusObject) => void)[] = [];
  private deadlineTimer: NodeJS.Timeout = setTimeout(() => {}, 0);
  private filterStack: FilterStack | null = null;

  private deadlineStartTime: Date | null = null;
  private configReceivedTime: Date | null = null;
  private childStartTime: Date | null = null;

  constructor(
    private readonly channel: InternalChannel,
    private readonly method: string,
    options: CallStreamOptions,
    private readonly filterStackFactory: FilterStackFactory,
    private credentials: CallCredentials,
    private callNumber: number
  ) {
    this.deadline = options.deadline;
    this.host = options.host;
    if (options.parentCall) {
      if (options.flags & Propagate.CANCELLATION) {
        options.parentCall.on('cancelled', () => {
          this.cancelWithStatus(Status.CANCELLED, 'Cancelled by parent call');
        });
      }
      if (options.flags & Propagate.DEADLINE) {
        this.trace(
          'Propagating deadline from parent: ' +
            options.parentCall.getDeadline()
        );
        this.deadline = minDeadline(
          this.deadline,
          options.parentCall.getDeadline()
        );
      }
    }
    this.trace('Created');
    this.runDeadlineTimer();
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '[' + this.callNumber + '] ' + text
    );
  }

  private runDeadlineTimer() {
    clearTimeout(this.deadlineTimer);
    this.deadlineStartTime = new Date();
    this.trace('Deadline: ' + deadlineToString(this.deadline));
    const timeout = getRelativeTimeout(this.deadline);
    if (timeout !== Infinity) {
      this.trace('Deadline will be reached in ' + timeout + 'ms');
      const handleDeadline = () => {
        if (!this.deadlineStartTime) {
          this.cancelWithStatus(Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
          return;
        }
        const deadlineInfo: string[] = [];
        const deadlineEndTime = new Date();
        deadlineInfo.push(`Deadline exceeded after ${formatDateDifference(this.deadlineStartTime, deadlineEndTime)}`);
        if (this.configReceivedTime) {
          if (this.configReceivedTime > this.deadlineStartTime) {
            deadlineInfo.push(`name resolution: ${formatDateDifference(this.deadlineStartTime, this.configReceivedTime)}`);
          }
          if (this.childStartTime) {
            if (this.childStartTime > this.configReceivedTime) {
              deadlineInfo.push(`metadata filters: ${formatDateDifference(this.configReceivedTime, this.childStartTime)}`);
            }
          } else {
            deadlineInfo.push('waiting for metadata filters');
          }
        } else {
          deadlineInfo.push('waiting for name resolution');
        }
        if (this.child) {
          deadlineInfo.push(...this.child.getDeadlineInfo());
        }
        this.cancelWithStatus(Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));
      };
      if (timeout <= 0) {
        process.nextTick(handleDeadline);
      } else {
        this.deadlineTimer = setTimeout(handleDeadline, timeout);
      }
    }
  }

  private outputStatus(status: StatusObject) {
    if (!this.ended) {
      this.ended = true;
      if (!this.filterStack) {
        this.filterStack = this.filterStackFactory.createFilter();
      }
      clearTimeout(this.deadlineTimer);
      const filteredStatus = this.filterStack.receiveTrailers(status);
      this.trace(
        'ended with status: code=' +
          filteredStatus.code +
          ' details="' +
          filteredStatus.details +
          '"'
      );
      this.statusWatchers.forEach(watcher => watcher(filteredStatus));
      process.nextTick(() => {
        this.listener?.onReceiveStatus(filteredStatus);
      });
    }
  }

  private sendMessageOnChild(context: MessageContext, message: Buffer): void {
    if (!this.child) {
      throw new Error('sendMessageonChild called with child not populated');
    }
    const child = this.child;
    this.writeFilterPending = true;
    this.filterStack!.sendMessage(
      Promise.resolve({ message: message, flags: context.flags })
    ).then(
      filteredMessage => {
        this.writeFilterPending = false;
        child.sendMessageWithContext(context, filteredMessage.message);
        if (this.pendingHalfClose) {
          child.halfClose();
        }
      },
      (status: StatusObject) => {
        this.cancelWithStatus(status.code, status.details);
      }
    );
  }

  getConfig(): void {
    if (this.ended) {
      return;
    }
    if (!this.metadata || !this.listener) {
      throw new Error('getConfig called before start');
    }
    const configResult = this.channel.getConfig(this.method, this.metadata);
    if (configResult.type === 'NONE') {
      this.channel.queueCallForConfig(this);
      return;
    } else if (configResult.type === 'ERROR') {
      if (this.metadata.getOptions().waitForReady) {
        this.channel.queueCallForConfig(this);
      } else {
        this.outputStatus(configResult.error);
      }
      return;
    }
    // configResult.type === 'SUCCESS'
    this.configReceivedTime = new Date();
    const config = configResult.config;
    if (config.status !== Status.OK) {
      const { code, details } = restrictControlPlaneStatusCode(
        config.status,
        'Failed to route call to method ' + this.method
      );
      this.outputStatus({
        code: code,
        details: details,
        metadata: new Metadata(),
      });
      return;
    }

    if (config.methodConfig.timeout) {
      const configDeadline = new Date();
      configDeadline.setSeconds(
        configDeadline.getSeconds() + config.methodConfig.timeout.seconds
      );
      configDeadline.setMilliseconds(
        configDeadline.getMilliseconds() +
          config.methodConfig.timeout.nanos / 1_000_000
      );
      this.deadline = minDeadline(this.deadline, configDeadline);
      this.runDeadlineTimer();
    }

    this.filterStackFactory.push(config.dynamicFilterFactories);
    this.filterStack = this.filterStackFactory.createFilter();
    this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(
      filteredMetadata => {
        this.child = this.channel.createInnerCall(
          config,
          this.method,
          this.host,
          this.credentials,
          this.deadline
        );
        this.trace('Created child [' + this.child.getCallNumber() + ']');
        this.childStartTime = new Date();
        this.child.start(filteredMetadata, {
          onReceiveMetadata: metadata => {
            this.trace('Received metadata');
            this.listener!.onReceiveMetadata(
              this.filterStack!.receiveMetadata(metadata)
            );
          },
          onReceiveMessage: message => {
            this.trace('Received message');
            this.readFilterPending = true;
            this.filterStack!.receiveMessage(message).then(
              filteredMesssage => {
                this.trace('Finished filtering received message');
                this.readFilterPending = false;
                this.listener!.onReceiveMessage(filteredMesssage);
                if (this.pendingChildStatus) {
                  this.outputStatus(this.pendingChildStatus);
                }
              },
              (status: StatusObject) => {
                this.cancelWithStatus(status.code, status.details);
              }
            );
          },
          onReceiveStatus: status => {
            this.trace('Received status');
            if (this.readFilterPending) {
              this.pendingChildStatus = status;
            } else {
              this.outputStatus(status);
            }
          },
        });
        if (this.readPending) {
          this.child.startRead();
        }
        if (this.pendingMessage) {
          this.sendMessageOnChild(
            this.pendingMessage.context,
            this.pendingMessage.message
          );
        } else if (this.pendingHalfClose) {
          this.child.halfClose();
        }
      },
      (status: StatusObject) => {
        this.outputStatus(status);
      }
    );
  }

  reportResolverError(status: StatusObject) {
    if (this.metadata?.getOptions().waitForReady) {
      this.channel.queueCallForConfig(this);
    } else {
      this.outputStatus(status);
    }
  }
  cancelWithStatus(status: Status, details: string): void {
    this.trace(
      'cancelWithStatus code: ' + status + ' details: "' + details + '"'
    );
    this.child?.cancelWithStatus(status, details);
    this.outputStatus({
      code: status,
      details: details,
      metadata: new Metadata(),
    });
  }
  getPeer(): string {
    return this.child?.getPeer() ?? this.channel.getTarget();
  }
  start(metadata: Metadata, listener: InterceptingListener): void {
    this.trace('start called');
    this.metadata = metadata.clone();
    this.listener = listener;
    this.getConfig();
  }
  sendMessageWithContext(context: MessageContext, message: Buffer): void {
    this.trace('write() called with message of length ' + message.length);
    if (this.child) {
      this.sendMessageOnChild(context, message);
    } else {
      this.pendingMessage = { context, message };
    }
  }
  startRead(): void {
    this.trace('startRead called');
    if (this.child) {
      this.child.startRead();
    } else {
      this.readPending = true;
    }
  }
  halfClose(): void {
    this.trace('halfClose called');
    if (this.child && !this.writeFilterPending) {
      this.child.halfClose();
    } else {
      this.pendingHalfClose = true;
    }
  }
  setCredentials(credentials: CallCredentials): void {
    this.credentials = this.credentials.compose(credentials);
  }

  addStatusWatcher(watcher: (status: StatusObject) => void) {
    this.statusWatchers.push(watcher);
  }

  getCallNumber(): number {
    return this.callNumber;
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import {
  ChannelControlHelper,
  LoadBalancer,
  TypedLoadBalancingConfig,
  selectLbConfigFromList,
} from './load-balancer';
import {
  MethodConfig,
  ServiceConfig,
  validateServiceConfig,
} from './service-config';
import { ConnectivityState } from './connectivity-state';
import { ConfigSelector, createResolver, Resolver } from './resolver';
import { ServiceError } from './call';
import { Picker, UnavailablePicker, QueuePicker } from './picker';
import { BackoffOptions, BackoffTimeout } from './backoff-timeout';
import { Status } from './constants';
import { StatusObject } from './call-interface';
import { Metadata } from './metadata';
import * as logging from './logging';
import { LogVerbosity } from './constants';
import { Endpoint } from './subchannel-address';
import { GrpcUri, uriToString } from './uri-parser';
import { ChildLoadBalancerHandler } from './load-balancer-child-handler';
import { ChannelOptions } from './channel-options';

const TRACER_NAME = 'resolving_load_balancer';

function trace(text: string): void {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

type NameMatchLevel = 'EMPTY' | 'SERVICE' | 'SERVICE_AND_METHOD';

/**
 * Name match levels in order from most to least specific. This is the order in
 * which searches will be performed.
 */
const NAME_MATCH_LEVEL_ORDER: NameMatchLevel[] = [
  'SERVICE_AND_METHOD',
  'SERVICE',
  'EMPTY',
];

function hasMatchingName(
  service: string,
  method: string,
  methodConfig: MethodConfig,
  matchLevel: NameMatchLevel
): boolean {
  for (const name of methodConfig.name) {
    switch (matchLevel) {
      case 'EMPTY':
        if (!name.service && !name.method) {
          return true;
        }
        break;
      case 'SERVICE':
        if (name.service === service && !name.method) {
          return true;
        }
        break;
      case 'SERVICE_AND_METHOD':
        if (name.service === service && name.method === method) {
          return true;
        }
    }
  }
  return false;
}

function findMatchingConfig(
  service: string,
  method: string,
  methodConfigs: MethodConfig[],
  matchLevel: NameMatchLevel
): MethodConfig | null {
  for (const config of methodConfigs) {
    if (hasMatchingName(service, method, config, matchLevel)) {
      return config;
    }
  }
  return null;
}

function getDefaultConfigSelector(
  serviceConfig: ServiceConfig | null
): ConfigSelector {
  return function defaultConfigSelector(
    methodName: string,
    metadata: Metadata
  ) {
    const splitName = methodName.split('/').filter(x => x.length > 0);
    const service = splitName[0] ?? '';
    const method = splitName[1] ?? '';
    if (serviceConfig && serviceConfig.methodConfig) {
      /* Check for the following in order, and return the first method
       * config that matches:
       * 1. A name that exactly matches the service and method
       * 2. A name with no method set that matches the service
       * 3. An empty name
       */
      for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
        const matchingConfig = findMatchingConfig(
          service,
          method,
          serviceConfig.methodConfig,
          matchLevel
        );
        if (matchingConfig) {
          return {
            methodConfig: matchingConfig,
            pickInformation: {},
            status: Status.OK,
            dynamicFilterFactories: [],
          };
        }
      }
    }
    return {
      methodConfig: { name: [] },
      pickInformation: {},
      status: Status.OK,
      dynamicFilterFactories: [],
    };
  };
}

export interface ResolutionCallback {
  (serviceConfig: ServiceConfig, configSelector: ConfigSelector): void;
}

export interface ResolutionFailureCallback {
  (status: StatusObject): void;
}

export class ResolvingLoadBalancer implements LoadBalancer {
  /**
   * The resolver class constructed for the target address.
   */
  private readonly innerResolver: Resolver;

  private readonly childLoadBalancer: ChildLoadBalancerHandler;
  private latestChildState: ConnectivityState = ConnectivityState.IDLE;
  private latestChildPicker: Picker = new QueuePicker(this);
  /**
   * This resolving load balancer's current connectivity state.
   */
  private currentState: ConnectivityState = ConnectivityState.IDLE;
  private readonly defaultServiceConfig: ServiceConfig;
  /**
   * The service config object from the last successful resolution, if
   * available. A value of null indicates that we have not yet received a valid
   * service config from the resolver.
   */
  private previousServiceConfig: ServiceConfig | null = null;

  /**
   * The backoff timer for handling name resolution failures.
   */
  private readonly backoffTimeout: BackoffTimeout;

  /**
   * Indicates whether we should attempt to resolve again after the backoff
   * timer runs out.
   */
  private continueResolving = false;

  /**
   * Wrapper class that behaves like a `LoadBalancer` and also handles name
   * resolution internally.
   * @param target The address of the backend to connect to.
   * @param channelControlHelper `ChannelControlHelper` instance provided by
   *     this load balancer's owner.
   * @param defaultServiceConfig The default service configuration to be used
   *     if none is provided by the name resolver. A `null` value indicates
   *     that the default behavior should be the default unconfigured behavior.
   *     In practice, that means using the "pick first" load balancer
   *     implmentation
   */
  constructor(
    private readonly target: GrpcUri,
    private readonly channelControlHelper: ChannelControlHelper,
    channelOptions: ChannelOptions,
    private readonly onSuccessfulResolution: ResolutionCallback,
    private readonly onFailedResolution: ResolutionFailureCallback
  ) {
    if (channelOptions['grpc.service_config']) {
      this.defaultServiceConfig = validateServiceConfig(
        JSON.parse(channelOptions['grpc.service_config']!)
      );
    } else {
      this.defaultServiceConfig = {
        loadBalancingConfig: [],
        methodConfig: [],
      };
    }

    this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
    this.childLoadBalancer = new ChildLoadBalancerHandler(
      {
        createSubchannel:
          channelControlHelper.createSubchannel.bind(channelControlHelper),
        requestReresolution: () => {
          /* If the backoffTimeout is running, we're still backing off from
           * making resolve requests, so we shouldn't make another one here.
           * In that case, the backoff timer callback will call
           * updateResolution */
          if (this.backoffTimeout.isRunning()) {
            trace(
              'requestReresolution delayed by backoff timer until ' +
                this.backoffTimeout.getEndTime().toISOString()
            );
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
        },
        updateState: (newState: ConnectivityState, picker: Picker) => {
          this.latestChildState = newState;
          this.latestChildPicker = picker;
          this.updateState(newState, picker);
        },
        addChannelzChild:
          channelControlHelper.addChannelzChild.bind(channelControlHelper),
        removeChannelzChild:
          channelControlHelper.removeChannelzChild.bind(channelControlHelper),
      },
      channelOptions
    );
    this.innerResolver = createResolver(
      target,
      {
        onSuccessfulResolution: (
          endpointList: Endpoint[],
          serviceConfig: ServiceConfig | null,
          serviceConfigError: ServiceError | null,
          configSelector: ConfigSelector | null,
          attributes: { [key: string]: unknown }
        ) => {
          this.backoffTimeout.stop();
          this.backoffTimeout.reset();
          let workingServiceConfig: ServiceConfig | null = null;
          /* This first group of conditionals implements the algorithm described
           * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
           * in the section called "Behavior on receiving a new gRPC Config".
           */
          if (serviceConfig === null) {
            // Step 4 and 5
            if (serviceConfigError === null) {
              // Step 5
              this.previousServiceConfig = null;
              workingServiceConfig = this.defaultServiceConfig;
            } else {
              // Step 4
              if (this.previousServiceConfig === null) {
                // Step 4.ii
                this.handleResolutionFailure(serviceConfigError);
              } else {
                // Step 4.i
                workingServiceConfig = this.previousServiceConfig;
              }
            }
          } else {
            // Step 3
            workingServiceConfig = serviceConfig;
            this.previousServiceConfig = serviceConfig;
          }
          const workingConfigList =
            workingServiceConfig?.loadBalancingConfig ?? [];
          const loadBalancingConfig = selectLbConfigFromList(
            workingConfigList,
            true
          );
          if (loadBalancingConfig === null) {
            // There were load balancing configs but none are supported. This counts as a resolution failure
            this.handleResolutionFailure({
              code: Status.UNAVAILABLE,
              details:
                'All load balancer options in service config are not compatible',
              metadata: new Metadata(),
            });
            return;
          }
          this.childLoadBalancer.updateAddressList(
            endpointList,
            loadBalancingConfig,
            attributes
          );
          const finalServiceConfig =
            workingServiceConfig ?? this.defaultServiceConfig;
          this.onSuccessfulResolution(
            finalServiceConfig,
            configSelector ?? getDefaultConfigSelector(finalServiceConfig)
          );
        },
        onError: (error: StatusObject) => {
          this.handleResolutionFailure(error);
        },
      },
      channelOptions
    );
    const backoffOptions: BackoffOptions = {
      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
    };
    this.backoffTimeout = new BackoffTimeout(() => {
      if (this.continueResolving) {
        this.updateResolution();
        this.continueResolving = false;
      } else {
        this.updateState(this.latestChildState, this.latestChildPicker);
      }
    }, backoffOptions);
    this.backoffTimeout.unref();
  }

  private updateResolution() {
    this.innerResolver.updateResolution();
    if (this.currentState === ConnectivityState.IDLE) {
      /* this.latestChildPicker is initialized as new QueuePicker(this), which
       * is an appropriate value here if the child LB policy is unset.
       * Otherwise, we want to delegate to the child here, in case that
       * triggers something. */
      this.updateState(ConnectivityState.CONNECTING, this.latestChildPicker);
    }
    this.backoffTimeout.runOnce();
  }

  private updateState(connectivityState: ConnectivityState, picker: Picker) {
    trace(
      uriToString(this.target) +
        ' ' +
        ConnectivityState[this.currentState] +
        ' -> ' +
        ConnectivityState[connectivityState]
    );
    // Ensure that this.exitIdle() is called by the picker
    if (connectivityState === ConnectivityState.IDLE) {
      picker = new QueuePicker(this, picker);
    }
    this.currentState = connectivityState;
    this.channelControlHelper.updateState(connectivityState, picker);
  }

  private handleResolutionFailure(error: StatusObject) {
    if (this.latestChildState === ConnectivityState.IDLE) {
      this.updateState(
        ConnectivityState.TRANSIENT_FAILURE,
        new UnavailablePicker(error)
      );
      this.onFailedResolution(error);
    }
  }

  exitIdle() {
    if (
      this.currentState === ConnectivityState.IDLE ||
      this.currentState === ConnectivityState.TRANSIENT_FAILURE
    ) {
      if (this.backoffTimeout.isRunning()) {
        this.continueResolving = true;
      } else {
        this.updateResolution();
      }
    }
    this.childLoadBalancer.exitIdle();
  }

  updateAddressList(
    endpointList: Endpoint[],
    lbConfig: TypedLoadBalancingConfig | null
  ): never {
    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
  }

  resetBackoff() {
    this.backoffTimeout.reset();
    this.childLoadBalancer.resetBackoff();
  }

  destroy() {
    this.childLoadBalancer.destroy();
    this.innerResolver.destroy();
    this.backoffTimeout.reset();
    this.backoffTimeout.stop();
    this.latestChildState = ConnectivityState.IDLE;
    this.latestChildPicker = new QueuePicker(this);
    this.currentState = ConnectivityState.IDLE;
    this.previousServiceConfig = null;
    this.continueResolving = false;
  }

  getTypeName() {
    return 'resolving_load_balancer';
  }
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { CallCredentials } from './call-credentials';
import { LogVerbosity, Status } from './constants';
import { Deadline, formatDateDifference } from './deadline';
import { Metadata } from './metadata';
import { CallConfig } from './resolver';
import * as logging from './logging';
import {
  Call,
  DeadlineInfoProvider,
  InterceptingListener,
  MessageContext,
  StatusObject,
  WriteCallback,
  WriteObject,
} from './call-interface';
import {
  LoadBalancingCall,
  StatusObjectWithProgress,
} from './load-balancing-call';
import { InternalChannel } from './internal-channel';

const TRACER_NAME = 'retrying_call';

export class RetryThrottler {
  private tokens: number;
  constructor(
    private readonly maxTokens: number,
    private readonly tokenRatio: number,
    previousRetryThrottler?: RetryThrottler
  ) {
    if (previousRetryThrottler) {
      /* When carrying over tokens from a previous config, rescale them to the
       * new max value */
      this.tokens =
        previousRetryThrottler.tokens *
        (maxTokens / previousRetryThrottler.maxTokens);
    } else {
      this.tokens = maxTokens;
    }
  }

  addCallSucceeded() {
    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
  }

  addCallFailed() {
    this.tokens = Math.min(this.tokens - 1, 0);
  }

  canRetryCall() {
    return this.tokens > this.maxTokens / 2;
  }
}

export class MessageBufferTracker {
  private totalAllocated = 0;
  private allocatedPerCall: Map<number, number> = new Map<number, number>();

  constructor(private totalLimit: number, private limitPerCall: number) {}

  allocate(size: number, callId: number): boolean {
    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;
    if (
      this.limitPerCall - currentPerCall < size ||
      this.totalLimit - this.totalAllocated < size
    ) {
      return false;
    }
    this.allocatedPerCall.set(callId, currentPerCall + size);
    this.totalAllocated += size;
    return true;
  }

  free(size: number, callId: number) {
    if (this.totalAllocated < size) {
      throw new Error(
        `Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`
      );
    }
    this.totalAllocated -= size;
    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;
    if (currentPerCall < size) {
      throw new Error(
        `Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`
      );
    }
    this.allocatedPerCall.set(callId, currentPerCall - size);
  }

  freeAll(callId: number) {
    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;
    if (this.totalAllocated < currentPerCall) {
      throw new Error(
        `Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`
      );
    }
    this.totalAllocated -= currentPerCall;
    this.allocatedPerCall.delete(callId);
  }
}

type UnderlyingCallState = 'ACTIVE' | 'COMPLETED';

interface UnderlyingCall {
  state: UnderlyingCallState;
  call: LoadBalancingCall;
  nextMessageToSend: number;
  startTime: Date;
}

/**
 * A retrying call can be in one of these states:
 * RETRY: Retries are configured and new attempts may be sent
 * HEDGING: Hedging is configured and new attempts may be sent
 * TRANSPARENT_ONLY: Neither retries nor hedging are configured, and
 * transparent retry attempts may still be sent
 * COMMITTED: One attempt is committed, and no new attempts will be
 * sent
 */
type RetryingCallState = 'RETRY' | 'HEDGING' | 'TRANSPARENT_ONLY' | 'COMMITTED';

/**
 * The different types of objects that can be stored in the write buffer, with
 * the following meanings:
 * MESSAGE: This is a message to be sent.
 * HALF_CLOSE: When this entry is reached, the calls should send a half-close.
 * FREED: This slot previously contained a message that has been sent on all
 * child calls and is no longer needed.
 */
type WriteBufferEntryType = 'MESSAGE' | 'HALF_CLOSE' | 'FREED';

/**
 * Entry in the buffer of messages to send to the remote end.
 */
interface WriteBufferEntry {
  entryType: WriteBufferEntryType;
  /**
   * Message to send.
   * Only populated if entryType is MESSAGE.
   */
  message?: WriteObject;
  /**
   * Callback to call after sending the message.
   * Only populated if entryType is MESSAGE and the call is in the COMMITTED
   * state.
   */
  callback?: WriteCallback;
  /**
   * Indicates whether the message is allocated in the buffer tracker. Ignored
   * if entryType is not MESSAGE. Should be the return value of
   * bufferTracker.allocate.
   */
  allocated: boolean;
}

const PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';

const DEFAULT_MAX_ATTEMPTS_LIMIT = 5;

export class RetryingCall implements Call, DeadlineInfoProvider {
  private state: RetryingCallState;
  private listener: InterceptingListener | null = null;
  private initialMetadata: Metadata | null = null;
  private underlyingCalls: UnderlyingCall[] = [];
  private writeBuffer: WriteBufferEntry[] = [];
  /**
   * The offset of message indices in the writeBuffer. For example, if
   * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15
   * is in writeBuffer[5].
   */
  private writeBufferOffset = 0;
  /**
   * Tracks whether a read has been started, so that we know whether to start
   * reads on new child calls. This only matters for the first read, because
   * once a message comes in the child call becomes committed and there will
   * be no new child calls.
   */
  private readStarted = false;
  private transparentRetryUsed = false;
  /**
   * Number of attempts so far
   */
  private attempts = 0;
  private hedgingTimer: NodeJS.Timeout | null = null;
  private committedCallIndex: number | null = null;
  private initialRetryBackoffSec = 0;
  private nextRetryBackoffSec = 0;
  private startTime: Date;
  private maxAttempts: number;
  constructor(
    private readonly channel: InternalChannel,
    private readonly callConfig: CallConfig,
    private readonly methodName: string,
    private readonly host: string,
    private readonly credentials: CallCredentials,
    private readonly deadline: Deadline,
    private readonly callNumber: number,
    private readonly bufferTracker: MessageBufferTracker,
    private readonly retryThrottler?: RetryThrottler
  ) {
    const maxAttemptsLimit = channel.getOptions()['grpc-node.retry_max_attempts_limit'] ?? DEFAULT_MAX_ATTEMPTS_LIMIT;
    if (callConfig.methodConfig.retryPolicy) {
      this.state = 'RETRY';
      const retryPolicy = callConfig.methodConfig.retryPolicy;
      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(
        retryPolicy.initialBackoff.substring(
          0,
          retryPolicy.initialBackoff.length - 1
        )
      );
      this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
    } else if (callConfig.methodConfig.hedgingPolicy) {
      this.state = 'HEDGING';
      this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
    } else {
      this.state = 'TRANSPARENT_ONLY';
      this.maxAttempts = 1;
    }
    this.startTime = new Date();
  }
  getDeadlineInfo(): string[] {
    if (this.underlyingCalls.length === 0) {
      return [];
    }
    const deadlineInfo: string[] = [];
    const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
    if (this.underlyingCalls.length > 1) {
      deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
    }
    if (latestCall.startTime > this.startTime) {
      deadlineInfo.push(`time to current attempt start: ${formatDateDifference(this.startTime, latestCall.startTime)}`);
    }
    deadlineInfo.push(...latestCall.call.getDeadlineInfo());
    return deadlineInfo;
  }
  getCallNumber(): number {
    return this.callNumber;
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '[' + this.callNumber + '] ' + text
    );
  }

  private reportStatus(statusObject: StatusObject) {
    this.trace(
      'ended with status: code=' +
        statusObject.code +
        ' details="' +
        statusObject.details +
        '" start time=' +
        this.startTime.toISOString()
    );
    this.bufferTracker.freeAll(this.callNumber);
    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
    this.writeBuffer = [];
    process.nextTick(() => {
      // Explicitly construct status object to remove progress field
      this.listener?.onReceiveStatus({
        code: statusObject.code,
        details: statusObject.details,
        metadata: statusObject.metadata,
      });
    });
  }

  cancelWithStatus(status: Status, details: string): void {
    this.trace(
      'cancelWithStatus code: ' + status + ' details: "' + details + '"'
    );
    this.reportStatus({ code: status, details, metadata: new Metadata() });
    for (const { call } of this.underlyingCalls) {
      call.cancelWithStatus(status, details);
    }
  }
  getPeer(): string {
    if (this.committedCallIndex !== null) {
      return this.underlyingCalls[this.committedCallIndex].call.getPeer();
    } else {
      return 'unknown';
    }
  }

  private getBufferEntry(messageIndex: number): WriteBufferEntry {
    return (
      this.writeBuffer[messageIndex - this.writeBufferOffset] ?? {
        entryType: 'FREED',
        allocated: false,
      }
    );
  }

  private getNextBufferIndex() {
    return this.writeBufferOffset + this.writeBuffer.length;
  }

  private clearSentMessages() {
    if (this.state !== 'COMMITTED') {
      return;
    }
    const earliestNeededMessageIndex =
      this.underlyingCalls[this.committedCallIndex!].nextMessageToSend;
    for (
      let messageIndex = this.writeBufferOffset;
      messageIndex < earliestNeededMessageIndex;
      messageIndex++
    ) {
      const bufferEntry = this.getBufferEntry(messageIndex);
      if (bufferEntry.allocated) {
        this.bufferTracker.free(
          bufferEntry.message!.message.length,
          this.callNumber
        );
      }
    }
    this.writeBuffer = this.writeBuffer.slice(
      earliestNeededMessageIndex - this.writeBufferOffset
    );
    this.writeBufferOffset = earliestNeededMessageIndex;
  }

  private commitCall(index: number) {
    if (this.state === 'COMMITTED') {
      return;
    }
    if (this.underlyingCalls[index].state === 'COMPLETED') {
      return;
    }
    this.trace(
      'Committing call [' +
        this.underlyingCalls[index].call.getCallNumber() +
        '] at index ' +
        index
    );
    this.state = 'COMMITTED';
    this.committedCallIndex = index;
    for (let i = 0; i < this.underlyingCalls.length; i++) {
      if (i === index) {
        continue;
      }
      if (this.underlyingCalls[i].state === 'COMPLETED') {
        continue;
      }
      this.underlyingCalls[i].state = 'COMPLETED';
      this.underlyingCalls[i].call.cancelWithStatus(
        Status.CANCELLED,
        'Discarded in favor of other hedged attempt'
      );
    }
    this.clearSentMessages();
  }

  private commitCallWithMostMessages() {
    if (this.state === 'COMMITTED') {
      return;
    }
    let mostMessages = -1;
    let callWithMostMessages = -1;
    for (const [index, childCall] of this.underlyingCalls.entries()) {
      if (
        childCall.state === 'ACTIVE' &&
        childCall.nextMessageToSend > mostMessages
      ) {
        mostMessages = childCall.nextMessageToSend;
        callWithMostMessages = index;
      }
    }
    if (callWithMostMessages === -1) {
      /* There are no active calls, disable retries to force the next call that
       * is started to be committed. */
      this.state = 'TRANSPARENT_ONLY';
    } else {
      this.commitCall(callWithMostMessages);
    }
  }

  private isStatusCodeInList(list: (Status | string)[], code: Status) {
    return list.some(
      value =>
        value === code ||
        value.toString().toLowerCase() === Status[code].toLowerCase()
    );
  }

  private getNextRetryBackoffMs() {
    const retryPolicy = this.callConfig?.methodConfig.retryPolicy;
    if (!retryPolicy) {
      return 0;
    }
    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
    const maxBackoffSec = Number(
      retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1)
    );
    this.nextRetryBackoffSec = Math.min(
      this.nextRetryBackoffSec * retryPolicy.backoffMultiplier,
      maxBackoffSec
    );
    return nextBackoffMs;
  }

  private maybeRetryCall(
    pushback: number | null,
    callback: (retried: boolean) => void
  ) {
    if (this.state !== 'RETRY') {
      callback(false);
      return;
    }
    if (this.attempts >= this.maxAttempts) {
      callback(false);
      return;
    }
    let retryDelayMs: number;
    if (pushback === null) {
      retryDelayMs = this.getNextRetryBackoffMs();
    } else if (pushback < 0) {
      this.state = 'TRANSPARENT_ONLY';
      callback(false);
      return;
    } else {
      retryDelayMs = pushback;
      this.nextRetryBackoffSec = this.initialRetryBackoffSec;
    }
    setTimeout(() => {
      if (this.state !== 'RETRY') {
        callback(false);
        return;
      }
      if (this.retryThrottler?.canRetryCall() ?? true) {
        callback(true);
        this.attempts += 1;
        this.startNewAttempt();
      }
    }, retryDelayMs);
  }

  private countActiveCalls(): number {
    let count = 0;
    for (const call of this.underlyingCalls) {
      if (call?.state === 'ACTIVE') {
        count += 1;
      }
    }
    return count;
  }

  private handleProcessedStatus(
    status: StatusObject,
    callIndex: number,
    pushback: number | null
  ) {
    switch (this.state) {
      case 'COMMITTED':
      case 'TRANSPARENT_ONLY':
        this.commitCall(callIndex);
        this.reportStatus(status);
        break;
      case 'HEDGING':
        if (
          this.isStatusCodeInList(
            this.callConfig!.methodConfig.hedgingPolicy!.nonFatalStatusCodes ??
              [],
            status.code
          )
        ) {
          this.retryThrottler?.addCallFailed();
          let delayMs: number;
          if (pushback === null) {
            delayMs = 0;
          } else if (pushback < 0) {
            this.state = 'TRANSPARENT_ONLY';
            this.commitCall(callIndex);
            this.reportStatus(status);
            return;
          } else {
            delayMs = pushback;
          }
          setTimeout(() => {
            this.maybeStartHedgingAttempt();
            // If after trying to start a call there are no active calls, this was the last one
            if (this.countActiveCalls() === 0) {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
          }, delayMs);
        } else {
          this.commitCall(callIndex);
          this.reportStatus(status);
        }
        break;
      case 'RETRY':
        if (
          this.isStatusCodeInList(
            this.callConfig!.methodConfig.retryPolicy!.retryableStatusCodes,
            status.code
          )
        ) {
          this.retryThrottler?.addCallFailed();
          this.maybeRetryCall(pushback, retried => {
            if (!retried) {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
          });
        } else {
          this.commitCall(callIndex);
          this.reportStatus(status);
        }
        break;
    }
  }

  private getPushback(metadata: Metadata): number | null {
    const mdValue = metadata.get('grpc-retry-pushback-ms');
    if (mdValue.length === 0) {
      return null;
    }
    try {
      return parseInt(mdValue[0] as string);
    } catch (e) {
      return -1;
    }
  }

  private handleChildStatus(
    status: StatusObjectWithProgress,
    callIndex: number
  ) {
    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {
      return;
    }
    this.trace(
      'state=' +
        this.state +
        ' handling status with progress ' +
        status.progress +
        ' from child [' +
        this.underlyingCalls[callIndex].call.getCallNumber() +
        '] in state ' +
        this.underlyingCalls[callIndex].state
    );
    this.underlyingCalls[callIndex].state = 'COMPLETED';
    if (status.code === Status.OK) {
      this.retryThrottler?.addCallSucceeded();
      this.commitCall(callIndex);
      this.reportStatus(status);
      return;
    }
    if (this.state === 'COMMITTED') {
      this.reportStatus(status);
      return;
    }
    const pushback = this.getPushback(status.metadata);
    switch (status.progress) {
      case 'NOT_STARTED':
        // RPC never leaves the client, always safe to retry
        this.startNewAttempt();
        break;
      case 'REFUSED':
        // RPC reaches the server library, but not the server application logic
        if (this.transparentRetryUsed) {
          this.handleProcessedStatus(status, callIndex, pushback);
        } else {
          this.transparentRetryUsed = true;
          this.startNewAttempt();
        }
        break;
      case 'DROP':
        this.commitCall(callIndex);
        this.reportStatus(status);
        break;
      case 'PROCESSED':
        this.handleProcessedStatus(status, callIndex, pushback);
        break;
    }
  }

  private maybeStartHedgingAttempt() {
    if (this.state !== 'HEDGING') {
      return;
    }
    if (!this.callConfig.methodConfig.hedgingPolicy) {
      return;
    }
    if (this.attempts >= this.maxAttempts) {
      return;
    }
    this.attempts += 1;
    this.startNewAttempt();
    this.maybeStartHedgingTimer();
  }

  private maybeStartHedgingTimer() {
    if (this.hedgingTimer) {
      clearTimeout(this.hedgingTimer);
    }
    if (this.state !== 'HEDGING') {
      return;
    }
    if (!this.callConfig.methodConfig.hedgingPolicy) {
      return;
    }
    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
    if (this.attempts >= this.maxAttempts) {
      return;
    }
    const hedgingDelayString = hedgingPolicy.hedgingDelay ?? '0s';
    const hedgingDelaySec = Number(
      hedgingDelayString.substring(0, hedgingDelayString.length - 1)
    );
    this.hedgingTimer = setTimeout(() => {
      this.maybeStartHedgingAttempt();
    }, hedgingDelaySec * 1000);
    this.hedgingTimer.unref?.();
  }

  private startNewAttempt() {
    const child = this.channel.createLoadBalancingCall(
      this.callConfig,
      this.methodName,
      this.host,
      this.credentials,
      this.deadline
    );
    this.trace(
      'Created child call [' +
        child.getCallNumber() +
        '] for attempt ' +
        this.attempts
    );
    const index = this.underlyingCalls.length;
    this.underlyingCalls.push({
      state: 'ACTIVE',
      call: child,
      nextMessageToSend: 0,
      startTime: new Date()
    });
    const previousAttempts = this.attempts - 1;
    const initialMetadata = this.initialMetadata!.clone();
    if (previousAttempts > 0) {
      initialMetadata.set(
        PREVIONS_RPC_ATTEMPTS_METADATA_KEY,
        `${previousAttempts}`
      );
    }
    let receivedMetadata = false;
    child.start(initialMetadata, {
      onReceiveMetadata: metadata => {
        this.trace(
          'Received metadata from child [' + child.getCallNumber() + ']'
        );
        this.commitCall(index);
        receivedMetadata = true;
        if (previousAttempts > 0) {
          metadata.set(
            PREVIONS_RPC_ATTEMPTS_METADATA_KEY,
            `${previousAttempts}`
          );
        }
        if (this.underlyingCalls[index].state === 'ACTIVE') {
          this.listener!.onReceiveMetadata(metadata);
        }
      },
      onReceiveMessage: message => {
        this.trace(
          'Received message from child [' + child.getCallNumber() + ']'
        );
        this.commitCall(index);
        if (this.underlyingCalls[index].state === 'ACTIVE') {
          this.listener!.onReceiveMessage(message);
        }
      },
      onReceiveStatus: status => {
        this.trace(
          'Received status from child [' + child.getCallNumber() + ']'
        );
        if (!receivedMetadata && previousAttempts > 0) {
          status.metadata.set(
            PREVIONS_RPC_ATTEMPTS_METADATA_KEY,
            `${previousAttempts}`
          );
        }
        this.handleChildStatus(status, index);
      },
    });
    this.sendNextChildMessage(index);
    if (this.readStarted) {
      child.startRead();
    }
  }

  start(metadata: Metadata, listener: InterceptingListener): void {
    this.trace('start called');
    this.listener = listener;
    this.initialMetadata = metadata;
    this.attempts += 1;
    this.startNewAttempt();
    this.maybeStartHedgingTimer();
  }

  private handleChildWriteCompleted(childIndex: number) {
    const childCall = this.underlyingCalls[childIndex];
    const messageIndex = childCall.nextMessageToSend;
    this.getBufferEntry(messageIndex).callback?.();
    this.clearSentMessages();
    childCall.nextMessageToSend += 1;
    this.sendNextChildMessage(childIndex);
  }

  private sendNextChildMessage(childIndex: number) {
    const childCall = this.underlyingCalls[childIndex];
    if (childCall.state === 'COMPLETED') {
      return;
    }
    if (this.getBufferEntry(childCall.nextMessageToSend)) {
      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
      switch (bufferEntry.entryType) {
        case 'MESSAGE':
          childCall.call.sendMessageWithContext(
            {
              callback: error => {
                // Ignore error
                this.handleChildWriteCompleted(childIndex);
              },
            },
            bufferEntry.message!.message
          );
          break;
        case 'HALF_CLOSE':
          childCall.nextMessageToSend += 1;
          childCall.call.halfClose();
          break;
        case 'FREED':
          // Should not be possible
          break;
      }
    }
  }

  sendMessageWithContext(context: MessageContext, message: Buffer): void {
    this.trace('write() called with message of length ' + message.length);
    const writeObj: WriteObject = {
      message,
      flags: context.flags,
    };
    const messageIndex = this.getNextBufferIndex();
    const bufferEntry: WriteBufferEntry = {
      entryType: 'MESSAGE',
      message: writeObj,
      allocated: this.bufferTracker.allocate(message.length, this.callNumber),
    };
    this.writeBuffer.push(bufferEntry);
    if (bufferEntry.allocated) {
      context.callback?.();
      for (const [callIndex, call] of this.underlyingCalls.entries()) {
        if (
          call.state === 'ACTIVE' &&
          call.nextMessageToSend === messageIndex
        ) {
          call.call.sendMessageWithContext(
            {
              callback: error => {
                // Ignore error
                this.handleChildWriteCompleted(callIndex);
              },
            },
            message
          );
        }
      }
    } else {
      this.commitCallWithMostMessages();
      // commitCallWithMostMessages can fail if we are between ping attempts
      if (this.committedCallIndex === null) {
        return;
      }
      const call = this.underlyingCalls[this.committedCallIndex];
      bufferEntry.callback = context.callback;
      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {
        call.call.sendMessageWithContext(
          {
            callback: error => {
              // Ignore error
              this.handleChildWriteCompleted(this.committedCallIndex!);
            },
          },
          message
        );
      }
    }
  }
  startRead(): void {
    this.trace('startRead called');
    this.readStarted = true;
    for (const underlyingCall of this.underlyingCalls) {
      if (underlyingCall?.state === 'ACTIVE') {
        underlyingCall.call.startRead();
      }
    }
  }
  halfClose(): void {
    this.trace('halfClose called');
    const halfCloseIndex = this.getNextBufferIndex();
    this.writeBuffer.push({
      entryType: 'HALF_CLOSE',
      allocated: false,
    });
    for (const call of this.underlyingCalls) {
      if (
        call?.state === 'ACTIVE' &&
        call.nextMessageToSend === halfCloseIndex
      ) {
        call.nextMessageToSend += 1;
        call.call.halfClose();
      }
    }
  }
  setCredentials(newCredentials: CallCredentials): void {
    throw new Error('Method not implemented.');
  }
  getMethod(): string {
    return this.methodName;
  }
  getHost(): string {
    return this.host;
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { EventEmitter } from 'events';
import { Duplex, Readable, Writable } from 'stream';

import { Status } from './constants';
import type { Deserialize, Serialize } from './make-client';
import { Metadata } from './metadata';
import type { ObjectReadable, ObjectWritable } from './object-stream';
import type { StatusObject, PartialStatusObject } from './call-interface';
import type { Deadline } from './deadline';
import type { ServerInterceptingCallInterface } from './server-interceptors';

export type ServerStatusResponse = Partial<StatusObject>;

export type ServerErrorResponse = ServerStatusResponse & Error;

export type ServerSurfaceCall = {
  cancelled: boolean;
  readonly metadata: Metadata;
  getPeer(): string;
  sendMetadata(responseMetadata: Metadata): void;
  getDeadline(): Deadline;
  getPath(): string;
  getHost(): string;
} & EventEmitter;

export type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {
  request: RequestType;
};
export type ServerReadableStream<RequestType, ResponseType> =
  ServerSurfaceCall & ObjectReadable<RequestType>;
export type ServerWritableStream<RequestType, ResponseType> =
  ServerSurfaceCall &
    ObjectWritable<ResponseType> & {
      request: RequestType;
      end: (metadata?: Metadata) => void;
    };
export type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &
  ObjectReadable<RequestType> &
  ObjectWritable<ResponseType> & { end: (metadata?: Metadata) => void };

export function serverErrorToStatus(
  error: ServerErrorResponse | ServerStatusResponse,
  overrideTrailers?: Metadata | undefined
): PartialStatusObject {
  const status: PartialStatusObject = {
    code: Status.UNKNOWN,
    details: 'message' in error ? error.message : 'Unknown Error',
    metadata: overrideTrailers ?? error.metadata ?? null,
  };

  if (
    'code' in error &&
    typeof error.code === 'number' &&
    Number.isInteger(error.code)
  ) {
    status.code = error.code;

    if ('details' in error && typeof error.details === 'string') {
      status.details = error.details!;
    }
  }
  return status;
}

export class ServerUnaryCallImpl<RequestType, ResponseType>
  extends EventEmitter
  implements ServerUnaryCall<RequestType, ResponseType>
{
  cancelled: boolean;

  constructor(
    private path: string,
    private call: ServerInterceptingCallInterface,
    public metadata: Metadata,
    public request: RequestType
  ) {
    super();
    this.cancelled = false;
  }

  getPeer(): string {
    return this.call.getPeer();
  }

  sendMetadata(responseMetadata: Metadata): void {
    this.call.sendMetadata(responseMetadata);
  }

  getDeadline(): Deadline {
    return this.call.getDeadline();
  }

  getPath(): string {
    return this.path;
  }

  getHost(): string {
    return this.call.getHost();
  }
}

export class ServerReadableStreamImpl<RequestType, ResponseType>
  extends Readable
  implements ServerReadableStream<RequestType, ResponseType>
{
  cancelled: boolean;

  constructor(
    private path: string,
    private call: ServerInterceptingCallInterface,
    public metadata: Metadata
  ) {
    super({ objectMode: true });
    this.cancelled = false;
  }

  _read(size: number) {
    this.call.startRead();
  }

  getPeer(): string {
    return this.call.getPeer();
  }

  sendMetadata(responseMetadata: Metadata): void {
    this.call.sendMetadata(responseMetadata);
  }

  getDeadline(): Deadline {
    return this.call.getDeadline();
  }

  getPath(): string {
    return this.path;
  }

  getHost(): string {
    return this.call.getHost();
  }
}

export class ServerWritableStreamImpl<RequestType, ResponseType>
  extends Writable
  implements ServerWritableStream<RequestType, ResponseType>
{
  cancelled: boolean;
  private trailingMetadata: Metadata;
  private pendingStatus: PartialStatusObject = {
    code: Status.OK,
    details: 'OK',
  };

  constructor(
    private path: string,
    private call: ServerInterceptingCallInterface,
    public metadata: Metadata,
    public request: RequestType
  ) {
    super({ objectMode: true });
    this.cancelled = false;
    this.trailingMetadata = new Metadata();

    this.on('error', err => {
      this.pendingStatus = serverErrorToStatus(err);
      this.end();
    });
  }

  getPeer(): string {
    return this.call.getPeer();
  }

  sendMetadata(responseMetadata: Metadata): void {
    this.call.sendMetadata(responseMetadata);
  }

  getDeadline(): Deadline {
    return this.call.getDeadline();
  }

  getPath(): string {
    return this.path;
  }

  getHost(): string {
    return this.call.getHost();
  }

  _write(
    chunk: ResponseType,
    encoding: string,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback: (...args: any[]) => void
  ) {
    this.call.sendMessage(chunk, callback);
  }

  _final(callback: Function): void {
    callback(null);
    this.call.sendStatus({
      ...this.pendingStatus,
      metadata: this.pendingStatus.metadata ?? this.trailingMetadata,
    });
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  end(metadata?: any) {
    if (metadata) {
      this.trailingMetadata = metadata;
    }

    return super.end();
  }
}

export class ServerDuplexStreamImpl<RequestType, ResponseType>
  extends Duplex
  implements ServerDuplexStream<RequestType, ResponseType>
{
  cancelled: boolean;
  private trailingMetadata: Metadata;
  private pendingStatus: PartialStatusObject = {
    code: Status.OK,
    details: 'OK',
  };

  constructor(
    private path: string,
    private call: ServerInterceptingCallInterface,
    public metadata: Metadata
  ) {
    super({ objectMode: true });
    this.cancelled = false;
    this.trailingMetadata = new Metadata();

    this.on('error', err => {
      this.pendingStatus = serverErrorToStatus(err);
      this.end();
    });
  }

  getPeer(): string {
    return this.call.getPeer();
  }

  sendMetadata(responseMetadata: Metadata): void {
    this.call.sendMetadata(responseMetadata);
  }

  getDeadline(): Deadline {
    return this.call.getDeadline();
  }

  getPath(): string {
    return this.path;
  }

  getHost(): string {
    return this.call.getHost();
  }

  _read(size: number) {
    this.call.startRead();
  }

  _write(
    chunk: ResponseType,
    encoding: string,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback: (...args: any[]) => void
  ) {
    this.call.sendMessage(chunk, callback);
  }

  _final(callback: Function): void {
    callback(null);
    this.call.sendStatus({
      ...this.pendingStatus,
      metadata: this.pendingStatus.metadata ?? this.trailingMetadata,
    });
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  end(metadata?: any) {
    if (metadata) {
      this.trailingMetadata = metadata;
    }

    return super.end();
  }
}

// Unary response callback signature.
export type sendUnaryData<ResponseType> = (
  error: ServerErrorResponse | ServerStatusResponse | null,
  value?: ResponseType | null,
  trailer?: Metadata,
  flags?: number
) => void;

// User provided handler for unary calls.
export type handleUnaryCall<RequestType, ResponseType> = (
  call: ServerUnaryCall<RequestType, ResponseType>,
  callback: sendUnaryData<ResponseType>
) => void;

// User provided handler for client streaming calls.
export type handleClientStreamingCall<RequestType, ResponseType> = (
  call: ServerReadableStream<RequestType, ResponseType>,
  callback: sendUnaryData<ResponseType>
) => void;

// User provided handler for server streaming calls.
export type handleServerStreamingCall<RequestType, ResponseType> = (
  call: ServerWritableStream<RequestType, ResponseType>
) => void;

// User provided handler for bidirectional streaming calls.
export type handleBidiStreamingCall<RequestType, ResponseType> = (
  call: ServerDuplexStream<RequestType, ResponseType>
) => void;

export type HandleCall<RequestType, ResponseType> =
  | handleUnaryCall<RequestType, ResponseType>
  | handleClientStreamingCall<RequestType, ResponseType>
  | handleServerStreamingCall<RequestType, ResponseType>
  | handleBidiStreamingCall<RequestType, ResponseType>;

export interface UnaryHandler<RequestType, ResponseType> {
  func: handleUnaryCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: 'unary';
  path: string;
}

export interface ClientStreamingHandler<RequestType, ResponseType> {
  func: handleClientStreamingCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: 'clientStream';
  path: string;
}

export interface ServerStreamingHandler<RequestType, ResponseType> {
  func: handleServerStreamingCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: 'serverStream';
  path: string;
}

export interface BidiStreamingHandler<RequestType, ResponseType> {
  func: handleBidiStreamingCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: 'bidi';
  path: string;
}

export type Handler<RequestType, ResponseType> =
  | UnaryHandler<RequestType, ResponseType>
  | ClientStreamingHandler<RequestType, ResponseType>
  | ServerStreamingHandler<RequestType, ResponseType>
  | BidiStreamingHandler<RequestType, ResponseType>;

export type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { SecureServerOptions } from 'http2';
import { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';
import { SecureContextOptions } from 'tls';
import { ServerInterceptor } from '.';

export interface KeyCertPair {
  private_key: Buffer;
  cert_chain: Buffer;
}

export interface SecureContextWatcher {
  (context: SecureContextOptions | null): void;
}

export abstract class ServerCredentials {
  private watchers: Set<SecureContextWatcher> = new Set();
  private latestContextOptions: SecureServerOptions | null = null;
  _addWatcher(watcher: SecureContextWatcher) {
    this.watchers.add(watcher);
  }
  _removeWatcher(watcher: SecureContextWatcher) {
    this.watchers.delete(watcher);
  }
  protected updateSecureContextOptions(options: SecureServerOptions | null) {
    if (options) {
      this.latestContextOptions = options;
    } else {
      this.latestContextOptions = null;
    }
    for (const watcher of this.watchers) {
      watcher(this.latestContextOptions);
    }
  }
  abstract _isSecure(): boolean;
  _getSettings(): SecureServerOptions | null {
    return this.latestContextOptions;
  }
  _getInterceptors(): ServerInterceptor[] {
    return [];
  }
  abstract _equals(other: ServerCredentials): boolean;

  static createInsecure(): ServerCredentials {
    return new InsecureServerCredentials();
  }

  static createSsl(
    rootCerts: Buffer | null,
    keyCertPairs: KeyCertPair[],
    checkClientCertificate = false
  ): ServerCredentials {
    if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
      throw new TypeError('rootCerts must be null or a Buffer');
    }

    if (!Array.isArray(keyCertPairs)) {
      throw new TypeError('keyCertPairs must be an array');
    }

    if (typeof checkClientCertificate !== 'boolean') {
      throw new TypeError('checkClientCertificate must be a boolean');
    }

    const cert: Buffer[] = [];
    const key: Buffer[] = [];

    for (let i = 0; i < keyCertPairs.length; i++) {
      const pair = keyCertPairs[i];

      if (pair === null || typeof pair !== 'object') {
        throw new TypeError(`keyCertPair[${i}] must be an object`);
      }

      if (!Buffer.isBuffer(pair.private_key)) {
        throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
      }

      if (!Buffer.isBuffer(pair.cert_chain)) {
        throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
      }

      cert.push(pair.cert_chain);
      key.push(pair.private_key);
    }

    return new SecureServerCredentials({
      ca: rootCerts ?? getDefaultRootsData() ?? undefined,
      cert,
      key,
      requestCert: checkClientCertificate,
      ciphers: CIPHER_SUITES,
    });
  }
}

class InsecureServerCredentials extends ServerCredentials {
  _isSecure(): boolean {
    return false;
  }

  _getSettings(): null {
    return null;
  }

  _equals(other: ServerCredentials): boolean {
    return other instanceof InsecureServerCredentials;
  }
}

class SecureServerCredentials extends ServerCredentials {
  private options: SecureServerOptions;

  constructor(options: SecureServerOptions) {
    super();
    this.options = options;
  }

  _isSecure(): boolean {
    return true;
  }

  _getSettings(): SecureServerOptions {
    return this.options;
  }

  /**
   * Checks equality by checking the options that are actually set by
   * createSsl.
   * @param other
   * @returns
   */
  _equals(other: ServerCredentials): boolean {
    if (this === other) {
      return true;
    }
    if (!(other instanceof SecureServerCredentials)) {
      return false;
    }
    // options.ca equality check
    if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
      if (!this.options.ca.equals(other.options.ca)) {
        return false;
      }
    } else {
      if (this.options.ca !== other.options.ca) {
        return false;
      }
    }
    // options.cert equality check
    if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
      if (this.options.cert.length !== other.options.cert.length) {
        return false;
      }
      for (let i = 0; i < this.options.cert.length; i++) {
        const thisCert = this.options.cert[i];
        const otherCert = other.options.cert[i];
        if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
          if (!thisCert.equals(otherCert)) {
            return false;
          }
        } else {
          if (thisCert !== otherCert) {
            return false;
          }
        }
      }
    } else {
      if (this.options.cert !== other.options.cert) {
        return false;
      }
    }
    // options.key equality check
    if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
      if (this.options.key.length !== other.options.key.length) {
        return false;
      }
      for (let i = 0; i < this.options.key.length; i++) {
        const thisKey = this.options.key[i];
        const otherKey = other.options.key[i];
        if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
          if (!thisKey.equals(otherKey)) {
            return false;
          }
        } else {
          if (thisKey !== otherKey) {
            return false;
          }
        }
      }
    } else {
      if (this.options.key !== other.options.key) {
        return false;
      }
    }
    // options.requestCert equality check
    if (this.options.requestCert !== other.options.requestCert) {
      return false;
    }
    /* ciphers is derived from a value that is constant for the process, so no
     * equality check is needed. */
    return true;
  }
}

class InterceptorServerCredentials extends ServerCredentials {
  constructor(private readonly childCredentials: ServerCredentials, private readonly interceptors: ServerInterceptor[]) {
    super();
  }
  _isSecure(): boolean {
    return this.childCredentials._isSecure();
  }
  _equals(other: ServerCredentials): boolean {
    if (!(other instanceof InterceptorServerCredentials)) {
      return false;
    }
    if (!(this.childCredentials._equals(other.childCredentials))) {
      return false;
    }
    if (this.interceptors.length !== other.interceptors.length) {
      return false;
    }
    for (let i = 0; i < this.interceptors.length; i++) {
      if (this.interceptors[i] !== other.interceptors[i]) {
        return false;
      }
    }
    return true;
  }
  override _getInterceptors(): ServerInterceptor[] {
    return this.interceptors;
  }
  override _addWatcher(watcher: SecureContextWatcher): void {
    this.childCredentials._addWatcher(watcher);
  }
  override _removeWatcher(watcher: SecureContextWatcher): void {
    this.childCredentials._removeWatcher(watcher);
  }
}

export function createServerCredentialsWithInterceptors(credentials: ServerCredentials, interceptors: ServerInterceptor[]): ServerCredentials {
  return new InterceptorServerCredentials(credentials, interceptors);
}
/*
 * Copyright 2024 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { PartialStatusObject } from './call-interface';
import { ServerMethodDefinition } from './make-client';
import { Metadata } from './metadata';
import { ChannelOptions } from './channel-options';
import { Handler, ServerErrorResponse } from './server-call';
import { Deadline } from './deadline';
import {
  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,
  DEFAULT_MAX_SEND_MESSAGE_LENGTH,
  LogVerbosity,
  Status,
} from './constants';
import * as http2 from 'http2';
import { getErrorMessage } from './error';
import * as zlib from 'zlib';
import { StreamDecoder } from './stream-decoder';
import { CallEventTracker } from './transport';
import * as logging from './logging';

const TRACER_NAME = 'server_call';

function trace(text: string) {
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

export interface ServerMetadataListener {
  (metadata: Metadata, next: (metadata: Metadata) => void): void;
}

export interface ServerMessageListener {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (message: any, next: (message: any) => void): void;
}

export interface ServerHalfCloseListener {
  (next: () => void): void;
}

export interface ServerCancelListener {
  (): void;
}

export interface FullServerListener {
  onReceiveMetadata: ServerMetadataListener;
  onReceiveMessage: ServerMessageListener;
  onReceiveHalfClose: ServerHalfCloseListener;
  onCancel: ServerCancelListener;
}

export type ServerListener = Partial<FullServerListener>;

export class ServerListenerBuilder {
  private metadata: ServerMetadataListener | undefined = undefined;
  private message: ServerMessageListener | undefined = undefined;
  private halfClose: ServerHalfCloseListener | undefined = undefined;
  private cancel: ServerCancelListener | undefined = undefined;

  withOnReceiveMetadata(onReceiveMetadata: ServerMetadataListener): this {
    this.metadata = onReceiveMetadata;
    return this;
  }

  withOnReceiveMessage(onReceiveMessage: ServerMessageListener): this {
    this.message = onReceiveMessage;
    return this;
  }

  withOnReceiveHalfClose(onReceiveHalfClose: ServerHalfCloseListener): this {
    this.halfClose = onReceiveHalfClose;
    return this;
  }

  withOnCancel(onCancel: ServerCancelListener): this {
    this.cancel = onCancel;
    return this;
  }

  build(): ServerListener {
    return {
      onReceiveMetadata: this.metadata,
      onReceiveMessage: this.message,
      onReceiveHalfClose: this.halfClose,
      onCancel: this.cancel,
    };
  }
}

export interface InterceptingServerListener {
  onReceiveMetadata(metadata: Metadata): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onReceiveMessage(message: any): void;
  onReceiveHalfClose(): void;
  onCancel(): void;
}

export function isInterceptingServerListener(
  listener: ServerListener | InterceptingServerListener
): listener is InterceptingServerListener {
  return (
    listener.onReceiveMetadata !== undefined &&
    listener.onReceiveMetadata.length === 1
  );
}

class InterceptingServerListenerImpl implements InterceptingServerListener {
  /**
   * Once the call is cancelled, ignore all other events.
   */
  private cancelled = false;
  private processingMetadata = false;
  private hasPendingMessage = false;
  private pendingMessage: any = null;
  private processingMessage = false;
  private hasPendingHalfClose = false;

  constructor(
    private listener: FullServerListener,
    private nextListener: InterceptingServerListener
  ) {}

  private processPendingMessage() {
    if (this.hasPendingMessage) {
      this.nextListener.onReceiveMessage(this.pendingMessage);
      this.pendingMessage = null;
      this.hasPendingMessage = false;
    }
  }

  private processPendingHalfClose() {
    if (this.hasPendingHalfClose) {
      this.nextListener.onReceiveHalfClose();
      this.hasPendingHalfClose = false;
    }
  }

  onReceiveMetadata(metadata: Metadata): void {
    if (this.cancelled) {
      return;
    }
    this.processingMetadata = true;
    this.listener.onReceiveMetadata(metadata, interceptedMetadata => {
      this.processingMetadata = false;
      if (this.cancelled) {
        return;
      }
      this.nextListener.onReceiveMetadata(interceptedMetadata);
      this.processPendingMessage();
      this.processPendingHalfClose();
    });
  }
  onReceiveMessage(message: any): void {
    if (this.cancelled) {
      return;
    }
    this.processingMessage = true;
    this.listener.onReceiveMessage(message, msg => {
      this.processingMessage = false;
      if (this.cancelled) {
        return;
      }
      if (this.processingMetadata) {
        this.pendingMessage = msg;
        this.hasPendingMessage = true;
      } else {
        this.nextListener.onReceiveMessage(msg);
        this.processPendingHalfClose();
      }
    });
  }
  onReceiveHalfClose(): void {
    if (this.cancelled) {
      return;
    }
    this.listener.onReceiveHalfClose(() => {
      if (this.cancelled) {
        return;
      }
      if (this.processingMetadata || this.processingMessage) {
        this.hasPendingHalfClose = true;
      } else {
        this.nextListener.onReceiveHalfClose();
      }
    });
  }
  onCancel(): void {
    this.cancelled = true;
    this.listener.onCancel();
    this.nextListener.onCancel();
  }
}

export interface StartResponder {
  (next: (listener?: ServerListener) => void): void;
}

export interface MetadataResponder {
  (metadata: Metadata, next: (metadata: Metadata) => void): void;
}

export interface MessageResponder {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (message: any, next: (message: any) => void): void;
}

export interface StatusResponder {
  (
    status: PartialStatusObject,
    next: (status: PartialStatusObject) => void
  ): void;
}

export interface FullResponder {
  start: StartResponder;
  sendMetadata: MetadataResponder;
  sendMessage: MessageResponder;
  sendStatus: StatusResponder;
}

export type Responder = Partial<FullResponder>;

export class ResponderBuilder {
  private start: StartResponder | undefined = undefined;
  private metadata: MetadataResponder | undefined = undefined;
  private message: MessageResponder | undefined = undefined;
  private status: StatusResponder | undefined = undefined;

  withStart(start: StartResponder): this {
    this.start = start;
    return this;
  }

  withSendMetadata(sendMetadata: MetadataResponder): this {
    this.metadata = sendMetadata;
    return this;
  }

  withSendMessage(sendMessage: MessageResponder): this {
    this.message = sendMessage;
    return this;
  }

  withSendStatus(sendStatus: StatusResponder): this {
    this.status = sendStatus;
    return this;
  }

  build(): Responder {
    return {
      start: this.start,
      sendMetadata: this.metadata,
      sendMessage: this.message,
      sendStatus: this.status,
    };
  }
}

const defaultServerListener: FullServerListener = {
  onReceiveMetadata: (metadata, next) => {
    next(metadata);
  },
  onReceiveMessage: (message, next) => {
    next(message);
  },
  onReceiveHalfClose: next => {
    next();
  },
  onCancel: () => {},
};

const defaultResponder: FullResponder = {
  start: next => {
    next();
  },
  sendMetadata: (metadata, next) => {
    next(metadata);
  },
  sendMessage: (message, next) => {
    next(message);
  },
  sendStatus: (status, next) => {
    next(status);
  },
};

export interface ServerInterceptingCallInterface {
  /**
   * Register the listener to handle inbound events.
   */
  start(listener: InterceptingServerListener): void;
  /**
   * Send response metadata.
   */
  sendMetadata(metadata: Metadata): void;
  /**
   * Send a response message.
   */
  sendMessage(message: any, callback: () => void): void;
  /**
   * End the call by sending this status.
   */
  sendStatus(status: PartialStatusObject): void;
  /**
   * Start a single read, eventually triggering either listener.onReceiveMessage or listener.onReceiveHalfClose.
   */
  startRead(): void;
  /**
   * Return the peer address of the client making the request, if known, or "unknown" otherwise
   */
  getPeer(): string;
  /**
   * Return the call deadline set by the client. The value is Infinity if there is no deadline.
   */
  getDeadline(): Deadline;
  /**
   * Return the host requested by the client in the ":authority" header.
   */
  getHost(): string;
}

export class ServerInterceptingCall implements ServerInterceptingCallInterface {
  private responder: FullResponder;
  private processingMetadata = false;
  private processingMessage = false;
  private pendingMessage: any = null;
  private pendingMessageCallback: (() => void) | null = null;
  private pendingStatus: PartialStatusObject | null = null;
  constructor(
    private nextCall: ServerInterceptingCallInterface,
    responder?: Responder
  ) {
    this.responder = {
      start: responder?.start ?? defaultResponder.start,
      sendMetadata: responder?.sendMetadata ?? defaultResponder.sendMetadata,
      sendMessage: responder?.sendMessage ?? defaultResponder.sendMessage,
      sendStatus: responder?.sendStatus ?? defaultResponder.sendStatus,
    };
  }

  private processPendingMessage() {
    if (this.pendingMessageCallback) {
      this.nextCall.sendMessage(
        this.pendingMessage,
        this.pendingMessageCallback
      );
      this.pendingMessage = null;
      this.pendingMessageCallback = null;
    }
  }

  private processPendingStatus() {
    if (this.pendingStatus) {
      this.nextCall.sendStatus(this.pendingStatus);
      this.pendingStatus = null;
    }
  }

  start(listener: InterceptingServerListener): void {
    this.responder.start(interceptedListener => {
      const fullInterceptedListener: FullServerListener = {
        onReceiveMetadata:
          interceptedListener?.onReceiveMetadata ??
          defaultServerListener.onReceiveMetadata,
        onReceiveMessage:
          interceptedListener?.onReceiveMessage ??
          defaultServerListener.onReceiveMessage,
        onReceiveHalfClose:
          interceptedListener?.onReceiveHalfClose ??
          defaultServerListener.onReceiveHalfClose,
        onCancel:
          interceptedListener?.onCancel ?? defaultServerListener.onCancel,
      };
      const finalInterceptingListener = new InterceptingServerListenerImpl(
        fullInterceptedListener,
        listener
      );
      this.nextCall.start(finalInterceptingListener);
    });
  }
  sendMetadata(metadata: Metadata): void {
    this.processingMetadata = true;
    this.responder.sendMetadata(metadata, interceptedMetadata => {
      this.processingMetadata = false;
      this.nextCall.sendMetadata(interceptedMetadata);
      this.processPendingMessage();
      this.processPendingStatus();
    });
  }
  sendMessage(message: any, callback: () => void): void {
    this.processingMessage = true;
    this.responder.sendMessage(message, interceptedMessage => {
      this.processingMessage = false;
      if (this.processingMetadata) {
        this.pendingMessage = interceptedMessage;
        this.pendingMessageCallback = callback;
      } else {
        this.nextCall.sendMessage(interceptedMessage, callback);
      }
    });
  }
  sendStatus(status: PartialStatusObject): void {
    this.responder.sendStatus(status, interceptedStatus => {
      if (this.processingMetadata || this.processingMessage) {
        this.pendingStatus = interceptedStatus;
      } else {
        this.nextCall.sendStatus(interceptedStatus);
      }
    });
  }
  startRead(): void {
    this.nextCall.startRead();
  }
  getPeer(): string {
    return this.nextCall.getPeer();
  }
  getDeadline(): Deadline {
    return this.nextCall.getDeadline();
  }
  getHost(): string {
    return this.nextCall.getHost();
  }
}

export interface ServerInterceptor {
  (
    methodDescriptor: ServerMethodDefinition<any, any>,
    call: ServerInterceptingCallInterface
  ): ServerInterceptingCall;
}

interface DeadlineUnitIndexSignature {
  [name: string]: number;
}

const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
const GRPC_ENCODING_HEADER = 'grpc-encoding';
const GRPC_MESSAGE_HEADER = 'grpc-message';
const GRPC_STATUS_HEADER = 'grpc-status';
const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
const DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
const deadlineUnitsToMs: DeadlineUnitIndexSignature = {
  H: 3600000,
  M: 60000,
  S: 1000,
  m: 1,
  u: 0.001,
  n: 0.000001,
};

const defaultCompressionHeaders = {
  // TODO(cjihrig): Remove these encoding headers from the default response
  // once compression is integrated.
  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
  [GRPC_ENCODING_HEADER]: 'identity',
};
const defaultResponseHeaders = {
  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
};
const defaultResponseOptions = {
  waitForTrailers: true,
} as http2.ServerStreamResponseOptions;

type ReadQueueEntryType = 'COMPRESSED' | 'READABLE' | 'HALF_CLOSE';

interface ReadQueueEntry {
  type: ReadQueueEntryType;
  compressedMessage: Buffer | null;
  parsedMessage: any;
}

export class BaseServerInterceptingCall
  implements ServerInterceptingCallInterface
{
  private listener: InterceptingServerListener | null = null;
  private metadata: Metadata;
  private deadlineTimer: NodeJS.Timeout | null = null;
  private deadline: Deadline = Infinity;
  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;
  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
  private cancelled = false;
  private metadataSent = false;
  private wantTrailers = false;
  private cancelNotified = false;
  private incomingEncoding = 'identity';
  private decoder: StreamDecoder;
  private readQueue: ReadQueueEntry[] = [];
  private isReadPending = false;
  private receivedHalfClose = false;
  private streamEnded = false;
  private host: string;

  constructor(
    private readonly stream: http2.ServerHttp2Stream,
    headers: http2.IncomingHttpHeaders,
    private readonly callEventTracker: CallEventTracker | null,
    private readonly handler: Handler<any, any>,
    options: ChannelOptions
  ) {
    this.stream.once('error', (err: ServerErrorResponse) => {
      /* We need an error handler to avoid uncaught error event exceptions, but
       * there is nothing we can reasonably do here. Any error event should
       * have a corresponding close event, which handles emitting the cancelled
       * event. And the stream is now in a bad state, so we can't reasonably
       * expect to be able to send an error over it. */
    });

    this.stream.once('close', () => {
      trace(
        'Request to method ' +
          this.handler?.path +
          ' stream closed with rstCode ' +
          this.stream.rstCode
      );

      if (this.callEventTracker && !this.streamEnded) {
        this.streamEnded = true;
        this.callEventTracker.onStreamEnd(false);
        this.callEventTracker.onCallEnd({
          code: Status.CANCELLED,
          details: 'Stream closed before sending status',
          metadata: null,
        });
      }

      this.notifyOnCancel();
    });

    this.stream.on('data', (data: Buffer) => {
      this.handleDataFrame(data);
    });
    this.stream.pause();

    this.stream.on('end', () => {
      this.handleEndEvent();
    });

    if ('grpc.max_send_message_length' in options) {
      this.maxSendMessageSize = options['grpc.max_send_message_length']!;
    }
    if ('grpc.max_receive_message_length' in options) {
      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;
    }

    this.host = headers[':authority'] ?? headers.host!;
    this.decoder = new StreamDecoder(this.maxReceiveMessageSize);

    const metadata = Metadata.fromHttp2Headers(headers);

    if (logging.isTracerEnabled(TRACER_NAME)) {
      trace(
        'Request to ' +
          this.handler.path +
          ' received headers ' +
          JSON.stringify(metadata.toJSON())
      );
    }

    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);

    if (timeoutHeader.length > 0) {
      this.handleTimeoutHeader(timeoutHeader[0] as string);
    }

    const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);

    if (encodingHeader.length > 0) {
      this.incomingEncoding = encodingHeader[0] as string;
    }

    // Remove several headers that should not be propagated to the application
    metadata.remove(GRPC_TIMEOUT_HEADER);
    metadata.remove(GRPC_ENCODING_HEADER);
    metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
    metadata.remove(http2.constants.HTTP2_HEADER_TE);
    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
    this.metadata = metadata;
  }

  private handleTimeoutHeader(timeoutHeader: string) {
    const match = timeoutHeader.toString().match(DEADLINE_REGEX);

    if (match === null) {
      const status: PartialStatusObject = {
        code: Status.INTERNAL,
        details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
        metadata: null,
      };
      // Wait for the constructor to complete before sending the error.
      process.nextTick(() => {
        this.sendStatus(status);
      });
      return;
    }

    const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;

    const now = new Date();
    this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
    this.deadlineTimer = setTimeout(() => {
      const status: PartialStatusObject = {
        code: Status.DEADLINE_EXCEEDED,
        details: 'Deadline exceeded',
        metadata: null,
      };
      this.sendStatus(status);
    }, timeout);
  }

  private checkCancelled(): boolean {
    /* In some cases the stream can become destroyed before the close event
     * fires. That creates a race condition that this check works around */
    if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
      this.notifyOnCancel();
      this.cancelled = true;
    }
    return this.cancelled;
  }
  private notifyOnCancel() {
    if (this.cancelNotified) {
      return;
    }
    this.cancelNotified = true;
    this.cancelled = true;
    process.nextTick(() => {
      this.listener?.onCancel();
    });
    if (this.deadlineTimer) {
      clearTimeout(this.deadlineTimer);
    }
    // Flush incoming data frames
    this.stream.resume();
  }

  /**
   * A server handler can start sending messages without explicitly sending
   * metadata. In that case, we need to send headers before sending any
   * messages. This function does that if necessary.
   */
  private maybeSendMetadata() {
    if (!this.metadataSent) {
      this.sendMetadata(new Metadata());
    }
  }

  /**
   * Serialize a message to a length-delimited byte string.
   * @param value
   * @returns
   */
  private serializeMessage(value: any) {
    const messageBuffer = this.handler.serialize(value);
    const byteLength = messageBuffer.byteLength;
    const output = Buffer.allocUnsafe(byteLength + 5);
    /* Note: response compression is currently not supported, so this
     * compressed bit is always 0. */
    output.writeUInt8(0, 0);
    output.writeUInt32BE(byteLength, 1);
    messageBuffer.copy(output, 5);
    return output;
  }

  private decompressMessage(
    message: Buffer,
    encoding: string
  ): Buffer | Promise<Buffer> {
    const messageContents = message.subarray(5);
    if (encoding === 'identity') {
      return messageContents;
    } else if (encoding === 'deflate' || encoding === 'gzip') {
      let decompresser: zlib.Gunzip | zlib.Deflate;
      if (encoding === 'deflate') {
        decompresser = zlib.createInflate();
      } else {
        decompresser = zlib.createGunzip();
      }
      return new Promise((resolve, reject) => {
        let totalLength = 0
        const messageParts: Buffer[] = [];
        decompresser.on('data', (chunk: Buffer) => {
          messageParts.push(chunk);
          totalLength += chunk.byteLength;
          if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {
            decompresser.destroy();
            reject({
              code: Status.RESOURCE_EXHAUSTED,
              details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
            });
          }
        });
        decompresser.on('end', () => {
          resolve(Buffer.concat(messageParts));
        });
        decompresser.write(messageContents);
        decompresser.end();
      });
    } else {
      return Promise.reject({
        code: Status.UNIMPLEMENTED,
        details: `Received message compressed with unsupported encoding "${encoding}"`,
      });
    }
  }

  private async decompressAndMaybePush(queueEntry: ReadQueueEntry) {
    if (queueEntry.type !== 'COMPRESSED') {
      throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
    }

    const compressed = queueEntry.compressedMessage!.readUInt8(0) === 1;
    const compressedMessageEncoding = compressed
      ? this.incomingEncoding
      : 'identity';
    let decompressedMessage: Buffer;
    try {
      decompressedMessage = await this.decompressMessage(
        queueEntry.compressedMessage!,
        compressedMessageEncoding
      );
    } catch (err) {
      this.sendStatus(err as PartialStatusObject);
      return;
    }
    try {
      queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
    } catch (err) {
      this.sendStatus({
        code: Status.INTERNAL,
        details: `Error deserializing request: ${(err as Error).message}`,
      });
      return;
    }
    queueEntry.type = 'READABLE';
    this.maybePushNextMessage();
  }

  private maybePushNextMessage() {
    if (
      this.listener &&
      this.isReadPending &&
      this.readQueue.length > 0 &&
      this.readQueue[0].type !== 'COMPRESSED'
    ) {
      this.isReadPending = false;
      const nextQueueEntry = this.readQueue.shift()!;
      if (nextQueueEntry.type === 'READABLE') {
        this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
      } else {
        // nextQueueEntry.type === 'HALF_CLOSE'
        this.listener.onReceiveHalfClose();
      }
    }
  }

  private handleDataFrame(data: Buffer) {
    if (this.checkCancelled()) {
      return;
    }
    trace(
      'Request to ' +
        this.handler.path +
        ' received data frame of size ' +
        data.length
    );
    let rawMessages: Buffer[];
    try {
      rawMessages = this.decoder.write(data);
    } catch (e) {
      this.sendStatus({ code: Status.RESOURCE_EXHAUSTED, details: (e as Error).message });
      return;
    }

    for (const messageBytes of rawMessages) {
      this.stream.pause();
      const queueEntry: ReadQueueEntry = {
        type: 'COMPRESSED',
        compressedMessage: messageBytes,
        parsedMessage: null,
      };
      this.readQueue.push(queueEntry);
      this.decompressAndMaybePush(queueEntry);
      this.callEventTracker?.addMessageReceived();
    }
  }
  private handleEndEvent() {
    this.readQueue.push({
      type: 'HALF_CLOSE',
      compressedMessage: null,
      parsedMessage: null,
    });
    this.receivedHalfClose = true;
    this.maybePushNextMessage();
  }
  start(listener: InterceptingServerListener): void {
    trace('Request to ' + this.handler.path + ' start called');
    if (this.checkCancelled()) {
      return;
    }
    this.listener = listener;
    listener.onReceiveMetadata(this.metadata);
  }
  sendMetadata(metadata: Metadata): void {
    if (this.checkCancelled()) {
      return;
    }

    if (this.metadataSent) {
      return;
    }

    this.metadataSent = true;
    const custom = metadata ? metadata.toHttp2Headers() : null;
    const headers = {
      ...defaultResponseHeaders,
      ...defaultCompressionHeaders,
      ...custom,
    };
    this.stream.respond(headers, defaultResponseOptions);
  }
  sendMessage(message: any, callback: () => void): void {
    if (this.checkCancelled()) {
      return;
    }
    let response: Buffer;
    try {
      response = this.serializeMessage(message);
    } catch (e) {
      this.sendStatus({
        code: Status.INTERNAL,
        details: `Error serializing response: ${getErrorMessage(e)}`,
        metadata: null,
      });
      return;
    }

    if (
      this.maxSendMessageSize !== -1 &&
      response.length - 5 > this.maxSendMessageSize
    ) {
      this.sendStatus({
        code: Status.RESOURCE_EXHAUSTED,
        details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
        metadata: null,
      });
      return;
    }
    this.maybeSendMetadata();
    trace(
      'Request to ' +
        this.handler.path +
        ' sent data frame of size ' +
        response.length
    );
    this.stream.write(response, error => {
      if (error) {
        this.sendStatus({
          code: Status.INTERNAL,
          details: `Error writing message: ${getErrorMessage(error)}`,
          metadata: null,
        });
        return;
      }
      this.callEventTracker?.addMessageSent();
      callback();
    });
  }
  sendStatus(status: PartialStatusObject): void {
    if (this.checkCancelled()) {
      return;
    }

    trace(
      'Request to method ' +
        this.handler?.path +
        ' ended with status code: ' +
        Status[status.code] +
        ' details: ' +
        status.details
    );

    if (this.metadataSent) {
      if (!this.wantTrailers) {
        this.wantTrailers = true;
        this.stream.once('wantTrailers', () => {
          if (this.callEventTracker && !this.streamEnded) {
            this.streamEnded = true;
            this.callEventTracker.onStreamEnd(true);
            this.callEventTracker.onCallEnd(status);
          }
          const trailersToSend = {
            [GRPC_STATUS_HEADER]: status.code,
            [GRPC_MESSAGE_HEADER]: encodeURI(status.details),
            ...status.metadata?.toHttp2Headers(),
          };

          this.stream.sendTrailers(trailersToSend);
          this.notifyOnCancel();
        });
        this.stream.end();
      } else {
        this.notifyOnCancel();
      }
    } else {
      if (this.callEventTracker && !this.streamEnded) {
        this.streamEnded = true;
        this.callEventTracker.onStreamEnd(true);
        this.callEventTracker.onCallEnd(status);
      }
      // Trailers-only response
      const trailersToSend = {
        [GRPC_STATUS_HEADER]: status.code,
        [GRPC_MESSAGE_HEADER]: encodeURI(status.details),
        ...defaultResponseHeaders,
        ...status.metadata?.toHttp2Headers(),
      };
      this.stream.respond(trailersToSend, { endStream: true });
      this.notifyOnCancel();
    }
  }
  startRead(): void {
    trace('Request to ' + this.handler.path + ' startRead called');
    if (this.checkCancelled()) {
      return;
    }
    this.isReadPending = true;
    if (this.readQueue.length === 0) {
      if (!this.receivedHalfClose) {
        this.stream.resume();
      }
    } else {
      this.maybePushNextMessage();
    }
  }
  getPeer(): string {
    const socket = this.stream.session?.socket;
    if (socket?.remoteAddress) {
      if (socket.remotePort) {
        return `${socket.remoteAddress}:${socket.remotePort}`;
      } else {
        return socket.remoteAddress;
      }
    } else {
      return 'unknown';
    }
  }
  getDeadline(): Deadline {
    return this.deadline;
  }
  getHost(): string {
    return this.host;
  }
}

export function getServerInterceptingCall(
  interceptors: ServerInterceptor[],
  stream: http2.ServerHttp2Stream,
  headers: http2.IncomingHttpHeaders,
  callEventTracker: CallEventTracker | null,
  handler: Handler<any, any>,
  options: ChannelOptions
) {
  const methodDefinition: ServerMethodDefinition<any, any> = {
    path: handler.path,
    requestStream: handler.type === 'clientStream' || handler.type === 'bidi',
    responseStream: handler.type === 'serverStream' || handler.type === 'bidi',
    requestDeserialize: handler.deserialize,
    responseSerialize: handler.serialize,
  };
  const baseCall = new BaseServerInterceptingCall(
    stream,
    headers,
    callEventTracker,
    handler,
    options
  );
  return interceptors.reduce(
    (call: ServerInterceptingCallInterface, interceptor: ServerInterceptor) => {
      return interceptor(methodDefinition, call);
    },
    baseCall
  );
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as http2 from 'http2';
import * as util from 'util';

import { ServiceError } from './call';
import { Status, LogVerbosity } from './constants';
import { Deserialize, Serialize, ServiceDefinition } from './make-client';
import { Metadata } from './metadata';
import {
  BidiStreamingHandler,
  ClientStreamingHandler,
  HandleCall,
  Handler,
  HandlerType,
  sendUnaryData,
  ServerDuplexStream,
  ServerDuplexStreamImpl,
  ServerReadableStream,
  ServerStreamingHandler,
  ServerUnaryCall,
  ServerWritableStream,
  ServerWritableStreamImpl,
  UnaryHandler,
  ServerErrorResponse,
  ServerStatusResponse,
  serverErrorToStatus,
} from './server-call';
import { SecureContextWatcher, ServerCredentials } from './server-credentials';
import { ChannelOptions } from './channel-options';
import {
  createResolver,
  ResolverListener,
  mapUriDefaultScheme,
} from './resolver';
import * as logging from './logging';
import {
  SubchannelAddress,
  isTcpSubchannelAddress,
  subchannelAddressToString,
  stringToSubchannelAddress,
} from './subchannel-address';
import {
  GrpcUri,
  combineHostPort,
  parseUri,
  splitHostPort,
  uriToString,
} from './uri-parser';
import {
  ChannelzCallTracker,
  ChannelzCallTrackerStub,
  ChannelzChildrenTracker,
  ChannelzChildrenTrackerStub,
  ChannelzTrace,
  ChannelzTraceStub,
  registerChannelzServer,
  registerChannelzSocket,
  ServerInfo,
  ServerRef,
  SocketInfo,
  SocketRef,
  TlsInfo,
  unregisterChannelzRef,
} from './channelz';
import { CipherNameAndProtocol, TLSSocket } from 'tls';
import {
  ServerInterceptingCallInterface,
  ServerInterceptor,
  getServerInterceptingCall,
} from './server-interceptors';
import { PartialStatusObject } from './call-interface';
import { CallEventTracker } from './transport';
import { Socket } from 'net';
import { Duplex } from 'stream';

const UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
const KEEPALIVE_TIMEOUT_MS = 20000;
const MAX_CONNECTION_IDLE_MS = ~(1 << 31);

const { HTTP2_HEADER_PATH } = http2.constants;

const TRACER_NAME = 'server';
const kMaxAge = Buffer.from('max_age');

type AnyHttp2Server = http2.Http2Server | http2.Http2SecureServer;

interface BindResult {
  port: number;
  count: number;
  errors: string[];
}

interface SingleAddressBindResult {
  port: number;
  error?: string;
}

function noop(): void {}

/**
 * Decorator to wrap a class method with util.deprecate
 * @param message The message to output if the deprecated method is called
 * @returns
 */
function deprecate(message: string) {
  return function <This, Args extends any[], Return>(
    target: (this: This, ...args: Args) => Return,
    context: ClassMethodDecoratorContext<
      This,
      (this: This, ...args: Args) => Return
    >
  ) {
    return util.deprecate(target, message);
  };
}

function getUnimplementedStatusResponse(
  methodName: string
): PartialStatusObject {
  return {
    code: Status.UNIMPLEMENTED,
    details: `The server does not implement the method ${methodName}`,
  };
}

/* eslint-disable @typescript-eslint/no-explicit-any */
type UntypedUnaryHandler = UnaryHandler<any, any>;
type UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;
type UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;
type UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;
export type UntypedHandleCall = HandleCall<any, any>;
type UntypedHandler = Handler<any, any>;
export interface UntypedServiceImplementation {
  [name: string]: UntypedHandleCall;
}

function getDefaultHandler(handlerType: HandlerType, methodName: string) {
  const unimplementedStatusResponse =
    getUnimplementedStatusResponse(methodName);
  switch (handlerType) {
    case 'unary':
      return (
        call: ServerUnaryCall<any, any>,
        callback: sendUnaryData<any>
      ) => {
        callback(unimplementedStatusResponse as ServiceError, null);
      };
    case 'clientStream':
      return (
        call: ServerReadableStream<any, any>,
        callback: sendUnaryData<any>
      ) => {
        callback(unimplementedStatusResponse as ServiceError, null);
      };
    case 'serverStream':
      return (call: ServerWritableStream<any, any>) => {
        call.emit('error', unimplementedStatusResponse);
      };
    case 'bidi':
      return (call: ServerDuplexStream<any, any>) => {
        call.emit('error', unimplementedStatusResponse);
      };
    default:
      throw new Error(`Invalid handlerType ${handlerType}`);
  }
}

interface ChannelzSessionInfo {
  ref: SocketRef;
  streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;
  messagesSent: number;
  messagesReceived: number;
  keepAlivesSent: number;
  lastMessageSentTimestamp: Date | null;
  lastMessageReceivedTimestamp: Date | null;
}

/**
 * Information related to a single invocation of bindAsync. This should be
 * tracked in a map keyed by target string, normalized with a pass through
 * parseUri -> mapUriDefaultScheme -> uriToString. If the target has a port
 * number and the port number is 0, the target string is modified with the
 * concrete bound port.
 */
interface BoundPort {
  /**
   * The key used to refer to this object in the boundPorts map.
   */
  mapKey: string;
  /**
   * The target string, passed through parseUri -> mapUriDefaultScheme. Used
   * to determine the final key when the port number is 0.
   */
  originalUri: GrpcUri;
  /**
   * If there is a pending bindAsync operation, this is a promise that resolves
   * with the port number when that operation succeeds. If there is no such
   * operation pending, this is null.
   */
  completionPromise: Promise<number> | null;
  /**
   * The port number that was actually bound. Populated only after
   * completionPromise resolves.
   */
  portNumber: number;
  /**
   * Set by unbind if called while pending is true.
   */
  cancelled: boolean;
  /**
   * The credentials object passed to the original bindAsync call.
   */
  credentials: ServerCredentials;
  /**
   * The set of servers associated with this listening port. A target string
   * that expands to multiple addresses will result in multiple listening
   * servers.
   */
  listeningServers: Set<AnyHttp2Server>;
}

/**
 * Should be in a map keyed by AnyHttp2Server.
 */
interface Http2ServerInfo {
  channelzRef: SocketRef;
  sessions: Set<http2.ServerHttp2Session>;
}

interface SessionIdleTimeoutTracker {
  activeStreams: number;
  lastIdle: number;
  timeout: NodeJS.Timeout;
  onClose: (session: http2.ServerHttp2Session) => void | null;
}

export interface ServerOptions extends ChannelOptions {
  interceptors?: ServerInterceptor[];
}

export interface ConnectionInjector {
  injectConnection(connection: Duplex): void;
  drain(graceTimeMs: number): void;
  destroy(): void;
}

export class Server {
  private boundPorts: Map<string, BoundPort> = new Map();
  private http2Servers: Map<AnyHttp2Server, Http2ServerInfo> = new Map();
  private sessionIdleTimeouts = new Map<
    http2.ServerHttp2Session,
    SessionIdleTimeoutTracker
  >();

  private handlers: Map<string, UntypedHandler> = new Map<
    string,
    UntypedHandler
  >();
  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();
  /**
   * This field only exists to ensure that the start method throws an error if
   * it is called twice, as it did previously.
   */
  private started = false;
  private shutdown = false;
  private options: ServerOptions;
  private serverAddressString = 'null';

  // Channelz Info
  private readonly channelzEnabled: boolean = true;
  private channelzRef: ServerRef;
  private channelzTrace: ChannelzTrace | ChannelzTraceStub;
  private callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;
  private listenerChildrenTracker:
    | ChannelzChildrenTracker
    | ChannelzChildrenTrackerStub;
  private sessionChildrenTracker:
    | ChannelzChildrenTracker
    | ChannelzChildrenTrackerStub;

  private readonly maxConnectionAgeMs: number;
  private readonly maxConnectionAgeGraceMs: number;

  private readonly keepaliveTimeMs: number;
  private readonly keepaliveTimeoutMs: number;

  private readonly sessionIdleTimeout: number;

  private readonly interceptors: ServerInterceptor[];

  /**
   * Options that will be used to construct all Http2Server instances for this
   * Server.
   */
  private commonServerOptions: http2.ServerOptions;

  constructor(options?: ServerOptions) {
    this.options = options ?? {};
    if (this.options['grpc.enable_channelz'] === 0) {
      this.channelzEnabled = false;
      this.channelzTrace = new ChannelzTraceStub();
      this.callTracker = new ChannelzCallTrackerStub();
      this.listenerChildrenTracker = new ChannelzChildrenTrackerStub();
      this.sessionChildrenTracker = new ChannelzChildrenTrackerStub();
    } else {
      this.channelzTrace = new ChannelzTrace();
      this.callTracker = new ChannelzCallTracker();
      this.listenerChildrenTracker = new ChannelzChildrenTracker();
      this.sessionChildrenTracker = new ChannelzChildrenTracker();
    }

    this.channelzRef = registerChannelzServer(
      'server',
      () => this.getChannelzInfo(),
      this.channelzEnabled
    );

    this.channelzTrace.addTrace('CT_INFO', 'Server created');
    this.maxConnectionAgeMs =
      this.options['grpc.max_connection_age_ms'] ?? UNLIMITED_CONNECTION_AGE_MS;
    this.maxConnectionAgeGraceMs =
      this.options['grpc.max_connection_age_grace_ms'] ??
      UNLIMITED_CONNECTION_AGE_MS;
    this.keepaliveTimeMs =
      this.options['grpc.keepalive_time_ms'] ?? KEEPALIVE_MAX_TIME_MS;
    this.keepaliveTimeoutMs =
      this.options['grpc.keepalive_timeout_ms'] ?? KEEPALIVE_TIMEOUT_MS;
    this.sessionIdleTimeout =
      this.options['grpc.max_connection_idle_ms'] ?? MAX_CONNECTION_IDLE_MS;

    this.commonServerOptions = {
      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
    };
    if ('grpc-node.max_session_memory' in this.options) {
      this.commonServerOptions.maxSessionMemory =
        this.options['grpc-node.max_session_memory'];
    } else {
      /* By default, set a very large max session memory limit, to effectively
       * disable enforcement of the limit. Some testing indicates that Node's
       * behavior degrades badly when this limit is reached, so we solve that
       * by disabling the check entirely. */
      this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
    }
    if ('grpc.max_concurrent_streams' in this.options) {
      this.commonServerOptions.settings = {
        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
      };
    }
    this.interceptors = this.options.interceptors ?? [];
    this.trace('Server constructed');
  }

  private getChannelzInfo(): ServerInfo {
    return {
      trace: this.channelzTrace,
      callTracker: this.callTracker,
      listenerChildren: this.listenerChildrenTracker.getChildLists(),
      sessionChildren: this.sessionChildrenTracker.getChildLists(),
    };
  }

  private getChannelzSessionInfo(
    session: http2.ServerHttp2Session
  ): SocketInfo {
    const sessionInfo = this.sessions.get(session)!;
    const sessionSocket = session.socket;
    const remoteAddress = sessionSocket.remoteAddress
      ? stringToSubchannelAddress(
          sessionSocket.remoteAddress,
          sessionSocket.remotePort
        )
      : null;
    const localAddress = sessionSocket.localAddress
      ? stringToSubchannelAddress(
          sessionSocket.localAddress!,
          sessionSocket.localPort
        )
      : null;
    let tlsInfo: TlsInfo | null;
    if (session.encrypted) {
      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;
      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =
        tlsSocket.getCipher();
      const certificate = tlsSocket.getCertificate();
      const peerCertificate = tlsSocket.getPeerCertificate();
      tlsInfo = {
        cipherSuiteStandardName: cipherInfo.standardName ?? null,
        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
        localCertificate:
          certificate && 'raw' in certificate ? certificate.raw : null,
        remoteCertificate:
          peerCertificate && 'raw' in peerCertificate
            ? peerCertificate.raw
            : null,
      };
    } else {
      tlsInfo = null;
    }
    const socketInfo: SocketInfo = {
      remoteAddress: remoteAddress,
      localAddress: localAddress,
      security: tlsInfo,
      remoteName: null,
      streamsStarted: sessionInfo.streamTracker.callsStarted,
      streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
      streamsFailed: sessionInfo.streamTracker.callsFailed,
      messagesSent: sessionInfo.messagesSent,
      messagesReceived: sessionInfo.messagesReceived,
      keepAlivesSent: sessionInfo.keepAlivesSent,
      lastLocalStreamCreatedTimestamp: null,
      lastRemoteStreamCreatedTimestamp:
        sessionInfo.streamTracker.lastCallStartedTimestamp,
      lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
      lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
      localFlowControlWindow: session.state.localWindowSize ?? null,
      remoteFlowControlWindow: session.state.remoteWindowSize ?? null,
    };
    return socketInfo;
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '(' + this.channelzRef.id + ') ' + text
    );
  }

  private keepaliveTrace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      'keepalive',
      '(' + this.channelzRef.id + ') ' + text
    );
  }

  addProtoService(): never {
    throw new Error('Not implemented. Use addService() instead');
  }

  addService(
    service: ServiceDefinition,
    implementation: UntypedServiceImplementation
  ): void {
    if (
      service === null ||
      typeof service !== 'object' ||
      implementation === null ||
      typeof implementation !== 'object'
    ) {
      throw new Error('addService() requires two objects as arguments');
    }

    const serviceKeys = Object.keys(service);

    if (serviceKeys.length === 0) {
      throw new Error('Cannot add an empty service to a server');
    }

    serviceKeys.forEach(name => {
      const attrs = service[name];
      let methodType: HandlerType;

      if (attrs.requestStream) {
        if (attrs.responseStream) {
          methodType = 'bidi';
        } else {
          methodType = 'clientStream';
        }
      } else {
        if (attrs.responseStream) {
          methodType = 'serverStream';
        } else {
          methodType = 'unary';
        }
      }

      let implFn = implementation[name];
      let impl;

      if (implFn === undefined && typeof attrs.originalName === 'string') {
        implFn = implementation[attrs.originalName];
      }

      if (implFn !== undefined) {
        impl = implFn.bind(implementation);
      } else {
        impl = getDefaultHandler(methodType, name);
      }

      const success = this.register(
        attrs.path,
        impl as UntypedHandleCall,
        attrs.responseSerialize,
        attrs.requestDeserialize,
        methodType
      );

      if (success === false) {
        throw new Error(`Method handler for ${attrs.path} already provided.`);
      }
    });
  }

  removeService(service: ServiceDefinition): void {
    if (service === null || typeof service !== 'object') {
      throw new Error('removeService() requires object as argument');
    }

    const serviceKeys = Object.keys(service);
    serviceKeys.forEach(name => {
      const attrs = service[name];
      this.unregister(attrs.path);
    });
  }

  bind(port: string, creds: ServerCredentials): never {
    throw new Error('Not implemented. Use bindAsync() instead');
  }

  private registerListenerToChannelz(boundAddress: SubchannelAddress) {
    return registerChannelzSocket(
      subchannelAddressToString(boundAddress),
      () => {
        return {
          localAddress: boundAddress,
          remoteAddress: null,
          security: null,
          remoteName: null,
          streamsStarted: 0,
          streamsSucceeded: 0,
          streamsFailed: 0,
          messagesSent: 0,
          messagesReceived: 0,
          keepAlivesSent: 0,
          lastLocalStreamCreatedTimestamp: null,
          lastRemoteStreamCreatedTimestamp: null,
          lastMessageSentTimestamp: null,
          lastMessageReceivedTimestamp: null,
          localFlowControlWindow: null,
          remoteFlowControlWindow: null,
        };
      },
      this.channelzEnabled
    );
  }

  private createHttp2Server(credentials: ServerCredentials) {
    let http2Server: http2.Http2Server | http2.Http2SecureServer;
    if (credentials._isSecure()) {
      const credentialsSettings = credentials._getSettings();
      const secureServerOptions: http2.SecureServerOptions = {
        ...this.commonServerOptions,
        ...credentialsSettings,
        enableTrace: this.options['grpc-node.tls_enable_trace'] === 1
      };
      let areCredentialsValid = credentialsSettings !== null;
      http2Server = http2.createSecureServer(secureServerOptions);
      http2Server.on('connection', (socket: Socket) => {
        if (!areCredentialsValid) {
          socket.destroy();
        }
      });
      http2Server.on('secureConnection', (socket: TLSSocket) => {
        /* These errors need to be handled by the user of Http2SecureServer,
         * according to https://github.com/nodejs/node/issues/35824 */
        socket.on('error', (e: Error) => {
          this.trace(
            'An incoming TLS connection closed with error: ' + e.message
          );
        });
      });
      const credsWatcher: SecureContextWatcher = options => {
        if (options) {
          (http2Server as http2.Http2SecureServer).setSecureContext(options);
        }
        areCredentialsValid = options !== null;
      }
      credentials._addWatcher(credsWatcher);
      http2Server.on('close', () => {
        credentials._removeWatcher(credsWatcher);
      });
    } else {
      http2Server = http2.createServer(this.commonServerOptions);
    }

    http2Server.setTimeout(0, noop);
    this._setupHandlers(http2Server, credentials._getInterceptors());
    return http2Server;
  }

  private bindOneAddress(
    address: SubchannelAddress,
    boundPortObject: BoundPort
  ): Promise<SingleAddressBindResult> {
    this.trace('Attempting to bind ' + subchannelAddressToString(address));
    const http2Server = this.createHttp2Server(boundPortObject.credentials);
    return new Promise<SingleAddressBindResult>((resolve, reject) => {
      const onError = (err: Error) => {
        this.trace(
          'Failed to bind ' +
            subchannelAddressToString(address) +
            ' with error ' +
            err.message
        );
        resolve({
          port: 'port' in address ? address.port : 1,
          error: err.message,
        });
      };

      http2Server.once('error', onError);

      http2Server.listen(address, () => {
        const boundAddress = http2Server.address()!;
        let boundSubchannelAddress: SubchannelAddress;
        if (typeof boundAddress === 'string') {
          boundSubchannelAddress = {
            path: boundAddress,
          };
        } else {
          boundSubchannelAddress = {
            host: boundAddress.address,
            port: boundAddress.port,
          };
        }

        const channelzRef = this.registerListenerToChannelz(
          boundSubchannelAddress
        );
        this.listenerChildrenTracker.refChild(channelzRef);

        this.http2Servers.set(http2Server, {
          channelzRef: channelzRef,
          sessions: new Set(),
        });
        boundPortObject.listeningServers.add(http2Server);
        this.trace(
          'Successfully bound ' +
            subchannelAddressToString(boundSubchannelAddress)
        );
        resolve({
          port:
            'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,
        });
        http2Server.removeListener('error', onError);
      });
    });
  }

  private async bindManyPorts(
    addressList: SubchannelAddress[],
    boundPortObject: BoundPort
  ): Promise<BindResult> {
    if (addressList.length === 0) {
      return {
        count: 0,
        port: 0,
        errors: [],
      };
    }
    if (isTcpSubchannelAddress(addressList[0]) && addressList[0].port === 0) {
      /* If binding to port 0, first try to bind the first address, then bind
       * the rest of the address list to the specific port that it binds. */
      const firstAddressResult = await this.bindOneAddress(
        addressList[0],
        boundPortObject
      );
      if (firstAddressResult.error) {
        /* If the first address fails to bind, try the same operation starting
         * from the second item in the list. */
        const restAddressResult = await this.bindManyPorts(
          addressList.slice(1),
          boundPortObject
        );
        return {
          ...restAddressResult,
          errors: [firstAddressResult.error, ...restAddressResult.errors],
        };
      } else {
        const restAddresses = addressList
          .slice(1)
          .map(address =>
            isTcpSubchannelAddress(address)
              ? { host: address.host, port: firstAddressResult.port }
              : address
          );
        const restAddressResult = await Promise.all(
          restAddresses.map(address =>
            this.bindOneAddress(address, boundPortObject)
          )
        );
        const allResults = [firstAddressResult, ...restAddressResult];
        return {
          count: allResults.filter(result => result.error === undefined).length,
          port: firstAddressResult.port,
          errors: allResults
            .filter(result => result.error)
            .map(result => result.error!),
        };
      }
    } else {
      const allResults = await Promise.all(
        addressList.map(address =>
          this.bindOneAddress(address, boundPortObject)
        )
      );
      return {
        count: allResults.filter(result => result.error === undefined).length,
        port: allResults[0].port,
        errors: allResults
          .filter(result => result.error)
          .map(result => result.error!),
      };
    }
  }

  private async bindAddressList(
    addressList: SubchannelAddress[],
    boundPortObject: BoundPort
  ): Promise<number> {
    const bindResult = await this.bindManyPorts(addressList, boundPortObject);
    if (bindResult.count > 0) {
      if (bindResult.count < addressList.length) {
        logging.log(
          LogVerbosity.INFO,
          `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`
        );
      }
      return bindResult.port;
    } else {
      const errorString = `No address added out of total ${addressList.length} resolved`;
      logging.log(LogVerbosity.ERROR, errorString);
      throw new Error(
        `${errorString} errors: [${bindResult.errors.join(',')}]`
      );
    }
  }

  private resolvePort(port: GrpcUri): Promise<SubchannelAddress[]> {
    return new Promise<SubchannelAddress[]>((resolve, reject) => {
      const resolverListener: ResolverListener = {
        onSuccessfulResolution: (
          endpointList,
          serviceConfig,
          serviceConfigError
        ) => {
          // We only want one resolution result. Discard all future results
          resolverListener.onSuccessfulResolution = () => {};
          const addressList = ([] as SubchannelAddress[]).concat(
            ...endpointList.map(endpoint => endpoint.addresses)
          );
          if (addressList.length === 0) {
            reject(new Error(`No addresses resolved for port ${port}`));
            return;
          }
          resolve(addressList);
        },
        onError: error => {
          reject(new Error(error.details));
        },
      };
      const resolver = createResolver(port, resolverListener, this.options);
      resolver.updateResolution();
    });
  }

  private async bindPort(
    port: GrpcUri,
    boundPortObject: BoundPort
  ): Promise<number> {
    const addressList = await this.resolvePort(port);
    if (boundPortObject.cancelled) {
      this.completeUnbind(boundPortObject);
      throw new Error('bindAsync operation cancelled by unbind call');
    }
    const portNumber = await this.bindAddressList(addressList, boundPortObject);
    if (boundPortObject.cancelled) {
      this.completeUnbind(boundPortObject);
      throw new Error('bindAsync operation cancelled by unbind call');
    }
    return portNumber;
  }

  private normalizePort(port: string): GrpcUri {
    const initialPortUri = parseUri(port);
    if (initialPortUri === null) {
      throw new Error(`Could not parse port "${port}"`);
    }
    const portUri = mapUriDefaultScheme(initialPortUri);
    if (portUri === null) {
      throw new Error(`Could not get a default scheme for port "${port}"`);
    }
    return portUri;
  }

  bindAsync(
    port: string,
    creds: ServerCredentials,
    callback: (error: Error | null, port: number) => void
  ): void {
    if (this.shutdown) {
      throw new Error('bindAsync called after shutdown');
    }
    if (typeof port !== 'string') {
      throw new TypeError('port must be a string');
    }

    if (creds === null || !(creds instanceof ServerCredentials)) {
      throw new TypeError('creds must be a ServerCredentials object');
    }

    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');
    }

    this.trace('bindAsync port=' + port);

    const portUri = this.normalizePort(port);

    const deferredCallback = (error: Error | null, port: number) => {
      process.nextTick(() => callback(error, port));
    };

    /* First, if this port is already bound or that bind operation is in
     * progress, use that result. */
    let boundPortObject = this.boundPorts.get(uriToString(portUri));
    if (boundPortObject) {
      if (!creds._equals(boundPortObject.credentials)) {
        deferredCallback(
          new Error(`${port} already bound with incompatible credentials`),
          0
        );
        return;
      }
      /* If that operation has previously been cancelled by an unbind call,
       * uncancel it. */
      boundPortObject.cancelled = false;
      if (boundPortObject.completionPromise) {
        boundPortObject.completionPromise.then(
          portNum => callback(null, portNum),
          error => callback(error as Error, 0)
        );
      } else {
        deferredCallback(null, boundPortObject.portNumber);
      }
      return;
    }
    boundPortObject = {
      mapKey: uriToString(portUri),
      originalUri: portUri,
      completionPromise: null,
      cancelled: false,
      portNumber: 0,
      credentials: creds,
      listeningServers: new Set(),
    };
    const splitPort = splitHostPort(portUri.path);
    const completionPromise = this.bindPort(portUri, boundPortObject);
    boundPortObject.completionPromise = completionPromise;
    /* If the port number is 0, defer populating the map entry until after the
     * bind operation completes and we have a specific port number. Otherwise,
     * populate it immediately. */
    if (splitPort?.port === 0) {
      completionPromise.then(
        portNum => {
          const finalUri: GrpcUri = {
            scheme: portUri.scheme,
            authority: portUri.authority,
            path: combineHostPort({ host: splitPort.host, port: portNum }),
          };
          boundPortObject!.mapKey = uriToString(finalUri);
          boundPortObject!.completionPromise = null;
          boundPortObject!.portNumber = portNum;
          this.boundPorts.set(boundPortObject!.mapKey, boundPortObject!);
          callback(null, portNum);
        },
        error => {
          callback(error, 0);
        }
      );
    } else {
      this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
      completionPromise.then(
        portNum => {
          boundPortObject!.completionPromise = null;
          boundPortObject!.portNumber = portNum;
          callback(null, portNum);
        },
        error => {
          callback(error, 0);
        }
      );
    }
  }

  private registerInjectorToChannelz() {
    return registerChannelzSocket(
      'injector',
      () => {
        return {
          localAddress: null,
          remoteAddress: null,
          security: null,
          remoteName: null,
          streamsStarted: 0,
          streamsSucceeded: 0,
          streamsFailed: 0,
          messagesSent: 0,
          messagesReceived: 0,
          keepAlivesSent: 0,
          lastLocalStreamCreatedTimestamp: null,
          lastRemoteStreamCreatedTimestamp: null,
          lastMessageSentTimestamp: null,
          lastMessageReceivedTimestamp: null,
          localFlowControlWindow: null,
          remoteFlowControlWindow: null,
        };
      },
      this.channelzEnabled
    );
  }

  createConnectionInjector(credentials: ServerCredentials): ConnectionInjector {
    if (credentials === null || !(credentials instanceof ServerCredentials)) {
      throw new TypeError('creds must be a ServerCredentials object');
    }
    const server = this.createHttp2Server(credentials);
    const channelzRef = this.registerInjectorToChannelz();
    if (this.channelzEnabled) {
      this.listenerChildrenTracker.refChild(channelzRef);
    }
    const sessionsSet: Set<http2.ServerHttp2Session> = new Set();
    this.http2Servers.set(server, {
      channelzRef: channelzRef,
      sessions: sessionsSet
    });
    return {
      injectConnection: (connection: Duplex) => {
        server.emit('connection', connection);
      },
      drain: (graceTimeMs: number) => {
        for (const session of sessionsSet) {
          this.closeSession(session);
        }
        setTimeout(() => {
          for (const session of sessionsSet) {
            session.destroy(http2.constants.NGHTTP2_CANCEL as any);
          }
        }, graceTimeMs).unref?.();
      },
      destroy: () => {
        this.closeServer(server)
        for (const session of sessionsSet) {
          this.closeSession(session);
        }
      }
    };
  }

  private closeServer(server: AnyHttp2Server, callback?: () => void) {
    this.trace(
      'Closing server with address ' + JSON.stringify(server.address())
    );
    const serverInfo = this.http2Servers.get(server);
    server.close(() => {
      if (serverInfo) {
        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
        unregisterChannelzRef(serverInfo.channelzRef);
      }
      this.http2Servers.delete(server);
      callback?.();
    });
  }

  private closeSession(
    session: http2.ServerHttp2Session,
    callback?: () => void
  ) {
    this.trace('Closing session initiated by ' + session.socket?.remoteAddress);
    const sessionInfo = this.sessions.get(session);
    const closeCallback = () => {
      if (sessionInfo) {
        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
        unregisterChannelzRef(sessionInfo.ref);
      }
      callback?.();
    };
    if (session.closed) {
      queueMicrotask(closeCallback);
    } else {
      session.close(closeCallback);
    }
  }

  private completeUnbind(boundPortObject: BoundPort) {
    for (const server of boundPortObject.listeningServers) {
      const serverInfo = this.http2Servers.get(server);
      this.closeServer(server, () => {
        boundPortObject.listeningServers.delete(server);
      });
      if (serverInfo) {
        for (const session of serverInfo.sessions) {
          this.closeSession(session);
        }
      }
    }
    this.boundPorts.delete(boundPortObject.mapKey);
  }

  /**
   * Unbind a previously bound port, or cancel an in-progress bindAsync
   * operation. If port 0 was bound, only the actual bound port can be
   * unbound. For example, if bindAsync was called with "localhost:0" and the
   * bound port result was 54321, it can be unbound as "localhost:54321".
   * @param port
   */
  unbind(port: string): void {
    this.trace('unbind port=' + port);
    const portUri = this.normalizePort(port);
    const splitPort = splitHostPort(portUri.path);
    if (splitPort?.port === 0) {
      throw new Error('Cannot unbind port 0');
    }
    const boundPortObject = this.boundPorts.get(uriToString(portUri));
    if (boundPortObject) {
      this.trace(
        'unbinding ' +
          boundPortObject.mapKey +
          ' originally bound as ' +
          uriToString(boundPortObject.originalUri)
      );
      /* If the bind operation is pending, the cancelled flag will trigger
       * the unbind operation later. */
      if (boundPortObject.completionPromise) {
        boundPortObject.cancelled = true;
      } else {
        this.completeUnbind(boundPortObject);
      }
    }
  }

  /**
   * Gracefully close all connections associated with a previously bound port.
   * After the grace time, forcefully close all remaining open connections.
   *
   * If port 0 was bound, only the actual bound port can be
   * drained. For example, if bindAsync was called with "localhost:0" and the
   * bound port result was 54321, it can be drained as "localhost:54321".
   * @param port
   * @param graceTimeMs
   * @returns
   */
  drain(port: string, graceTimeMs: number): void {
    this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);
    const portUri = this.normalizePort(port);
    const splitPort = splitHostPort(portUri.path);
    if (splitPort?.port === 0) {
      throw new Error('Cannot drain port 0');
    }
    const boundPortObject = this.boundPorts.get(uriToString(portUri));
    if (!boundPortObject) {
      return;
    }
    const allSessions: Set<http2.Http2Session> = new Set();
    for (const http2Server of boundPortObject.listeningServers) {
      const serverEntry = this.http2Servers.get(http2Server);
      if (serverEntry) {
        for (const session of serverEntry.sessions) {
          allSessions.add(session);
          this.closeSession(session, () => {
            allSessions.delete(session);
          });
        }
      }
    }
    /* After the grace time ends, send another goaway to all remaining sessions
     * with the CANCEL code. */
    setTimeout(() => {
      for (const session of allSessions) {
        session.destroy(http2.constants.NGHTTP2_CANCEL as any);
      }
    }, graceTimeMs).unref?.();
  }

  forceShutdown(): void {
    for (const boundPortObject of this.boundPorts.values()) {
      boundPortObject.cancelled = true;
    }
    this.boundPorts.clear();
    // Close the server if it is still running.
    for (const server of this.http2Servers.keys()) {
      this.closeServer(server);
    }

    // Always destroy any available sessions. It's possible that one or more
    // tryShutdown() calls are in progress. Don't wait on them to finish.
    this.sessions.forEach((channelzInfo, session) => {
      this.closeSession(session);
      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
      // recognize destroy(code) as a valid signature.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      session.destroy(http2.constants.NGHTTP2_CANCEL as any);
    });
    this.sessions.clear();
    unregisterChannelzRef(this.channelzRef);

    this.shutdown = true;
  }

  register<RequestType, ResponseType>(
    name: string,
    handler: HandleCall<RequestType, ResponseType>,
    serialize: Serialize<ResponseType>,
    deserialize: Deserialize<RequestType>,
    type: string
  ): boolean {
    if (this.handlers.has(name)) {
      return false;
    }

    this.handlers.set(name, {
      func: handler,
      serialize,
      deserialize,
      type,
      path: name,
    } as UntypedHandler);
    return true;
  }

  unregister(name: string): boolean {
    return this.handlers.delete(name);
  }

  /**
   * @deprecated No longer needed as of version 1.10.x
   */
  @deprecate(
    'Calling start() is no longer necessary. It can be safely omitted.'
  )
  start(): void {
    if (
      this.http2Servers.size === 0 ||
      [...this.http2Servers.keys()].every(server => !server.listening)
    ) {
      throw new Error('server must be bound in order to start');
    }

    if (this.started === true) {
      throw new Error('server is already started');
    }
    this.started = true;
  }

  tryShutdown(callback: (error?: Error) => void): void {
    const wrappedCallback = (error?: Error) => {
      unregisterChannelzRef(this.channelzRef);
      callback(error);
    };
    let pendingChecks = 0;

    function maybeCallback(): void {
      pendingChecks--;

      if (pendingChecks === 0) {
        wrappedCallback();
      }
    }
    this.shutdown = true;

    for (const [serverKey, server] of this.http2Servers.entries()) {
      pendingChecks++;
      const serverString = server.channelzRef.name;
      this.trace('Waiting for server ' + serverString + ' to close');
      this.closeServer(serverKey, () => {
        this.trace('Server ' + serverString + ' finished closing');
        maybeCallback();
      });

      for (const session of server.sessions.keys()) {
        pendingChecks++;
        const sessionString = session.socket?.remoteAddress;
        this.trace('Waiting for session ' + sessionString + ' to close');
        this.closeSession(session, () => {
          this.trace('Session ' + sessionString + ' finished closing');
          maybeCallback();
        });
      }
    }

    if (pendingChecks === 0) {
      wrappedCallback();
    }
  }

  addHttp2Port(): never {
    throw new Error('Not yet implemented');
  }

  /**
   * Get the channelz reference object for this server. The returned value is
   * garbage if channelz is disabled for this server.
   * @returns
   */
  getChannelzRef() {
    return this.channelzRef;
  }

  private _verifyContentType(
    stream: http2.ServerHttp2Stream,
    headers: http2.IncomingHttpHeaders
  ): boolean {
    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];

    if (
      typeof contentType !== 'string' ||
      !contentType.startsWith('application/grpc')
    ) {
      stream.respond(
        {
          [http2.constants.HTTP2_HEADER_STATUS]:
            http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
        },
        { endStream: true }
      );
      return false;
    }

    return true;
  }

  private _retrieveHandler(path: string): Handler<any, any> | null {
    this.trace(
      'Received call to method ' +
        path +
        ' at address ' +
        this.serverAddressString
    );

    const handler = this.handlers.get(path);

    if (handler === undefined) {
      this.trace(
        'No handler registered for method ' +
          path +
          '. Sending UNIMPLEMENTED status.'
      );
      return null;
    }

    return handler;
  }

  private _respondWithError(
    err: PartialStatusObject,
    stream: http2.ServerHttp2Stream,
    channelzSessionInfo: ChannelzSessionInfo | null = null
  ) {
    const trailersToSend = {
      'grpc-status': err.code ?? Status.INTERNAL,
      'grpc-message': err.details,
      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
      ...err.metadata?.toHttp2Headers(),
    };
    stream.respond(trailersToSend, { endStream: true });

    this.callTracker.addCallFailed();
    channelzSessionInfo?.streamTracker.addCallFailed();
  }

  private _channelzHandler(
    extraInterceptors: ServerInterceptor[],
    stream: http2.ServerHttp2Stream,
    headers: http2.IncomingHttpHeaders
  ) {
    // for handling idle timeout
    this.onStreamOpened(stream);

    const channelzSessionInfo = this.sessions.get(
      stream.session as http2.ServerHttp2Session
    );

    this.callTracker.addCallStarted();
    channelzSessionInfo?.streamTracker.addCallStarted();

    if (!this._verifyContentType(stream, headers)) {
      this.callTracker.addCallFailed();
      channelzSessionInfo?.streamTracker.addCallFailed();
      return;
    }

    const path = headers[HTTP2_HEADER_PATH] as string;

    const handler = this._retrieveHandler(path);
    if (!handler) {
      this._respondWithError(
        getUnimplementedStatusResponse(path),
        stream,
        channelzSessionInfo
      );
      return;
    }

    const callEventTracker: CallEventTracker = {
      addMessageSent: () => {
        if (channelzSessionInfo) {
          channelzSessionInfo.messagesSent += 1;
          channelzSessionInfo.lastMessageSentTimestamp = new Date();
        }
      },
      addMessageReceived: () => {
        if (channelzSessionInfo) {
          channelzSessionInfo.messagesReceived += 1;
          channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
        }
      },
      onCallEnd: status => {
        if (status.code === Status.OK) {
          this.callTracker.addCallSucceeded();
        } else {
          this.callTracker.addCallFailed();
        }
      },
      onStreamEnd: success => {
        if (channelzSessionInfo) {
          if (success) {
            channelzSessionInfo.streamTracker.addCallSucceeded();
          } else {
            channelzSessionInfo.streamTracker.addCallFailed();
          }
        }
      },
    };

    const call = getServerInterceptingCall(
      [...extraInterceptors, ...this.interceptors],
      stream,
      headers,
      callEventTracker,
      handler,
      this.options
    );

    if (!this._runHandlerForCall(call, handler)) {
      this.callTracker.addCallFailed();
      channelzSessionInfo?.streamTracker.addCallFailed();

      call.sendStatus({
        code: Status.INTERNAL,
        details: `Unknown handler type: ${handler.type}`,
      });
    }
  }

  private _streamHandler(
    extraInterceptors: ServerInterceptor[],
    stream: http2.ServerHttp2Stream,
    headers: http2.IncomingHttpHeaders
  ) {
    // for handling idle timeout
    this.onStreamOpened(stream);

    if (this._verifyContentType(stream, headers) !== true) {
      return;
    }

    const path = headers[HTTP2_HEADER_PATH] as string;

    const handler = this._retrieveHandler(path);
    if (!handler) {
      this._respondWithError(
        getUnimplementedStatusResponse(path),
        stream,
        null
      );
      return;
    }

    const call = getServerInterceptingCall(
      [...extraInterceptors, ...this.interceptors],
      stream,
      headers,
      null,
      handler,
      this.options
    );

    if (!this._runHandlerForCall(call, handler)) {
      call.sendStatus({
        code: Status.INTERNAL,
        details: `Unknown handler type: ${handler.type}`,
      });
    }
  }

  private _runHandlerForCall(
    call: ServerInterceptingCallInterface,
    handler:
      | UntypedUnaryHandler
      | UntypedClientStreamingHandler
      | UntypedServerStreamingHandler
      | UntypedBidiStreamingHandler
  ): boolean {
    const { type } = handler;
    if (type === 'unary') {
      handleUnary(call, handler);
    } else if (type === 'clientStream') {
      handleClientStreaming(call, handler);
    } else if (type === 'serverStream') {
      handleServerStreaming(call, handler);
    } else if (type === 'bidi') {
      handleBidiStreaming(call, handler);
    } else {
      return false;
    }

    return true;
  }

  private _setupHandlers(
    http2Server: http2.Http2Server | http2.Http2SecureServer,
    extraInterceptors: ServerInterceptor[]
  ): void {
    if (http2Server === null) {
      return;
    }

    const serverAddress = http2Server.address();
    let serverAddressString = 'null';
    if (serverAddress) {
      if (typeof serverAddress === 'string') {
        serverAddressString = serverAddress;
      } else {
        serverAddressString = serverAddress.address + ':' + serverAddress.port;
      }
    }
    this.serverAddressString = serverAddressString;

    const handler = this.channelzEnabled
      ? this._channelzHandler
      : this._streamHandler;

    const sessionHandler = this.channelzEnabled
      ? this._channelzSessionHandler(http2Server)
      : this._sessionHandler(http2Server);

    http2Server.on('stream', handler.bind(this, extraInterceptors));
    http2Server.on('session', sessionHandler);
  }

  private _sessionHandler(
    http2Server: http2.Http2Server | http2.Http2SecureServer
  ) {
    return (session: http2.ServerHttp2Session) => {
      this.http2Servers.get(http2Server)?.sessions.add(session);

      let connectionAgeTimer: NodeJS.Timeout | null = null;
      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;
      let keepaliveTimer: NodeJS.Timeout | null = null;
      let sessionClosedByServer = false;

      const idleTimeoutObj = this.enableIdleTimeout(session);

      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
        // Apply a random jitter within a +/-10% range
        const jitterMagnitude = this.maxConnectionAgeMs / 10;
        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;

        connectionAgeTimer = setTimeout(() => {
          sessionClosedByServer = true;

          this.trace(
            'Connection dropped by max connection age: ' +
              session.socket?.remoteAddress
          );

          try {
            session.goaway(
              http2.constants.NGHTTP2_NO_ERROR,
              ~(1 << 31),
              kMaxAge
            );
          } catch (e) {
            // The goaway can't be sent because the session is already closed
            session.destroy();
            return;
          }
          session.close();

          /* Allow a grace period after sending the GOAWAY before forcibly
           * closing the connection. */
          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
            connectionAgeGraceTimer = setTimeout(() => {
              session.destroy();
            }, this.maxConnectionAgeGraceMs);
            connectionAgeGraceTimer.unref?.();
          }
        }, this.maxConnectionAgeMs + jitter);
        connectionAgeTimer.unref?.();
      }

      const clearKeepaliveTimeout = () => {
        if (keepaliveTimer) {
          clearTimeout(keepaliveTimer);
          keepaliveTimer = null;
        }
      };

      const canSendPing = () => {
        return (
          !session.destroyed &&
          this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
          this.keepaliveTimeMs > 0
        );
      };

      /* eslint-disable-next-line prefer-const */
      let sendPing: () => void; // hoisted for use in maybeStartKeepalivePingTimer

      const maybeStartKeepalivePingTimer = () => {
        if (!canSendPing()) {
          return;
        }
        this.keepaliveTrace(
          'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'
        );
        keepaliveTimer = setTimeout(() => {
          clearKeepaliveTimeout();
          sendPing();
        }, this.keepaliveTimeMs);
        keepaliveTimer.unref?.();
      };

      sendPing = () => {
        if (!canSendPing()) {
          return;
        }
        this.keepaliveTrace(
          'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'
        );
        let pingSendError = '';
        try {
          const pingSentSuccessfully = session.ping(
            (err: Error | null, duration: number, payload: Buffer) => {
              clearKeepaliveTimeout();
              if (err) {
                this.keepaliveTrace('Ping failed with error: ' + err.message);
                sessionClosedByServer = true;
                session.close();
              } else {
                this.keepaliveTrace('Received ping response');
                maybeStartKeepalivePingTimer();
              }
            }
          );
          if (!pingSentSuccessfully) {
            pingSendError = 'Ping returned false';
          }
        } catch (e) {
          // grpc/grpc-node#2139
          pingSendError =
            (e instanceof Error ? e.message : '') || 'Unknown error';
        }

        if (pingSendError) {
          this.keepaliveTrace('Ping send failed: ' + pingSendError);
          this.trace(
            'Connection dropped due to ping send error: ' + pingSendError
          );
          sessionClosedByServer = true;
          session.close();
          return;
        }

        keepaliveTimer = setTimeout(() => {
          clearKeepaliveTimeout();
          this.keepaliveTrace('Ping timeout passed without response');
          this.trace('Connection dropped by keepalive timeout');
          sessionClosedByServer = true;
          session.close();
        }, this.keepaliveTimeoutMs);
        keepaliveTimer.unref?.();
      };

      maybeStartKeepalivePingTimer();

      session.on('close', () => {
        if (!sessionClosedByServer) {
          this.trace(
            `Connection dropped by client ${session.socket?.remoteAddress}`
          );
        }

        if (connectionAgeTimer) {
          clearTimeout(connectionAgeTimer);
        }

        if (connectionAgeGraceTimer) {
          clearTimeout(connectionAgeGraceTimer);
        }

        clearKeepaliveTimeout();

        if (idleTimeoutObj !== null) {
          clearTimeout(idleTimeoutObj.timeout);
          this.sessionIdleTimeouts.delete(session);
        }

        this.http2Servers.get(http2Server)?.sessions.delete(session);
      });
    };
  }

  private _channelzSessionHandler(
    http2Server: http2.Http2Server | http2.Http2SecureServer
  ) {
    return (session: http2.ServerHttp2Session) => {
      const channelzRef = registerChannelzSocket(
        session.socket?.remoteAddress ?? 'unknown',
        this.getChannelzSessionInfo.bind(this, session),
        this.channelzEnabled
      );

      const channelzSessionInfo: ChannelzSessionInfo = {
        ref: channelzRef,
        streamTracker: new ChannelzCallTracker(),
        messagesSent: 0,
        messagesReceived: 0,
        keepAlivesSent: 0,
        lastMessageSentTimestamp: null,
        lastMessageReceivedTimestamp: null,
      };

      this.http2Servers.get(http2Server)?.sessions.add(session);
      this.sessions.set(session, channelzSessionInfo);
      const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;

      this.channelzTrace.addTrace(
        'CT_INFO',
        'Connection established by client ' + clientAddress
      );
      this.trace('Connection established by client ' + clientAddress);
      this.sessionChildrenTracker.refChild(channelzRef);

      let connectionAgeTimer: NodeJS.Timeout | null = null;
      let connectionAgeGraceTimer: NodeJS.Timeout | null = null;
      let keepaliveTimeout: NodeJS.Timeout | null = null;
      let sessionClosedByServer = false;

      const idleTimeoutObj = this.enableIdleTimeout(session);

      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
        // Apply a random jitter within a +/-10% range
        const jitterMagnitude = this.maxConnectionAgeMs / 10;
        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;

        connectionAgeTimer = setTimeout(() => {
          sessionClosedByServer = true;
          this.channelzTrace.addTrace(
            'CT_INFO',
            'Connection dropped by max connection age from ' + clientAddress
          );

          try {
            session.goaway(
              http2.constants.NGHTTP2_NO_ERROR,
              ~(1 << 31),
              kMaxAge
            );
          } catch (e) {
            // The goaway can't be sent because the session is already closed
            session.destroy();
            return;
          }
          session.close();

          /* Allow a grace period after sending the GOAWAY before forcibly
           * closing the connection. */
          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
            connectionAgeGraceTimer = setTimeout(() => {
              session.destroy();
            }, this.maxConnectionAgeGraceMs);
            connectionAgeGraceTimer.unref?.();
          }
        }, this.maxConnectionAgeMs + jitter);
        connectionAgeTimer.unref?.();
      }

      const clearKeepaliveTimeout = () => {
        if (keepaliveTimeout) {
          clearTimeout(keepaliveTimeout);
          keepaliveTimeout = null;
        }
      };

      const canSendPing = () => {
        return (
          !session.destroyed &&
          this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
          this.keepaliveTimeMs > 0
        );
      };

      /* eslint-disable-next-line prefer-const */
      let sendPing: () => void; // hoisted for use in maybeStartKeepalivePingTimer

      const maybeStartKeepalivePingTimer = () => {
        if (!canSendPing()) {
          return;
        }
        this.keepaliveTrace(
          'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'
        );
        keepaliveTimeout = setTimeout(() => {
          clearKeepaliveTimeout();
          sendPing();
        }, this.keepaliveTimeMs);
        keepaliveTimeout.unref?.();
      };

      sendPing = () => {
        if (!canSendPing()) {
          return;
        }
        this.keepaliveTrace(
          'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'
        );
        let pingSendError = '';
        try {
          const pingSentSuccessfully = session.ping(
            (err: Error | null, duration: number, payload: Buffer) => {
              clearKeepaliveTimeout();
              if (err) {
                this.keepaliveTrace('Ping failed with error: ' + err.message);
                this.channelzTrace.addTrace(
                  'CT_INFO',
                  'Connection dropped due to error of a ping frame ' +
                    err.message +
                    ' return in ' +
                    duration
                );
                sessionClosedByServer = true;
                session.close();
              } else {
                this.keepaliveTrace('Received ping response');
                maybeStartKeepalivePingTimer();
              }
            }
          );
          if (!pingSentSuccessfully) {
            pingSendError = 'Ping returned false';
          }
        } catch (e) {
          // grpc/grpc-node#2139
          pingSendError =
            (e instanceof Error ? e.message : '') || 'Unknown error';
        }

        if (pingSendError) {
          this.keepaliveTrace('Ping send failed: ' + pingSendError);
          this.channelzTrace.addTrace(
            'CT_INFO',
            'Connection dropped due to ping send error: ' + pingSendError
          );
          sessionClosedByServer = true;
          session.close();
          return;
        }

        channelzSessionInfo.keepAlivesSent += 1;

        keepaliveTimeout = setTimeout(() => {
          clearKeepaliveTimeout();
          this.keepaliveTrace('Ping timeout passed without response');
          this.channelzTrace.addTrace(
            'CT_INFO',
            'Connection dropped by keepalive timeout from ' + clientAddress
          );
          sessionClosedByServer = true;
          session.close();
        }, this.keepaliveTimeoutMs);
        keepaliveTimeout.unref?.();
      };

      maybeStartKeepalivePingTimer();

      session.on('close', () => {
        if (!sessionClosedByServer) {
          this.channelzTrace.addTrace(
            'CT_INFO',
            'Connection dropped by client ' + clientAddress
          );
        }

        this.sessionChildrenTracker.unrefChild(channelzRef);
        unregisterChannelzRef(channelzRef);

        if (connectionAgeTimer) {
          clearTimeout(connectionAgeTimer);
        }

        if (connectionAgeGraceTimer) {
          clearTimeout(connectionAgeGraceTimer);
        }

        clearKeepaliveTimeout();

        if (idleTimeoutObj !== null) {
          clearTimeout(idleTimeoutObj.timeout);
          this.sessionIdleTimeouts.delete(session);
        }

        this.http2Servers.get(http2Server)?.sessions.delete(session);
        this.sessions.delete(session);
      });
    };
  }

  private enableIdleTimeout(
    session: http2.ServerHttp2Session
  ): SessionIdleTimeoutTracker | null {
    if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
      return null;
    }

    const idleTimeoutObj: SessionIdleTimeoutTracker = {
      activeStreams: 0,
      lastIdle: Date.now(),
      onClose: this.onStreamClose.bind(this, session),
      timeout: setTimeout(
        this.onIdleTimeout,
        this.sessionIdleTimeout,
        this,
        session
      ),
    };
    idleTimeoutObj.timeout.unref?.();
    this.sessionIdleTimeouts.set(session, idleTimeoutObj);

    const { socket } = session;
    this.trace(
      'Enable idle timeout for ' +
        socket.remoteAddress +
        ':' +
        socket.remotePort
    );

    return idleTimeoutObj;
  }

  private onIdleTimeout(
    this: undefined,
    ctx: Server,
    session: http2.ServerHttp2Session
  ) {
    const { socket } = session;
    const sessionInfo = ctx.sessionIdleTimeouts.get(session);

    // if it is called while we have activeStreams - timer will not be rescheduled
    // until last active stream is closed, then it will call .refresh() on the timer
    // important part is to not clearTimeout(timer) or it becomes unusable
    // for future refreshes
    if (
      sessionInfo !== undefined &&
      sessionInfo.activeStreams === 0
    ) {
      if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
        ctx.trace(
          'Session idle timeout triggered for ' +
            socket?.remoteAddress +
            ':' +
            socket?.remotePort +
            ' last idle at ' +
            sessionInfo.lastIdle
        );

        ctx.closeSession(session);
      } else {
        sessionInfo.timeout.refresh();
      }
    }
  }

  private onStreamOpened(stream: http2.ServerHttp2Stream) {
    const session = stream.session as http2.ServerHttp2Session;

    const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
    if (idleTimeoutObj) {
      idleTimeoutObj.activeStreams += 1;
      stream.once('close', idleTimeoutObj.onClose);
    }
  }

  private onStreamClose(session: http2.ServerHttp2Session) {
    const idleTimeoutObj = this.sessionIdleTimeouts.get(session);

    if (idleTimeoutObj) {
      idleTimeoutObj.activeStreams -= 1;
      if (idleTimeoutObj.activeStreams === 0) {
        idleTimeoutObj.lastIdle = Date.now();
        idleTimeoutObj.timeout.refresh();

        this.trace(
          'Session onStreamClose' +
            session.socket?.remoteAddress +
            ':' +
            session.socket?.remotePort +
            ' at ' +
            idleTimeoutObj.lastIdle
        );
      }
    }
  }
}

async function handleUnary<RequestType, ResponseType>(
  call: ServerInterceptingCallInterface,
  handler: UnaryHandler<RequestType, ResponseType>
): Promise<void> {
  let stream: ServerUnaryCall<RequestType, ResponseType>;

  function respond(
    err: ServerErrorResponse | ServerStatusResponse | null,
    value?: ResponseType | null,
    trailer?: Metadata,
    flags?: number
  ) {
    if (err) {
      call.sendStatus(serverErrorToStatus(err, trailer));
      return;
    }
    call.sendMessage(value, () => {
      call.sendStatus({
        code: Status.OK,
        details: 'OK',
        metadata: trailer ?? null,
      });
    });
  }

  let requestMetadata: Metadata;
  let requestMessage: RequestType | null = null;
  call.start({
    onReceiveMetadata(metadata) {
      requestMetadata = metadata;
      call.startRead();
    },
    onReceiveMessage(message) {
      if (requestMessage) {
        call.sendStatus({
          code: Status.UNIMPLEMENTED,
          details: `Received a second request message for server streaming method ${handler.path}`,
          metadata: null,
        });
        return;
      }
      requestMessage = message;
      call.startRead();
    },
    onReceiveHalfClose() {
      if (!requestMessage) {
        call.sendStatus({
          code: Status.UNIMPLEMENTED,
          details: `Received no request message for server streaming method ${handler.path}`,
          metadata: null,
        });
        return;
      }
      stream = new ServerWritableStreamImpl(
        handler.path,
        call,
        requestMetadata,
        requestMessage
      );
      try {
        handler.func(stream, respond);
      } catch (err) {
        call.sendStatus({
          code: Status.UNKNOWN,
          details: `Server method handler threw error ${
            (err as Error).message
          }`,
          metadata: null,
        });
      }
    },
    onCancel() {
      if (stream) {
        stream.cancelled = true;
        stream.emit('cancelled', 'cancelled');
      }
    },
  });
}

function handleClientStreaming<RequestType, ResponseType>(
  call: ServerInterceptingCallInterface,
  handler: ClientStreamingHandler<RequestType, ResponseType>
): void {
  let stream: ServerReadableStream<RequestType, ResponseType>;

  function respond(
    err: ServerErrorResponse | ServerStatusResponse | null,
    value?: ResponseType | null,
    trailer?: Metadata,
    flags?: number
  ) {
    if (err) {
      call.sendStatus(serverErrorToStatus(err, trailer));
      return;
    }
    call.sendMessage(value, () => {
      call.sendStatus({
        code: Status.OK,
        details: 'OK',
        metadata: trailer ?? null,
      });
    });
  }

  call.start({
    onReceiveMetadata(metadata) {
      stream = new ServerDuplexStreamImpl(handler.path, call, metadata);
      try {
        handler.func(stream, respond);
      } catch (err) {
        call.sendStatus({
          code: Status.UNKNOWN,
          details: `Server method handler threw error ${
            (err as Error).message
          }`,
          metadata: null,
        });
      }
    },
    onReceiveMessage(message) {
      stream.push(message);
    },
    onReceiveHalfClose() {
      stream.push(null);
    },
    onCancel() {
      if (stream) {
        stream.cancelled = true;
        stream.emit('cancelled', 'cancelled');
        stream.destroy();
      }
    },
  });
}

function handleServerStreaming<RequestType, ResponseType>(
  call: ServerInterceptingCallInterface,
  handler: ServerStreamingHandler<RequestType, ResponseType>
): void {
  let stream: ServerWritableStream<RequestType, ResponseType>;

  let requestMetadata: Metadata;
  let requestMessage: RequestType | null = null;
  call.start({
    onReceiveMetadata(metadata) {
      requestMetadata = metadata;
      call.startRead();
    },
    onReceiveMessage(message) {
      if (requestMessage) {
        call.sendStatus({
          code: Status.UNIMPLEMENTED,
          details: `Received a second request message for server streaming method ${handler.path}`,
          metadata: null,
        });
        return;
      }
      requestMessage = message;
      call.startRead();
    },
    onReceiveHalfClose() {
      if (!requestMessage) {
        call.sendStatus({
          code: Status.UNIMPLEMENTED,
          details: `Received no request message for server streaming method ${handler.path}`,
          metadata: null,
        });
        return;
      }
      stream = new ServerWritableStreamImpl(
        handler.path,
        call,
        requestMetadata,
        requestMessage
      );
      try {
        handler.func(stream);
      } catch (err) {
        call.sendStatus({
          code: Status.UNKNOWN,
          details: `Server method handler threw error ${
            (err as Error).message
          }`,
          metadata: null,
        });
      }
    },
    onCancel() {
      if (stream) {
        stream.cancelled = true;
        stream.emit('cancelled', 'cancelled');
        stream.destroy();
      }
    },
  });
}

function handleBidiStreaming<RequestType, ResponseType>(
  call: ServerInterceptingCallInterface,
  handler: BidiStreamingHandler<RequestType, ResponseType>
): void {
  let stream: ServerDuplexStream<RequestType, ResponseType>;

  call.start({
    onReceiveMetadata(metadata) {
      stream = new ServerDuplexStreamImpl(handler.path, call, metadata);
      try {
        handler.func(stream);
      } catch (err) {
        call.sendStatus({
          code: Status.UNKNOWN,
          details: `Server method handler threw error ${
            (err as Error).message
          }`,
          metadata: null,
        });
      }
    },
    onReceiveMessage(message) {
      stream.push(message);
    },
    onReceiveHalfClose() {
      stream.push(null);
    },
    onCancel() {
      if (stream) {
        stream.cancelled = true;
        stream.emit('cancelled', 'cancelled');
        stream.destroy();
      }
    },
  });
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/* This file implements gRFC A2 and the service config spec:
 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
 * function here takes an object with unknown structure and returns its
 * specific object type if the input has the right structure, and throws an
 * error otherwise. */

/* The any type is purposely used here. All functions validate their input at
 * runtime */
/* eslint-disable @typescript-eslint/no-explicit-any */

import * as os from 'os';
import { Status } from './constants';
import { Duration } from './duration';

export interface MethodConfigName {
  service?: string;
  method?: string;
}

export interface RetryPolicy {
  maxAttempts: number;
  initialBackoff: string;
  maxBackoff: string;
  backoffMultiplier: number;
  retryableStatusCodes: (Status | string)[];
}

export interface HedgingPolicy {
  maxAttempts: number;
  hedgingDelay?: string;
  nonFatalStatusCodes?: (Status | string)[];
}

export interface MethodConfig {
  name: MethodConfigName[];
  waitForReady?: boolean;
  timeout?: Duration;
  maxRequestBytes?: number;
  maxResponseBytes?: number;
  retryPolicy?: RetryPolicy;
  hedgingPolicy?: HedgingPolicy;
}

export interface RetryThrottling {
  maxTokens: number;
  tokenRatio: number;
}

export interface LoadBalancingConfig {
  [key: string]: object;
}

export interface ServiceConfig {
  loadBalancingPolicy?: string;
  loadBalancingConfig: LoadBalancingConfig[];
  methodConfig: MethodConfig[];
  retryThrottling?: RetryThrottling;
}

export interface ServiceConfigCanaryConfig {
  clientLanguage?: string[];
  percentage?: number;
  clientHostname?: string[];
  serviceConfig: ServiceConfig;
}

/**
 * Recognizes a number with up to 9 digits after the decimal point, followed by
 * an "s", representing a number of seconds.
 */
const DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;

/**
 * Client language name used for determining whether this client matches a
 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
 */
const CLIENT_LANGUAGE_STRING = 'node';

function validateName(obj: any): MethodConfigName {
  // In this context, and unset field and '' are considered the same
  if ('service' in obj && obj.service !== '') {
    if (typeof obj.service !== 'string') {
      throw new Error(
        `Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`
      );
    }
    if ('method' in obj && obj.method !== '') {
      if (typeof obj.method !== 'string') {
        throw new Error(
          `Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`
        );
      }
      return {
        service: obj.service,
        method: obj.method,
      };
    } else {
      return {
        service: obj.service,
      };
    }
  } else {
    if ('method' in obj && obj.method !== undefined) {
      throw new Error(
        `Invalid method config name: method set with empty or unset service`
      );
    }
    return {};
  }
}

function validateRetryPolicy(obj: any): RetryPolicy {
  if (
    !('maxAttempts' in obj) ||
    !Number.isInteger(obj.maxAttempts) ||
    obj.maxAttempts < 2
  ) {
    throw new Error(
      'Invalid method config retry policy: maxAttempts must be an integer at least 2'
    );
  }
  if (
    !('initialBackoff' in obj) ||
    typeof obj.initialBackoff !== 'string' ||
    !DURATION_REGEX.test(obj.initialBackoff)
  ) {
    throw new Error(
      'Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s'
    );
  }
  if (
    !('maxBackoff' in obj) ||
    typeof obj.maxBackoff !== 'string' ||
    !DURATION_REGEX.test(obj.maxBackoff)
  ) {
    throw new Error(
      'Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s'
    );
  }
  if (
    !('backoffMultiplier' in obj) ||
    typeof obj.backoffMultiplier !== 'number' ||
    obj.backoffMultiplier <= 0
  ) {
    throw new Error(
      'Invalid method config retry policy: backoffMultiplier must be a number greater than 0'
    );
  }
  if (
    !('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))
  ) {
    throw new Error(
      'Invalid method config retry policy: retryableStatusCodes is required'
    );
  }
  if (obj.retryableStatusCodes.length === 0) {
    throw new Error(
      'Invalid method config retry policy: retryableStatusCodes must be non-empty'
    );
  }
  for (const value of obj.retryableStatusCodes) {
    if (typeof value === 'number') {
      if (!Object.values(Status).includes(value)) {
        throw new Error(
          'Invalid method config retry policy: retryableStatusCodes value not in status code range'
        );
      }
    } else if (typeof value === 'string') {
      if (!Object.values(Status).includes(value.toUpperCase())) {
        throw new Error(
          'Invalid method config retry policy: retryableStatusCodes value not a status code name'
        );
      }
    } else {
      throw new Error(
        'Invalid method config retry policy: retryableStatusCodes value must be a string or number'
      );
    }
  }
  return {
    maxAttempts: obj.maxAttempts,
    initialBackoff: obj.initialBackoff,
    maxBackoff: obj.maxBackoff,
    backoffMultiplier: obj.backoffMultiplier,
    retryableStatusCodes: obj.retryableStatusCodes,
  };
}

function validateHedgingPolicy(obj: any): HedgingPolicy {
  if (
    !('maxAttempts' in obj) ||
    !Number.isInteger(obj.maxAttempts) ||
    obj.maxAttempts < 2
  ) {
    throw new Error(
      'Invalid method config hedging policy: maxAttempts must be an integer at least 2'
    );
  }
  if (
    'hedgingDelay' in obj &&
    (typeof obj.hedgingDelay !== 'string' ||
      !DURATION_REGEX.test(obj.hedgingDelay))
  ) {
    throw new Error(
      'Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s'
    );
  }
  if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {
    for (const value of obj.nonFatalStatusCodes) {
      if (typeof value === 'number') {
        if (!Object.values(Status).includes(value)) {
          throw new Error(
            'Invalid method config hedging policy: nonFatalStatusCodes value not in status code range'
          );
        }
      } else if (typeof value === 'string') {
        if (!Object.values(Status).includes(value.toUpperCase())) {
          throw new Error(
            'Invalid method config hedging policy: nonFatalStatusCodes value not a status code name'
          );
        }
      } else {
        throw new Error(
          'Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number'
        );
      }
    }
  }
  const result: HedgingPolicy = {
    maxAttempts: obj.maxAttempts,
  };
  if (obj.hedgingDelay) {
    result.hedgingDelay = obj.hedgingDelay;
  }
  if (obj.nonFatalStatusCodes) {
    result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
  }
  return result;
}

function validateMethodConfig(obj: any): MethodConfig {
  const result: MethodConfig = {
    name: [],
  };
  if (!('name' in obj) || !Array.isArray(obj.name)) {
    throw new Error('Invalid method config: invalid name array');
  }
  for (const name of obj.name) {
    result.name.push(validateName(name));
  }
  if ('waitForReady' in obj) {
    if (typeof obj.waitForReady !== 'boolean') {
      throw new Error('Invalid method config: invalid waitForReady');
    }
    result.waitForReady = obj.waitForReady;
  }
  if ('timeout' in obj) {
    if (typeof obj.timeout === 'object') {
      if (
        !('seconds' in obj.timeout) ||
        !(typeof obj.timeout.seconds === 'number')
      ) {
        throw new Error('Invalid method config: invalid timeout.seconds');
      }
      if (
        !('nanos' in obj.timeout) ||
        !(typeof obj.timeout.nanos === 'number')
      ) {
        throw new Error('Invalid method config: invalid timeout.nanos');
      }
      result.timeout = obj.timeout;
    } else if (
      typeof obj.timeout === 'string' &&
      DURATION_REGEX.test(obj.timeout)
    ) {
      const timeoutParts = obj.timeout
        .substring(0, obj.timeout.length - 1)
        .split('.');
      result.timeout = {
        seconds: timeoutParts[0] | 0,
        nanos: (timeoutParts[1] ?? 0) | 0,
      };
    } else {
      throw new Error('Invalid method config: invalid timeout');
    }
  }
  if ('maxRequestBytes' in obj) {
    if (typeof obj.maxRequestBytes !== 'number') {
      throw new Error('Invalid method config: invalid maxRequestBytes');
    }
    result.maxRequestBytes = obj.maxRequestBytes;
  }
  if ('maxResponseBytes' in obj) {
    if (typeof obj.maxResponseBytes !== 'number') {
      throw new Error('Invalid method config: invalid maxRequestBytes');
    }
    result.maxResponseBytes = obj.maxResponseBytes;
  }
  if ('retryPolicy' in obj) {
    if ('hedgingPolicy' in obj) {
      throw new Error(
        'Invalid method config: retryPolicy and hedgingPolicy cannot both be specified'
      );
    } else {
      result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
    }
  } else if ('hedgingPolicy' in obj) {
    result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
  }
  return result;
}

export function validateRetryThrottling(obj: any): RetryThrottling {
  if (
    !('maxTokens' in obj) ||
    typeof obj.maxTokens !== 'number' ||
    obj.maxTokens <= 0 ||
    obj.maxTokens > 1000
  ) {
    throw new Error(
      'Invalid retryThrottling: maxTokens must be a number in (0, 1000]'
    );
  }
  if (
    !('tokenRatio' in obj) ||
    typeof obj.tokenRatio !== 'number' ||
    obj.tokenRatio <= 0
  ) {
    throw new Error(
      'Invalid retryThrottling: tokenRatio must be a number greater than 0'
    );
  }
  return {
    maxTokens: +(obj.maxTokens as number).toFixed(3),
    tokenRatio: +(obj.tokenRatio as number).toFixed(3),
  };
}

function validateLoadBalancingConfig(obj: any): LoadBalancingConfig {
  if (!(typeof obj === 'object' && obj !== null)) {
    throw new Error(
      `Invalid loadBalancingConfig: unexpected type ${typeof obj}`
    );
  }
  const keys = Object.keys(obj);
  if (keys.length > 1) {
    throw new Error(
      `Invalid loadBalancingConfig: unexpected multiple keys ${keys}`
    );
  }
  if (keys.length === 0) {
    throw new Error(
      'Invalid loadBalancingConfig: load balancing policy name required'
    );
  }
  return {
    [keys[0]]: obj[keys[0]],
  };
}

export function validateServiceConfig(obj: any): ServiceConfig {
  const result: ServiceConfig = {
    loadBalancingConfig: [],
    methodConfig: [],
  };
  if ('loadBalancingPolicy' in obj) {
    if (typeof obj.loadBalancingPolicy === 'string') {
      result.loadBalancingPolicy = obj.loadBalancingPolicy;
    } else {
      throw new Error('Invalid service config: invalid loadBalancingPolicy');
    }
  }
  if ('loadBalancingConfig' in obj) {
    if (Array.isArray(obj.loadBalancingConfig)) {
      for (const config of obj.loadBalancingConfig) {
        result.loadBalancingConfig.push(validateLoadBalancingConfig(config));
      }
    } else {
      throw new Error('Invalid service config: invalid loadBalancingConfig');
    }
  }
  if ('methodConfig' in obj) {
    if (Array.isArray(obj.methodConfig)) {
      for (const methodConfig of obj.methodConfig) {
        result.methodConfig.push(validateMethodConfig(methodConfig));
      }
    }
  }
  if ('retryThrottling' in obj) {
    result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
  }
  // Validate method name uniqueness
  const seenMethodNames: MethodConfigName[] = [];
  for (const methodConfig of result.methodConfig) {
    for (const name of methodConfig.name) {
      for (const seenName of seenMethodNames) {
        if (
          name.service === seenName.service &&
          name.method === seenName.method
        ) {
          throw new Error(
            `Invalid service config: duplicate name ${name.service}/${name.method}`
          );
        }
      }
      seenMethodNames.push(name);
    }
  }
  return result;
}

function validateCanaryConfig(obj: any): ServiceConfigCanaryConfig {
  if (!('serviceConfig' in obj)) {
    throw new Error('Invalid service config choice: missing service config');
  }
  const result: ServiceConfigCanaryConfig = {
    serviceConfig: validateServiceConfig(obj.serviceConfig),
  };
  if ('clientLanguage' in obj) {
    if (Array.isArray(obj.clientLanguage)) {
      result.clientLanguage = [];
      for (const lang of obj.clientLanguage) {
        if (typeof lang === 'string') {
          result.clientLanguage.push(lang);
        } else {
          throw new Error(
            'Invalid service config choice: invalid clientLanguage'
          );
        }
      }
    } else {
      throw new Error('Invalid service config choice: invalid clientLanguage');
    }
  }
  if ('clientHostname' in obj) {
    if (Array.isArray(obj.clientHostname)) {
      result.clientHostname = [];
      for (const lang of obj.clientHostname) {
        if (typeof lang === 'string') {
          result.clientHostname.push(lang);
        } else {
          throw new Error(
            'Invalid service config choice: invalid clientHostname'
          );
        }
      }
    } else {
      throw new Error('Invalid service config choice: invalid clientHostname');
    }
  }
  if ('percentage' in obj) {
    if (
      typeof obj.percentage === 'number' &&
      0 <= obj.percentage &&
      obj.percentage <= 100
    ) {
      result.percentage = obj.percentage;
    } else {
      throw new Error('Invalid service config choice: invalid percentage');
    }
  }
  // Validate that no unexpected fields are present
  const allowedFields = [
    'clientLanguage',
    'percentage',
    'clientHostname',
    'serviceConfig',
  ];
  for (const field in obj) {
    if (!allowedFields.includes(field)) {
      throw new Error(
        `Invalid service config choice: unexpected field ${field}`
      );
    }
  }
  return result;
}

function validateAndSelectCanaryConfig(
  obj: any,
  percentage: number
): ServiceConfig {
  if (!Array.isArray(obj)) {
    throw new Error('Invalid service config list');
  }
  for (const config of obj) {
    const validatedConfig = validateCanaryConfig(config);
    /* For each field, we check if it is present, then only discard the
     * config if the field value does not match the current client */
    if (
      typeof validatedConfig.percentage === 'number' &&
      percentage > validatedConfig.percentage
    ) {
      continue;
    }
    if (Array.isArray(validatedConfig.clientHostname)) {
      let hostnameMatched = false;
      for (const hostname of validatedConfig.clientHostname) {
        if (hostname === os.hostname()) {
          hostnameMatched = true;
        }
      }
      if (!hostnameMatched) {
        continue;
      }
    }
    if (Array.isArray(validatedConfig.clientLanguage)) {
      let languageMatched = false;
      for (const language of validatedConfig.clientLanguage) {
        if (language === CLIENT_LANGUAGE_STRING) {
          languageMatched = true;
        }
      }
      if (!languageMatched) {
        continue;
      }
    }
    return validatedConfig.serviceConfig;
  }
  throw new Error('No matching service config found');
}

/**
 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
 * and select a service config with selection fields that all match this client. Most of these steps
 * can fail with an error; the caller must handle any errors thrown this way.
 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
 * @return The service configuration to use, given the percentage value, or null if the service config
 *     data has a valid format but none of the options match the current client.
 */
export function extractAndSelectServiceConfig(
  txtRecord: string[][],
  percentage: number
): ServiceConfig | null {
  for (const record of txtRecord) {
    if (record.length > 0 && record[0].startsWith('grpc_config=')) {
      /* Treat the list of strings in this record as a single string and remove
       * "grpc_config=" from the beginning. The rest should be a JSON string */
      const recordString = record.join('').substring('grpc_config='.length);
      const recordJson: any = JSON.parse(recordString);
      return validateAndSelectCanaryConfig(recordJson, percentage);
    }
  }
  return null;
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { StatusObject } from './call-interface';
import { Status } from './constants';
import { Metadata } from './metadata';

/**
 * A builder for gRPC status objects.
 */
export class StatusBuilder {
  private code: Status | null;
  private details: string | null;
  private metadata: Metadata | null;

  constructor() {
    this.code = null;
    this.details = null;
    this.metadata = null;
  }

  /**
   * Adds a status code to the builder.
   */
  withCode(code: Status): this {
    this.code = code;
    return this;
  }

  /**
   * Adds details to the builder.
   */
  withDetails(details: string): this {
    this.details = details;
    return this;
  }

  /**
   * Adds metadata to the builder.
   */
  withMetadata(metadata: Metadata): this {
    this.metadata = metadata;
    return this;
  }

  /**
   * Builds the status object.
   */
  build(): Partial<StatusObject> {
    const status: Partial<StatusObject> = {};

    if (this.code !== null) {
      status.code = this.code;
    }

    if (this.details !== null) {
      status.details = this.details;
    }

    if (this.metadata !== null) {
      status.metadata = this.metadata;
    }

    return status;
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

enum ReadState {
  NO_DATA,
  READING_SIZE,
  READING_MESSAGE,
}

export class StreamDecoder {
  private readState: ReadState = ReadState.NO_DATA;
  private readCompressFlag: Buffer = Buffer.alloc(1);
  private readPartialSize: Buffer = Buffer.alloc(4);
  private readSizeRemaining = 4;
  private readMessageSize = 0;
  private readPartialMessage: Buffer[] = [];
  private readMessageRemaining = 0;

  constructor(private maxReadMessageLength: number) {}

  write(data: Buffer): Buffer[] {
    let readHead = 0;
    let toRead: number;
    const result: Buffer[] = [];

    while (readHead < data.length) {
      switch (this.readState) {
        case ReadState.NO_DATA:
          this.readCompressFlag = data.slice(readHead, readHead + 1);
          readHead += 1;
          this.readState = ReadState.READING_SIZE;
          this.readPartialSize.fill(0);
          this.readSizeRemaining = 4;
          this.readMessageSize = 0;
          this.readMessageRemaining = 0;
          this.readPartialMessage = [];
          break;
        case ReadState.READING_SIZE:
          toRead = Math.min(data.length - readHead, this.readSizeRemaining);
          data.copy(
            this.readPartialSize,
            4 - this.readSizeRemaining,
            readHead,
            readHead + toRead
          );
          this.readSizeRemaining -= toRead;
          readHead += toRead;
          // readSizeRemaining >=0 here
          if (this.readSizeRemaining === 0) {
            this.readMessageSize = this.readPartialSize.readUInt32BE(0);
            if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
              throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
            }
            this.readMessageRemaining = this.readMessageSize;
            if (this.readMessageRemaining > 0) {
              this.readState = ReadState.READING_MESSAGE;
            } else {
              const message = Buffer.concat(
                [this.readCompressFlag, this.readPartialSize],
                5
              );

              this.readState = ReadState.NO_DATA;
              result.push(message);
            }
          }
          break;
        case ReadState.READING_MESSAGE:
          toRead = Math.min(data.length - readHead, this.readMessageRemaining);
          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
          this.readMessageRemaining -= toRead;
          readHead += toRead;
          // readMessageRemaining >=0 here
          if (this.readMessageRemaining === 0) {
            // At this point, we have read a full message
            const framedMessageBuffers = [
              this.readCompressFlag,
              this.readPartialSize,
            ].concat(this.readPartialMessage);
            const framedMessage = Buffer.concat(
              framedMessageBuffers,
              this.readMessageSize + 5
            );

            this.readState = ReadState.NO_DATA;
            result.push(framedMessage);
          }
          break;
        default:
          throw new Error('Unexpected read state');
      }
    }

    return result;
  }
}
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { isIP, isIPv6 } from 'net';

export interface TcpSubchannelAddress {
  port: number;
  host: string;
}

export interface IpcSubchannelAddress {
  path: string;
}
/**
 * This represents a single backend address to connect to. This interface is a
 * subset of net.SocketConnectOpts, i.e. the options described at
 * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener.
 * Those are in turn a subset of the options that can be passed to http2.connect.
 */

export type SubchannelAddress = TcpSubchannelAddress | IpcSubchannelAddress;

export function isTcpSubchannelAddress(
  address: SubchannelAddress
): address is TcpSubchannelAddress {
  return 'port' in address;
}

export function subchannelAddressEqual(
  address1?: SubchannelAddress,
  address2?: SubchannelAddress
): boolean {
  if (!address1 && !address2) {
    return true;
  }
  if (!address1 || !address2) {
    return false;
  }
  if (isTcpSubchannelAddress(address1)) {
    return (
      isTcpSubchannelAddress(address2) &&
      address1.host === address2.host &&
      address1.port === address2.port
    );
  } else {
    return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
  }
}

export function subchannelAddressToString(address: SubchannelAddress): string {
  if (isTcpSubchannelAddress(address)) {
    if (isIPv6(address.host)) {
      return '[' + address.host + ']:' + address.port;
    } else {
      return address.host + ':' + address.port;
    }
  } else {
    return address.path;
  }
}

const DEFAULT_PORT = 443;

export function stringToSubchannelAddress(
  addressString: string,
  port?: number
): SubchannelAddress {
  if (isIP(addressString)) {
    return {
      host: addressString,
      port: port ?? DEFAULT_PORT,
    };
  } else {
    return {
      path: addressString,
    };
  }
}

export interface Endpoint {
  addresses: SubchannelAddress[];
}

export function endpointEqual(endpoint1: Endpoint, endpoint2: Endpoint) {
  if (endpoint1.addresses.length !== endpoint2.addresses.length) {
    return false;
  }
  for (let i = 0; i < endpoint1.addresses.length; i++) {
    if (
      !subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])
    ) {
      return false;
    }
  }
  return true;
}

export function endpointToString(endpoint: Endpoint): string {
  return (
    '[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']'
  );
}

export function endpointHasAddress(
  endpoint: Endpoint,
  expectedAddress: SubchannelAddress
): boolean {
  for (const address of endpoint.addresses) {
    if (subchannelAddressEqual(address, expectedAddress)) {
      return true;
    }
  }
  return false;
}

interface EndpointMapEntry<ValueType> {
  key: Endpoint;
  value: ValueType;
}

function endpointEqualUnordered(
  endpoint1: Endpoint,
  endpoint2: Endpoint
): boolean {
  if (endpoint1.addresses.length !== endpoint2.addresses.length) {
    return false;
  }
  for (const address1 of endpoint1.addresses) {
    let matchFound = false;
    for (const address2 of endpoint2.addresses) {
      if (subchannelAddressEqual(address1, address2)) {
        matchFound = true;
        break;
      }
    }
    if (!matchFound) {
      return false;
    }
  }
  return true;
}

export class EndpointMap<ValueType> {
  private map: Set<EndpointMapEntry<ValueType>> = new Set();

  get size() {
    return this.map.size;
  }

  getForSubchannelAddress(address: SubchannelAddress): ValueType | undefined {
    for (const entry of this.map) {
      if (endpointHasAddress(entry.key, address)) {
        return entry.value;
      }
    }
    return undefined;
  }

  /**
   * Delete any entries in this map with keys that are not in endpoints
   * @param endpoints
   */
  deleteMissing(endpoints: Endpoint[]): ValueType[] {
    const removedValues: ValueType[] = [];
    for (const entry of this.map) {
      let foundEntry = false;
      for (const endpoint of endpoints) {
        if (endpointEqualUnordered(endpoint, entry.key)) {
          foundEntry = true;
        }
      }
      if (!foundEntry) {
        removedValues.push(entry.value);
        this.map.delete(entry);
      }
    }
    return removedValues;
  }

  get(endpoint: Endpoint): ValueType | undefined {
    for (const entry of this.map) {
      if (endpointEqualUnordered(endpoint, entry.key)) {
        return entry.value;
      }
    }
    return undefined;
  }

  set(endpoint: Endpoint, mapEntry: ValueType) {
    for (const entry of this.map) {
      if (endpointEqualUnordered(endpoint, entry.key)) {
        entry.value = mapEntry;
        return;
      }
    }
    this.map.add({ key: endpoint, value: mapEntry });
  }

  delete(endpoint: Endpoint) {
    for (const entry of this.map) {
      if (endpointEqualUnordered(endpoint, entry.key)) {
        this.map.delete(entry);
        return;
      }
    }
  }

  has(endpoint: Endpoint): boolean {
    for (const entry of this.map) {
      if (endpointEqualUnordered(endpoint, entry.key)) {
        return true;
      }
    }
    return false;
  }

  clear() {
    this.map.clear();
  }

  *keys(): IterableIterator<Endpoint> {
    for (const entry of this.map) {
      yield entry.key;
    }
  }

  *values(): IterableIterator<ValueType> {
    for (const entry of this.map) {
      yield entry.value;
    }
  }

  *entries(): IterableIterator<[Endpoint, ValueType]> {
    for (const entry of this.map) {
      yield [entry.key, entry.value];
    }
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as http2 from 'http2';
import * as os from 'os';

import { DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH, Status } from './constants';
import { Metadata } from './metadata';
import { StreamDecoder } from './stream-decoder';
import * as logging from './logging';
import { LogVerbosity } from './constants';
import {
  InterceptingListener,
  MessageContext,
  StatusObject,
  WriteCallback,
} from './call-interface';
import { CallEventTracker, Transport } from './transport';

const TRACER_NAME = 'subchannel_call';

/**
 * https://nodejs.org/api/errors.html#errors_class_systemerror
 */
interface SystemError extends Error {
  address?: string;
  code: string;
  dest?: string;
  errno: number;
  info?: object;
  message: string;
  path?: string;
  port?: number;
  syscall: string;
}

/**
 * Should do approximately the same thing as util.getSystemErrorName but the
 * TypeScript types don't have that function for some reason so I just made my
 * own.
 * @param errno
 */
function getSystemErrorName(errno: number): string {
  for (const [name, num] of Object.entries(os.constants.errno)) {
    if (num === errno) {
      return name;
    }
  }
  return 'Unknown system error ' + errno;
}

export interface SubchannelCall {
  cancelWithStatus(status: Status, details: string): void;
  getPeer(): string;
  sendMessageWithContext(context: MessageContext, message: Buffer): void;
  startRead(): void;
  halfClose(): void;
  getCallNumber(): number;
  getDeadlineInfo(): string[];
}

export interface StatusObjectWithRstCode extends StatusObject {
  rstCode?: number;
}

export interface SubchannelCallInterceptingListener
  extends InterceptingListener {
  onReceiveStatus(status: StatusObjectWithRstCode): void;
}

function mapHttpStatusCode(code: number): StatusObject {
  const details = `Received HTTP status code ${code}`;
  let mappedStatusCode: number;
  switch (code) {
    // TODO(murgatroid99): handle 100 and 101
    case 400:
      mappedStatusCode = Status.INTERNAL;
      break;
    case 401:
      mappedStatusCode = Status.UNAUTHENTICATED;
      break;
    case 403:
      mappedStatusCode = Status.PERMISSION_DENIED;
      break;
    case 404:
      mappedStatusCode = Status.UNIMPLEMENTED;
      break;
    case 429:
    case 502:
    case 503:
    case 504:
      mappedStatusCode = Status.UNAVAILABLE;
      break;
    default:
      mappedStatusCode = Status.UNKNOWN;
  }
  return {
    code: mappedStatusCode,
    details: details,
    metadata: new Metadata()
  };
}

export class Http2SubchannelCall implements SubchannelCall {
  private decoder: StreamDecoder;

  private isReadFilterPending = false;
  private isPushPending = false;
  private canPush = false;
  /**
   * Indicates that an 'end' event has come from the http2 stream, so there
   * will be no more data events.
   */
  private readsClosed = false;

  private statusOutput = false;

  private unpushedReadMessages: Buffer[] = [];

  private httpStatusCode: number | undefined;

  // This is populated (non-null) if and only if the call has ended
  private finalStatus: StatusObject | null = null;

  private internalError: SystemError | null = null;

  private serverEndedCall = false;

  constructor(
    private readonly http2Stream: http2.ClientHttp2Stream,
    private readonly callEventTracker: CallEventTracker,
    private readonly listener: SubchannelCallInterceptingListener,
    private readonly transport: Transport,
    private readonly callId: number
  ) {
    const maxReceiveMessageLength = transport.getOptions()['grpc.max_receive_message_length'] ?? DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
    this.decoder = new StreamDecoder(maxReceiveMessageLength);
    http2Stream.on('response', (headers, flags) => {
      let headersString = '';
      for (const header of Object.keys(headers)) {
        headersString += '\t\t' + header + ': ' + headers[header] + '\n';
      }
      this.trace('Received server headers:\n' + headersString);
      this.httpStatusCode = headers[':status'];

      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
        this.handleTrailers(headers);
      } else {
        let metadata: Metadata;
        try {
          metadata = Metadata.fromHttp2Headers(headers);
        } catch (error) {
          this.endCall({
            code: Status.UNKNOWN,
            details: (error as Error).message,
            metadata: new Metadata(),
          });
          return;
        }
        this.listener.onReceiveMetadata(metadata);
      }
    });
    http2Stream.on('trailers', (headers: http2.IncomingHttpHeaders) => {
      this.handleTrailers(headers);
    });
    http2Stream.on('data', (data: Buffer) => {
      /* If the status has already been output, allow the http2 stream to
       * drain without processing the data. */
      if (this.statusOutput) {
        return;
      }
      this.trace('receive HTTP/2 data frame of length ' + data.length);
      let messages: Buffer[];
      try {
        messages = this.decoder.write(data);
      } catch (e) {
        this.cancelWithStatus(Status.RESOURCE_EXHAUSTED, (e as Error).message);
        return;
      }

      for (const message of messages) {
        this.trace('parsed message of length ' + message.length);
        this.callEventTracker!.addMessageReceived();
        this.tryPush(message);
      }
    });
    http2Stream.on('end', () => {
      this.readsClosed = true;
      this.maybeOutputStatus();
    });
    http2Stream.on('close', () => {
      this.serverEndedCall = true;
      /* Use process.next tick to ensure that this code happens after any
       * "error" event that may be emitted at about the same time, so that
       * we can bubble up the error message from that event. */
      process.nextTick(() => {
        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);
        /* If we have a final status with an OK status code, that means that
         * we have received all of the messages and we have processed the
         * trailers and the call completed successfully, so it doesn't matter
         * how the stream ends after that */
        if (this.finalStatus?.code === Status.OK) {
          return;
        }
        let code: Status;
        let details = '';
        switch (http2Stream.rstCode) {
          case http2.constants.NGHTTP2_NO_ERROR:
            /* If we get a NO_ERROR code and we already have a status, the
             * stream completed properly and we just haven't fully processed
             * it yet */
            if (this.finalStatus !== null) {
              return;
            }
            if (this.httpStatusCode && this.httpStatusCode !== 200) {
              const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
              code = mappedStatus.code;
              details = mappedStatus.details;
            } else {
              code = Status.INTERNAL;
              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
            }
            break;
          case http2.constants.NGHTTP2_REFUSED_STREAM:
            code = Status.UNAVAILABLE;
            details = 'Stream refused by server';
            break;
          case http2.constants.NGHTTP2_CANCEL:
            code = Status.CANCELLED;
            details = 'Call cancelled';
            break;
          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
            code = Status.RESOURCE_EXHAUSTED;
            details = 'Bandwidth exhausted or memory limit exceeded';
            break;
          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
            code = Status.PERMISSION_DENIED;
            details = 'Protocol not secure enough';
            break;
          case http2.constants.NGHTTP2_INTERNAL_ERROR:
            code = Status.INTERNAL;
            if (this.internalError === null) {
              /* This error code was previously handled in the default case, and
               * there are several instances of it online, so I wanted to
               * preserve the original error message so that people find existing
               * information in searches, but also include the more recognizable
               * "Internal server error" message. */
              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
            } else {
              if (
                this.internalError.code === 'ECONNRESET' ||
                this.internalError.code === 'ETIMEDOUT'
              ) {
                code = Status.UNAVAILABLE;
                details = this.internalError.message;
              } else {
                /* The "Received RST_STREAM with code ..." error is preserved
                 * here for continuity with errors reported online, but the
                 * error message at the end will probably be more relevant in
                 * most cases. */
                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
              }
            }
            break;
          default:
            code = Status.INTERNAL;
            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
        }
        // This is a no-op if trailers were received at all.
        // This is OK, because status codes emitted here correspond to more
        // catastrophic issues that prevent us from receiving trailers in the
        // first place.
        this.endCall({
          code,
          details,
          metadata: new Metadata(),
          rstCode: http2Stream.rstCode,
        });
      });
    });
    http2Stream.on('error', (err: SystemError) => {
      /* We need an error handler here to stop "Uncaught Error" exceptions
       * from bubbling up. However, errors here should all correspond to
       * "close" events, where we will handle the error more granularly */
      /* Specifically looking for stream errors that were *not* constructed
       * from a RST_STREAM response here:
       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
       */
      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {
        this.trace(
          'Node error event: message=' +
            err.message +
            ' code=' +
            err.code +
            ' errno=' +
            getSystemErrorName(err.errno) +
            ' syscall=' +
            err.syscall
        );
        this.internalError = err;
      }
      this.callEventTracker.onStreamEnd(false);
    });
  }
  getDeadlineInfo(): string[] {
    return [`remote_addr=${this.getPeer()}`];
  }

  public onDisconnect() {
    this.endCall({
      code: Status.UNAVAILABLE,
      details: 'Connection dropped',
      metadata: new Metadata(),
    });
  }

  private outputStatus() {
    /* Precondition: this.finalStatus !== null */
    if (!this.statusOutput) {
      this.statusOutput = true;
      this.trace(
        'ended with status: code=' +
          this.finalStatus!.code +
          ' details="' +
          this.finalStatus!.details +
          '"'
      );
      this.callEventTracker.onCallEnd(this.finalStatus!);
      /* We delay the actual action of bubbling up the status to insulate the
       * cleanup code in this class from any errors that may be thrown in the
       * upper layers as a result of bubbling up the status. In particular,
       * if the status is not OK, the "error" event may be emitted
       * synchronously at the top level, which will result in a thrown error if
       * the user does not handle that event. */
      process.nextTick(() => {
        this.listener.onReceiveStatus(this.finalStatus!);
      });
      /* Leave the http2 stream in flowing state to drain incoming messages, to
       * ensure that the stream closure completes. The call stream already does
       * not push more messages after the status is output, so the messages go
       * nowhere either way. */
      this.http2Stream.resume();
    }
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '[' + this.callId + '] ' + text
    );
  }

  /**
   * On first call, emits a 'status' event with the given StatusObject.
   * Subsequent calls are no-ops.
   * @param status The status of the call.
   */
  private endCall(status: StatusObjectWithRstCode): void {
    /* If the status is OK and a new status comes in (e.g. from a
     * deserialization failure), that new status takes priority */
    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {
      this.finalStatus = status;
      this.maybeOutputStatus();
    }
    this.destroyHttp2Stream();
  }

  private maybeOutputStatus() {
    if (this.finalStatus !== null) {
      /* The combination check of readsClosed and that the two message buffer
       * arrays are empty checks that there all incoming data has been fully
       * processed */
      if (
        this.finalStatus.code !== Status.OK ||
        (this.readsClosed &&
          this.unpushedReadMessages.length === 0 &&
          !this.isReadFilterPending &&
          !this.isPushPending)
      ) {
        this.outputStatus();
      }
    }
  }

  private push(message: Buffer): void {
    this.trace(
      'pushing to reader message of length ' +
        (message instanceof Buffer ? message.length : null)
    );
    this.canPush = false;
    this.isPushPending = true;
    process.nextTick(() => {
      this.isPushPending = false;
      /* If we have already output the status any later messages should be
       * ignored, and can cause out-of-order operation errors higher up in the
       * stack. Checking as late as possible here to avoid any race conditions.
       */
      if (this.statusOutput) {
        return;
      }
      this.listener.onReceiveMessage(message);
      this.maybeOutputStatus();
    });
  }

  private tryPush(messageBytes: Buffer): void {
    if (this.canPush) {
      this.http2Stream!.pause();
      this.push(messageBytes);
    } else {
      this.trace(
        'unpushedReadMessages.push message of length ' + messageBytes.length
      );
      this.unpushedReadMessages.push(messageBytes);
    }
  }

  private handleTrailers(headers: http2.IncomingHttpHeaders) {
    this.serverEndedCall = true;
    this.callEventTracker.onStreamEnd(true);
    let headersString = '';
    for (const header of Object.keys(headers)) {
      headersString += '\t\t' + header + ': ' + headers[header] + '\n';
    }
    this.trace('Received server trailers:\n' + headersString);
    let metadata: Metadata;
    try {
      metadata = Metadata.fromHttp2Headers(headers);
    } catch (e) {
      metadata = new Metadata();
    }
    const metadataMap = metadata.getMap();
    let status: StatusObject;
    if (typeof metadataMap['grpc-status'] === 'string') {
      const receivedStatus: Status = Number(metadataMap['grpc-status']);
      this.trace('received status code ' + receivedStatus + ' from server');
      metadata.remove('grpc-status');
      let details = '';
      if (typeof metadataMap['grpc-message'] === 'string') {
        try {
          details = decodeURI(metadataMap['grpc-message']);
        } catch (e) {
          details = metadataMap['grpc-message'];
        }
        metadata.remove('grpc-message');
        this.trace(
          'received status details string "' + details + '" from server'
        );
      }
      status = {
        code: receivedStatus,
        details: details,
        metadata: metadata
      };
    } else if (this.httpStatusCode) {
      status = mapHttpStatusCode(this.httpStatusCode);
      status.metadata = metadata;
    } else {
      status = {
        code: Status.UNKNOWN,
        details: 'No status information received',
        metadata: metadata
      };
    }
    // This is a no-op if the call was already ended when handling headers.
    this.endCall(status);
  }

  private destroyHttp2Stream() {
    // The http2 stream could already have been destroyed if cancelWithStatus
    // is called in response to an internal http2 error.
    if (this.http2Stream.destroyed) {
      return;
    }
    /* If the server ended the call, sending an RST_STREAM is redundant, so we
     * just half close on the client side instead to finish closing the stream.
     */
    if (this.serverEndedCall) {
      this.http2Stream.end();
    } else {
      /* If the call has ended with an OK status, communicate that when closing
       * the stream, partly to avoid a situation in which we detect an error
       * RST_STREAM as a result after we have the status */
      let code: number;
      if (this.finalStatus?.code === Status.OK) {
        code = http2.constants.NGHTTP2_NO_ERROR;
      } else {
        code = http2.constants.NGHTTP2_CANCEL;
      }
      this.trace('close http2 stream with code ' + code);
      this.http2Stream.close(code);
    }
  }

  cancelWithStatus(status: Status, details: string): void {
    this.trace(
      'cancelWithStatus code: ' + status + ' details: "' + details + '"'
    );
    this.endCall({ code: status, details, metadata: new Metadata() });
  }

  getStatus(): StatusObject | null {
    return this.finalStatus;
  }

  getPeer(): string {
    return this.transport.getPeerName();
  }

  getCallNumber(): number {
    return this.callId;
  }

  startRead() {
    /* If the stream has ended with an error, we should not emit any more
     * messages and we should communicate that the stream has ended */
    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {
      this.readsClosed = true;
      this.maybeOutputStatus();
      return;
    }
    this.canPush = true;
    if (this.unpushedReadMessages.length > 0) {
      const nextMessage: Buffer = this.unpushedReadMessages.shift()!;
      this.push(nextMessage);
      return;
    }
    /* Only resume reading from the http2Stream if we don't have any pending
     * messages to emit */
    this.http2Stream.resume();
  }

  sendMessageWithContext(context: MessageContext, message: Buffer) {
    this.trace('write() called with message of length ' + message.length);
    const cb: WriteCallback = (error?: Error | null) => {
      /* nextTick here ensures that no stream action can be taken in the call
       * stack of the write callback, in order to hopefully work around
       * https://github.com/nodejs/node/issues/49147 */
      process.nextTick(() => {
        let code: Status = Status.UNAVAILABLE;
        if (
          (error as NodeJS.ErrnoException)?.code ===
          'ERR_STREAM_WRITE_AFTER_END'
        ) {
          code = Status.INTERNAL;
        }
        if (error) {
          this.cancelWithStatus(code, `Write error: ${error.message}`);
        }
        context.callback?.();
      });
    };
    this.trace('sending data chunk of length ' + message.length);
    this.callEventTracker.addMessageSent();
    try {
      this.http2Stream!.write(message, cb);
    } catch (error) {
      this.endCall({
        code: Status.UNAVAILABLE,
        details: `Write failed with error ${(error as Error).message}`,
        metadata: new Metadata(),
      });
    }
  }

  halfClose() {
    this.trace('end() called');
    this.trace('calling end() on HTTP/2 stream');
    this.http2Stream.end();
  }
}
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import type { SubchannelRef } from './channelz';
import { ConnectivityState } from './connectivity-state';
import { Subchannel } from './subchannel';

export type ConnectivityStateListener = (
  subchannel: SubchannelInterface,
  previousState: ConnectivityState,
  newState: ConnectivityState,
  keepaliveTime: number,
  errorMessage?: string
) => void;

export type HealthListener = (healthy: boolean) => void;

/**
 * This is an interface for load balancing policies to use to interact with
 * subchannels. This allows load balancing policies to wrap and unwrap
 * subchannels.
 *
 * Any load balancing policy that wraps subchannels must unwrap the subchannel
 * in the picker, so that other load balancing policies consistently have
 * access to their own wrapper objects.
 */
export interface SubchannelInterface {
  getConnectivityState(): ConnectivityState;
  addConnectivityStateListener(listener: ConnectivityStateListener): void;
  removeConnectivityStateListener(listener: ConnectivityStateListener): void;
  startConnecting(): void;
  getAddress(): string;
  throttleKeepalive(newKeepaliveTime: number): void;
  ref(): void;
  unref(): void;
  getChannelzRef(): SubchannelRef;
  isHealthy(): boolean;
  addHealthStateWatcher(listener: HealthListener): void;
  removeHealthStateWatcher(listener: HealthListener): void;
  /**
   * If this is a wrapper, return the wrapped subchannel, otherwise return this
   */
  getRealSubchannel(): Subchannel;
  /**
   * Returns true if this and other both proxy the same underlying subchannel.
   * Can be used instead of directly accessing getRealSubchannel to allow mocks
   * to avoid implementing getRealSubchannel
   */
  realSubchannelEquals(other: SubchannelInterface): boolean;
}

export abstract class BaseSubchannelWrapper implements SubchannelInterface {
  private healthy = true;
  private healthListeners: Set<HealthListener> = new Set();
  constructor(protected child: SubchannelInterface) {
    child.addHealthStateWatcher(childHealthy => {
      /* A change to the child health state only affects this wrapper's overall
       * health state if this wrapper is reporting healthy. */
      if (this.healthy) {
        this.updateHealthListeners();
      }
    });
  }

  private updateHealthListeners(): void {
    for (const listener of this.healthListeners) {
      listener(this.isHealthy());
    }
  }

  getConnectivityState(): ConnectivityState {
    return this.child.getConnectivityState();
  }
  addConnectivityStateListener(listener: ConnectivityStateListener): void {
    this.child.addConnectivityStateListener(listener);
  }
  removeConnectivityStateListener(listener: ConnectivityStateListener): void {
    this.child.removeConnectivityStateListener(listener);
  }
  startConnecting(): void {
    this.child.startConnecting();
  }
  getAddress(): string {
    return this.child.getAddress();
  }
  throttleKeepalive(newKeepaliveTime: number): void {
    this.child.throttleKeepalive(newKeepaliveTime);
  }
  ref(): void {
    this.child.ref();
  }
  unref(): void {
    this.child.unref();
  }
  getChannelzRef(): SubchannelRef {
    return this.child.getChannelzRef();
  }
  isHealthy(): boolean {
    return this.healthy && this.child.isHealthy();
  }
  addHealthStateWatcher(listener: HealthListener): void {
    this.healthListeners.add(listener);
  }
  removeHealthStateWatcher(listener: HealthListener): void {
    this.healthListeners.delete(listener);
  }
  protected setHealthy(healthy: boolean): void {
    if (healthy !== this.healthy) {
      this.healthy = healthy;
      /* A change to this wrapper's health state only affects the overall
       * reported health state if the child is healthy. */
      if (this.child.isHealthy()) {
        this.updateHealthListeners();
      }
    }
  }
  getRealSubchannel(): Subchannel {
    return this.child.getRealSubchannel();
  }
  realSubchannelEquals(other: SubchannelInterface): boolean {
    return this.getRealSubchannel() === other.getRealSubchannel();
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelOptions, channelOptionsEqual } from './channel-options';
import { Subchannel } from './subchannel';
import {
  SubchannelAddress,
  subchannelAddressEqual,
} from './subchannel-address';
import { ChannelCredentials } from './channel-credentials';
import { GrpcUri, uriToString } from './uri-parser';
import { Http2SubchannelConnector } from './transport';

// 10 seconds in milliseconds. This value is arbitrary.
/**
 * The amount of time in between checks for dropping subchannels that have no
 * other references
 */
const REF_CHECK_INTERVAL = 10_000;

export class SubchannelPool {
  private pool: {
    [channelTarget: string]: Array<{
      subchannelAddress: SubchannelAddress;
      channelArguments: ChannelOptions;
      channelCredentials: ChannelCredentials;
      subchannel: Subchannel;
    }>;
  } = Object.create(null);

  /**
   * A timer of a task performing a periodic subchannel cleanup.
   */
  private cleanupTimer: NodeJS.Timeout | null = null;

  /**
   * A pool of subchannels use for making connections. Subchannels with the
   * exact same parameters will be reused.
   */
  constructor() {}

  /**
   * Unrefs all unused subchannels and cancels the cleanup task if all
   * subchannels have been unrefed.
   */
  unrefUnusedSubchannels(): void {
    let allSubchannelsUnrefed = true;

    /* These objects are created with Object.create(null), so they do not
     * have a prototype, which means that for (... in ...) loops over them
     * do not need to be filtered */
    // eslint-disable-disable-next-line:forin
    for (const channelTarget in this.pool) {
      const subchannelObjArray = this.pool[channelTarget];

      const refedSubchannels = subchannelObjArray.filter(
        value => !value.subchannel.unrefIfOneRef()
      );

      if (refedSubchannels.length > 0) {
        allSubchannelsUnrefed = false;
      }

      /* For each subchannel in the pool, try to unref it if it has
       * exactly one ref (which is the ref from the pool itself). If that
       * does happen, remove the subchannel from the pool */
      this.pool[channelTarget] = refedSubchannels;
    }
    /* Currently we do not delete keys with empty values. If that results
     * in significant memory usage we should change it. */

    // Cancel the cleanup task if all subchannels have been unrefed.
    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
  }

  /**
   * Ensures that the cleanup task is spawned.
   */
  ensureCleanupTask(): void {
    if (this.cleanupTimer === null) {
      this.cleanupTimer = setInterval(() => {
        this.unrefUnusedSubchannels();
      }, REF_CHECK_INTERVAL);

      // Unref because this timer should not keep the event loop running.
      // Call unref only if it exists to address electron/electron#21162
      this.cleanupTimer.unref?.();
    }
  }

  /**
   * Get a subchannel if one already exists with exactly matching parameters.
   * Otherwise, create and save a subchannel with those parameters.
   * @param channelTarget
   * @param subchannelTarget
   * @param channelArguments
   * @param channelCredentials
   */
  getOrCreateSubchannel(
    channelTargetUri: GrpcUri,
    subchannelTarget: SubchannelAddress,
    channelArguments: ChannelOptions,
    channelCredentials: ChannelCredentials
  ): Subchannel {
    this.ensureCleanupTask();
    const channelTarget = uriToString(channelTargetUri);
    if (channelTarget in this.pool) {
      const subchannelObjArray = this.pool[channelTarget];
      for (const subchannelObj of subchannelObjArray) {
        if (
          subchannelAddressEqual(
            subchannelTarget,
            subchannelObj.subchannelAddress
          ) &&
          channelOptionsEqual(
            channelArguments,
            subchannelObj.channelArguments
          ) &&
          channelCredentials._equals(subchannelObj.channelCredentials)
        ) {
          return subchannelObj.subchannel;
        }
      }
    }
    // If we get here, no matching subchannel was found
    const subchannel = new Subchannel(
      channelTargetUri,
      subchannelTarget,
      channelArguments,
      channelCredentials,
      new Http2SubchannelConnector(channelTargetUri)
    );
    if (!(channelTarget in this.pool)) {
      this.pool[channelTarget] = [];
    }
    this.pool[channelTarget].push({
      subchannelAddress: subchannelTarget,
      channelArguments,
      channelCredentials,
      subchannel,
    });
    subchannel.ref();
    return subchannel;
  }
}

const globalSubchannelPool = new SubchannelPool();

/**
 * Get either the global subchannel pool, or a new subchannel pool.
 * @param global
 */
export function getSubchannelPool(global: boolean): SubchannelPool {
  if (global) {
    return globalSubchannelPool;
  } else {
    return new SubchannelPool();
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import { ChannelCredentials } from './channel-credentials';
import { Metadata } from './metadata';
import { ChannelOptions } from './channel-options';
import { ConnectivityState } from './connectivity-state';
import { BackoffTimeout, BackoffOptions } from './backoff-timeout';
import * as logging from './logging';
import { LogVerbosity, Status } from './constants';
import { GrpcUri, uriToString } from './uri-parser';
import {
  SubchannelAddress,
  subchannelAddressToString,
} from './subchannel-address';
import {
  SubchannelRef,
  ChannelzTrace,
  ChannelzChildrenTracker,
  ChannelzChildrenTrackerStub,
  SubchannelInfo,
  registerChannelzSubchannel,
  ChannelzCallTracker,
  ChannelzCallTrackerStub,
  unregisterChannelzRef,
  ChannelzTraceStub,
} from './channelz';
import {
  ConnectivityStateListener,
  SubchannelInterface,
} from './subchannel-interface';
import { SubchannelCallInterceptingListener } from './subchannel-call';
import { SubchannelCall } from './subchannel-call';
import { CallEventTracker, SubchannelConnector, Transport } from './transport';

const TRACER_NAME = 'subchannel';

/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
 * have a constant for the max signed 32 bit integer, so this is a simple way
 * to calculate it */
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);

export class Subchannel {
  /**
   * The subchannel's current connectivity state. Invariant: `session` === `null`
   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
   */
  private connectivityState: ConnectivityState = ConnectivityState.IDLE;
  /**
   * The underlying http2 session used to make requests.
   */
  private transport: Transport | null = null;
  /**
   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
   * CONNECTING instead of IDLE when the backoff timeout ends.
   */
  private continueConnecting = false;
  /**
   * A list of listener functions that will be called whenever the connectivity
   * state changes. Will be modified by `addConnectivityStateListener` and
   * `removeConnectivityStateListener`
   */
  private stateListeners: Set<ConnectivityStateListener> = new Set();

  private backoffTimeout: BackoffTimeout;

  private keepaliveTime: number;
  /**
   * Tracks channels and subchannel pools with references to this subchannel
   */
  private refcount = 0;

  /**
   * A string representation of the subchannel address, for logging/tracing
   */
  private subchannelAddressString: string;

  // Channelz info
  private readonly channelzEnabled: boolean = true;
  private channelzRef: SubchannelRef;

  private channelzTrace: ChannelzTrace | ChannelzTraceStub;
  private callTracker: ChannelzCallTracker | ChannelzCallTrackerStub;
  private childrenTracker:
    | ChannelzChildrenTracker
    | ChannelzChildrenTrackerStub;

  // Channelz socket info
  private streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;

  /**
   * A class representing a connection to a single backend.
   * @param channelTarget The target string for the channel as a whole
   * @param subchannelAddress The address for the backend that this subchannel
   *     will connect to
   * @param options The channel options, plus any specific subchannel options
   *     for this subchannel
   * @param credentials The channel credentials used to establish this
   *     connection
   */
  constructor(
    private channelTarget: GrpcUri,
    private subchannelAddress: SubchannelAddress,
    private options: ChannelOptions,
    private credentials: ChannelCredentials,
    private connector: SubchannelConnector
  ) {
    const backoffOptions: BackoffOptions = {
      initialDelay: options['grpc.initial_reconnect_backoff_ms'],
      maxDelay: options['grpc.max_reconnect_backoff_ms'],
    };
    this.backoffTimeout = new BackoffTimeout(() => {
      this.handleBackoffTimer();
    }, backoffOptions);
    this.backoffTimeout.unref();
    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);

    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;

    if (options['grpc.enable_channelz'] === 0) {
      this.channelzEnabled = false;
      this.channelzTrace = new ChannelzTraceStub();
      this.callTracker = new ChannelzCallTrackerStub();
      this.childrenTracker = new ChannelzChildrenTrackerStub();
      this.streamTracker = new ChannelzCallTrackerStub();
    } else {
      this.channelzTrace = new ChannelzTrace();
      this.callTracker = new ChannelzCallTracker();
      this.childrenTracker = new ChannelzChildrenTracker();
      this.streamTracker = new ChannelzCallTracker();
    }

    this.channelzRef = registerChannelzSubchannel(
      this.subchannelAddressString,
      () => this.getChannelzInfo(),
      this.channelzEnabled
    );

    this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');
    this.trace(
      'Subchannel constructed with options ' +
        JSON.stringify(options, undefined, 2)
    );
  }

  private getChannelzInfo(): SubchannelInfo {
    return {
      state: this.connectivityState,
      trace: this.channelzTrace,
      callTracker: this.callTracker,
      children: this.childrenTracker.getChildLists(),
      target: this.subchannelAddressString,
    };
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '(' +
        this.channelzRef.id +
        ') ' +
        this.subchannelAddressString +
        ' ' +
        text
    );
  }

  private refTrace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      'subchannel_refcount',
      '(' +
        this.channelzRef.id +
        ') ' +
        this.subchannelAddressString +
        ' ' +
        text
    );
  }

  private handleBackoffTimer() {
    if (this.continueConnecting) {
      this.transitionToState(
        [ConnectivityState.TRANSIENT_FAILURE],
        ConnectivityState.CONNECTING
      );
    } else {
      this.transitionToState(
        [ConnectivityState.TRANSIENT_FAILURE],
        ConnectivityState.IDLE
      );
    }
  }

  /**
   * Start a backoff timer with the current nextBackoff timeout
   */
  private startBackoff() {
    this.backoffTimeout.runOnce();
  }

  private stopBackoff() {
    this.backoffTimeout.stop();
    this.backoffTimeout.reset();
  }

  private startConnectingInternal() {
    let options = this.options;
    if (options['grpc.keepalive_time_ms']) {
      const adjustedKeepaliveTime = Math.min(
        this.keepaliveTime,
        KEEPALIVE_MAX_TIME_MS
      );
      options = { ...options, 'grpc.keepalive_time_ms': adjustedKeepaliveTime };
    }
    this.connector
      .connect(this.subchannelAddress, this.credentials, options)
      .then(
        transport => {
          if (
            this.transitionToState(
              [ConnectivityState.CONNECTING],
              ConnectivityState.READY
            )
          ) {
            this.transport = transport;
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(transport.getChannelzRef());
            }
            transport.addDisconnectListener(tooManyPings => {
              this.transitionToState(
                [ConnectivityState.READY],
                ConnectivityState.IDLE
              );
              if (tooManyPings && this.keepaliveTime > 0) {
                this.keepaliveTime *= 2;
                logging.log(
                  LogVerbosity.ERROR,
                  `Connection to ${uriToString(this.channelTarget)} at ${
                    this.subchannelAddressString
                  } rejected by server because of excess pings. Increasing ping interval to ${
                    this.keepaliveTime
                  } ms`
                );
              }
            });
          } else {
            /* If we can't transition from CONNECTING to READY here, we will
             * not be using this transport, so release its resources. */
            transport.shutdown();
          }
        },
        error => {
          this.transitionToState(
            [ConnectivityState.CONNECTING],
            ConnectivityState.TRANSIENT_FAILURE,
            `${error}`
          );
        }
      );
  }

  /**
   * Initiate a state transition from any element of oldStates to the new
   * state. If the current connectivityState is not in oldStates, do nothing.
   * @param oldStates The set of states to transition from
   * @param newState The state to transition to
   * @returns True if the state changed, false otherwise
   */
  private transitionToState(
    oldStates: ConnectivityState[],
    newState: ConnectivityState,
    errorMessage?: string
  ): boolean {
    if (oldStates.indexOf(this.connectivityState) === -1) {
      return false;
    }
    this.trace(
      ConnectivityState[this.connectivityState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    if (this.channelzEnabled) {
      this.channelzTrace.addTrace(
        'CT_INFO',
        'Connectivity state change to ' + ConnectivityState[newState]
      );
    }
    const previousState = this.connectivityState;
    this.connectivityState = newState;
    switch (newState) {
      case ConnectivityState.READY:
        this.stopBackoff();
        break;
      case ConnectivityState.CONNECTING:
        this.startBackoff();
        this.startConnectingInternal();
        this.continueConnecting = false;
        break;
      case ConnectivityState.TRANSIENT_FAILURE:
        if (this.channelzEnabled && this.transport) {
          this.childrenTracker.unrefChild(this.transport.getChannelzRef());
        }
        this.transport?.shutdown();
        this.transport = null;
        /* If the backoff timer has already ended by the time we get to the
         * TRANSIENT_FAILURE state, we want to immediately transition out of
         * TRANSIENT_FAILURE as though the backoff timer is ending right now */
        if (!this.backoffTimeout.isRunning()) {
          process.nextTick(() => {
            this.handleBackoffTimer();
          });
        }
        break;
      case ConnectivityState.IDLE:
        if (this.channelzEnabled && this.transport) {
          this.childrenTracker.unrefChild(this.transport.getChannelzRef());
        }
        this.transport?.shutdown();
        this.transport = null;
        break;
      default:
        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
    }
    for (const listener of this.stateListeners) {
      listener(this, previousState, newState, this.keepaliveTime, errorMessage);
    }
    return true;
  }

  ref() {
    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));
    this.refcount += 1;
  }

  unref() {
    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));
    this.refcount -= 1;
    if (this.refcount === 0) {
      this.channelzTrace.addTrace('CT_INFO', 'Shutting down');
      unregisterChannelzRef(this.channelzRef);
      process.nextTick(() => {
        this.transitionToState(
          [ConnectivityState.CONNECTING, ConnectivityState.READY],
          ConnectivityState.IDLE
        );
      });
    }
  }

  unrefIfOneRef(): boolean {
    if (this.refcount === 1) {
      this.unref();
      return true;
    }
    return false;
  }

  createCall(
    metadata: Metadata,
    host: string,
    method: string,
    listener: SubchannelCallInterceptingListener
  ): SubchannelCall {
    if (!this.transport) {
      throw new Error('Cannot create call, subchannel not READY');
    }
    let statsTracker: Partial<CallEventTracker>;
    if (this.channelzEnabled) {
      this.callTracker.addCallStarted();
      this.streamTracker.addCallStarted();
      statsTracker = {
        onCallEnd: status => {
          if (status.code === Status.OK) {
            this.callTracker.addCallSucceeded();
          } else {
            this.callTracker.addCallFailed();
          }
        },
      };
    } else {
      statsTracker = {};
    }
    return this.transport.createCall(
      metadata,
      host,
      method,
      listener,
      statsTracker
    );
  }

  /**
   * If the subchannel is currently IDLE, start connecting and switch to the
   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
   * the next time it would transition to IDLE, start connecting again instead.
   * Otherwise, do nothing.
   */
  startConnecting() {
    process.nextTick(() => {
      /* First, try to transition from IDLE to connecting. If that doesn't happen
       * because the state is not currently IDLE, check if it is
       * TRANSIENT_FAILURE, and if so indicate that it should go back to
       * connecting after the backoff timer ends. Otherwise do nothing */
      if (
        !this.transitionToState(
          [ConnectivityState.IDLE],
          ConnectivityState.CONNECTING
        )
      ) {
        if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {
          this.continueConnecting = true;
        }
      }
    });
  }

  /**
   * Get the subchannel's current connectivity state.
   */
  getConnectivityState() {
    return this.connectivityState;
  }

  /**
   * Add a listener function to be called whenever the subchannel's
   * connectivity state changes.
   * @param listener
   */
  addConnectivityStateListener(listener: ConnectivityStateListener) {
    this.stateListeners.add(listener);
  }

  /**
   * Remove a listener previously added with `addConnectivityStateListener`
   * @param listener A reference to a function previously passed to
   *     `addConnectivityStateListener`
   */
  removeConnectivityStateListener(listener: ConnectivityStateListener) {
    this.stateListeners.delete(listener);
  }

  /**
   * Reset the backoff timeout, and immediately start connecting if in backoff.
   */
  resetBackoff() {
    process.nextTick(() => {
      this.backoffTimeout.reset();
      this.transitionToState(
        [ConnectivityState.TRANSIENT_FAILURE],
        ConnectivityState.CONNECTING
      );
    });
  }

  getAddress(): string {
    return this.subchannelAddressString;
  }

  getChannelzRef(): SubchannelRef {
    return this.channelzRef;
  }

  isHealthy(): boolean {
    return true;
  }

  addHealthStateWatcher(listener: (healthy: boolean) => void): void {
    // Do nothing with the listener
  }

  removeHealthStateWatcher(listener: (healthy: boolean) => void): void {
    // Do nothing with the listener
  }

  getRealSubchannel(): this {
    return this;
  }

  realSubchannelEquals(other: SubchannelInterface): boolean {
    return other.getRealSubchannel() === this;
  }

  throttleKeepalive(newKeepaliveTime: number) {
    if (newKeepaliveTime > this.keepaliveTime) {
      this.keepaliveTime = newKeepaliveTime;
    }
  }
}
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as fs from 'fs';

export const CIPHER_SUITES: string | undefined =
  process.env.GRPC_SSL_CIPHER_SUITES;

const DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;

let defaultRootsData: Buffer | null = null;

export function getDefaultRootsData(): Buffer | null {
  if (DEFAULT_ROOTS_FILE_PATH) {
    if (defaultRootsData === null) {
      defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
    }
    return defaultRootsData;
  }
  return null;
}
/*
 * Copyright 2023 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as http2 from 'http2';
import {
  checkServerIdentity,
  CipherNameAndProtocol,
  ConnectionOptions,
  PeerCertificate,
  TLSSocket,
} from 'tls';
import { PartialStatusObject } from './call-interface';
import { ChannelCredentials } from './channel-credentials';
import { ChannelOptions } from './channel-options';
import {
  ChannelzCallTracker,
  ChannelzCallTrackerStub,
  registerChannelzSocket,
  SocketInfo,
  SocketRef,
  TlsInfo,
  unregisterChannelzRef,
} from './channelz';
import { LogVerbosity } from './constants';
import { getProxiedConnection, ProxyConnectionResult } from './http_proxy';
import * as logging from './logging';
import { getDefaultAuthority } from './resolver';
import {
  stringToSubchannelAddress,
  SubchannelAddress,
  subchannelAddressToString,
} from './subchannel-address';
import { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';
import * as net from 'net';
import {
  Http2SubchannelCall,
  SubchannelCall,
  SubchannelCallInterceptingListener,
} from './subchannel-call';
import { Metadata } from './metadata';
import { getNextCallNumber } from './call-number';

const TRACER_NAME = 'transport';
const FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';

const clientVersion = require('../../package.json').version;

const {
  HTTP2_HEADER_AUTHORITY,
  HTTP2_HEADER_CONTENT_TYPE,
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_TE,
  HTTP2_HEADER_USER_AGENT,
} = http2.constants;

const KEEPALIVE_TIMEOUT_MS = 20000;

export interface CallEventTracker {
  addMessageSent(): void;
  addMessageReceived(): void;
  onCallEnd(status: PartialStatusObject): void;
  onStreamEnd(success: boolean): void;
}

export interface TransportDisconnectListener {
  (tooManyPings: boolean): void;
}

export interface Transport {
  getChannelzRef(): SocketRef;
  getPeerName(): string;
  getOptions(): ChannelOptions;
  createCall(
    metadata: Metadata,
    host: string,
    method: string,
    listener: SubchannelCallInterceptingListener,
    subchannelCallStatsTracker: Partial<CallEventTracker>
  ): SubchannelCall;
  addDisconnectListener(listener: TransportDisconnectListener): void;
  shutdown(): void;
}

const tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');

class Http2Transport implements Transport {
  /**
   * The amount of time in between sending pings
   */
  private readonly keepaliveTimeMs: number;
  /**
   * The amount of time to wait for an acknowledgement after sending a ping
   */
  private readonly keepaliveTimeoutMs: number;
  /**
   * Indicates whether keepalive pings should be sent without any active calls
   */
  private readonly keepaliveWithoutCalls: boolean;
  /**
   * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.
   */
  private keepaliveTimer: NodeJS.Timeout | null = null;
  /**
   * Indicates that the keepalive timer ran out while there were no active
   * calls, and a ping should be sent the next time a call starts.
   */
  private pendingSendKeepalivePing = false;

  private userAgent: string;

  private activeCalls: Set<Http2SubchannelCall> = new Set();

  private subchannelAddressString: string;

  private disconnectListeners: TransportDisconnectListener[] = [];

  private disconnectHandled = false;

  // Channelz info
  private channelzRef: SocketRef;
  private readonly channelzEnabled: boolean = true;
  private streamTracker: ChannelzCallTracker | ChannelzCallTrackerStub;
  private keepalivesSent = 0;
  private messagesSent = 0;
  private messagesReceived = 0;
  private lastMessageSentTimestamp: Date | null = null;
  private lastMessageReceivedTimestamp: Date | null = null;

  constructor(
    private session: http2.ClientHttp2Session,
    subchannelAddress: SubchannelAddress,
    private options: ChannelOptions,
    /**
     * Name of the remote server, if it is not the same as the subchannel
     * address, i.e. if connecting through an HTTP CONNECT proxy.
     */
    private remoteName: string | null
  ) {
    /* Populate subchannelAddressString and channelzRef before doing anything
     * else, because they are used in the trace methods. */
    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);

    if (options['grpc.enable_channelz'] === 0) {
      this.channelzEnabled = false;
      this.streamTracker = new ChannelzCallTrackerStub();
    } else {
      this.streamTracker = new ChannelzCallTracker();
    }

    this.channelzRef = registerChannelzSocket(
      this.subchannelAddressString,
      () => this.getChannelzInfo(),
      this.channelzEnabled
    );

    // Build user-agent string.
    this.userAgent = [
      options['grpc.primary_user_agent'],
      `grpc-node-js/${clientVersion}`,
      options['grpc.secondary_user_agent'],
    ]
      .filter(e => e)
      .join(' '); // remove falsey values first

    if ('grpc.keepalive_time_ms' in options) {
      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;
    } else {
      this.keepaliveTimeMs = -1;
    }
    if ('grpc.keepalive_timeout_ms' in options) {
      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;
    } else {
      this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
    }
    if ('grpc.keepalive_permit_without_calls' in options) {
      this.keepaliveWithoutCalls =
        options['grpc.keepalive_permit_without_calls'] === 1;
    } else {
      this.keepaliveWithoutCalls = false;
    }

    session.once('close', () => {
      this.trace('session closed');
      this.handleDisconnect();
    });

    session.once(
      'goaway',
      (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => {
        let tooManyPings = false;
        /* See the last paragraph of
         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
        if (
          errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
          opaqueData &&
          opaqueData.equals(tooManyPingsData)
        ) {
          tooManyPings = true;
        }
        this.trace(
          'connection closed by GOAWAY with code ' +
            errorCode +
            ' and data ' +
            opaqueData?.toString()
        );
        this.reportDisconnectToOwner(tooManyPings);
      }
    );

    session.once('error', error => {
      /* Do nothing here. Any error should also trigger a close event, which is
       * where we want to handle that.  */
      this.trace('connection closed with error ' + (error as Error).message);
    });

    if (logging.isTracerEnabled(TRACER_NAME)) {
      session.on('remoteSettings', (settings: http2.Settings) => {
        this.trace(
          'new settings received' +
            (this.session !== session ? ' on the old connection' : '') +
            ': ' +
            JSON.stringify(settings)
        );
      });
      session.on('localSettings', (settings: http2.Settings) => {
        this.trace(
          'local settings acknowledged by remote' +
            (this.session !== session ? ' on the old connection' : '') +
            ': ' +
            JSON.stringify(settings)
        );
      });
    }

    /* Start the keepalive timer last, because this can trigger trace logs,
     * which should only happen after everything else is set up. */
    if (this.keepaliveWithoutCalls) {
      this.maybeStartKeepalivePingTimer();
    }
  }

  private getChannelzInfo(): SocketInfo {
    const sessionSocket = this.session.socket;
    const remoteAddress = sessionSocket.remoteAddress
      ? stringToSubchannelAddress(
          sessionSocket.remoteAddress,
          sessionSocket.remotePort
        )
      : null;
    const localAddress = sessionSocket.localAddress
      ? stringToSubchannelAddress(
          sessionSocket.localAddress,
          sessionSocket.localPort
        )
      : null;
    let tlsInfo: TlsInfo | null;
    if (this.session.encrypted) {
      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;
      const cipherInfo: CipherNameAndProtocol & { standardName?: string } =
        tlsSocket.getCipher();
      const certificate = tlsSocket.getCertificate();
      const peerCertificate = tlsSocket.getPeerCertificate();
      tlsInfo = {
        cipherSuiteStandardName: cipherInfo.standardName ?? null,
        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
        localCertificate:
          certificate && 'raw' in certificate ? certificate.raw : null,
        remoteCertificate:
          peerCertificate && 'raw' in peerCertificate
            ? peerCertificate.raw
            : null,
      };
    } else {
      tlsInfo = null;
    }
    const socketInfo: SocketInfo = {
      remoteAddress: remoteAddress,
      localAddress: localAddress,
      security: tlsInfo,
      remoteName: this.remoteName,
      streamsStarted: this.streamTracker.callsStarted,
      streamsSucceeded: this.streamTracker.callsSucceeded,
      streamsFailed: this.streamTracker.callsFailed,
      messagesSent: this.messagesSent,
      messagesReceived: this.messagesReceived,
      keepAlivesSent: this.keepalivesSent,
      lastLocalStreamCreatedTimestamp:
        this.streamTracker.lastCallStartedTimestamp,
      lastRemoteStreamCreatedTimestamp: null,
      lastMessageSentTimestamp: this.lastMessageSentTimestamp,
      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
      localFlowControlWindow: this.session.state.localWindowSize ?? null,
      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null,
    };
    return socketInfo;
  }

  private trace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '(' +
        this.channelzRef.id +
        ') ' +
        this.subchannelAddressString +
        ' ' +
        text
    );
  }

  private keepaliveTrace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      'keepalive',
      '(' +
        this.channelzRef.id +
        ') ' +
        this.subchannelAddressString +
        ' ' +
        text
    );
  }

  private flowControlTrace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      FLOW_CONTROL_TRACER_NAME,
      '(' +
        this.channelzRef.id +
        ') ' +
        this.subchannelAddressString +
        ' ' +
        text
    );
  }

  private internalsTrace(text: string): void {
    logging.trace(
      LogVerbosity.DEBUG,
      'transport_internals',
      '(' +
        this.channelzRef.id +
        ') ' +
        this.subchannelAddressString +
        ' ' +
        text
    );
  }

  /**
   * Indicate to the owner of this object that this transport should no longer
   * be used. That happens if the connection drops, or if the server sends a
   * GOAWAY.
   * @param tooManyPings If true, this was triggered by a GOAWAY with data
   * indicating that the session was closed becaues the client sent too many
   * pings.
   * @returns
   */
  private reportDisconnectToOwner(tooManyPings: boolean) {
    if (this.disconnectHandled) {
      return;
    }
    this.disconnectHandled = true;
    this.disconnectListeners.forEach(listener => listener(tooManyPings));
  }

  /**
   * Handle connection drops, but not GOAWAYs.
   */
  private handleDisconnect() {
    this.clearKeepaliveTimeout();
    this.reportDisconnectToOwner(false);
    /* Give calls an event loop cycle to finish naturally before reporting the
     * disconnnection to them. */
    setImmediate(() => {
      for (const call of this.activeCalls) {
        call.onDisconnect();
      }
      this.session.destroy();
    });
  }

  addDisconnectListener(listener: TransportDisconnectListener): void {
    this.disconnectListeners.push(listener);
  }

  private canSendPing() {
    return (
      !this.session.destroyed &&
      this.keepaliveTimeMs > 0 &&
      (this.keepaliveWithoutCalls || this.activeCalls.size > 0)
    );
  }

  private maybeSendPing() {
    if (!this.canSendPing()) {
      this.pendingSendKeepalivePing = true;
      return;
    }
    if (this.keepaliveTimer) {
      console.error('keepaliveTimeout is not null');
      return;
    }
    if (this.channelzEnabled) {
      this.keepalivesSent += 1;
    }
    this.keepaliveTrace(
      'Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms'
    );
    this.keepaliveTimer = setTimeout(() => {
      this.keepaliveTimer = null;
      this.keepaliveTrace('Ping timeout passed without response');
      this.handleDisconnect();
    }, this.keepaliveTimeoutMs);
    this.keepaliveTimer.unref?.();
    let pingSendError = '';
    try {
      const pingSentSuccessfully = this.session.ping(
        (err: Error | null, duration: number, payload: Buffer) => {
          this.clearKeepaliveTimeout();
          if (err) {
            this.keepaliveTrace('Ping failed with error ' + err.message);
            this.handleDisconnect();
          } else {
            this.keepaliveTrace('Received ping response');
            this.maybeStartKeepalivePingTimer();
          }
        }
      );
      if (!pingSentSuccessfully) {
        pingSendError = 'Ping returned false';
      }
    } catch (e) {
      // grpc/grpc-node#2139
      pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';
    }
    if (pingSendError) {
      this.keepaliveTrace('Ping send failed: ' + pingSendError);
      this.handleDisconnect();
    }
  }

  /**
   * Starts the keepalive ping timer if appropriate. If the timer already ran
   * out while there were no active requests, instead send a ping immediately.
   * If the ping timer is already running or a ping is currently in flight,
   * instead do nothing and wait for them to resolve.
   */
  private maybeStartKeepalivePingTimer() {
    if (!this.canSendPing()) {
      return;
    }
    if (this.pendingSendKeepalivePing) {
      this.pendingSendKeepalivePing = false;
      this.maybeSendPing();
    } else if (!this.keepaliveTimer) {
      this.keepaliveTrace(
        'Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms'
      );
      this.keepaliveTimer = setTimeout(() => {
        this.keepaliveTimer = null;
        this.maybeSendPing();
      }, this.keepaliveTimeMs);
      this.keepaliveTimer.unref?.();
    }
    /* Otherwise, there is already either a keepalive timer or a ping pending,
     * wait for those to resolve. */
  }

  /**
   * Clears whichever keepalive timeout is currently active, if any.
   */
  private clearKeepaliveTimeout() {
    if (this.keepaliveTimer) {
      clearTimeout(this.keepaliveTimer);
      this.keepaliveTimer = null;
    }
  }

  private removeActiveCall(call: Http2SubchannelCall) {
    this.activeCalls.delete(call);
    if (this.activeCalls.size === 0) {
      this.session.unref();
    }
  }

  private addActiveCall(call: Http2SubchannelCall) {
    this.activeCalls.add(call);
    if (this.activeCalls.size === 1) {
      this.session.ref();
      if (!this.keepaliveWithoutCalls) {
        this.maybeStartKeepalivePingTimer();
      }
    }
  }

  createCall(
    metadata: Metadata,
    host: string,
    method: string,
    listener: SubchannelCallInterceptingListener,
    subchannelCallStatsTracker: Partial<CallEventTracker>
  ): Http2SubchannelCall {
    const headers = metadata.toHttp2Headers();
    headers[HTTP2_HEADER_AUTHORITY] = host;
    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
    headers[HTTP2_HEADER_METHOD] = 'POST';
    headers[HTTP2_HEADER_PATH] = method;
    headers[HTTP2_HEADER_TE] = 'trailers';
    // Set default 'user-agent' header if it's not explicitly set in the metadata
    if (
      !Object.keys(headers).some(
        key => key.toLowerCase() === HTTP2_HEADER_USER_AGENT
      )
    ) {
      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
    }
    let http2Stream: http2.ClientHttp2Stream;
    /* In theory, if an error is thrown by session.request because session has
     * become unusable (e.g. because it has received a goaway), this subchannel
     * should soon see the corresponding close or goaway event anyway and leave
     * READY. But we have seen reports that this does not happen
     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
     * so for defense in depth, we just discard the session when we see an
     * error here.
     */
    try {
      http2Stream = this.session.request(headers);
    } catch (e) {
      this.handleDisconnect();
      throw e;
    }
    this.flowControlTrace(
      'local window size: ' +
        this.session.state.localWindowSize +
        ' remote window size: ' +
        this.session.state.remoteWindowSize
    );
    this.internalsTrace(
      'session.closed=' +
        this.session.closed +
        ' session.destroyed=' +
        this.session.destroyed +
        ' session.socket.destroyed=' +
        this.session.socket.destroyed
    );
    let eventTracker: CallEventTracker;
    // eslint-disable-next-line prefer-const
    let call: Http2SubchannelCall;
    if (this.channelzEnabled) {
      this.streamTracker.addCallStarted();
      eventTracker = {
        addMessageSent: () => {
          this.messagesSent += 1;
          this.lastMessageSentTimestamp = new Date();
          subchannelCallStatsTracker.addMessageSent?.();
        },
        addMessageReceived: () => {
          this.messagesReceived += 1;
          this.lastMessageReceivedTimestamp = new Date();
          subchannelCallStatsTracker.addMessageReceived?.();
        },
        onCallEnd: status => {
          subchannelCallStatsTracker.onCallEnd?.(status);
          this.removeActiveCall(call);
        },
        onStreamEnd: success => {
          if (success) {
            this.streamTracker.addCallSucceeded();
          } else {
            this.streamTracker.addCallFailed();
          }
          subchannelCallStatsTracker.onStreamEnd?.(success);
        },
      };
    } else {
      eventTracker = {
        addMessageSent: () => {
          subchannelCallStatsTracker.addMessageSent?.();
        },
        addMessageReceived: () => {
          subchannelCallStatsTracker.addMessageReceived?.();
        },
        onCallEnd: status => {
          subchannelCallStatsTracker.onCallEnd?.(status);
          this.removeActiveCall(call);
        },
        onStreamEnd: success => {
          subchannelCallStatsTracker.onStreamEnd?.(success);
        },
      };
    }
    call = new Http2SubchannelCall(
      http2Stream,
      eventTracker,
      listener,
      this,
      getNextCallNumber()
    );
    this.addActiveCall(call);
    return call;
  }

  getChannelzRef(): SocketRef {
    return this.channelzRef;
  }

  getPeerName() {
    return this.subchannelAddressString;
  }

  getOptions() {
    return this.options;
  }

  shutdown() {
    this.session.close();
    unregisterChannelzRef(this.channelzRef);
  }
}

export interface SubchannelConnector {
  connect(
    address: SubchannelAddress,
    credentials: ChannelCredentials,
    options: ChannelOptions
  ): Promise<Transport>;
  shutdown(): void;
}

export class Http2SubchannelConnector implements SubchannelConnector {
  private session: http2.ClientHttp2Session | null = null;
  private isShutdown = false;
  constructor(private channelTarget: GrpcUri) {}

  private trace(text: string) {
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      uriToString(this.channelTarget) + ' ' + text
    );
  }

  private createSession(
    address: SubchannelAddress,
    credentials: ChannelCredentials,
    options: ChannelOptions,
    proxyConnectionResult: ProxyConnectionResult
  ): Promise<Http2Transport> {
    if (this.isShutdown) {
      return Promise.reject();
    }

    return new Promise<Http2Transport>((resolve, reject) => {
      let remoteName: string | null;
      if (proxyConnectionResult.realTarget) {
        remoteName = uriToString(proxyConnectionResult.realTarget);
        this.trace(
          'creating HTTP/2 session through proxy to ' +
            uriToString(proxyConnectionResult.realTarget)
        );
      } else {
        remoteName = null;
        this.trace(
          'creating HTTP/2 session to ' + subchannelAddressToString(address)
        );
      }
      const targetAuthority = getDefaultAuthority(
        proxyConnectionResult.realTarget ?? this.channelTarget
      );
      let connectionOptions: http2.SecureClientSessionOptions =
        credentials._getConnectionOptions() || {};
      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
      if ('grpc-node.max_session_memory' in options) {
        connectionOptions.maxSessionMemory =
          options['grpc-node.max_session_memory'];
      } else {
        /* By default, set a very large max session memory limit, to effectively
         * disable enforcement of the limit. Some testing indicates that Node's
         * behavior degrades badly when this limit is reached, so we solve that
         * by disabling the check entirely. */
        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
      }
      let addressScheme = 'http://';
      if ('secureContext' in connectionOptions) {
        addressScheme = 'https://';
        // If provided, the value of grpc.ssl_target_name_override should be used
        // to override the target hostname when checking server identity.
        // This option is used for testing only.
        if (options['grpc.ssl_target_name_override']) {
          const sslTargetNameOverride =
            options['grpc.ssl_target_name_override']!;
          const originalCheckServerIdentity =
            connectionOptions.checkServerIdentity ?? checkServerIdentity;
          connectionOptions.checkServerIdentity = (
            host: string,
            cert: PeerCertificate
          ): Error | undefined => {
            return originalCheckServerIdentity(sslTargetNameOverride, cert);
          };
          connectionOptions.servername = sslTargetNameOverride;
        } else {
          const authorityHostname =
            splitHostPort(targetAuthority)?.host ?? 'localhost';
          // We want to always set servername to support SNI
          connectionOptions.servername = authorityHostname;
        }
        if (proxyConnectionResult.socket) {
          /* This is part of the workaround for
           * https://github.com/nodejs/node/issues/32922. Without that bug,
           * proxyConnectionResult.socket would always be a plaintext socket and
           * this would say
           * connectionOptions.socket = proxyConnectionResult.socket; */
          connectionOptions.createConnection = (authority, option) => {
            return proxyConnectionResult.socket!;
          };
        }
      } else {
        /* In all but the most recent versions of Node, http2.connect does not use
         * the options when establishing plaintext connections, so we need to
         * establish that connection explicitly. */
        connectionOptions.createConnection = (authority, option) => {
          if (proxyConnectionResult.socket) {
            return proxyConnectionResult.socket;
          } else {
            /* net.NetConnectOpts is declared in a way that is more restrictive
             * than what net.connect will actually accept, so we use the type
             * assertion to work around that. */
            return net.connect(address);
          }
        };
      }

      connectionOptions = {
        ...connectionOptions,
        ...address,
        enableTrace: options['grpc-node.tls_enable_trace'] === 1,
      };

      /* http2.connect uses the options here:
       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
       * The spread operator overides earlier values with later ones, so any port
       * or host values in the options will be used rather than any values extracted
       * from the first argument. In addition, the path overrides the host and port,
       * as documented for plaintext connections here:
       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
       * and for TLS connections here:
       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
       * earlier versions of Node, http2.connect passes these options to
       * tls.connect but not net.connect, so in the insecure case we still need
       * to set the createConnection option above to create the connection
       * explicitly. We cannot do that in the TLS case because http2.connect
       * passes necessary additional options to tls.connect.
       * The first argument just needs to be parseable as a URL and the scheme
       * determines whether the connection will be established over TLS or not.
       */
      const session = http2.connect(
        addressScheme + targetAuthority,
        connectionOptions
      );
      this.session = session;
      let errorMessage = 'Failed to connect';
      session.unref();
      session.once('connect', () => {
        session.removeAllListeners();
        resolve(new Http2Transport(session, address, options, remoteName));
        this.session = null;
      });
      session.once('close', () => {
        this.session = null;
        // Leave time for error event to happen before rejecting
        setImmediate(() => {
          reject(`${errorMessage} (${new Date().toISOString()})`);
        });
      });
      session.once('error', error => {
        errorMessage = (error as Error).message;
        this.trace('connection failed with error ' + errorMessage);
      });
    });
  }

  connect(
    address: SubchannelAddress,
    credentials: ChannelCredentials,
    options: ChannelOptions
  ): Promise<Http2Transport> {
    if (this.isShutdown) {
      return Promise.reject();
    }
    /* Pass connection options through to the proxy so that it's able to
     * upgrade it's connection to support tls if needed.
     * This is a workaround for https://github.com/nodejs/node/issues/32922
     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
    const connectionOptions: ConnectionOptions =
      credentials._getConnectionOptions() || {};

    if ('secureContext' in connectionOptions) {
      connectionOptions.ALPNProtocols = ['h2'];
      // If provided, the value of grpc.ssl_target_name_override should be used
      // to override the target hostname when checking server identity.
      // This option is used for testing only.
      if (options['grpc.ssl_target_name_override']) {
        const sslTargetNameOverride = options['grpc.ssl_target_name_override']!;
        const originalCheckServerIdentity =
          connectionOptions.checkServerIdentity ?? checkServerIdentity;
        connectionOptions.checkServerIdentity = (
          host: string,
          cert: PeerCertificate
        ): Error | undefined => {
          return originalCheckServerIdentity(sslTargetNameOverride, cert);
        };
        connectionOptions.servername = sslTargetNameOverride;
      } else {
        if ('grpc.http_connect_target' in options) {
          /* This is more or less how servername will be set in createSession
           * if a connection is successfully established through the proxy.
           * If the proxy is not used, these connectionOptions are discarded
           * anyway */
          const targetPath = getDefaultAuthority(
            parseUri(options['grpc.http_connect_target'] as string) ?? {
              path: 'localhost',
            }
          );
          const hostPort = splitHostPort(targetPath);
          connectionOptions.servername = hostPort?.host ?? targetPath;
        }
      }
      if (options['grpc-node.tls_enable_trace']) {
        connectionOptions.enableTrace = true;
      }
    }

    return getProxiedConnection(address, options, connectionOptions).then(
      result => this.createSession(address, credentials, options, result)
    );
  }

  shutdown(): void {
    this.isShutdown = true;
    this.session?.close();
    this.session = null;
  }
}
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

export interface GrpcUri {
  scheme?: string;
  authority?: string;
  path: string;
}

/*
 * The groups correspond to URI parts as follows:
 * 1. scheme
 * 2. authority
 * 3. path
 */
const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;

export function parseUri(uriString: string): GrpcUri | null {
  const parsedUri = URI_REGEX.exec(uriString);
  if (parsedUri === null) {
    return null;
  }
  return {
    scheme: parsedUri[1],
    authority: parsedUri[2],
    path: parsedUri[3],
  };
}

export interface HostPort {
  host: string;
  port?: number;
}

const NUMBER_REGEX = /^\d+$/;

export function splitHostPort(path: string): HostPort | null {
  if (path.startsWith('[')) {
    const hostEnd = path.indexOf(']');
    if (hostEnd === -1) {
      return null;
    }
    const host = path.substring(1, hostEnd);
    /* Only an IPv6 address should be in bracketed notation, and an IPv6
     * address should have at least one colon */
    if (host.indexOf(':') === -1) {
      return null;
    }
    if (path.length > hostEnd + 1) {
      if (path[hostEnd + 1] === ':') {
        const portString = path.substring(hostEnd + 2);
        if (NUMBER_REGEX.test(portString)) {
          return {
            host: host,
            port: +portString,
          };
        } else {
          return null;
        }
      } else {
        return null;
      }
    } else {
      return {
        host,
      };
    }
  } else {
    const splitPath = path.split(':');
    /* Exactly one colon means that this is host:port. Zero colons means that
     * there is no port. And multiple colons means that this is a bare IPv6
     * address with no port */
    if (splitPath.length === 2) {
      if (NUMBER_REGEX.test(splitPath[1])) {
        return {
          host: splitPath[0],
          port: +splitPath[1],
        };
      } else {
        return null;
      }
    } else {
      return {
        host: path,
      };
    }
  }
}

export function combineHostPort(hostPort: HostPort): string {
  if (hostPort.port === undefined) {
    return hostPort.host;
  } else {
    // Only an IPv6 host should include a colon
    if (hostPort.host.includes(':')) {
      return `[${hostPort.host}]:${hostPort.port}`;
    } else {
      return `${hostPort.host}:${hostPort.port}`;
    }
  }
}

export function uriToString(uri: GrpcUri): string {
  let result = '';
  if (uri.scheme !== undefined) {
    result += uri.scheme + ':';
  }
  if (uri.authority !== undefined) {
    result += '//' + uri.authority + '/';
  }
  result += uri.path;
  return result;
}
import { ChannelCredentials, Metadata } from '@postman/grpc-js';
import * as services from './reflection_grpc_pb';
import { Root } from '@postman/protobufjs';
export declare class Client {
    metadata: Metadata;
    grpcClient: services.IServerReflectionClient;
    private fileDescriptorCache;
    private reflectionOptions?;
    constructor(url: string, credentials: ChannelCredentials, options?: object, metadata?: Metadata, reflectionOptions?: Client['reflectionOptions']);
    listServices(): Promise<string[]>;
    fileContainingSymbol(symbol: string): Promise<Root>;
    fileByFilename(filename: string): Promise<Root>;
    private resolveFileDescriptorSet;
    private resolveDescriptorRecursive;
    private getFileContainingSymbol;
    private getFilesByFilenames;
}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const grpc_js_1 = require("@postman/grpc-js");
const descriptor_1 = require("./descriptor");
const services = __importStar(require("./reflection_grpc_pb"));
const reflection_pb_1 = require("./reflection_pb");
const descriptor_2 = require("@postman/protobufjs/ext/descriptor");
const lodash_set_1 = __importDefault(require("lodash.set"));
class Client {
    constructor(url, credentials, options, metadata, reflectionOptions) {
        this.fileDescriptorCache = new Map();
        this.fileDescriptorCache = new Map();
        this.metadata = metadata || new grpc_js_1.Metadata();
        this.grpcClient = new services.ServerReflectionClient(url, credentials, options);
        this.reflectionOptions = reflectionOptions;
    }
    listServices() {
        return new Promise((resolve, reject) => {
            function dataCallback(response) {
                var _a;
                if (response.hasListServicesResponse()) {
                    const services = (_a = response
                        .getListServicesResponse()) === null || _a === void 0 ? void 0 : _a.getServiceList().map(svc => {
                        return svc.getName();
                    });
                    resolve(services || []);
                }
                else {
                    reject(Error());
                }
            }
            function errorCallback(e) {
                reject(e);
            }
            const request = new reflection_pb_1.ServerReflectionRequest();
            request.setListServices('*');
            const grpcCall = this.grpcClient.serverReflectionInfo(this.metadata);
            grpcCall.on('data', dataCallback);
            grpcCall.on('error', errorCallback);
            grpcCall.write(request);
            grpcCall.end();
        });
    }
    fileContainingSymbol(symbol) {
        return new Promise((resolve, reject) => {
            this.getFileContainingSymbol(symbol)
                .then(val => resolve(this.resolveFileDescriptorSet(val)))
                .catch(err => reject(err));
        });
    }
    fileByFilename(filename) {
        return new Promise((resolve, reject) => {
            this.getFilesByFilenames([filename])
                .then(val => resolve(this.resolveFileDescriptorSet(val)))
                .catch(err => reject(err));
        });
    }
    async resolveFileDescriptorSet(fileDescriptorProtos) {
        var _a;
        const fileDescriptorMap = await this.resolveDescriptorRecursive(fileDescriptorProtos);
        const fileDescriptorSet = descriptor_2.FileDescriptorSet.create();
        lodash_set_1.default(fileDescriptorSet, 'file', Array.from(fileDescriptorMap.values()));
        return descriptor_1.getDescriptorRootFromDescriptorSet(fileDescriptorSet, (_a = this.reflectionOptions) === null || _a === void 0 ? void 0 : _a.useExperimentalMapFieldDecoding);
    }
    async resolveDescriptorRecursive(fileDescriptorProtos = [], fileDescriptorMap = new Map()) {
        await Promise.all(fileDescriptorProtos.map(async (fileDescriptorProto) => {
            if (fileDescriptorMap.has(fileDescriptorProto.name)) {
                return;
            }
            else {
                fileDescriptorMap.set(fileDescriptorProto.name, fileDescriptorProto);
            }
            const dependencies = (fileDescriptorProto.dependency || []).filter((dependency) => !fileDescriptorMap.has(dependency));
            if (dependencies.length) {
                await this.resolveDescriptorRecursive(await this.getFilesByFilenames(dependencies), fileDescriptorMap);
            }
        }));
        return fileDescriptorMap;
    }
    getFileContainingSymbol(symbol) {
        const fileDescriptorCache = this.fileDescriptorCache;
        return new Promise((resolve, reject) => {
            function dataCallback(response) {
                var _a;
                if (response.hasFileDescriptorResponse()) {
                    const fileDescriptorProtoBytes = (((_a = response
                        .getFileDescriptorResponse()) === null || _a === void 0 ? void 0 : _a.getFileDescriptorProtoList()) || []);
                    resolve(fileDescriptorProtoBytes.map(descriptorByte => {
                        const fileDescriptorProto = descriptor_2.FileDescriptorProto.decode(descriptorByte);
                        fileDescriptorCache.set(fileDescriptorProto.name, fileDescriptorProto);
                        return fileDescriptorProto;
                    }));
                }
                else {
                    reject(Error());
                }
            }
            function errorCallback(e) {
                reject(e);
            }
            const request = new reflection_pb_1.ServerReflectionRequest();
            request.setFileContainingSymbol(symbol);
            const grpcCall = this.grpcClient.serverReflectionInfo(this.metadata);
            grpcCall.on('data', dataCallback);
            grpcCall.on('error', errorCallback);
            grpcCall.write(request);
            grpcCall.end();
        });
    }
    getFilesByFilenames(symbols) {
        const result = [];
        const fileDescriptorCache = this.fileDescriptorCache;
        const symbolsToFetch = symbols.filter(symbol => {
            const cached = fileDescriptorCache.get(symbol);
            if (cached) {
                result.push(cached);
                return false;
            }
            return true;
        });
        if (symbolsToFetch.length === 0) {
            return Promise.resolve(result);
        }
        return new Promise((resolve, reject) => {
            function dataCallback(response) {
                var _a, _b;
                if (response.hasFileDescriptorResponse()) {
                    (_b = (_a = response
                        .getFileDescriptorResponse()) === null || _a === void 0 ? void 0 : _a.getFileDescriptorProtoList()) === null || _b === void 0 ? void 0 : _b.forEach(descriptorByte => {
                        if (descriptorByte instanceof Uint8Array) {
                            const fileDescriptorProto = descriptor_2.FileDescriptorProto.decode(descriptorByte);
                            fileDescriptorCache.set(fileDescriptorProto.name, fileDescriptorProto);
                            result.push(fileDescriptorProto);
                        }
                    });
                }
                else {
                    reject(Error());
                }
            }
            function errorCallback(e) {
                reject(e);
            }
            const grpcCall = this.grpcClient.serverReflectionInfo(this.metadata);
            grpcCall.on('data', dataCallback);
            grpcCall.on('error', errorCallback);
            grpcCall.on('end', () => {
                resolve(result);
            });
            symbolsToFetch.forEach(symbol => {
                const request = new reflection_pb_1.ServerReflectionRequest();
                grpcCall.write(request.setFileByFilename(symbol));
            });
            grpcCall.end();
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/client.ts"],"names":[],"mappings":"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"}/**
 * @typedef {import('@postman/protobufjs').Root} Root
 * @typedef {import('@postman/protobufjs').Message} Message
 */
/**
 * Get Protobuf.js Root object from the serialized FileDescriptorProto messages
 * that gotten from reflection service.
 * @param {Array<Uint8Array|string>|undefined} file_descriptor_protos - Reflection descriptor protos
 * @param {boolean} [useMapField=false] - Use experimental map field decoding support of protobufjs
 * @return {Root} Protobuf.js Root object
 */
export function getDescriptorRoot(file_descriptor_protos: Array<Uint8Array | string> | undefined, useMapField?: boolean | undefined): Root;
/**
 * Get Protobuf.js Root object from FileDescriptorSet
 * @param {Message file_descriptor_set - File descriptor set
 * @param {boolean} [useMapField=false] - Use experimental map field decoding support of protobufjs
 * @return {Root} Protobuf.js Root object
 */
export function getDescriptorRootFromDescriptorSet(file_descriptor_set: Message, useMapField?: boolean | undefined): Root;
export type Root = import("@postman/protobufjs").Root;
export type Message = import("@postman/protobufjs").Message<object>;
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDescriptorRootFromDescriptorSet = exports.getDescriptorRoot = void 0;
const protobuf = require('@postman/protobufjs');
const Descriptor = require('@postman/protobufjs/ext/descriptor');
const set = require('lodash.set');
/**
 * @typedef {import('@postman/protobufjs').Root} Root
 * @typedef {import('@postman/protobufjs').Message} Message
 */
/**
 * Get Protobuf.js Root object from the serialized FileDescriptorProto messages
 * that gotten from reflection service.
 * @param {Array<Uint8Array|string>|undefined} file_descriptor_protos - Reflection descriptor protos
 * @param {boolean} [useMapField=false] - Use experimental map field decoding support of protobufjs
 * @return {Root} Protobuf.js Root object
 */
// eslint-disable-next-line node/no-unsupported-features/es-syntax
function getDescriptorRoot(file_descriptor_protos, useMapField = false) {
    const descriptorSet = Descriptor.FileDescriptorSet.create();
    file_descriptor_protos.forEach((descriptorByte, i) => {
        const descriptor = Descriptor.FileDescriptorProto.decode(descriptorByte);
        set(descriptorSet, 'file[' + i + ']', descriptor);
    });
    return protobuf.Root.fromDescriptor(descriptorSet, { useMapField });
}
exports.getDescriptorRoot = getDescriptorRoot;
/**
 * Get Protobuf.js Root object from FileDescriptorSet
 * @param {Message file_descriptor_set - File descriptor set
 * @param {boolean} [useMapField=false] - Use experimental map field decoding support of protobufjs
 * @return {Root} Protobuf.js Root object
 */
// eslint-disable-next-line node/no-unsupported-features/es-syntax
function getDescriptorRootFromDescriptorSet(file_descriptor_set, useMapField = false) {
    return protobuf.Root.fromDescriptor(file_descriptor_set, { useMapField });
}
exports.getDescriptorRootFromDescriptorSet = getDescriptorRootFromDescriptorSet;
//# sourceMappingURL=descriptor.js.map{"version":3,"file":"descriptor.js","sourceRoot":"","sources":["../../src/descriptor.js"],"names":[],"mappings":";;;AAAA,MAAM,QAAQ,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAChD,MAAM,UAAU,GAAG,OAAO,CAAC,oCAAoC,CAAC,CAAC;AACjE,MAAM,GAAG,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AAElC;;;GAGG;AAEH;;;;;;GAMG;AACH,kEAAkE;AAClE,SAAgB,iBAAiB,CAAC,sBAAsB,EAAE,WAAW,GAAG,KAAK;IAC3E,MAAM,aAAa,GAAG,UAAU,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC;IAE5D,sBAAsB,CAAC,OAAO,CAAC,CAAC,cAAc,EAAE,CAAC,EAAE,EAAE;QACnD,MAAM,UAAU,GAAG,UAAU,CAAC,mBAAmB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;QACzE,GAAG,CAAC,aAAa,EAAE,OAAO,GAAG,CAAC,GAAG,GAAG,EAAE,UAAU,CAAC,CAAC;IACpD,CAAC,CAAC,CAAC;IACH,OAAO,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE,EAAC,WAAW,EAAC,CAAC,CAAC;AACpE,CAAC;AARD,8CAQC;AAED;;;;;GAKG;AACH,kEAAkE;AAClE,SAAgB,kCAAkC,CAChD,mBAAmB,EACnB,WAAW,GAAG,KAAK;IAEnB,OAAO,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,EAAC,WAAW,EAAC,CAAC,CAAC;AAC1E,CAAC;AALD,gFAKC"}export { Client } from './client';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var client_1 = require("./client");
Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;AAAA,mCAAgC;AAAxB,gGAAA,MAAM,OAAA"}export namespace ServerReflectionService {
    export namespace serverReflectionInfo {
        export const path: string;
        export const requestStream: boolean;
        export const responseStream: boolean;
        export const requestType: typeof import("./reflection_pb.js").ServerReflectionRequest;
        export const responseType: typeof import("./reflection_pb.js").ServerReflectionResponse;
        export { serialize_grpc_reflection_v1alpha_ServerReflectionRequest as requestSerialize };
        export { deserialize_grpc_reflection_v1alpha_ServerReflectionRequest as requestDeserialize };
        export { serialize_grpc_reflection_v1alpha_ServerReflectionResponse as responseSerialize };
        export { deserialize_grpc_reflection_v1alpha_ServerReflectionResponse as responseDeserialize };
    }
}
export var ServerReflectionClient: import("@postman/grpc-js").ServiceClientConstructor;
declare function serialize_grpc_reflection_v1alpha_ServerReflectionRequest(arg: any): Buffer;
declare function deserialize_grpc_reflection_v1alpha_ServerReflectionRequest(buffer_arg: any): import("./reflection_pb.js").ServerReflectionRequest;
declare function serialize_grpc_reflection_v1alpha_ServerReflectionResponse(arg: any): Buffer;
declare function deserialize_grpc_reflection_v1alpha_ServerReflectionResponse(buffer_arg: any): import("./reflection_pb.js").ServerReflectionResponse;
export {};
// GENERATED CODE -- DO NOT EDIT!
// Original file comments:
// Copyright 2016 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Service exported by server reflection
//
'use strict';
var grpc = require('@postman/grpc-js');
var reflection_pb = require('./reflection_pb.js');
function serialize_grpc_reflection_v1alpha_ServerReflectionRequest(arg) {
    if (!(arg instanceof reflection_pb.ServerReflectionRequest)) {
        throw new Error('Expected argument of type grpc.reflection.v1alpha.ServerReflectionRequest');
    }
    return Buffer.from(arg.serializeBinary());
}
function deserialize_grpc_reflection_v1alpha_ServerReflectionRequest(buffer_arg) {
    return reflection_pb.ServerReflectionRequest.deserializeBinary(new Uint8Array(buffer_arg));
}
function serialize_grpc_reflection_v1alpha_ServerReflectionResponse(arg) {
    if (!(arg instanceof reflection_pb.ServerReflectionResponse)) {
        throw new Error('Expected argument of type grpc.reflection.v1alpha.ServerReflectionResponse');
    }
    return Buffer.from(arg.serializeBinary());
}
function deserialize_grpc_reflection_v1alpha_ServerReflectionResponse(buffer_arg) {
    return reflection_pb.ServerReflectionResponse.deserializeBinary(new Uint8Array(buffer_arg));
}
var ServerReflectionService = exports.ServerReflectionService = {
    // The reflection service is structured as a bidirectional stream, ensuring
    // all related requests go to a single server.
    serverReflectionInfo: {
        path: '/grpc.reflection.v1alpha.ServerReflection/ServerReflectionInfo',
        requestStream: true,
        responseStream: true,
        requestType: reflection_pb.ServerReflectionRequest,
        responseType: reflection_pb.ServerReflectionResponse,
        requestSerialize: serialize_grpc_reflection_v1alpha_ServerReflectionRequest,
        requestDeserialize: deserialize_grpc_reflection_v1alpha_ServerReflectionRequest,
        responseSerialize: serialize_grpc_reflection_v1alpha_ServerReflectionResponse,
        responseDeserialize: deserialize_grpc_reflection_v1alpha_ServerReflectionResponse,
    },
};
exports.ServerReflectionClient = grpc.makeGenericClientConstructor(ServerReflectionService);
//# sourceMappingURL=reflection_grpc_pb.js.map{"version":3,"file":"reflection_grpc_pb.js","sourceRoot":"","sources":["../../src/reflection_grpc_pb.js"],"names":[],"mappings":"AAAA,iCAAiC;AAEjC,0BAA0B;AAC1B,+BAA+B;AAC/B,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,iDAAiD;AACjD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AACjC,EAAE;AACF,wCAAwC;AACxC,EAAE;AACF,YAAY,CAAC;AACb,IAAI,IAAI,GAAG,OAAO,CAAC,kBAAkB,CAAC,CAAC;AACvC,IAAI,aAAa,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAElD,SAAS,yDAAyD,CAAC,GAAG;IACpE,IAAI,CAAC,CAAC,GAAG,YAAY,aAAa,CAAC,uBAAuB,CAAC,EAAE;QAC3D,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;KAC9F;IACD,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;AAC5C,CAAC;AAED,SAAS,2DAA2D,CAAC,UAAU;IAC7E,OAAO,aAAa,CAAC,uBAAuB,CAAC,iBAAiB,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;AAC7F,CAAC;AAED,SAAS,0DAA0D,CAAC,GAAG;IACrE,IAAI,CAAC,CAAC,GAAG,YAAY,aAAa,CAAC,wBAAwB,CAAC,EAAE;QAC5D,MAAM,IAAI,KAAK,CAAC,4EAA4E,CAAC,CAAC;KAC/F;IACD,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;AAC5C,CAAC;AAED,SAAS,4DAA4D,CAAC,UAAU;IAC9E,OAAO,aAAa,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;AAC9F,CAAC;AAGD,IAAI,uBAAuB,GAAG,OAAO,CAAC,uBAAuB,GAAG;IAC9D,2EAA2E;IAC7E,8CAA8C;IAC9C,oBAAoB,EAAE;QAClB,IAAI,EAAE,gEAAgE;QACtE,aAAa,EAAE,IAAI;QACnB,cAAc,EAAE,IAAI;QACpB,WAAW,EAAE,aAAa,CAAC,uBAAuB;QAClD,YAAY,EAAE,aAAa,CAAC,wBAAwB;QACpD,gBAAgB,EAAE,yDAAyD;QAC3E,kBAAkB,EAAE,2DAA2D;QAC/E,iBAAiB,EAAE,0DAA0D;QAC7E,mBAAmB,EAAE,4DAA4D;KAClF;CACF,CAAC;AAEF,OAAO,CAAC,sBAAsB,GAAG,IAAI,CAAC,4BAA4B,CAAC,uBAAuB,CAAC,CAAC"}export {};
"use strict";
// source: reflection.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();
goog.exportSymbol('proto.grpc.reflection.v1alpha.ErrorResponse', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ExtensionNumberResponse', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ExtensionRequest', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.FileDescriptorResponse', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ListServiceResponse', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ServerReflectionRequest', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ServerReflectionRequest.MessageRequestCase', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ServerReflectionResponse', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ServerReflectionResponse.MessageResponseCase', null, global);
goog.exportSymbol('proto.grpc.reflection.v1alpha.ServiceResponse', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_);
};
goog.inherits(proto.grpc.reflection.v1alpha.ServerReflectionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ServerReflectionRequest.displayName = 'proto.grpc.reflection.v1alpha.ServerReflectionRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ExtensionRequest = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.grpc.reflection.v1alpha.ExtensionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ExtensionRequest.displayName = 'proto.grpc.reflection.v1alpha.ExtensionRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_);
};
goog.inherits(proto.grpc.reflection.v1alpha.ServerReflectionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ServerReflectionResponse.displayName = 'proto.grpc.reflection.v1alpha.ServerReflectionResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, proto.grpc.reflection.v1alpha.FileDescriptorResponse.repeatedFields_, null);
};
goog.inherits(proto.grpc.reflection.v1alpha.FileDescriptorResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.FileDescriptorResponse.displayName = 'proto.grpc.reflection.v1alpha.FileDescriptorResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, proto.grpc.reflection.v1alpha.ExtensionNumberResponse.repeatedFields_, null);
};
goog.inherits(proto.grpc.reflection.v1alpha.ExtensionNumberResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ExtensionNumberResponse.displayName = 'proto.grpc.reflection.v1alpha.ExtensionNumberResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ListServiceResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, proto.grpc.reflection.v1alpha.ListServiceResponse.repeatedFields_, null);
};
goog.inherits(proto.grpc.reflection.v1alpha.ListServiceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ListServiceResponse.displayName = 'proto.grpc.reflection.v1alpha.ListServiceResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ServiceResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.grpc.reflection.v1alpha.ServiceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ServiceResponse.displayName = 'proto.grpc.reflection.v1alpha.ServiceResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.grpc.reflection.v1alpha.ErrorResponse = function (opt_data) {
    jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.grpc.reflection.v1alpha.ErrorResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
    /**
     * @public
     * @override
     */
    proto.grpc.reflection.v1alpha.ErrorResponse.displayName = 'proto.grpc.reflection.v1alpha.ErrorResponse';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_ = [[3, 4, 5, 6, 7]];
/**
 * @enum {number}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.MessageRequestCase = {
    MESSAGE_REQUEST_NOT_SET: 0,
    FILE_BY_FILENAME: 3,
    FILE_CONTAINING_SYMBOL: 4,
    FILE_CONTAINING_EXTENSION: 5,
    ALL_EXTENSION_NUMBERS_OF_TYPE: 6,
    LIST_SERVICES: 7
};
/**
 * @return {proto.grpc.reflection.v1alpha.ServerReflectionRequest.MessageRequestCase}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getMessageRequestCase = function () {
    return /** @type {proto.grpc.reflection.v1alpha.ServerReflectionRequest.MessageRequestCase} */ (jspb.Message.computeOneofCase(this, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0]));
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ServerReflectionRequest.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ServerReflectionRequest.toObject = function (includeInstance, msg) {
        var f, obj = {
            host: jspb.Message.getFieldWithDefault(msg, 1, ""),
            fileByFilename: jspb.Message.getFieldWithDefault(msg, 3, ""),
            fileContainingSymbol: jspb.Message.getFieldWithDefault(msg, 4, ""),
            fileContainingExtension: (f = msg.getFileContainingExtension()) && proto.grpc.reflection.v1alpha.ExtensionRequest.toObject(includeInstance, f),
            allExtensionNumbersOfType: jspb.Message.getFieldWithDefault(msg, 6, ""),
            listServices: jspb.Message.getFieldWithDefault(msg, 7, "")
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ServerReflectionRequest;
    return proto.grpc.reflection.v1alpha.ServerReflectionRequest.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {string} */ (reader.readString());
                msg.setHost(value);
                break;
            case 3:
                var value = /** @type {string} */ (reader.readString());
                msg.setFileByFilename(value);
                break;
            case 4:
                var value = /** @type {string} */ (reader.readString());
                msg.setFileContainingSymbol(value);
                break;
            case 5:
                var value = new proto.grpc.reflection.v1alpha.ExtensionRequest;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.ExtensionRequest.deserializeBinaryFromReader);
                msg.setFileContainingExtension(value);
                break;
            case 6:
                var value = /** @type {string} */ (reader.readString());
                msg.setAllExtensionNumbersOfType(value);
                break;
            case 7:
                var value = /** @type {string} */ (reader.readString());
                msg.setListServices(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ServerReflectionRequest.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getHost();
    if (f.length > 0) {
        writer.writeString(1, f);
    }
    f = /** @type {string} */ (jspb.Message.getField(message, 3));
    if (f != null) {
        writer.writeString(3, f);
    }
    f = /** @type {string} */ (jspb.Message.getField(message, 4));
    if (f != null) {
        writer.writeString(4, f);
    }
    f = message.getFileContainingExtension();
    if (f != null) {
        writer.writeMessage(5, f, proto.grpc.reflection.v1alpha.ExtensionRequest.serializeBinaryToWriter);
    }
    f = /** @type {string} */ (jspb.Message.getField(message, 6));
    if (f != null) {
        writer.writeString(6, f);
    }
    f = /** @type {string} */ (jspb.Message.getField(message, 7));
    if (f != null) {
        writer.writeString(7, f);
    }
};
/**
 * optional string host = 1;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getHost = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.setHost = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional string file_by_filename = 3;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getFileByFilename = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.setFileByFilename = function (value) {
    return jspb.Message.setOneofField(this, 3, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.clearFileByFilename = function () {
    return jspb.Message.setOneofField(this, 3, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.hasFileByFilename = function () {
    return jspb.Message.getField(this, 3) != null;
};
/**
 * optional string file_containing_symbol = 4;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getFileContainingSymbol = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.setFileContainingSymbol = function (value) {
    return jspb.Message.setOneofField(this, 4, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.clearFileContainingSymbol = function () {
    return jspb.Message.setOneofField(this, 4, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.hasFileContainingSymbol = function () {
    return jspb.Message.getField(this, 4) != null;
};
/**
 * optional ExtensionRequest file_containing_extension = 5;
 * @return {?proto.grpc.reflection.v1alpha.ExtensionRequest}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getFileContainingExtension = function () {
    return /** @type{?proto.grpc.reflection.v1alpha.ExtensionRequest} */ (jspb.Message.getWrapperField(this, proto.grpc.reflection.v1alpha.ExtensionRequest, 5));
};
/**
 * @param {?proto.grpc.reflection.v1alpha.ExtensionRequest|undefined} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
*/
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.setFileContainingExtension = function (value) {
    return jspb.Message.setOneofWrapperField(this, 5, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.clearFileContainingExtension = function () {
    return this.setFileContainingExtension(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.hasFileContainingExtension = function () {
    return jspb.Message.getField(this, 5) != null;
};
/**
 * optional string all_extension_numbers_of_type = 6;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getAllExtensionNumbersOfType = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.setAllExtensionNumbersOfType = function (value) {
    return jspb.Message.setOneofField(this, 6, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.clearAllExtensionNumbersOfType = function () {
    return jspb.Message.setOneofField(this, 6, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.hasAllExtensionNumbersOfType = function () {
    return jspb.Message.getField(this, 6) != null;
};
/**
 * optional string list_services = 7;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.getListServices = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.setListServices = function (value) {
    return jspb.Message.setOneofField(this, 7, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], value);
};
/**
 * Clears the field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.clearListServices = function () {
    return jspb.Message.setOneofField(this, 7, proto.grpc.reflection.v1alpha.ServerReflectionRequest.oneofGroups_[0], undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionRequest.prototype.hasListServices = function () {
    return jspb.Message.getField(this, 7) != null;
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ExtensionRequest.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ExtensionRequest.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ExtensionRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ExtensionRequest.toObject = function (includeInstance, msg) {
        var f, obj = {
            containingType: jspb.Message.getFieldWithDefault(msg, 1, ""),
            extensionNumber: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ExtensionRequest}
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ExtensionRequest;
    return proto.grpc.reflection.v1alpha.ExtensionRequest.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ExtensionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ExtensionRequest}
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {string} */ (reader.readString());
                msg.setContainingType(value);
                break;
            case 2:
                var value = /** @type {number} */ (reader.readInt32());
                msg.setExtensionNumber(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ExtensionRequest.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ExtensionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getContainingType();
    if (f.length > 0) {
        writer.writeString(1, f);
    }
    f = message.getExtensionNumber();
    if (f !== 0) {
        writer.writeInt32(2, f);
    }
};
/**
 * optional string containing_type = 1;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.prototype.getContainingType = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ExtensionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.prototype.setContainingType = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional int32 extension_number = 2;
 * @return {number}
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.prototype.getExtensionNumber = function () {
    return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};
/**
 * @param {number} value
 * @return {!proto.grpc.reflection.v1alpha.ExtensionRequest} returns this
 */
proto.grpc.reflection.v1alpha.ExtensionRequest.prototype.setExtensionNumber = function (value) {
    return jspb.Message.setProto3IntField(this, 2, value);
};
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_ = [[4, 5, 6, 7]];
/**
 * @enum {number}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.MessageResponseCase = {
    MESSAGE_RESPONSE_NOT_SET: 0,
    FILE_DESCRIPTOR_RESPONSE: 4,
    ALL_EXTENSION_NUMBERS_RESPONSE: 5,
    LIST_SERVICES_RESPONSE: 6,
    ERROR_RESPONSE: 7
};
/**
 * @return {proto.grpc.reflection.v1alpha.ServerReflectionResponse.MessageResponseCase}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getMessageResponseCase = function () {
    return /** @type {proto.grpc.reflection.v1alpha.ServerReflectionResponse.MessageResponseCase} */ (jspb.Message.computeOneofCase(this, proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_[0]));
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ServerReflectionResponse.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ServerReflectionResponse.toObject = function (includeInstance, msg) {
        var f, obj = {
            validHost: jspb.Message.getFieldWithDefault(msg, 1, ""),
            originalRequest: (f = msg.getOriginalRequest()) && proto.grpc.reflection.v1alpha.ServerReflectionRequest.toObject(includeInstance, f),
            fileDescriptorResponse: (f = msg.getFileDescriptorResponse()) && proto.grpc.reflection.v1alpha.FileDescriptorResponse.toObject(includeInstance, f),
            allExtensionNumbersResponse: (f = msg.getAllExtensionNumbersResponse()) && proto.grpc.reflection.v1alpha.ExtensionNumberResponse.toObject(includeInstance, f),
            listServicesResponse: (f = msg.getListServicesResponse()) && proto.grpc.reflection.v1alpha.ListServiceResponse.toObject(includeInstance, f),
            errorResponse: (f = msg.getErrorResponse()) && proto.grpc.reflection.v1alpha.ErrorResponse.toObject(includeInstance, f)
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ServerReflectionResponse;
    return proto.grpc.reflection.v1alpha.ServerReflectionResponse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {string} */ (reader.readString());
                msg.setValidHost(value);
                break;
            case 2:
                var value = new proto.grpc.reflection.v1alpha.ServerReflectionRequest;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.ServerReflectionRequest.deserializeBinaryFromReader);
                msg.setOriginalRequest(value);
                break;
            case 4:
                var value = new proto.grpc.reflection.v1alpha.FileDescriptorResponse;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.FileDescriptorResponse.deserializeBinaryFromReader);
                msg.setFileDescriptorResponse(value);
                break;
            case 5:
                var value = new proto.grpc.reflection.v1alpha.ExtensionNumberResponse;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.ExtensionNumberResponse.deserializeBinaryFromReader);
                msg.setAllExtensionNumbersResponse(value);
                break;
            case 6:
                var value = new proto.grpc.reflection.v1alpha.ListServiceResponse;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.ListServiceResponse.deserializeBinaryFromReader);
                msg.setListServicesResponse(value);
                break;
            case 7:
                var value = new proto.grpc.reflection.v1alpha.ErrorResponse;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.ErrorResponse.deserializeBinaryFromReader);
                msg.setErrorResponse(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ServerReflectionResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getValidHost();
    if (f.length > 0) {
        writer.writeString(1, f);
    }
    f = message.getOriginalRequest();
    if (f != null) {
        writer.writeMessage(2, f, proto.grpc.reflection.v1alpha.ServerReflectionRequest.serializeBinaryToWriter);
    }
    f = message.getFileDescriptorResponse();
    if (f != null) {
        writer.writeMessage(4, f, proto.grpc.reflection.v1alpha.FileDescriptorResponse.serializeBinaryToWriter);
    }
    f = message.getAllExtensionNumbersResponse();
    if (f != null) {
        writer.writeMessage(5, f, proto.grpc.reflection.v1alpha.ExtensionNumberResponse.serializeBinaryToWriter);
    }
    f = message.getListServicesResponse();
    if (f != null) {
        writer.writeMessage(6, f, proto.grpc.reflection.v1alpha.ListServiceResponse.serializeBinaryToWriter);
    }
    f = message.getErrorResponse();
    if (f != null) {
        writer.writeMessage(7, f, proto.grpc.reflection.v1alpha.ErrorResponse.serializeBinaryToWriter);
    }
};
/**
 * optional string valid_host = 1;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getValidHost = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.setValidHost = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * optional ServerReflectionRequest original_request = 2;
 * @return {?proto.grpc.reflection.v1alpha.ServerReflectionRequest}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getOriginalRequest = function () {
    return /** @type{?proto.grpc.reflection.v1alpha.ServerReflectionRequest} */ (jspb.Message.getWrapperField(this, proto.grpc.reflection.v1alpha.ServerReflectionRequest, 2));
};
/**
 * @param {?proto.grpc.reflection.v1alpha.ServerReflectionRequest|undefined} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
*/
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.setOriginalRequest = function (value) {
    return jspb.Message.setWrapperField(this, 2, value);
};
/**
 * Clears the message field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.clearOriginalRequest = function () {
    return this.setOriginalRequest(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.hasOriginalRequest = function () {
    return jspb.Message.getField(this, 2) != null;
};
/**
 * optional FileDescriptorResponse file_descriptor_response = 4;
 * @return {?proto.grpc.reflection.v1alpha.FileDescriptorResponse}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getFileDescriptorResponse = function () {
    return /** @type{?proto.grpc.reflection.v1alpha.FileDescriptorResponse} */ (jspb.Message.getWrapperField(this, proto.grpc.reflection.v1alpha.FileDescriptorResponse, 4));
};
/**
 * @param {?proto.grpc.reflection.v1alpha.FileDescriptorResponse|undefined} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
*/
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.setFileDescriptorResponse = function (value) {
    return jspb.Message.setOneofWrapperField(this, 4, proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.clearFileDescriptorResponse = function () {
    return this.setFileDescriptorResponse(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.hasFileDescriptorResponse = function () {
    return jspb.Message.getField(this, 4) != null;
};
/**
 * optional ExtensionNumberResponse all_extension_numbers_response = 5;
 * @return {?proto.grpc.reflection.v1alpha.ExtensionNumberResponse}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getAllExtensionNumbersResponse = function () {
    return /** @type{?proto.grpc.reflection.v1alpha.ExtensionNumberResponse} */ (jspb.Message.getWrapperField(this, proto.grpc.reflection.v1alpha.ExtensionNumberResponse, 5));
};
/**
 * @param {?proto.grpc.reflection.v1alpha.ExtensionNumberResponse|undefined} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
*/
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.setAllExtensionNumbersResponse = function (value) {
    return jspb.Message.setOneofWrapperField(this, 5, proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.clearAllExtensionNumbersResponse = function () {
    return this.setAllExtensionNumbersResponse(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.hasAllExtensionNumbersResponse = function () {
    return jspb.Message.getField(this, 5) != null;
};
/**
 * optional ListServiceResponse list_services_response = 6;
 * @return {?proto.grpc.reflection.v1alpha.ListServiceResponse}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getListServicesResponse = function () {
    return /** @type{?proto.grpc.reflection.v1alpha.ListServiceResponse} */ (jspb.Message.getWrapperField(this, proto.grpc.reflection.v1alpha.ListServiceResponse, 6));
};
/**
 * @param {?proto.grpc.reflection.v1alpha.ListServiceResponse|undefined} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
*/
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.setListServicesResponse = function (value) {
    return jspb.Message.setOneofWrapperField(this, 6, proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.clearListServicesResponse = function () {
    return this.setListServicesResponse(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.hasListServicesResponse = function () {
    return jspb.Message.getField(this, 6) != null;
};
/**
 * optional ErrorResponse error_response = 7;
 * @return {?proto.grpc.reflection.v1alpha.ErrorResponse}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.getErrorResponse = function () {
    return /** @type{?proto.grpc.reflection.v1alpha.ErrorResponse} */ (jspb.Message.getWrapperField(this, proto.grpc.reflection.v1alpha.ErrorResponse, 7));
};
/**
 * @param {?proto.grpc.reflection.v1alpha.ErrorResponse|undefined} value
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
*/
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.setErrorResponse = function (value) {
    return jspb.Message.setOneofWrapperField(this, 7, proto.grpc.reflection.v1alpha.ServerReflectionResponse.oneofGroups_[0], value);
};
/**
 * Clears the message field making it undefined.
 * @return {!proto.grpc.reflection.v1alpha.ServerReflectionResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.clearErrorResponse = function () {
    return this.setErrorResponse(undefined);
};
/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.grpc.reflection.v1alpha.ServerReflectionResponse.prototype.hasErrorResponse = function () {
    return jspb.Message.getField(this, 7) != null;
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.repeatedFields_ = [1];
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.FileDescriptorResponse.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.FileDescriptorResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.FileDescriptorResponse.toObject = function (includeInstance, msg) {
        var f, obj = {
            fileDescriptorProtoList: msg.getFileDescriptorProtoList_asB64()
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.FileDescriptorResponse}
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.FileDescriptorResponse;
    return proto.grpc.reflection.v1alpha.FileDescriptorResponse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.FileDescriptorResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.FileDescriptorResponse}
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {!Uint8Array} */ (reader.readBytes());
                msg.addFileDescriptorProto(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.FileDescriptorResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.FileDescriptorResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getFileDescriptorProtoList_asU8();
    if (f.length > 0) {
        writer.writeRepeatedBytes(1, f);
    }
};
/**
 * repeated bytes file_descriptor_proto = 1;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.getFileDescriptorProtoList = function () {
    return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 1));
};
/**
 * repeated bytes file_descriptor_proto = 1;
 * This is a type-conversion wrapper around `getFileDescriptorProtoList()`
 * @return {!Array<string>}
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.getFileDescriptorProtoList_asB64 = function () {
    return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(this.getFileDescriptorProtoList()));
};
/**
 * repeated bytes file_descriptor_proto = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFileDescriptorProtoList()`
 * @return {!Array<!Uint8Array>}
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.getFileDescriptorProtoList_asU8 = function () {
    return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(this.getFileDescriptorProtoList()));
};
/**
 * @param {!(Array<!Uint8Array>|Array<string>)} value
 * @return {!proto.grpc.reflection.v1alpha.FileDescriptorResponse} returns this
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.setFileDescriptorProtoList = function (value) {
    return jspb.Message.setField(this, 1, value || []);
};
/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 * @return {!proto.grpc.reflection.v1alpha.FileDescriptorResponse} returns this
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.addFileDescriptorProto = function (value, opt_index) {
    return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 * @return {!proto.grpc.reflection.v1alpha.FileDescriptorResponse} returns this
 */
proto.grpc.reflection.v1alpha.FileDescriptorResponse.prototype.clearFileDescriptorProtoList = function () {
    return this.setFileDescriptorProtoList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.repeatedFields_ = [2];
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ExtensionNumberResponse.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ExtensionNumberResponse.toObject = function (includeInstance, msg) {
        var f, obj = {
            baseTypeName: jspb.Message.getFieldWithDefault(msg, 1, ""),
            extensionNumberList: (f = jspb.Message.getRepeatedField(msg, 2)) == null ? undefined : f
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse}
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ExtensionNumberResponse;
    return proto.grpc.reflection.v1alpha.ExtensionNumberResponse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse}
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {string} */ (reader.readString());
                msg.setBaseTypeName(value);
                break;
            case 2:
                var value = /** @type {!Array<number>} */ (reader.readPackedInt32());
                msg.setExtensionNumberList(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ExtensionNumberResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getBaseTypeName();
    if (f.length > 0) {
        writer.writeString(1, f);
    }
    f = message.getExtensionNumberList();
    if (f.length > 0) {
        writer.writePackedInt32(2, f);
    }
};
/**
 * optional string base_type_name = 1;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.getBaseTypeName = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} returns this
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.setBaseTypeName = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
/**
 * repeated int32 extension_number = 2;
 * @return {!Array<number>}
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.getExtensionNumberList = function () {
    return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 2));
};
/**
 * @param {!Array<number>} value
 * @return {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} returns this
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.setExtensionNumberList = function (value) {
    return jspb.Message.setField(this, 2, value || []);
};
/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} returns this
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.addExtensionNumber = function (value, opt_index) {
    return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 * @return {!proto.grpc.reflection.v1alpha.ExtensionNumberResponse} returns this
 */
proto.grpc.reflection.v1alpha.ExtensionNumberResponse.prototype.clearExtensionNumberList = function () {
    return this.setExtensionNumberList([]);
};
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.repeatedFields_ = [1];
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ListServiceResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ListServiceResponse.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ListServiceResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ListServiceResponse.toObject = function (includeInstance, msg) {
        var f, obj = {
            serviceList: jspb.Message.toObjectList(msg.getServiceList(), proto.grpc.reflection.v1alpha.ServiceResponse.toObject, includeInstance)
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ListServiceResponse}
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ListServiceResponse;
    return proto.grpc.reflection.v1alpha.ListServiceResponse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ListServiceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ListServiceResponse}
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = new proto.grpc.reflection.v1alpha.ServiceResponse;
                reader.readMessage(value, proto.grpc.reflection.v1alpha.ServiceResponse.deserializeBinaryFromReader);
                msg.addService(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ListServiceResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ListServiceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getServiceList();
    if (f.length > 0) {
        writer.writeRepeatedMessage(1, f, proto.grpc.reflection.v1alpha.ServiceResponse.serializeBinaryToWriter);
    }
};
/**
 * repeated ServiceResponse service = 1;
 * @return {!Array<!proto.grpc.reflection.v1alpha.ServiceResponse>}
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.prototype.getServiceList = function () {
    return /** @type{!Array<!proto.grpc.reflection.v1alpha.ServiceResponse>} */ (jspb.Message.getRepeatedWrapperField(this, proto.grpc.reflection.v1alpha.ServiceResponse, 1));
};
/**
 * @param {!Array<!proto.grpc.reflection.v1alpha.ServiceResponse>} value
 * @return {!proto.grpc.reflection.v1alpha.ListServiceResponse} returns this
*/
proto.grpc.reflection.v1alpha.ListServiceResponse.prototype.setServiceList = function (value) {
    return jspb.Message.setRepeatedWrapperField(this, 1, value);
};
/**
 * @param {!proto.grpc.reflection.v1alpha.ServiceResponse=} opt_value
 * @param {number=} opt_index
 * @return {!proto.grpc.reflection.v1alpha.ServiceResponse}
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.prototype.addService = function (opt_value, opt_index) {
    return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.grpc.reflection.v1alpha.ServiceResponse, opt_index);
};
/**
 * Clears the list making it empty but non-null.
 * @return {!proto.grpc.reflection.v1alpha.ListServiceResponse} returns this
 */
proto.grpc.reflection.v1alpha.ListServiceResponse.prototype.clearServiceList = function () {
    return this.setServiceList([]);
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ServiceResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ServiceResponse.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ServiceResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ServiceResponse.toObject = function (includeInstance, msg) {
        var f, obj = {
            name: jspb.Message.getFieldWithDefault(msg, 1, "")
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ServiceResponse}
 */
proto.grpc.reflection.v1alpha.ServiceResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ServiceResponse;
    return proto.grpc.reflection.v1alpha.ServiceResponse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ServiceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ServiceResponse}
 */
proto.grpc.reflection.v1alpha.ServiceResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {string} */ (reader.readString());
                msg.setName(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ServiceResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ServiceResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ServiceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ServiceResponse.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getName();
    if (f.length > 0) {
        writer.writeString(1, f);
    }
};
/**
 * optional string name = 1;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ServiceResponse.prototype.getName = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ServiceResponse} returns this
 */
proto.grpc.reflection.v1alpha.ServiceResponse.prototype.setName = function (value) {
    return jspb.Message.setProto3StringField(this, 1, value);
};
if (jspb.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * Optional fields that are not set will be set to undefined.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
     * @param {boolean=} opt_includeInstance Deprecated. whether to include the
     *     JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.grpc.reflection.v1alpha.ErrorResponse.prototype.toObject = function (opt_includeInstance) {
        return proto.grpc.reflection.v1alpha.ErrorResponse.toObject(opt_includeInstance, this);
    };
    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Deprecated. Whether to include
     *     the JSPB instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.grpc.reflection.v1alpha.ErrorResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.grpc.reflection.v1alpha.ErrorResponse.toObject = function (includeInstance, msg) {
        var f, obj = {
            errorCode: jspb.Message.getFieldWithDefault(msg, 1, 0),
            errorMessage: jspb.Message.getFieldWithDefault(msg, 2, "")
        };
        if (includeInstance) {
            obj.$jspbMessageInstance = msg;
        }
        return obj;
    };
}
/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.grpc.reflection.v1alpha.ErrorResponse}
 */
proto.grpc.reflection.v1alpha.ErrorResponse.deserializeBinary = function (bytes) {
    var reader = new jspb.BinaryReader(bytes);
    var msg = new proto.grpc.reflection.v1alpha.ErrorResponse;
    return proto.grpc.reflection.v1alpha.ErrorResponse.deserializeBinaryFromReader(msg, reader);
};
/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.grpc.reflection.v1alpha.ErrorResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.grpc.reflection.v1alpha.ErrorResponse}
 */
proto.grpc.reflection.v1alpha.ErrorResponse.deserializeBinaryFromReader = function (msg, reader) {
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
            case 1:
                var value = /** @type {number} */ (reader.readInt32());
                msg.setErrorCode(value);
                break;
            case 2:
                var value = /** @type {string} */ (reader.readString());
                msg.setErrorMessage(value);
                break;
            default:
                reader.skipField();
                break;
        }
    }
    return msg;
};
/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.grpc.reflection.v1alpha.ErrorResponse.prototype.serializeBinary = function () {
    var writer = new jspb.BinaryWriter();
    proto.grpc.reflection.v1alpha.ErrorResponse.serializeBinaryToWriter(this, writer);
    return writer.getResultBuffer();
};
/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.grpc.reflection.v1alpha.ErrorResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.grpc.reflection.v1alpha.ErrorResponse.serializeBinaryToWriter = function (message, writer) {
    var f = undefined;
    f = message.getErrorCode();
    if (f !== 0) {
        writer.writeInt32(1, f);
    }
    f = message.getErrorMessage();
    if (f.length > 0) {
        writer.writeString(2, f);
    }
};
/**
 * optional int32 error_code = 1;
 * @return {number}
 */
proto.grpc.reflection.v1alpha.ErrorResponse.prototype.getErrorCode = function () {
    return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};
/**
 * @param {number} value
 * @return {!proto.grpc.reflection.v1alpha.ErrorResponse} returns this
 */
proto.grpc.reflection.v1alpha.ErrorResponse.prototype.setErrorCode = function (value) {
    return jspb.Message.setProto3IntField(this, 1, value);
};
/**
 * optional string error_message = 2;
 * @return {string}
 */
proto.grpc.reflection.v1alpha.ErrorResponse.prototype.getErrorMessage = function () {
    return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};
/**
 * @param {string} value
 * @return {!proto.grpc.reflection.v1alpha.ErrorResponse} returns this
 */
proto.grpc.reflection.v1alpha.ErrorResponse.prototype.setErrorMessage = function (value) {
    return jspb.Message.setProto3StringField(this, 2, value);
};
goog.object.extend(exports, proto.grpc.reflection.v1alpha);
//# sourceMappingURL=reflection_pb.js.map{"version":3,"file":"reflection_pb.js","sourceRoot":"","sources":["../../src/reflection_pb.js"],"names":[],"mappings":"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"}export {};
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("../src/client");
const grpc_js_1 = require("@postman/grpc-js");
// eslint-disable-next-line node/no-unpublished-import
const chai_1 = require("chai");
const sinon = __importStar(require("sinon"));
const reflection_pb_1 = require("../src/reflection_pb");
// eslint-disable-next-line no-undef
describe('listServices', () => {
    // eslint-disable-next-line no-undef
    it('should return services', async () => {
        const reflectionClient = new client_1.Client('localhost:4770', grpc_js_1.credentials.createInsecure());
        const grpcCall = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            on: function (_event, listener) {
                const res = new reflection_pb_1.ServerReflectionResponse();
                const service1 = new reflection_pb_1.ServiceResponse();
                service1.setName('grpc.reflection.v1alpha.ServerReflection');
                const service2 = new reflection_pb_1.ServiceResponse();
                service2.setName('phone.Messenger');
                const serviceList = [service1, service2];
                const listService = new reflection_pb_1.ListServiceResponse();
                listService.setServiceList(serviceList);
                res.setListServicesResponse(listService);
                listener(res);
            },
            write: function () { },
            end: function () { },
        };
        const mock = sinon.mock(reflectionClient.grpcClient);
        mock.expects('serverReflectionInfo').once().returns(grpcCall);
        const expectedServices = [
            'grpc.reflection.v1alpha.ServerReflection',
            'phone.Messenger',
        ];
        chai_1.assert.sameMembers(await reflectionClient.listServices(), expectedServices);
    });
});
// eslint-disable-next-line no-undef
describe('fileContainingSymbol', () => {
    // eslint-disable-next-line no-undef
    it('should return Root', async () => {
        const reflectionClient = new client_1.Client('localhost:4770', grpc_js_1.credentials.createInsecure());
        const grpcCallPhone = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            on: function (_event, listener) {
                if (_event === 'error') {
                    return;
                }
                const res = new reflection_pb_1.ServerReflectionResponse();
                const fileDescriptorResponse = new reflection_pb_1.FileDescriptorResponse();
                // eslint-disable-next-line prettier/prettier
                const protoBytes = Buffer.from([10, 11, 112, 104, 111, 110, 101, 46, 112, 114, 111, 116, 111, 18, 5, 112, 104, 111, 110, 101, 26, 13, 99, 111, 110, 116, 97, 99, 116, 46, 112, 114, 111, 116, 111, 34, 97, 10, 11, 84, 101, 120, 116, 82, 101, 113, 117, 101, 115, 116, 18, 14, 10, 2, 105, 100, 24, 1, 32, 1, 40, 9, 82, 2, 105, 100, 18, 24, 10, 7, 109, 101, 115, 115, 97, 103, 101, 24, 2, 32, 1, 40, 9, 82, 7, 109, 101, 115, 115, 97, 103, 101, 18, 40, 10, 7, 99, 111, 110, 116, 97, 99, 116, 24, 3, 32, 1, 40, 11, 50, 14, 46, 112, 104, 111, 110, 101, 46, 67, 111, 110, 116, 97, 99, 116, 82, 7, 99, 111, 110, 116, 97, 99, 116, 34, 40, 10, 12, 84, 101, 120, 116, 82, 101, 115, 112, 111, 110, 115, 101, 18, 24, 10, 7, 115, 117, 99, 99, 101, 115, 115, 24, 1, 32, 1, 40, 8, 82, 7, 115, 117, 99, 99, 101, 115, 115, 50, 63, 10, 9, 77, 101, 115, 115, 101, 110, 103, 101, 114, 18, 50, 10, 7, 77, 101, 115, 115, 97, 103, 101, 18, 18, 46, 112, 104, 111, 110, 101, 46, 84, 101, 120, 116, 82, 101, 113, 117, 101, 115, 116, 26, 19, 46, 112, 104, 111, 110, 101, 46, 84, 101, 120, 116, 82, 101, 115, 112, 111, 110, 115, 101, 98, 6, 112, 114, 111, 116, 111, 51]);
                fileDescriptorResponse.addFileDescriptorProto(protoBytes);
                res.setFileDescriptorResponse(fileDescriptorResponse);
                listener(res);
            },
            write: function () { },
            end: function () { },
        };
        const grpcCallContact = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            on: function (_event, listener) {
                if (_event === 'error') {
                    return;
                }
                const res = new reflection_pb_1.ServerReflectionResponse();
                const fileDescriptorResponse = new reflection_pb_1.FileDescriptorResponse();
                // eslint-disable-next-line prettier/prettier
                const protoBytes = Buffer.from([10, 13, 99, 111, 110, 116, 97, 99, 116, 46, 112, 114, 111, 116, 111, 18, 5, 112, 104, 111, 110, 101, 34, 53, 10, 7, 67, 111, 110, 116, 97, 99, 116, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 2, 32, 1, 40, 9, 82, 6, 110, 117, 109, 98, 101, 114, 98, 6, 112, 114, 111, 116, 111, 51]);
                fileDescriptorResponse.addFileDescriptorProto(protoBytes);
                res.setFileDescriptorResponse(fileDescriptorResponse);
                listener(res);
            },
            write: function () { },
            end: function () { },
        };
        const mock = sinon.mock(reflectionClient.grpcClient);
        mock.expects('serverReflectionInfo').once().returns(grpcCallPhone);
        mock.expects('serverReflectionInfo').once().returns(grpcCallContact);
        const root = await reflectionClient.fileContainingSymbol('phone.Messenger');
        chai_1.assert.sameDeepMembers(root.files, ['contact.proto', 'phone.proto']);
    });
});
// eslint-disable-next-line no-undef
describe('fileByFilename', () => {
    // eslint-disable-next-line no-undef
    it('should return Root', async () => {
        const reflectionClient = new client_1.Client('localhost:4770', grpc_js_1.credentials.createInsecure());
        const grpcCallContact = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            on: function (_event, listener) {
                if (_event === 'error') {
                    return;
                }
                const res = new reflection_pb_1.ServerReflectionResponse();
                const fileDescriptorResponse = new reflection_pb_1.FileDescriptorResponse();
                // eslint-disable-next-line prettier/prettier
                const protoBytes = Buffer.from([10, 13, 99, 111, 110, 116, 97, 99, 116, 46, 112, 114, 111, 116, 111, 18, 5, 112, 104, 111, 110, 101, 34, 53, 10, 7, 67, 111, 110, 116, 97, 99, 116, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 2, 32, 1, 40, 9, 82, 6, 110, 117, 109, 98, 101, 114, 98, 6, 112, 114, 111, 116, 111, 51]);
                fileDescriptorResponse.addFileDescriptorProto(protoBytes);
                res.setFileDescriptorResponse(fileDescriptorResponse);
                listener(res);
            },
            write: function () { },
            end: function () { },
        };
        const mock = sinon.mock(reflectionClient.grpcClient);
        mock.expects('serverReflectionInfo').once().returns(grpcCallContact);
        const root = await reflectionClient.fileByFilename('contact.proto');
        chai_1.assert.deepEqual(root.files, ['contact.proto']);
    });
});
//# sourceMappingURL=client.test.js.map{"version":3,"file":"client.test.js","sourceRoot":"","sources":["../../test/client.test.ts"],"names":[],"mappings":"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,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG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"}export {};
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const descriptor_1 = require("../src/descriptor");
// eslint-disable-next-line node/no-unpublished-import
const chai_1 = require("chai");
const descriptor_2 = require("@postman/protobufjs/ext/descriptor");
const lodash_set_1 = __importDefault(require("lodash.set"));
// eslint-disable-next-line prettier/prettier
const protoBytes = Buffer.from([10, 11, 112, 104, 111, 110, 101, 46, 112, 114, 111, 116, 111, 18, 5, 112, 104, 111, 110, 101, 34, 55, 10, 11, 84, 101, 120, 116, 82, 101, 113, 117, 101, 115, 116, 18, 14, 10, 2, 105, 100, 24, 1, 32, 1, 40, 9, 82, 2, 105, 100, 18, 24, 10, 7, 109, 101, 115, 115, 97, 103, 101, 24, 2, 32, 1, 40, 9, 82, 7, 109, 101, 115, 115, 97, 103, 101, 34, 40, 10, 12, 84, 101, 120, 116, 82, 101, 115, 112, 111, 110, 115, 101, 18, 24, 10, 7, 115, 117, 99, 99, 101, 115, 115, 24, 1, 32, 1, 40, 8, 82, 7, 115, 117, 99, 99, 101, 115, 115, 50, 63, 10, 9, 77, 101, 115, 115, 101, 110, 103, 101, 114, 18, 50, 10, 7, 77, 101, 115, 115, 97, 103, 101, 18, 18, 46, 112, 104, 111, 110, 101, 46, 84, 101, 120, 116, 82, 101, 113, 117, 101, 115, 116, 26, 19, 46, 112, 104, 111, 110, 101, 46, 84, 101, 120, 116, 82, 101, 115, 112, 111, 110, 115, 101, 98, 6, 112, 114, 111, 116, 111, 51]);
// eslint-disable-next-line no-undef
describe('getDescriptorRoot', () => {
    // eslint-disable-next-line no-undef
    it('should return Root', () => {
        const root = descriptor_1.getDescriptorRoot([protoBytes]);
        chai_1.assert.deepEqual(root.files, ['phone.proto']);
    });
});
// eslint-disable-next-line no-undef
describe('getDescriptorRootFromDescriptorSet', () => {
    // eslint-disable-next-line no-undef
    it('should return Root', () => {
        const descriptorSet = descriptor_2.FileDescriptorSet.create();
        lodash_set_1.default(descriptorSet, 'file[0]', descriptor_2.FileDescriptorProto.decode(protoBytes));
        const root = descriptor_1.getDescriptorRootFromDescriptorSet(descriptorSet);
        chai_1.assert.deepEqual(root.files, ['phone.proto']);
    });
});
//# sourceMappingURL=descriptor.test.js.map{"version":3,"file":"descriptor.test.js","sourceRoot":"","sources":["../../test/descriptor.test.ts"],"names":[],"mappings":";;;;;AAAA,kDAG2B;AAC3B,sDAAsD;AACtD,+BAA4B;AAC5B,mEAG4C;AAC5C,4DAA6B;AAE7B,6CAA6C;AAC7C,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,CAAC,CAAC,CAAC;AAE1rB,oCAAoC;AACpC,QAAQ,CAAC,mBAAmB,EAAE,GAAG,EAAE;IACjC,oCAAoC;IACpC,EAAE,CAAC,oBAAoB,EAAE,GAAG,EAAE;QAC5B,MAAM,IAAI,GAAG,8BAAiB,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;QAC7C,aAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,oCAAoC;AACpC,QAAQ,CAAC,oCAAoC,EAAE,GAAG,EAAE;IAClD,oCAAoC;IACpC,EAAE,CAAC,oBAAoB,EAAE,GAAG,EAAE;QAC5B,MAAM,aAAa,GAAG,8BAAiB,CAAC,MAAM,EAAE,CAAC;QACjD,oBAAG,CAAC,aAAa,EAAE,SAAS,EAAE,gCAAmB,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;QACtE,MAAM,IAAI,GAAG,+CAAkC,CAAC,aAAa,CAAC,CAAC;QAC/D,aAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC"}MIT License

Copyright (c) 2020 Muhammad Redho Ayassa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
{
  "name": "@postman/grpc-reflection-js",
  "version": "0.1.2-postman.6",
  "main": "build/src/index.js",
  "license": "MIT",
  "dependencies": {
    "@types/google-protobuf": "^3.7.2",
    "@types/lodash.set": "^4.3.6",
    "google-protobuf": "^3.12.2",
    "lodash.set": "^4.3.2",
    "@postman/protobufjs": "^7.3.2-postman.3"
  },
  "devDependencies": {
    "@postman/grpc-js": "1.10.8-postman.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^7.0.2",
    "@types/node": "^13.11.1",
    "@types/sinon": "^9.0.4",
    "@typescript-eslint/eslint-plugin": "^2.33.0",
    "@typescript-eslint/parser": "^2.33.0",
    "chai": "^4.2.0",
    "eslint": "^7.0.0",
    "eslint-config-prettier": "^6.11.0",
    "eslint-plugin-jest": "^23.11.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^3.1.3",
    "grpc-tools": "^1.9.1",
    "grpc_tools_node_protoc_ts": "^5.0.0",
    "gts": "^2.0.2",
    "mocha": "^7.2.0",
    "nyc": "^15.1.0",
    "prettier": "^2.0.5",
    "sinon": "^9.0.2",
    "ts-node": "^8.10.2",
    "typescript": "^3.9.5"
  },
  "scripts": {
    "check": "gts check",
    "clean": "gts clean",
    "compile": "tsc",
    "fix": "gts fix",
    "test": "nyc mocha -r ts-node/register test/**/*.test.ts",
    "report": "nyc report --reporter=json",
    "prepare": "yarn run compile",
    "pretest": "yarn run compile && yarn run fix",
    "posttest": "yarn run check",
    "protoc": "grpc_tools_node_protoc --js_out=import_style=commonjs,binary:./src --grpc_out=grpc_js:./src --ts_out=grpc_js:./src --plugin=protoc-gen-ts=./node_modules/.bin/protoc-gen-ts -I ./static/grpc/reflection/v1alpha reflection.proto",
    "build": "yarn run compile && yarn run fix && yarn run check"
  },
  "files": [
    "build",
    "LICENSE",
    "README.md"
  ],
  "keywords": [
    "grpc",
    "gRPC"
  ],
  "types": "build/src/index.d.ts",
  "peerDependencies": {
    "@postman/grpc-js": "1.11.0-postman.1"
  }
}
# gRPC Reflection JS
[![npm version](https://badge.fury.io/js/grpc-reflection-js.svg)](https://badge.fury.io/js/grpc-reflection-js)
![CI](https://github.com/redhoyasa/grpc-reflection-js/workflows/CI/badge.svg)
[![codecov](https://codecov.io/gh/redhoyasa/grpc-reflection-js/branch/master/graph/badge.svg)](https://codecov.io/gh/redhoyasa/grpc-reflection-js)

A JS library for talking with any gRPC Server that implements [Reflection](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md) protocol.

## Installation

Install with npm:
```sh
npm install grpc-reflection-js @grpc/grpc-js
```

Install with yarn:
```sh
yarn add grpc-reflection-js @grpc/grpc-js
```

## Usage
- [Initialize client](#Initialize)
- [listServices](#listServices): List gRPC services
- [fileContainingSymbol](#fileContainingSymbol): Get protobuf Root using fully-qualified symbol name
- [fileByFilename](#fileByFilename): Get protobuf Root using proto file name


### Initialize
```js
const grpc = require('grpc');
const grpcReflection = require('grpc-reflection-js');

const grpcReflectionServer = '<gRPC Reflection server host>'
const reflectionClient = new grpcReflection.Client(
  grpcReflectionServer,
  grpc.credentials.createInsecure()
);
```

### listServices
```js
const services = await reflectionClient.listServices()
```
Output
```text
['grpc.reflection.v1alpha.ServerReflection', 'phone.Messenger']
```

### fileContainingSymbol
```js
const root = await reflectionClient.fileContainingSymbol('phone.Messenger')
```

### fileByFilename
```js
const root = await reflectionClient.fileContainingSymbol('contact.proto')
```

## License

[![GitHub license](https://img.shields.io/badge/license-MIT-lightgrey.svg?maxAge=2592000)](https://raw.githubusercontent.com/apollostack/apollo-ios/master/LICENSE)

MIT
# editorconfig.org
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
.git/*
node_modules/*
coverage/*
out/*
module.exports = {
  "extends": "airbnb-base",
  "plugins": [
    "mocha"
  ],
  "rules": {
    "global-require": "off",
    "brace-style": ["error", "stroustrup", {
      "allowSingleLine": true
    }],
    "no-unused-expressions": "off", // to allow `expr1 && expr2`
    "consistent-return": "off", // causing issue in early bail-outs
    "one-var": "off",
    // "one-var": ["error", { var: "never", let: "consecutive", const: "consecutive" }],
    "object-curly-newline": ["error", { "multiline": true }],
    "indent": ["error", 2, {
      "VariableDeclarator": {
        "var": 2, "let": 2, "const": 3
      }
    }],

    // MOCHA
    "mocha/no-exclusive-tests": "error",
    "mocha/no-skipped-tests": "warn"
  }
};
image: node:7.0.0

pipelines:
  default:
    - step:
        caches:
          - node
        script:
          - npm install --loglevel=error
          - npm test
# Hermes ChangeLog

#### Unreleased

### v1.1.4 (May 26, 2021)
* [DKTPFN-186] Fixed an issue where child process was getting crashed while extracting the downloaded tar file

### v1.1.3 (April 22, 2020)
* [APPSDK-705] Fixed an issue where parent process was crashing when the swapping command was generating output on standard output stream

#### v1.1.2 (April 8, 2020)
* [APPSDK-686] Added logic to run child process in isolation even after killing its parent
 JFIF        C 	!"$"$ C "            	
    } !1AQa"q2#BR$3br	
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz        	
   w !1AQaq"2B	#3Rbr
$4%&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz   ? .(((((((((((((((((((((((((((((((((((((((((((((((O$<Uxs7vlJY` SAOWs 5- oY .: ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +7[SnVQkK[&abtyHabI!I A  Bo? }g+ZgoKuN 	=xU:v)"q^ux_V kOew5[>nwf+31F$0|1A.>F'J*Bc
PNe OWs  oo[Z  y4c2Ffai]*1w e,$[wcwM<vs|5=mFQBnJbYAoXh:xk573G4voHckMSG 0Xx=GKn<#
S50Rw lFW	=p-[zFWNZ\m[CFf=_FW-cd b*2cr#W ) *_^h~$X
}6o2/lrBFH$?PM3UPg]t]ZyZ0[,3B>r2TIG(xGkZ[tFAs,K,qG39(~PG8'9{;|+O:.KK.bH ?kQ:9vK5<-$pb1?YFX31 n$U5+I7M/a<pS9 u|BM3L#%x 24"1W ) *_^)}qCj([{[D9,rr?G^xfEX9w@+$fC. r%*S+d!'fUbG g?)_ Mgw?>	^Nyo<{{e"-FzKYSh<Ckumfun). R-Bfd?.K i|S 7U /&3 
WiZ7oq}d;4~ry@xyMiKox=I!G+%YZ~idwz]56FF<j ?| ] +j	-:DxXRIm:K[3YU|/>q#WYt}zVV84wd _ Mgw?o8o5.&?&lo|GNxoWZ|c2+[mft&!j71st3H%F\]yFa8; r *kaa_qyOfb.@$H% s!x{C
2#-]NN$ 3]x:w>xuo=b<i Ic-WUS-_*s=oAp)>w,w ;K	  i|S 7U {zmKGD+e-$7CMnx#h#]FdeR8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs okxA7~}y+> zwG] QE QE QE QE QE QE q   N]y-//?DL&M9);c8  [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ Y~ o Y~ o ;:+  [   [ [c|g f |g f \g, 7FjG, 7Fj@|g f |g f \g, 7FjG, 7Fj@V,,uRB$&D%VD`+ AW+ / #Q / #PgU+NKJP\D$9V@?r; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 vtW / #Q / #PgEq; @ 5; @ 5 x; I?D< b g@Q@Q@Q@Q@Q@Q@f % -?Sg\f % -?Sg@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@MWWYeyxo[Da &ii2_gs8joM7Zw":sx d<W\x_7:De\ B7`Sx{M=;A-#[s#NMymKxC1N#8+xLX"[R<;~<BDEp{xop[zd1Eflc;DUKc >xwG&$1[d,Q8xq :46?,MkY.4i"hlqDZ8g*E~CX|JiO%^B7NY#9<55~Qjy7Wg?y /AUx?HIa<2EmEoB[# xeEkAuumvzOJy1
;}tk(4.8DDy- pk<#M?Fl|1ZwjR	kq)w|/7G'8089 jZwMo\e|B86uf1'yz%q!Np|Gg_mZ+U[0BBWmlZ6qAFc(\P   uK{B^[]m/ggU_3F1@[?V6"uKZnJIqq&K?,n	2OZhl/F^%]NUf 9c0bJIg!6yp2b3	$riM53uV`]qNO y~o6n*DM:=<bk*F{/|7wO<OCygjZb?p9.$H~oI.|1VgI%^{QMROU'o^H&x]II2:3	#hWrtm*UO-,fp(=<Akg]f3-%]flk1lidaaP-%x*:NO6dd@QxRZCZOOmce|<LoDk	69xG<aEe3^i&5PL8P]Z0]fx\ bMT6UMmz t7=QK=Jydei$
$rdP9;Fz
 6[nTjjv0<F	-!mCxTwz+f_"'I]q	,W<'}ym"a$'9|14/~;KhtR%P.F4~<]m7KZQ[Te vs(8e;=PAgRoFe;Gq_j~qh:\hm3J$~xF7,n${hp [r yi^ x.5Mc-0yU<<nyL[5'l[B0.@d{>:>cr%BB@'n7+;XuFa{ )v,ORh4vi+5jIcq]IwbTL'Y^ "IZIc832!3\j5	AYG+[Sx'w.Kx]fapsdUzq@ j"}{b-)(.&?:V[53nh`X!@ ;U ( ( ( ( ( ( ( ( ( ( ( ( > zwG]qx; I
(
(
(
(
(
(8_K [K~<K>#f?$q.4+ag	?T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[^{O<?K^><YmKB%6Gro[6[ZJ^^]a91BWq\jm-Wqgm4j(gu*J=j>|Eu.vcq .T *K0:oYt{9|MFL pXqC{eM5 tgHnMXrLr[Qm [} {v?ivc^-Ni8mZ(l<-cb8>:zh17ZMXm06>wYx~4-'}{#G"a`O>jQm/sxX_NKas *ZZFoK Z%vcXO46G+Z>UWH=NU<M$-
D>va( C_0xq
]zK6p\MQpK
|YI3/{c/ YV6GXid{Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @Y D" ( O?Em PgEq4g?S, i[\g*M< +o"T ?x3 VE vtW 
gO ?&  @" oN h3O 4uEPEPEPEPEPEP ozu ozuEPEPEPEPEPEPEPEPEPEPEPEPEPEPEP}RSnxVSA"7t/G]J[;[;{|%hD|r|1cs^E p.o}}W`m E eiS 7&U%YGQ9h>&[u8FT/VRY$v~Qq_:|nfG%5!By>F6\,r5zq|$[V7qO{#_Eq;<l
;|zXQiVebFK4omz%#WquM3\Co5KG$x2dHH9&vGM&Yfqky7;Iv#(Ozm:k=DclM+
HH_"~\2rm5bR5%  bA'5@}iH uY/<[iu	!'e P'/=?zA{RLNfAgF8!?1w((((((((((((((((3O 4u'H [: ( ( ( ( ( (|w^|)ocOA|?9a4l"x] G8: I 5- oY .: ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA _it'f<1S2SNv\c8z/ir <m-(`w	02$m0R1Ex:]O+4Bm)drV2qp_4i~m]|6K'Pnw~2$}b|A8l]B{_-IWs Ei>^YC4XL6dr	) .&Hj aVa|@ChD^]A<dx$*5;Pkb4F[-0%!)<#Ix,3=t{m9xjXeyy#1E% xR5v/Iw[Ya<" FFpx#'gx4vFt]G~;O%1B$;A4|_]40oL-LYGvOLI4nM/<AVZ]Q8w}.&GA"66T*1sk 1bDHotds (n~Zyan..vnIZEQl 9Ms)ggo6?UYix~{qrYLo+~Ps]{ox|;iO|Lt{HsR:a*#kd|
eG..o[{;_67<m!
>>%&+[Vmncso:Ne[4J&;pX?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( $C-Mvu|	 !?&: ( ( ( ( ( ( 5- oY .:3Ln_inX:C)-n0I:_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_PXW^Qy#S@}8\eXr	uEy_xOKwEA|I fn$ W-{K]OI.mYbQvxhaxtadq@Eq_ Mgw?K	  ^0~1%RuAlp$eIb>`t> =g7I]tAA(h=W+r D On yi. ,988 _ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +/&3 
WOWs  3K	  i|S 7U ;:+ Bo? }_ Mgw??) *_G?| ] +  $C-Mvu|	 !?&: ( ( ( ( ( ( 5- oY .:5- oY .: ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( +6C7T.]2K}@FF	e#:([_wq)owJQmmXrT_n[_Fv&RW!<n^tPm{x{Y'?W}>@WyqVU+Z#/%=3>!JMeqiyR'VH@>7Ywt\N`e	=3V(OOI_[_RnKJB1;ql&7X	5YN/+Y-dWTvIye}1E |cX:5W~K4K}:I?v[n"
O/$$`6svC(:( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( $C-Mvu|	 !?&: ( ( ( ( ( ( Z
^_CX-q{&MrRvp33 / #Q ozu / #Q / #WgE q; @ 5; @ 5vu_MN[$F 8e8  r; @ 5; @ 5vtP / #Q / #WSKGj1,e6$+g!IV Ol(t{YFc	0' / #Q / #WgE q; @ 5; @ 5vuq[?xF[^-db"@'J   [   [ w+C7 .E# (lEY`: GA   ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3O 4u'H [: ( ( ( ( ( ( _g Jt'K}OwK`G-fRM!   N] yo6x7GWZ--[;A?d(T0-sWAOm,nthdE$A%M}h^.&kxeUeG=:V |COy&hQ^HPX\2vZO@Qyy.yxAiwqj.}'o'OJrFgeqGtkdf F=[jw%CzZ+[)-RD1PycT.M6u"WQ]KK`qE#,;Bv }7-^[+(bY5+)22@r~\M[};f,3331%$I4<>%>?3F=V<CQ_DR*2lYYU"a\V-VN}k58ik$$`HJUkxOUmuiYX[QX(1o
75C]oXz&-uY&J-5d9$EyHMNWP/[OV#MG$L1>La{M2V:>	WBe,7UTvIBdPEQ@6x~Ypxb^u;[}r%d[34!ze+?jZgcG=ij+WkeJ;WU@9#<YxG`)}6.3e+</.syxV9!XpB#k((((((((((((((((((((((((((((((3O 4u'H [: ( ( ( ( ( (|w|)c=Lm#2AhM 6zZ O?Em Q ozuOO5zfSVS-RZ}_./26
.6 *(*M< +o"T ?x3 VEG_75ckIYl,L6H<IR<M\`&U(|`	@=?&  G*M< +o"/=[N|A4Vz]_GrYK1Vydxe6XW]O0xLub~n/V0\2\G<
4g?S, i[/|IxOv7,<.oNO	9eLxBk	5MRg<_hamfK&yK
<C+eCnw4g?S, i[GZh'si:vK-@2$U~6.Te5='.m{It+R9Y`O$D?9 4?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3?&  G*M< +o":( O?Em Q 
gO  ?S, i[Y D" +8T ?x3 VE4g3O 4u'H [: ( ( ( ( ( ( _g Jt|w^|)ocOA|?9a4l"x] G8: I  <M^$?{w*MG3,R!rFUpz2zd|=0Eqmyl2]5w,ZGIw%3Nj /+3 ]' h 7_V<g O  ?omt}FYa0Zw|-O# ` qiw^o[1,7<cHI=Is I ? . 4 x<Y7,uy;[IeF5+:i}FTGD!#98ml!" ?C|E Ec  Z_xvLh_NOOq_i]jk7OB5GSQO)n8m2Q'2&L W7  . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ?;:+ 7_V<g O   ox tA? . 4/+3 ]' hC|E Ec  I  3X?G!" ??D< b g\g" oN h((((((3W )5kZnvWoa$iC)~ ozuFiWlemTTn#?$8 gxV,u>skaLT.3*Rs\FvYZ6GCbcI(`Sp d-ziE2[x)udE 2 qv
?fx3Kq>$7 R$
6`o[a47zk*B
nI~lEd WNc%x++	;W@,@.QP;}Zz53E<#^9_|%M4]d{TQw+H_urm*UGIO>LfcDp}3cTRYo	ubA"EJqaF
o,	up[+i=f5{m$H\2rv |E?D\?XM&Gw,S,KujK1T@*:/T^JHTR/'!Xe>"kq kr7gw38^n57\:f|9<V*!37-Olx:]k]7>n9|^<UQ{jYbKW:#at&H85>7P:&oklQHvI,;H't8z\{[ j]kNI]Fi@ufS7>1akzom4dpC[
Ce[n eww&vn`f?6bUF92U/xo[&&I--$qH[> A5A[pS*uz +Y^=}XKiwSuL;SRI$p@2o:+:Jxj\)2;J2IVbM?w1[ZF]R8VGx$/;)[\8`V.qEuHv!QW#YV^L+;> }r /'VvI=tn/b!Ybr+xWV>.{MK-H=aJ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( > zwG]qx; I
(
(
(
(
(
(8_K [K_K [K[hK|t@i6@~mGlp'Zjg@u( @"?_4	uiNtwZ0E<3)1}P_EP:$x`.)e!#<HUk6 >	X/aIZS
6
1;Px<r.:FAc=z}KQF!jS&cR21Z|#CCujDK9_=E nQ\<}jVZUm&yukm\N$"22xK/3%u)4Jl['iqNtW;2nZ4oe-#DDjFX>%s[i> 	Vl(RJ6>4Eqs|R;ci]+Q>!k+%Hbd1V<%t53mqMK6g*TEci~+~%"9#G}z`u;:55i4d@"NW<VuH(h4H}W7R_X]jBCshFB8[Mg[{Nnjc*ylUPC1 wV-|+w6kmW]&	Wm)V h*>G-/HT6PsZ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( $C-Mvu|	 !?&: ( ( ( ( ( ( 5- oY . }7m;]ZD)b|q
P1u- oY .: ~(zmQjPQ-HUy)u{	y/hY<&>bn/#)K<"
cpHa(-xHXz%:XFrkqR|E#o&"mNY.%wI"s{vV3x~}U-<U&|76[dmDSzH;!73|= bH{_IiYpO"44OoFJ@x7sXI5YxP[(,,#6 ]5nb/YGk6-4&T>r\{}>(6y`m,$[.Fna
vZ5s`W-|)/-uhol|'&_icp>\)ko(219IQ@Ii~%|Q[x
B[Mm~hoLRiEI{ciPadw*/kSh)Aa><<I+4${_6g5:/MKY-eY+H#H$Zp8;9|,$xdx i@sjo|xR}T.#gDD Np{]Xgpx2-'1\@sFsG8 (M,d_5h'$0'd#nw2 cw48t-9~	-myv7+}E~
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(8?D< b g\g" oN h((((((3W )3W )/E<7?u.MRy;"}KJV14[0"
b";%{{gCHkFR##OwVMi266_-o,a\m"OXuj?:ux.W0"|!>t>7>!k j2m;P3D59<H:Mgyg_A,Ow2U`F66HUvW\iyopy+2mV}<*|kkc cZ4(UF!$*<kMl=mcXZ7d"D-EPYI1o#K{Th yz1
RH|U{oEhs bn\H; jkj>*ES\1um5o=mi!&0/|^ks]h83-7+2*,y3/ofXfx%0#Sj|4i:CNf9a0H/>dHf73i!zZIkH{VH6[Ve<QD76vw-2JRIV+'(
|SwY/51R9QRFm]:HEZ2;%ZQ!,tC*
55!}&?,,Vu8RCqnnf =8\"]FMgN}v)i4Amq3:	PAY][\h X_E%#Xb=pgT32Qx+|&6zm.'K}4G%<6TemHs8}r-RM(nE$O3;vc9qI$:ee9Bq_%|>etM&z7}6kveY>a6l]NkM^kM}-<oi@YPcn]` GQ_>:dhffq]\k=%9dgU( n}@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@g" oN h3O 4uEPEPEPEPEPEP ozu ozuEPEPEPEPEPEPEPEPEP=x3A!]JP"$Aq#@\t(((((((((((((((((((((((((((((3O 4u'H [: ( ( ( ( ( ( _g Jt~&z]/.[cku1I P
D|~fAj [/ b :]tjwZm6to,{/7$[,#2 ,U; j\kli.%U6rT|]m2Vji,J%&Fst<Kc5~jj:}|i2B=]Y$H \]{Oi^4_4!I#B6hrc_gRhg_>QY $k3Uy%mN{x 1e5-0%s8Pe!~T?mbG,7j%LO")`FF)	muM>Y6(xU3k }qJ>4%]C\Jnbt{--Ac;X$d\x>+iv~.}]B{kXiDHfd@dR{ym=B]gGmZOq^I!1*@;~6cuDIhK,Z3so
?>Ax{GD*R6pnbfVa@YA9jm'<?kKk,/$RE/Aik:n}ft5Adr-yRUCc*oz+G|1y}%[Ed6_6XY@DT>*.}{FGhZQia&b<A tt{%W@55`*;?E:>^NVm\M>,\Fm FwFx;K4]KFF})k7w+,3O(hqd$Y4w}Kuh4MGI0	.6lD[j-|a~M9	eImfhem}z-GzwYp cE%h6r6c_KZh`}cY?vyQo~-xr?Zkeku9DQa-Fvx,MpooK1a9ePLc?Fk6"5l ]'5&,n$1>] rHa(lz oyz6 |}w6u?6V+6y!N#SIk@~,y)}}_Aj-xQ++)A$
K3	|#Yt]_MJJeowV$nzn"x%X\w#"#p(JN//KS\f@s
8&+q~i	t3$$(s6c%e'}<Ki^!,|t_$BYNomn?|K 	< p|'vO|A~tc-l|-.>0Z|I|i&Ow$41C0:bUEVN^)qqS&S3l`@*	RFjeogEt<C `$o M[]AsyOHIrSzXewq~ jcK[Jm98h#KPmL.H&'7KhH.m.=GQLf @*wH_xg7ul 2]4b2C|S|9&~$INFh{iUkXRx1qjRx{\&MmmhK(.7v11U e\z3+K}+FI~tw&X(l m;6~_ovo/~s T~4xzu+W7NRyW.19$(^k2q`g|4vMwMv}P{kaj4w,7emp>eTjc45Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@g" oN h3O 4uEPEPEPEPEPEP\>0RNhAl42n4#^F3?Y~ o _K [K8Y~ o Y~ o :%{{gCHkFR##9?Y~ o Y~ o :(  [   [ ;K{XajVqV(  [   [ 9/-RI6@v
	(I 
4-BZ}?6	reYYHA@, 7FjG, 7Fj]$&`Z	yW U ?ew3 3V j?ew3 3V j|Ev-oMAtF\BrH4-}>dr.fns=(  [   [ 'Rm0^[NUDE)$c @g, 7FjG, 7Fj]\WRynOn$H3/Pc[X3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3_?#5oF_?#5oF ?ew3 3V j?ew3 3V j3O 4u'H [: ( ( ( ( ( ( _g Jt'K}OwK`G-fRM!   N] yh_l&uXuBRUa
0rdm:]x^ZkG+uk`ZyI>i\_SQ@:AZiH6	OR H${~&y/^x'w*#crT*(_+\\4O {G24!W?69_kgskz>'J'mb-}pb'd
H_1}cE |b-GH!k>:>MM>[13m$2)o\M=;S|FI]RA 9E |LxWW}G^\P~k=tPc+U^duY_'nO5Yf7}ZUYDX|=F ?ZG>3i~ }[M3P`f]!XH{rAa^U|/mCTBU ;:+m_NPdY)n<
d6W4P*hF4O$`u[5^!uR_9\]mL^p"oE.c;c-Hy {V^"<AOP(&I?wv"+1X,jH'>*hz{]"{)5+[i6lCx@rF[(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(8?D< b g\g" oN h((((((3W )3W )k'3}[ 5\^el%b]Bm,TPEr<Gh~omok:t/}+B$n8 8#Mqs]?P$}=6D*&2FF=}#Pvq_~}&ieb/U R|*x|+/nlwyP&PG2``(<giSZ=m[$-Vc.hx/|btk{M&h[i[Hl3g< Exij]Yz-H$[9eo48_(amP<wKG/]tZjQu@\pH_:U7^Bc$I2%rX"<=kS&CeuP{)$FaxQyIH,e$ >5;Y}fh76}DQEF$U6#7,<{4KYYxLHkt J3PQ_<=7/=u|6$9L?jB\m7AbX wZg<Q']+TO	7Qo73[.}_j1Q\"sGiX4Pr'eR`d}<kU!^}XVIA%i"dG67Fz|e&6%Ckosm,4L[T1`=}7|QMF'Xbm8eq"l]' J+>^6n:eetd"I@@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@g" oN h3O 4uEPEPEPEPEPEP ozu ozug+YugI3$R#GI#*C)z9qhhI	gN)O3$Fuu,C	]jHg`&#$L b	*^Q{o
Gy7H~o0oa o>xFfRitHGP`s ^ZK xb")Q,301vP!svo6+$&*6Wa?	Eqkyrh/&-r|:.@uOi])K[0*!v! z'|=ia\-5[k%RZ|aq !_[ []	#O2$B"TqU@<RZ5m:ej7-W.|3mTo-
 "IGPYK`&vd909YAxQB/k[D7K~j2<O<P|.? M{Iren$i3:$>x6;-R}>PMRu[MgtI$39!
PGcE s"r$V!r~blr?vfm%>\En2U=	 n ?5NV]F<XQG.'0U\PEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEP'H [: $C-Mvt QE QE QE QE QE QEj [/ b :]?|kMA=.q-1M(w">Q@?3 5- oY .]SH;6L7m-gAg xE G.bl64rSC9fePNk.6+]_W5fuHbLVsli%#tjv:v~?%PM?S>K>4!.HSd@.V4ZF}In/dUDTFp4m[1Kl/TmeHAY)43(@`idea6u=h(2x*6GoWvF&hbr#vG#ikxo|<*c J>N%x{ s.Y\j1x:= ,chBX.Flj_
C?T.{=H4$Hy 2)Y=<Rm.}eu-'cKXwWBg}_HK_"k	HyinIu[y9CPEb =_"k^{I
8ZX7EdD3+,OI[.STnX`h{rpv*E/Aik:n}ft5Adr-yRUCc*f~ewgZ&vwyx/6U>Y#KNk-lQUh)o@Ga{8t,UYW pqWOHD]h- %yb*_Vw#Fr:_> GRQ-5;sPZX41+
Gy#!l7M#|h:5}=3ZN:+ *ZouoxgZg6	lfbFb?8OOgg[AR-ckue-e$j	SWog|7|i- #kq&CPs soND[R}|DW7Hm8twOer'h063r;~w_k(XWZ4Q\&G.]Nz=sA)2?V6`A@9R~";w^_DE5&eNb|9wOgV,_Yfu;PyXl)w;>	-xN_zEx6}7BN{
K#6/b em}_vrXiz-ykVQVkxif!,oo<zy>ys^ire{|7&g[@4ijFpn[d(((((((((((((((((((((((((((((3O 4u'H [: ( ( ( ( ( (|w>
?43Q>=b?i`v@'<` i|S 7U _K [K[hK|t@i6@~mGlp9?/&3 
WOWs 5OM=_P`b0Nfb UmIo[kT}lw}dy|  Bo? }_ Mgw?U}&hWq]Ouq3"Q 8;c&on<C &e	?&P8o(6l!OWs ?) *_M_OxwL6p4}>k[i"
F`pB!EZ'St[{+]N+tHd,+<G(?| ] + Bo? }-G]3^_6ymlpJ#W8^koJGum>CJg< f9co hK	  i|S 7U __afvjii d|"	guX?XCsC4{OLayNy^Zn#:__ Mgw?K	  t;(;[	hcd~qk	xvoDE6Mmtdu= ci|S 7U /&3 
W3OA]3X$r[hU'k3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }_ Mgw? ?) *_G?| ] +8?D< b g\g" oN h((((((3W )/7|_I!IPA4AQb'7	W )?gX Fh%7R#k4dWgRx,xmO]R6}n<A` eXDo*hc3} =O)>#NxLD[H#BT rKs~EO,|Su|<Gd-(#i<qm+Pxi {~-wMk{o,34Gs(uO~#D(T;W@=Ex*FX.c?-R@*+<ix zD:QX44B6=\0+;m8(ZxA;:Ohq$FVX+@c&]ZxEXj'E];Ki]Bg.3e:(czGZj6IA1VQ&LoU&;Oi^#OSo/KUKd`dB7K%Q^E yrv z=Couf3(R>yo,HK ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( > zwG]qx; I
(
(
(
(
(
(8_K [K_K [Kt$t=6K}rHk-)[oh(!> 4z_4y5kxu	t(\InQ2Z-+ZZzYbn $Ht5iV&t+ReQ#; ic94P8W%YXj|}|N'z+J[k\'HM6p:<fO_&nOq4$$!3e DjZ}{H7~l]rx3*&>DT#c5y_x'M:0d^p!0afu#Sk>/p2 r8$x{-ZH-[I6|N_4?sK\HB]Qr6` tKD"S{Eq+3KmY3_j7vv)ygAqxoc6O_qwuug;>i"[l*Rc_0$a<[p=ndcA8jB# }YO,%@YX2H#v ^KO\ie=jQ[1<;%:k{ ^:z~e,,YYx_.Pm=K]B)M/|lJXxv~_vPX8^ $M-m|?IXltX<6gp	$`$0 FiX'-"(.eX6#<UkFZGu 4=4&TQ9 I#vv]o+]r]~!j0{FX/8|X
! -_55b{u]jr%	CFdL@(A*;
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(8?D< b g\g" oN h((((((3W )3W )(((((((:26pH?Z(/O5,/qj7^G($pNp+ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( > zwG]qx; I
(
(
(
(
(
(8_K [K|qxg4jYn",qyUu	8QW5- oY .: >+&tc2XM}R+3Ama05C':]ZCsK$ya1N d;MM6xLhD4mH*WA5a0I:F{9<fgy<bKgU71 |UGt5gaZv94\{!
cdo5(kv?n4.}^m.X4[LV/w|$b O{wo{=q&*_iqXvp1]K_%1pby-mTn _x^OmiVye[[qi [`&K_,0YSf$x|Q i}W:Xf[XIceBGw 7g<`kgyf4i-Q?f9D3l"bqg{owqyV"i$Ab `<F/?\AAE1A%Nrmx<j-w^Aqhm fx/*xQ<|]'dW,HGs'z@DKQ{/+y(
 p(->1L} Kp1=;]In@>^B xi?<Q~t,-9
@xCd/k 
>uGv[.`\LE@d$It}HjUR29 o_;x3q&qi4Q]y#t2vBrCg\`,5{pZi9;xVU;ncN[[Ck+GZJ=epXa]mVSI wu"X
>U Xbhog|T eL}PG& |B?&O d<1UwZkkC#~$+`/>?y_po$<s}<b<-? 	4+\i6	VkWI"Cm*PO]k%.VH@8-gX#:KB&F.C},bXNk;T5%;UF (j(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(8?D< b g\g" oN h((((((gms\u?ZmsjldS,G =}j!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k8C|E Ec  I 3X?G!" ?:( 7_V<g O   ox tA ? . 4/+3 ]' k3<'ZkO,dKM*(bHK -=iE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE Q\*+k0?DtHFf}9 @-iVxIWe`[`1#5/VWe5b8tq@4Vyiv../{X(ZYOeFV}_	ZNyYj<V1jw1A,P1)'@Uu]xGZN5V"wk>_x`x6q,Kl4Cn*OEs~5+Q.[afUbnpd^1-j>->&l;(,9w "K0 <Pk~=m?2j:Zyy+S^9?4ij\ @k;HeC<PIEc^*yMLw.X Ub	Q]x_y4I4w[Gu@=c z x>]""o!NF<M-YjkocO2C XE_V%%	|eb1 5N_x`x6q,Kl4Cn*OEpz_xE!5yI<'x 9	'xz-{KYHfc <qE jQE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE WI_|B]; ]6o,\X[L*v 7^  't	iO:iO6;UEf`mW;U9\E#4ihG|'-|7Fp+h?5nK=8zVh,@"Gpwd	(~c8I{Vn=	$.*1axP7m:u6~#o[VmI,>AL6F $Mgo<.V4]y_02oaTP=kU44eIJ27wi	 \gu\_e`*H;@+|So[70K	K)c 6c<-CefbIHAOf .o__P 3wqW28.H<=j"Wwi7>!3Bn,pAo4e]JF H 
hu;[_v]\<?i#9+k^tl3quoc[khQ	FC$nmq4P6:6x 9/%Ys2[g*jS~7VmKt65Kvk0y]`,= =gQeV	4H!UIMa?A&^/k:;eA	B
OQ@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@V<O9=_PvO;(1cFsu$Epx7Y?<sKAz<YD=#	.HT5m d( $WGBVyF/OM\xK_3{^_"nb>7dE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE W9GX?k"5uHw\*8D<y b Pdd
[a.!z1$[iOL&9
I|GQ(.rGQ7*C\2:u$Dv6c
}P @tQE |NM=SF] d7SAy1Ul=eA]Z_X]B;OkB;[X. DHr<u( ] QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE |`5o1woO$$]M bxHB2H3sx6Ru_2L[>{.OEj<a_x~=;6(4ZO&p91#Fu`=YFmf[A'5"BEnGa-w *<-W9/Kqf6veL+1FWOh?pv gn$V2GKu|[E;oX`4 xozV89c}kQE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE 2xxXmtuXzzx?C?-|7"i>vRIq'V|7K}&].ac1)XQ(V-lm`A"`8=PEPEPECwRB[IXP!Px#+/?e	O6p<wyurP#(^+9jw70oPOcB-fqqS(q7-
~OAK<@|?~#al$dC Z`y9 GXqm_jA:i$NgrYIb_h<&=i|G5T_JL$vC'
2ps6u-jYEcnJ-'$+eX7k]Zx?ck5[y<	Y(w`Sam|'!zg(.#}fv ^>lPWz-kz! tY4MF&fV$9Dv *;2LpZ_FEpXZYD =>\\<i'1	mF,NXPk(((Q@Q@Q@|[]h_Y<I|K}n+%otVZ$S[EoXkl'ae?-JWoIk	 Z49_LZ}EqOz)LvF+I}JOKrbDkl*O.$@BQ_01|><.G C91 hjry~>g;@"=+~$M]Es2a7'R-tA@EPE(((((((((((((((((((((((( B>1&`=F. -b\N@OZ
{|;oYE%b%)>0 di|S 7U /&3 
WgE q_ Mgw?K	  @g?| ] + Bo? }vtPOWs ?) *_]i|S 7U #Un4 .k[r%K}<h-5H] i|S 7U :( Bo? }g~ gi>e5KJrp00+3K	  i|S 7U :( Bo? }GwwB[i<IQ^/#k-e>GPk8]>o:}|okm1,hP?  */&3 
WgE q_ Mgw?K	  @g?| ] + Bo? }vtPOWs ?) *_]~O56=vo,niFr1mn	>%xL>8nKe8# +8c[j($;I'5| FM{ Ntm3 	k\1 ~>r \4 ) *_F %-SWg@g?| ] + Bo? }vtP	;QR)`#WC\xjnf.%UUc 
( Bo? }_ Mgw? ?) *_Y_muQ-<I	]c6;gPFn( Bo? }_ Mgw? ?) *__&|0Q?N]cnVOo9*\8C66+jXxc=2NI${@y|J-|%q^07k-#/pF@<V<IW-3LlQ5GX %)n72kvH o)(( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ?YnM]8ZbRVfxOg]'?'k0 h?yq;c4 ( ( ( ( ( ( ( ( ( ( ( ( +7 "372kvH o)+3H o)+((+<u8<c9%h#kNmfdbU<PCECawkc7V1,O6VV2ApA ( (7 "? JuJ> } c& k4-( oF R;:(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
{|;oYE%b%)>0nV|7K}&].ac1)XQ(r((((((((((((((:> } c& k 4-( oF R:xZMzmG]w>T49<"c;h4/|e45(Ehj)fh3 [ Ea\ ]2Ks;VUj"cG^V}?|wPmy,5@U;s+\2KmCstj_g 2b.mckzzRiUR8+9[Gu}"5/E*.5(+ndEfV#Am/ D[W2y mm 	sXj"q?4_M!pv3G$j ,S EvsLW2ZJ:FbJa$Bo-3iw iXv~*wZRLnS).tXCmwph+r=?hv6:$Bk;t Gn3mk	aMNYn{mlYDV#72kvH o)+_	iG5Fuy	[$Q#\nA/_k&5M)o?[gfx"~ <gEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPY WI ?>Oln:{|;oYE%b%)>0 nQE QE QE QE QE QE QE QE QE QE QE QE QE WoE5;]g\godw@ %-SV~!)%V[vh~).;o]#K?[T
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
{5|;qoK=5f%+0nWcPMc*\awx (Zep7]@(((o&$p	,$=Is
ElM-~]Yy_!x;w)~/67.w}6g  >7-uu{sfo'(7vOi:2A[{y!2_/ :$/7k)|G0ax.T+thNqHMsK=f}fO}mYl^iD/ * R!'~wtj7Ei9K']6#!W?#
Q6z-Qy7~- HNr 
uxWUL0)M[#1)w,8|&wIn6Q>f3e]SUWK|D^:n=j&ylc	c$#8$R|S!R[aq}Im\HB3|..-,j=ho,3};r6x3dorEW;A#gXH_ dnO\'W7Yye],H,ww4hzqKU`O x MOtuvgIym<hNu}1|63_DaIeJA  t Q@Q@Q@Q@q Q ^ vu| FM{ Nt i[Q b :vui[Q b :vt QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE x^IbJ:`Q^AO~j-/arvkwkh"]naFPkw>e.l0DzKL{"~Im1A5AN2u?! L'|<nVm[io]
-I]1ePs6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs??OIR?l{?%,Sb
|q^E qU 	oXht{};R=vvg,g*  vtQ@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@fxOg]'?'k0 h?yq;c6v>elrQ,~4EPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPXfn4-)tgqb#F"O$~Oa`vw iE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE Vl}7T}Z-.-(YIakrgsi[6Rvo`kJG/@QE QE U?YuSS,|.T=<xE#(x': (kLdn~o1,2R.84(Zv}a{~!]Fnv[:9hmn:r2Ef6F$';#sc:V QTYSQx}qhtFm:g<@kLlc~o%,Q4( :n h7?iH0gFFhPER5m?C_Q.V8B: O,?lRE|tIK57Mql(b  PaEAZ}{2kk4A,W 5&Aphj*Yj}!WG(eee A@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@fxOg]'?'k0 h?yq;cK.>:[+f<I=&? . 4/+3 ]' h_x>wfc?z=Mf/+3 ]' h 7_V<g O  P^G_	_?~\g
vg9 Q|6$hC{d-ghK0
OGG8#> ox tAX?@J 5*{|;k6Mir%|^L[(AO"Vil.a^NwZo}qlt_C|E Ec  I   ;Mn+;-5ah}i7N41@B;|?H6Y76:nPJ/${10C|E Ec  I  Y+jGy7ROcQ(IHs-7ET<d ~xd|J!" ?C|E Ec  ymzX[ISS/;6hl]^6a ?ek}W;aKD
Y`IP];k . 4/+3 ]' h5"g[-S;	b,Q+=[I],;]s~#Xd^V-Ef}I,d;
OC|E Ec  I  -W5O_>-MYBQk'LB?2A*r*]Z#XlR\E ]2i2oUTTW/+3 ]' h 7_V<g O  7Oj^oyxsH9~53D<-L	+=uo [x{Zk%*o
j{nH# 7_V<g O   ox tA$7k<u9i
]Y<Cy7s\J7U<+8}|[q^[x-:-f{tH]C$PS+#*d%f	^ ox tAX?@`a]R#?QfLKFdk3X?G!" ?;:+ 7_V<g O   ox tAxA]V{)8eduzzV|Us	^Hu!"31;qm@G<!W__jZiAJ[_On"RyN  So6E5/jz$RM5H TxAk((((((((((((((((((((((((((((((gsi[6Rvo`kJG/[?EtH Fj ( ( ( ( ( ( ( ( ( ( ( ( ( 372kv(#K?[T#K?[T
(
+/	zzLGgcsIV5O *:L~RxK7"n[<g<J hI5=
}{JV{`;~V>S\</q3VyuH,PSY7M 4Q\ Uk"ioGe,q49[1`+gXKHvyeWa1c|7F*hXj.R&8 2	EPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPXamQk(dsDe'{5|;qoK=5f%+0 nQE QE QE QE QE QE QE QE QE QE QE QE QE WoE5;]g\godw@ %-SWg^g }z":;Vscw69?N~E vtW - <flG 2U
 o~d0{ce1%*z S|MWZc5{{4xn-mOlfY\]+OR/I6  +,l|'y4zg$7%ZEPcg1! |UxEm!Ce5qc>YXherm Of5+0_.46=X~Mb[+XW/	tRd2XB/P5m[_.+$;!Ce1R|)M 9 _fw^'#InkjI;ct@l#t7h?U ;6_s5QkvY43F3r@%X ?T7/o^?_#V7&g-kM!h`m^ }'Ey_|/y5	J 6n=NrS8TUP; p+g<5v>O<oHn5 X aTg F( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 	 l + G m}'_67n?~{Va=>uGZ1Vo7( ( ( ( ( ( ( ( ( ( ( ( ( +7 "372kvH o)+3H o)+((((((372kvH o)(7 "? JuJ  ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( +w>e.l0DzY WI ?>Oln:(
(
(
+I3Mg.[v\y2mbs	"@mu-s%keX[lTnfe4W|ld-,<I,[-1Lo`6QiZ;;i[73.ou6`-
yPW?t+uTK&X%_ Vo0aCEZ7[N@Qq,,*P\dN(>3-{5w{[].).xHbeS*'*B:^4|3j2SQ-	8&	z'EY<($_VAmD$i5h1!r?z'>%xj+RmP`|3a-r>SFPrAazE[]m@x%5_J@BV ;;yMx']kK/5!hYABJm%%@ :+o^!|CafkZ"*F0t/	##sn`'6Z`Ko<q$e88`X`04E QE QE WoE5;]g\godw@ %-SWg^ax~;YynG
	T7/9[IJK.-;Qh+xJL'6,M~Uz#g~hC":^h21N"4~16ooAqoy~gyywg"ofQuqX6TUJWF/(y c]I	1sKI?|GmZ9RR+!3DhR$u\Me0-meP|HuV*v)	=]AH|Ky	,WYuz=fGmjm#@^v,n"+> B7ztyB8o >g@ _xK_P) u])hrV%'|Kgy4eV)hl$@iI;KNAx{tf<,s$0F g8 hY\Xj7xV%R?7?Khe#j@;gXF=(+0xJ'v m^}gZZL~}:Kmd$8{a@ Q ^ G NPsB,S[N[7#yX:MoGz7E QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE Xay9TR"b $`2k!u?
wk.;oT[Rhlc}pdpE|] oM.M51%+J:)h[i>$nK=*/=PoU$e 	|c<MPXjw>wqFHN2rrM Vqj-=hw+ <h=(VoiZ-Aw* =cX=
+r  ygeNw[xLufY4; QAE r.3^'"n 2H|#I|K<@n.tTo|
q!xB$
(/j :>On"bH  I 
iQqzV@Kh@BWk<mMhwUK2;p mn%=h%<vS6]qkk?T9K:[4l6 B0yS<{C<7-$(gr"F(WhUY|FM<z54x)! +hgHVwgu7u[|57?tx:itO2_ncW}An<$<71
_PO?jOG]4{46Rm0B"w$A-4[S&Y!`e2O$stPO_6645Ge.@ oxGI<Myv{ouuqS,antez*@v*.4B;]tEYM%b?mya>*->K]t0XV=RkxGEnQ@_ `:76=>Ukoiv"&x6<0(;iv%b,+x?5#@ nYCk32F'w;ZtP;P]iVeCIXDaaX_. E@U 28*x kX5i[Z\\Xa^8)nH&a_vX_YedASVG?M7pmASO-y]k^-^]EmT[H't QE QE QE QE QE QE2m}=	]]O<5,rS,I<kO tm;~c;wlQ[4PEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPY WI ?>Oln:{|;oYE%b%)>0 nQE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE V|7K}&].ac1)XQ+r<'  	|h<@tQE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE ;o vMVKK{9kJR}Xa?YnM]8ZbRPQ@Q@WOOtlymGUxmDe#iM. \|$g$ vWA7PQ|%58}:V>nhDbIroVVI7oKQWr#jQfh2jZ}JSRl8O-?#,Nmb" v<gZeiz,v'X$1 {Eo-KR__[[\jR%DnFE0G	{I;s[ukzU bnyV	Z0##+d[RY|4g'4A mM%DhTFiyv/_gp\itrMbt[ApCe+3n?so@ExW'mBXv`noiVIDf:[w`}cHrmH&B[:^gi[EW/BY GZa9oRflT|
?v GKOifZ\O=y["]O ExkuKMgbeK7f\BX4Cf|MWW}/E]mQdB"y$+owL=/;CKo#j-b8I"`NN~q
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
	K WI Moa|yh<cgmQivo~-uBO7@; @ 5; @ 5vtP / #Q / #WgE q; @ 5c5:6y[x_[	6@20$z]6+8m|-HR%X6x_\V[1-~gYwig:K}rUh&0K3c$
(`K~Kx9VP'h
keGm^cmikpc4 hwFYm| _s\k2I+A~i"( L`Lw	amKo}rIm1BR2">Y@E xt7KKam~Ml (T?
WRo
}Jb0f_$~i]x^E y'm4de!coBIp1i{6	-F'{fy Z6`l{>wI&)t<1:E7m^	~ooomLQmtAUyam7l6 E x	uim}r&-
QbP%*EG[$Y.12\*\7 b-NM{=~mb[lhGaoA f~kK4]%2eK7C / #WgE q; @ 5; @ 5vtP / #Q / #WgE | z<]>=V{k+g#e|1l`*Z3[!$trlnWVR; */?GNl5F[BaN^F,YyZ> } c& k 4?^q_7V2,rl4, +? JuJ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ?YnM]8ZbRVfxOg]'?'k0 h?yq;c4 ( ( ( ( ( ( ( ( ( ( ( ( +7 "372kvH o)+3H o)+/%ltK-nD.<qe-9};%>*Y[6"$su_:$`/dOD@_7#+0.t#FuK!yu(8X|Ox[TM>[f8	" }/E|^5lZ Fvm{ja]'@p!Z0_o%lotn[z=>6+f6en0Y\n`PW[OgWN[^[}?g	.LP@S[~!Ph<5^[?>S\\.Jef'4Eh:vY35kT>&)oxM Xq4m ;gdrf3;@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@a=>uGZ1Vo+w>e.l0DzEPEPEPEPEPEPEPEPEPEPEPEPEP\godw]q Q ^  d\xGzN|;jrYuL){>OWs 4-( oF R: ?) *_G?| ] +8/&3 
WOWs 3K	  i|S 7U :( Bo? }Tm"l4 6dwt	8Q
 i|S 7U i6og\57EUU Q@~,xh-`59y9Y"{x|m=Eo|5X^krZf	4}M	xnBr P	?A\ % -?S-_^>[R}JW$KnbHkJ	y@3'6?2h?v
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
"O$~Oa`vwil}7T}Z-.-(YIahr((((((((((((((:> } c& k 4-( oF R:4-( oF R: ( ( (M&tc270  gMM@B[muk	Sm4Y2.Pz@Q@q   N]q   N@Oldi]q?Q A vt QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE V|7K}&].ac1)XQ+r;WC&xPaX;1v (hzAm8&3=9  d9v
(
(
(2M[V:vvi~:}<%y6S;P-V55-.\;Y3#};>"Rfy.=^]YlR[F7.tQMK7w+9)'QeR@AV&ipzG}{d`Tbqpdtg9p_5$]uSL;Hnc%' 4#d=3Qk_[=*QC-s{	&$[uF<Ex_&'KP=WanU9_Nt>Eu+m#Dc:x~/>D]>NE;$#at NyxUA!5I=4P,q4C*4eax-OyN[[| xK~"O=t8{oj[	Cl,cnfGp) [FP %StBheVs'ty*[i14^GKi_}je;|K 23jv>&t-->lM7<OnZLmBZo+#?g%	.Rk{O<>k;]Z%M6=.U71h*+~x;Z5w\:
jZDQElqoVf(3;WdBC+S QE QE QE WoE5;]g\O#*+R0"<Zw*xp3hG N]R$0>6:l}m7O859hO<q2ekUop|cmLvzViC O[4b Pxxk^o	6lc\ K8 ZmC!7( xP<M%wY~iw3$~K+fo+"]hZws3++#[#-1O; M"8L!xxu??|my~pm@i?$?X.a_]4Ydiy[K9S!lyS\yL=SxgTZ.]G}(IYY_~Ioi"dy&n' y^KqXH4I`oY$3 Z :.kQ,u2[:et5u?K[M$w3}f^ NrmP/`o[vc|EdXk)6e1mn-MFcPwE,?f:
5- oY ..tR[:?_Asl@c>Y/?s,_Zk;W[(Z0?"BO+ ?Q A vu>#[k6#!73d QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE l.2<Wxw:YxL~ K[ej. i,ukw?0F9uk; vMIK{{kXJV"=Ta
 Z'_,Z&-4[Ausd9m?vAH?!lE ahzZvk'bIzD!\s}~2`Mu6f[(kr5C[Pge$?dev fy^vijmi2gCu$6b[1[pEs[PKi][V5po \Y SOV.+ m1ZtPEjx][-lAm ]:.-v	mX4Qfe(sT>E ff^ C 	O+g_ol wn Z-vyn7RCf%GtW>E azvk%`]GzJPH?!lE ahzZvk'bIzD!\s}~2`Mu6f[(kr5C[Pge$?dev fy^vijmi2gCu$6b[1[pEs[PKi][V5po \Y SOV.+ m1ZtPEjx][-lAm ]:.-v	mX4Qfe(sT>E ff^ C 	O+g_ol wn Z-vyn7RCf%GtW>E azvk%`]GzJPH?!lE ahzZvk'bIzD!\?_z="dn$IwyM_)(|}'VL&0sd%'DU>q]acaY[YZDx8P ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 	 l + G m}'_67n?~{Va=>uGZ1Vo7( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( +w>e.l0DzY WI ?>Oln:(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
{|;oYE%b%)>0nV|7K}&].ac1)XQ(r(((7^-ugt%BX'Ei`+J(1MK Uj_oH1Msbs@ATW6Vs^]F,Qd' _?Ek?
xZ36ZZ), LF`xz t	n"'+dP
G#@W +/ eO6&)0t T }?*mnYgV.T`ut_x#z-2(A}Do	(d]L8$YZd!;u+icDF_<?iq}#ZHR]-xcKw+JI/C1- +k~.admm\l!1v F~~!lI{Vco[gXY>a!Q&9$w|eyKxO8{oBh=tx\5 {Fzdo5]dwWUid1|N1W4ksjQu%]GR*0#
+> >Z6[xn!b	&8` B9<a?k^#opy,gn@`2c;m5m>VVK)	L`xXIy\GFX+ g#p8zxS|?4@72K#(IL,rkigBymB=VSP
l *  {]Q@Q@Q@h> 7we;]UbT_J(((((((((((((((((((((((((((((((^$?5MaK	"v2OgmQivo~-uBO7@ I ? . 5@g!" ?C|E Ec vtP ox tAX?]/+3 ]' h 7_V<g O  gE q I ? . 5@g!" ?C|E Ec vtP ox tAX?]/+3 ]' h 7_V<g O  gE q I ? . 5@g!" ?C|E Ec vtP ox tAX?]/+3 ]' h 7_V<g O  gE q I ? . 5@xq}\kxvGWHHnN[P'vG4OG,ZbM(.kfNJD`q^\godw@)?/|9xS-6I"i@1[<]qG N] QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE k; vMIK{{kXJV"=Ta
	 l + G m}'_67n?~{PQ@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@q Q ^ vu| FM{ Nt i[Q b :vui[Q b :vt QE QE QEgk:mcOsQ{hv1#$;0eA; 4(xY|=kz,2Kb
	?4~((((((((((((((((((((((((((gmQivo~-uBO7[k; vMIK{{kXJV"=Ta
 ( ( ( ( ( ( ( ( ( ( ( ( ( 372kv(#K?[T Fu f +zF h\cvC|E Ec  q|	tXq=W2[6muwc!~$^X7v?b7&L1C1^H  k? . 4/+3 ]' hQiPLm{Khgh3:gi7"A_#g%iEXYcI]c2JfdIbv I ? . 47?L)nay6 d6 Vv=d^<24vM{g!" ?C|E Ec  y1S4Km&&mRncw9[~%\I7O>_xc-irpa>?Hbk . 4/+3 ]' hAjuMsN.]Z=Zq#5i;]JoUPa#!YuZ:Ji}SI
L[O/X'2Yad>b 2}[X?G!" ?4~i7tM/Q[HK>8Fn{Nq(gX#U  . 5 gw5|'du{! p2wmq@j^Yq}ySXJ{t<)<'V\"5=~HomT)&$ *E}A 4E QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE Vg #v=NgmQivo~-uBO7@QE QE QE QE QE QE QE QE QE QE QE QE QE | FM{ NuoE5;]oGz7oGz7EPEPEPEPEPEPoE5;]oGz7| FM{ Nti[Q b : vtQE Q\uop^J"bY#d*S!PH g:Z+k4<K[YG)r6h%1;~lm'G-!mxDQnbNF*va@$@?i=jG]F(i,#Uy>ea_W/m[X\\-l#lEf QEr#iIMe+)WPa2NA $k_.	& t_h @3^mZu)X X
Z5vk{]xBD
QIbpH4Q\ihWB\Q"x+rqT"Zvm.Z|NIHE uW^xZR\Coc
[`\P2GxWZOMI@[y )crPzPCiIn
8PIugOVHRv8GA[ m^'M6M&w4)oWypF0k;bXov^fMN{#O]DBEf`8Ub ;+>"xZOwP\KapE,	&hqyN#UO|KYicP[""|1dmYTl	qE)/~!6u7o$[GzIU4{\ +> }ln	\^<b++s*UT2+XEOtUor8yc6-qo5]D$=F	^WIy3\MwX:%zTeV[# EPEPEPEPEPEPEPEPEPXfn4-)tgqb#F"O$~Oa`vw iE QE QE QE QE QE QE QE QE QE QE QE QE WoE5;]g\godw@ %-SWg\f %-SWg@Q@Q@Q@Q@Q@Q@godwF %-SQoE5;]o/]l|]qyi\sEq~Iq<Xdg( ?{ZY-M$m+:y2o"C+ #
Fk(k!/tbKX[/OpfHSb_'n%k0jL/`bQ3vvOMkR[SKk8k`2h[	44Y`IUWY7I< B) U'<3;>ogp'cIt[NQ][JG") @Q~#}
h7C58-]D>wx7^$].q4ep  ;tP\WsanP[Z-qGkum4rqeUFcVBwW7sCk.5GWaI*3 ~x?WMCk:]AnA2|Tqt_kq=D EgIa)amzc0[Y)NQk`|(a#W+gbwMx}JHb}JQ@~z=c_uG]b2Nr|;[K>wb'Ram ()qi72f#D5 tq"@+AQ>}NVieB4 V5(#h${=V_ch/.?ub9^ns#AWu;f>></^j&UHKc~oF$ N
hfOu%^<"P$(j'`61 uR-6O)zpqq|@[qE y_ul-tu+okEo,q\yrEby}Yu%H`O_wfj>Z:2%g^LFcRAb?u3xO g[_P]	Y[8#h(((((((((gmQivo~-uBO7[[I*Km>qU (Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@pM#7tKk:k2;# 5@"kw%BV|iE1q!$zzWME QE QE QE QE QE QEVOkNdZ;O.[%jfJ7 xak?
~>"ho}[Jxn$*fE>8RI /+3 ]' h 7_V<g O  gE q I ? . 5@g!" ?UZZ|Dq>qVmvf$k eO.SZs{t0#U=h
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
~*x~k)`t-RG_3q237=
EilT	#FCVVR
A  xO^xOw>vEC)U$T|ZG?VoBj?i%	Rrk]Y^x> c^eR
FvVcFqv@-//5O{}6dI6dM9?wVeZfgq7BHoSdrFs[_m+\i6dy)T |o<_rMjO&Klr4';xr:OSKt|AjZOuK{mBP5x~q4,*U|n@DHP@P7NTtxZ+x~[=AJ ej&vkrZ<sZE&!v&6Tx |OxBdgLTPe2HNprxY[$&.a%IJ&]6(W s!jz;)}kO7[v`$%X)8&E]/t[q/fZw_6H`1fh|>=>"56[%H'{\y2N_kIGAk)k0BhhOfAsf`@X|[,F:M$+w(B[8:~V>o=GVnu;y4w
U/QHU(((((((((((((((((((((((((((((((((((((((((Ac5K
fw8BHoj \Ic1	 UGssuMTrQG~XSM;6CZonVKS'O>Q1{VmKrU&B HFJ(:y}9.%krF{w< *N rHTc=W6U)*AC:}gbMboOJdh( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (49yz7iWi\gj oJ&;I+kD5'WG0=4 (
ho,wc%OH
+_EO]d">Cr((((((((((((((((((((((((((((((((((((((((((((KG"+2+PkH|&_f[^~RU`5s^$^I-C[IF	s-j %eee9B:F*-?i!+U9V)(E<&i5mm mat2EK Y1z(f3h:ljWP^%\ UQI$>W?C(}K w6E^4pG2S#NOEPEPEx]-#PS`L2%jeo9 ,x[^0 givPiZ4'qmTHTWG_/Ki|t9,.%[)- 6XXqhp|ixvEh46)gm L,r@=_z+O~,^[."]J%Y2E2 K%l+]aKCOhLe@a*	p *+wOT]zeKVq[T QE QE Q@9( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( 6-,kZ]9Ikd,hff2q<w-[SQFH,$pgOWs ?) *_]i|S 7U /&3 
WgE q_ Mgw?K	  @g?| ] + Bo? }vtPOWs  sCq;]p`#v2@ Q@g?| ] +>#k]x<_]U8GB	 ]i|S 7U /&3 
WgE q_ Mgw?K	  @g?| ] + Bo? }vtP?<qB/i>tm'>,6[?N8a7n[#b9FpxB/*qmxI$!oE5;]&_#2OG9c{ "Ck3H o)+((((((((((((((((((((((((((((((((((<5/]~W?$>|juMEg9+#^LEF=PQ@Q@Q@Q@Q@Q@Q@Q@Q@q Q ^ vu| FM{ Nt i[Q b :vui[Q b :vt QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE Vn$Lj4.0ZEd#{8tOw_w h k ( ( ( ( ( ( ( ( ( 372kv(#K?[T#K?[T
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
(
<6v-vqSQvJ4}#rdX~EK}2!j(ie_A7( ( ( ( ( ( ( ( ( +7 "372kvH o)+3H o)+((((((((((((((((((((((((((((((((((<5/]~W?$>||[oZ7^!c]kHh9U9";+/7:3H|e!P>sRq QE QE W!q3v mqMZd8&".A_^*~-lmuRQ/B/s=0U_(@b%s3];"
766/T5w?Ot}	8Qof1JTn lu{
Xvt<p3<PUkokj[ o`%
yt$i-0i\KcEAv%0Lg& 	G}mW:
;%WiDI0.r0fsT`M>W 4{y{<*%Mrvnq4EPEPEP\godw]q Q ^  G N]qG N] QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE QE /m#	A<KV7"dm	cpUrWkv0+;oGY(F%a'*9V6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs6ZkOapq[Pg#$? a^WDOg}m[io]
-I]1ePs(6ZkOapqV?! L'|<nVm[io]
-I]1ePs??OIR?l{?%,Sb
|q^E qU 	oXht{};R=vvg,g*  vtQ@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@module.exports = require('./src/index');
{
  "name": "@postman/hermes",
  "version": "1.1.4",
  "description": "",
  "main": "index.js",
  "engines": {
    "node": ">=7.0.0"
  },
  "scripts": {
    "prepush": "npm run test-lint",
    "prepublish": "npm test",
    "test": "npm run test-lint && npm run test-node && npm run test-bash",
    "build-docs": "jsdoc src",
    "test-node": "nyc mocha ./tests/unit/node/*.test.js --timeout=120000",
    "test-bash": "bash ./tests/unit/bash/test.sh",
    "test-lint": "eslint .",
    "report": "nyc report --reporter=html"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@bitbucket.org/postmanlabs/hermes.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "homepage": "https://bitbucket.org/postmanlabs/hermes#readme",
  "dependencies": {
    "rimraf": "2.6.3"
  },
  "devDependencies": {
    "chai": "^4.1.2",
    "eslint": "^4.18.2",
    "eslint-config-airbnb-base": "^12.1.0",
    "eslint-plugin-import": "^2.9.0",
    "eslint-plugin-mocha": "^4.12.1",
    "http-server": "^0.11.1",
    "husky": "^0.14.3",
    "jsdoc": "^3.5.5",
    "mocha": "^5.0.4",
    "nyc": "^11.6.0"
  }
}
# Hermes (Linux auto-updater)

It is been used in the Postman Electron app to implement the auto-update feature.

The basic functionalities of hermes is to

  - Download the update
  - Extract the app
  - Swap and re-opens the app


  ```javascript

    const hermes = require('postman-app/hermes');

  ```

Usage:

![Usage](/docs/images/usage.jpg)

# Methods

## Method: 'hermes.init(initInputData)'

  - `initInputData` Object
  - `initInputData.packageName` String

### Returns `initOutputData`

  - `initOutputData` Object
  - `initOutputData.packageName` String
  - `initOutputData.eID` String

  It generates the unique `eID` (execution ID), which needs to be used for further processing in the module.

## Method: 'hermes.download(downloadInputData)'

  - @extends `initOutputData`
  - `downloadInputData.downloadURL` String
  - `downloadInputData.downloadDirectory` String
  - `downloadInputData.downloadChecksum` [String] Optional
  - `downloadInputData.downloadChecksumAlgorithm` [String] Optional defaults to `sha1` if `downloadInputData.downloadChecksum` is provided

### Return `downloadOutputData`

  - @extends `downloadInputData`
  - `downloadOutputData.downloadInfo` Object
  - `downloadOutputData.downloadInfo.status` String Which will have values `CHECKSUM_ERROR, DOWNLOAD_COMPLETED, DOWNLOAD_ERROR, INVALID_ARGUMENT_ERROR`
  - `downloadOutputData.downloadInfo.error` [Error]

  It Downloads the file from the `downloadInputData.downloadURL` to the `downloadInputData.downloadDirectory` and provides the downloadInfo along with the downloadInputData as `downloadOutputData`. It does the checksum if the `downloadInputData.checksum` is provided.

## Method: 'hermes.extract(extractInputData)'

  - `extractInputData` alias `downloadOutputData`

### Return `extractOutputData`

  - @extends `extractInputData`
  - `extractOutputData.extractInfo` Object
  - `extractOutputData.extractInfo.status` String Which will have values `MKDIR_DIRECTORY_FAILED, 'INVALID_ARGUMENT_ERROR','EXTRACTION_FAILED', 'EXTRACTION_SUCCESSFUL'`
  - `extractOutputData.extractInfo.error` [Error]

  It extracts the `tar.gz` in parallel to the place the file has been downloaded `downloadInputData.downloadDirectory`.

## Method: 'hermes.swap(swapInputData)'

  - `swapInputData` alias `extractOutputData`

### Return `swapOutputData`

  - @extends `swapInputData`
  - `swapOutputData.swapInfo` Object
  - `swapOutputData.swapInfo.status` String Which will have values `MKDIR_DIRECTORY_FAILED, 'INVALID_ARGUMENT_ERROR','EXTRACTION_FAILED', 'EXTRACTION_SUCCESSFUL'`
  - `swapOutputData.swapInfo.error` [Error]

  It will do the following things
  - rename the old package `postman/app` to `postman/$eid-old`
  - rename the newly extracted package `postman/$eid` to `postman/app`
  - kill the parent process (old app) if it's still running
  - launch the new app

## Method: 'hermes.clear(clearInputData)'

  - `clearInputData.appName` String
  - `clearInputData.directory` String

### Return `clearOutputData`

  - @extends `clearInputData`
  - `clearOutputData.clearInfo.status` String Which will have values `'INVALID_ARGUMENT_ERROR', 'FILE_ACCESS_ERROR', 'CLEAR_COMPLETED'`
  - `clearOutputData.clearInfo.error` [Error]

  It will clear the previously downloaded files and folders in specified directory `clearInputData.directory` and clears only the files and folders which are specified in a pattern. Patterns starts with `appName-[0-9]*`, so every file or folder which starts with pattern gets deleted.

  Files that should come with the pattern:
  - `appName-xxxxxxxxxxx.tar.gz`
  - `appName-xxxxxxxxxxx-old`
const { removeOnly } = require('./util'),

      INVALID_ARGUMENT_ERROR = 'INVALID_ARGUMENT_ERROR',
      DELETE_ERROR = 'DELETE_ERROR',
      CLEAR_COMPLETED = 'CLEAR_COMPLETED';

/**
 * Defines the basic properties needed for clearing a directory.
 * @typedef {object} clearInputData
 *
 * @property {String} directory the directory to clean
 *
 * @example
 * {
 *   appName: 'somePackage',
 *   directory: 'User/PathForExtractDirectory'
 * }
 *
 */

/**
 * @typedef {String} clearStatus
 * It holds the value of either one of
 * 'INVALID_ARGUMENT_ERROR', 'FILE_ACCESS_ERROR', 'CLEAR_COMPLETED'
 */

/**
 * @typedef clearInfo
 * The below object holds key properties defining the information for clearing process
 *
 * @property {clearStatus} status
 * @property {?Error} [error]
 *
 * @example
 * {
 *   status: 'CLEAR_COMPLETED',
 *   error: null
 * }
 */

/**
 * @typedef clearOutputData
 * All the properties present in the return value
 *
 * @extends clearInputData
 * @property {clearInfo} clearInfo
 *
 * @example
 * {
 *   appName: 'somePackage',
 *   directory: 'User/PathForExtractDirectory',
 *   clearInfo: {
 *     status: 'CLEAR_COMPLETED',
 *     error: null
 *   }
 * }
 *
 */

/**
 * @callback clearResponseCallback
 * @param {?Error} error
 * @param {clearOutputData} data
 *
 */

/**
 * @method clear
 * @description This will clear the given directory
 * leaving only the `app` directory and `appName` executable file
 * @param {clearInputData} clearInputData
 * @param {clearResponseCallback} callback
 * @throws {InvalidParamsException}
 */
function clear(clearInputData, callback) {
  if (!callback) {
    throw new Error('InvalidArgumentException: Hermes~clear - callback is a required parameter');
  }

  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~clear - callback should be of type function');
  }

  const clearOutputData = Object.assign({}, clearInputData, {
    clearInfo: {
      status: null,
      error: null,
    },
  });

  if (!clearInputData) {
    const err = new Error('InvalidArgumentException: Hermes~clear - clearInputData is a required parameter');
    clearOutputData.clearInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, clearOutputData);
  }

  if (typeof clearInputData !== 'object' || Array.isArray(clearInputData)) {
    const err = new Error('InvalidArgumentException: Hermes~clear - clearInputData should be of type object');
    clearOutputData.clearInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, clearOutputData);
  }

  if (!clearInputData.directory) {
    const err = new Error('InvalidArgumentException: Hermes~clear - clearInputData.directory is a required field');
    clearOutputData.clearInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, clearOutputData);
  }

  if (typeof clearInputData.directory !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~clear - clearInputData.directory should be of type string');
    clearOutputData.clearInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, clearOutputData);
  }

  if (!clearInputData.appName) {
    const err = new Error('InvalidArgumentException: Hermes~clear - clearInputData.appName is a required field');
    clearOutputData.clearInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, clearOutputData);
  }

  if (typeof clearInputData.appName !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~clear - clearInputData.appName should be of type string');
    clearOutputData.clearInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, clearOutputData);
  }

  const directoryToClean = clearInputData.directory,
        { appName } = clearInputData,
        patterns = `${appName}-[0-9]*`, // delete only the ${appName}-${eid} and ${appName}-${eid}-old
        fileSystemModule = clearInputData.fileSystemModule || require('fs');

  return removeOnly({ rootDirectory: directoryToClean, patterns, fileSystemModule }, (err) => {
    if (err) {
      clearOutputData.clearInfo = { status: DELETE_ERROR, error: err };
      return callback(err, clearOutputData);
    }

    clearOutputData.clearInfo = { status: CLEAR_COMPLETED, error: null };
    return callback(null, clearOutputData);
  });
}

module.exports = clear;
const path = require('path'),
      { getChecksumForFile, downloadFile } = require('./util'),
      CHECKSUM_ERROR = 'CHECKSUM_ERROR',
      DOWNLOAD_COMPLETED = 'DOWNLOAD_COMPLETED',
      DOWNLOAD_ERROR = 'DOWNLOAD_ERROR',
      INVALID_ARGUMENT_ERROR = 'INVALID_ARGUMENT_ERROR';


/**
 * The below object defines the basic properties needed for starting the download.
 *
 * @typedef downloadInputData
 *
 * @extends initOutputData
 * @property {String} downloadURL The download URL from which the download needs to happen
 * @property {String} downloadDirectory The absolute path to which the download needs to be done.
 * @property {String} [downloadChecksum] The checksum of the binary which will be downloaded
 * @property {String} [downloadChecksumAlgorithm = 'sha1'] The algorithm to be used
 *
 * @example
 * {
 *   eID: 'pack-xxx',
 *   packageName: 'pack',
 *   downloadURL: 'http://sample.com/foo.tar.gz',
 *   downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b'
 *   downloadChecksumAlgorithm: 'sha1'
 * }
 *
 */

/**
 * downloadInfo
 *
 * @typedef {String} downloadInfo
 *
 * They holds the values of either one of
 * 'CHECKSUM_ERROR','DOWNLOAD_ERROR','DOWNLOAD_COMPLETED','INVALID_ARGUMENT_ERROR'
 */

/**
 * The below object holds key properties defining the downloaded information
 *
 * @typedef downloadInfo
 *
 * @property {downloadInfo} status The status of the download.
 * @property {?Error} [error] Will be null initially and hold the error in case of failures.
 * @property {String} downloadDirectory The absolute location of the download Directory
 *
 * @example
 * {
 *   status: 'DOWNLOAD_COMPLETED',
 *   error: null
 *   downloadDirectory: 'User/PathForDownloadDirectory'
 * }
 */

/**
 * The below object defines the basic properties which defines
 * the download status at the end of download process.
 *
 * @typedef downloadOutputData
 *
 * @extends downloadInputData
 * @property {downloadInfo} downloadInfo
 *
 * @example
 * {
 *   eID: 'pack-xxx',
 *   packageName: 'pack',
 *   downloadURL: 'http://sample.com/foo.tar.gz',
 *   downloadDirectory: '/some/directory'
 *   downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b'
 *   downloadChecksumAlgorithm: 'sha1',
 *   downloadInfo {
 *     status: 'DOWNLOAD_COMPLETED',
 *     error: null,
 *     downloadDirectory: 'User/PathForDownloadDirectory
 *   }
 * }
 *
 */

/**
 * @callback downloadResponseCallback
 * @param {?Error} error
 * @param {downloadOutputData} data
 *
 */


/**
 * @method __runCheckSum
 * @private
 *
 * @param {String} filePath The path to the file for which checksum needs to be done
 * @param {String} checksum The hash to which the checksum needs to be compared with.
 * @param {String} algorithm Them algorithm to be used.
 * @param {checksumCallback} callback The callback function where
 */
function runCheckSum(filePath, checksum, algorithm, cb) {
  getChecksumForFile(filePath, (checksumError, hash) => {
    // If any error, just bubble that up.
    if (checksumError) {
      cb(checksumError);
      return;
    }
    // Once the hash is received, then check for it's equality mismatch,
    // if any mismatch, give it as error.
    if (checksum !== hash) {
      const error = new Error('Checksum failed: Hermes~download - mismatch in the checksum provided and the file downloaded');
      cb(error);
      return;
    }
    cb(null);
  }, { algorithm });
}


/**
 * @method download
 * @description This will download the file
 * @param {downloadInputData} downloadInputData This holds the details on the module output
 * @param {downloadResponseCallback} callback The final status of the download will responded here
 * @param {Object={}} options The additional options to the module.
 * @param {String=} options.downloadDirectory The directory to which the app needs to be downloaded.
 * @throws {InvalidArgumentException}
 */
module.exports = function download(downloadInputData, callback) {
  // Bail out if callback is not available.
  if (!callback) {
    throw new Error('InvalidArgumentException: Hermes~download - callback is a required param');
  }

  // Bail out if the downloadInputData is not an object
  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~download - callback should be of type function');
  }

  // Bail out if the downloadInputData is not an object
  if (typeof downloadInputData !== 'object' || Array.isArray(downloadInputData)) {
    callback(new Error('InvalidArgumentException: Hermes~download - downloadInputData should be of type object'));
  }

  const { eID, downloadURL, downloadChecksum, downloadDirectory, downloadChecksumAlgorithm = 'sha1' } = downloadInputData,
        downloadOutputData = Object.assign(
          {},
          downloadInputData,
          {
            downloadInfo: {
              status: DOWNLOAD_COMPLETED,
              err: null,
            },
          },
        );

  // Bail out if downloadInputData.eID is not not of type string.
  if (typeof downloadInputData.eID !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.eId should be of type string');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }

  // Bail out if downloadInputData.eID is not available.
  if (!downloadInputData.eID.trim()) {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.eId should not be empty');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }

  // Bail out if downloadInputData.downloadURL is not of type string.
  if (typeof downloadInputData.downloadURL !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should be of type string');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }

  // Bail out if downloadInputData.downloadURL is not available.
  if (!downloadInputData.downloadURL.trim()) {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should not be empty');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }

  // Bail out if downloadInputData.downloadURL is not of type string.
  if (typeof downloadInputData.downloadDirectory !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should be of type string');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }

  // Bail out if downloadInputData.downloadDirectory is not available.
  if (!downloadInputData.downloadDirectory.trim()) {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should not be empty');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }

  // if checksum is provided it should be of type string
  if (downloadInputData.downloadChecksum && typeof downloadInputData.downloadChecksum !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~download - downloadInputData.downloadChecksum should be of type string');
    downloadOutputData.downloadInfo = {
      status: INVALID_ARGUMENT_ERROR,
      error: err,
    };
    callback(err, downloadOutputData);
    return;
  }
  /**
   *  app
   *    - Resources
   *      - app
   *        - node_modules
   *            - hermes
   *               - src
   *                  - download
   */
  const downloadPath = path.resolve(downloadDirectory, `${eID}.tar.gz`); // @todo user should be able to provide option for extension and extraction


  downloadFile(downloadURL, downloadPath, (err) => {
    // Just bubble up the error received from the downloader
    if (err) {
      downloadOutputData.downloadInfo = {
        status: DOWNLOAD_ERROR,
        error: err,
        downloadDirectory,
      };
      callback(err, downloadOutputData);
      return;
    }

    if (!downloadChecksum) {
      // Reaching here specifies, download completed and checksum is not needed.
      downloadOutputData.downloadInfo = {
        status: DOWNLOAD_COMPLETED,
        error: null,
        downloadDirectory,
      };
      callback(null, downloadOutputData);
      return;
    }

    runCheckSum(downloadPath, downloadChecksum, downloadChecksumAlgorithm, (checksumError) => {
      downloadOutputData.downloadInfo = {
        status: checksumError ? CHECKSUM_ERROR : DOWNLOAD_COMPLETED,
        error: checksumError,
        downloadDirectory,
      };
      callback(checksumError, downloadOutputData);
    });
  });
};
const { exec } = require('child_process'),
      path = require('path'),
      MKDIR_DIRECTORY_FAILED = 'MKDIR_DIRECTORY_FAILED',
      INVALID_ARGUMENT_ERROR = 'INVALID_ARGUMENT_ERROR',
      EXTRACTION_FAILED = 'EXTRACTION_FAILED',
      EXTRACTION_SUCCESSFUL = 'EXTRACTION_SUCCESSFUL';

/**
 * @typedef {downloadOutputInfo} extractInputData
 * The below object defines the input object for this module for extraction.
 *
 * @example
 * {
 *   eID: 'pack-xxxx',
 *   packageName: 'pack',
 *   downloadURL: 'http://sample.com/foo.tar.gz',
 *   downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b'
 *   downloadChecksumAlgorith: 'sha1',
 *   downloadInfo: {
 *     status: 'DOWNLOAD_COMPLETED',
 *     error: null,
 *     downloadDirectory: 'User/PathForDownloadDirectory'
 *   }
 * }
 */

/**
 * @typedef {String} extractStatus
 *
 * They holds the value of either one of
 * 'MKDIR_DIRECTORY_FAILED','INVALID_ARGUMENT_ERROR','EXTRACTION_FAILED','EXTRACTION_SUCCESSFUL'
 *
 */

/**
 * @typedef extractInfo
 * The below object holds key properties for defining the extracted information
 *
 * @property {extractStatus} status The status of the extraction process.
 * @property {?Error} [error] Will be null initially, initialized to the error in case of failures
 * @property {String} [extractDirectory] Path where the .tar file is extracted
 *
 * @example
 * {
 *   status: 'EXTRACTION_SUCCESSFUL',
 *   error: null,
 *   extractDirectory: 'User/PathForExtractedDirectory'
 * }
 */

/**
 * @typedef extractOutputData
 * The below object defines all the properties present in the return value
 *
 * @extends extractInputData
 * @property {extractInfo} extractInfo
 *
 * @example
 * {
 *   eID: 'pack-xxxx',
 *   packageName: 'pack',
 *   downloadURL: 'http://sample.com/foo.tar.gz',
 *   downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b'
 *   downloadChecksumAlgorithm: 'sha1',
 *   downloadInfo: {
 *     status: 'DOWNLOAD_COMPLETED',
 *     error: null,
 *     downloadDirectory: 'User/PathForDownloadDirectory'
 *   },
 *   extractInfo: {
 *     status: 'EXTRACTION_SUCCESSFUL',
 *     error: null,
 *     extractDirectory: 'User/PathForExtractedDirectory'
 *   }
 * }
 *
 */

/**
 * @callback responseCallback
 * @param {?Error} error
 * @param {extractOutputData} data
 */

/**
 * @method extract
 * @description Used to extract the .tar file downloaded in the desired directory
 * @param  {extractInputData} extractInputData
 * @param  {responseCallback} callback
 * @throws {InvalidParamsException}
 */
module.exports = function extract(extractInputData, callback) {
  // Bail out if invoked without callback
  if (!callback) {
    throw new Error('InvalidParamsException: Hermes~extract - callback should not be empty');
  }

  // Bail out if callback is not a function
  if (typeof callback !== 'function') {
    throw new Error('InvalidParamsException: Hermes~extract - callback should be of type function');
  }

  const extractOutputData = Object.assign({}, extractInputData, {
    extractInfo: {
      status: null,
      error: null,
      extractDirectory: null,
    },
  });

  // Bail out if invoked without extractInputData
  if (!extractInputData) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData should not be empty or false');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if extractInputData is not a object
  if (typeof extractInputData !== 'object' || Array.isArray(extractInputData)) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData should be of type object');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if invoked without extractInputData.eID
  if (!extractInputData.eID) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.eId should not be empty');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if extractInputData.eID is not of type string.
  if (typeof extractInputData.eID !== 'string') {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.eId should be of type string');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if invoked without extractInputData.packageName
  if (!extractInputData.packageName) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.packageName should not be empty');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if extractInputData.packageName is not of type string.
  if (typeof extractInputData.packageName !== 'string') {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.packageName should be of type string');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if invoked without extractInputData.downloadInfo
  if (!extractInputData.downloadInfo) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo should not be empty');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if extractInputData.downloadInfo is not a object
  if (typeof extractInputData.downloadInfo !== 'object' || Array.isArray(extractInputData.downloadInfo)) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo should be of type object');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if invoked without extractInputData.downloadInfo.downloadDirectory
  if (!extractInputData.downloadInfo.downloadDirectory) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.downloadDirectory should not be empty');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if extractInputData.downloadInfo.downloadDirectory is not a string
  if (typeof extractInputData.downloadInfo.downloadDirectory !== 'string') {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.downloadDirectory should be a string');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if invoked without extractInputData.downloadInfo.status
  if (!extractInputData.downloadInfo.status) {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.status should not be empty');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  // Bail out if extractInputData.downloadInfo.status is not equal to 'DOWNLOAD_COMPLETED'
  if (extractInputData.downloadInfo.status !== 'DOWNLOAD_COMPLETED') {
    const err = new Error('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.status should be equal to DOWNLOAD_COMPLETED');
    extractOutputData.extractInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, extractOutputData);
  }

  const filePath = extractInputData.downloadInfo.downloadDirectory,
        { eID } = extractInputData,
        packName = extractInputData.packageName;

  // should create a new directory in the filePath
  // (extractInputData.downloadInfo.downloadDirectory)
  exec(`mkdir "${path.resolve(filePath, eID)}"`, (mkdirError) => {
    if (mkdirError) {
      extractOutputData.extractInfo = {
        status: MKDIR_DIRECTORY_FAILED,
        error: mkdirError,
        extractDirectory: filePath,
      };
      return callback(mkdirError, extractOutputData);
    }

    // should extract the downloaded file in the directory made in the above exec command
    // xzf are arguments to the tar command:
    // x: --extract (extract files from an archive)
    // z: --gzip
    // f: --file use archive file
    // --strip-components=NUMBER: strip NUMBER leading components from file names on extraction

    exec(`tar -xzf "${path.resolve(filePath, `${eID}.tar.gz`)}" -C "${path.resolve(filePath, eID)}" --strip-components=2 "${packName}/app/"`, { maxBuffer: Infinity }, (extractError, stdout, stderr) => {
      if (extractError) {
        extractOutputData.extractInfo = {
          status: EXTRACTION_FAILED,
          error: extractError,
          extractDirectory: filePath,
          standardOutput: stdout,
          standardError: stderr,
        };
        return callback(extractError, extractOutputData);
      }

      // reached this state when extraction is successfully done
      extractOutputData.extractInfo = {
        status: EXTRACTION_SUCCESSFUL,
        error: null,
        extractDirectory: filePath,
        standardOutput: stdout,
        standardError: stderr,
      };
      return callback(null, extractOutputData);
    });
  });
};
module.exports = {
  init: require('./init'),
  download: require('./download'),
  extract: require('./extract'),
  swap: require('./swap'),
  clear: require('./clear'),
};
/**
 * The object below provides the basic configurations needed to pass to the init function
 * @typedef initInputData
 *
 * @property {String} packageName the package name for which the init generates the execution id.
 *
 * @example
 * {
 *    packageName: 'blah'
 * }
 */

/**
 * The below object provides the information available in the initOutputData.
 * @typedef initOutputData
 *
 * @extends initInputData
 *
 * @property {String} eID the unique id generated with the combination of packageName and timestamp.
 *
 * @example
 * {
 *    packageName: 'blah',
 *    eID: 'blah-1522229136510'
 * }
 */

/**
 * @method init
 * @description It will be used to generate the eID (Execution ID)
 *              This eID(execution ID) will be used for the other processes in the module.
 * @param {initInputData} initInputData
 * @throws InvalidArgumentException
 * @returns {initOutputData}
 */
module.exports = function init(initInputData) {
  // Bail out if the updateInfo is empty
  if (!initInputData) {
    throw new Error('InvalidArgumentException: Hermes~init - initInputData should not be empty');
  }

  // Bail out if the updateInfo is not an object
  if (typeof initInputData !== 'object' || Array.isArray(initInputData)) {
    throw new Error('InvalidArgumentException: Hermes~init - initInputData should be of type object');
  }

  if (typeof initInputData.packageName !== 'string') {
    throw new Error('InvalidArgumentException: Hermes~init - initInputData.packageName should be of type string');
  }

  // Bail out if the updateInfo.packageName is empty
  if (!initInputData.packageName.trim()) {
    throw new Error('InvalidArgumentException: Hermes~init - initInputData.packageName should not be empty');
  }

  // Reaching here ensure that updateInfo.packageName is available and it is a string.
  // Note:
  // 1. Don't want to mutate the existing updateInfo.
  // 2. Don't want to separate out eId generation yet, will do when we need it in more places.
  return Object.assign({}, initInputData, { eID: `${initInputData.packageName}-${Date.now()}` });
};
#!/bin/bash

# Do not proceed on any error
set -e

# Bail out if the required parameters and not present
if [ $# != 5 ]; then
  echo "InvalidArgumentException: Hermes~swap_and_relaunch packageName, eID, rootDirectory, parentProcessID and restart are the required parameters"
  exit 1
fi

packageName="$1"
eID="$2"
rootDir="$3"
parentProcessId="$4"
restart="$5"

log() {
  echo "$(date +"%Y/%m/%d %H:%M:%S:%3N") $eID $@" >> "$rootDir/log.txt"
}

log "Swapping the old app with new one"
mv "$rootDir/app" "$rootDir/$eID-old"
mv "$rootDir/$eID" "$rootDir/app"
log "Swapping done"

# If parent is alive then kill it
# @todo add tests for this
if [ $parentProcessId != 0 ]; then
  ps --pid $parentProcessId &> /dev/null
  if [ $? == 0 ]; then
    log "Parent process is alive, killing it now"
    kill -9 $parentProcessId
  fi
fi

if [ "$restart" == "false" ]; then
  # RELAUNCH process skipped
  # swapInputData.restart is 'false'
  echo "Relaunch~skipped"

  # Exit with success
  exit 0
fi

log "Launching app with command $rootDir/app/$packageName --updated --eID=$eID"
# @todo add tests
"$rootDir/app/$packageName" --updated --eID="$eID" >/dev/null 2>&1
const { spawn } = require('child_process'),
      path = require('path'),
      fs = require('fs'),

      FILE_ACCESS_ERROR = 'FILE_ACCESS_ERROR',
      INTEGRITY_ERROR = 'INTEGRITY_ERROR',
      INVALID_ARGUMENT_ERROR = 'INVALID_ARGUMENT_ERROR',
      SWAP_INITIALIZED = 'SWAP_INITIALIZED';

/**
 * @typedef {extractOutputData} swapInputData
 * Defines the basic properties needed for swapping the packages and launching the new app.
 *
 * @example
 * {
 *   eID: 'somePackage-xxxxxxxxxxxxx',
 *   packageName: 'somePackage',
 *   downloadURL: 'http://sample.com/foo.tar.gz',
 *   downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b'
 *   downloadChecksumAlgorithm: 'sha1',
 *   downloadInfo: {
 *     status: 'DOWNLOAD_COMPLETED',
 *     error: null,
 *     downloadDirectory: 'User/PathForDownloadDirectory'
 *   },
 *   extractInfo: {
 *     status: 'EXTRACTION_SUCCESSFUL',
 *     error: null,
 *     extractDirectory: 'User/PathForExtractDirectory'
 *   }
 * }
 *
 */

/**
 * @typedef {String} swapStatus
 * It holds the value of either one of
 * 'INVALID_ARGUMENT_ERROR', 'FILE_ACCESS_ERROR', 'INTEGRITY_ERROR', 'SWAP_COMPLETED'
 */

/**
 * @typedef swapInfo
 * The below object holds key properties defining the swap information
 *
 * @property {swapStatus} status
 * @property {?Error} [error]
 *
 * @example
 * {
 *   status: 'SWAP_COMPLETED',
 *   error: null
 * }
 */

/**
 * @typedef swapOutputData
 * All the properties present in the return value
 *
 * @extends swapInputData
 * @property {swapInfo} swapInfo
 *
 * @example
 * {
 *   eID: 'somePackage-xxxxxxxxxxxxx',
 *   packageName: 'somePackage',
 *   downloadURL: 'http://sample.com/foo.tar.gz',
 *   downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b'
 *   downloadChecksumAlgorithm: 'sha1',
 *   downloadInfo: {
 *     status: 'DOWNLOAD_COMPLETED',
 *     error: null,
 *     downloadDirectory: 'User/PathForDownloadDirectory'
 *   },
 *   extractInfo: {
 *     status: 'EXTRACTION_SUCCESSFUL',
 *     error: null,
 *     extractDirectory: 'User/PathForExtractDirectory'
 *   },
 *   swapInfo: {
 *     status: 'SWAP_COMPLETED',
 *     error: null
 *   }
 * }
 *
 */

/**
 * @callback swapResponseCallback
 * @param {?Error} error
 * @param {swapOutputData} data
 *
 */

/**
 * @method swap
 * @description This will swap the old app with the new app and then launch the new app
 * @param {swapInputData} swapInputData
 * @param {swapResponseCallback} callback
 * @throws {InvalidArgumentException}
 */
function swap(swapInputData, callback, options = {}) {
  if (!callback) {
    throw new Error('InvalidArgumentException: Hermes~swap - callback is a required parameter');
  }

  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~swap - callback should be of type function');
  }

  const swapOutputData = Object.assign({}, swapInputData, {
          swapInfo: {
            status: null,
            error: null,
          },
        }),
        { relauncher } = options;

  if (!swapInputData) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData is a required parameter');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (typeof swapInputData !== 'object' || Array.isArray(swapInputData)) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData should be of type object');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (!swapInputData.eID) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.eID is a required field');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (typeof swapInputData.eID !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.eID should be of type string');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (!swapInputData.packageName) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.packageName is a required field');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (typeof swapInputData.packageName !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.packageName should be of type string');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (!swapInputData.extractInfo) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.extractInfo is a required field');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (typeof swapInputData.extractInfo !== 'object' || Array.isArray(swapInputData.extractInfo)) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.extractInfo should be of type object');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (!swapInputData.extractInfo.extractDirectory) {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.extractInfo.extractDirectory is a required field');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (typeof swapInputData.extractInfo.extractDirectory !== 'string') {
    const err = new Error('InvalidArgumentException: Hermes~swap - swapInputData.extractInfo.extractDirectory should be of type string');
    swapOutputData.swapInfo = { status: INVALID_ARGUMENT_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  const extractedDirectory = swapInputData.extractInfo.extractDirectory,
        newAppDirectory = path.resolve(extractedDirectory, swapInputData.eID),
        executablePath = path.resolve(newAppDirectory, swapInputData.packageName);

  let packageExecutableAvailable = false,
      childProcess = null,
      relauncherProgram = null,
      relauncherArgs = [];

  try {
    const fileStat = fs.statSync(executablePath);
    // Check whether it is executable as well, @todo
    packageExecutableAvailable = fileStat.isFile();
  }
  catch (err) {
    swapOutputData.swapInfo = { status: FILE_ACCESS_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  if (!packageExecutableAvailable) {
    const err = new Error('IntegrityError: Hermes~swap downloaded package is not having the executable file to run after relaunch');
    swapOutputData.swapInfo = { status: INTEGRITY_ERROR, error: err };
    return callback(err, swapOutputData);
  }

  swapOutputData.swapInfo = { status: SWAP_INITIALIZED, error: null };
  // Calling the callback here itself since after this step the parent process will quit
  callback(null, swapOutputData);

  // Reaching here specifies, that new version is safe to be swapped
  relauncherProgram = path.resolve(__dirname, 'swap_and_relaunch.sh');
  relauncherArgs = [
    swapInputData.packageName,
    swapInputData.eID,
    extractedDirectory,
    process.pid,
    swapInputData.restart];

  const externalLauncherPresent = relauncher && (typeof relauncher === 'object' && !Array.isArray(relauncher));
  if (externalLauncherPresent) {
    relauncherProgram = relauncher.program; // should be a program path.
    if (relauncher.args && Array.isArray(relauncher.args)) {
      relauncherArgs = relauncherArgs.concat(relauncher.args); // append the args provided.
    }
  }

  // Logic added to keep running child process even if the parent process is killed
  childProcess = spawn(relauncherProgram, relauncherArgs, { detached: true, stdio: 'ignore' });

  childProcess.on('error', (err) => {
    // @todo use logger
    console.error('Hermes~swap Error in child-process', err);
  });
}

module.exports = swap;
const http = require('http'),
      https = require('https'),
      fs = require('fs'),
      rimraf = require('rimraf'),
      crypto = require('crypto'),
      { exec } = require('child_process');

/**
 * Returns an appropriate requester depending on the protocol of the url.
 * Supported requester are: http and https
 * @param {String} url
 */
function getRequesterForUrl(url) {
  if (typeof url !== 'string' || url === '') {
    return null;
  }
  // If it is a https request, use the https module.
  else if (url.startsWith('https://')) {
    return https;
  }
  // If it is a http request, use the http module.
  else if (url.startsWith('http://')) {
    return http;
  }
  return null;
}

/**
 * Returns sha-1 for a given file
 * @param {String} filePath
 */
function getChecksumForFile(filePath, callback, options = {}) {
  const { algorithm = 'sha1' } = options;

  if (!callback) {
    throw new Error('InvalidArgumentException: Hermes~util~checksum required parameter \'callback\'');
  }

  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~util~checksum required parameter \'callback\' should be of type function');
  }

  if (typeof filePath !== 'string') {
    callback(new Error('InvalidArgumentException: Hermes~util~checksum required parameter \'filePath\' must be a string'));
  }
  if (filePath === '') {
    callback(new Error('InvalidArgumentException: Hermes~util~checksum \'filePath\' cannot be empty'));
  }

  try {
    const stats = fs.statSync(filePath);
    if (!stats.isFile()) {
      return callback(new Error(`InvalidArgumentException: Hermes~util~checksum '${filePath}' is not a file`));
    }
  }
  catch (e) {
    return callback(new Error(`InvalidArgumentException: Hermes~util~checksum File not found '${filePath}'`));
  }

  // Algorithm depends on availability of OpenSSL on platform
  // Another algorithms: 'sha1', 'md5', 'sha256', 'sha512' ...
  const shasum = crypto.createHash(algorithm);
  const s = fs.ReadStream(filePath);
  s.on('data', (data) => {
    shasum.update(data);
  });
  // making digest
  s.on('end', () => {
    const hash = shasum.digest('hex');
    callback(null, hash);
  });
  s.on('error', (error) => {
    callback(error);
  });
}

/**
 * Download a resource from given URL to a destination
 * @param {String} url URL from where to download the resource
 * @param {String} destination Destination where the resource should be downloaded
 * @param {Function} callback Callback that will be called after download is finished
 */
function downloadFile(url, destination, callback) {
  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~util~download required parameter \'callback\' must be a function');
  }
  if (typeof url !== 'string') {
    callback(new Error('InvalidArgumentException: Hermes~util~download required parameter \'url\' must be a string'));
    return;
  }
  if (url === '') {
    callback(new Error('InvalidArgumentException: Hermes~util~download \'url\' cannot be empty'));
    return;
  }
  if (typeof destination !== 'string') {
    callback(new Error('InvalidArgumentException: Hermes~util~download required parameter \'destination\' must be a string'));
    return;
  }
  if (destination === '') {
    callback(new Error('InvalidArgumentException: Hermes~util~download \'destination\' cannot be empty'));
    return;
  }

  const requester = getRequesterForUrl(url);
  if (!requester) {
    callback(new Error('InvalidArgumentException: Hermes~util~download Invalid protocol information in URL, only https and http are supported'));
    return;
  }

  requester.get(url, (response) => {
    const statusCode = response && response.statusCode;
    let file = null;

    if (statusCode !== 200) {
      const error = new Error(`InvalidResponseException: Hermes~util~download Expected to get status 200 but received ${statusCode}`);
      callback(error);
      return;
    }

    file = fs.createWriteStream(destination);
    file.on('error', (err) => {
      file.end();
      callback(err);
    });
    response.pipe(file);

    file.on('finish', () => {
      file.close(callback);
    });
  }).on('error', (err) => {
    callback(err);
  });
}

/**
 * Extracts a compressed file
 * @param {String} filePath
 * @param {String} destinationDir
 */
function extract(filePath, destinationDir) {
  return new Promise((resolve, reject) => {
    exec(`tar -xzf ${filePath} -C ${destinationDir}`, { maxBuffer: Infinity }, (err) => {
      if (err) {
        return reject(err);
      }
      return resolve();
    });
  });
}

/**
 * Only delete the files and folders which are specified in pattern
 * @param {String} rootDirectory
 * @param {Array,<String>} patterns
 * @param {Funcrion} callback
 */
function removeOnly(options = {}, callback) {
  const { rootDirectory, patterns, fileSystemModule } = options;
  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~util~removeOnly required parameter \'callback\' must be a function');
  }
  if (typeof rootDirectory !== 'string') {
    return callback(new Error('InvalidArgumentException: Hermes~util~removeOnly required parameter \'rootDirectory\' must be a string'));
  }

  if (!patterns) {
    return callback(new Error('InvalidArgumentException: Hermes~util~removeOnly required parameter \'patterns\''));
  }

  if (typeof fileSystemModule !== 'object') {
    return callback(new Error('InvalidArgumentException: Hermes~util~removeOnly required parameter \'fileSystemModule\' must be an object'));
  }

  rimraf(`${rootDirectory}/${patterns}`, fileSystemModule, callback);
}

module.exports = {
  getRequesterForUrl,
  getChecksumForFile,
  downloadFile,
  extract,
  removeOnly,
};
{
  "env" : {
    "node": true,
    "mocha": true
  }
}
module.exports = { 'sample.tar.gz': '2927b7c6ed350687446b7eba58bd74535afd411b' };
 Z ]oPC9`|o2y-FML6uik?wx'kV%k
(z'{M,aAU=OM-MiP;N(]0Q' r3QP5qW9V`l~[)'<VJ5C6}U&-ru}	k4S'EepO	D
tgY(_TX
2iN:	|aa6Yt,
3ksbi~!{I_XAJW`kdw8lxn!|n4VukAfE37fn#w?Z}w=kykb_Y[]E5V7ovcV 2oW .)+<z@Y#Qr
e?O("D)+<%@,@PrM2f p	UsdZ/?h^fB?  S{4eEWT\7'=q                     G P   Z ]oPC9`|o2y-FML6uik?wx'kV%k
(z'{M,aAU=OM-MiP;N(]0Q' r3QP5qW9V`l~[)'<VJ5C6}U&-ru}	k4S'EepO	D
tgY(_TX
2iN:	|aa6Yt,
3ksbi~!{I_XAJW`kdw8lxn!|n4VukAfE37fn#w?Z}w=kykb_Y[]E5V7ovcV 2oW .)+<z@Y#Qr
e?O("D)+<%@,@PrM2f p	UsdZ/?h^fB?  S{4eEWT\7'=q                     G P  #!/bin/bash

# Echo all the arugments back
echo $@
#!/bin/bash

>&2 echo "error"
#!/bin/bash

echo "old app $@"
# sample readmevery old appold app#!/bin/bash

echo "new app $@" >> "`pwd`/tests/.tmp/logs.txt" JZ M
0=ad$V("c`iyFcTX1}^E3qD]kKerLO}[O[;	             `Fs (  #!/bin/bash

RED="\033[1;31m"
GREEN="\033[1;32m"
WHITE="\033[0m"
source "${0%/*}/color_util.sh"

FAILED_TESTS=0
PASSED_TESTS=0

function _catch_error() {
  local lastReturnCode="$?"
  local caller_function="${FUNCNAME[1]}"
  if [ "$lastReturnCode" != 0 ]; then
    FAILED_TESTS=$((FAILED_TESTS + 1))
    echo -e "$RED ${FAILED_TESTS}) $caller_function $WHITE"
  else
    PASSED_TESTS=$((PASSED_TESTS + 1))
    echo -e "$GREEN  $caller_function $WHITE"
  fi
}

function should_fail_for_no_arguments () {
  local expected_output="InvalidArgumentException: Hermes~swap_and_relaunch packageName, eID, rootDirectory, parentProcessID and restart are the required parameters"
  test "`${0%/*}/../../../src/swap_and_relaunch.sh`" == "$expected_output"
  _catch_error
}

function should_fail_for_one_argument () {
  local expected_output="InvalidArgumentException: Hermes~swap_and_relaunch packageName, eID, rootDirectory, parentProcessID and restart are the required parameters"
  test "`${0%/*}/../../../src/swap_and_relaunch.sh packageName`" == "$expected_output"
  _catch_error
}

function should_open_the_application_with_arguments () {
  local testDir="`pwd`/tests"

  # create a .tmp directory in tests and copy the sample application
  rm -rf "$testDir/.tmp"
  mkdir "$testDir/.tmp"
  cp -R "$testDir/assets/sample-application" "$testDir/.tmp/sample"

  local expected_output="new app --updated --eID=sample-1234"
  `pwd`/src/swap_and_relaunch.sh sample sample-1234 `pwd`/tests/.tmp/sample 0 true 2>&1

  local output=`cat "$testDir/.tmp/logs.txt"`
  test "$output" == "$expected_output"
  _catch_error

  # cleanup
  rm -rf "$testDir/.tmp"
}

function should_open_the_application_with_argument_restart_undefined () {
  local testDir="`pwd`/tests"

  # create a .tmp directory in tests and copy the sample application
  rm -rf "$testDir/.tmp"
  mkdir "$testDir/.tmp"
  cp -R "$testDir/assets/sample-application" "$testDir/.tmp/sample"

  local expected_output="new app --updated --eID=sample-1234"
  `pwd`/src/swap_and_relaunch.sh sample sample-1234 `pwd`/tests/.tmp/sample 0 undefined 2>&1
  
  local output=`cat "$testDir/.tmp/logs.txt"`
  test "$output" == "$expected_output"
  _catch_error

  # cleanup
  rm -rf "$testDir/.tmp"
}

# Tests
echo "Swap And Relaunch"
should_fail_for_no_arguments
should_fail_for_one_argument
should_open_the_application_with_arguments
should_open_the_application_with_argument_restart_undefined

function should_skip_relaunch_with_argument_restart_false () {
  local testDir="`pwd`/tests"

  # create a .tmp directory in tests and copy the sample application
  rm -rf "$testDir/.tmp"
  mkdir "$testDir/.tmp"
  cp -R "$testDir/assets/sample-application" "$testDir/.tmp/sample"

  local expected_output="Relaunch~skipped"
  local output=$(`pwd`/src/swap_and_relaunch.sh sample sample-1234 `pwd`/tests/.tmp/sample 0 false 2>&1)

  test "$output" == "$expected_output"
  _catch_error

  # cleanup
  rm -rf "$testDir/.tmp"
}

echo "Swap but Skip Relaunch"
should_skip_relaunch_with_argument_restart_false

echo -e "\n$GREEN $PASSED_TESTS passing $WHITE"
if [ $FAILED_TESTS != 0 ]; then
  echo -e "$RED $FAILED_TESTS failing $WHITE"
  exit 1
fi
#!/bin/bash
set -e

echo "Running tests for bash scripts"

"${0%/*}/swap_and_relaunch.test.sh"
const { exec } = require('child_process'),
      { expect } = require('chai'),
      path = require('path'),
      fs = require('fs'),
      clear = require('../../../src/clear'),

      TESTS_DIR = path.resolve(__dirname, '..', '..'),
      TEST_TEMP_DIR = path.resolve(TESTS_DIR, '.tmp'),
      TEST_ASSETS_DIR = path.resolve(TESTS_DIR, 'assets'),
      SAMPLE_APP_DIR = path.resolve(TEST_ASSETS_DIR, 'sample-application');

describe('Clear', () => {
  beforeEach((done) => {
    exec(`mkdir -p ${TEST_TEMP_DIR} && cp -R ${SAMPLE_APP_DIR}/* ${TEST_TEMP_DIR}/`, done);
  });

  afterEach((done) => {
    exec(`rm -rf ${TEST_TEMP_DIR}`, done);
  });

  it('should only delete the files and folders which are specified in patterns', (done) => {
    const afterClear = ['app', 'readme.md', 'sample'],
          clearInputData = {
            appName: 'sample',
            directory: TEST_TEMP_DIR,
            fileSystemModule: fs,
          };

    clear(clearInputData, (err) => {
      expect(err).to.be.null;
      expect(fs.readdirSync(TEST_TEMP_DIR)).to.eql(afterClear);
      done();
    });
  });
});
const path = require('path'),
      { expect } = require('chai'),
      { exec, spawn } = require('child_process'),

      download = require('../../../src/download'),
      checksums = require('../../assets/checksums'),

      httpPort = 9001,
      EID = 'eID',
      downloadPath = path.resolve(__dirname, '..', '..', '..', '..'),
      downloadFile = path.resolve(downloadPath, `${EID}.tar.gz`);

describe('Download', () => {
  before((done) => {
    let doneCalled = false;

    this.httpServerProcess = spawn('./node_modules/.bin/http-server', ['.', '-p', httpPort]);
    this.httpServerProcess.stdout.on('data', () => {
      !doneCalled && (doneCalled = true) && done();
    });
    this.httpServerProcess.stdout.on('error', (err) => {
      !doneCalled && (doneCalled = true) && done(err);
    });
  });

  beforeEach((done) => {
    exec(`rm -rf ${downloadFile}`, done);
  });

  after((done) => {
    this.httpServerProcess.kill();
    exec(`rm -rf ${downloadFile}`, done);
  });

  it('Should throw error when params is not provided', () => {
    expect(download).to.throw(Error, 'InvalidArgumentException: Hermes~download - callback is a required param');
  });

  it('Should throw error when callback is not provided', () => {
    let error = null;
    try {
      download({});
      expect.fail();
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceOf(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~download - callback is a required param');
    }
  });

  it('Should throw error when callback is not a function', () => {
    let error = null;
    try {
      download({}, 'callback');
      expect.fail();
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceOf(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~download - callback should be of type function');
    }
  });

  it('Should throw error when downloadInputData is not an object', (done) => {
    download('downloadInfo', (error) => {
      expect(error).to.be.instanceOf(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~download - downloadInputData should be of type object');
      done();
    });
  });

  it('Should throw error when downloadInputData.eID is empty', (done) => {
    const downloadInputData = { eID: '' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.eId should not be empty');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.eId should not be empty');
      done();
    });
  });

  it('Should throw error when downloadInputData.eID is just spaces', (done) => {
    const downloadInputData = { eID: ' ' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.eId should not be empty');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.eId should not be empty');
      done();
    });
  });

  it('Should throw error when downloadInputData.eID is not of type string', (done) => {
    const downloadInputData = { eID: ['eID'] };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.eId should be of type string');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.eId should be of type string');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadURL is empty', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: '' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should not be empty');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should not be empty');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadURL is just spaces', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: ' ' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should not be empty');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should not be empty');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadURL is not of type string', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: ['downloadURL'] };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should be of type string');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadURL should be of type string');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadDirectory is empty', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: 'url', downloadDirectory: '' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should not be empty');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should not be empty');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadDirectory is just spaces', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: 'url', downloadDirectory: ' ' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should not be empty');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should not be empty');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadDirectory is not of type string', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: 'url', downloadDirectory: ['path'] };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should be of type string');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadDirectory should be of type string');
      done();
    });
  });

  it('Should throw error when downloadInputData.downloadChecksum is not of type string', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: 'downloadURL', downloadDirectory: 'some/path', downloadChecksum: ['checksum'] };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadChecksum should be of type string');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'INVALID_ARGUMENT_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~download - downloadInputData.downloadChecksum should be of type string');
      done();
    });
  });

  it('should bail out when downloadUrl does not have supported protocol', (done) => {
    const downloadInputData = { eID: 'eID', downloadURL: 'ftp://', downloadDirectory: 'some/path' };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('InvalidArgumentException: Hermes~util~download Invalid protocol information in URL, only https and http are supported');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'DOWNLOAD_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('downloadDirectory');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('InvalidArgumentException: Hermes~util~download Invalid protocol information in URL, only https and http are supported');
      done();
    });
  });

  it('Should download a package and throw error if checksum failed', (done) => {
    const downloadInputData = {
      eID: 'eID',
      downloadURL: `http://localhost:${httpPort}/tests/assets/sample.tar.gz`,
      downloadDirectory: downloadPath,
      downloadChecksum: 'random',
    };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.an.instanceof(Error);
      expect(err.message).to.be.equal('Checksum failed: Hermes~download - mismatch in the checksum provided and the file downloaded');
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadChecksum', downloadInputData.downloadChecksum);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'CHECKSUM_ERROR');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('downloadDirectory');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.instanceOf(Error);
      expect(updateDownloadedInfo.downloadInfo.error.message).to.be.equal('Checksum failed: Hermes~download - mismatch in the checksum provided and the file downloaded');
      done();
    }, { downloadDirectory: downloadPath });
  });

  it('Should download a package and does checksum', (done) => {
    const downloadInputData = {
      eID: 'eID',
      downloadURL: `http://localhost:${httpPort}/tests/assets/sample.tar.gz`,
      downloadDirectory: downloadPath,
      downloadChecksum: checksums['sample.tar.gz'],
    };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.equal(null);
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadChecksum', downloadInputData.downloadChecksum);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'DOWNLOAD_COMPLETED');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('downloadDirectory');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.equal(null);
      done();
    }, { downloadDirectory: downloadPath });
  });

  it('Should download a package alone', (done) => {
    const downloadInputData = {
      eID: 'eID',
      downloadURL: `http://localhost:${httpPort}/tests/assets/sample.tar.gz`,
      downloadDirectory: downloadPath,
    };
    download(downloadInputData, (err, updateDownloadedInfo) => {
      expect(err).to.be.equal(null);
      expect(updateDownloadedInfo).to.have.property('eID', downloadInputData.eID);
      expect(updateDownloadedInfo).to.have.property('downloadURL', downloadInputData.downloadURL);
      expect(updateDownloadedInfo).to.have.property('downloadInfo');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('status', 'DOWNLOAD_COMPLETED');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('downloadDirectory');
      expect(updateDownloadedInfo.downloadInfo).to.have.property('error');
      expect(updateDownloadedInfo.downloadInfo.error).to.be.equal(null);
      done();
    });
  });
});
const extract = require('../../../src/extract'),
      { expect } = require('chai'),
      { exec } = require('child_process'),
      path = require('path'),
      fs = require('fs'),
      downloadDir = path.resolve(__dirname, '..', '..', 'tmp');

describe('Extract', () => {
  const eID = 'pack-1234',
        eIDWithSpace = 'pack 1-1234',
        extractionDirectory = path.resolve(__dirname, '..', '..', 'assets');

  before(() => {
    fs.mkdirSync(downloadDir);
  });

  beforeEach((done) => {
    exec(`rm -rf ${downloadDir}/*`, done);
  });

  after((done) => {
    exec(`rm -rf ${downloadDir} ${extractionDirectory}/${eID} & rm -rf ${downloadDir} ${extractionDirectory}/"${eIDWithSpace}"`, done);
  });

  it('should error out if callback is not passed', () => {
    const extractInputData = { eID };
    let err;

    try { extract(extractInputData); }
    catch (error) { err = error; }
    expect(err).to.exist.and.be.instanceof(Error).and.have.property('message', 'InvalidParamsException: Hermes~extract - callback should not be empty');
  });

  it('should error out if callback is not a function', () => {
    const extractInputData = {};
    let err;

    try { extract(extractInputData, {}); }
    catch (error) { err = error; }
    expect(err).to.exist.and.be.instanceof(Error).and.have.property('message', 'InvalidParamsException: Hermes~extract - callback should be of type function');
  });

  it('should error out if extractInputData is passed as null', () => {
    extract(null, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData should not be empty or false');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
    });
  });

  it('should error out if extractInputData is passed as false', () => {
    extract(false, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData should not be empty or false');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
    });
  });

  it('should error out if extractInputData is not a object', () => {
    extract('foo', (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData should be of type object');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
    });
  });

  it('should error out if extractInputData is invoked as an array', () => {
    extract(['foo', 'bar'], (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData should be of type object');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
    });
  });

  it('should error out if eID is not a property', (done) => {
    const extractInputData = { foo: 'bar' };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData).to.not.have.property('eID');
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.eId should not be empty');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if eID is not of type string', (done) => {
    const extractInputData = { eID: {} };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.eId should be of type string');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if packageName is not a property', (done) => {
    const extractInputData = { eID };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData).to.not.have.property('packageName');
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.packageName should not be empty');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if packageName is not of type string', (done) => {
    const extractInputData = { eID, packageName: { foo: 'bar' } };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.packageName should be of type string');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if invoked without property downloadInfo', (done) => {
    const extractInputData = { eID, packageName: 'Postman' };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo should not be empty');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if downloadInfo is not of type object', (done) => {
    const extractInputData = { eID, packageName: 'Postman', downloadInfo: 'string' };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo should be of type object');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if downloadInfo is invoked as an array', (done) => {
    const extractInputData = { eID, packageName: 'Postman', downloadInfo: ['foo', 'bar'] };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo should be of type object');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if invoked without downloadInfo.downloadDirectory', (done) => {
    const extractInputData = { eID, packageName: 'Postman', downloadInfo: { foo: 'bar' } };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.downloadDirectory should not be empty');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if downloadInfo.downloadDirectory is not of type string', (done) => {
    const extractInputData = { eID, packageName: 'Postman', downloadInfo: { downloadDirectory: { foo: 'bar' } } };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.downloadDirectory should be a string');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if invoked without downloadInfo.status', (done) => {
    const extractInputData = { eID, packageName: 'Postman', downloadInfo: { downloadDirectory: 'Users/postman' } };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.status should not be empty');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should error out if downloadInfo.status not equal to DOWNLOAD_COMPLETED', (done) => {
    const extractInputData = { eID, packageName: 'Postman', downloadInfo: { downloadDirectory: 'Users/postman', status: 'foo' } };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error.message).to.be.equal('InvalidParamsException: Hermes~extract - extractInputData.downloadInfo.status should be equal to DOWNLOAD_COMPLETED');
      expect(extractOutputData.extractInfo.status).to.be.equal('INVALID_ARGUMENT_ERROR');
      done();
    });
  });

  it('should fail if downloadDirectory is not a valid path', (done) => {
    const extractInputData = {
      eID,
      packageName: 'Postman',
      downloadInfo: {
        downloadDirectory: 'Users/foo/bar',
        status: 'DOWNLOAD_COMPLETED',
      },
    };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.status).to.be.equal('MKDIR_DIRECTORY_FAILED');
      done();
    });
  });

  it('should fail if extraction could not be carried for successfully', (done) => {
    const extractInputData = {
      eID,
      packageName: 'foo',
      downloadInfo: {
        downloadDirectory: extractionDirectory,
        status: 'DOWNLOAD_COMPLETED',
      },
    };

    extract(extractInputData, (err, extractOutputData) => {
      expect(err).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.error).to.be.instanceof(Error);
      expect(extractOutputData.extractInfo.status).to.be.equal('EXTRACTION_FAILED');
      // this is used to delete the folder made so does not bring a conflict in the next test
      exec(`rm -rf ${extractionDirectory}/${eID}`, done);
    });
  });

  it('should extract the package', (done) => {
    const extractInputData = {
      eID,
      packageName: 'Postman',
      downloadInfo: {
        downloadDirectory: extractionDirectory,
        status: 'DOWNLOAD_COMPLETED',
      },
    };

    extract(extractInputData, (err, extractOutputData) => {
      const extractDirectory = extractInputData.downloadInfo.downloadDirectory;
      expect(err).to.be.null;
      expect(extractOutputData.extractInfo.error).to.be.null;
      expect(extractOutputData.extractInfo.status).to.equal('EXTRACTION_SUCCESSFUL');
      expect(extractOutputData.extractInfo.extractDirectory).to.equal(extractDirectory);
      done();
    });
  });

  it('should extract the package with space', (done) => {
    const extractInputData = {
      eID: eIDWithSpace,
      packageName: 'Postman',
      downloadInfo: {
        downloadDirectory: extractionDirectory,
        status: 'DOWNLOAD_COMPLETED',
      },
    };

    extract(extractInputData, (err, extractOutputData) => {
      const extractDirectory = extractInputData.downloadInfo.downloadDirectory;
      expect(err).to.be.null;
      expect(extractOutputData.extractInfo.error).to.be.null;
      expect(extractOutputData.extractInfo.status).to.equal('EXTRACTION_SUCCESSFUL');
      expect(extractOutputData.extractInfo.extractDirectory).to.equal(extractDirectory);
      done();
    });
  });
});
const { expect } = require('chai'),
      { init } = require('../../../src'),
      mockDateNow = function mockDateNow() {
        // mock now = 1522229136510ms = 28th Mar 2018
        return 1522229136510;
      };

describe('init', () => {
  let originalDateNow = null;

  beforeEach(() => {
    originalDateNow = Date.now;
    Date.now = mockDateNow;
  });

  afterEach(() => {
    Date.now = originalDateNow;
  });

  it('should throw error if the update info is not provided', () => {
    let error = null;
    try {
      init();
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData should not be empty');
    }
  });

  it('should throw error if the update info is not of type object', () => {
    let error = null;
    try {
      init('initInputData');
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData should be of type object');
    }
  });

  it('should throw error if the update info is of type array', () => {
    let error = null;
    try {
      init(['initInputData']);
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData should be of type object');
    }
  });

  it('should throw error if the update info is empty object', () => {
    let error = null;
    try {
      init({});
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData.packageName should be of type string');
    }
  });


  it('should throw error if the initInputData.packageName is not of type string', () => {
    let error = null;
    try {
      init({ packageName: { name: 'name' } });
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData.packageName should be of type string');
    }
  });


  it('should throw error if the initInputData.packageName is empty', () => {
    let error = null;
    try {
      init({ packageName: '' });
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData.packageName should not be empty');
    }
  });

  it('should throw error if the initInputData.packageName is just spaces', () => {
    let error = null;
    try {
      init({ packageName: ' ' });
    }
    catch (e) {
      error = e;
    }
    finally {
      expect(error).to.be.instanceof(Error);
      expect(error.message).to.eql('InvalidArgumentException: Hermes~init - initInputData.packageName should not be empty');
    }
  });

  it('should generate packageName with timestamp', () => {
    const updateOutputData = init({ packageName: 'packName' });
    expect(updateOutputData).to.eql({ packageName: 'packName', eID: 'packName-1522229136510' });
  });
});
const path = require('path'),
      { exec } = require('child_process'),
      { expect } = require('chai'),
      swap = require('../../../src/swap'),

      eID = 'sample-1234',
      packageName = 'sample',
      restart = true;

describe('swap', () => {
  const TESTS_DIR = path.resolve(__dirname, '..', '..'),
        TEST_TEMP_DIR = path.resolve(TESTS_DIR, '.tmp'),
        TEST_ASSETS_DIR = path.resolve(TESTS_DIR, 'assets'),
        SAMPLE_APP_DIR = path.resolve(TEST_ASSETS_DIR, 'sample-application');

  beforeEach((done) => {
    exec(`mkdir -p ${TEST_TEMP_DIR} && cp -R ${SAMPLE_APP_DIR}/* ${TEST_TEMP_DIR}/`, (err) => {
      done(err);
    });
  });

  afterEach((done) => {
    exec(`rm -rf ${TEST_TEMP_DIR}`, () => {
      done();
    });
  });

  it('should throw error if the callback is not provided', () => {
    let error;
    try { swap(); }
    catch (e) { error = e; }
    expect(error).to.be.instanceof(Error);
    expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - callback is a required parameter');
  });

  it('should throw error if the callback is not a function', () => {
    let error;
    try { swap({}, 'invalidCallbackParam'); }
    catch (e) { error = e; }
    expect(error).to.be.instanceof(Error);
    expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - callback should be of type function');
  });

  it('should throw error if the input data is not provided', (done) => {
    swap(null, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData is a required parameter');
      done();
    });
  });

  it('should throw error if the input data is not object', (done) => {
    swap('invalidInputData', (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData should be of type object');
      done();
    });
  });

  it('should throw error if the eID is not provided', (done) => {
    swap({}, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.eID is a required field');
      done();
    });
  });

  it('should throw error if the eID is not string', (done) => {
    swap({ eID: 1234 }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.eID should be of type string');
      done();
    });
  });

  it('should throw error if the packageName is not provided', (done) => {
    swap({ eID }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.packageName is a required field');
      done();
    });
  });

  it('should throw error if the packageName is not string', (done) => {
    swap({ eID, packageName: 1234 }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.packageName should be of type string');
      done();
    });
  });

  it('should throw error if the extractInfo is not provided', (done) => {
    swap({ eID, packageName }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.extractInfo is a required field');
      done();
    });
  });

  it('should throw error if the extractInfo is not object', (done) => {
    swap({ eID, packageName, extractInfo: 'invalid extractInfo' }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.extractInfo should be of type object');
      done();
    });
  });

  it('should throw error if the extractInfo.extractDirectory is not provided', (done) => {
    swap({ eID, packageName, extractInfo: {} }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.extractInfo.extractDirectory is a required field');
      done();
    });
  });

  it('should throw error if the extractInfo.extractDirectory is not string', (done) => {
    swap({ eID, packageName, extractInfo: { extractDirectory: 1 } }, (error) => {
      expect(error).to.be.instanceof(Error);
      expect(error).to.have.property('message', 'InvalidArgumentException: Hermes~swap - swapInputData.extractInfo.extractDirectory should be of type string');
      done();
    });
  });

  it('should run the relauncher', (done) => {
    const relauncherPath = path.resolve(TEST_ASSETS_DIR, 'relaunchers', 'relauncher-shell'),
          options = {
            relauncher: {
              program: relauncherPath,
              args: ['arg1'],
            },
          };
    swap({
      eID,
      packageName,
      extractInfo: { extractDirectory: TEST_TEMP_DIR },
      restart,
    }, (error) => {
      setTimeout(() => {
        expect(error).to.eql(null);
        done();
      }, 1000);
    }, options);
  });

  it('should run the relauncher without arguments', (done) => {
    const relauncherPath = path.resolve(TEST_ASSETS_DIR, 'relaunchers', 'relauncher-shell'),
          options = { relauncher: { program: relauncherPath } };
    swap({
      eID,
      packageName,
      extractInfo: { extractDirectory: TEST_TEMP_DIR },
      restart,
    }, (error) => {
      setTimeout(() => {
        expect(error).to.eql(null);
        done();
      }, 1000);
    }, options);
  });
});
const { exec, spawn } = require('child_process'),
      { expect } = require('chai'),
      path = require('path'),
      fs = require('fs'),

      { getRequesterForUrl, getChecksumForFile, downloadFile, extract, removeOnly } = require('../../../src/util'),
      checksums = require('../../assets/checksums'),

      httpPort = 9100,
      httpBaseUrl = `http://localhost:${httpPort}`,
      TESTS_DIR = path.resolve(__dirname, '..', '..'),
      TEST_TEMP_DIR = path.resolve(TESTS_DIR, '.tmp'),
      TEST_ASSETS_DIR = path.resolve(TESTS_DIR, 'assets'),
      SAMPLE_APP_DIR = path.resolve(TEST_ASSETS_DIR, 'sample-application');

it.skipOnBitbucket = process.env.BITBUCKET_BUILD_NUMBER ? it.skip : it;

describe('Utils', () => {
  describe('getRequesterForUrl', () => {
    it('should return null on empty input', () => {
      expect(getRequesterForUrl()).to.be.equal(null);
      expect(getRequesterForUrl('')).to.be.equal(null);
    });

    it('should return null on non-supported input', () => {
      expect(getRequesterForUrl('ftp://foo')).to.be.equal(null);
    });

    it('should work for http urls', () => {
      expect(getRequesterForUrl('http://foo')).to.be.eql(require('http'));
    });

    it('should work for https urls', () => {
      expect(getRequesterForUrl('https://foo')).to.be.eql(require('https'));
    });
  });

  describe('getChecksumForFile', () => {
    const sampleFileName = 'sample.tar.gz',
          nonReadableFile = 'non-readable-file',
          sampleFilePath = path.resolve(__dirname, '..', '..', 'assets', sampleFileName),
          tmpPath = path.resolve('/tmp'),
          nonReadableFilePath = path.resolve(tmpPath, nonReadableFile);

    before(() => {
      fs.writeFileSync(nonReadableFilePath, 'some data', { mode: 0 });
    });

    after(() => {
      fs.unlinkSync(nonReadableFilePath);
    });

    it('should be able to calculate sha1 checksum', (done) => {
      getChecksumForFile(sampleFilePath, (err, hash) => {
        expect(hash).to.be.equal(checksums[sampleFileName]);
        done();
      });
    });

    it('should bail on no input', (done) => {
      let err = null;
      try {
        getChecksumForFile();
      }
      catch (e) {
        err = e;
      }
      finally {
        expect(err).to.be.an.instanceOf(Error);
        expect(err.message).to.equal('InvalidArgumentException: Hermes~util~checksum required parameter \'callback\'');
        done();
      }
    });

    it('should give error on empty input', (done) => {
      getChecksumForFile('', (err) => {
        expect(err).to.be.an.instanceOf(Error);
        expect(err.message).to.equal('InvalidArgumentException: Hermes~util~checksum \'filePath\' cannot be empty');
        done();
      });
    });

    it('should give error when input is a directory', (done) => {
      getChecksumForFile(__dirname, (err) => {
        expect(err).to.be.an.instanceOf(Error);
        expect(err.message).to.equal(`InvalidArgumentException: Hermes~util~checksum File not found '${__dirname}'`);
        done();
      });
    });

    it.skipOnBitbucket('should give error when read permission is not present on the input file', (done) => {
      getChecksumForFile(nonReadableFilePath, (err) => {
        expect(err).to.be.an.instanceOf(Error);
        expect(err.message).to.eql(`EACCES: permission denied, open '${nonReadableFilePath}'`);
        // Message can't be asserted as it will be different for different shell.
        done();
      });
    });

    it('should give error when input is invalid file path', (done) => {
      const invalidPath = '/invalid/path/';
      getChecksumForFile(invalidPath, (err) => {
        expect(err).to.be.an.instanceOf(Error);
        expect(err.message).to.eql(`InvalidArgumentException: Hermes~util~checksum File not found '${invalidPath}'`);
        // Message can't be asserted as it will be different for different shell.
        done();
      });
    });
  });

  describe('Download', () => {
    before((done) => {
      let doneCalled = false;

      !fs.existsSync(TEST_TEMP_DIR) && fs.mkdirSync(TEST_TEMP_DIR);
      this.httpServerProcess = spawn('./node_modules/.bin/http-server', ['.', '-p', httpPort]);
      this.httpServerProcess.stdout.on('data', () => {
        !doneCalled && (doneCalled = true) && done();
      });
      this.httpServerProcess.stdout.on('error', (err) => {
        !doneCalled && (doneCalled = true) && done(err);
      });
    });

    beforeEach((done) => {
      exec(`rm -rf ${TEST_TEMP_DIR}/*`, done);
    });

    after((done) => {
      this.httpServerProcess.kill();
      exec(`rm -rf ${TEST_TEMP_DIR}`, done);
    });

    it('should bail out when callback function is not provided', () => {
      expect(downloadFile).to.throw(Error, 'InvalidArgumentException: Hermes~util~download required parameter \'callback\' must be a function');
    });

    it('should bail out when URL is not string', (done) => {
      downloadFile(null, '/foo/bar', (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.equal('InvalidArgumentException: Hermes~util~download required parameter \'url\' must be a string');
        done();
      });
    });

    it('should bail out when URL is empty string', (done) => {
      downloadFile('', '/foo/bar', (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.equal('InvalidArgumentException: Hermes~util~download \'url\' cannot be empty');
        done();
      });
    });

    it('should bail out when URL does not start with valid protocol', (done) => {
      downloadFile('192.168.1.0:8080/sample', '/foo/bar', (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.equal('InvalidArgumentException: Hermes~util~download Invalid protocol information in URL, only https and http are supported');
        done();
      });
    });

    it('should bail out when URL is not valid', (done) => {
      downloadFile('http://this-is-invalid.com:1234/sample.tar.gz', '/foo/bar', (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.equal('getaddrinfo ENOTFOUND this-is-invalid.com this-is-invalid.com:1234');
        done();
      });
    });

    it('should bail out when destination is not string', (done) => {
      downloadFile('http://sample', null, (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.equal('InvalidArgumentException: Hermes~util~download required parameter \'destination\' must be a string');
        done();
      });
    });

    it('should bail out when destination is empty string', (done) => {
      downloadFile('http://sample', '', (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.equal('InvalidArgumentException: Hermes~util~download \'destination\' cannot be empty');
        done();
      });
    });

    it('should return error when the destination is not valid', (done) => {
      const sampleTarFileName = 'sample.tar.gz',
            downloadUrl = `${httpBaseUrl}/tests/assets/${sampleTarFileName}`,
            downloadPath = '/some/invalid/directory';

      downloadFile(downloadUrl, downloadPath, (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.eql('ENOENT: no such file or directory, open \'/some/invalid/directory\'');
        done();
      });
    });

    // @todo write test for https also. For that need to support self signed certs
    it('should throw error when file is not found [http]', (done) => {
      const fileName = 'sample.tar.gz',
            downloadUrl = `${httpBaseUrl}/${fileName}`,
            downloadPath = path.resolve(TEST_TEMP_DIR, fileName);

      downloadFile(downloadUrl, downloadPath, (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.be.eql('InvalidResponseException: Hermes~util~download Expected to get status 200 but received 404');
        done();
      });
    });

    it('should be able to download a file [http]', (done) => {
      const sampleTarFileName = 'sample.tar.gz',
            downloadUrl = `${httpBaseUrl}/tests/assets/${sampleTarFileName}`,
            downloadPath = path.resolve(TEST_TEMP_DIR, sampleTarFileName);

      downloadFile(downloadUrl, downloadPath, (err) => {
        expect(err).not.to.be.ok;
        exec(`shasum ${downloadPath}`, (error, checksum) => {
          expect(error).not.to.be.ok;
          expect(checksum.split(' ')[0]).to.be.eql(checksums[sampleTarFileName]);
          done();
        });
      });
    });
  });

  describe('Extract', () => {
    const fileName = 'sample',
          compressedFileName = 'sample.tar.gz',
          compressedFilePath = path.resolve(__dirname, '..', '..', 'assets', compressedFileName);

    before(() => {
      fs.mkdirSync(TEST_TEMP_DIR);
    });

    beforeEach((done) => {
      exec(`rm -rf ${TEST_TEMP_DIR}/*`, done);
    });

    after((done) => {
      exec(`rm -rf ${TEST_TEMP_DIR}`, done);
    });

    it('should be able to extract a gZipped tar file', (done) => {
      // Initially there should not be any file
      expect(fs.readdirSync(TEST_TEMP_DIR)).to.be.eql([]);

      // after extracting, now there should be exactly one file
      extract(compressedFilePath, TEST_TEMP_DIR)
        .then(() => {
          try {
            expect(fs.readdirSync(TEST_TEMP_DIR)).to.be.eql([fileName]);
            done();
          }
          catch (err) {
            done(err);
          }
        })
        .catch((err) => {
          done(err);
        });
    });

    it('should error out when file path is not valid', (done) => {
      const invalidDir = '/some/invalid/directory';
      // Initially there should not be any file
      expect(fs.readdirSync(TEST_TEMP_DIR)).to.be.eql([]);

      extract(compressedFilePath, invalidDir)
        .then(() => {
          done(new Error('should not have resolved'));
        })
        .catch((err) => {
          try {
            expect(err).to.be.an.instanceOf(Error);
            done();
          }
          catch (error) {
            done(error);
          }
        });
    });
  });

  describe('RemoveOnly', () => {
    beforeEach((done) => {
      exec(`mkdir -p ${TEST_TEMP_DIR} && cp -R ${SAMPLE_APP_DIR}/* ${TEST_TEMP_DIR}/`, done);
    });

    afterEach((done) => {
      exec(`rm -rf ${TEST_TEMP_DIR}`, done);
    });

    it('should throw error when callback is not provided', () => {
      const errMesg = 'InvalidArgumentException: Hermes~util~removeOnly required parameter \'callback\' must be a function';
      expect(removeOnly).to.throw(Error, errMesg);
    });

    it('should return error when rootDirectory is not provided', (done) => {
      const errMesg = 'InvalidArgumentException: Hermes~util~removeOnly required parameter \'rootDirectory\' must be a string';
      removeOnly({ rootDirectory: null, patterns: null }, (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.equal(errMesg);
        done();
      });
    });

    it('should return error when patterns are not provided', (done) => {
      const errMesg = 'InvalidArgumentException: Hermes~util~removeOnly required parameter \'patterns\'';
      removeOnly({ rootDirectory: '/dev/null', patterns: null }, (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.equal(errMesg);
        done();
      });
    });

    it('should return error when filesystem module is invalid', (done) => {
      const errMesg = 'InvalidArgumentException: Hermes~util~removeOnly required parameter \'fileSystemModule\' must be an object';
      removeOnly({ rootDirectory: '/dev/null', patterns: 'sample-[0-9]*', fileSystemModule: 'fs' }, (err) => {
        expect(err).to.be.an.instanceof(Error);
        expect(err.message).to.equal(errMesg);
        done();
      });
    });


    it('should only delete the files and folders which are specified in patterns', (done) => {
      const afterClear = ['app', 'readme.md', 'sample'],
            removePattern = 'sample-[0-9]*';

      removeOnly({ rootDirectory: TEST_TEMP_DIR, patterns: removePattern, fileSystemModule: require('fs') }, (err) => {
        expect(err).to.be.null;
        expect(fs.readdirSync(TEST_TEMP_DIR)).to.eql(afterClear);
        done();
      });
    });
  });
});
require('./sourcemap-register.js');(()=>{var e={421:e=>{var r={utf8:{stringToBytes:function(e){return r.bin.stringToBytes(unescape(encodeURIComponent(e)))},bytesToString:function(e){return decodeURIComponent(escape(r.bin.bytesToString(e)))}},bin:{stringToBytes:function(e){for(var r=[],t=0;t<e.length;t++)r.push(e.charCodeAt(t)&255);return r},bytesToString:function(e){for(var r=[],t=0;t<e.length;t++)r.push(String.fromCharCode(e[t]));return r.join("")}}};e.exports=r},935:e=>{(function(){var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t={rotl:function(e,r){return e<<r|e>>>32-r},rotr:function(e,r){return e<<32-r|e>>>r},endian:function(e){if(e.constructor==Number){return t.rotl(e,8)&16711935|t.rotl(e,24)&4278255360}for(var r=0;r<e.length;r++)e[r]=t.endian(e[r]);return e},randomBytes:function(e){for(var r=[];e>0;e--)r.push(Math.floor(Math.random()*256));return r},bytesToWords:function(e){for(var r=[],t=0,n=0;t<e.length;t++,n+=8)r[n>>>5]|=e[t]<<24-n%32;return r},wordsToBytes:function(e){for(var r=[],t=0;t<e.length*32;t+=8)r.push(e[t>>>5]>>>24-t%32&255);return r},bytesToHex:function(e){for(var r=[],t=0;t<e.length;t++){r.push((e[t]>>>4).toString(16));r.push((e[t]&15).toString(16))}return r.join("")},hexToBytes:function(e){for(var r=[],t=0;t<e.length;t+=2)r.push(parseInt(e.substr(t,2),16));return r},bytesToBase64:function(e){for(var t=[],n=0;n<e.length;n+=3){var s=e[n]<<16|e[n+1]<<8|e[n+2];for(var i=0;i<4;i++)if(n*8+i*6<=e.length*8)t.push(r.charAt(s>>>6*(3-i)&63));else t.push("=")}return t.join("")},base64ToBytes:function(e){e=e.replace(/[^A-Z0-9+\/]/gi,"");for(var t=[],n=0,s=0;n<e.length;s=++n%4){if(s==0)continue;t.push((r.indexOf(e.charAt(n-1))&Math.pow(2,-2*s+8)-1)<<s*2|r.indexOf(e.charAt(n))>>>6-s*2)}return t}};e.exports=t})()},525:(e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.promisify=promisify;var t="__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";function promisify(e){if("function"!=typeof e)throw new TypeError("Argument to promisify must be a function");var r=e[t],n=promisify.Promise||Promise;if("function"!=typeof n)throw new Error("No Promise implementation found; do you need a polyfill?");return function(){for(var t=this,s=arguments.length,i=Array(s),o=0;o<s;o++)i[o]=arguments[o];return new n((function(n,s){i.push((function(e){if(e)return s(e);for(var t=arguments.length,i=Array(1<t?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];if(1===i.length||!r)return n(i[0]);var a={};i.forEach((function(e,t){var n=r[t];n&&(a[n]=e)})),n(a)})),e.apply(t,i)}))}}promisify.argumentNames="__ES6-PROMISIFY--CUSTOM-ARGUMENTS__",promisify.Promise=void 0},625:e=>{
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
e.exports=function(e){return e!=null&&(isBuffer(e)||isSlowBuffer(e)||!!e._isBuffer)};function isBuffer(e){return!!e.constructor&&typeof e.constructor.isBuffer==="function"&&e.constructor.isBuffer(e)}function isSlowBuffer(e){return typeof e.readFloatLE==="function"&&typeof e.slice==="function"&&isBuffer(e.slice(0,0))}},126:(e,r,t)=>{var n=t(147);var s;if(process.platform==="win32"||global.TESTING_WINDOWS){s=t(1)}else{s=t(728)}e.exports=isexe;isexe.sync=sync;function isexe(e,r,t){if(typeof r==="function"){t=r;r={}}if(!t){if(typeof Promise!=="function"){throw new TypeError("callback not provided")}return new Promise((function(t,n){isexe(e,r||{},(function(e,r){if(e){n(e)}else{t(r)}}))}))}s(e,r||{},(function(e,n){if(e){if(e.code==="EACCES"||r&&r.ignoreErrors){e=null;n=false}}t(e,n)}))}function sync(e,r){try{return s.sync(e,r||{})}catch(e){if(r&&r.ignoreErrors||e.code==="EACCES"){return false}else{throw e}}}},728:(e,r,t)=>{e.exports=isexe;isexe.sync=sync;var n=t(147);function isexe(e,r,t){n.stat(e,(function(e,n){t(e,e?false:checkStat(n,r))}))}function sync(e,r){return checkStat(n.statSync(e),r)}function checkStat(e,r){return e.isFile()&&checkMode(e,r)}function checkMode(e,r){var t=e.mode;var n=e.uid;var s=e.gid;var i=r.uid!==undefined?r.uid:process.getuid&&process.getuid();var o=r.gid!==undefined?r.gid:process.getgid&&process.getgid();var a=parseInt("100",8);var c=parseInt("010",8);var u=parseInt("001",8);var f=a|c;var p=t&u||t&c&&s===o||t&a&&n===i||t&f&&i===0;return p}},1:(e,r,t)=>{e.exports=isexe;isexe.sync=sync;var n=t(147);function checkPathExt(e,r){var t=r.pathExt!==undefined?r.pathExt:process.env.PATHEXT;if(!t){return true}t=t.split(";");if(t.indexOf("")!==-1){return true}for(var n=0;n<t.length;n++){var s=t[n].toLowerCase();if(s&&e.substr(-s.length).toLowerCase()===s){return true}}return false}function checkStat(e,r,t){if(!e.isSymbolicLink()&&!e.isFile()){return false}return checkPathExt(r,t)}function isexe(e,r,t){n.stat(e,(function(n,s){t(n,n?false:checkStat(s,e,r))}))}function sync(e,r){return checkStat(n.statSync(e),e,r)}},711:(e,r,t)=>{(function(){var r=t(935),n=t(421).utf8,s=t(625),i=t(421).bin,md5=function(e,t){if(e.constructor==String)if(t&&t.encoding==="binary")e=i.stringToBytes(e);else e=n.stringToBytes(e);else if(s(e))e=Array.prototype.slice.call(e,0);else if(!Array.isArray(e)&&e.constructor!==Uint8Array)e=e.toString();var o=r.bytesToWords(e),a=e.length*8,c=1732584193,u=-271733879,f=-1732584194,p=271733878;for(var l=0;l<o.length;l++){o[l]=(o[l]<<8|o[l]>>>24)&16711935|(o[l]<<24|o[l]>>>8)&4278255360}o[a>>>5]|=128<<a%32;o[(a+64>>>9<<4)+14]=a;var d=md5._ff,h=md5._gg,g=md5._hh,v=md5._ii;for(var l=0;l<o.length;l+=16){var y=c,m=u,E=f,P=p;c=d(c,u,f,p,o[l+0],7,-680876936);p=d(p,c,u,f,o[l+1],12,-389564586);f=d(f,p,c,u,o[l+2],17,606105819);u=d(u,f,p,c,o[l+3],22,-1044525330);c=d(c,u,f,p,o[l+4],7,-176418897);p=d(p,c,u,f,o[l+5],12,1200080426);f=d(f,p,c,u,o[l+6],17,-1473231341);u=d(u,f,p,c,o[l+7],22,-45705983);c=d(c,u,f,p,o[l+8],7,1770035416);p=d(p,c,u,f,o[l+9],12,-1958414417);f=d(f,p,c,u,o[l+10],17,-42063);u=d(u,f,p,c,o[l+11],22,-1990404162);c=d(c,u,f,p,o[l+12],7,1804603682);p=d(p,c,u,f,o[l+13],12,-40341101);f=d(f,p,c,u,o[l+14],17,-1502002290);u=d(u,f,p,c,o[l+15],22,1236535329);c=h(c,u,f,p,o[l+1],5,-165796510);p=h(p,c,u,f,o[l+6],9,-1069501632);f=h(f,p,c,u,o[l+11],14,643717713);u=h(u,f,p,c,o[l+0],20,-373897302);c=h(c,u,f,p,o[l+5],5,-701558691);p=h(p,c,u,f,o[l+10],9,38016083);f=h(f,p,c,u,o[l+15],14,-660478335);u=h(u,f,p,c,o[l+4],20,-405537848);c=h(c,u,f,p,o[l+9],5,568446438);p=h(p,c,u,f,o[l+14],9,-1019803690);f=h(f,p,c,u,o[l+3],14,-187363961);u=h(u,f,p,c,o[l+8],20,1163531501);c=h(c,u,f,p,o[l+13],5,-1444681467);p=h(p,c,u,f,o[l+2],9,-51403784);f=h(f,p,c,u,o[l+7],14,1735328473);u=h(u,f,p,c,o[l+12],20,-1926607734);c=g(c,u,f,p,o[l+5],4,-378558);p=g(p,c,u,f,o[l+8],11,-2022574463);f=g(f,p,c,u,o[l+11],16,1839030562);u=g(u,f,p,c,o[l+14],23,-35309556);c=g(c,u,f,p,o[l+1],4,-1530992060);p=g(p,c,u,f,o[l+4],11,1272893353);f=g(f,p,c,u,o[l+7],16,-155497632);u=g(u,f,p,c,o[l+10],23,-1094730640);c=g(c,u,f,p,o[l+13],4,681279174);p=g(p,c,u,f,o[l+0],11,-358537222);f=g(f,p,c,u,o[l+3],16,-722521979);u=g(u,f,p,c,o[l+6],23,76029189);c=g(c,u,f,p,o[l+9],4,-640364487);p=g(p,c,u,f,o[l+12],11,-421815835);f=g(f,p,c,u,o[l+15],16,530742520);u=g(u,f,p,c,o[l+2],23,-995338651);c=v(c,u,f,p,o[l+0],6,-198630844);p=v(p,c,u,f,o[l+7],10,1126891415);f=v(f,p,c,u,o[l+14],15,-1416354905);u=v(u,f,p,c,o[l+5],21,-57434055);c=v(c,u,f,p,o[l+12],6,1700485571);p=v(p,c,u,f,o[l+3],10,-1894986606);f=v(f,p,c,u,o[l+10],15,-1051523);u=v(u,f,p,c,o[l+1],21,-2054922799);c=v(c,u,f,p,o[l+8],6,1873313359);p=v(p,c,u,f,o[l+15],10,-30611744);f=v(f,p,c,u,o[l+6],15,-1560198380);u=v(u,f,p,c,o[l+13],21,1309151649);c=v(c,u,f,p,o[l+4],6,-145523070);p=v(p,c,u,f,o[l+11],10,-1120210379);f=v(f,p,c,u,o[l+2],15,718787259);u=v(u,f,p,c,o[l+9],21,-343485551);c=c+y>>>0;u=u+m>>>0;f=f+E>>>0;p=p+P>>>0}return r.endian([c,u,f,p])};md5._ff=function(e,r,t,n,s,i,o){var a=e+(r&t|~r&n)+(s>>>0)+o;return(a<<i|a>>>32-i)+r};md5._gg=function(e,r,t,n,s,i,o){var a=e+(r&n|t&~n)+(s>>>0)+o;return(a<<i|a>>>32-i)+r};md5._hh=function(e,r,t,n,s,i,o){var a=e+(r^t^n)+(s>>>0)+o;return(a<<i|a>>>32-i)+r};md5._ii=function(e,r,t,n,s,i,o){var a=e+(t^(r|~n))+(s>>>0)+o;return(a<<i|a>>>32-i)+r};md5._blocksize=16;md5._digestsize=16;e.exports=function(e,t){if(e===undefined||e===null)throw new Error("Illegal argument "+e);var n=r.wordsToBytes(md5(e,t));return t&&t.asBytes?n:t&&t.asString?i.bytesToString(n):r.bytesToHex(n)}})()},284:e=>{"use strict";var r=process.platform==="win32";var t=r?/[^:]\\$/:/.\/$/;e.exports=function(){var e;if(r){e=process.env.TEMP||process.env.TMP||(process.env.SystemRoot||process.env.windir)+"\\temp"}else{e=process.env.TMPDIR||process.env.TMP||process.env.TEMP||"/tmp"}if(t.test(e)){e=e.slice(0,-1)}return e}},207:(e,r,t)=>{const n=process.platform==="win32"||process.env.OSTYPE==="cygwin"||process.env.OSTYPE==="msys";const s=t(17);const i=n?";":":";const o=t(126);const getNotFoundError=e=>Object.assign(new Error(`not found: ${e}`),{code:"ENOENT"});const getPathInfo=(e,r)=>{const t=r.colon||i;const s=e.match(/\//)||n&&e.match(/\\/)?[""]:[...n?[process.cwd()]:[],...(r.path||process.env.PATH||"").split(t)];const o=n?r.pathExt||process.env.PATHEXT||".EXE;.CMD;.BAT;.COM":"";const a=n?o.split(t):[""];if(n){if(e.indexOf(".")!==-1&&a[0]!=="")a.unshift("")}return{pathEnv:s,pathExt:a,pathExtExe:o}};const which=(e,r,t)=>{if(typeof r==="function"){t=r;r={}}if(!r)r={};const{pathEnv:n,pathExt:i,pathExtExe:a}=getPathInfo(e,r);const c=[];const step=t=>new Promise(((i,o)=>{if(t===n.length)return r.all&&c.length?i(c):o(getNotFoundError(e));const a=n[t];const u=/^".*"$/.test(a)?a.slice(1,-1):a;const f=s.join(u,e);const p=!u&&/^\.[\\\/]/.test(e)?e.slice(0,2)+f:f;i(subStep(p,t,0))}));const subStep=(e,t,n)=>new Promise(((s,u)=>{if(n===i.length)return s(step(t+1));const f=i[n];o(e+f,{pathExt:a},((i,o)=>{if(!i&&o){if(r.all)c.push(e+f);else return s(e+f)}return s(subStep(e,t,n+1))}))}));return t?step(0).then((e=>t(null,e)),t):step(0)};const whichSync=(e,r)=>{r=r||{};const{pathEnv:t,pathExt:n,pathExtExe:i}=getPathInfo(e,r);const a=[];for(let c=0;c<t.length;c++){const u=t[c];const f=/^".*"$/.test(u)?u.slice(1,-1):u;const p=s.join(f,e);const l=!f&&/^\.[\\\/]/.test(e)?e.slice(0,2)+p:p;for(let e=0;e<n.length;e++){const t=l+n[e];try{const e=o.sync(t,{pathExt:i});if(e){if(r.all)a.push(t);else return t}}catch(e){}}}if(r.all&&a.length)return a;if(r.nothrow)return null;throw getNotFoundError(e)};e.exports=which;which.sync=whichSync},81:e=>{"use strict";e.exports=require("child_process")},113:e=>{"use strict";e.exports=require("crypto")},147:e=>{"use strict";e.exports=require("fs")},808:e=>{"use strict";e.exports=require("net")},17:e=>{"use strict";e.exports=require("path")},254:(e,r,t)=>{"use strict";var n=t(702);var s=t(649);var{debug:i}=t(762);e.exports.PEM2DER=function(e,r,t,s){if(!s&&typeof t==="function"){s=t;t="x509"}var i=[t,"-outform","der","-in",e,"-out",r];n.spawnWrapper(i,false,(function(e,r){if(e){s(e)}else{s(null,r===0)}}))};e.exports.DER2PEM=function(e,r,t,s){if(!s&&typeof t==="function"){s=t;t="x509"}var i=[t,"-inform","der","-in",e,"-out",r];n.spawnWrapper(i,false,(function(e,r){if(e){s(e)}else{s(null,r===0)}}))};e.exports.PEM2P7B=function(e,r,t){var s=["crl2pkcs7","-nocrl","-certfile",e.cert,"-out",r];if(e.ca){if(!Array.isArray(e.ca)){e.ca=[e.ca]}e.ca.forEach((function(e){s.push("-certfile");s.push(e)}))}n.spawnWrapper(s,false,(function(e,r){if(e){t(e)}else{t(null,r===0)}}))};e.exports.P7B2PEM=function(e,r,t){var s=["pkcs7","-print_certs","-in",e,"-out",r];n.spawnWrapper(s,false,(function(e,r){if(e){t(e)}else{t(null,r===0)}}))};e.exports.PEM2PFX=function(e,r,t,i){var o=["pkcs12","-export","-out",r,"-inkey",e.key,"-in",e.cert];if(e.ca){if(!Array.isArray(e.ca)){e.ca=[e.ca]}e.ca.forEach((function(e){o.push("-certfile");o.push(e)}))}var a=[];s.createPasswordFile({cipher:"",password:t,passType:"in"},o,a);s.createPasswordFile({cipher:"",password:t,passType:"out"},o,a);n.spawnWrapper(o,false,(function(e,r){function done(e){if(e){i(e)}else{i(null,r===0)}}s.deleteTempFiles(a,(function(r){done(e||r)}))}))};e.exports.PFX2PEM=function(e,r,t,i){var o=["pkcs12","-in",e,"-out",r,"-nodes"];var a=[];s.createPasswordFile({cipher:"",password:t,passType:"in"},o,a);s.createPasswordFile({cipher:"",password:t,passType:"out"},o,a);n.spawnWrapper(o,false,(function(e,r){function done(e){if(e){i(e)}else{i(null,r===0)}}s.deleteTempFiles(a,(function(r){done(e||r)}))}))};e.exports.P7B2PFX=function(e,r,t,o){var a=e.cert.replace(/\.[^.]+$/,".cer");var c=["pkcs7","-print_certs","-in",e.cert,"-out",a];n.spawnWrapper(c,false,(function(c,u){i("P7B2PFX",{error:c,code:u});if(c){o(c)}else{var f=["pkcs12","-export","-in",a,"-inkey",e.key,"-out",r];if(e.ca){if(!Array.isArray(e.ca)){e.ca=[e.ca]}e.ca.forEach((function(e){f.push("-certfile");f.push(e)}))}var p=[a];s.createPasswordFile({cipher:"",password:t,passType:"in"},f,p);s.createPasswordFile({cipher:"",password:t,passType:"out"},f,p);n.spawnWrapper(f,false,(function(e,r){function done(e){if(e){o(e)}else{o(null,r===0)}}s.deleteTempFiles(p,(function(r){done(e||r)}))}))}}))}},762:e=>{function debug(e,r){if(process.env.CI==="true"){console.log(`::group::${e}`);console.log(JSON.stringify(r,null,3));console.log("::endgroup::")}}e.exports={debug:debug}},649:(e,r,t)=>{"use strict";var n=t(17);var s=t(147);var i=t(113);var o=t(284);var a=process.env.PEMJS_TMPDIR||o();e.exports.isNumber=function(e){if(Array.isArray(e)){return false}return/^\d+$/g.test(e)};e.exports.isHex=function isHex(e){return/^(0x){0,1}([0-9A-F]{1,40}|[0-9A-F]{1,40})$/gi.test(e)};e.exports.toHex=function toHex(e){var r="";for(var t=0;t<e.length;t++){r+=""+e.charCodeAt(t).toString(16)}return r};e.exports.ciphers=["aes128","aes192","aes256","camellia128","camellia192","camellia256","des","des3","idea"];var c=e.exports.ciphers;e.exports.createPasswordFile=function(e,r,t){if(!e||!Object.prototype.hasOwnProperty.call(e,"password")||!Object.prototype.hasOwnProperty.call(e,"passType")||!/^(word|in|out)$/.test(e.passType)){return false}var o=n.join(a,i.randomBytes(20).toString("hex"));t.push(o);e.password=e.password.trim();if(e.password===""){e.mustPass=true}if(e.cipher&&c.indexOf(e.cipher)!==-1){r.push("-"+e.cipher)}r.push("-pass"+e.passType);if(e.mustPass){r.push("pass:"+e.password)}else{s.writeFileSync(o,e.password);r.push("file:"+o)}return true};e.exports.deleteTempFiles=function(e,r){var t=[];if(typeof e==="string"){t.push(e)}else if(Array.isArray(e)){t=e}else{return r(new Error("Unexcepted files parameter type; only string or array supported"))}var deleteSeries=function(e,r){if(e.length){var t=e.shift();var myCallback=function(t){if(t&&t.code==="ENOENT"){return deleteSeries(e,r)}else if(t){return r(t)}else{return deleteSeries(e,r)}};if(t&&typeof t==="string"){s.unlink(t,myCallback)}else{return deleteSeries(e,r)}}else{return r(null)}};deleteSeries(t,r)}},702:(e,r,t)=>{var n=t(649);var{debug:s}=t(762);var i=t(81).spawn;var o=t(17);var a=t(147);var c=t(284);var u=t(113);var f=t(207);var p={};var l=process.env.PEMJS_TMPDIR||c();const d=new RegExp("^(OpenSSL|LibreSSL) (((\\d+).(\\d+)).(\\d+))([a-z]+)?");if("CI"in process.env&&process.env.CI==="true"){if("LIBRARY"in process.env&&"VERSION"in process.env&&process.env.LIBRARY!=""&&process.env.VERSION!=""){const e=`./openssl/${process.env.LIBRARY}_v${process.env.VERSION}/bin/openssl`;if(a.existsSync(e)){process.env.OPENSSL_BIN=e}}}function set(e,r){p[e]=r}function get(e){return p[e]||null}function exec(e,r,t,n){if(!n&&typeof t==="function"){n=t;t=false}spawnWrapper(e,t,(function(e,t,s,i){var o,a;if(e){return n(e)}if(o=s.match(new RegExp("-+BEGIN "+r+"-+$","mu"))){o=o.index}else{o=-1}if(r==="EC PARAMETERS"){r="EC PRIVATE KEY"}if(a=s.match(new RegExp("^\\-+END "+r+"\\-+","m"))){a=a.index+a[0].length}else{a=-1}if(o>=0&&a>=0){return n(null,s.substring(o,a))}else{return n(new Error(r+" not found from openssl output:\n---stdout---\n"+s+"\n---stderr---\n"+i+"\ncode: "+t))}}))}function execBinary(e,r,t){if(!t&&typeof r==="function"){t=r;r=false}spawnWrapper(e,r,true,(function(e,r,n,i){s("execBinary",{err:e,code:r,stdout:n,stderr:i});if(e){return t(e)}return t(null,n)}))}function spawn(e,r,t){var n=get("pathOpenSSL")||process.env.OPENSSL_BIN||"openssl";testOpenSSLPath(n,(function(s){if(s){return t(s)}var o=i(n,e);var a="";var c=r?Buffer.alloc(0):"";o.stdout.on("data",(function(e){if(!r){c+=e.toString("binary")}else{c=Buffer.concat([c,e])}}));o.stderr.on("data",(function(e){a+=e.toString("binary")}));var u=2;var f=-1;var p=false;var done=function(r){if(p){return}if(r){p=true;return t(r)}if(--u<1){p=true;if(f!==0){if(f===2&&(a===""||/depth lookup: unable to/.test(a)||/depth lookup: self(-|\s)signed certificate/.test(a))){return t(null,f,c,a)}return t(new Error("Invalid openssl exit code: "+f+"\n% openssl "+e.join(" ")+"\n"+a),f)}else{return t(null,f,c,a)}}};o.on("error",done);o.on("exit",(function(e){f=e;done()}));o.on("close",(function(){c=r?c:Buffer.from(c,"binary").toString("utf-8");a=Buffer.from(a,"binary").toString("utf-8");done()}))}))}function spawnWrapper(e,r,t,i){if(!i&&typeof t==="function"){i=t;t=false}var c=[];var f=[];if(r){r=[].concat(r);var p,d;for(d=0;d<e.length;d++){if(e[d]==="--TMPFILE--"){p=o.join(l,u.randomBytes(20).toString("hex"));c.push({path:p,contents:r.shift()});e[d]=p;f.push(p)}}}var h;for(d=0;d<c.length;d++){h=c[d];a.writeFileSync(h.path,h.contents)}spawn(e,t,(function(r,t,o,a){n.deleteTempFiles(f,(function(n){s(e[0],{err:r,fsErr:n,code:t,stdout:o,stderr:a});i(r||n,t,o,a)}))}))}function testOpenSSLPath(e,r){f(e,(function(t){if(t){return r(new Error("Could not find openssl on your system on this path: "+e))}r()}))}spawn(["version"],false,(function(e,r,t,n){var s=String(t)+"\n"+String(n)+"\n"+String(e);let i=d.exec(s);if(i===null||i.length<=7)return;set("openSslVersion",i[1].toUpperCase());set("Vendor",i[1].toUpperCase());set("VendorVersion",i[2]);set("VendorVersionMajorMinor",i[3]);set("VendorVersionMajor",i[4]);set("VendorVersionMinor",i[5]);set("VendorVersionPatch",i[6]);set("VendorVersionBuildChar",typeof i[7]==="undefined"?"":i[7])}));e.exports={exec:exec,execBinary:execBinary,spawn:spawn,spawnWrapper:spawnWrapper,settings:p,set:set,get:get}},214:(e,r,t)=>{"use strict";const{debug:n}=t(762);const{promisify:s}=t(525);var i=t(808);var o=t(649);var a=t(702);const c=t(711);e.exports.createPrivateKey=createPrivateKey;e.exports.createDhparam=createDhparam;e.exports.createEcparam=createEcparam;e.exports.createCSR=createCSR;e.exports.createCertificate=createCertificate;e.exports.readCertificateInfo=readCertificateInfo;e.exports.getPublicKey=getPublicKey;e.exports.getFingerprint=getFingerprint;e.exports.getModulus=getModulus;e.exports.getDhparamInfo=getDhparamInfo;e.exports.createPkcs12=createPkcs12;e.exports.readPkcs12=readPkcs12;e.exports.verifySigningChain=verifySigningChain;e.exports.checkCertificate=checkCertificate;e.exports.checkPkcs12=checkPkcs12;e.exports.config=config;e.exports.convert=t(254);var u="-----BEGIN PRIVATE KEY-----";var f="-----END PRIVATE KEY-----";var p="-----BEGIN RSA PRIVATE KEY-----";var l="-----END RSA PRIVATE KEY-----";var d="-----BEGIN ENCRYPTED PRIVATE KEY-----";var h="-----END ENCRYPTED PRIVATE KEY-----";var g="-----BEGIN CERTIFICATE-----";var v="-----END CERTIFICATE-----";function createPrivateKey(e,r,t){if(!t&&!r&&typeof e==="function"){t=e;e=undefined;r={}}else if(!t&&e&&typeof r==="function"){t=r;r={}}e=Number(e)||2048;var s=["genrsa"];var i=[];if(r&&r.cipher&&Number(o.ciphers.indexOf(r.cipher))!==-1&&r.password){n("helper.createPasswordFile",{cipher:r.cipher,password:r.password,passType:"out"});o.createPasswordFile({cipher:r.cipher,password:r.password,passType:"out"},s,i)}s.push(e);n("version",a.get("openSslVersion"));a.exec(s,"(RSA |ENCRYPTED |)PRIVATE KEY",(function(e,r){function done(e){if(e){return t(e)}return t(null,{key:r})}o.deleteTempFiles(i,(function(t){n("createPrivateKey",{sslErr:e,fsErr:t,key:r,keyLength:r&&r.length});done(e||t)}))}))}function createDhparam(e,r){if(!r&&typeof e==="function"){r=e;e=undefined}e=Number(e)||512;var t=["dhparam","-outform","PEM",e];a.exec(t,"DH PARAMETERS",(function(e,t){if(e){return r(e)}return r(null,{dhparam:t})}))}function createEcparam(e,r,t,n){if(!n&&typeof t==="undefined"&&!r&&typeof e==="function"){n=e;e=undefined}else if(!n&&typeof t==="undefined"&&e&&typeof r==="function"){n=r;r=undefined}else if(!n&&typeof t==="function"&&e&&r){n=t;t=undefined}e=e||"secp256k1";r=r||"explicit";t=t||false;var s=["ecparam","-name",e,"-genkey","-param_enc",r];var i="EC PARAMETERS";if(t){s.push("-noout");i="EC PRIVATE KEY"}a.exec(s,i,(function(e,r){if(e){return n(e)}return n(null,{ecparam:r})}))}function createCSR(e,r){if(!r&&typeof e==="function"){r=e;e=undefined}let t=[];e=e||{};if(e.commonName&&(i.isIPv4(e.commonName)||i.isIPv6(e.commonName))){if(!e.altNames){e.altNames=[e.commonName]}else if(e.altNames.indexOf(e.commonName)===-1){e.altNames=e.altNames.concat([e.commonName])}}if(!e.clientKey){if(e&&(e.password||e.clientKeyPassword)){e.password=e.password||e.clientKeyPassword||""}createPrivateKey(e.keyBitsize||2048,e,(function(t,n){if(t){return r(t)}e.clientKey=n.key;createCSR(e,r)}));return}var n=["req","-new","-"+(e.hash||"sha256")];if(e.csrConfigFile){n.push("-config");n.push(e.csrConfigFile)}else{n.push("-subj");n.push(generateCSRSubject(e))}n.push("-key");n.push("--TMPFILE--");var s=[e.clientKey];var c=null;if(e&&(e.password||e.clientKeyPassword)){o.createPasswordFile({cipher:"",password:e.password||e.clientKeyPassword,passType:"in"},n,t)}if(e.altNames&&Array.isArray(e.altNames)&&e.altNames.length){n.push("-extensions");n.push("v3_req");n.push("-config");n.push("--TMPFILE--");var u=[];for(var f=0;f<e.altNames.length;f++){u.push((i.isIP(e.altNames[f])?"IP":"DNS")+"."+(f+1)+" = "+e.altNames[f])}s.push(c=["[req]","req_extensions = v3_req","distinguished_name = req_distinguished_name","[v3_req]","subjectAltName = @alt_names","[alt_names]",u.join("\n"),"[req_distinguished_name]","commonName = Common Name","commonName_max = 64"].join("\n"))}else if(e.config){c=e.config}if(e.clientKeyPassword){o.createPasswordFile({cipher:"",password:e.clientKeyPassword,passType:"in"},n,t)}a.exec(n,"CERTIFICATE REQUEST",s,(function(n,s){function done(t){if(t){return r(t)}r(null,{csr:s,config:c,clientKey:e.clientKey})}o.deleteTempFiles(t,(function(e){done(n||e)}))}))}function createCertificate(e,r){if(!r&&typeof e==="function"){r=e;e=undefined}e=e||{};if(!e.csr){createCSR(e,(function(t,n){if(t){return r(t)}e.csr=n.csr;e.config=n.config;e.clientKey=n.clientKey;createCertificate(e,r)}));return}if(!e.clientKey){e.clientKey=""}if(!e.serviceKey){if(e.selfSigned){e.serviceKey=e.clientKey}else{createPrivateKey(e.keyBitsize||2048,{cipher:e.cipher,password:e.clientKeyPassword||""},(function(t,n){if(t){return r(t)}e.serviceKey=n.key;createCertificate(e,r)}));return}}readCertificateInfo(e.csr,(function(t,n){if(t){return r(t)}var s=["x509","-req","-"+(e.hash||"sha256"),"-days",Number(e.days)||"365","-in","--TMPFILE--"];var i=[e.csr];var c=[];if(e.serviceCertificate){s.push("-CA");s.push("--TMPFILE--");s.push("-CAkey");s.push("--TMPFILE--");if(e.serial){s.push("-set_serial");if(o.isNumber(e.serial)){s.push("0x"+("0000000000000000000000000000000000000000"+e.serial.toString(16)).slice(-40))}else{if(o.isHex(e.serial)){if(e.serial.startsWith("0x")){e.serial=e.serial.substring(2,e.serial.length)}s.push("0x"+("0000000000000000000000000000000000000000"+e.serial).slice(-40))}else{s.push("0x"+("0000000000000000000000000000000000000000"+o.toHex(e.serial)).slice(-40))}}}else{s.push("-CAcreateserial");if(e.serialFile){s.push("-CAserial");s.push(e.serialFile+".srl")}}if(e.serviceKeyPassword){o.createPasswordFile({cipher:"",password:e.serviceKeyPassword,passType:"in"},s,c)}i.push(e.serviceCertificate);i.push(e.serviceKey)}else{s.push("-signkey");s.push("--TMPFILE--");if(e.serviceKeyPassword){o.createPasswordFile({cipher:"",password:e.serviceKeyPassword,passType:"in"},s,c)}i.push(e.serviceKey)}if(e.config){s.push("-extensions");s.push("v3_req");s.push("-extfile");s.push("--TMPFILE--");i.push(e.config)}else if(e.extFile){s.push("-extfile");s.push(e.extFile)}else{var u=[];if(n&&n.san){for(var f=0;f<n.san.dns.length;f++){u.push("DNS"+"."+(f+1)+" = "+n.san.dns[f])}for(var p=0;p<n.san.ip.length;p++){u.push("IP"+"."+(p+1)+" = "+n.san.ip[p])}for(var l=0;l<n.san.email.length;l++){u.push("email"+"."+(l+1)+" = "+n.san.email[l])}s.push("-extensions");s.push("v3_req");s.push("-extfile");s.push("--TMPFILE--");i.push(["[v3_req]","subjectAltName = @alt_names","[alt_names]",u.join("\n")].join("\n"))}}if(e.clientKeyPassword){o.createPasswordFile({cipher:"",password:e.clientKeyPassword,passType:"in"},s,c)}a.exec(s,"CERTIFICATE",i,(function(t,n){function done(t){if(t){return r(t)}var s={csr:e.csr,clientKey:e.clientKey,certificate:n,serviceKey:e.serviceKey};return r(null,s)}o.deleteTempFiles(c,(function(e){done(t||e)}))}))}))}function getPublicKey(e,r){if(!r&&typeof e==="function"){r=e;e=undefined}e=(e||"").toString();var t;if(e.match(/BEGIN(\sNEW)? CERTIFICATE REQUEST/)){t=["req","-in","--TMPFILE--","-pubkey","-noout"]}else if(e.match(/BEGIN RSA PRIVATE KEY/)||e.match(/BEGIN PRIVATE KEY/)){t=["rsa","-in","--TMPFILE--","-pubout"]}else{t=["x509","-in","--TMPFILE--","-pubkey","-noout"]}a.exec(t,"PUBLIC KEY",e,(function(e,t){if(e){return r(e)}return r(null,{publicKey:t})}))}function readCertificateInfo(e,r){if(!r&&typeof e==="function"){r=e;e=undefined}e=(e||"").toString();var t=e.match(/BEGIN(\sNEW)? CERTIFICATE REQUEST/);var n=t?"req":"x509";var s=[n,"-noout","-nameopt","RFC2253,sep_multiline,space_eq,-esc_msb,utf8","-text","-in","--TMPFILE--"];a.spawnWrapper(s,e,(function(e,t,n,s){if(e){return r(e)}else if(s){return r(s)}return fetchCertificateData(n,r)}))}function getModulus(e,r,t,n){if(!n&&!t&&typeof r==="function"){n=r;r=undefined;t=false}else if(!n&&t&&typeof t==="function"){n=t;t=false}if(t&&t!=="md5"){t=false}e=Buffer.isBuffer(e)&&e.toString()||e;let s;if(e.match(/BEGIN(\sNEW)? CERTIFICATE REQUEST/)){s="req"}else if(e.match(/BEGIN RSA PRIVATE KEY/)||e.match(/BEGIN PRIVATE KEY/)){s="rsa"}else{s="x509"}let i=[s,"-noout","-modulus","-in","--TMPFILE--"];let u=[];if(r){o.createPasswordFile({cipher:"",password:r,passType:"in"},i,u)}a.spawnWrapper(i,e,(function(e,r,s,i){function done(e){if(e){return n(e)}var r=s.match(/Modulus=([0-9a-fA-F]+)$/m);if(r){if(t==="md5"){return n(null,{modulus:c(r[1])})}return n(null,{modulus:r[1]})}else{return n(new Error("No modulus"))}}o.deleteTempFiles(u,(function(r){done(e||r||i)}))}))}function getDhparamInfo(e,r){e=Buffer.isBuffer(e)&&e.toString()||e;var t=["dhparam","-text","-in","--TMPFILE--"];a.spawnWrapper(t,e,(function(e,t,n,s){if(e){return r(e)}else if(s){return r(s)}var i={};var o=n.match(/Parameters: \((\d+) bit\)/);if(o){i.size=Number(o[1])}var a="";n.split("\n").forEach((function(e){if(/\s+([0-9a-f][0-9a-f]:)+[0-9a-f]?[0-9a-f]?/g.test(e)){a+=e.trim()}}));if(a){i.prime=a}if(!o&&!a){return r(new Error("No DH info found"))}return r(null,i)}))}function config(e){Object.keys(e).forEach((function(r){a.set(r,e[r])}))}function getFingerprint(e,r,t){if(!t&&typeof r==="function"){t=r;r=undefined}r=r||"sha1";var n=["x509","-in","--TMPFILE--","-fingerprint","-noout","-"+r];a.spawnWrapper(n,e,(function(e,r,n,s){if(e){return t(e)}else if(s){return t(s)}var i=n.match(/Fingerprint=([0-9a-fA-F:]+)$/m);if(i){return t(null,{fingerprint:i[1]})}else{return t(new Error("No fingerprint"))}}))}function createPkcs12(e,r,t,n,s){if(!s&&typeof n==="function"){s=n;n={}}var i=["pkcs12","-export"];var c=[];if(n.cipher&&n.clientKeyPassword){o.createPasswordFile({cipher:n.cipher,password:n.clientKeyPassword,passType:"in"},i,c)}o.createPasswordFile({cipher:"",password:t,passType:"word"},i,c);i.push("-in");i.push("--TMPFILE--");i.push("-inkey");i.push("--TMPFILE--");var u=[r,e];if(n.certFiles){u.push(n.certFiles.join(""));i.push("-certfile");i.push("--TMPFILE--")}a.execBinary(i,u,(function(e,r){function done(e){if(e){return s(e)}return s(null,{pkcs12:r})}o.deleteTempFiles(c,(function(r){done(e||r)}))}))}function readPkcs12(e,r,t){if(!t&&typeof r==="function"){t=r;r={}}r.p12Password=r.p12Password||"";var s=[];var i=[];var c=["pkcs12","-in",e];o.createPasswordFile({cipher:"",password:r.p12Password,passType:"in"},c,i);if(Buffer.isBuffer(e)){s=[e];c[2]="--TMPFILE--"}if(a.get("Vendor")==="OPENSSL"&&a.get("VendorVersionMajor")>=3){c.push("-legacy");c.push("-traditional")}if(r.clientKeyPassword){o.createPasswordFile({cipher:"",password:r.clientKeyPassword,passType:"out"},c,i)}else{c.push("-nodes")}a.execBinary(c,s,(function(e,s){function done(e){var i={};if(e&&e.message.indexOf("No such file or directory")!==-1){e.code="ENOENT"}if(!e){var o=readFromString(s,g,v);i.cert=o.shift();i.ca=o;i.key=readFromString(s,u,f).pop();n("readPkcs12.execBinary - PRIVATE KEY - ?: ",i.key);if(i.key){return a.exec(["rsa","-in","--TMPFILE--"],"(RSA |)PRIVATE KEY",[i.key],(function(e,r){if(e){n("readPkcs12.execBinary - PRIVATE KEY convert - error: ",e)}i.key=r;return t(e,i)}))}if(r.clientKeyPassword){i.key=readFromString(s,d,h).pop();n("readPkcs12.execBinary - ENCRYPTED PRIVATE KEY - ?: ",i.key)}else{i.key=readFromString(s,p,l).pop();n("readPkcs12.execBinary - RSA PRIVATE KEY - ?: ",i.key)}}return t(e,i)}o.deleteTempFiles(i,(function(r){done(e||r)}))}))}function checkCertificate(e,r,t){var n;var s=[];if(!t&&typeof r==="function"){t=r;r=undefined}e=(e||"").toString();if(e.match(/BEGIN(\sNEW)? CERTIFICATE REQUEST/)){n=["req","-text","-noout","-verify","-in","--TMPFILE--"]}else if(e.match(/BEGIN RSA PRIVATE KEY/)||e.match(/BEGIN PRIVATE KEY/)){n=["rsa","-noout","-check","-in","--TMPFILE--"]}else{n=["x509","-text","-noout","-in","--TMPFILE--"]}if(r){o.createPasswordFile({cipher:"",password:r,passType:"in"},n,s)}a.spawnWrapper(n,e,(function(e,r,i,c){function done(e){i=i&&i.trim();var r;switch(n[0]){case"rsa":r=/^Rsa key ok$/i.test(i);break;default:r=/Signature Algorithm/im.test(i);break}if(!r){if(a.get("Vendor")==="OPENSSL"&&a.get("VendorVersionMajor")>=3){if(!(c&&c.toString().trim().endsWith("verify OK"))){return t(new Error(c.toString()))}}if(e&&e.toString().trim()!=="verify OK"){return t(e)}}t(null,r)}o.deleteTempFiles(s,(function(r){done(e||r||c)}))}))}function checkPkcs12(e,r,t){if(!t&&typeof r==="function"){t=r;r=""}var s=[];var i=[];var c=["pkcs12","-info","-in",e,"-noout","-maciter","-nodes"];o.createPasswordFile({cipher:"",password:r,passType:"in"},c,i);if(Buffer.isBuffer(e)){s=[e];c[3]="--TMPFILE--"}if(a.get("Vendor")==="OPENSSL"&&a.get("VendorVersionMajor")>=3){c.splice(2,0,"-legacy")}a.spawnWrapper(c,s,(function(e,r,s,a){n("checkPkcs12 error",{err:e,code:r,stdout:s,stdoutResult:/MAC verified OK/im.test(a)||!/MAC verified OK/im.test(a)&&!/Mac verify error/im.test(a),stderr:a});function done(e){if(e){return t(e)}t(null,/MAC verified OK/im.test(a)||!/MAC verified OK/im.test(a)&&!/Mac verify error/im.test(a))}o.deleteTempFiles(i,(function(t){n("checkPkcs12 clean-up error",{sslErr:e,fsErr:t,code:r,stdout:s,stdoutResult:/MAC verified OK/im.test(a)||!/MAC verified OK/im.test(a)&&!/Mac verify error/im.test(a),stderr:a});done(e||t)}))}))}function verifySigningChain(e,r,t){if(!t&&typeof r==="function"){t=r;r=undefined}if(!Array.isArray(e)){e=readFromString(e,g,v)}if(!Array.isArray(r)&&r!==undefined){if(r!==""){r=[r]}}var s=["verify"];var i=[];if(r!==undefined){s.push("-CAfile");s.push("--TMPFILE--");i.push(r.join("\n"))}var o=e.shift();if(e.length>0){s.push("-untrusted");s.push("--TMPFILE--");i.push(e.join("\n"))}s.push("--TMPFILE--");i.push(o);a.spawnWrapper(s,i,(function(e,r,s,i){n("Vendor",a.get("Vendor"));n("VendorVersionMajor",a.get("VendorVersionMajor"));n("openssl.get('VendorVersionMajor') >= 3",a.get("VendorVersionMajor")>=3);if(a.get("Vendor")==="OPENSSL"&&a.get("VendorVersionMajor")>=3){let o=!!(s&&s.trim().includes(": OK"));if(e){n("verifySigningChain error",{err:e,code:r,stdout:s,stdoutResult:o,stderr:i});return t(e)}n("verifySigningChain error - use stderr",{err:e,code:r,stdout:s.trim(),stdoutResult:o,stderr:i.trim()});return t(null,o)}if(e){n("verifySigningChain error",{err:e,code:r,stdout:s,stdoutResult:s&&s.trim().slice(-4)===": OK",stderr:i});return t(e)}n("verifySigningChain",{err:e,code:r,stdout:s,stdoutResult:s&&s.trim().slice(-4)===": OK",stderr:i});t(null,s&&s.trim().slice(-4)===": OK")}))}function fetchCertificateData(e,r){try{e=(e||"").toString();var t,n,s,i;var o={issuer:{}};var a={};var c;var u,f;if((t=e.match(/\s*Serial Number:\r?\n?\s*([^\r\n]*)\r?\n\s*\b/))&&t.length>1){o.serial=t[1]}if((n=e.match(/\s*Subject:\r?\n(\s*(([a-zA-Z0-9.]+)\s=\s[^\r\n]+\r?\n))*\s*\b/))&&n.length>1){n=n[0];s=matchAll(n,/\s([a-zA-Z0-9.]+)\s=\s([^\r\n].*)/g);if(s){for(f=0;f<s.length;f++){u=s[f][1].trim();if(u.match("(C|ST|L|O|OU|CN|emailAddress|DC)")||u===""){continue}o[u]=s[f][2].trim()}}s=n.match(/\sC\s=\s([^\r\n].*?)[\r\n]/);o.country=s&&s[1]||"";s=n.match(/\sST\s=\s([^\r\n].*?)[\r\n]/);o.state=s&&s[1]||"";s=n.match(/\sL\s=\s([^\r\n].*?)[\r\n]/);o.locality=s&&s[1]||"";s=matchAll(n,/\sO\s=\s([^\r\n].*)/g);o.organization=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(n,/\sOU\s=\s([^\r\n].*)/g);o.organizationUnit=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(n,/\sCN\s=\s([^\r\n].*)/g);o.commonName=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(n,/emailAddress\s=\s([^\r\n].*)/g);o.emailAddress=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(n,/\sDC\s=\s([^\r\n].*)/g);o.dc=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:""}if((i=e.match(/\s*Issuer:\r?\n(\s*([a-zA-Z0-9.]+)\s=\s[^\r\n].*\r?\n)*\s*\b/))&&i.length>1){i=i[0];s=matchAll(i,/\s([a-zA-Z0-9.]+)\s=\s([^\r\n].*)/g);for(f=0;f<s.length;f++){u=s[f][1].toString();if(u.match("(C|ST|L|O|OU|CN|emailAddress|DC)")){continue}o.issuer[u]=s[f][2].toString()}s=i.match(/\sC\s=\s([^\r\n].*?)[\r\n]/);o.issuer.country=s&&s[1]||"";s=i.match(/\sST\s=\s([^\r\n].*?)[\r\n]/);o.issuer.state=s&&s[1]||"";s=i.match(/\sL\s=\s([^\r\n].*?)[\r\n]/);o.issuer.locality=s&&s[1]||"";s=matchAll(i,/\sO\s=\s([^\r\n].*)/g);o.issuer.organization=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(i,/\sOU\s=\s([^\r\n].*)/g);o.issuer.organizationUnit=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(i,/\sCN\s=\s([^\r\n].*)/g);o.issuer.commonName=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:"";s=matchAll(i,/\sDC\s=\s([^\r\n].*)/g);o.issuer.dc=s?s.length>1?s.sort((function(e,r){var t=e[1].toUpperCase();var n=r[1].toUpperCase();return n>t?-1:t>n?1:0})).sort((function(e,r){return e[1].length-r[1].length})).map((function(e){return e[1]})):s[0][1]:""}if((c=e.match(/X509v3 Subject Alternative Name: \r?\n([^\r\n]*)\r?\n/))&&c.length>1){c=c[1].trim()+"\n";o.san={};s=pregMatchAll("DNS:([^,\\r\\n].*?)[,\\r\\n\\s]",c);o.san.dns=s||"";s=pregMatchAll("IP Address:([^,\\r\\n].*?)[,\\r\\n\\s]",c);o.san.ip=s||"";s=pregMatchAll("email:([^,\\r\\n].*?)[,\\r\\n\\s]",c);o.san.email=s||""}if((s=e.match(/Not Before\s?:\s?([^\r\n]*)\r?\n/))&&s.length>1){a.start=Date.parse(s&&s[1]||"")}if((s=e.match(/Not After\s?:\s?([^\r\n]*)\r?\n/))&&s.length>1){a.end=Date.parse(s&&s[1]||"")}if(a.start&&a.end){o.validity=a}if((s=e.match(/Signature Algorithm: ([^\r\n]*)\r?\n/))&&s.length>1){o.signatureAlgorithm=s&&s[1]||""}if((s=e.match(/Public[ -]Key: ([^\r\n]*)\r?\n/))&&s.length>1){o.publicKeySize=(s&&s[1]||"").replace(/[()]/g,"")}if((s=e.match(/Public Key Algorithm: ([^\r\n]*)\r?\n/))&&s.length>1){o.publicKeyAlgorithm=s&&s[1]||""}r(null,o)}catch(e){r(e)}}function matchAll(e,r){var t=[];e.replace(r,(function(){var e=[].slice.call(arguments,0);var r=e.splice(-2);e.index=r[0];e.input=r[1];t.push(e)}));return t.length?t:null}function pregMatchAll(e,r){var t=new RegExp(e,"g");var n=r.match(t)||[];var s=[];var i,o;for(var a=0;a<n.length;a++){i=new RegExp(e);o=n[a].match(i);s.push(o[1])}return s}function generateCSRSubject(e){e=e||{};var r={C:e.country||e.C,ST:e.state||e.ST,L:e.locality||e.L,O:e.organization||e.O,OU:e.organizationUnit||e.OU,CN:e.commonName||e.CN||"localhost",DC:e.dc||e.DC||"",emailAddress:e.emailAddress};var t=Object.keys(r).map((function(e){if(r[e]){if(typeof r[e]==="object"&&r[e].length>=1){var t="";r[e].map((function(r){t+="/"+e+"="+r.replace(/[^\w\s-!$%^&*()_+|~=`{}[\]:/;<>?,.@#]+/g," ").replace("/","\\/").replace("+","\\+").trim()}));return t}else{return"/"+e+"="+r[e].replace(/[^\w\s-!$%^&*()_+|~=`{}[\]:/;<>?,.@#]+/g," ").replace("/","\\/").replace("+","\\+").trim()}}}));return t.join("")}function readFromString(e,r,t){if(Buffer.isBuffer(e)){e=e.toString("utf8")}var n=[];if(!e){return n}var s=e.indexOf(r);while(s!==-1){e=e.substring(s);var i=e.indexOf(t);if(i===-1){break}i+=t.length;n.push(e.substring(0,i));s=e.indexOf(r,i)}return n}e.exports.promisified={createPrivateKey:s(createPrivateKey),createDhparam:s(createDhparam),createEcparam:s(createEcparam),createCSR:s(createCSR),createCertificate:s(createCertificate),readCertificateInfo:s(readCertificateInfo),getPublicKey:s(getPublicKey),getFingerprint:s(getFingerprint),getModulus:s(getModulus),getDhparamInfo:s(getDhparamInfo),createPkcs12:s(createPkcs12),readPkcs12:s(readPkcs12),verifySigningChain:s(verifySigningChain),checkCertificate:s(checkCertificate),checkPkcs12:s(checkPkcs12)}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var s=r[t]={exports:{}};var i=true;try{e[t](s,s.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return s.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var t=__nccwpck_require__(214);module.exports=t})();
//# sourceMappingURL=index.js.map{"version":3,"sources":["../webpack:/pem/node_modules/charenc/charenc.js","../webpack:/pem/node_modules/crypt/crypt.js","../webpack:/pem/node_modules/es6-promisify/dist/promisify.js","../webpack:/pem/node_modules/is-buffer/index.js","../webpack:/pem/node_modules/isexe/index.js","../webpack:/pem/node_modules/isexe/mode.js","../webpack:/pem/node_modules/isexe/windows.js","../webpack:/pem/node_modules/md5/md5.js","../webpack:/pem/node_modules/os-tmpdir/index.js","../webpack:/pem/node_modules/which/which.js","../webpack:/pem/external node-commonjs \"child_process\"","../webpack:/pem/external node-commonjs \"crypto\"","../webpack:/pem/external node-commonjs \"fs\"","../webpack:/pem/external node-commonjs \"net\"","../webpack:/pem/external node-commonjs \"path\"","../webpack:/pem/lib/convert.js","../webpack:/pem/lib/debug.js","../webpack:/pem/lib/helper.js","../webpack:/pem/lib/openssl.js","../webpack:/pem/lib/pem.js","../webpack:/pem/webpack/bootstrap","../webpack:/pem/webpack/runtime/compat","../webpack:/pem/webpack/startup"],"names":["charenc","utf8","stringToBytes","str","bin","unescape","encodeURIComponent","bytesToString","bytes","decodeURIComponent","escape","i","length","push","charCodeAt","String","fromCharCode","join","module","exports","base64map","crypt","rotl","n","b","rotr","endian","constructor","Number","randomBytes","Math","floor","random","bytesToWords","words","wordsToBytes","bytesToHex","hex","toString","hexToBytes","c","parseInt","substr","bytesToBase64","base64","triplet","j","charAt","base64ToBytes","replace","imod4","indexOf","pow","Object","defineProperty","value","promisify","customArgumentsToken","a","TypeError","Promise","Error","d","this","e","arguments","f","Array","g","h","forEach","apply","argumentNames","obj","isBuffer","isSlowBuffer","_isBuffer","readFloatLE","slice","fs","__webpack_require__","core","process","platform","global","TESTING_WINDOWS","isexe","sync","path","options","cb","resolve","reject","er","is","code","ignoreErrors","stat","checkStat","statSync","isFile","checkMode","mod","mode","uid","gid","myUid","undefined","getuid","myGid","getgid","u","o","ug","ret","checkPathExt","pathext","pathExt","env","PATHEXT","split","p","toLowerCase","isSymbolicLink","md5","message","encoding","prototype","call","isArray","Uint8Array","m","l","FF","_ff","GG","_gg","HH","_hh","II","_ii","aa","bb","cc","dd","x","s","t","_blocksize","_digestsize","digestbytes","asBytes","asString","isWindows","trailingSlashRe","TEMP","TMP","SystemRoot","windir","TMPDIR","test","OSTYPE","COLON","getNotFoundError","cmd","assign","getPathInfo","opt","colon","pathEnv","match","cwd","PATH","pathExtExe","unshift","which","found","step","all","ppRaw","pathPart","pCmd","subStep","ii","ext","then","res","whichSync","cur","ex","nothrow","require","openssl","helper","debug","PEM2DER","pathIN","pathOUT","type","callback","params","spawnWrapper","error","DER2PEM","PEM2P7B","pathBundleIN","cert","ca","P7B2PEM","PEM2PFX","password","key","delTempPWFiles","createPasswordFile","cipher","passType","done","deleteTempFiles","fsErr","PFX2PEM","P7B2PFX","tmpfile","title","content","CI","console","log","JSON","stringify","pathlib","crypto","osTmpdir","tempDir","PEMJS_TMPDIR","isNumber","isHex","toHex","ciphers","PasswordFileArray","hasOwnProperty","PasswordFile","trim","mustPass","writeFileSync","files","rmFiles","deleteSeries","list","finalCallback","file","shift","myCallback","err","unlink","cpspawn","settings","versionRegEx","RegExp","LIBRARY","VERSION","filePathOpenSSL","existsSync","OPENSSL_BIN","set","option","get","exec","searchStr","tmpfiles","stdout","stderr","start","end","index","substring","execBinary","spawn","binary","pathBin","testOpenSSLPath","Buffer","alloc","on","data","concat","needed","finished","from","fpath","contents","text","version","toUpperCase","net","hash_md5","createPrivateKey","createDhparam","createEcparam","createCSR","createCertificate","readCertificateInfo","getPublicKey","getFingerprint","getModulus","getDhparamInfo","createPkcs12","readPkcs12","verifySigningChain","checkCertificate","checkPkcs12","config","convert","KEY_START","KEY_END","RSA_KEY_START","RSA_KEY_END","ENCRYPTED_KEY_START","ENCRYPTED_KEY_END","CERT_START","CERT_END","keyBitsize","sslErr","keyLength","dhparam","keyName","paramEnc","noOut","searchString","ecparam","commonName","isIPv4","isIPv6","altNames","clientKey","clientKeyPassword","keyData","hash","csrConfigFile","generateCSRSubject","altNamesRep","isIP","csr","serviceKey","selfSigned","error2","data2","days","serviceCertificate","serial","startsWith","serialFile","serviceKeyPassword","extFile","san","dns","i2","ip","i3","email","response","certificate","publicKey","isMatch","fetchCertificateData","modulus","dh","result","size","prime","line","keys","k","fingerprint","certFiles","pkcs12","bufferOrPath","p12Password","args","keybundle","certs","readFromString","pop","passphrase","endsWith","splice","stdoutResult","leaf","openssl30Check","includes","certData","subject","tmp","issuer","certValues","validity","ky","matchAll","country","state","locality","organization","sort","r","map","organizationUnit","emailAddress","dc","pregMatchAll","Date","parse","signatureAlgorithm","publicKeySize","publicKeyAlgorithm","regexp","matches","arr","extras","input","regex","haystack","globalRegex","globalMatch","matchArray","nonGlobalRegex","nonGlobalMatch","csrData","C","ST","L","O","OU","CN","DC","csrBuilder","tmpStr","string","output","offset","endOffset","promisified","__webpack_module_cache__","moduleId","cachedModule","threw","__webpack_modules__","ab","__dirname","__webpack_exports__"],"mappings":"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","file":"index.js","sourcesContent":["var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n","(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.promisify=promisify;var customArgumentsToken=\"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\";function promisify(a){if(\"function\"!=typeof a)throw new TypeError(\"Argument to promisify must be a function\");var b=a[customArgumentsToken],c=promisify.Promise||Promise;if(\"function\"!=typeof c)throw new Error(\"No Promise implementation found; do you need a polyfill?\");return function(){for(var d=this,e=arguments.length,f=Array(e),g=0;g<e;g++)f[g]=arguments[g];return new c(function(c,e){f.push(function(a){if(a)return e(a);for(var d=arguments.length,f=Array(1<d?d-1:0),g=1;g<d;g++)f[g-1]=arguments[g];if(1===f.length||!b)return c(f[0]);var h={};f.forEach(function(a,c){var d=b[c];d&&(h[d]=a)}),c(h)}),a.apply(d,f)})}}promisify.argumentNames=\"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\",promisify.Promise=void 0;\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      isBuffer = require('is-buffer'),\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message) && message.constructor !== Uint8Array)\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n","'use strict';\nvar isWindows = process.platform === 'win32';\nvar trailingSlashRe = isWindows ? /[^:]\\\\$/ : /.\\/$/;\n\n// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43\nmodule.exports = function () {\n\tvar path;\n\n\tif (isWindows) {\n\t\tpath = process.env.TEMP ||\n\t\t\tprocess.env.TMP ||\n\t\t\t(process.env.SystemRoot || process.env.windir) + '\\\\temp';\n\t} else {\n\t\tpath = process.env.TMPDIR ||\n\t\t\tprocess.env.TMP ||\n\t\t\tprocess.env.TEMP ||\n\t\t\t'/tmp';\n\t}\n\n\tif (trailingSlashRe.test(path)) {\n\t\tpath = path.slice(0, -1);\n\t}\n\n\treturn path;\n};\n","const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"path\");","'use strict'\n\nvar openssl = require('./openssl.js')\nvar helper = require('./helper.js')\nvar {debug} = require('./debug.js')\n\n// PEM format: .pem, .crt, .cer (!bin), .key\n// base64 encoded; the cert file might also include the private key; so key file is optional\n\n// DER format: .der, .cer (bin)\n// binary encoded format; cannot include key file\n\n// PKCS#7 / P7B format: .p7b, .p7c\n// contains cert and ca chain cert files, but not the key file\n// A PKCS7 certificate is serialized using either PEM or DER format.\n\n// PKCS#12 / PFX format: .pfx, .p12\n// contains all files: key file, cert and ca chain cert files\n\n/**\n * pem convert module\n *\n * @module convert\n */\n\n/**\n * conversion from PEM to DER format\n * if private key is included in PEM encoded file, it won't be included in DER file\n * use this method with type 'rsa' to export private key in that case\n * @param  {String} pathIN  path of the PEM encoded certificate file\n * @param  {String} pathOUT path of the DER encoded certificate file to generate\n * @param  {String} [type] type of file, use 'rsa' for key file, 'x509' otherwise or leave this parameter out\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.PEM2DER = function (pathIN, pathOUT, type, callback) {\n  if (!callback && typeof type === 'function') {\n    callback = type\n    type = 'x509'\n  }\n  var params = [\n    type,\n    '-outform',\n    'der',\n    '-in',\n    pathIN,\n    '-out',\n    pathOUT\n  ]\n  openssl.spawnWrapper(params, false, function (error, code) {\n    if (error) {\n      callback(error)\n    } else {\n      callback(null, code === 0)\n    }\n  })\n}\n\n/**\n * conversion from DER to PEM format\n * @param  {String} pathIN  path of the DER encoded certificate file\n * @param  {String} pathOUT path of the PEM encoded certificate file to generate\n * @param  {String} [type] type of file, use 'rsa' for key file, 'x509' otherwise or leave this parameter out\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.DER2PEM = function (pathIN, pathOUT, type, callback) {\n  if (!callback && typeof type === 'function') {\n    callback = type\n    type = 'x509'\n  }\n  var params = [\n    type,\n    '-inform',\n    'der',\n    '-in',\n    pathIN,\n    '-out',\n    pathOUT\n  ]\n  openssl.spawnWrapper(params, false, function (error, code) {\n    if (error) {\n      callback(error)\n    } else {\n      callback(null, code === 0)\n    }\n  })\n}\n\n/**\n * conversion from PEM to P7B format\n * @param  {Object} pathBundleIN  paths of the PEM encoded certificate files ({cert: '...', ca: '...' or ['...', ...]})\n * @param  {String} pathOUT path of the P7B encoded certificate file to generate\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.PEM2P7B = function (pathBundleIN, pathOUT, callback) {\n  var params = [\n    'crl2pkcs7',\n    '-nocrl',\n    '-certfile',\n    pathBundleIN.cert,\n    '-out',\n    pathOUT\n  ]\n  if (pathBundleIN.ca) {\n    if (!Array.isArray(pathBundleIN.ca)) {\n      pathBundleIN.ca = [pathBundleIN.ca]\n    }\n    pathBundleIN.ca.forEach(function (ca) {\n      params.push('-certfile')\n      params.push(ca)\n    })\n  }\n  openssl.spawnWrapper(params, false, function (error, code) {\n    if (error) {\n      callback(error)\n    } else {\n      callback(null, code === 0)\n    }\n  })\n}\n\n/**\n * conversion from P7B to PEM format\n * @param  {String} pathIN  path of the P7B encoded certificate file\n * @param  {String} pathOUT path of the PEM encoded certificate file to generate\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.P7B2PEM = function (pathIN, pathOUT, callback) {\n  var params = [\n    'pkcs7',\n    '-print_certs',\n    '-in',\n    pathIN,\n    '-out',\n    pathOUT\n  ]\n  openssl.spawnWrapper(params, false, function (error, code) {\n    if (error) {\n      callback(error)\n    } else {\n      callback(null, code === 0)\n    }\n  })\n}// TODO: CA also included?\n\n/**\n * conversion from PEM to PFX\n * @param  {Object} pathBundleIN paths of the PEM encoded certificate files ({cert: '...', key: '...', ca: '...' or ['...', ...]})\n * @param  {String} pathOUT path of the PFX encoded certificate file to generate\n * @param  {String} password password to set for accessing the PFX file\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.PEM2PFX = function (pathBundleIN, pathOUT, password, callback) {\n  var params = [\n    'pkcs12',\n    '-export',\n    '-out',\n    pathOUT,\n    '-inkey',\n    pathBundleIN.key,\n    '-in',\n    pathBundleIN.cert\n  ]\n  if (pathBundleIN.ca) {\n    if (!Array.isArray(pathBundleIN.ca)) {\n      pathBundleIN.ca = [pathBundleIN.ca]\n    }\n    pathBundleIN.ca.forEach(function (ca) {\n      params.push('-certfile')\n      params.push(ca)\n    })\n  }\n  var delTempPWFiles = []\n  helper.createPasswordFile({ cipher: '', password: password, passType: 'in' }, params, delTempPWFiles)\n  helper.createPasswordFile({ cipher: '', password: password, passType: 'out' }, params, delTempPWFiles)\n  openssl.spawnWrapper(params, false, function (error, code) {\n    function done (error) {\n      if (error) {\n        callback(error)\n      } else {\n        callback(null, code === 0)\n      }\n    }\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(error || fsErr)\n    })\n  })\n}\n\n/**\n * conversion from PFX to PEM\n * @param  {Object} pathIN  path of the PFX encoded certificate file\n * @param  {String} pathOUT path of the PEM encoded certificate file to generate\n * @param  {String} password password to set for accessing the PFX file\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.PFX2PEM = function (pathIN, pathOUT, password, callback) {\n  var params = [\n    'pkcs12',\n    '-in',\n    pathIN,\n    '-out',\n    pathOUT,\n    '-nodes'\n  ]\n  var delTempPWFiles = []\n  helper.createPasswordFile({ cipher: '', password: password, passType: 'in' }, params, delTempPWFiles)\n  helper.createPasswordFile({ cipher: '', password: password, passType: 'out' }, params, delTempPWFiles)\n  openssl.spawnWrapper(params, false, function (error, code) {\n    function done (error) {\n      if (error) {\n        callback(error)\n      } else {\n        callback(null, code === 0)\n      }\n    }\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(error || fsErr)\n    })\n  })\n}\n\n/**\n * conversion from P7B to PFX/PKCS#12\n * @param  {Object} pathBundleIN  paths of the PEM encoded certificate files ({cert: '...', key: '...', ca: '...' or ['...', ...]})\n * @param  {String} pathOUT path of the PFX certificate file to generate\n * @param  {String} password password to be set for the PFX file and to be used to access the key file\n * @param  {Function} callback callback method called with error, boolean result\n */\nmodule.exports.P7B2PFX = function (pathBundleIN, pathOUT, password, callback) {\n  var tmpfile = pathBundleIN.cert.replace(/\\.[^.]+$/, '.cer')\n  var params = [\n    'pkcs7',\n    '-print_certs',\n    '-in',\n    pathBundleIN.cert,\n    '-out',\n    tmpfile\n  ]\n  openssl.spawnWrapper(params, false, function (error, code) {\n    debug(\"P7B2PFX\", {\n      error, code\n    })\n    if (error) {\n      callback(error)\n    } else {\n      var params = [\n        'pkcs12',\n        '-export',\n        '-in',\n        tmpfile,\n        '-inkey',\n        pathBundleIN.key,\n        '-out',\n        pathOUT\n      ]\n      if (pathBundleIN.ca) {\n        if (!Array.isArray(pathBundleIN.ca)) {\n          pathBundleIN.ca = [pathBundleIN.ca]\n        }\n        pathBundleIN.ca.forEach(function (ca) {\n          params.push('-certfile')\n          params.push(ca)\n        })\n      }\n      var delTempPWFiles = [tmpfile]\n      helper.createPasswordFile({ cipher: '', password: password, passType: 'in' }, params, delTempPWFiles)\n      helper.createPasswordFile({ cipher: '', password: password, passType: 'out' }, params, delTempPWFiles)\n      openssl.spawnWrapper(params, false, function (error, code) {\n        function done (error) {\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, code === 0)\n          }\n        }\n        helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n          done(error || fsErr)\n        })\n      })\n    }\n  })\n}\n","function debug (title, content) {\n  if (process.env.CI === 'true') {\n    console.log(`::group::${title}`)\n    console.log(JSON.stringify(content, null, 3))\n    console.log('::endgroup::')\n  }\n}\n\nmodule.exports = {\n  debug: debug\n}\n","'use strict'\r\n\r\nvar pathlib = require('path')\r\nvar fs = require('fs')\r\nvar crypto = require('crypto')\r\nvar osTmpdir = require('os-tmpdir')\r\nvar tempDir = process.env.PEMJS_TMPDIR || osTmpdir()\r\n\r\n/**\r\n * pem helper module\r\n *\r\n * @module helper\r\n */\r\n\r\n/**\r\n * helper function to check is the string a number or not\r\n * @param {String} str String that should be checked to be a number\r\n */\r\nmodule.exports.isNumber = function (str) {\r\n  if (Array.isArray(str)) {\r\n    return false\r\n  }\r\n  /*\r\n  var bstr = str && str.toString()\r\n  str = str + ''\r\n\r\n  return bstr - parseFloat(bstr) + 1 >= 0 &&\r\n          !/^\\s+|\\s+$/g.test(str) && /^\\d+$/g.test(str) &&\r\n          !isNaN(str) && !isNaN(parseFloat(str))\r\n  */\r\n  return /^\\d+$/g.test(str)\r\n}\r\n\r\n/**\r\n * helper function to check is the string a hexaceximal value\r\n * @param {String} hex String that should be checked to be a hexaceximal\r\n */\r\nmodule.exports.isHex = function isHex (hex) {\r\n  return /^(0x){0,1}([0-9A-F]{1,40}|[0-9A-F]{1,40})$/gi.test(hex)\r\n}\r\n\r\n/**\r\n * helper function to convert a string to a hexaceximal value\r\n * @param {String} str String that should be converted to a hexaceximal\r\n */\r\nmodule.exports.toHex = function toHex (str) {\r\n  var hex = ''\r\n  for (var i = 0; i < str.length; i++) {\r\n    hex += '' + str.charCodeAt(i).toString(16)\r\n  }\r\n  return hex\r\n}\r\n\r\n// cipherPassword returns an array of supported ciphers.\r\n/**\r\n * list of supported ciphers\r\n * @type {Array}\r\n */\r\nmodule.exports.ciphers = ['aes128', 'aes192', 'aes256', 'camellia128', 'camellia192', 'camellia256', 'des', 'des3', 'idea']\r\nvar ciphers = module.exports.ciphers\r\n\r\n/**\r\n * Creates a PasswordFile to hide the password form process infos via `ps auxf` etc.\r\n * @param {Object} options object of cipher, password and passType, mustPass, {cipher:'aes128', password:'xxxx', passType:\"in/out/word\"}, if the object empty we do nothing\r\n * @param {String} options.cipher cipher like 'aes128', 'aes192', 'aes256', 'camellia128', 'camellia192', 'camellia256', 'des', 'des3', 'idea'\r\n * @param {String} options.password password can be empty or at last 4 to 1023 chars\r\n * @param {String} options.passType passType: can be in/out/word for passIN/passOUT/passWORD\r\n * @param {Boolean} options.mustPass mustPass is used when you need to set the pass like as \"-password pass:\" most needed when empty password\r\n * @param {Object} params params will be extended with the data that need for the openssl command. IS USED AS POINTER!\r\n * @param {String} PasswordFileArray PasswordFileArray is an array of filePaths that later need to deleted ,after the openssl command. IS USED AS POINTER!\r\n * @return {Boolean} result\r\n */\r\nmodule.exports.createPasswordFile = function (options, params, PasswordFileArray) {\r\n  if (!options || !Object.prototype.hasOwnProperty.call(options, 'password') || !Object.prototype.hasOwnProperty.call(options, 'passType') || !/^(word|in|out)$/.test(options.passType)) {\r\n    return false\r\n  }\r\n  var PasswordFile = pathlib.join(tempDir, crypto.randomBytes(20).toString('hex'))\r\n  PasswordFileArray.push(PasswordFile)\r\n  options.password = options.password.trim()\r\n  if (options.password === '') {\r\n    options.mustPass = true\r\n  }\r\n  if (options.cipher && (ciphers.indexOf(options.cipher) !== -1)) {\r\n    params.push('-' + options.cipher)\r\n  }\r\n  params.push('-pass' + options.passType)\r\n  if (options.mustPass) {\r\n    params.push('pass:' + options.password)\r\n  } else {\r\n    fs.writeFileSync(PasswordFile, options.password)\r\n    params.push('file:' + PasswordFile)\r\n  }\r\n  return true\r\n}\r\n\r\n/**\r\n * Deletes a file or an array of files\r\n * @param {Array} files array of files that shoudld be deleted\r\n * @param {errorCallback} callback Callback function with an error object\r\n */\r\nmodule.exports.deleteTempFiles = function (files, callback) {\r\n  var rmFiles = []\r\n  if (typeof files === 'string') {\r\n    rmFiles.push(files)\r\n  } else if (Array.isArray(files)) {\r\n    rmFiles = files\r\n  } else {\r\n    return callback(new Error('Unexcepted files parameter type; only string or array supported'))\r\n  }\r\n  var deleteSeries = function (list, finalCallback) {\r\n    if (list.length) {\r\n      var file = list.shift()\r\n      var myCallback = function (err) {\r\n        if (err && err.code === 'ENOENT') {\r\n          // file doens't exist\r\n          return deleteSeries(list, finalCallback)\r\n        } else if (err) {\r\n          // other errors, e.g. maybe we don't have enough permission\r\n          return finalCallback(err)\r\n        } else {\r\n          return deleteSeries(list, finalCallback)\r\n        }\r\n      }\r\n      if (file && typeof file === 'string') {\r\n        fs.unlink(file, myCallback)\r\n      } else {\r\n        return deleteSeries(list, finalCallback)\r\n      }\r\n    } else {\r\n      return finalCallback(null) // no errors\r\n    }\r\n  }\r\n  deleteSeries(rmFiles, callback)\r\n}\r\n/**\r\n * Callback for return an error object.\r\n * @callback errorCallback\r\n * @param {Error} err - An Error Object or null\r\n */\n","var helper = require('./helper.js')\nvar {debug} = require('./debug.js')\nvar cpspawn = require('child_process').spawn\nvar pathlib = require('path')\nvar fs = require('fs')\nvar osTmpdir = require('os-tmpdir')\nvar crypto = require('crypto')\nvar which = require('which')\nvar settings = {}\nvar tempDir = process.env.PEMJS_TMPDIR || osTmpdir()\n\nconst versionRegEx = new RegExp('^(OpenSSL|LibreSSL) (((\\\\d+).(\\\\d+)).(\\\\d+))([a-z]+)?')\n\nif (\"CI\" in process.env && process.env.CI === 'true') {\n  if (\"LIBRARY\" in process.env && \"VERSION\" in process.env && process.env.LIBRARY != \"\" && process.env.VERSION != \"\") {\n    const filePathOpenSSL=`./openssl/${process.env.LIBRARY}_v${process.env.VERSION}/bin/openssl`\n    if (fs.existsSync(filePathOpenSSL)) {\n      process.env.OPENSSL_BIN = filePathOpenSSL\n    }\n  }\n}\n\n/**\n * pem openssl module\n *\n * @module openssl\n */\n\n/**\n * configue this openssl module\n *\n * @static\n * @param {String} option name e.g. pathOpenSSL, openSslVersion; TODO rethink nomenclature\n * @param {*} value value\n */\nfunction set(option, value) {\n  settings[option] = value\n}\n\n/**\n * get configuration setting value\n *\n * @static\n * @param {String} option name\n */\nfunction get(option) {\n  return settings[option] || null\n}\n\n/**\n * Spawn an openssl command\n *\n * @static\n * @param {Array} params Array of openssl command line parameters\n * @param {String} searchStr String to use to find data\n * @param {Array} [tmpfiles] list of temporary files\n * @param {Function} callback Called with (error, stdout-substring)\n */\nfunction exec(params, searchStr, tmpfiles, callback) {\n  if (!callback && typeof tmpfiles === 'function') {\n    callback = tmpfiles\n    tmpfiles = false\n  }\n\n  spawnWrapper(params, tmpfiles, function (err, code, stdout, stderr) {\n    var start, end\n\n    if (err) {\n      return callback(err)\n    }\n\n    if ((start = stdout.match(new RegExp('-+BEGIN ' + searchStr + '-+$', 'mu')))) {\n      start = start.index\n    } else {\n      start = -1\n    }\n\n    // To get the full EC key with parameters and private key\n    if (searchStr === 'EC PARAMETERS') {\n      searchStr = 'EC PRIVATE KEY'\n    }\n\n    if ((end = stdout.match(new RegExp('^\\\\-+END ' + searchStr + '\\\\-+', 'm')))) {\n      end = end.index + end[0].length\n    } else {\n      end = -1\n    }\n\n    if (start >= 0 && end >= 0) {\n      return callback(null, stdout.substring(start, end))\n    } else {\n      return callback(new Error(searchStr + ' not found from openssl output:\\n---stdout---\\n' + stdout + '\\n---stderr---\\n' + stderr + '\\ncode: ' + code))\n    }\n  })\n}\n\n/**\n *  Spawn an openssl command and get binary output\n *\n * @static\n * @param {Array} params Array of openssl command line parameters\n * @param {Array} [tmpfiles] list of temporary files\n * @param {Function} callback Called with (error, stdout)\n */\nfunction execBinary(params, tmpfiles, callback) {\n  if (!callback && typeof tmpfiles === 'function') {\n    callback = tmpfiles\n    tmpfiles = false\n  }\n  spawnWrapper(params, tmpfiles, true, function (err, code, stdout, stderr) {\n    debug(\"execBinary\", {err, code, stdout, stderr})\n    if (err) {\n      return callback(err)\n    }\n    return callback(null, stdout)\n  })\n}\n\n/**\n * Generically spawn openSSL, without processing the result\n *\n * @static\n * @param {Array}        params   The parameters to pass to openssl\n * @param {Boolean}      binary   Output of openssl is binary or text\n * @param {Function}     callback Called with (error, exitCode, stdout, stderr)\n */\nfunction spawn(params, binary, callback) {\n  var pathBin = get('pathOpenSSL') || process.env.OPENSSL_BIN || 'openssl'\n\n  testOpenSSLPath(pathBin, function (err) {\n    if (err) {\n      return callback(err)\n    }\n    var openssl = cpspawn(pathBin, params)\n    var stderr = ''\n\n    var stdout = (binary ? Buffer.alloc(0) : '')\n    openssl.stdout.on('data', function (data) {\n      if (!binary) {\n        stdout += data.toString('binary')\n      } else {\n        stdout = Buffer.concat([stdout, data])\n      }\n    })\n\n    openssl.stderr.on('data', function (data) {\n      stderr += data.toString('binary')\n    })\n    // We need both the return code and access to all of stdout.  Stdout isn't\n    // *really* available until the close event fires; the timing nuance was\n    // making this fail periodically.\n    var needed = 2 // wait for both exit and close.\n    var code = -1\n    var finished = false\n    var done = function (err) {\n      if (finished) {\n        return\n      }\n\n      if (err) {\n        finished = true\n        return callback(err)\n      }\n\n      if (--needed < 1) {\n        finished = true\n        if (code !== 0) {\n          if (code === 2 && (stderr === '' || /depth lookup: unable to/.test(stderr) || /depth lookup: self(-|\\s)signed certificate/.test(stderr))) {\n            return callback(null, code, stdout, stderr)\n          }\n          return callback(new Error('Invalid openssl exit code: ' + code + '\\n% openssl ' + params.join(' ') + '\\n' + stderr), code)\n        } else {\n          return callback(null, code, stdout, stderr)\n        }\n      }\n    }\n\n    openssl.on('error', done)\n\n    openssl.on('exit', function (ret) {\n      code = ret\n      done()\n    })\n\n    openssl.on('close', function () {\n      stdout = (binary ? stdout : Buffer.from(stdout, 'binary').toString('utf-8'))\n      stderr = Buffer.from(stderr, 'binary').toString('utf-8')\n      done()\n    })\n  })\n}\n\n/**\n * Wrapper for spawn method\n *\n * @static\n * @param {Array} params The parameters to pass to openssl\n * @param {Array} [tmpfiles] list of temporary files\n * @param {Boolean} [binary] Output of openssl is binary or text\n * @param {Function} callback Called with (error, exitCode, stdout, stderr)\n */\nfunction spawnWrapper(params, tmpfiles, binary, callback) {\n  if (!callback && typeof binary === 'function') {\n    callback = binary\n    binary = false\n  }\n\n  var files = []\n  var delTempPWFiles = []\n\n  if (tmpfiles) {\n    tmpfiles = [].concat(tmpfiles)\n    var fpath, i\n    for (i = 0; i < params.length; i++) {\n      if (params[i] === '--TMPFILE--') {\n        fpath = pathlib.join(tempDir, crypto.randomBytes(20).toString('hex'))\n        files.push({\n          path: fpath,\n          contents: tmpfiles.shift()\n        })\n        params[i] = fpath\n        delTempPWFiles.push(fpath)\n      }\n    }\n  }\n\n  var file\n  for (i = 0; i < files.length; i++) {\n    file = files[i]\n    fs.writeFileSync(file.path, file.contents)\n  }\n\n  spawn(params, binary, function (err, code, stdout, stderr) {\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      debug(params[0], {\n        err: err,\n        fsErr: fsErr,\n        code: code,\n        stdout: stdout,\n        stderr: stderr\n      })\n      callback(err || fsErr, code, stdout, stderr)\n    })\n  })\n}\n\n/**\n * Validates the pathBin for the openssl command\n *\n * @private\n * @param {String} pathBin The path to OpenSSL Bin\n * @param {Function} callback Callback function with an error object\n */\nfunction testOpenSSLPath(pathBin, callback) {\n  which(pathBin, function (error) {\n    if (error) {\n      return callback(new Error('Could not find openssl on your system on this path: ' + pathBin))\n    }\n    callback()\n  })\n}\n\n/* Once PEM is imported, the openSslVersion is set with this function. */\nspawn(['version'], false, function (err, code, stdout, stderr) {\n  var text = String(stdout) + '\\n' + String(stderr) + '\\n' + String(err)\n  let version = versionRegEx.exec(text)\n  if (version === null || version.length <= 7) return\n  set('openSslVersion', (version[1]).toUpperCase())\n  set('Vendor', (version[1]).toUpperCase())\n  set('VendorVersion', version[2])\n  set('VendorVersionMajorMinor', version[3])\n  set('VendorVersionMajor', version[4])\n  set('VendorVersionMinor', version[5])\n  set('VendorVersionPatch', version[6])\n  set('VendorVersionBuildChar', typeof version[7] === 'undefined' ? '' : version[7])\n})\n\nmodule.exports = {\n  exec: exec,\n  execBinary: execBinary,\n  spawn: spawn,\n  spawnWrapper: spawnWrapper,\n  settings: settings,\n  set: set,\n  get: get\n}\n","'use strict'\n\n/**\n * pem module\n *\n * @module pem\n */\nconst {debug} = require('./debug.js')\nconst {promisify} = require('es6-promisify')\nvar net = require('net')\nvar helper = require('./helper.js')\nvar openssl = require('./openssl.js')\nconst hash_md5 = require(\"md5\")\n\nmodule.exports.createPrivateKey = createPrivateKey\nmodule.exports.createDhparam = createDhparam\nmodule.exports.createEcparam = createEcparam\nmodule.exports.createCSR = createCSR\nmodule.exports.createCertificate = createCertificate\nmodule.exports.readCertificateInfo = readCertificateInfo\nmodule.exports.getPublicKey = getPublicKey\nmodule.exports.getFingerprint = getFingerprint\nmodule.exports.getModulus = getModulus\nmodule.exports.getDhparamInfo = getDhparamInfo\nmodule.exports.createPkcs12 = createPkcs12\nmodule.exports.readPkcs12 = readPkcs12\nmodule.exports.verifySigningChain = verifySigningChain\nmodule.exports.checkCertificate = checkCertificate\nmodule.exports.checkPkcs12 = checkPkcs12\nmodule.exports.config = config\n\n/**\n * quick access the convert module\n * @type {module:convert}\n */\nmodule.exports.convert = require('./convert.js')\n\nvar KEY_START = '-----BEGIN PRIVATE KEY-----'\nvar KEY_END = '-----END PRIVATE KEY-----'\nvar RSA_KEY_START = '-----BEGIN RSA PRIVATE KEY-----'\nvar RSA_KEY_END = '-----END RSA PRIVATE KEY-----'\nvar ENCRYPTED_KEY_START = '-----BEGIN ENCRYPTED PRIVATE KEY-----'\nvar ENCRYPTED_KEY_END = '-----END ENCRYPTED PRIVATE KEY-----'\nvar CERT_START = '-----BEGIN CERTIFICATE-----'\nvar CERT_END = '-----END CERTIFICATE-----'\n\n/**\n * Creates a private key\n *\n * @static\n * @param {Number} [keyBitsize=2048] Size of the key, defaults to 2048bit\n * @param {Object} [options] object of cipher and password {cipher:'aes128',password:'xxx'}, defaults empty object\n * @param {String} [options.cipher] string of the cipher for the encryption - needed with password\n * @param {String} [options.password] string of the cipher password for the encryption needed with cipher\n * @param {Function} callback Callback function with an error object and {key}\n */\nfunction createPrivateKey(keyBitsize, options, callback) {\n  if (!callback && !options && typeof keyBitsize === 'function') {\n    callback = keyBitsize\n    keyBitsize = undefined\n    options = {}\n  } else if (!callback && keyBitsize && typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  keyBitsize = Number(keyBitsize) || 2048\n\n  var params = ['genrsa']\n  var delTempPWFiles = []\n\n  if (options && options.cipher && (Number(helper.ciphers.indexOf(options.cipher)) !== -1) && options.password) {\n    debug('helper.createPasswordFile', {\n      cipher: options.cipher,\n      password: options.password,\n      passType: 'out'\n    })\n    helper.createPasswordFile({\n      cipher: options.cipher,\n      password: options.password,\n      passType: 'out'\n    }, params, delTempPWFiles)\n  }\n\n  params.push(keyBitsize)\n\n  debug('version', openssl.get('openSslVersion'))\n\n  openssl.exec(params, '(RSA |ENCRYPTED |)PRIVATE KEY', function (sslErr, key) {\n    function done(err) {\n      if (err) {\n        return callback(err)\n      }\n      return callback(null, {\n        key: key\n      })\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      debug('createPrivateKey', {\n        sslErr: sslErr,\n        fsErr: fsErr,\n        key: key,\n        keyLength: key && key.length\n      })\n      done(sslErr || fsErr)\n    })\n  })\n}\n\n/**\n * Creates a dhparam key\n *\n * @static\n * @param {Number} [keyBitsize=512] Size of the key, defaults to 512bit\n * @param {Function} callback Callback function with an error object and {dhparam}\n */\nfunction createDhparam(keyBitsize, callback) {\n  if (!callback && typeof keyBitsize === 'function') {\n    callback = keyBitsize\n    keyBitsize = undefined\n  }\n\n  keyBitsize = Number(keyBitsize) || 512\n\n  var params = ['dhparam',\n    '-outform',\n    'PEM',\n    keyBitsize\n  ]\n\n  openssl.exec(params, 'DH PARAMETERS', function (error, dhparam) {\n    if (error) {\n      return callback(error)\n    }\n    return callback(null, {\n      dhparam: dhparam\n    })\n  })\n}\n\n/**\n * Creates a ecparam key\n * @static\n * @param {String} [keyName=secp256k1] Name of the key, defaults to secp256k1\n * @param {String} [paramEnc=explicit] Encoding of the elliptic curve parameters, defaults to explicit\n * @param {Boolean} [noOut=false] This option inhibits the output of the encoded version of the parameters.\n * @param {Function} callback Callback function with an error object and {ecparam}\n */\nfunction createEcparam(keyName, paramEnc, noOut, callback) {\n  if (!callback && typeof noOut === 'undefined' && !paramEnc && typeof keyName === 'function') {\n    callback = keyName\n    keyName = undefined\n  } else if (!callback && typeof noOut === 'undefined' && keyName && typeof paramEnc === 'function') {\n    callback = paramEnc\n    paramEnc = undefined\n  } else if (!callback && typeof noOut === 'function' && keyName && paramEnc) {\n    callback = noOut\n    noOut = undefined\n  }\n\n  keyName = keyName || 'secp256k1'\n  paramEnc = paramEnc || 'explicit'\n  noOut = noOut || false\n\n  var params = ['ecparam',\n    '-name',\n    keyName,\n    '-genkey',\n    '-param_enc',\n    paramEnc\n  ]\n\n  var searchString = 'EC PARAMETERS'\n  if (noOut) {\n    params.push('-noout')\n    searchString = 'EC PRIVATE KEY'\n  }\n\n  openssl.exec(params, searchString, function (error, ecparam) {\n    if (error) {\n      return callback(error)\n    }\n    return callback(null, {\n      ecparam: ecparam\n    })\n  })\n}\n\n/**\n * Creates a Certificate Signing Request\n * If client key is undefined, a new key is created automatically. The used key is included\n * in the callback return as clientKey\n * @static\n * @param {Object} [options] Optional options object\n * @param {String} [options.clientKey] Optional client key to use\n * @param {Number} [options.keyBitsize] If clientKey is undefined, bit size to use for generating a new key (defaults to 2048)\n * @param {String} [options.hash] Hash function to use (either md5 sha1 or sha256, defaults to sha256)\n * @param {String} [options.country] CSR country field\n * @param {String} [options.state] CSR state field\n * @param {String} [options.locality] CSR locality field\n * @param {String} [options.organization] CSR organization field\n * @param {String} [options.organizationUnit] CSR organizational unit field\n * @param {String} [options.commonName='localhost'] CSR common name field\n * @param {String} [options.emailAddress] CSR email address field\n * @param {String} [options.csrConfigFile] CSR config file\n * @param {Array}  [options.altNames] is a list of subjectAltNames in the subjectAltName field\n * @param {Function} callback Callback function with an error object and {csr, clientKey}\n */\nfunction createCSR(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options\n    options = undefined\n  }\n\n  let delTempPWFiles = []\n\n  options = options || {}\n\n  // http://stackoverflow.com/questions/14089872/why-does-node-js-accept-ip-addresses-in-certificates-only-for-san-not-for-cn\n  if (options.commonName && (net.isIPv4(options.commonName) || net.isIPv6(options.commonName))) {\n    if (!options.altNames) {\n      options.altNames = [options.commonName]\n    } else if (options.altNames.indexOf(options.commonName) === -1) {\n      options.altNames = options.altNames.concat([options.commonName])\n    }\n  }\n\n  if (!options.clientKey) {\n    if (options && (options.password || options.clientKeyPassword)) {\n      options.password = options.password || options.clientKeyPassword || ''\n    }\n    createPrivateKey(options.keyBitsize || 2048, options, function (error, keyData) {\n      if (error) {\n        return callback(error)\n      }\n      options.clientKey = keyData.key\n\n      createCSR(options, callback)\n    })\n    return\n  }\n\n  var params = ['req',\n    '-new',\n    '-' + (options.hash || 'sha256')\n  ]\n\n  if (options.csrConfigFile) {\n    params.push('-config')\n    params.push(options.csrConfigFile)\n  } else {\n    params.push('-subj')\n    params.push(generateCSRSubject(options))\n  }\n\n  params.push('-key')\n  params.push('--TMPFILE--')\n\n  var tmpfiles = [options.clientKey]\n  var config = null\n\n  if (options && (options.password || options.clientKeyPassword)) {\n    helper.createPasswordFile({\n      cipher: '',\n      password: options.password || options.clientKeyPassword,\n      passType: 'in'\n    }, params, delTempPWFiles)\n  }\n\n  if (options.altNames && Array.isArray(options.altNames) && options.altNames.length) {\n    params.push('-extensions')\n    params.push('v3_req')\n    params.push('-config')\n    params.push('--TMPFILE--')\n    var altNamesRep = []\n    for (var i = 0; i < options.altNames.length; i++) {\n      altNamesRep.push((net.isIP(options.altNames[i]) ? 'IP' : 'DNS') + '.' + (i + 1) + ' = ' + options.altNames[i])\n    }\n\n    tmpfiles.push(config = [\n      '[req]',\n      'req_extensions = v3_req',\n      'distinguished_name = req_distinguished_name',\n      '[v3_req]',\n      'subjectAltName = @alt_names',\n      '[alt_names]',\n      altNamesRep.join('\\n'),\n      '[req_distinguished_name]',\n      'commonName = Common Name',\n      'commonName_max = 64'\n    ].join('\\n'))\n  } else if (options.config) {\n    config = options.config\n  }\n\n\n  if (options.clientKeyPassword) {\n    helper.createPasswordFile({\n      cipher: '',\n      password: options.clientKeyPassword,\n      passType: 'in'\n    }, params, delTempPWFiles)\n  }\n\n  openssl.exec(params, 'CERTIFICATE REQUEST', tmpfiles, function (sslErr, data) {\n    function done(err) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, {\n        csr: data,\n        config: config,\n        clientKey: options.clientKey\n      })\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(sslErr || fsErr)\n    })\n  })\n}\n\n/**\n * Creates a certificate based on a CSR. If CSR is not defined, a new one\n * will be generated automatically. For CSR generation all the options values\n * can be used as with createCSR.\n * @static\n * @param {Object} [options] Optional options object\n * @param {String} [options.serviceCertificate] PEM encoded certificate\n * @param {String} [options.serviceKey] Private key for signing the certificate, if not defined a new one is generated\n * @param {String} [options.serviceKeyPassword] Password of the service key\n * @param {Boolean} [options.selfSigned] If set to true and serviceKey is not defined, use clientKey for signing\n * @param {String|Number} [options.serial] Set a serial max. 20 octets - only together with options.serviceCertificate\n * @param {String} [options.serialFile] Set the name of the serial file, without extension. - only together with options.serviceCertificate and never in tandem with options.serial\n * @param {String} [options.hash] Hash function to use (either md5 sha1 or sha256, defaults to sha256)\n * @param {String} [options.csr] CSR for the certificate, if not defined a new one is generated\n * @param {Number} [options.days] Certificate expire time in days\n * @param {String} [options.clientKeyPassword] Password of the client key\n * @param {String} [options.extFile] extension config file - without '-extensions v3_req'\n * @param {String} [options.config] extension config file - with '-extensions v3_req'\n * @param {String} [options.csrConfigFile] CSR config file - only used if no options.csr is provided\n * @param {Array}  [options.altNames] is a list of subjectAltNames in the subjectAltName field - only used if no options.csr is provided\n * @param {Function} callback Callback function with an error object and {certificate, csr, clientKey, serviceKey}\n */\nfunction createCertificate(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options\n    options = undefined\n  }\n\n  options = options || {}\n\n  if (!options.csr) {\n    createCSR(options, function (error, keyData) {\n      if (error) {\n        return callback(error)\n      }\n      options.csr = keyData.csr\n      options.config = keyData.config\n      options.clientKey = keyData.clientKey\n      createCertificate(options, callback)\n    })\n    return\n  }\n\n  if (!options.clientKey) {\n    options.clientKey = ''\n  }\n\n  if (!options.serviceKey) {\n    if (options.selfSigned) {\n      options.serviceKey = options.clientKey\n    } else {\n      createPrivateKey(options.keyBitsize || 2048, {\n        cipher: options.cipher,\n        password: options.clientKeyPassword || ''\n      }, function (error, keyData) {\n        if (error) {\n          return callback(error)\n        }\n        options.serviceKey = keyData.key\n        createCertificate(options, callback)\n      })\n      return\n    }\n  }\n\n  readCertificateInfo(options.csr, function (error2, data2) {\n    if (error2) {\n      return callback(error2)\n    }\n\n    var params = ['x509',\n      '-req',\n      '-' + (options.hash || 'sha256'),\n      '-days',\n      Number(options.days) || '365',\n      '-in',\n      '--TMPFILE--'\n    ]\n    var tmpfiles = [options.csr]\n    var delTempPWFiles = []\n\n    if (options.serviceCertificate) {\n      params.push('-CA')\n      params.push('--TMPFILE--')\n      params.push('-CAkey')\n      params.push('--TMPFILE--')\n      if (options.serial) {\n        params.push('-set_serial')\n        if (helper.isNumber(options.serial)) {\n          // set the serial to the max lenth of 20 octets ()\n          // A certificate serial number is not decimal conforming. That is the\n          // bytes in a serial number do not necessarily map to a printable ASCII\n          // character.\n          // eg: 0x00 is a valid serial number and can not be represented in a\n          // human readable format (atleast one that can be directly mapped to\n          // the ACSII table).\n          params.push('0x' + ('0000000000000000000000000000000000000000' + options.serial.toString(16)).slice(-40))\n        } else {\n          if (helper.isHex(options.serial)) {\n            if (options.serial.startsWith('0x')) {\n              options.serial = options.serial.substring(2, options.serial.length)\n            }\n            params.push('0x' + ('0000000000000000000000000000000000000000' + options.serial).slice(-40))\n          } else {\n            params.push('0x' + ('0000000000000000000000000000000000000000' + helper.toHex(options.serial)).slice(-40))\n          }\n        }\n      } else {\n        params.push('-CAcreateserial')\n        if (options.serialFile) {\n          params.push('-CAserial')\n          params.push(options.serialFile + '.srl')\n        }\n      }\n      if (options.serviceKeyPassword) {\n        helper.createPasswordFile({\n          cipher: '',\n          password: options.serviceKeyPassword,\n          passType: 'in'\n        }, params, delTempPWFiles)\n      }\n      tmpfiles.push(options.serviceCertificate)\n      tmpfiles.push(options.serviceKey)\n    } else {\n      params.push('-signkey')\n      params.push('--TMPFILE--')\n      if (options.serviceKeyPassword) {\n        helper.createPasswordFile({\n          cipher: '',\n          password: options.serviceKeyPassword,\n          passType: 'in'\n        }, params, delTempPWFiles)\n      }\n      tmpfiles.push(options.serviceKey)\n    }\n\n    if (options.config) {\n      params.push('-extensions')\n      params.push('v3_req')\n      params.push('-extfile')\n      params.push('--TMPFILE--')\n      tmpfiles.push(options.config)\n    } else if (options.extFile) {\n      params.push('-extfile')\n      params.push(options.extFile)\n    } else {\n      var altNamesRep = []\n      if (data2 && data2.san) {\n        for (var i = 0; i < data2.san.dns.length; i++) {\n          altNamesRep.push('DNS' + '.' + (i + 1) + ' = ' + data2.san.dns[i])\n        }\n        for (var i2 = 0; i2 < data2.san.ip.length; i2++) {\n          altNamesRep.push('IP' + '.' + (i2 + 1) + ' = ' + data2.san.ip[i2])\n        }\n        for (var i3 = 0; i3 < data2.san.email.length; i3++) {\n          altNamesRep.push('email' + '.' + (i3 + 1) + ' = ' + data2.san.email[i3])\n        }\n        params.push('-extensions')\n        params.push('v3_req')\n        params.push('-extfile')\n        params.push('--TMPFILE--')\n        tmpfiles.push([\n          '[v3_req]',\n          'subjectAltName = @alt_names',\n          '[alt_names]',\n          altNamesRep.join('\\n')\n        ].join('\\n'))\n      }\n    }\n\n    if (options.clientKeyPassword) {\n      helper.createPasswordFile({\n        cipher: '',\n        password: options.clientKeyPassword,\n        passType: 'in'\n      }, params, delTempPWFiles)\n    }\n\n    openssl.exec(params, 'CERTIFICATE', tmpfiles, function (sslErr, data) {\n      function done(err) {\n        if (err) {\n          return callback(err)\n        }\n        var response = {\n          csr: options.csr,\n          clientKey: options.clientKey,\n          certificate: data,\n          serviceKey: options.serviceKey\n        }\n        return callback(null, response)\n      }\n\n      helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n        done(sslErr || fsErr)\n      })\n    })\n  })\n}\n\n/**\n * Exports a public key from a private key, CSR or certificate\n * @static\n * @param {String} certificate PEM encoded private key, CSR or certificate\n * @param {Function} callback Callback function with an error object and {publicKey}\n */\nfunction getPublicKey(certificate, callback) {\n  if (!callback && typeof certificate === 'function') {\n    callback = certificate\n    certificate = undefined\n  }\n\n  certificate = (certificate || '').toString()\n\n  var params\n\n  if (certificate.match(/BEGIN(\\sNEW)? CERTIFICATE REQUEST/)) {\n    params = ['req',\n      '-in',\n      '--TMPFILE--',\n      '-pubkey',\n      '-noout'\n    ]\n  } else if (certificate.match(/BEGIN RSA PRIVATE KEY/) || certificate.match(/BEGIN PRIVATE KEY/)) {\n    params = ['rsa',\n      '-in',\n      '--TMPFILE--',\n      '-pubout'\n    ]\n  } else {\n    params = ['x509',\n      '-in',\n      '--TMPFILE--',\n      '-pubkey',\n      '-noout'\n    ]\n  }\n\n  openssl.exec(params, 'PUBLIC KEY', certificate, function (error, key) {\n    if (error) {\n      return callback(error)\n    }\n    return callback(null, {\n      publicKey: key\n    })\n  })\n}\n\n/**\n * Reads subject data from a certificate or a CSR\n * @static\n * @param {String} certificate PEM encoded CSR or certificate\n * @param {Function} callback Callback function with an error object and {country, state, locality, organization, organizationUnit, commonName, emailAddress}\n */\nfunction readCertificateInfo(certificate, callback) {\n  if (!callback && typeof certificate === 'function') {\n    callback = certificate\n    certificate = undefined\n  }\n\n  certificate = (certificate || '').toString()\n  var isMatch = certificate.match(/BEGIN(\\sNEW)? CERTIFICATE REQUEST/)\n  var type = isMatch ? 'req' : 'x509'\n  var params = [type,\n    '-noout',\n    '-nameopt',\n    'RFC2253,sep_multiline,space_eq,-esc_msb,utf8',\n    '-text',\n    '-in',\n    '--TMPFILE--'\n  ]\n  openssl.spawnWrapper(params, certificate, function (err, code, stdout, stderr) {\n    if (err) {\n      return callback(err)\n    } else if (stderr) {\n      return callback(stderr)\n    }\n    return fetchCertificateData(stdout, callback)\n  })\n}\n\n/**\n * get the modulus from a certificate, a CSR or a private key\n * @static\n * @param {String} certificate PEM encoded, CSR PEM encoded, or private key\n * @param {String} [password] password for the certificate\n * @param {String} [hash] hash function to use (up to now `md5` supported) (default: none)\n * @param {Function} callback Callback function with an error object and {modulus}\n */\nfunction getModulus(certificate, password, hash, callback) {\n  if (!callback && !hash && typeof password === 'function') {\n    callback = password\n    password = undefined\n    hash = false\n  } else if (!callback && hash && typeof hash === 'function') {\n    callback = hash\n    hash = false\n    // password will be falsy if not provided\n  }\n  // adding hash function to params, is not supported by openssl.\n  // process piping would be the right way (... | openssl md5)\n  // No idea how this can be achieved in easy with the current build in methods\n  // of pem.\n  if (hash && hash !== 'md5') {\n    hash = false\n  }\n\n  certificate = (Buffer.isBuffer(certificate) && certificate.toString()) || certificate\n\n  let type\n  if (certificate.match(/BEGIN(\\sNEW)? CERTIFICATE REQUEST/)) {\n    type = 'req'\n  } else if (certificate.match(/BEGIN RSA PRIVATE KEY/) || certificate.match(/BEGIN PRIVATE KEY/)) {\n    type = 'rsa'\n  } else {\n    type = 'x509'\n  }\n  let params = [\n    type,\n    '-noout',\n    '-modulus',\n    '-in',\n    '--TMPFILE--'\n  ]\n  let delTempPWFiles = []\n  if (password) {\n    helper.createPasswordFile({cipher: '', password: password, passType: 'in'}, params, delTempPWFiles)\n  }\n\n  openssl.spawnWrapper(params, certificate, function (sslErr, code, stdout, stderr) {\n    function done(err) {\n      if (err) {\n        return callback(err)\n      }\n      var match = stdout.match(/Modulus=([0-9a-fA-F]+)$/m)\n      if (match) {\n        if (hash === 'md5') {\n          return callback(null, {\n            modulus: hash_md5(match[1])\n          })\n        }\n\n        return callback(null, {\n          modulus: match[1]\n        })\n\n      } else {\n        return callback(new Error('No modulus'))\n      }\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(sslErr || fsErr || stderr)\n    })\n  })\n}\n\n/**\n * get the size and prime of DH parameters\n * @static\n * @param {String} dh parameters PEM encoded\n * @param {Function} callback Callback function with an error object and {size, prime}\n */\nfunction getDhparamInfo(dh, callback) {\n  dh = (Buffer.isBuffer(dh) && dh.toString()) || dh\n\n  var params = [\n    'dhparam',\n    '-text',\n    '-in',\n    '--TMPFILE--'\n  ]\n\n  openssl.spawnWrapper(params, dh, function (err, code, stdout, stderr) {\n    if (err) {\n      return callback(err)\n    } else if (stderr) {\n      return callback(stderr)\n    }\n\n    var result = {}\n    var match = stdout.match(/Parameters: \\((\\d+) bit\\)/)\n\n    if (match) {\n      result.size = Number(match[1])\n    }\n\n    var prime = ''\n    stdout.split('\\n').forEach(function (line) {\n      if (/\\s+([0-9a-f][0-9a-f]:)+[0-9a-f]?[0-9a-f]?/g.test(line)) {\n        prime += line.trim()\n      }\n    })\n\n    if (prime) {\n      result.prime = prime\n    }\n\n    if (!match && !prime) {\n      return callback(new Error('No DH info found'))\n    }\n\n    return callback(null, result)\n  })\n}\n\n/**\n * config the pem module\n * @static\n * @param {Object} options\n */\nfunction config(options) {\n  Object.keys(options).forEach(function (k) {\n    openssl.set(k, options[k])\n  })\n}\n\n/**\n * Gets the fingerprint for a certificate\n * @static\n * @param {String} certificate PEM encoded certificate\n * @param {String} [hash] hash function to use (either `md5`, `sha1` or `sha256`, defaults to `sha1`)\n * @param {Function} callback Callback function with an error object and {fingerprint}\n */\nfunction getFingerprint(certificate, hash, callback) {\n  if (!callback && typeof hash === 'function') {\n    callback = hash\n    hash = undefined\n  }\n\n  hash = hash || 'sha1'\n\n  var params = ['x509',\n    '-in',\n    '--TMPFILE--',\n    '-fingerprint',\n    '-noout',\n    '-' + hash\n  ]\n\n  openssl.spawnWrapper(params, certificate, function (err, code, stdout, stderr) {\n    if (err) {\n      return callback(err)\n    } else if (stderr) {\n      return callback(stderr)\n    }\n    var match = stdout.match(/Fingerprint=([0-9a-fA-F:]+)$/m)\n    if (match) {\n      return callback(null, {\n        fingerprint: match[1]\n      })\n    } else {\n      return callback(new Error('No fingerprint'))\n    }\n  })\n}\n\n/**\n * Export private key and certificate to a PKCS12 keystore\n * @static\n * @param {String} key PEM encoded private key\n * @param {String} certificate PEM encoded certificate\n * @param {String} password Password of the result PKCS12 file\n * @param {Object} [options] object of cipher and optional client key password {cipher:'aes128', clientKeyPassword: 'xxxx', certFiles: ['file1','file2']}\n * @param {Function} callback Callback function with an error object and {pkcs12}\n */\nfunction createPkcs12(key, certificate, password, options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  var params = ['pkcs12', '-export']\n  var delTempPWFiles = []\n\n  if (options.cipher && options.clientKeyPassword) {\n    // NOTICE: The password field is needed! self if it is empty.\n    // create password file for the import \"-passin\"\n    helper.createPasswordFile({\n      cipher: options.cipher,\n      password: options.clientKeyPassword,\n      passType: 'in'\n    }, params, delTempPWFiles)\n  }\n  // NOTICE: The password field is needed! self if it is empty.\n  // create password file for the password \"-password\"\n  helper.createPasswordFile({cipher: '', password: password, passType: 'word'}, params, delTempPWFiles)\n\n  params.push('-in')\n  params.push('--TMPFILE--')\n  params.push('-inkey')\n  params.push('--TMPFILE--')\n\n  var tmpfiles = [certificate, key]\n\n  if (options.certFiles) {\n    tmpfiles.push(options.certFiles.join(''))\n\n    params.push('-certfile')\n    params.push('--TMPFILE--')\n  }\n\n  openssl.execBinary(params, tmpfiles, function (sslErr, pkcs12) {\n    function done(err) {\n      if (err) {\n        return callback(err)\n      }\n      return callback(null, {\n        pkcs12: pkcs12\n      })\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(sslErr || fsErr)\n    })\n  })\n}\n\n/**\n * read sslcert data from Pkcs12 file. Results are provided in callback response in object notation ({cert: .., ca:..., key:...})\n * @static\n * @param  {Buffer|String}   bufferOrPath Buffer or path to file\n * @param  {Object}   [options]      openssl options\n * @param  {Function} callback     Called with error object and sslcert bundle object\n */\nfunction readPkcs12(bufferOrPath, options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  options.p12Password = options.p12Password || ''\n\n  var tmpfiles = []\n  var delTempPWFiles = []\n  var args = ['pkcs12', '-in', bufferOrPath]\n\n  helper.createPasswordFile({cipher: '', password: options.p12Password, passType: 'in'}, args, delTempPWFiles)\n\n  if (Buffer.isBuffer(bufferOrPath)) {\n    tmpfiles = [bufferOrPath]\n    args[2] = '--TMPFILE--'\n  }\n\n  if (openssl.get('Vendor') === \"OPENSSL\" && openssl.get('VendorVersionMajor') >= 3) {\n    args.push('-legacy')\n    args.push('-traditional')\n  }\n\n  if (options.clientKeyPassword) {\n    helper.createPasswordFile({\n      cipher: '',\n      password: options.clientKeyPassword,\n      passType: 'out'\n    }, args, delTempPWFiles)\n  } else {\n    args.push('-nodes')\n  }\n\n  openssl.execBinary(args, tmpfiles, function (sslErr, stdout) {\n    function done(err) {\n      var keybundle = {}\n\n      if (err && err.message.indexOf('No such file or directory') !== -1) {\n        err.code = 'ENOENT'\n      }\n\n      if (!err) {\n        var certs = readFromString(stdout, CERT_START, CERT_END)\n        keybundle.cert = certs.shift()\n        keybundle.ca = certs\n        keybundle.key = readFromString(stdout, KEY_START, KEY_END).pop()\n\n        debug(\"readPkcs12.execBinary - PRIVATE KEY - ?: \", keybundle.key)\n        if (keybundle.key) {\n          // convert to RSA key\n          return openssl.exec(['rsa', '-in', '--TMPFILE--'], '(RSA |)PRIVATE KEY', [keybundle.key], function (err, key) {\n            if (err) {\n              debug(\"readPkcs12.execBinary - PRIVATE KEY convert - error: \", err)\n            }\n            //debug(\"readPkcs12.execBinary - PRIVATE KEY\", key)\n            keybundle.key = key\n\n            return callback(err, keybundle)\n          })\n        }\n\n        if (options.clientKeyPassword) {\n          keybundle.key = readFromString(stdout, ENCRYPTED_KEY_START, ENCRYPTED_KEY_END).pop()\n          debug(\"readPkcs12.execBinary - ENCRYPTED PRIVATE KEY - ?: \", keybundle.key)\n          /*return openssl.exec(['rsa', '-in', '--TMPFILE--'], 'RSA PRIVATE KEY', [keybundle.key], function (err, key) {\n            if (err) {\n              debug(\"readPkcs12.execBinary - ENCRYPTED PRIVATE KEY - error: \", err)\n            }\n            debug(\"readPkcs12.execBinary - ENCRYPTED PRIVATE KEY\", key)\n            keybundle.key = key\n\n            return callback(err, keybundle)\n          })*/\n        } else {\n          keybundle.key = readFromString(stdout, RSA_KEY_START, RSA_KEY_END).pop()\n          debug(\"readPkcs12.execBinary - RSA PRIVATE KEY - ?: \", keybundle.key)\n          /*return openssl.exec(['rsa', '-in', '--TMPFILE--'], 'RSA PRIVATE KEY', [keybundle.key], function (err, key) {\n            if (err) {\n              debug(\"readPkcs12.execBinary - RSA PRIVATE KEY - error: \", err)\n            }\n            debug(\"readPkcs12.execBinary - RSA PRIVATE KEY\", key)\n            keybundle.key = key\n\n            return callback(err, keybundle)\n          })*/\n        }\n      }\n\n      return callback(err, keybundle)\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(sslErr || fsErr)\n    })\n  })\n}\n\n/**\n * Check a certificate\n * @static\n * @param {String} certificate PEM encoded certificate\n * @param {String} [passphrase] password for the certificate\n * @param {Function} callback Callback function with an error object and a boolean valid\n */\nfunction checkCertificate(certificate, passphrase, callback) {\n  var params\n  var delTempPWFiles = []\n\n  if (!callback && typeof passphrase === 'function') {\n    callback = passphrase\n    passphrase = undefined\n  }\n  certificate = (certificate || '').toString()\n\n  if (certificate.match(/BEGIN(\\sNEW)? CERTIFICATE REQUEST/)) {\n    params = ['req', '-text', '-noout', '-verify', '-in', '--TMPFILE--']\n  } else if (certificate.match(/BEGIN RSA PRIVATE KEY/) || certificate.match(/BEGIN PRIVATE KEY/)) {\n    params = ['rsa', '-noout', '-check', '-in', '--TMPFILE--']\n  } else {\n    params = ['x509', '-text', '-noout', '-in', '--TMPFILE--']\n  }\n  if (passphrase) {\n    helper.createPasswordFile({cipher: '', password: passphrase, passType: 'in'}, params, delTempPWFiles)\n  }\n\n  openssl.spawnWrapper(params, certificate, function (sslErr, code, stdout, stderr) {\n    function done(err) {\n\n      stdout = stdout && stdout.trim()\n      var result\n      switch (params[0]) {\n        case 'rsa':\n          result = /^Rsa key ok$/i.test(stdout)\n          break\n        default:\n          result = /Signature Algorithm/im.test(stdout)\n          break\n      }\n      if (!result) {\n        if (openssl.get('Vendor') === \"OPENSSL\" && openssl.get('VendorVersionMajor') >= 3) {\n          if (!(stderr && stderr.toString().trim().endsWith('verify OK'))) {\n            return callback(new Error(stderr.toString()))\n          }\n        }\n        if (err && err.toString().trim() !== 'verify OK') {\n          return callback(err)\n        }\n      }\n      callback(null, result)\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      done(sslErr || fsErr || stderr)\n    })\n  })\n}\n\n/**\n * check a PKCS#12 file (.pfx or.p12)\n * @static\n * @param {Buffer|String} bufferOrPath PKCS#12 certificate\n * @param {String} [passphrase] optional passphrase which will be used to open the keystore\n * @param {Function} callback Callback function with an error object and a boolean valid\n */\nfunction checkPkcs12(bufferOrPath, passphrase, callback) {\n  if (!callback && typeof passphrase === 'function') {\n    callback = passphrase\n    passphrase = ''\n  }\n\n  var tmpfiles = []\n  var delTempPWFiles = []\n  var args = ['pkcs12', '-info', '-in', bufferOrPath, '-noout', '-maciter', '-nodes']\n\n  helper.createPasswordFile({cipher: '', password: passphrase, passType: 'in'}, args, delTempPWFiles)\n\n  if (Buffer.isBuffer(bufferOrPath)) {\n    tmpfiles = [bufferOrPath]\n    args[3] = '--TMPFILE--'\n  }\n\n  if (openssl.get('Vendor') === \"OPENSSL\" && openssl.get('VendorVersionMajor') >= 3) {\n    args.splice(2, 0, '-legacy');\n  }\n\n  openssl.spawnWrapper(args, tmpfiles, function (sslErr, code, stdout, stderr) {\n    debug('checkPkcs12 error', {\n      err: sslErr,\n      code: code,\n      stdout: stdout,\n      stdoutResult: (/MAC verified OK/im.test(stderr) || (!(/MAC verified OK/im.test(stderr)) && !(/Mac verify error/im.test(stderr)))),\n      stderr: stderr\n    })\n\n    function done(err) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, (/MAC verified OK/im.test(stderr) || (!(/MAC verified OK/im.test(stderr)) && !(/Mac verify error/im.test(stderr)))))\n    }\n\n    helper.deleteTempFiles(delTempPWFiles, function (fsErr) {\n      debug('checkPkcs12 clean-up error', {\n        sslErr: sslErr,\n        fsErr: fsErr,\n        code: code,\n        stdout: stdout,\n        stdoutResult: (/MAC verified OK/im.test(stderr) || (!(/MAC verified OK/im.test(stderr)) && !(/Mac verify error/im.test(stderr)))),\n        stderr: stderr\n      })\n      done(sslErr || fsErr)\n    })\n  })\n}\n\n/**\n * Verifies the signing chain of the passed certificate\n * @static\n * @param {String|Array} certificate PEM encoded certificate include intermediate certificates\n * The correct order of trust chain must be preserved and should start with Leaf\n * certificate. Example array: [Leaf, Int CA 1, ... , Int CA N, Root CA].\n * @param {String|Array} ca [List] of CA certificates\n * @param {Function} callback Callback function with an error object and a boolean valid\n */\nfunction verifySigningChain(certificate, ca, callback) {\n  if (!callback && typeof ca === 'function') {\n    callback = ca\n    ca = undefined\n  }\n  if (!Array.isArray(certificate)) {\n    certificate = readFromString(certificate, CERT_START, CERT_END)\n  }\n  if (!Array.isArray(ca) && ca !== undefined) {\n    if (ca !== '') {\n      ca = [ca]\n    }\n  }\n\n  var params = ['verify']\n  var files = []\n\n  if (ca !== undefined) {\n    // ca certificates\n    params.push('-CAfile')\n    params.push('--TMPFILE--')\n    files.push(ca.join('\\n'))\n  }\n  // extracting the very first - leaf - cert in chain\n  var leaf = certificate.shift()\n\n  if (certificate.length > 0) {\n    params.push('-untrusted')\n    params.push('--TMPFILE--')\n    files.push(certificate.join('\\n'))\n  }\n\n  params.push('--TMPFILE--')\n  files.push(leaf)\n\n  openssl.spawnWrapper(params, files, function (err, code, stdout, stderr) {\n    // OPENSSL 3.x don't use stdout to print the error\n    debug('Vendor', openssl.get('Vendor'))\n    debug('VendorVersionMajor', openssl.get('VendorVersionMajor'))\n    debug('openssl.get(\\'VendorVersionMajor\\') >= 3', openssl.get('VendorVersionMajor') >= 3)\n\n    if (openssl.get('Vendor') === \"OPENSSL\" && openssl.get('VendorVersionMajor') >= 3) {\n      let openssl30Check = !!(stdout && stdout.trim().includes(\": OK\"));\n\n      if (err) {\n        debug('verifySigningChain error', {\n          err: err,\n          code: code,\n          stdout: stdout,\n          stdoutResult: openssl30Check,\n          stderr: stderr\n        })\n        return callback(err)\n      }\n\n      debug('verifySigningChain error - use stderr', {\n        err: err,\n        code: code,\n        stdout: stdout.trim(),\n        stdoutResult: openssl30Check,\n        stderr: stderr.trim()\n      })\n      return callback(null, openssl30Check)\n    }\n    // END: OPENSSL 3.x don't use stdout to print the error\n    if (err) {\n      debug('verifySigningChain error', {\n        err: err,\n        code: code,\n        stdout: stdout,\n        stdoutResult: stdout && stdout.trim().slice(-4) === ': OK',\n        stderr: stderr\n      })\n      return callback(err)\n    }\n    debug('verifySigningChain', {\n      err: err,\n      code: code,\n      stdout: stdout,\n      stdoutResult: stdout && stdout.trim().slice(-4) === ': OK',\n      stderr: stderr\n    })\n    callback(null, stdout && stdout.trim().slice(-4) === ': OK')\n  })\n}\n\n// HELPER FUNCTIONS\nfunction fetchCertificateData(certData, callback) {\n  // try catch : if something will fail in parsing it won't crash the calling code\n  try {\n    certData = (certData || '').toString()\n\n    var serial, subject, tmp, issuer\n    var certValues = {\n      issuer: {}\n    }\n    var validity = {}\n    var san\n\n    var ky, i\n\n    // serial\n    if ((serial = certData.match(/\\s*Serial Number:\\r?\\n?\\s*([^\\r\\n]*)\\r?\\n\\s*\\b/)) && serial.length > 1) {\n      certValues.serial = serial[1]\n    }\n\n    if ((subject = certData.match(/\\s*Subject:\\r?\\n(\\s*(([a-zA-Z0-9.]+)\\s=\\s[^\\r\\n]+\\r?\\n))*\\s*\\b/)) && subject.length > 1) {\n      subject = subject[0]\n      tmp = matchAll(subject, /\\s([a-zA-Z0-9.]+)\\s=\\s([^\\r\\n].*)/g)\n      if (tmp) {\n        for (i = 0; i < tmp.length; i++) {\n          ky = tmp[i][1].trim()\n          if (ky.match('(C|ST|L|O|OU|CN|emailAddress|DC)') || ky === '') {\n            continue\n          }\n          certValues[ky] = tmp[i][2].trim()\n        }\n      }\n\n      // country\n      tmp = subject.match(/\\sC\\s=\\s([^\\r\\n].*?)[\\r\\n]/)\n      certValues.country = (tmp && tmp[1]) || ''\n\n      // state\n      tmp = subject.match(/\\sST\\s=\\s([^\\r\\n].*?)[\\r\\n]/)\n      certValues.state = (tmp && tmp[1]) || ''\n\n      // locality\n      tmp = subject.match(/\\sL\\s=\\s([^\\r\\n].*?)[\\r\\n]/)\n      certValues.locality = (tmp && tmp[1]) || ''\n\n      // organization\n      tmp = matchAll(subject, /\\sO\\s=\\s([^\\r\\n].*)/g)\n      certValues.organization = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // unit\n      tmp = matchAll(subject, /\\sOU\\s=\\s([^\\r\\n].*)/g)\n      certValues.organizationUnit = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // common name\n      tmp = matchAll(subject, /\\sCN\\s=\\s([^\\r\\n].*)/g)\n      certValues.commonName = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // email\n      tmp = matchAll(subject, /emailAddress\\s=\\s([^\\r\\n].*)/g)\n      certValues.emailAddress = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // DC name\n      tmp = matchAll(subject, /\\sDC\\s=\\s([^\\r\\n].*)/g)\n      certValues.dc = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n    }\n\n    if ((issuer = certData.match(/\\s*Issuer:\\r?\\n(\\s*([a-zA-Z0-9.]+)\\s=\\s[^\\r\\n].*\\r?\\n)*\\s*\\b/)) && issuer.length > 1) {\n      issuer = issuer[0]\n      tmp = matchAll(issuer, /\\s([a-zA-Z0-9.]+)\\s=\\s([^\\r\\n].*)/g)\n      for (i = 0; i < tmp.length; i++) {\n        ky = tmp[i][1].toString()\n        if (ky.match('(C|ST|L|O|OU|CN|emailAddress|DC)')) {\n          continue\n        }\n        certValues.issuer[ky] = tmp[i][2].toString()\n      }\n\n      // country\n      tmp = issuer.match(/\\sC\\s=\\s([^\\r\\n].*?)[\\r\\n]/)\n      certValues.issuer.country = (tmp && tmp[1]) || ''\n\n      // state\n      tmp = issuer.match(/\\sST\\s=\\s([^\\r\\n].*?)[\\r\\n]/)\n      certValues.issuer.state = (tmp && tmp[1]) || ''\n\n      // locality\n      tmp = issuer.match(/\\sL\\s=\\s([^\\r\\n].*?)[\\r\\n]/)\n      certValues.issuer.locality = (tmp && tmp[1]) || ''\n\n      // organization\n      tmp = matchAll(issuer, /\\sO\\s=\\s([^\\r\\n].*)/g)\n      certValues.issuer.organization = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // unit\n      tmp = matchAll(issuer, /\\sOU\\s=\\s([^\\r\\n].*)/g)\n      certValues.issuer.organizationUnit = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var\n          r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // common name\n      tmp = matchAll(issuer, /\\sCN\\s=\\s([^\\r\\n].*)/g)\n      certValues.issuer.commonName = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var\n          r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n\n      // DC name\n      tmp = matchAll(issuer, /\\sDC\\s=\\s([^\\r\\n].*)/g)\n      certValues.issuer.dc = tmp ? (tmp.length > 1 ? tmp.sort(function (t, n) {\n        var e = t[1].toUpperCase()\n        var\n          r = n[1].toUpperCase()\n        return r > e ? -1 : e > r ? 1 : 0\n      }).sort(function (t, n) {\n        return t[1].length - n[1].length\n      }).map(function (t) {\n        return t[1]\n      }) : tmp[0][1]) : ''\n    }\n\n    // SAN\n    if ((san = certData.match(/X509v3 Subject Alternative Name: \\r?\\n([^\\r\\n]*)\\r?\\n/)) && san.length > 1) {\n      san = san[1].trim() + '\\n'\n      certValues.san = {}\n\n      // hostnames\n      tmp = pregMatchAll('DNS:([^,\\\\r\\\\n].*?)[,\\\\r\\\\n\\\\s]', san)\n      certValues.san.dns = tmp || ''\n\n      // IP-Addresses IPv4 & IPv6\n      tmp = pregMatchAll('IP Address:([^,\\\\r\\\\n].*?)[,\\\\r\\\\n\\\\s]', san)\n      certValues.san.ip = tmp || ''\n\n      // Email Addresses\n      tmp = pregMatchAll('email:([^,\\\\r\\\\n].*?)[,\\\\r\\\\n\\\\s]', san)\n      certValues.san.email = tmp || ''\n    }\n\n    // Validity\n    if ((tmp = certData.match(/Not Before\\s?:\\s?([^\\r\\n]*)\\r?\\n/)) && tmp.length > 1) {\n      validity.start = Date.parse((tmp && tmp[1]) || '')\n    }\n\n    if ((tmp = certData.match(/Not After\\s?:\\s?([^\\r\\n]*)\\r?\\n/)) && tmp.length > 1) {\n      validity.end = Date.parse((tmp && tmp[1]) || '')\n    }\n\n    if (validity.start && validity.end) {\n      certValues.validity = validity\n    }\n    // Validity end\n\n    // Signature Algorithm\n    if ((tmp = certData.match(/Signature Algorithm: ([^\\r\\n]*)\\r?\\n/)) && tmp.length > 1) {\n      certValues.signatureAlgorithm = (tmp && tmp[1]) || ''\n    }\n\n    // Public Key\n    if ((tmp = certData.match(/Public[ -]Key: ([^\\r\\n]*)\\r?\\n/)) && tmp.length > 1) {\n      certValues.publicKeySize = ((tmp && tmp[1]) || '').replace(/[()]/g, '')\n    }\n\n    // Public Key Algorithm\n    if ((tmp = certData.match(/Public Key Algorithm: ([^\\r\\n]*)\\r?\\n/)) && tmp.length > 1) {\n      certValues.publicKeyAlgorithm = (tmp && tmp[1]) || ''\n    }\n\n    callback(null, certValues)\n  } catch (err) {\n    callback(err)\n  }\n}\n\nfunction matchAll(str, regexp) {\n  var matches = []\n  str.replace(regexp, function () {\n    var arr = ([]).slice.call(arguments, 0)\n    var extras = arr.splice(-2)\n    arr.index = extras[0]\n    arr.input = extras[1]\n    matches.push(arr)\n  })\n  return matches.length ? matches : null\n}\n\nfunction pregMatchAll(regex, haystack) {\n  var globalRegex = new RegExp(regex, 'g')\n  var globalMatch = haystack.match(globalRegex) || []\n  var matchArray = []\n  var nonGlobalRegex, nonGlobalMatch\n  for (var i = 0; i < globalMatch.length; i++) {\n    nonGlobalRegex = new RegExp(regex)\n    nonGlobalMatch = globalMatch[i].match(nonGlobalRegex)\n    matchArray.push(nonGlobalMatch[1])\n  }\n  return matchArray\n}\n\nfunction generateCSRSubject(options) {\n  options = options || {}\n\n  var csrData = {\n    C: options.country || options.C,\n    ST: options.state || options.ST,\n    L: options.locality || options.L,\n    O: options.organization || options.O,\n    OU: options.organizationUnit || options.OU,\n    CN: options.commonName || options.CN || 'localhost',\n    DC: options.dc || options.DC || '',\n    emailAddress: options.emailAddress\n  }\n\n  var csrBuilder = Object.keys(csrData).map(function (key) {\n    if (csrData[key]) {\n      if (typeof csrData[key] === 'object' && csrData[key].length >= 1) {\n        var tmpStr = ''\n        csrData[key].map(function (o) {\n          tmpStr += '/' + key + '=' + o.replace(/[^\\w\\s-!$%^&*()_+|~=`{}[\\]:/;<>?,.@#]+/g, ' ').replace('/', '\\\\/').replace('+', '\\\\+').trim()\n        })\n        return tmpStr\n      } else {\n        return '/' + key + '=' + csrData[key].replace(/[^\\w\\s-!$%^&*()_+|~=`{}[\\]:/;<>?,.@#]+/g, ' ').replace('/', '\\\\/').replace('+', '\\\\+').trim()\n      }\n    }\n  })\n\n  return csrBuilder.join('')\n}\n\nfunction readFromString(string, start, end) {\n  if (Buffer.isBuffer(string)) {\n    string = string.toString('utf8')\n  }\n\n  var output = []\n\n  if (!string) {\n    return output\n  }\n\n  var offset = string.indexOf(start)\n\n  while (offset !== -1) {\n    string = string.substring(offset)\n\n    var endOffset = string.indexOf(end)\n\n    if (endOffset === -1) {\n      break\n    }\n\n    endOffset += end.length\n\n    output.push(string.substring(0, endOffset))\n    offset = string.indexOf(start, endOffset)\n  }\n\n  return output\n}\n\n// promisify not tested yet\n/**\n * Verifies the signing chain of the passed certificate\n * @namespace\n * @name promisified\n * @property {function}  createPrivateKey               @see createPrivateKey\n * @property {function}  createDhparam       - The default number of players.\n * @property {function}  createEcparam         - The default level for the party.\n * @property {function}  createCSR      - The default treasure.\n * @property {function}  createCertificate - How much gold the party starts with.\n */\nmodule.exports.promisified = {\n  createPrivateKey: promisify(createPrivateKey),\n  createDhparam: promisify(createDhparam),\n  createEcparam: promisify(createEcparam),\n  createCSR: promisify(createCSR),\n  createCertificate: promisify(createCertificate),\n  readCertificateInfo: promisify(readCertificateInfo),\n  getPublicKey: promisify(getPublicKey),\n  getFingerprint: promisify(getFingerprint),\n  getModulus: promisify(getModulus),\n  getDhparamInfo: promisify(getDhparamInfo),\n  createPkcs12: promisify(createPkcs12),\n  readPkcs12: promisify(readPkcs12),\n  verifySigningChain: promisify(verifySigningChain),\n  checkCertificate: promisify(checkCertificate),\n  checkPkcs12: promisify(checkPkcs12)\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(214);\n"]}(()=>{var e={650:e=>{var r=Object.prototype.toString;var n=typeof Buffer.alloc==="function"&&typeof Buffer.allocUnsafe==="function"&&typeof Buffer.from==="function";function isArrayBuffer(e){return r.call(e).slice(8,-1)==="ArrayBuffer"}function fromArrayBuffer(e,r,t){r>>>=0;var o=e.byteLength-r;if(o<0){throw new RangeError("'offset' is out of bounds")}if(t===undefined){t=o}else{t>>>=0;if(t>o){throw new RangeError("'length' is out of bounds")}}return n?Buffer.from(e.slice(r,r+t)):new Buffer(new Uint8Array(e.slice(r,r+t)))}function fromString(e,r){if(typeof r!=="string"||r===""){r="utf8"}if(!Buffer.isEncoding(r)){throw new TypeError('"encoding" must be a valid string encoding')}return n?Buffer.from(e,r):new Buffer(e,r)}function bufferFrom(e,r,t){if(typeof e==="number"){throw new TypeError('"value" argument must not be a number')}if(isArrayBuffer(e)){return fromArrayBuffer(e,r,t)}if(typeof e==="string"){return fromString(e,r)}return n?Buffer.from(e):new Buffer(e)}e.exports=bufferFrom},284:(e,r,n)=>{e=n.nmd(e);var t=n(596).SourceMapConsumer;var o=n(17);var i;try{i=n(147);if(!i.existsSync||!i.readFileSync){i=null}}catch(e){}var a=n(650);function dynamicRequire(e,r){return e.require(r)}var u=false;var s=false;var l=false;var c="auto";var p={};var f={};var g=/^data:application\/json[^,]+base64,/;var h=[];var d=[];function isInBrowser(){if(c==="browser")return true;if(c==="node")return false;return typeof window!=="undefined"&&typeof XMLHttpRequest==="function"&&!(window.require&&window.module&&window.process&&window.process.type==="renderer")}function hasGlobalProcessEventEmitter(){return typeof process==="object"&&process!==null&&typeof process.on==="function"}function handlerExec(e){return function(r){for(var n=0;n<e.length;n++){var t=e[n](r);if(t){return t}}return null}}var m=handlerExec(h);h.push((function(e){e=e.trim();if(/^file:/.test(e)){e=e.replace(/file:\/\/\/(\w:)?/,(function(e,r){return r?"":"/"}))}if(e in p){return p[e]}var r="";try{if(!i){var n=new XMLHttpRequest;n.open("GET",e,false);n.send(null);if(n.readyState===4&&n.status===200){r=n.responseText}}else if(i.existsSync(e)){r=i.readFileSync(e,"utf8")}}catch(e){}return p[e]=r}));function supportRelativeURL(e,r){if(!e)return r;var n=o.dirname(e);var t=/^\w+:\/\/[^\/]*/.exec(n);var i=t?t[0]:"";var a=n.slice(i.length);if(i&&/^\/\w\:/.test(a)){i+="/";return i+o.resolve(n.slice(i.length),r).replace(/\\/g,"/")}return i+o.resolve(n.slice(i.length),r)}function retrieveSourceMapURL(e){var r;if(isInBrowser()){try{var n=new XMLHttpRequest;n.open("GET",e,false);n.send(null);r=n.readyState===4?n.responseText:null;var t=n.getResponseHeader("SourceMap")||n.getResponseHeader("X-SourceMap");if(t){return t}}catch(e){}}r=m(e);var o=/(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm;var i,a;while(a=o.exec(r))i=a;if(!i)return null;return i[1]}var v=handlerExec(d);d.push((function(e){var r=retrieveSourceMapURL(e);if(!r)return null;var n;if(g.test(r)){var t=r.slice(r.indexOf(",")+1);n=a(t,"base64").toString();r=e}else{r=supportRelativeURL(e,r);n=m(r)}if(!n){return null}return{url:r,map:n}}));function mapSourcePosition(e){var r=f[e.source];if(!r){var n=v(e.source);if(n){r=f[e.source]={url:n.url,map:new t(n.map)};if(r.map.sourcesContent){r.map.sources.forEach((function(e,n){var t=r.map.sourcesContent[n];if(t){var o=supportRelativeURL(r.url,e);p[o]=t}}))}}else{r=f[e.source]={url:null,map:null}}}if(r&&r.map&&typeof r.map.originalPositionFor==="function"){var o=r.map.originalPositionFor(e);if(o.source!==null){o.source=supportRelativeURL(r.url,o.source);return o}}return e}function mapEvalOrigin(e){var r=/^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(e);if(r){var n=mapSourcePosition({source:r[2],line:+r[3],column:r[4]-1});return"eval at "+r[1]+" ("+n.source+":"+n.line+":"+(n.column+1)+")"}r=/^eval at ([^(]+) \((.+)\)$/.exec(e);if(r){return"eval at "+r[1]+" ("+mapEvalOrigin(r[2])+")"}return e}function CallSiteToString(){var e;var r="";if(this.isNative()){r="native"}else{e=this.getScriptNameOrSourceURL();if(!e&&this.isEval()){r=this.getEvalOrigin();r+=", "}if(e){r+=e}else{r+="<anonymous>"}var n=this.getLineNumber();if(n!=null){r+=":"+n;var t=this.getColumnNumber();if(t){r+=":"+t}}}var o="";var i=this.getFunctionName();var a=true;var u=this.isConstructor();var s=!(this.isToplevel()||u);if(s){var l=this.getTypeName();if(l==="[object Object]"){l="null"}var c=this.getMethodName();if(i){if(l&&i.indexOf(l)!=0){o+=l+"."}o+=i;if(c&&i.indexOf("."+c)!=i.length-c.length-1){o+=" [as "+c+"]"}}else{o+=l+"."+(c||"<anonymous>")}}else if(u){o+="new "+(i||"<anonymous>")}else if(i){o+=i}else{o+=r;a=false}if(a){o+=" ("+r+")"}return o}function cloneCallSite(e){var r={};Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){r[n]=/^(?:is|get)/.test(n)?function(){return e[n].call(e)}:e[n]}));r.toString=CallSiteToString;return r}function wrapCallSite(e,r){if(r===undefined){r={nextPosition:null,curPosition:null}}if(e.isNative()){r.curPosition=null;return e}var n=e.getFileName()||e.getScriptNameOrSourceURL();if(n){var t=e.getLineNumber();var o=e.getColumnNumber()-1;var i=/^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;var a=i.test(process.version)?0:62;if(t===1&&o>a&&!isInBrowser()&&!e.isEval()){o-=a}var u=mapSourcePosition({source:n,line:t,column:o});r.curPosition=u;e=cloneCallSite(e);var s=e.getFunctionName;e.getFunctionName=function(){if(r.nextPosition==null){return s()}return r.nextPosition.name||s()};e.getFileName=function(){return u.source};e.getLineNumber=function(){return u.line};e.getColumnNumber=function(){return u.column+1};e.getScriptNameOrSourceURL=function(){return u.source};return e}var l=e.isEval()&&e.getEvalOrigin();if(l){l=mapEvalOrigin(l);e=cloneCallSite(e);e.getEvalOrigin=function(){return l};return e}return e}function prepareStackTrace(e,r){if(l){p={};f={}}var n=e.name||"Error";var t=e.message||"";var o=n+": "+t;var i={nextPosition:null,curPosition:null};var a=[];for(var u=r.length-1;u>=0;u--){a.push("\n    at "+wrapCallSite(r[u],i));i.nextPosition=i.curPosition}i.curPosition=i.nextPosition=null;return o+a.reverse().join("")}function getErrorSource(e){var r=/\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(e.stack);if(r){var n=r[1];var t=+r[2];var o=+r[3];var a=p[n];if(!a&&i&&i.existsSync(n)){try{a=i.readFileSync(n,"utf8")}catch(e){a=""}}if(a){var u=a.split(/(?:\r\n|\r|\n)/)[t-1];if(u){return n+":"+t+"\n"+u+"\n"+new Array(o).join(" ")+"^"}}}return null}function printErrorAndExit(e){var r=getErrorSource(e);if(process.stderr._handle&&process.stderr._handle.setBlocking){process.stderr._handle.setBlocking(true)}if(r){console.error();console.error(r)}console.error(e.stack);process.exit(1)}function shimEmitUncaughtException(){var e=process.emit;process.emit=function(r){if(r==="uncaughtException"){var n=arguments[1]&&arguments[1].stack;var t=this.listeners(r).length>0;if(n&&!t){return printErrorAndExit(arguments[1])}}return e.apply(this,arguments)}}var S=h.slice(0);var _=d.slice(0);r.wrapCallSite=wrapCallSite;r.getErrorSource=getErrorSource;r.mapSourcePosition=mapSourcePosition;r.retrieveSourceMap=v;r.install=function(r){r=r||{};if(r.environment){c=r.environment;if(["node","browser","auto"].indexOf(c)===-1){throw new Error("environment "+c+" was unknown. Available options are {auto, browser, node}")}}if(r.retrieveFile){if(r.overrideRetrieveFile){h.length=0}h.unshift(r.retrieveFile)}if(r.retrieveSourceMap){if(r.overrideRetrieveSourceMap){d.length=0}d.unshift(r.retrieveSourceMap)}if(r.hookRequire&&!isInBrowser()){var n=dynamicRequire(e,"module");var t=n.prototype._compile;if(!t.__sourceMapSupport){n.prototype._compile=function(e,r){p[r]=e;f[r]=undefined;return t.call(this,e,r)};n.prototype._compile.__sourceMapSupport=true}}if(!l){l="emptyCacheBetweenOperations"in r?r.emptyCacheBetweenOperations:false}if(!u){u=true;Error.prepareStackTrace=prepareStackTrace}if(!s){var o="handleUncaughtExceptions"in r?r.handleUncaughtExceptions:true;try{var i=dynamicRequire(e,"worker_threads");if(i.isMainThread===false){o=false}}catch(e){}if(o&&hasGlobalProcessEventEmitter()){s=true;shimEmitUncaughtException()}}};r.resetRetrieveHandlers=function(){h.length=0;d.length=0;h=S.slice(0);d=_.slice(0);v=handlerExec(d);m=handlerExec(h)}},837:(e,r,n)=>{var t=n(983);var o=Object.prototype.hasOwnProperty;var i=typeof Map!=="undefined";function ArraySet(){this._array=[];this._set=i?new Map:Object.create(null)}ArraySet.fromArray=function ArraySet_fromArray(e,r){var n=new ArraySet;for(var t=0,o=e.length;t<o;t++){n.add(e[t],r)}return n};ArraySet.prototype.size=function ArraySet_size(){return i?this._set.size:Object.getOwnPropertyNames(this._set).length};ArraySet.prototype.add=function ArraySet_add(e,r){var n=i?e:t.toSetString(e);var a=i?this.has(e):o.call(this._set,n);var u=this._array.length;if(!a||r){this._array.push(e)}if(!a){if(i){this._set.set(e,u)}else{this._set[n]=u}}};ArraySet.prototype.has=function ArraySet_has(e){if(i){return this._set.has(e)}else{var r=t.toSetString(e);return o.call(this._set,r)}};ArraySet.prototype.indexOf=function ArraySet_indexOf(e){if(i){var r=this._set.get(e);if(r>=0){return r}}else{var n=t.toSetString(e);if(o.call(this._set,n)){return this._set[n]}}throw new Error('"'+e+'" is not in the set.')};ArraySet.prototype.at=function ArraySet_at(e){if(e>=0&&e<this._array.length){return this._array[e]}throw new Error("No element indexed by "+e)};ArraySet.prototype.toArray=function ArraySet_toArray(){return this._array.slice()};r.I=ArraySet},215:(e,r,n)=>{var t=n(537);var o=5;var i=1<<o;var a=i-1;var u=i;function toVLQSigned(e){return e<0?(-e<<1)+1:(e<<1)+0}function fromVLQSigned(e){var r=(e&1)===1;var n=e>>1;return r?-n:n}r.encode=function base64VLQ_encode(e){var r="";var n;var i=toVLQSigned(e);do{n=i&a;i>>>=o;if(i>0){n|=u}r+=t.encode(n)}while(i>0);return r};r.decode=function base64VLQ_decode(e,r,n){var i=e.length;var s=0;var l=0;var c,p;do{if(r>=i){throw new Error("Expected more digits in base 64 VLQ value.")}p=t.decode(e.charCodeAt(r++));if(p===-1){throw new Error("Invalid base64 digit: "+e.charAt(r-1))}c=!!(p&u);p&=a;s=s+(p<<l);l+=o}while(c);n.value=fromVLQSigned(s);n.rest=r}},537:(e,r)=>{var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");r.encode=function(e){if(0<=e&&e<n.length){return n[e]}throw new TypeError("Must be between 0 and 63: "+e)};r.decode=function(e){var r=65;var n=90;var t=97;var o=122;var i=48;var a=57;var u=43;var s=47;var l=26;var c=52;if(r<=e&&e<=n){return e-r}if(t<=e&&e<=o){return e-t+l}if(i<=e&&e<=a){return e-i+c}if(e==u){return 62}if(e==s){return 63}return-1}},164:(e,r)=>{r.GREATEST_LOWER_BOUND=1;r.LEAST_UPPER_BOUND=2;function recursiveSearch(e,n,t,o,i,a){var u=Math.floor((n-e)/2)+e;var s=i(t,o[u],true);if(s===0){return u}else if(s>0){if(n-u>1){return recursiveSearch(u,n,t,o,i,a)}if(a==r.LEAST_UPPER_BOUND){return n<o.length?n:-1}else{return u}}else{if(u-e>1){return recursiveSearch(e,u,t,o,i,a)}if(a==r.LEAST_UPPER_BOUND){return u}else{return e<0?-1:e}}}r.search=function search(e,n,t,o){if(n.length===0){return-1}var i=recursiveSearch(-1,n.length,e,n,t,o||r.GREATEST_LOWER_BOUND);if(i<0){return-1}while(i-1>=0){if(t(n[i],n[i-1],true)!==0){break}--i}return i}},740:(e,r,n)=>{var t=n(983);function generatedPositionAfter(e,r){var n=e.generatedLine;var o=r.generatedLine;var i=e.generatedColumn;var a=r.generatedColumn;return o>n||o==n&&a>=i||t.compareByGeneratedPositionsInflated(e,r)<=0}function MappingList(){this._array=[];this._sorted=true;this._last={generatedLine:-1,generatedColumn:0}}MappingList.prototype.unsortedForEach=function MappingList_forEach(e,r){this._array.forEach(e,r)};MappingList.prototype.add=function MappingList_add(e){if(generatedPositionAfter(this._last,e)){this._last=e;this._array.push(e)}else{this._sorted=false;this._array.push(e)}};MappingList.prototype.toArray=function MappingList_toArray(){if(!this._sorted){this._array.sort(t.compareByGeneratedPositionsInflated);this._sorted=true}return this._array};r.H=MappingList},226:(e,r)=>{function swap(e,r,n){var t=e[r];e[r]=e[n];e[n]=t}function randomIntInRange(e,r){return Math.round(e+Math.random()*(r-e))}function doQuickSort(e,r,n,t){if(n<t){var o=randomIntInRange(n,t);var i=n-1;swap(e,o,t);var a=e[t];for(var u=n;u<t;u++){if(r(e[u],a)<=0){i+=1;swap(e,i,u)}}swap(e,i+1,u);var s=i+1;doQuickSort(e,r,n,s-1);doQuickSort(e,r,s+1,t)}}r.U=function(e,r){doQuickSort(e,r,0,e.length-1)}},327:(e,r,n)=>{var t;var o=n(983);var i=n(164);var a=n(837).I;var u=n(215);var s=n(226).U;function SourceMapConsumer(e,r){var n=e;if(typeof e==="string"){n=o.parseSourceMapInput(e)}return n.sections!=null?new IndexedSourceMapConsumer(n,r):new BasicSourceMapConsumer(n,r)}SourceMapConsumer.fromSourceMap=function(e,r){return BasicSourceMapConsumer.fromSourceMap(e,r)};SourceMapConsumer.prototype._version=3;SourceMapConsumer.prototype.__generatedMappings=null;Object.defineProperty(SourceMapConsumer.prototype,"_generatedMappings",{configurable:true,enumerable:true,get:function(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot)}return this.__generatedMappings}});SourceMapConsumer.prototype.__originalMappings=null;Object.defineProperty(SourceMapConsumer.prototype,"_originalMappings",{configurable:true,enumerable:true,get:function(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot)}return this.__originalMappings}});SourceMapConsumer.prototype._charIsMappingSeparator=function SourceMapConsumer_charIsMappingSeparator(e,r){var n=e.charAt(r);return n===";"||n===","};SourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(e,r){throw new Error("Subclasses must implement _parseMappings")};SourceMapConsumer.GENERATED_ORDER=1;SourceMapConsumer.ORIGINAL_ORDER=2;SourceMapConsumer.GREATEST_LOWER_BOUND=1;SourceMapConsumer.LEAST_UPPER_BOUND=2;SourceMapConsumer.prototype.eachMapping=function SourceMapConsumer_eachMapping(e,r,n){var t=r||null;var i=n||SourceMapConsumer.GENERATED_ORDER;var a;switch(i){case SourceMapConsumer.GENERATED_ORDER:a=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:a=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var u=this.sourceRoot;a.map((function(e){var r=e.source===null?null:this._sources.at(e.source);r=o.computeSourceURL(u,r,this._sourceMapURL);return{source:r,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:e.name===null?null:this._names.at(e.name)}}),this).forEach(e,t)};SourceMapConsumer.prototype.allGeneratedPositionsFor=function SourceMapConsumer_allGeneratedPositionsFor(e){var r=o.getArg(e,"line");var n={source:o.getArg(e,"source"),originalLine:r,originalColumn:o.getArg(e,"column",0)};n.source=this._findSourceIndex(n.source);if(n.source<0){return[]}var t=[];var a=this._findMapping(n,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,i.LEAST_UPPER_BOUND);if(a>=0){var u=this._originalMappings[a];if(e.column===undefined){var s=u.originalLine;while(u&&u.originalLine===s){t.push({line:o.getArg(u,"generatedLine",null),column:o.getArg(u,"generatedColumn",null),lastColumn:o.getArg(u,"lastGeneratedColumn",null)});u=this._originalMappings[++a]}}else{var l=u.originalColumn;while(u&&u.originalLine===r&&u.originalColumn==l){t.push({line:o.getArg(u,"generatedLine",null),column:o.getArg(u,"generatedColumn",null),lastColumn:o.getArg(u,"lastGeneratedColumn",null)});u=this._originalMappings[++a]}}}return t};r.SourceMapConsumer=SourceMapConsumer;function BasicSourceMapConsumer(e,r){var n=e;if(typeof e==="string"){n=o.parseSourceMapInput(e)}var t=o.getArg(n,"version");var i=o.getArg(n,"sources");var u=o.getArg(n,"names",[]);var s=o.getArg(n,"sourceRoot",null);var l=o.getArg(n,"sourcesContent",null);var c=o.getArg(n,"mappings");var p=o.getArg(n,"file",null);if(t!=this._version){throw new Error("Unsupported version: "+t)}if(s){s=o.normalize(s)}i=i.map(String).map(o.normalize).map((function(e){return s&&o.isAbsolute(s)&&o.isAbsolute(e)?o.relative(s,e):e}));this._names=a.fromArray(u.map(String),true);this._sources=a.fromArray(i,true);this._absoluteSources=this._sources.toArray().map((function(e){return o.computeSourceURL(s,e,r)}));this.sourceRoot=s;this.sourcesContent=l;this._mappings=c;this._sourceMapURL=r;this.file=p}BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer;BasicSourceMapConsumer.prototype._findSourceIndex=function(e){var r=e;if(this.sourceRoot!=null){r=o.relative(this.sourceRoot,r)}if(this._sources.has(r)){return this._sources.indexOf(r)}var n;for(n=0;n<this._absoluteSources.length;++n){if(this._absoluteSources[n]==e){return n}}return-1};BasicSourceMapConsumer.fromSourceMap=function SourceMapConsumer_fromSourceMap(e,r){var n=Object.create(BasicSourceMapConsumer.prototype);var t=n._names=a.fromArray(e._names.toArray(),true);var i=n._sources=a.fromArray(e._sources.toArray(),true);n.sourceRoot=e._sourceRoot;n.sourcesContent=e._generateSourcesContent(n._sources.toArray(),n.sourceRoot);n.file=e._file;n._sourceMapURL=r;n._absoluteSources=n._sources.toArray().map((function(e){return o.computeSourceURL(n.sourceRoot,e,r)}));var u=e._mappings.toArray().slice();var l=n.__generatedMappings=[];var c=n.__originalMappings=[];for(var p=0,f=u.length;p<f;p++){var g=u[p];var h=new Mapping;h.generatedLine=g.generatedLine;h.generatedColumn=g.generatedColumn;if(g.source){h.source=i.indexOf(g.source);h.originalLine=g.originalLine;h.originalColumn=g.originalColumn;if(g.name){h.name=t.indexOf(g.name)}c.push(h)}l.push(h)}s(n.__originalMappings,o.compareByOriginalPositions);return n};BasicSourceMapConsumer.prototype._version=3;Object.defineProperty(BasicSourceMapConsumer.prototype,"sources",{get:function(){return this._absoluteSources.slice()}});function Mapping(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null}BasicSourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(e,r){var n=1;var t=0;var i=0;var a=0;var l=0;var c=0;var p=e.length;var f=0;var g={};var h={};var d=[];var m=[];var v,S,_,C,y;while(f<p){if(e.charAt(f)===";"){n++;f++;t=0}else if(e.charAt(f)===","){f++}else{v=new Mapping;v.generatedLine=n;for(C=f;C<p;C++){if(this._charIsMappingSeparator(e,C)){break}}S=e.slice(f,C);_=g[S];if(_){f+=S.length}else{_=[];while(f<C){u.decode(e,f,h);y=h.value;f=h.rest;_.push(y)}if(_.length===2){throw new Error("Found a source, but no line and column")}if(_.length===3){throw new Error("Found a source and line, but no column")}g[S]=_}v.generatedColumn=t+_[0];t=v.generatedColumn;if(_.length>1){v.source=l+_[1];l+=_[1];v.originalLine=i+_[2];i=v.originalLine;v.originalLine+=1;v.originalColumn=a+_[3];a=v.originalColumn;if(_.length>4){v.name=c+_[4];c+=_[4]}}m.push(v);if(typeof v.originalLine==="number"){d.push(v)}}}s(m,o.compareByGeneratedPositionsDeflated);this.__generatedMappings=m;s(d,o.compareByOriginalPositions);this.__originalMappings=d};BasicSourceMapConsumer.prototype._findMapping=function SourceMapConsumer_findMapping(e,r,n,t,o,a){if(e[n]<=0){throw new TypeError("Line must be greater than or equal to 1, got "+e[n])}if(e[t]<0){throw new TypeError("Column must be greater than or equal to 0, got "+e[t])}return i.search(e,r,o,a)};BasicSourceMapConsumer.prototype.computeColumnSpans=function SourceMapConsumer_computeColumnSpans(){for(var e=0;e<this._generatedMappings.length;++e){var r=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var n=this._generatedMappings[e+1];if(r.generatedLine===n.generatedLine){r.lastGeneratedColumn=n.generatedColumn-1;continue}}r.lastGeneratedColumn=Infinity}};BasicSourceMapConsumer.prototype.originalPositionFor=function SourceMapConsumer_originalPositionFor(e){var r={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")};var n=this._findMapping(r,this._generatedMappings,"generatedLine","generatedColumn",o.compareByGeneratedPositionsDeflated,o.getArg(e,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND));if(n>=0){var t=this._generatedMappings[n];if(t.generatedLine===r.generatedLine){var i=o.getArg(t,"source",null);if(i!==null){i=this._sources.at(i);i=o.computeSourceURL(this.sourceRoot,i,this._sourceMapURL)}var a=o.getArg(t,"name",null);if(a!==null){a=this._names.at(a)}return{source:i,line:o.getArg(t,"originalLine",null),column:o.getArg(t,"originalColumn",null),name:a}}}return{source:null,line:null,column:null,name:null}};BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function BasicSourceMapConsumer_hasContentsOfAllSources(){if(!this.sourcesContent){return false}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(e){return e==null}))};BasicSourceMapConsumer.prototype.sourceContentFor=function SourceMapConsumer_sourceContentFor(e,r){if(!this.sourcesContent){return null}var n=this._findSourceIndex(e);if(n>=0){return this.sourcesContent[n]}var t=e;if(this.sourceRoot!=null){t=o.relative(this.sourceRoot,t)}var i;if(this.sourceRoot!=null&&(i=o.urlParse(this.sourceRoot))){var a=t.replace(/^file:\/\//,"");if(i.scheme=="file"&&this._sources.has(a)){return this.sourcesContent[this._sources.indexOf(a)]}if((!i.path||i.path=="/")&&this._sources.has("/"+t)){return this.sourcesContent[this._sources.indexOf("/"+t)]}}if(r){return null}else{throw new Error('"'+t+'" is not in the SourceMap.')}};BasicSourceMapConsumer.prototype.generatedPositionFor=function SourceMapConsumer_generatedPositionFor(e){var r=o.getArg(e,"source");r=this._findSourceIndex(r);if(r<0){return{line:null,column:null,lastColumn:null}}var n={source:r,originalLine:o.getArg(e,"line"),originalColumn:o.getArg(e,"column")};var t=this._findMapping(n,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,o.getArg(e,"bias",SourceMapConsumer.GREATEST_LOWER_BOUND));if(t>=0){var i=this._originalMappings[t];if(i.source===n.source){return{line:o.getArg(i,"generatedLine",null),column:o.getArg(i,"generatedColumn",null),lastColumn:o.getArg(i,"lastGeneratedColumn",null)}}}return{line:null,column:null,lastColumn:null}};t=BasicSourceMapConsumer;function IndexedSourceMapConsumer(e,r){var n=e;if(typeof e==="string"){n=o.parseSourceMapInput(e)}var t=o.getArg(n,"version");var i=o.getArg(n,"sections");if(t!=this._version){throw new Error("Unsupported version: "+t)}this._sources=new a;this._names=new a;var u={line:-1,column:0};this._sections=i.map((function(e){if(e.url){throw new Error("Support for url field in sections not implemented.")}var n=o.getArg(e,"offset");var t=o.getArg(n,"line");var i=o.getArg(n,"column");if(t<u.line||t===u.line&&i<u.column){throw new Error("Section offsets must be ordered and non-overlapping.")}u=n;return{generatedOffset:{generatedLine:t+1,generatedColumn:i+1},consumer:new SourceMapConsumer(o.getArg(e,"map"),r)}}))}IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer;IndexedSourceMapConsumer.prototype._version=3;Object.defineProperty(IndexedSourceMapConsumer.prototype,"sources",{get:function(){var e=[];for(var r=0;r<this._sections.length;r++){for(var n=0;n<this._sections[r].consumer.sources.length;n++){e.push(this._sections[r].consumer.sources[n])}}return e}});IndexedSourceMapConsumer.prototype.originalPositionFor=function IndexedSourceMapConsumer_originalPositionFor(e){var r={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")};var n=i.search(r,this._sections,(function(e,r){var n=e.generatedLine-r.generatedOffset.generatedLine;if(n){return n}return e.generatedColumn-r.generatedOffset.generatedColumn}));var t=this._sections[n];if(!t){return{source:null,line:null,column:null,name:null}}return t.consumer.originalPositionFor({line:r.generatedLine-(t.generatedOffset.generatedLine-1),column:r.generatedColumn-(t.generatedOffset.generatedLine===r.generatedLine?t.generatedOffset.generatedColumn-1:0),bias:e.bias})};IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function IndexedSourceMapConsumer_hasContentsOfAllSources(){return this._sections.every((function(e){return e.consumer.hasContentsOfAllSources()}))};IndexedSourceMapConsumer.prototype.sourceContentFor=function IndexedSourceMapConsumer_sourceContentFor(e,r){for(var n=0;n<this._sections.length;n++){var t=this._sections[n];var o=t.consumer.sourceContentFor(e,true);if(o){return o}}if(r){return null}else{throw new Error('"'+e+'" is not in the SourceMap.')}};IndexedSourceMapConsumer.prototype.generatedPositionFor=function IndexedSourceMapConsumer_generatedPositionFor(e){for(var r=0;r<this._sections.length;r++){var n=this._sections[r];if(n.consumer._findSourceIndex(o.getArg(e,"source"))===-1){continue}var t=n.consumer.generatedPositionFor(e);if(t){var i={line:t.line+(n.generatedOffset.generatedLine-1),column:t.column+(n.generatedOffset.generatedLine===t.line?n.generatedOffset.generatedColumn-1:0)};return i}}return{line:null,column:null}};IndexedSourceMapConsumer.prototype._parseMappings=function IndexedSourceMapConsumer_parseMappings(e,r){this.__generatedMappings=[];this.__originalMappings=[];for(var n=0;n<this._sections.length;n++){var t=this._sections[n];var i=t.consumer._generatedMappings;for(var a=0;a<i.length;a++){var u=i[a];var l=t.consumer._sources.at(u.source);l=o.computeSourceURL(t.consumer.sourceRoot,l,this._sourceMapURL);this._sources.add(l);l=this._sources.indexOf(l);var c=null;if(u.name){c=t.consumer._names.at(u.name);this._names.add(c);c=this._names.indexOf(c)}var p={source:l,generatedLine:u.generatedLine+(t.generatedOffset.generatedLine-1),generatedColumn:u.generatedColumn+(t.generatedOffset.generatedLine===u.generatedLine?t.generatedOffset.generatedColumn-1:0),originalLine:u.originalLine,originalColumn:u.originalColumn,name:c};this.__generatedMappings.push(p);if(typeof p.originalLine==="number"){this.__originalMappings.push(p)}}}s(this.__generatedMappings,o.compareByGeneratedPositionsDeflated);s(this.__originalMappings,o.compareByOriginalPositions)};t=IndexedSourceMapConsumer},341:(e,r,n)=>{var t=n(215);var o=n(983);var i=n(837).I;var a=n(740).H;function SourceMapGenerator(e){if(!e){e={}}this._file=o.getArg(e,"file",null);this._sourceRoot=o.getArg(e,"sourceRoot",null);this._skipValidation=o.getArg(e,"skipValidation",false);this._sources=new i;this._names=new i;this._mappings=new a;this._sourcesContents=null}SourceMapGenerator.prototype._version=3;SourceMapGenerator.fromSourceMap=function SourceMapGenerator_fromSourceMap(e){var r=e.sourceRoot;var n=new SourceMapGenerator({file:e.file,sourceRoot:r});e.eachMapping((function(e){var t={generated:{line:e.generatedLine,column:e.generatedColumn}};if(e.source!=null){t.source=e.source;if(r!=null){t.source=o.relative(r,t.source)}t.original={line:e.originalLine,column:e.originalColumn};if(e.name!=null){t.name=e.name}}n.addMapping(t)}));e.sources.forEach((function(t){var i=t;if(r!==null){i=o.relative(r,t)}if(!n._sources.has(i)){n._sources.add(i)}var a=e.sourceContentFor(t);if(a!=null){n.setSourceContent(t,a)}}));return n};SourceMapGenerator.prototype.addMapping=function SourceMapGenerator_addMapping(e){var r=o.getArg(e,"generated");var n=o.getArg(e,"original",null);var t=o.getArg(e,"source",null);var i=o.getArg(e,"name",null);if(!this._skipValidation){this._validateMapping(r,n,t,i)}if(t!=null){t=String(t);if(!this._sources.has(t)){this._sources.add(t)}}if(i!=null){i=String(i);if(!this._names.has(i)){this._names.add(i)}}this._mappings.add({generatedLine:r.line,generatedColumn:r.column,originalLine:n!=null&&n.line,originalColumn:n!=null&&n.column,source:t,name:i})};SourceMapGenerator.prototype.setSourceContent=function SourceMapGenerator_setSourceContent(e,r){var n=e;if(this._sourceRoot!=null){n=o.relative(this._sourceRoot,n)}if(r!=null){if(!this._sourcesContents){this._sourcesContents=Object.create(null)}this._sourcesContents[o.toSetString(n)]=r}else if(this._sourcesContents){delete this._sourcesContents[o.toSetString(n)];if(Object.keys(this._sourcesContents).length===0){this._sourcesContents=null}}};SourceMapGenerator.prototype.applySourceMap=function SourceMapGenerator_applySourceMap(e,r,n){var t=r;if(r==null){if(e.file==null){throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, "+'or the source map\'s "file" property. Both were omitted.')}t=e.file}var a=this._sourceRoot;if(a!=null){t=o.relative(a,t)}var u=new i;var s=new i;this._mappings.unsortedForEach((function(r){if(r.source===t&&r.originalLine!=null){var i=e.originalPositionFor({line:r.originalLine,column:r.originalColumn});if(i.source!=null){r.source=i.source;if(n!=null){r.source=o.join(n,r.source)}if(a!=null){r.source=o.relative(a,r.source)}r.originalLine=i.line;r.originalColumn=i.column;if(i.name!=null){r.name=i.name}}}var l=r.source;if(l!=null&&!u.has(l)){u.add(l)}var c=r.name;if(c!=null&&!s.has(c)){s.add(c)}}),this);this._sources=u;this._names=s;e.sources.forEach((function(r){var t=e.sourceContentFor(r);if(t!=null){if(n!=null){r=o.join(n,r)}if(a!=null){r=o.relative(a,r)}this.setSourceContent(r,t)}}),this)};SourceMapGenerator.prototype._validateMapping=function SourceMapGenerator_validateMapping(e,r,n,t){if(r&&typeof r.line!=="number"&&typeof r.column!=="number"){throw new Error("original.line and original.column are not numbers -- you probably meant to omit "+"the original mapping entirely and only map the generated position. If so, pass "+"null for the original mapping instead of an object with empty or null values.")}if(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0&&!r&&!n&&!t){return}else if(e&&"line"in e&&"column"in e&&r&&"line"in r&&"column"in r&&e.line>0&&e.column>=0&&r.line>0&&r.column>=0&&n){return}else{throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:n,original:r,name:t}))}};SourceMapGenerator.prototype._serializeMappings=function SourceMapGenerator_serializeMappings(){var e=0;var r=1;var n=0;var i=0;var a=0;var u=0;var s="";var l;var c;var p;var f;var g=this._mappings.toArray();for(var h=0,d=g.length;h<d;h++){c=g[h];l="";if(c.generatedLine!==r){e=0;while(c.generatedLine!==r){l+=";";r++}}else{if(h>0){if(!o.compareByGeneratedPositionsInflated(c,g[h-1])){continue}l+=","}}l+=t.encode(c.generatedColumn-e);e=c.generatedColumn;if(c.source!=null){f=this._sources.indexOf(c.source);l+=t.encode(f-u);u=f;l+=t.encode(c.originalLine-1-i);i=c.originalLine-1;l+=t.encode(c.originalColumn-n);n=c.originalColumn;if(c.name!=null){p=this._names.indexOf(c.name);l+=t.encode(p-a);a=p}}s+=l}return s};SourceMapGenerator.prototype._generateSourcesContent=function SourceMapGenerator_generateSourcesContent(e,r){return e.map((function(e){if(!this._sourcesContents){return null}if(r!=null){e=o.relative(r,e)}var n=o.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,n)?this._sourcesContents[n]:null}),this)};SourceMapGenerator.prototype.toJSON=function SourceMapGenerator_toJSON(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};if(this._file!=null){e.file=this._file}if(this._sourceRoot!=null){e.sourceRoot=this._sourceRoot}if(this._sourcesContents){e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)}return e};SourceMapGenerator.prototype.toString=function SourceMapGenerator_toString(){return JSON.stringify(this.toJSON())};r.h=SourceMapGenerator},990:(e,r,n)=>{var t;var o=n(341).h;var i=n(983);var a=/(\r?\n)/;var u=10;var s="$$$isSourceNode$$$";function SourceNode(e,r,n,t,o){this.children=[];this.sourceContents={};this.line=e==null?null:e;this.column=r==null?null:r;this.source=n==null?null:n;this.name=o==null?null:o;this[s]=true;if(t!=null)this.add(t)}SourceNode.fromStringWithSourceMap=function SourceNode_fromStringWithSourceMap(e,r,n){var t=new SourceNode;var o=e.split(a);var u=0;var shiftNextLine=function(){var e=getNextLine();var r=getNextLine()||"";return e+r;function getNextLine(){return u<o.length?o[u++]:undefined}};var s=1,l=0;var c=null;r.eachMapping((function(e){if(c!==null){if(s<e.generatedLine){addMappingWithCode(c,shiftNextLine());s++;l=0}else{var r=o[u]||"";var n=r.substr(0,e.generatedColumn-l);o[u]=r.substr(e.generatedColumn-l);l=e.generatedColumn;addMappingWithCode(c,n);c=e;return}}while(s<e.generatedLine){t.add(shiftNextLine());s++}if(l<e.generatedColumn){var r=o[u]||"";t.add(r.substr(0,e.generatedColumn));o[u]=r.substr(e.generatedColumn);l=e.generatedColumn}c=e}),this);if(u<o.length){if(c){addMappingWithCode(c,shiftNextLine())}t.add(o.splice(u).join(""))}r.sources.forEach((function(e){var o=r.sourceContentFor(e);if(o!=null){if(n!=null){e=i.join(n,e)}t.setSourceContent(e,o)}}));return t;function addMappingWithCode(e,r){if(e===null||e.source===undefined){t.add(r)}else{var o=n?i.join(n,e.source):e.source;t.add(new SourceNode(e.originalLine,e.originalColumn,o,r,e.name))}}};SourceNode.prototype.add=function SourceNode_add(e){if(Array.isArray(e)){e.forEach((function(e){this.add(e)}),this)}else if(e[s]||typeof e==="string"){if(e){this.children.push(e)}}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e)}return this};SourceNode.prototype.prepend=function SourceNode_prepend(e){if(Array.isArray(e)){for(var r=e.length-1;r>=0;r--){this.prepend(e[r])}}else if(e[s]||typeof e==="string"){this.children.unshift(e)}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e)}return this};SourceNode.prototype.walk=function SourceNode_walk(e){var r;for(var n=0,t=this.children.length;n<t;n++){r=this.children[n];if(r[s]){r.walk(e)}else{if(r!==""){e(r,{source:this.source,line:this.line,column:this.column,name:this.name})}}}};SourceNode.prototype.join=function SourceNode_join(e){var r;var n;var t=this.children.length;if(t>0){r=[];for(n=0;n<t-1;n++){r.push(this.children[n]);r.push(e)}r.push(this.children[n]);this.children=r}return this};SourceNode.prototype.replaceRight=function SourceNode_replaceRight(e,r){var n=this.children[this.children.length-1];if(n[s]){n.replaceRight(e,r)}else if(typeof n==="string"){this.children[this.children.length-1]=n.replace(e,r)}else{this.children.push("".replace(e,r))}return this};SourceNode.prototype.setSourceContent=function SourceNode_setSourceContent(e,r){this.sourceContents[i.toSetString(e)]=r};SourceNode.prototype.walkSourceContents=function SourceNode_walkSourceContents(e){for(var r=0,n=this.children.length;r<n;r++){if(this.children[r][s]){this.children[r].walkSourceContents(e)}}var t=Object.keys(this.sourceContents);for(var r=0,n=t.length;r<n;r++){e(i.fromSetString(t[r]),this.sourceContents[t[r]])}};SourceNode.prototype.toString=function SourceNode_toString(){var e="";this.walk((function(r){e+=r}));return e};SourceNode.prototype.toStringWithSourceMap=function SourceNode_toStringWithSourceMap(e){var r={code:"",line:1,column:0};var n=new o(e);var t=false;var i=null;var a=null;var s=null;var l=null;this.walk((function(e,o){r.code+=e;if(o.source!==null&&o.line!==null&&o.column!==null){if(i!==o.source||a!==o.line||s!==o.column||l!==o.name){n.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:r.line,column:r.column},name:o.name})}i=o.source;a=o.line;s=o.column;l=o.name;t=true}else if(t){n.addMapping({generated:{line:r.line,column:r.column}});i=null;t=false}for(var c=0,p=e.length;c<p;c++){if(e.charCodeAt(c)===u){r.line++;r.column=0;if(c+1===p){i=null;t=false}else if(t){n.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:r.line,column:r.column},name:o.name})}}else{r.column++}}}));this.walkSourceContents((function(e,r){n.setSourceContent(e,r)}));return{code:r.code,map:n}};t=SourceNode},983:(e,r)=>{function getArg(e,r,n){if(r in e){return e[r]}else if(arguments.length===3){return n}else{throw new Error('"'+r+'" is a required argument.')}}r.getArg=getArg;var n=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;var t=/^data:.+\,.+$/;function urlParse(e){var r=e.match(n);if(!r){return null}return{scheme:r[1],auth:r[2],host:r[3],port:r[4],path:r[5]}}r.urlParse=urlParse;function urlGenerate(e){var r="";if(e.scheme){r+=e.scheme+":"}r+="//";if(e.auth){r+=e.auth+"@"}if(e.host){r+=e.host}if(e.port){r+=":"+e.port}if(e.path){r+=e.path}return r}r.urlGenerate=urlGenerate;function normalize(e){var n=e;var t=urlParse(e);if(t){if(!t.path){return e}n=t.path}var o=r.isAbsolute(n);var i=n.split(/\/+/);for(var a,u=0,s=i.length-1;s>=0;s--){a=i[s];if(a==="."){i.splice(s,1)}else if(a===".."){u++}else if(u>0){if(a===""){i.splice(s+1,u);u=0}else{i.splice(s,2);u--}}}n=i.join("/");if(n===""){n=o?"/":"."}if(t){t.path=n;return urlGenerate(t)}return n}r.normalize=normalize;function join(e,r){if(e===""){e="."}if(r===""){r="."}var n=urlParse(r);var o=urlParse(e);if(o){e=o.path||"/"}if(n&&!n.scheme){if(o){n.scheme=o.scheme}return urlGenerate(n)}if(n||r.match(t)){return r}if(o&&!o.host&&!o.path){o.host=r;return urlGenerate(o)}var i=r.charAt(0)==="/"?r:normalize(e.replace(/\/+$/,"")+"/"+r);if(o){o.path=i;return urlGenerate(o)}return i}r.join=join;r.isAbsolute=function(e){return e.charAt(0)==="/"||n.test(e)};function relative(e,r){if(e===""){e="."}e=e.replace(/\/$/,"");var n=0;while(r.indexOf(e+"/")!==0){var t=e.lastIndexOf("/");if(t<0){return r}e=e.slice(0,t);if(e.match(/^([^\/]+:\/)?\/*$/)){return r}++n}return Array(n+1).join("../")+r.substr(e.length+1)}r.relative=relative;var o=function(){var e=Object.create(null);return!("__proto__"in e)}();function identity(e){return e}function toSetString(e){if(isProtoString(e)){return"$"+e}return e}r.toSetString=o?identity:toSetString;function fromSetString(e){if(isProtoString(e)){return e.slice(1)}return e}r.fromSetString=o?identity:fromSetString;function isProtoString(e){if(!e){return false}var r=e.length;if(r<9){return false}if(e.charCodeAt(r-1)!==95||e.charCodeAt(r-2)!==95||e.charCodeAt(r-3)!==111||e.charCodeAt(r-4)!==116||e.charCodeAt(r-5)!==111||e.charCodeAt(r-6)!==114||e.charCodeAt(r-7)!==112||e.charCodeAt(r-8)!==95||e.charCodeAt(r-9)!==95){return false}for(var n=r-10;n>=0;n--){if(e.charCodeAt(n)!==36){return false}}return true}function compareByOriginalPositions(e,r,n){var t=strcmp(e.source,r.source);if(t!==0){return t}t=e.originalLine-r.originalLine;if(t!==0){return t}t=e.originalColumn-r.originalColumn;if(t!==0||n){return t}t=e.generatedColumn-r.generatedColumn;if(t!==0){return t}t=e.generatedLine-r.generatedLine;if(t!==0){return t}return strcmp(e.name,r.name)}r.compareByOriginalPositions=compareByOriginalPositions;function compareByGeneratedPositionsDeflated(e,r,n){var t=e.generatedLine-r.generatedLine;if(t!==0){return t}t=e.generatedColumn-r.generatedColumn;if(t!==0||n){return t}t=strcmp(e.source,r.source);if(t!==0){return t}t=e.originalLine-r.originalLine;if(t!==0){return t}t=e.originalColumn-r.originalColumn;if(t!==0){return t}return strcmp(e.name,r.name)}r.compareByGeneratedPositionsDeflated=compareByGeneratedPositionsDeflated;function strcmp(e,r){if(e===r){return 0}if(e===null){return 1}if(r===null){return-1}if(e>r){return 1}return-1}function compareByGeneratedPositionsInflated(e,r){var n=e.generatedLine-r.generatedLine;if(n!==0){return n}n=e.generatedColumn-r.generatedColumn;if(n!==0){return n}n=strcmp(e.source,r.source);if(n!==0){return n}n=e.originalLine-r.originalLine;if(n!==0){return n}n=e.originalColumn-r.originalColumn;if(n!==0){return n}return strcmp(e.name,r.name)}r.compareByGeneratedPositionsInflated=compareByGeneratedPositionsInflated;function parseSourceMapInput(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))}r.parseSourceMapInput=parseSourceMapInput;function computeSourceURL(e,r,n){r=r||"";if(e){if(e[e.length-1]!=="/"&&r[0]!=="/"){e+="/"}r=e+r}if(n){var t=urlParse(n);if(!t){throw new Error("sourceMapURL could not be parsed")}if(t.path){var o=t.path.lastIndexOf("/");if(o>=0){t.path=t.path.substring(0,o+1)}}r=join(urlGenerate(t),r)}return normalize(r)}r.computeSourceURL=computeSourceURL},596:(e,r,n)=>{n(341).h;r.SourceMapConsumer=n(327).SourceMapConsumer;n(990)},147:e=>{"use strict";e.exports=require("fs")},17:e=>{"use strict";e.exports=require("path")}};var r={};function __webpack_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={id:n,loaded:false,exports:{}};var i=true;try{e[n](o,o.exports,__webpack_require__);i=false}finally{if(i)delete r[n]}o.loaded=true;return o.exports}(()=>{__webpack_require__.nmd=e=>{e.paths=[];if(!e.children)e.children=[];return e}})();if(typeof __webpack_require__!=="undefined")__webpack_require__.ab=__dirname+"/";var n={};(()=>{__webpack_require__(284).install()})();module.exports=n})();Copyright (c) 2012 Andris Reinman
Copyright (c) 2016 Josef Frhle

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.{
  "author": "Andris Reinman <andris@kreata.ee>",
  "contributors": [
    {
      "name": "Josef Frhle",
      "email": "github@josef-froehle.de",
      "url": "https://www.josef-froehle.de/"
    }
  ],
  "license": "MIT",
  "name": "@postman/pem",
  "description": "Create private keys and certificates with node.js and io.js",
  "version": "1.14.6",
  "repository": {
    "type": "git",
    "url": "https://github.com/postmanlabs/pem"
  },
  "main": "./dist/index.js",
  "files": [
    "dist"
  ],
  "type": "commonjs",
  "scripts": {
    "documentation": "yarn run docco && yarn run jsdoc",
    "docco": "docco -l parallel -o docs/docco lib/helper.js lib/openssl.js lib/pem.js",
    "jsdoc": "jsdoc -c jsdoc.json",
    "build": "ncc build -m -s lib/pem.js -o dist",
    "changelog": "auto-changelog -p --output HISTORY.md",
    "coverage": "cross-env NODE_ENV=development nyc ./node_modules/.bin/_mocha --recursive --bail --inline-diffs --reporter spec --check-leaks --use_strict $(find . -type f -name '*.spec.js'  ! -path './nyc_output/*' ! -path './coverage/*' ! -path './node_modules/*')",
    "lint": "eslint --fix --config=./.eslintrc.js lib/*.js *.md *.json lib/*.js test/*.js test/*.spec.js",
    "test": "yarn run lint && yarn run coverage",
    "test:opensslv3.0.1": "yarn run build > openssl_v3.0.1.log && yarn run test >> openssl_v3.0.1.log"
  },
  "nyc": {
    "reporter": [
      "html",
      "text"
    ],
    "exclude": [
      "**/*.spec.js",
      "test/pem.helper.js"
    ]
  },
  "dependencies": {
    "es6-promisify": "^7.0.0",
    "md5": "^2.3.0",
    "os-tmpdir": "^1.0.2",
    "which": "^2.0.2"
  },
  "devDependencies": {
    "@deineagenturug/docdash": "0.4.2",
    "@types/chai": "4.3.1",
    "@types/dirty-chai": "2.0.2",
    "@vercel/ncc": "0.33.4",
    "auto-changelog": "2.4.0",
    "chai": "4.3.6",
    "cross-env": "7.0.3",
    "dirty-chai": "2.0.1",
    "docco": "0.9.1",
    "eslint": "8.14.0",
    "eslint-plugin-chai-friendly": "0.7.2",
    "eslint-plugin-eslint-plugin": "4.1.0",
    "eslint-plugin-import": "2.26.0",
    "eslint-plugin-json": "3.1.0",
    "eslint-plugin-markdown": "2.2.1",
    "eslint-plugin-mocha": "10.0.4",
    "eslint-plugin-n": "15.2.0",
    "eslint-plugin-promise": "6.0.0",
    "jsdoc": "3.6.10",
    "marked": "4.0.14",
    "mocha": "9.2.2",
    "nyc": "15.1.0"
  },
  "engines": {
    "node": ">=14.0.0"
  }
}
pem
===

Create private keys and certificates with node.js

[![Build Status](https://secure.travis-ci.org/Dexus/pem.png)](http://travis-ci.org/Dexus/pem) [![npm version](https://badge.fury.io/js/pem.svg)](http://badge.fury.io/js/pem) [![npm downloads](https://img.shields.io/npm/dt/pem.svg)](https://www.npmjs.com/package/pem) [![pem documentation](https://img.shields.io/badge/pem-documentation-0099ff.svg?style=flat)](https://dexus.github.io/pem/jsdoc/)

[![JavaScript Style Guide](https://cdn.rawgit.com/standard/standard/master/badge.svg)](https://github.com/standard/standard)

## Installation

Install with npm

    npm install pem

or use yarn

    yarn add pem

:warning: Please make sure you have `openssl` or `libressl` already installed on your system/container, without
them `pem` will not work.

## Examples

Here are some examples for creating an SSL key/cert on the fly, and running an HTTPS server on port 443. 443 is the
standard HTTPS port, but requires root permissions on most systems. To get around this, you could use a higher port
number, like 4300, and use https://localhost:4300 to access your server.

### Basic https

```javascript
var https = require('https')
var pem = require('pem')

pem.createCertificate({ days: 1, selfSigned: true }, function (err, keys) {
  if (err) {
    throw err
  }
  https.createServer({ key: keys.clientKey, cert: keys.certificate }, function (req, res) {
    res.end('o hai!')
  }).listen(443)
})
```

###  Express
```javascript
var https = require('https')
var pem = require('pem')
var express = require('express')

pem.createCertificate({ days: 1, selfSigned: true }, function (err, keys) {
  if (err) {
    throw err
  }
  var app = express()

  app.get('/', function (req, res) {
    res.send('o hai!')
  })

  https.createServer({ key: keys.clientKey, cert: keys.certificate }, app).listen(443)
})
```

## API
Please have a look into the [API documentation](https://dexus.github.io/pem/jsdoc/).

_we had to clean up a bit_
<!--
### Create a dhparam key

Use `createDhparam` for creating dhparam keys

    pem.createDhparam(keyBitsize, callback)

Where

  * **keyBitsize** is an optional size of the key, defaults to 512 (bit)
  * **callback** is a callback function with an error object and `{dhparam}`

### Create a ecparam key

Use `createEcparam` for creating ecparam keys

    pem.createEcparam(keyName, callback)

Where

  * **keyName** is an optional name of the key curves name, defaults to secp256k1
  * **callback** is a callback function with an error object and `{ecparam}`

### Create a private key

Use `createPrivateKey` for creating private keys

    pem.createPrivateKey(keyBitsize, [options,] callback)

Where

  * **keyBitsize** is an optional size of the key, defaults to 2048 (bit)
  * **options** is an optional object of the cipher and password (both required for encryption), defaults {cipher:'',password:''}
  (ciphers:["aes128", "aes192", "aes256", "camellia128", "camellia192", "camellia256", "des", "des3", "idea"])
  * **callback** is a callback function with an error object and `{key}`

### Create a Certificate Signing Request

Use `createCSR` for creating certificate signing requests

    pem.createCSR(options, callback)

Where

  * **options** is an optional options object
  * **callback** is a callback function with an error object and `{csr, clientKey}`

Possible options are the following

  * **clientKey** is an optional client key to use
  * **clientKeyPassword** the optional password for `clientKey`
  * **keyBitsize** - if `clientKey` is undefined, bit size to use for generating a new key (defaults to 2048)
  * **hash** is a hash function to use (either `md5`, `sha1` or `sha256`, defaults to `sha256`)
  * **country** is a CSR country field
  * **state** is a CSR state field
  * **locality** is a CSR locality field
  * **organization** is a CSR organization field
  * **organizationUnit** is a CSR organizational unit field
  * **commonName** is a CSR common name field (defaults to `localhost`)
  * **altNames** is a list (`Array`) of subjectAltNames in the subjectAltName field (optional)
  * **emailAddress** is a CSR email address field
  * **csrConfigFile** is a CSR config file

### Create a certificate

Use `createCertificate` for creating private keys

    pem.createCertificate(options, callback)

Where

  * **options** is an optional options object
  * **callback** is a callback function with an error object and `{certificate, csr, clientKey, serviceKey}`

Possible options include all the options for `createCSR` - in case `csr` parameter is not defined and a new
CSR needs to be generated.

In addition, possible options are the following

  * **serviceKey** is a private key for signing the certificate, if not defined a new one is generated
  * **serviceKeyPassword** Password of the service key
  * **serviceCertificate** is the optional certificate for the `serviceKey`
  * **serial** is the unique serial number for the signed certificate, required if `serviceCertificate` is defined
  * **selfSigned** - if set to true and `serviceKey` is not defined, use `clientKey` for signing
  * **csr** is a CSR for the certificate, if not defined a new one is generated
  * **days** is the certificate expire time in days
  * **extFile** extension config file - **without** `-extensions v3_req`
  * **config** extension config file - **with** `-extensions v3_req`

### Export a public key

Use `getPublicKey` for exporting a public key from a private key, CSR or certificate

    pem.getPublicKey(certificate, callback)

Where

  * **certificate** is a PEM encoded private key, CSR or certificate
  * **callback** is a callback function with an error object and `{publicKey}`

### Read certificate info

Use `readCertificateInfo` for reading subject data from a certificate or a CSR

    pem.readCertificateInfo(certificate, callback)

Where

  * **certificate** is a PEM encoded CSR or a certificate
  * **callback** is a callback function with an error object and `{serial, country, state, locality, organization, organizationUnit, commonName, emailAddress, validity{start, end}, san{dns, ip, email}?, issuer{country, state, locality, organization, organizationUnit}, signatureAlgorithm, publicKeyAlgorithm, publicKeySize }`

? *san* is only present if the CSR or certificate has SAN entries.

*signatureAlgorithm, publicKeyAlgorithm and publicKeySize* only available if supportet and can parsed form openssl output

### Get fingerprint

Use `getFingerprint` to get the default SHA1 fingerprint for a certificate

    pem.getFingerprint(certificate, [hash], callback)

Where

  * **certificate** is a PEM encoded certificate
  * **hash** is a hash function to use (either `md5`, `sha1` or `sha256`, defaults to `sha1`)
  * **callback** is a callback function with an error object and `{fingerprint}`

### Get modulus

Use `getModulus` to get the modulus for a certificate, a CSR or a private key. Modulus can be useful to check that a Private Key Matches a Certificate

    pem.getModulus(certificate, [password], [hash], callback)

Where

  * **certificate** is a PEM encoded certificate, CSR or private key
  * **password** is an optional passphrase for passpharse protected certificates
  * **hash** is an optional hash function to use (up to now `md5` supported) (default: none)
  * **callback** is a callback function with an error object and `{modulus}`

### Get DH parameter information

Use `getDhparamInfo` to get the size and prime of DH parameters.

    pem.getDhparamInfo(dhparam, callback)

Where

  * **dhparam** is a PEM encoded DH parameters string
  * **callback** is a callback function with an error object and `{size, prime}`


### Export to a PKCS12 keystore

Use `createPkcs12` to export a certificate, the private key and optionally any signing or intermediate CA certificates to a PKCS12 keystore.

	pem.createPkcs12(clientKey, certificate, p12Password, [options], callback)

Where

* **clientKey** is a PEM encoded private key
* **certificate** is a PEM encoded certificate
* **p12Password** is the password of the exported keystore
* **options** is an optional options object with `cipher`, (one of "aes128", "aes192", "aes256", "camellia128", "camellia192", "camellia256", "des", "des3" or "idea"), `clientKeyPassword` and `certFiles` (an array of additional certificates to include - e.g. CA certificates)
* **callback** is a callback function with an error object and `{pkcs12}` (binary)

### Read a PKCS12 keystore

Use `readPkcs12` to read a certificate, private key and CA certificates from a PKCS12 keystore.

	pem.readPkcs12(bufferOrPath, [options], callback)

Where

* **bufferOrPath** is a PKCS12 keystore as a [Buffer](https://nodejs.org/api/buffer.html) or the path to a file
* **options** is an optional options object with `clientKeyPassword` which will be used to encrypt the stored key and `p12Password` which will be used to open the keystore
* **callback** is a callback function with an error object and `{key: String, cert: String, ca: Array}`

### Check a PKCS12 keystore

Use `checkPkcs12` to check a PKCS12 keystore.

	pem.checkPkcs12(bufferOrPath, [passphrase], callback)

Where

* **bufferOrPath** is a PKCS12 keystore as a [Buffer](https://nodejs.org/api/buffer.html) or the path to a file
* **passphrase** is an optional passphrase which will be used to open the keystore
* **callback** is a callback function with an error object and a boolean as arguments

###Verify a certificate signing chain

Use `verifySigningChain` to assert that a given certificate has a valid signing chain.

    pem.verifySigningChain(certificate, ca, callback)

Where

* **certificate** is a PEM encoded certificate string
* **ca** is a PEM encoded CA certificate string or an array of certificate strings
* **callback** is a callback function with an error object and a boolean as arguments

###Check a certificate file

Use `checkCertificate` to check / verify consistency of a certificate.

    pem.checkCertificate(certificate, callback)

Where

* **certificate** is a PEM encoded certificate string
* **callback** is a callback function with an error object and a boolean as arguments
-->

### Custom extensions config file

You can specify custom OpenSSL extensions using the `config` or `extFile` options for `createCertificate` (or using `csrConfigFile` with `createCSR`).

`extFile` and `csrConfigFile` should be paths to the extension files. While `config` will generate a temporary file from the supplied file contents.

If you specify `config` then the `v3_req` section of your config file will be used.

The following would be an example of a Certificate Authority extensions file:

    [req]
    req_extensions = v3_req
    distinguished_name = req_distinguished_name

    [req_distinguished_name]
    commonName = Common Name
    commonName_max = 64

    [v3_req]
    basicConstraints = critical,CA:TRUE

While the following would specify subjectAltNames in the resulting certificate:

    [req]
    req_extensions = v3_req

    [ v3_req ]
    basicConstraints = CA:FALSE
    keyUsage = nonRepudiation, digitalSignature, keyEncipherment
    subjectAltName = @alt_names

    [alt_names]
    DNS.1 = host1.example.com
    DNS.2 = host2.example.com
    DNS.3 = host3.example.com

Note that `createCertificate` and `createCSR` supports the `altNames` option which would be easier to use in most cases.

:warning: **Warning: If you specify `altNames` the custom extensions file will not be passed to OpenSSL.**

### Setting openssl location

In some systems the `openssl` executable might not be available by the default name or it is not included in $PATH. In this case you can define the location of the executable yourself as a one time action after you have loaded the pem module:

```javascript
var pem = require('pem')
pem.config({
  pathOpenSSL: '/usr/local/bin/openssl'
})
// do something with the pem module
```

### :warning: CSR/Certificates with special chars
For more details, search in `test/pem.spec.js`: `Create CSR with specialchars config file`

If you use special chars like:

```
-!$%^&*()_+|~=`{}[]:/;<>?,.@#
```

You should know that the result mey have escaped characters when you read it in your application.
Will try to fix this in the future, but not sure.


### Special thanks to

- Andris Reinman (@andris9) - Initiator of pem

## License

**MIT**
#!/usr/bin/env node
"use strict";
/**
 * @license
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const Protobuf = require("@postman/protobufjs");
const yargs = require("yargs");
const camelCase = require("lodash.camelcase");
const util_1 = require("../src/util");
const templateStr = "%s";
const useNameFmter = ({ outputTemplate, inputTemplate }) => {
    if (outputTemplate === inputTemplate) {
        throw new Error('inputTemplate and outputTemplate must differ');
    }
    return {
        outputName: (n) => outputTemplate.replace(templateStr, n),
        inputName: (n) => inputTemplate.replace(templateStr, n)
    };
};
class TextFormatter {
    constructor() {
        this.indentText = '  ';
        this.indentValue = 0;
        this.textParts = [];
    }
    indent() {
        this.indentValue += 1;
    }
    unindent() {
        this.indentValue -= 1;
    }
    writeLine(line) {
        for (let i = 0; i < this.indentValue; i += 1) {
            this.textParts.push(this.indentText);
        }
        this.textParts.push(line);
        this.textParts.push('\n');
    }
    getFullText() {
        return this.textParts.join('');
    }
}
// GENERATOR UTILITY FUNCTIONS
function compareName(x, y) {
    if (x.name < y.name) {
        return -1;
    }
    else if (x.name > y.name) {
        return 1;
    }
    else {
        return 0;
    }
}
function isNamespaceBase(obj) {
    return Array.isArray(obj.nestedArray);
}
function stripLeadingPeriod(name) {
    return name.startsWith('.') ? name.substring(1) : name;
}
function getImportPath(to) {
    /* If the thing we are importing is defined in a message, it is generated in
     * the same file as that message. */
    if (to.parent instanceof Protobuf.Type) {
        return getImportPath(to.parent);
    }
    return stripLeadingPeriod(to.fullName).replace(/\./g, '/');
}
function getPath(to) {
    return stripLeadingPeriod(to.fullName).replace(/\./g, '/') + '.ts';
}
function getPathToRoot(from) {
    const depth = stripLeadingPeriod(from.fullName).split('.').length - 1;
    if (depth === 0) {
        return './';
    }
    let path = '';
    for (let i = 0; i < depth; i++) {
        path += '../';
    }
    return path;
}
function getRelativeImportPath(from, to) {
    return getPathToRoot(from) + getImportPath(to);
}
function getTypeInterfaceName(type) {
    return type.fullName.replace(/\./g, '_');
}
function getImportLine(dependency, from, options) {
    const filePath = from === undefined ? './' + getImportPath(dependency) : getRelativeImportPath(from, dependency);
    const { outputName, inputName } = useNameFmter(options);
    const typeInterfaceName = getTypeInterfaceName(dependency);
    let importedTypes;
    /* If the dependency is defined within a message, it will be generated in that
     * message's file and exported using its typeInterfaceName. */
    if (dependency.parent instanceof Protobuf.Type) {
        if (dependency instanceof Protobuf.Type || dependency instanceof Protobuf.Enum) {
            importedTypes = `${inputName(typeInterfaceName)}, ${outputName(typeInterfaceName)}`;
        }
        else if (dependency instanceof Protobuf.Service) {
            importedTypes = `${typeInterfaceName}Client, ${typeInterfaceName}Definition`;
        }
        else {
            throw new Error('Invalid object passed to getImportLine');
        }
    }
    else {
        if (dependency instanceof Protobuf.Type || dependency instanceof Protobuf.Enum) {
            importedTypes = `${inputName(dependency.name)} as ${inputName(typeInterfaceName)}, ${outputName(dependency.name)} as ${outputName(typeInterfaceName)}`;
        }
        else if (dependency instanceof Protobuf.Service) {
            importedTypes = `${dependency.name}Client as ${typeInterfaceName}Client, ${dependency.name}Definition as ${typeInterfaceName}Definition`;
        }
        else {
            throw new Error('Invalid object passed to getImportLine');
        }
    }
    return `import type { ${importedTypes} } from '${filePath}';`;
}
function getChildMessagesAndEnums(namespace) {
    const messageList = [];
    for (const nested of namespace.nestedArray) {
        if (nested instanceof Protobuf.Type || nested instanceof Protobuf.Enum) {
            messageList.push(nested);
        }
        if (isNamespaceBase(nested)) {
            messageList.push(...getChildMessagesAndEnums(nested));
        }
    }
    return messageList;
}
function formatComment(formatter, comment, options) {
    if (!comment && !(options === null || options === void 0 ? void 0 : options.deprecated)) {
        return;
    }
    formatter.writeLine('/**');
    if (comment) {
        for (const line of comment.split('\n')) {
            formatter.writeLine(` * ${line.replace(/\*\//g, '* /')}`);
        }
    }
    if (options === null || options === void 0 ? void 0 : options.deprecated) {
        formatter.writeLine(' * @deprecated');
    }
    formatter.writeLine(' */');
}
const typeBrandHint = `This field is a type brand and is not populated at runtime. Instances of this type should be created using type assertions.
https://github.com/grpc/grpc-node/pull/2281`;
function formatTypeBrand(formatter, messageType) {
    formatComment(formatter, typeBrandHint);
    formatter.writeLine(`__type: '${messageType.fullName}'`);
}
// GENERATOR FUNCTIONS
function getTypeNamePermissive(fieldType, resolvedType, repeated, map, options) {
    const { inputName } = useNameFmter(options);
    switch (fieldType) {
        case 'double':
        case 'float':
            return 'number | string';
        case 'int32':
        case 'uint32':
        case 'sint32':
        case 'fixed32':
        case 'sfixed32':
            return 'number';
        case 'int64':
        case 'uint64':
        case 'sint64':
        case 'fixed64':
        case 'sfixed64':
            return 'number | string | Long';
        case 'bool':
            return 'boolean';
        case 'string':
            return 'string';
        case 'bytes':
            return 'Buffer | Uint8Array | string';
        default:
            if (resolvedType === null) {
                throw new Error('Found field with no usable type');
            }
            const typeInterfaceName = getTypeInterfaceName(resolvedType);
            if (resolvedType instanceof Protobuf.Type) {
                if (repeated || map) {
                    return inputName(typeInterfaceName);
                }
                else {
                    return `${inputName(typeInterfaceName)} | null`;
                }
            }
            else {
                // Enum
                return inputName(typeInterfaceName);
            }
    }
}
function getFieldTypePermissive(field, options) {
    const valueType = getTypeNamePermissive(field.type, field.resolvedType, field.repeated, field.map, options);
    if (field instanceof Protobuf.MapField) {
        const keyType = field.keyType === 'string' ? 'string' : 'number';
        return `{[key: ${keyType}]: ${valueType}}`;
    }
    else {
        return valueType;
    }
}
function generatePermissiveMessageInterface(formatter, messageType, options, nameOverride) {
    const { inputName } = useNameFmter(options);
    if (options.includeComments) {
        formatComment(formatter, messageType.comment, messageType.options);
    }
    if (messageType.fullName === '.google.protobuf.Any') {
        /* This describes the behavior of the Protobuf.js Any wrapper fromObject
         * replacement function */
        formatter.writeLine(`export type ${inputName('Any')} = AnyExtension | {`);
        formatter.writeLine('  type_url: string;');
        formatter.writeLine('  value: Buffer | Uint8Array | string;');
        formatter.writeLine('}');
        return;
    }
    formatter.writeLine(`export interface ${inputName(nameOverride !== null && nameOverride !== void 0 ? nameOverride : messageType.name)} {`);
    formatter.indent();
    for (const field of messageType.fieldsArray) {
        const repeatedString = field.repeated ? '[]' : '';
        const type = getFieldTypePermissive(field, options);
        if (options.includeComments) {
            formatComment(formatter, field.comment, field.options);
        }
        formatter.writeLine(`'${field.name}'?: (${type})${repeatedString};`);
    }
    for (const oneof of messageType.oneofsArray) {
        const typeString = oneof.fieldsArray.map(field => `"${field.name}"`).join('|');
        if (options.includeComments) {
            formatComment(formatter, oneof.comment, oneof.options);
        }
        formatter.writeLine(`'${oneof.name}'?: ${typeString};`);
    }
    if (options.inputBranded) {
        formatTypeBrand(formatter, messageType);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function getTypeNameRestricted(fieldType, resolvedType, repeated, map, options) {
    const { outputName } = useNameFmter(options);
    switch (fieldType) {
        case 'double':
        case 'float':
            if (options.json) {
                return 'number | string';
            }
            else {
                return 'number';
            }
        case 'int32':
        case 'uint32':
        case 'sint32':
        case 'fixed32':
        case 'sfixed32':
            return 'number';
        case 'int64':
        case 'uint64':
        case 'sint64':
        case 'fixed64':
        case 'sfixed64':
            if (options.longs === Number) {
                return 'number';
            }
            else if (options.longs === String) {
                return 'string';
            }
            else {
                return 'Long';
            }
        case 'bool':
            return 'boolean';
        case 'string':
            return 'string';
        case 'bytes':
            if (options.bytes === Array) {
                return 'Uint8Array';
            }
            else if (options.bytes === String) {
                return 'string';
            }
            else {
                return 'Buffer';
            }
        default:
            if (resolvedType === null) {
                throw new Error('Found field with no usable type');
            }
            const typeInterfaceName = getTypeInterfaceName(resolvedType);
            if (resolvedType instanceof Protobuf.Type) {
                /* null is only used to represent absent message values if the defaults
                 * option is set, and only for non-repeated, non-map fields. */
                if (options.defaults && !repeated && !map) {
                    return `${outputName(typeInterfaceName)} | null`;
                }
                else {
                    return `${outputName(typeInterfaceName)}`;
                }
            }
            else {
                // Enum
                return outputName(typeInterfaceName);
            }
    }
}
function getFieldTypeRestricted(field, options) {
    const valueType = getTypeNameRestricted(field.type, field.resolvedType, field.repeated, field.map, options);
    if (field instanceof Protobuf.MapField) {
        const keyType = field.keyType === 'string' ? 'string' : 'number';
        return `{[key: ${keyType}]: ${valueType}}`;
    }
    else {
        return valueType;
    }
}
function generateRestrictedMessageInterface(formatter, messageType, options, nameOverride) {
    var _a, _b, _c;
    const { outputName } = useNameFmter(options);
    if (options.includeComments) {
        formatComment(formatter, messageType.comment, messageType.options);
    }
    if (messageType.fullName === '.google.protobuf.Any' && options.json) {
        /* This describes the behavior of the Protobuf.js Any wrapper toObject
         * replacement function */
        let optionalString = options.defaults ? '' : '?';
        formatter.writeLine(`export type ${outputName('Any')} = AnyExtension | {`);
        formatter.writeLine(`  type_url${optionalString}: string;`);
        formatter.writeLine(`  value${optionalString}: ${getTypeNameRestricted('bytes', null, false, false, options)};`);
        formatter.writeLine('}');
        return;
    }
    formatter.writeLine(`export interface ${outputName(nameOverride !== null && nameOverride !== void 0 ? nameOverride : messageType.name)} {`);
    formatter.indent();
    for (const field of messageType.fieldsArray) {
        let fieldGuaranteed;
        if (field.partOf) {
            // The field is not guaranteed populated if it is part of a oneof
            fieldGuaranteed = false;
        }
        else if (field.repeated) {
            fieldGuaranteed = (_a = (options.defaults || options.arrays)) !== null && _a !== void 0 ? _a : false;
        }
        else if (field.map) {
            fieldGuaranteed = (_b = (options.defaults || options.objects)) !== null && _b !== void 0 ? _b : false;
        }
        else {
            fieldGuaranteed = (_c = options.defaults) !== null && _c !== void 0 ? _c : false;
        }
        const optionalString = fieldGuaranteed ? '' : '?';
        const repeatedString = field.repeated ? '[]' : '';
        const type = getFieldTypeRestricted(field, options);
        if (options.includeComments) {
            formatComment(formatter, field.comment, field.options);
        }
        formatter.writeLine(`'${field.name}'${optionalString}: (${type})${repeatedString};`);
    }
    if (options.oneofs) {
        for (const oneof of messageType.oneofsArray) {
            const typeString = oneof.fieldsArray.map(field => `"${field.name}"`).join('|');
            if (options.includeComments) {
                formatComment(formatter, oneof.comment, oneof.options);
            }
            formatter.writeLine(`'${oneof.name}': ${typeString};`);
        }
    }
    if (options.outputBranded) {
        formatTypeBrand(formatter, messageType);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateMessageInterfaces(formatter, messageType, options) {
    var _a, _b;
    let usesLong = false;
    let seenDeps = new Set();
    const childTypes = getChildMessagesAndEnums(messageType);
    formatter.writeLine(`// Original file: ${(_b = ((_a = messageType.filename) !== null && _a !== void 0 ? _a : 'null')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/')}`);
    formatter.writeLine('');
    const isLongField = (field) => ['int64', 'uint64', 'sint64', 'fixed64', 'sfixed64'].includes(field.type);
    messageType.fieldsArray.sort((fieldA, fieldB) => fieldA.id - fieldB.id);
    for (const field of messageType.fieldsArray) {
        if (field.resolvedType && childTypes.indexOf(field.resolvedType) < 0) {
            const dependency = field.resolvedType;
            if (seenDeps.has(dependency.fullName)) {
                continue;
            }
            seenDeps.add(dependency.fullName);
            formatter.writeLine(getImportLine(dependency, messageType, options));
        }
        if (isLongField(field)) {
            usesLong = true;
        }
    }
    for (const childType of childTypes) {
        if (childType instanceof Protobuf.Type) {
            for (const field of childType.fieldsArray) {
                if (field.resolvedType && childTypes.indexOf(field.resolvedType) < 0) {
                    const dependency = field.resolvedType;
                    if (seenDeps.has(dependency.fullName)) {
                        continue;
                    }
                    seenDeps.add(dependency.fullName);
                    formatter.writeLine(getImportLine(dependency, messageType, options));
                }
                if (isLongField(field)) {
                    usesLong = true;
                }
            }
        }
    }
    if (usesLong) {
        formatter.writeLine("import type { Long } from '@postman/proto-loader';");
    }
    if (messageType.fullName === '.google.protobuf.Any') {
        formatter.writeLine("import type { AnyExtension } from '@postman/proto-loader';");
    }
    formatter.writeLine('');
    for (const childType of childTypes.sort(compareName)) {
        const nameOverride = getTypeInterfaceName(childType);
        if (childType instanceof Protobuf.Type) {
            generatePermissiveMessageInterface(formatter, childType, options, nameOverride);
            formatter.writeLine('');
            generateRestrictedMessageInterface(formatter, childType, options, nameOverride);
        }
        else {
            generateEnumInterface(formatter, childType, options, nameOverride);
        }
        formatter.writeLine('');
    }
    generatePermissiveMessageInterface(formatter, messageType, options);
    formatter.writeLine('');
    generateRestrictedMessageInterface(formatter, messageType, options);
}
function generateEnumInterface(formatter, enumType, options, nameOverride) {
    var _a, _b, _c;
    const { inputName, outputName } = useNameFmter(options);
    const name = nameOverride !== null && nameOverride !== void 0 ? nameOverride : enumType.name;
    formatter.writeLine(`// Original file: ${(_b = ((_a = enumType.filename) !== null && _a !== void 0 ? _a : 'null')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/')}`);
    formatter.writeLine('');
    if (options.includeComments) {
        formatComment(formatter, enumType.comment, enumType.options);
    }
    formatter.writeLine(`export const ${name} = {`);
    formatter.indent();
    for (const key of Object.keys(enumType.values)) {
        if (options.includeComments) {
            formatComment(formatter, enumType.comments[key], ((_c = enumType.valuesOptions) !== null && _c !== void 0 ? _c : {})[key]);
        }
        formatter.writeLine(`${key}: ${options.enums == String ? `'${key}'` : enumType.values[key]},`);
    }
    formatter.unindent();
    formatter.writeLine('} as const;');
    // Permissive Type
    formatter.writeLine('');
    if (options.includeComments) {
        formatComment(formatter, enumType.comment, enumType.options);
    }
    formatter.writeLine(`export type ${inputName(name)} =`);
    formatter.indent();
    for (const key of Object.keys(enumType.values)) {
        if (options.includeComments) {
            formatComment(formatter, enumType.comments[key]);
        }
        formatter.writeLine(`| '${key}'`);
        formatter.writeLine(`| ${enumType.values[key]}`);
    }
    formatter.unindent();
    // Restrictive Type
    formatter.writeLine('');
    if (options.includeComments) {
        formatComment(formatter, enumType.comment, enumType.options);
    }
    formatter.writeLine(`export type ${outputName(name)} = typeof ${name}[keyof typeof ${name}]`);
}
/**
 * This is a list of methods that are exist in the generic Client class in the
 * gRPC libraries. TypeScript has a problem with methods in subclasses with the
 * same names as methods in the superclass, but with mismatched APIs. So, we
 * avoid generating methods with these names in the service client interfaces.
 * We always generate two service client methods per service method: one camel
 * cased, and one with the original casing. So we will still generate one
 * service client method for any conflicting name.
 *
 * Technically, at runtime conflicting name in the service client method
 * actually shadows the original method, but TypeScript does not have a good
 * way to represent that. So this change is not 100% accurate, but it gets the
 * generated code to compile.
 *
 * This is just a list of the methods in the Client class definitions in
 * grpc@1.24.11 and @grpc/grpc-js@1.4.0.
 */
const CLIENT_RESERVED_METHOD_NAMES = new Set([
    'close',
    'getChannel',
    'waitForReady',
    'makeUnaryRequest',
    'makeClientStreamRequest',
    'makeServerStreamRequest',
    'makeBidiStreamRequest',
    'resolveCallInterceptors',
    /* These methods are private, but TypeScript is not happy with overriding even
     * private methods with mismatched APIs. */
    'checkOptionalUnaryResponseArguments',
    'checkMetadataAndOptions'
]);
function generateServiceClientInterface(formatter, serviceType, options) {
    const { outputName, inputName } = useNameFmter(options);
    if (options.includeComments) {
        formatComment(formatter, serviceType.comment, serviceType.options);
    }
    formatter.writeLine(`export interface ${serviceType.name}Client extends grpc.Client {`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) {
        const method = serviceType.methods[methodName];
        for (const name of new Set([methodName, camelCase(methodName)])) {
            if (CLIENT_RESERVED_METHOD_NAMES.has(name)) {
                continue;
            }
            if (options.includeComments) {
                formatComment(formatter, method.comment, method.options);
            }
            const requestType = inputName(getTypeInterfaceName(method.resolvedRequestType));
            const responseType = outputName(getTypeInterfaceName(method.resolvedResponseType));
            const callbackType = `grpc.requestCallback<${responseType}>`;
            if (method.requestStream) {
                if (method.responseStream) {
                    // Bidi streaming
                    const callType = `grpc.ClientDuplexStream<${requestType}, ${responseType}>`;
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, options?: grpc.CallOptions): ${callType};`);
                    formatter.writeLine(`${name}(options?: grpc.CallOptions): ${callType};`);
                }
                else {
                    // Client streaming
                    const callType = `grpc.ClientWritableStream<${requestType}>`;
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(metadata: grpc.Metadata, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(callback: ${callbackType}): ${callType};`);
                }
            }
            else {
                if (method.responseStream) {
                    // Server streaming
                    const callType = `grpc.ClientReadableStream<${responseType}>`;
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, options?: grpc.CallOptions): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, options?: grpc.CallOptions): ${callType};`);
                }
                else {
                    // Unary
                    const callType = 'grpc.ClientUnaryCall';
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, metadata: grpc.Metadata, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, options: grpc.CallOptions, callback: ${callbackType}): ${callType};`);
                    formatter.writeLine(`${name}(argument: ${requestType}, callback: ${callbackType}): ${callType};`);
                }
            }
        }
        formatter.writeLine('');
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceHandlerInterface(formatter, serviceType, options) {
    const { inputName, outputName } = useNameFmter(options);
    if (options.includeComments) {
        formatComment(formatter, serviceType.comment, serviceType.options);
    }
    formatter.writeLine(`export interface ${serviceType.name}Handlers extends grpc.UntypedServiceImplementation {`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) {
        const method = serviceType.methods[methodName];
        if (options.includeComments) {
            formatComment(formatter, method.comment, serviceType.options);
        }
        const requestType = outputName(getTypeInterfaceName(method.resolvedRequestType));
        const responseType = inputName(getTypeInterfaceName(method.resolvedResponseType));
        if (method.requestStream) {
            if (method.responseStream) {
                // Bidi streaming
                formatter.writeLine(`${methodName}: grpc.handleBidiStreamingCall<${requestType}, ${responseType}>;`);
            }
            else {
                // Client streaming
                formatter.writeLine(`${methodName}: grpc.handleClientStreamingCall<${requestType}, ${responseType}>;`);
            }
        }
        else {
            if (method.responseStream) {
                // Server streaming
                formatter.writeLine(`${methodName}: grpc.handleServerStreamingCall<${requestType}, ${responseType}>;`);
            }
            else {
                // Unary
                formatter.writeLine(`${methodName}: grpc.handleUnaryCall<${requestType}, ${responseType}>;`);
            }
        }
        formatter.writeLine('');
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceDefinitionInterface(formatter, serviceType, options) {
    const { inputName, outputName } = useNameFmter(options);
    if (options.grpcLib) {
        formatter.writeLine(`export interface ${serviceType.name}Definition extends grpc.ServiceDefinition {`);
    }
    else {
        formatter.writeLine(`export interface ${serviceType.name}Definition {`);
    }
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) {
        const method = serviceType.methods[methodName];
        const requestType = getTypeInterfaceName(method.resolvedRequestType);
        const responseType = getTypeInterfaceName(method.resolvedResponseType);
        formatter.writeLine(`${methodName}: MethodDefinition<${inputName(requestType)}, ${inputName(responseType)}, ${outputName(requestType)}, ${outputName(responseType)}>`);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceInterfaces(formatter, serviceType, options) {
    var _a, _b;
    formatter.writeLine(`// Original file: ${(_b = ((_a = serviceType.filename) !== null && _a !== void 0 ? _a : 'null')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/')}`);
    formatter.writeLine('');
    if (options.grpcLib) {
        const grpcImportPath = options.grpcLib.startsWith('.') ? getPathToRoot(serviceType) + options.grpcLib : options.grpcLib;
        formatter.writeLine(`import type * as grpc from '${grpcImportPath}'`);
    }
    formatter.writeLine(`import type { MethodDefinition } from '@postman/proto-loader'`);
    const dependencies = new Set();
    for (const method of serviceType.methodsArray) {
        dependencies.add(method.resolvedRequestType);
        dependencies.add(method.resolvedResponseType);
    }
    for (const dep of Array.from(dependencies.values()).sort(compareName)) {
        formatter.writeLine(getImportLine(dep, serviceType, options));
    }
    formatter.writeLine('');
    if (options.grpcLib) {
        generateServiceClientInterface(formatter, serviceType, options);
        formatter.writeLine('');
        generateServiceHandlerInterface(formatter, serviceType, options);
        formatter.writeLine('');
    }
    generateServiceDefinitionInterface(formatter, serviceType, options);
}
function containsDefinition(definitionType, namespace) {
    for (const nested of namespace.nestedArray.sort(compareName)) {
        if (nested instanceof definitionType) {
            return true;
        }
        else if (isNamespaceBase(nested) && !(nested instanceof Protobuf.Type) && !(nested instanceof Protobuf.Enum) && containsDefinition(definitionType, nested)) {
            return true;
        }
    }
    return false;
}
function generateDefinitionImports(formatter, namespace, options) {
    const imports = [];
    if (containsDefinition(Protobuf.Enum, namespace)) {
        imports.push('EnumTypeDefinition');
    }
    if (containsDefinition(Protobuf.Type, namespace)) {
        imports.push('MessageTypeDefinition');
    }
    if (imports.length) {
        formatter.writeLine(`import type { ${imports.join(', ')} } from '@postman/proto-loader';`);
    }
}
function generateServiceImports(formatter, namespace, options) {
    for (const nested of namespace.nestedArray.sort(compareName)) {
        if (nested instanceof Protobuf.Service) {
            formatter.writeLine(getImportLine(nested, undefined, options));
        }
        else if (isNamespaceBase(nested) && !(nested instanceof Protobuf.Type) && !(nested instanceof Protobuf.Enum)) {
            generateServiceImports(formatter, nested, options);
        }
    }
}
function generateSingleLoadedDefinitionType(formatter, nested, options) {
    if (nested instanceof Protobuf.Service) {
        if (options.includeComments) {
            formatComment(formatter, nested.comment, nested.options);
        }
        const typeInterfaceName = getTypeInterfaceName(nested);
        formatter.writeLine(`${nested.name}: SubtypeConstructor<typeof grpc.Client, ${typeInterfaceName}Client> & { service: ${typeInterfaceName}Definition }`);
    }
    else if (nested instanceof Protobuf.Enum) {
        formatter.writeLine(`${nested.name}: EnumTypeDefinition`);
    }
    else if (nested instanceof Protobuf.Type) {
        formatter.writeLine(`${nested.name}: MessageTypeDefinition`);
    }
    else if (isNamespaceBase(nested)) {
        generateLoadedDefinitionTypes(formatter, nested, options);
    }
}
function generateLoadedDefinitionTypes(formatter, namespace, options) {
    formatter.writeLine(`${namespace.name}: {`);
    formatter.indent();
    for (const nested of namespace.nestedArray.sort(compareName)) {
        generateSingleLoadedDefinitionType(formatter, nested, options);
    }
    formatter.unindent();
    formatter.writeLine('}');
}
function generateRootFile(formatter, root, options) {
    if (!options.grpcLib) {
        return;
    }
    formatter.writeLine(`import type * as grpc from '${options.grpcLib}';`);
    generateDefinitionImports(formatter, root, options);
    formatter.writeLine('');
    generateServiceImports(formatter, root, options);
    formatter.writeLine('');
    formatter.writeLine('type SubtypeConstructor<Constructor extends new (...args: any) => any, Subtype> = {');
    formatter.writeLine('  new(...args: ConstructorParameters<Constructor>): Subtype;');
    formatter.writeLine('};');
    formatter.writeLine('');
    formatter.writeLine('export interface ProtoGrpcType {');
    formatter.indent();
    for (const nested of root.nestedArray) {
        generateSingleLoadedDefinitionType(formatter, nested, options);
    }
    formatter.unindent();
    formatter.writeLine('}');
    formatter.writeLine('');
}
async function writeFile(filename, contents) {
    await fs.promises.mkdir(path.dirname(filename), { recursive: true });
    return fs.promises.writeFile(filename, contents);
}
function generateFilesForNamespace(namespace, options) {
    const filePromises = [];
    for (const nested of namespace.nestedArray) {
        const fileFormatter = new TextFormatter();
        if (nested instanceof Protobuf.Type) {
            generateMessageInterfaces(fileFormatter, nested, options);
            if (options.verbose) {
                console.log(`Writing ${options.outDir}/${getPath(nested)} from file ${nested.filename}`);
            }
            filePromises.push(writeFile(`${options.outDir}/${getPath(nested)}`, fileFormatter.getFullText()));
        }
        else if (nested instanceof Protobuf.Enum) {
            generateEnumInterface(fileFormatter, nested, options);
            if (options.verbose) {
                console.log(`Writing ${options.outDir}/${getPath(nested)} from file ${nested.filename}`);
            }
            filePromises.push(writeFile(`${options.outDir}/${getPath(nested)}`, fileFormatter.getFullText()));
        }
        else if (nested instanceof Protobuf.Service) {
            generateServiceInterfaces(fileFormatter, nested, options);
            if (options.verbose) {
                console.log(`Writing ${options.outDir}/${getPath(nested)} from file ${nested.filename}`);
            }
            filePromises.push(writeFile(`${options.outDir}/${getPath(nested)}`, fileFormatter.getFullText()));
        }
        else if (isNamespaceBase(nested)) {
            filePromises.push(...generateFilesForNamespace(nested, options));
        }
    }
    return filePromises;
}
function writeFilesForRoot(root, masterFileName, options) {
    const filePromises = [];
    const masterFileFormatter = new TextFormatter();
    if (options.grpcLib) {
        generateRootFile(masterFileFormatter, root, options);
        if (options.verbose) {
            console.log(`Writing ${options.outDir}/${masterFileName}`);
        }
        filePromises.push(writeFile(`${options.outDir}/${masterFileName}`, masterFileFormatter.getFullText()));
    }
    filePromises.push(...generateFilesForNamespace(root, options));
    return filePromises;
}
async function writeAllFiles(protoFiles, options) {
    await fs.promises.mkdir(options.outDir, { recursive: true });
    const basenameMap = new Map();
    for (const filename of protoFiles) {
        const basename = path.basename(filename).replace(/\.proto$/, '.ts');
        if (basenameMap.has(basename)) {
            basenameMap.get(basename).push(filename);
        }
        else {
            basenameMap.set(basename, [filename]);
        }
    }
    for (const [basename, filenames] of basenameMap.entries()) {
        const loadedRoot = await (0, util_1.loadProtosWithOptions)(filenames, options);
        writeFilesForRoot(loadedRoot, basename, options);
    }
}
async function runScript() {
    const boolDefaultFalseOption = {
        boolean: true,
        default: false,
    };
    const argv = await yargs
        .parserConfiguration({
        'parse-positional-numbers': false
    })
        .option('keepCase', boolDefaultFalseOption)
        .option('longs', { string: true, default: 'Long' })
        .option('enums', { string: true, default: 'number' })
        .option('bytes', { string: true, default: 'Buffer' })
        .option('defaults', boolDefaultFalseOption)
        .option('arrays', boolDefaultFalseOption)
        .option('objects', boolDefaultFalseOption)
        .option('oneofs', boolDefaultFalseOption)
        .option('json', boolDefaultFalseOption)
        .boolean('verbose')
        .option('includeComments', boolDefaultFalseOption)
        .option('includeDirs', {
        normalize: true,
        array: true,
        alias: 'I'
    })
        .option('outDir', {
        alias: 'O',
        normalize: true,
    })
        .option('grpcLib', { string: true })
        .option('inputTemplate', { string: true, default: `${templateStr}` })
        .option('outputTemplate', { string: true, default: `${templateStr}__Output` })
        .option('inputBranded', boolDefaultFalseOption)
        .option('outputBranded', boolDefaultFalseOption)
        .coerce('longs', value => {
        switch (value) {
            case 'String': return String;
            case 'Number': return Number;
            default: return undefined;
        }
    }).coerce('enums', value => {
        if (value === 'String') {
            return String;
        }
        else {
            return undefined;
        }
    }).coerce('bytes', value => {
        switch (value) {
            case 'Array': return Array;
            case 'String': return String;
            default: return undefined;
        }
    })
        .alias({
        verbose: 'v'
    }).describe({
        keepCase: 'Preserve the case of field names',
        longs: 'The type that should be used to output 64 bit integer values. Can be String, Number',
        enums: 'The type that should be used to output enum fields. Can be String',
        bytes: 'The type that should be used to output bytes fields. Can be String, Array',
        defaults: 'Output default values for omitted fields',
        arrays: 'Output default values for omitted repeated fields even if --defaults is not set',
        objects: 'Output default values for omitted message fields even if --defaults is not set',
        oneofs: 'Output virtual oneof fields set to the present field\'s name',
        json: 'Represent Infinity and NaN as strings in float fields. Also decode google.protobuf.Any automatically',
        includeComments: 'Generate doc comments from comments in the original files',
        includeDirs: 'Directories to search for included files',
        outDir: 'Directory in which to output files',
        grpcLib: 'The gRPC implementation library that these types will be used with. If not provided, some types will not be generated',
        inputTemplate: 'Template for mapping input or "permissive" type names',
        outputTemplate: 'Template for mapping output or "restricted" type names',
        inputBranded: 'Output property for branded type for  "permissive" types with fullName of the Message as its value',
        outputBranded: 'Output property for branded type for  "restricted" types with fullName of the Message as its value',
    }).demandOption(['outDir'])
        .demand(1)
        .usage('$0 [options] filenames...')
        .epilogue('WARNING: This tool is in alpha. The CLI and generated code are subject to change')
        .argv;
    if (argv.verbose) {
        console.log('Parsed arguments:', argv);
    }
    (0, util_1.addCommonProtos)();
    writeAllFiles(argv._, Object.assign(Object.assign({}, argv), { alternateCommentMode: true })).then(() => {
        if (argv.verbose) {
            console.log('Success');
        }
    }, (error) => {
        console.error(error);
        process.exit(1);
    });
}
if (require.main === module) {
    runScript();
}
//# sourceMappingURL=proto-loader-gen-types.js.map{"version":3,"file":"proto-loader-gen-types.js","sourceRoot":"","sources":["../../bin/proto-loader-gen-types.ts"],"names":[],"mappings":"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"}/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/// <reference types="node" />
import * as Protobuf from '@postman/protobufjs';
import * as descriptor from '@postman/protobufjs/ext/descriptor';
import { Options } from './util';
import Long = require('long');
export { Options, Long };
/**
 * This type exists for use with code generated by the proto-loader-gen-types
 * tool. This type should be used with another interface, e.g.
 * MessageType & AnyExtension for an object that is converted to or from a
 * google.protobuf.Any message.
 * For example, when processing an Any message:
 *
 * ```ts
 * if (isAnyExtension(message)) {
 *   switch (message['@type']) {
 *     case TYPE1_URL:
 *       handleType1(message as AnyExtension & Type1);
 *       break;
 *     case TYPE2_URL:
 *       handleType2(message as AnyExtension & Type2);
 *       break;
 *     // ...
 *   }
 * }
 * ```
 */
export interface AnyExtension {
    /**
     * The fully qualified name of the message type that this object represents,
     * possibly including a URL prefix.
     */
    '@type': string;
}
export declare function isAnyExtension(obj: object): obj is AnyExtension;
declare module '@postman/protobufjs' {
    interface Type {
        toDescriptor(protoVersion: string): Protobuf.Message<descriptor.IDescriptorProto> & descriptor.IDescriptorProto;
    }
    interface RootConstructor {
        new (options?: Options): Root;
        fromDescriptor(descriptorSet: descriptor.IFileDescriptorSet | Protobuf.Reader | Uint8Array): Root;
        fromJSON(json: Protobuf.INamespace, root?: Root): Root;
    }
    interface Root {
        toDescriptor(protoVersion: string): Protobuf.Message<descriptor.IFileDescriptorSet> & descriptor.IFileDescriptorSet;
    }
    interface Enum {
        toDescriptor(protoVersion: string): Protobuf.Message<descriptor.IEnumDescriptorProto> & descriptor.IEnumDescriptorProto;
    }
}
export interface Serialize<T> {
    (value: T): Buffer;
}
export interface Deserialize<T> {
    (bytes: Buffer): T;
}
export interface ProtobufTypeDefinition {
    format: string;
    type: object;
    fileDescriptorProtos: Buffer[];
}
export interface MessageTypeDefinition extends ProtobufTypeDefinition {
    format: 'Protocol Buffer 3 DescriptorProto';
}
export interface EnumTypeDefinition extends ProtobufTypeDefinition {
    format: 'Protocol Buffer 3 EnumDescriptorProto';
}
export declare enum IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = "IDEMPOTENCY_UNKNOWN",
    NO_SIDE_EFFECTS = "NO_SIDE_EFFECTS",
    IDEMPOTENT = "IDEMPOTENT"
}
export interface NamePart {
    name_part: string;
    is_extension: boolean;
}
export interface UninterpretedOption {
    name?: NamePart[];
    identifier_value?: string;
    positive_int_value?: number;
    negative_int_value?: number;
    double_value?: number;
    string_value?: string;
    aggregate_value?: string;
}
export interface MethodOptions {
    deprecated: boolean;
    idempotency_level: IdempotencyLevel;
    uninterpreted_option: UninterpretedOption[];
    [k: string]: unknown;
}
export interface MethodDefinition<RequestType, ResponseType, OutputRequestType = RequestType, OutputResponseType = ResponseType> {
    path: string;
    requestStream: boolean;
    responseStream: boolean;
    requestSerialize: Serialize<RequestType>;
    responseSerialize: Serialize<ResponseType>;
    requestDeserialize: Deserialize<OutputRequestType>;
    responseDeserialize: Deserialize<OutputResponseType>;
    originalName?: string;
    requestType: MessageTypeDefinition;
    responseType: MessageTypeDefinition;
    options: MethodOptions;
}
export interface ServiceDefinition {
    [index: string]: MethodDefinition<object, object>;
}
export declare type AnyDefinition = ServiceDefinition | MessageTypeDefinition | EnumTypeDefinition;
export interface PackageDefinition {
    [index: string]: AnyDefinition;
}
/**
 * Load a .proto file with the specified options.
 * @param filename One or multiple file paths to load. Can be an absolute path
 *     or relative to an include path.
 * @param options.keepCase Preserve field names. The default is to change them
 *     to camel case.
 * @param options.longs The type that should be used to represent `long` values.
 *     Valid options are `Number` and `String`. Defaults to a `Long` object type
 *     from a library.
 * @param options.enums The type that should be used to represent `enum` values.
 *     The only valid option is `String`. Defaults to the numeric value.
 * @param options.bytes The type that should be used to represent `bytes`
 *     values. Valid options are `Array` and `String`. The default is to use
 *     `Buffer`.
 * @param options.defaults Set default values on output objects. Defaults to
 *     `false`.
 * @param options.arrays Set empty arrays for missing array values even if
 *     `defaults` is `false`. Defaults to `false`.
 * @param options.objects Set empty objects for missing object values even if
 *     `defaults` is `false`. Defaults to `false`.
 * @param options.oneofs Set virtual oneof properties to the present field's
 *     name
 * @param options.json Represent Infinity and NaN as strings in float fields,
 *     and automatically decode google.protobuf.Any values.
 * @param options.includeDirs Paths to search for imported `.proto` files.
 */
export declare function load(filename: string | string[], options?: Options): Promise<PackageDefinition>;
export declare function loadSync(filename: string | string[], options?: Options): PackageDefinition;
export declare function fromJSON(json: Protobuf.INamespace, options?: Options): PackageDefinition;
export declare function loadFileDescriptorSetFromBuffer(descriptorSet: Buffer, options?: Options): PackageDefinition;
export declare function loadFileDescriptorSetFromObject(descriptorSet: Parameters<typeof descriptor.FileDescriptorSet.fromObject>[0], options?: Options): PackageDefinition;
"use strict";
/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;
const camelCase = require("lodash.camelcase");
const Protobuf = require("@postman/protobufjs");
const descriptor = require("@postman/protobufjs/ext/descriptor");
const util_1 = require("./util");
const Long = require("long");
exports.Long = Long;
function isAnyExtension(obj) {
    return ('@type' in obj) && (typeof obj['@type'] === 'string');
}
exports.isAnyExtension = isAnyExtension;
var IdempotencyLevel;
(function (IdempotencyLevel) {
    IdempotencyLevel["IDEMPOTENCY_UNKNOWN"] = "IDEMPOTENCY_UNKNOWN";
    IdempotencyLevel["NO_SIDE_EFFECTS"] = "NO_SIDE_EFFECTS";
    IdempotencyLevel["IDEMPOTENT"] = "IDEMPOTENT";
})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));
const descriptorOptions = {
    longs: String,
    enums: String,
    bytes: String,
    defaults: true,
    oneofs: true,
    json: true,
};
function joinName(baseName, name) {
    if (baseName === '') {
        return name;
    }
    else {
        return baseName + '.' + name;
    }
}
function isHandledReflectionObject(obj) {
    return (obj instanceof Protobuf.Service ||
        obj instanceof Protobuf.Type ||
        obj instanceof Protobuf.Enum);
}
function isNamespaceBase(obj) {
    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
}
function getAllHandledReflectionObjects(obj, parentName) {
    const objName = joinName(parentName, obj.name);
    if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
    }
    else {
        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {
            return Object.keys(obj.nested)
                .map(name => {
                return getAllHandledReflectionObjects(obj.nested[name], objName);
            })
                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
    }
    return [];
}
function createDeserializer(cls, options) {
    return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options);
    };
}
function createSerializer(cls) {
    return function serialize(arg) {
        if (Array.isArray(arg)) {
            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
        }
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
    };
}
function mapMethodOptions(options) {
    return (options || []).reduce((obj, item) => {
        for (const [key, value] of Object.entries(item)) {
            switch (key) {
                case 'uninterpreted_option':
                    obj.uninterpreted_option.push(item.uninterpreted_option);
                    break;
                default:
                    obj[key] = value;
            }
        }
        return obj;
    }, {
        deprecated: false,
        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
        uninterpreted_option: [],
    });
}
function createMethodDefinition(method, serviceName, options, fileDescriptors) {
    /* This is only ever called after the corresponding root.resolveAll(), so we
     * can assume that the resolved request and response types are non-null */
    const requestType = method.resolvedRequestType;
    const responseType = method.resolvedResponseType;
    return {
        path: '/' + serviceName + '/' + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options),
        // TODO(murgatroid99): Find a better way to handle this
        originalName: camelCase(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors),
        options: mapMethodOptions(method.parsedOptions),
    };
}
function createServiceDefinition(service, name, options, fileDescriptors) {
    const def = {};
    for (const method of service.methodsArray) {
        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
    }
    return def;
}
function createMessageDefinition(message, fileDescriptors) {
    const messageDescriptor = message.toDescriptor('proto3');
    return {
        format: 'Protocol Buffer 3 DescriptorProto',
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors,
    };
}
function createEnumDefinition(enumType, fileDescriptors) {
    const enumDescriptor = enumType.toDescriptor('proto3');
    return {
        format: 'Protocol Buffer 3 EnumDescriptorProto',
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors,
    };
}
/**
 * function createDefinition(obj: Protobuf.Service, name: string, options:
 * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,
 * name: string, options: Options): MessageTypeDefinition; function
 * createDefinition(obj: Protobuf.Enum, name: string, options: Options):
 * EnumTypeDefinition;
 */
function createDefinition(obj, name, options, fileDescriptors) {
    if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name, options, fileDescriptors);
    }
    else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
    }
    else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
    }
    else {
        throw new Error('Type mismatch in reflection object handling');
    }
}
function createPackageDefinition(root, options) {
    const def = {};
    root.resolveAll();
    const descriptorList = root.toDescriptor('proto3').file;
    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {
        def[name] = createDefinition(obj, name, options, bufferList);
    }
    return def;
}
function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
    options = options || {};
    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
    root.resolveAll();
    return createPackageDefinition(root, options);
}
/**
 * Load a .proto file with the specified options.
 * @param filename One or multiple file paths to load. Can be an absolute path
 *     or relative to an include path.
 * @param options.keepCase Preserve field names. The default is to change them
 *     to camel case.
 * @param options.longs The type that should be used to represent `long` values.
 *     Valid options are `Number` and `String`. Defaults to a `Long` object type
 *     from a library.
 * @param options.enums The type that should be used to represent `enum` values.
 *     The only valid option is `String`. Defaults to the numeric value.
 * @param options.bytes The type that should be used to represent `bytes`
 *     values. Valid options are `Array` and `String`. The default is to use
 *     `Buffer`.
 * @param options.defaults Set default values on output objects. Defaults to
 *     `false`.
 * @param options.arrays Set empty arrays for missing array values even if
 *     `defaults` is `false`. Defaults to `false`.
 * @param options.objects Set empty objects for missing object values even if
 *     `defaults` is `false`. Defaults to `false`.
 * @param options.oneofs Set virtual oneof properties to the present field's
 *     name
 * @param options.json Represent Infinity and NaN as strings in float fields,
 *     and automatically decode google.protobuf.Any values.
 * @param options.includeDirs Paths to search for imported `.proto` files.
 */
function load(filename, options) {
    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {
        return createPackageDefinition(loadedRoot, options);
    });
}
exports.load = load;
function loadSync(filename, options) {
    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
    return createPackageDefinition(loadedRoot, options);
}
exports.loadSync = loadSync;
function fromJSON(json, options) {
    options = options || {};
    const loadedRoot = Protobuf.Root.fromJSON(json);
    loadedRoot.resolveAll();
    return createPackageDefinition(loadedRoot, options);
}
exports.fromJSON = fromJSON;
function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
}
exports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
function loadFileDescriptorSetFromObject(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
}
exports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
(0, util_1.addCommonProtos)();
//# sourceMappingURL=index.js.map{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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"}/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import * as Protobuf from '@postman/protobufjs';
export declare type Options = Protobuf.IParseOptions & Protobuf.IConversionOptions & {
    includeDirs?: string[];
};
export declare function loadProtosWithOptions(filename: string | string[], options?: Options): Promise<Protobuf.Root>;
export declare function loadProtosWithOptionsSync(filename: string | string[], options?: Options): Protobuf.Root;
/**
 * Load Google's well-known proto files that aren't exposed by Protobuf.js.
 */
export declare function addCommonProtos(): void;
"use strict";
/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;
const fs = require("fs");
const path = require("path");
const Protobuf = require("@postman/protobufjs");
function addIncludePathResolver(root, includePaths) {
    const originalResolvePath = root.resolvePath;
    root.resolvePath = (origin, target) => {
        if (path.isAbsolute(target)) {
            return target;
        }
        for (const directory of includePaths) {
            const fullPath = path.join(directory, target);
            try {
                fs.accessSync(fullPath, fs.constants.R_OK);
                return fullPath;
            }
            catch (err) {
                continue;
            }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
    };
}
async function loadProtosWithOptions(filename, options) {
    const root = new Protobuf.Root();
    options = options || {};
    if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
            return Promise.reject(new Error('The includeDirs option must be an array'));
        }
        addIncludePathResolver(root, options.includeDirs);
    }
    const loadedRoot = await root.load(filename, options);
    loadedRoot.resolveAll();
    return loadedRoot;
}
exports.loadProtosWithOptions = loadProtosWithOptions;
function loadProtosWithOptionsSync(filename, options) {
    const root = new Protobuf.Root();
    options = options || {};
    if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
            throw new Error('The includeDirs option must be an array');
        }
        addIncludePathResolver(root, options.includeDirs);
    }
    const loadedRoot = root.loadSync(filename, options);
    loadedRoot.resolveAll();
    return loadedRoot;
}
exports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
/**
 * Load Google's well-known proto files that aren't exposed by Protobuf.js.
 */
function addCommonProtos() {
    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,
    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.
    // Using constant strings for compatibility with tools like Webpack
    const apiDescriptor = require('@postman/protobufjs/google/protobuf/api.json');
    const descriptorDescriptor = require('@postman/protobufjs/google/protobuf/descriptor.json');
    const sourceContextDescriptor = require('@postman/protobufjs/google/protobuf/source_context.json');
    const typeDescriptor = require('@postman/protobufjs/google/protobuf/type.json');
    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);
    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);
    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);
    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);
}
exports.addCommonProtos = addCommonProtos;
//# sourceMappingURL=util.js.map{"version":3,"file":"util.js","sourceRoot":"","sources":["../../src/util.ts"],"names":[],"mappings":"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"}                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
{
  "name": "@postman/proto-loader",
  "version": "0.7.13-postman.3",
  "author": "Google Inc.",
  "contributors": [
    {
      "name": "Michael Lumish",
      "email": "mlumish@google.com"
    }
  ],
  "description": "gRPC utility library for loading .proto files",
  "homepage": "https://grpc.io/",
  "main": "build/src/index.js",
  "typings": "build/src/index.d.ts",
  "scripts": {
    "build": "npm run compile",
    "clean": "rimraf ./build",
    "compile": "tsc -p .",
    "format": "clang-format -i -style=\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\" src/*.ts test/*.ts",
    "lint": "tslint -c node_modules/google-ts-style/tslint.json -p . -t codeFrame --type-check",
    "prepare": "npm run compile",
    "test": "gulp test",
    "check": "gts check",
    "fix": "gts fix",
    "pretest": "npm run compile",
    "posttest": "npm run check",
    "generate-golden": "node ./build/bin/proto-loader-gen-types.js --keepCase --longs=String --enums=String --defaults --oneofs --json --includeComments --inputTemplate=I%s --outputTemplate=O%s -I deps/gapic-showcase/schema/ deps/googleapis/ -O ./golden-generated --grpcLib @grpc/grpc-js google/showcase/v1beta1/echo.proto",
    "validate-golden": "rm -rf ./golden-generated-old && mv ./golden-generated/ ./golden-generated-old && npm run generate-golden && diff -rb ./golden-generated ./golden-generated-old"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/grpc/grpc-node.git"
  },
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/grpc/grpc-node/issues"
  },
  "files": [
    "LICENSE",
    "build/src/*.d.ts",
    "build/src/*.{js,js.map}",
    "build/bin/*.{js,js.map}"
  ],
  "bin": {
    "proto-loader-gen-types": "./build/bin/proto-loader-gen-types.js"
  },
  "dependencies": {
    "lodash.camelcase": "^4.3.0",
    "long": "^5.0.0",
    "@postman/protobufjs": "^7.3.2-postman.3",
    "yargs": "^17.7.2"
  },
  "devDependencies": {
    "@types/lodash.camelcase": "^4.3.4",
    "@types/mkdirp": "^1.0.1",
    "@types/mocha": "^5.2.7",
    "@types/node": "^10.17.26",
    "@types/yargs": "^17.0.24",
    "clang-format": "^1.2.2",
    "google-proto-files": "^3.0.2",
    "gts": "^3.1.0",
    "rimraf": "^3.0.2",
    "ts-node": "^10.9.2",
    "typescript": "~4.7.4"
  },
  "engines": {
    "node": ">=6"
  }
}
# gRPC Protobuf Loader

A utility package for loading `.proto` files for use with gRPC, using the latest Protobuf.js package.
Please refer to [protobuf.js' documentation](https://github.com/dcodeIO/protobuf.js/blob/master/README.md)
to understands its features and limitations.

## Installation

```sh
npm install @grpc/proto-loader
```

## Usage

```js
const protoLoader = require('@grpc/proto-loader');
const grpcLibrary = require('grpc');
// OR
const grpcLibrary = require('@grpc/grpc-js');

protoLoader.load(protoFileName, options).then(packageDefinition => {
  const packageObject = grpcLibrary.loadPackageDefinition(packageDefinition);
});
// OR
const packageDefinition = protoLoader.loadSync(protoFileName, options);
const packageObject = grpcLibrary.loadPackageDefinition(packageDefinition);
```

The options parameter is an object that can have the following optional properties:

| Field name | Valid values | Description
|------------|--------------|------------
| `keepCase` | `true` or `false` | Preserve field names. The default is to change them to camel case.
| `longs` | `String` or `Number` | The type to use to represent `long` values. Defaults to a `Long` object type.
| `enums` | `String` | The type to use to represent `enum` values. Defaults to the numeric value.
| `bytes` | `Array` or `String` | The type to use to represent `bytes` values. Defaults to `Buffer`.
| `defaults` | `true` or `false` | Set default values on output objects. Defaults to `false`.
| `arrays` | `true` or `false` | Set empty arrays for missing array values even if `defaults` is `false` Defaults to `false`.
| `objects` | `true` or `false` | Set empty objects for missing object values even if `defaults` is `false` Defaults to `false`.
| `oneofs` | `true` or `false` | Set virtual oneof properties to the present field's name. Defaults to `false`.
| `json` | `true` or `false` | Represent `Infinity` and `NaN` as strings in `float` fields, and automatically decode `google.protobuf.Any` values. Defaults to `false`
| `includeDirs` | An array of strings | A list of search paths for imported `.proto` files.

The following options object closely approximates the existing behavior of `grpc.load`:

```js
const options = {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true
}
```

## Generating TypeScript types

The `proto-loader-gen-types` script distributed with this package can be used to generate TypeScript type information for the objects loaded at runtime. More information about how to use it can be found in [the *@grpc/proto-loader TypeScript Type Generator CLI Tool* proposal document](https://github.com/grpc/proposal/blob/master/L70-node-proto-loader-type-generator.md). The arguments mostly match the `load` function's options; the full usage information is as follows:

```console
proto-loader-gen-types.js [options] filenames...

Options:
      --help             Show help                                     [boolean]
      --version          Show version number                           [boolean]
      --keepCase         Preserve the case of field names
                                                      [boolean] [default: false]
      --longs            The type that should be used to output 64 bit integer
                         values. Can be String, Number[string] [default: "Long"]
      --enums            The type that should be used to output enum fields. Can
                         be String                  [string] [default: "number"]
      --bytes            The type that should be used to output bytes fields.
                         Can be String, Array       [string] [default: "Buffer"]
      --defaults         Output default values for omitted fields
                                                      [boolean] [default: false]
      --arrays           Output default values for omitted repeated fields even
                         if --defaults is not set     [boolean] [default: false]
      --objects          Output default values for omitted message fields even
                         if --defaults is not set     [boolean] [default: false]
      --oneofs           Output virtual oneof fields set to the present field's
                         name                         [boolean] [default: false]
      --json             Represent Infinity and NaN as strings in float fields.
                         Also decode google.protobuf.Any automatically
                                                      [boolean] [default: false]
      --includeComments  Generate doc comments from comments in the original
                         files                        [boolean] [default: false]
  -I, --includeDirs      Directories to search for included files        [array]
  -O, --outDir           Directory in which to output files  [string] [required]
      --grpcLib          The gRPC implementation library that these types will
                         be used with. If not provided, some types will not be
                         generated                                      [string]
      --inputTemplate    Template for mapping input or "permissive" type names
                                                        [string] [default: "%s"]
      --outputTemplate   Template for mapping output or "restricted" type names
                                                [string] [default: "%s__Output"]
      --inputBranded     Output property for branded type for  "permissive"
                         types with fullName of the Message as its value
                                                      [boolean] [default: false]
      --outputBranded    Output property for branded type for  "restricted"
                         types with fullName of the Message as its value
                                                      [boolean] [default: false]
```

### Example Usage

Generate the types:

```sh
$(npm bin)/proto-loader-gen-types --longs=String --enums=String --defaults --oneofs --grpcLib=@grpc/grpc-js --outDir=proto/ proto/*.proto
```

Consume the types:

```ts
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import type { ProtoGrpcType } from './proto/example.ts';
import type { ExampleHandlers } from './proto/example_package/Example.ts';

const exampleServer: ExampleHandlers = {
  // server handlers implementation...
};

const packageDefinition = protoLoader.loadSync('./proto/example.proto');
const proto = (grpc.loadPackageDefinition(
  packageDefinition
) as unknown) as ProtoGrpcType;

const server = new grpc.Server();
server.addService(proto.example_package.Example.service, exampleServer);
```
/*!
 * protobuf.js v7.3.2-postman.2 (c) 2016, daniel wirtz
 * compiled fri, 19 jul 2024 16:26:24 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
(function(undefined){"use strict";(function prelude(modules, cache, entries) {

    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
    // sources through a conflict-free require shim and is again wrapped within an iife that
    // provides a minification-friendly `undefined` var plus a global "use strict" directive
    // so that minification can remove the directives of each module.

    function $require(name) {
        var $module = cache[name];
        if (!$module)
            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);
        return $module.exports;
    }

    var protobuf = $require(entries[0]);

    // Expose globally
    protobuf.util.global.protobuf = protobuf;

    // Be nice to AMD
    if (typeof define === "function" && define.amd)
        define(["long"], function(Long) {
            if (Long && Long.isLong) {
                protobuf.util.Long = Long;
                protobuf.configure();
            }
            return protobuf;
        });

    // Be nice to CommonJS
    if (typeof module === "object" && module && module.exports)
        module.exports = protobuf;

})/* end of prelude */({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require(1),
    inquire   = require(7);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"1":1,"7":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require(14),
    util = require(33);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    var defaultAlreadyEmitted = false;
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                // enum unknown values passthrough
                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen
                    ("default:")
                        ("if(typeof(d%s)===\"number\"){m%s=d%s;break}", prop, prop, prop);
                    if (!field.repeated) gen // fallback to default value only for
                                             // arrays, to avoid leaving holes.
                        ("break");           // for non-repeated fields, just ignore
                    defaultAlreadyEmitted = true;
                }
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length >= 0)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"14":14,"33":33}],12:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require(14),
    types   = require(32),
    util    = require(33);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i: {", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break")
            ("}");
        // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"14":14,"32":32,"33":33}],13:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require(14),
    types    = require(32),
    util     = require(33);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

},{"14":14,"32":32,"33":33}],14:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require(22);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require(21),
    util = require(33);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum
 */
function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Values options, if any
     * @type {Object<string, Object<string, *>>|undefined}
     */
    this.valuesOptions = valuesOptions;

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"       , this.options,
        "valuesOptions" , this.valuesOptions,
        "values"        , this.values,
        "reserved"      , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"       , keepComments ? this.comment : undefined,
        "comments"      , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @param {Object.<string, *>|undefined} [options] Options, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment, options) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    if (options) {
        if (this.valuesOptions === undefined)
            this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
    }

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
        delete this.valuesOptions[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"21":21,"22":22,"33":33}],15:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require(22);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require(14),
    types = require(32),
    util  = require(33);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    if (rule === "proto3_optional") {
        rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    } else if (this.options && this.options.proto3_optional) {
        // proto3 scalar value marked optional; should default to null
        this.typeDefault = null;
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"14":14,"22":22,"32":32,"33":33}],16:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(17);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require(13);
protobuf.decoder          = require(12);
protobuf.verifier         = require(36);
protobuf.converter        = require(11);

// Reflection
protobuf.ReflectionObject = require(22);
protobuf.Namespace        = require(21);
protobuf.Root             = require(26);
protobuf.Enum             = require(14);
protobuf.Type             = require(31);
protobuf.Field            = require(15);
protobuf.OneOf            = require(23);
protobuf.MapField         = require(18);
protobuf.Service          = require(30);
protobuf.Method           = require(20);

// Runtime
protobuf.Message          = require(19);
protobuf.wrappers         = require(37);

// Utility
protobuf.types            = require(32);
protobuf.util             = require(33);

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"11":11,"12":12,"13":13,"14":14,"15":15,"17":17,"18":18,"19":19,"20":20,"21":21,"22":22,"23":23,"26":26,"30":30,"31":31,"32":32,"33":33,"36":36,"37":37}],17:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require(38);
protobuf.BufferWriter = require(39);
protobuf.Reader       = require(24);
protobuf.BufferReader = require(25);

// Utility
protobuf.util         = require(35);
protobuf.rpc          = require(28);
protobuf.roots        = require(27);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"24":24,"25":25,"27":27,"28":28,"35":35,"38":38,"39":39}],18:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require(15);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require(32),
    util    = require(33);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"15":15,"32":32,"33":33}],19:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require(35);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"35":35}],20:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require(22);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require(33);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Options properly parsed into an object
     */
    this.parsedOptions = parsedOptions;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 * @property {string} comment Method comments
 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined,
        "parsedOptions"  , this.parsedOptions,
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"22":22,"33":33}],21:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require(22);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require(15),
    util     = require(33),
    OneOf    = require(23);

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}
 */

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return util.getProp(this.nested, name)
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

},{"15":15,"22":22,"23":23,"33":33}],22:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require(33);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"33":33}],23:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require(22);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require(15),
    util  = require(33);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"15":15,"22":22,"33":33}],24:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require(35);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);

    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
        var nativeBuffer = util.Buffer;
        return nativeBuffer
            ? nativeBuffer.alloc(0)
            : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"35":35}],25:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require(24);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require(35);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"24":24,"35":35}],26:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require(21);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require(15),
    Enum    = require(14),
    OneOf   = require(23),
    util    = require(33);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        if (sync)
            throw err;
        var cb = callback;
        callback = null;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {
        filename = getBundledFileName(filename) || filename;

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        //do not allow to extend same field twice to prevent the error
        if (extendedType.get(sisterField.name)) {
            return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

},{"14":14,"15":15,"21":21,"23":23,"33":33}],27:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],28:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require(29);

},{"29":29}],29:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require(35);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"35":35}],30:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require(21);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require(20),
    util   = require(33),
    rpc    = require(28);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return util.getProp(this.methods, name)
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"20":20,"21":21,"28":28,"33":33}],31:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require(21);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require(14),
    OneOf     = require(23),
    Field     = require(15),
    MapField  = require(18),
    Service   = require(30),
    Message   = require(19),
    Reader    = require(24),
    Writer    = require(38),
    util      = require(33),
    encoder   = require(13),
    decoder   = require(12),
    verifier  = require(36),
    converter = require(11),
    wrappers  = require(37);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {Array.<number[]|string>} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return util.getProp(this.fields, name)
        || util.getProp(this.oneofs, name)
        || util.getProp(this.nested, name)
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"11":11,"12":12,"13":13,"14":14,"15":15,"18":18,"19":19,"21":21,"23":23,"24":24,"30":30,"33":33,"36":36,"37":37,"38":38}],32:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require(33);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"33":33}],33:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require(35);

var roots = require(27);

var Type, // cyclic
    Enum;

util.codegen = require(3);
util.fetch   = require(5);
util.path    = require(8);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Returns the value of a property found directly in a given object.
 * @param {Object} object Source object
 * @param {string} prop Property name
 * @returns {*} Value or `undefined` if not set
 */
util.getProp = function get(object, prop) {
    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require(31);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require(14);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst;
        }
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require(26))());
    }
});

},{"14":14,"26":26,"27":27,"3":3,"31":31,"35":35,"5":5,"8":8}],34:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require(35);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"35":35}],35:[function(require,module,exports){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require(1);

// converts to / from base64 encoded strings
util.base64 = require(2);

// base class of rpc.Service
util.EventEmitter = require(4);

// float handling accross browsers
util.float = require(6);

// requires modules optionally and hides the call from bundlers
util.inquire = require(7);

// converts to / from utf8 encoded strings
util.utf8 = require(10);

// provides a node-like buffer pool in the browser
util.pool = require(9);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require(34);

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true,
        },
        name: {
            get: function get() { return name; },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true,
        },
        toString: {
            value: function value() { return this.name + ": " + this.message; },
            writable: true,
            enumerable: false,
            configurable: true,
        },
    });

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

},{"1":1,"10":10,"2":2,"34":34,"4":4,"6":6,"7":7,"9":9}],36:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require(14),
    util      = require(33);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"14":14,"33":33}],37:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require(19);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].slice(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.slice(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"19":19}],38:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require(35);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"35":35}],39:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require(38);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require(35);

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"35":35,"38":38}]},{},[16])

})();
//# sourceMappingURL=protobuf.js.map
{"version":3,"sources":["lib/prelude.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/codegen/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/fetch/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/path/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/@protobufjs/utf8/index.js","../src/converter.js","../src/decoder.js","../src/encoder.js","../src/enum.js","../src/field.js","../src/index-light","../src/index-minimal.js","../src/mapfield.js","../src/message.js","../src/method.js","../src/namespace.js","../src/object.js","../src/oneof.js","../src/reader.js","../src/reader_buffer.js","../src/root.js","../src/roots.js","../src/rpc.js","../src/rpc/service.js","../src/service.js","../src/type.js","../src/types.js","../src/util.js","../src/util/longbits.js","../src/util/minimal.js","../src/verifier.js","../src/wrappers.js","../src/writer.js","../src/writer_buffer.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"protobuf.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = codegen;\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\r\nfunction codegen(functionParams, functionName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof functionParams === \"string\") {\r\n        functionName = functionParams;\r\n        functionParams = undefined;\r\n    }\r\n\r\n    var body = [];\r\n\r\n    /**\r\n     * Appends code to the function's body or finishes generation.\r\n     * @typedef Codegen\r\n     * @type {function}\r\n     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n     * @param {...*} [formatParams] Format parameters\r\n     * @returns {Codegen|Function} Itself or the generated function if finished\r\n     * @throws {Error} If format parameter counts do not match\r\n     */\r\n\r\n    function Codegen(formatStringOrScope) {\r\n        // note that explicit array handling below makes this ~50% faster\r\n\r\n        // finish the function\r\n        if (typeof formatStringOrScope !== \"string\") {\r\n            var source = toString();\r\n            if (codegen.verbose)\r\n                console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n            source = \"return \" + source;\r\n            if (formatStringOrScope) {\r\n                var scopeKeys   = Object.keys(formatStringOrScope),\r\n                    scopeParams = new Array(scopeKeys.length + 1),\r\n                    scopeValues = new Array(scopeKeys.length),\r\n                    scopeOffset = 0;\r\n                while (scopeOffset < scopeKeys.length) {\r\n                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                }\r\n                scopeParams[scopeOffset] = source;\r\n                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n            }\r\n            return Function(source)(); // eslint-disable-line no-new-func\r\n        }\r\n\r\n        // otherwise append to body\r\n        var formatParams = new Array(arguments.length - 1),\r\n            formatOffset = 0;\r\n        while (formatOffset < formatParams.length)\r\n            formatParams[formatOffset] = arguments[++formatOffset];\r\n        formatOffset = 0;\r\n        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n            var value = formatParams[formatOffset++];\r\n            switch ($1) {\r\n                case \"d\": case \"f\": return String(Number(value));\r\n                case \"i\": return String(Math.floor(value));\r\n                case \"j\": return JSON.stringify(value);\r\n                case \"s\": return String(value);\r\n            }\r\n            return \"%\";\r\n        });\r\n        if (formatOffset !== formatParams.length)\r\n            throw Error(\"parameter count mismatch\");\r\n        body.push(formatStringOrScope);\r\n        return Codegen;\r\n    }\r\n\r\n    function toString(functionNameOverride) {\r\n        return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n    }\r\n\r\n    Codegen.toString = toString;\r\n    return Codegen;\r\n}\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\r\ncodegen.verbose = false;\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\nmodule.exports = fetch;\r\n\r\nvar asPromise = require(1),\r\n    inquire   = require(7);\r\n\r\nvar fs = inquire(\"fs\");\r\n\r\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nfunction fetch(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (!options)\r\n        options = {};\r\n\r\n    if (!callback)\r\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\r\n\r\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\r\n    if (!options.xhr && fs && fs.readFile)\r\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\r\n            return err && typeof XMLHttpRequest !== \"undefined\"\r\n                ? fetch.xhr(filename, options, callback)\r\n                : err\r\n                ? callback(err)\r\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\r\n        });\r\n\r\n    // use the XHR version otherwise.\r\n    return fetch.xhr(filename, options, callback);\r\n}\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\r\n\r\n/**/\r\nfetch.xhr = function fetch_xhr(filename, options, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\r\n\r\n        if (xhr.readyState !== 4)\r\n            return undefined;\r\n\r\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\r\n        // reliably distinguished from an actually empty file for security reasons. feel free\r\n        // to send a pull request if you are aware of a solution.\r\n        if (xhr.status !== 0 && xhr.status !== 200)\r\n            return callback(Error(\"status \" + xhr.status));\r\n\r\n        // if binary data is expected, make sure that some sort of array is returned, even if\r\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\r\n        if (options.binary) {\r\n            var buffer = xhr.response;\r\n            if (!buffer) {\r\n                buffer = [];\r\n                for (var i = 0; i < xhr.responseText.length; ++i)\r\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\r\n            }\r\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\r\n        }\r\n        return callback(null, xhr.responseText);\r\n    };\r\n\r\n    if (options.binary) {\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\r\n        if (\"overrideMimeType\" in xhr)\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        xhr.responseType = \"arraybuffer\";\r\n    }\r\n\r\n    xhr.open(\"GET\", filename);\r\n    xhr.send();\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal path module to resolve Unix, Windows and URL paths alike.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar path = exports;\r\n\r\nvar isAbsolute =\r\n/**\r\n * Tests if the specified path is absolute.\r\n * @param {string} path Path to test\r\n * @returns {boolean} `true` if path is absolute\r\n */\r\npath.isAbsolute = function isAbsolute(path) {\r\n    return /^(?:\\/|\\w+:)/.test(path);\r\n};\r\n\r\nvar normalize =\r\n/**\r\n * Normalizes the specified path.\r\n * @param {string} path Path to normalize\r\n * @returns {string} Normalized path\r\n */\r\npath.normalize = function normalize(path) {\r\n    path = path.replace(/\\\\/g, \"/\")\r\n               .replace(/\\/{2,}/g, \"/\");\r\n    var parts    = path.split(\"/\"),\r\n        absolute = isAbsolute(path),\r\n        prefix   = \"\";\r\n    if (absolute)\r\n        prefix = parts.shift() + \"/\";\r\n    for (var i = 0; i < parts.length;) {\r\n        if (parts[i] === \"..\") {\r\n            if (i > 0 && parts[i - 1] !== \"..\")\r\n                parts.splice(--i, 2);\r\n            else if (absolute)\r\n                parts.splice(i, 1);\r\n            else\r\n                ++i;\r\n        } else if (parts[i] === \".\")\r\n            parts.splice(i, 1);\r\n        else\r\n            ++i;\r\n    }\r\n    return prefix + parts.join(\"/\");\r\n};\r\n\r\n/**\r\n * Resolves the specified include path against the specified origin path.\r\n * @param {string} originPath Path to the origin file\r\n * @param {string} includePath Include path relative to origin path\r\n * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized\r\n * @returns {string} Path to the include file\r\n */\r\npath.resolve = function resolve(originPath, includePath, alreadyNormalized) {\r\n    if (!alreadyNormalized)\r\n        includePath = normalize(includePath);\r\n    if (isAbsolute(includePath))\r\n        return includePath;\r\n    if (!alreadyNormalized)\r\n        originPath = normalize(originPath);\r\n    return (originPath = originPath.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? normalize(originPath + \"/\" + includePath) : includePath;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */\nvar converter = exports;\n\nvar Enum = require(14),\n    util = require(33);\n\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(d%s){\", prop);\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen\n                    (\"default:\")\n                        (\"if(typeof(d%s)===\\\"number\\\"){m%s=d%s;break}\", prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                                             // arrays, to avoid leaving holes.\n                        (\"break\");           // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen\n                (\"case%j:\", keys[i])\n                (\"case %i:\", values[keys[i]])\n                    (\"m%s=%j\", prop, values[keys[i]])\n                    (\"break\");\n            } gen\n            (\"}\");\n        } else gen\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\": gen\n                (\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\": gen\n                (\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(util.Long)\")\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n                    (\"m%s=d%s\", prop, prop)\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\": gen\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n                (\"else if(d%s.length >= 0)\", prop)\n                    (\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\": gen\n                (\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\": gen\n                (\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n            /* default: gen\n                (\"m%s=d%s\", prop, prop);\n                break; */\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray;\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n    (\"if(d instanceof this.ctor)\")\n        (\"return d\");\n    if (!fields.length) return gen\n    (\"return new this.ctor\");\n    gen\n    (\"var m=new this.ctor\");\n    for (var i = 0; i < fields.length; ++i) {\n        var field  = fields[i].resolve(),\n            prop   = util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) { gen\n    (\"if(d%s){\", prop)\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n        (\"m%s={}\", prop)\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n        (\"}\")\n    (\"}\");\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(d%s){\", prop)\n        (\"if(!Array.isArray(d%s))\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n        (\"m%s=[]\", prop)\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n        (\"}\")\n    (\"}\");\n\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen\n    (\"}\");\n        }\n    } return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen\n            (\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n            (\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n                break;\n            case \"bytes\": gen\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default: gen\n            (\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length)\n        return util.codegen()(\"return {}\");\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n    (\"if(!o)\")\n        (\"o={}\")\n    (\"var d={}\");\n\n    var repeatedFields = [],\n        mapFields = [],\n        normalFields = [],\n        i = 0;\n    for (; i < fields.length; ++i)\n        if (!fields[i].partOf)\n            ( fields[i].resolve().repeated ? repeatedFields\n            : fields[i].map ? mapFields\n            : normalFields).push(fields[i]);\n\n    if (repeatedFields.length) { gen\n    (\"if(o.arrays||o.defaults){\");\n        for (i = 0; i < repeatedFields.length; ++i) gen\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (mapFields.length) { gen\n    (\"if(o.objects||o.defaults){\");\n        for (i = 0; i < mapFields.length; ++i) gen\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (normalFields.length) { gen\n    (\"if(o.defaults){\");\n        for (i = 0; i < normalFields.length; ++i) {\n            var field = normalFields[i],\n                prop  = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen\n        (\"if(util.Long){\")\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n        (\"}else\")\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n        (\"else{\")\n            (\"d%s=%s\", prop, arrayDefault)\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n        (\"}\");\n            } else gen\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        } gen\n    (\"}\");\n    }\n    var hasKs2 = false;\n    for (i = 0; i < fields.length; ++i) {\n        var field = fields[i],\n            index = mtype._fieldsArray.indexOf(field),\n            prop  = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) { hasKs2 = true; gen\n    (\"var ks2\");\n            } gen\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n        (\"d%s={}\", prop)\n        (\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n        (\"}\");\n        } else if (field.repeated) { gen\n    (\"if(m%s&&m%s.length){\", prop, prop)\n        (\"d%s=[]\", prop)\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n        (\"}\");\n        } else { gen\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n        if (field.partOf) gen\n        (\"if(o.oneofs)\")\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen\n    (\"}\");\n    }\n    return gen\n    (\"return d\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n","\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(14),\n    types   = require(32),\n    util    = require(33);\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i: {\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\")\n            (\"}\");\n        // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n","\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(14),\n    types    = require(32),\n    util     = require(33);\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n","\"use strict\";\nmodule.exports = Enum;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\nvar Namespace = require(21),\n    util = require(33);\n\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */\nfunction Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */\n    this.valuesOptions = valuesOptions;\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"       , this.options,\n        \"valuesOptions\" , this.valuesOptions,\n        \"values\"        , this.values,\n        \"reserved\"      , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"       , keepComments ? this.comment : undefined,\n        \"comments\"      , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    if (options) {\n        if (this.valuesOptions === undefined)\n            this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions)\n        delete this.valuesOptions[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n","\"use strict\";\nmodule.exports = Field;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\n\nvar Enum  = require(14),\n    types = require(32),\n    util  = require(33);\n\nvar Type; // cyclic\n\nvar ruleRe = /^required|optional|repeated$/;\n\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */\nField.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction Field(name, id, type, rule, extend, options, comment) {\n\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n\n    ReflectionObject.call(this, name, options);\n\n    if (!util.isInteger(id) || id < 0)\n        throw TypeError(\"id must be a non-negative integer\");\n\n    if (!util.isString(type))\n        throw TypeError(\"type must be a string\");\n\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))\n        throw TypeError(\"rule must be a string rule\");\n\n    if (extend !== undefined && !util.isString(extend))\n        throw TypeError(\"extend must be a string\");\n\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */\n    if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n\n    /**\n     * Field type.\n     * @type {string}\n     */\n    this.type = type; // toJSON\n\n    /**\n     * Unique field id.\n     * @type {number}\n     */\n    this.id = id; // toJSON, marker\n\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */\n    this.extend = extend || undefined; // toJSON\n\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */\n    this.required = rule === \"required\";\n\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */\n    this.optional = !this.required;\n\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */\n    this.repeated = rule === \"repeated\";\n\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */\n    this.map = false;\n\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */\n    this.message = null;\n\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */\n    this.partOf = null;\n\n    /**\n     * The field type's default value.\n     * @type {*}\n     */\n    this.typeDefault = null;\n\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */\n    this.defaultValue = null;\n\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */\n    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */\n    this.bytes = type === \"bytes\";\n\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */\n    this.resolvedType = null;\n\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */\n    this.extensionField = null;\n\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */\n    this.declaringField = null;\n\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */\n    this._packed = null;\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */\nObject.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null)\n            this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n\n/**\n * @override\n */\nField.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") // clear cached before setting\n        this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */\n\n/**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */\n\n/**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */\nField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\"    , this.rule !== \"optional\" && this.rule || undefined,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */\nField.prototype.resolve = function resolve() {\n\n    if (this.resolved)\n        return this;\n\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type)\n            this.typeDefault = null;\n        else // instanceof Enum\n            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\")\n            this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))\n            delete this.options.packed;\n        if (!Object.keys(this.options).length)\n            this.options = undefined;\n    }\n\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n\n        /* istanbul ignore else */\n        if (Object.freeze)\n            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault))\n            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else\n            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n\n    // take special care of maps and repeated fields\n    if (this.map)\n        this.defaultValue = util.emptyObject;\n    else if (this.repeated)\n        this.defaultValue = util.emptyArray;\n    else\n        this.defaultValue = this.typeDefault;\n\n    // ensure proper value on prototype\n    if (this.parent instanceof Type)\n        this.parent.ctor.prototype[this.name] = this.defaultValue;\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */\nField.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\")\n        fieldType = util.decorateType(fieldType).name;\n\n    // enum reference: create a reflected copy of the enum and keep reuseing it\n    else if (fieldType && typeof fieldType === \"object\")\n        fieldType = util.decorateEnum(fieldType).name;\n\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { \"default\": defaultValue }));\n    };\n};\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */\n// like Field.d but without a default value\n\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n","\"use strict\";\nvar protobuf = module.exports = require(17);\n\nprotobuf.build = \"light\";\n\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */\nfunction load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root)\n        root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */\n// function load(filename:string, [root:Root]):Promise<Root>\n\nprotobuf.load = load;\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */\nfunction loadSync(filename, root) {\n    if (!root)\n        root = new protobuf.Root();\n    return root.loadSync(filename);\n}\n\nprotobuf.loadSync = loadSync;\n\n// Serialization\nprotobuf.encoder          = require(13);\nprotobuf.decoder          = require(12);\nprotobuf.verifier         = require(36);\nprotobuf.converter        = require(11);\n\n// Reflection\nprotobuf.ReflectionObject = require(22);\nprotobuf.Namespace        = require(21);\nprotobuf.Root             = require(26);\nprotobuf.Enum             = require(14);\nprotobuf.Type             = require(31);\nprotobuf.Field            = require(15);\nprotobuf.OneOf            = require(23);\nprotobuf.MapField         = require(18);\nprotobuf.Service          = require(30);\nprotobuf.Method           = require(20);\n\n// Runtime\nprotobuf.Message          = require(19);\nprotobuf.wrappers         = require(37);\n\n// Utility\nprotobuf.types            = require(32);\nprotobuf.util             = require(33);\n\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(38);\nprotobuf.BufferWriter = require(39);\nprotobuf.Reader       = require(24);\nprotobuf.BufferReader = require(25);\n\n// Utility\nprotobuf.util         = require(35);\nprotobuf.rpc          = require(28);\nprotobuf.roots        = require(27);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(15);\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types   = require(32),\n    util    = require(33);\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n    /* istanbul ignore if */\n    if (!util.isString(keyType))\n        throw TypeError(\"keyType must be a string\");\n\n    /**\n     * Key type.\n     * @type {string}\n     */\n    this.keyType = keyType; // toJSON, marker\n\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */\n    this.resolvedKeyType = null;\n\n    // Overrides Field#map\n    this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\" , this.keyType,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined)\n        throw Error(\"invalid key type: \" + this.keyType);\n\n    return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\")\n        fieldValueType = util.decorateType(fieldValueType).name;\n\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\n    else if (fieldValueType && typeof fieldValueType === \"object\")\n        fieldValueType = util.decorateEnum(fieldValueType).name;\n\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n","\"use strict\";\nmodule.exports = Message;\n\nvar util = require(35);\n\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */\nfunction Message(properties) {\n    // not used internally\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            this[keys[i]] = properties[keys[i]];\n}\n\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */\n\n/**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */\n\n/*eslint-disable valid-jsdoc*/\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.create = function create(properties) {\n    return this.$type.create(properties);\n};\n\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */\nMessage.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */\nMessage.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n};\n\n/*eslint-enable valid-jsdoc*/","\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(33);\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Options properly parsed into an object\n     */\n    this.parsedOptions = parsedOptions;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined,\n        \"parsedOptions\"  , this.parsedOptions,\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n","\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(15),\n    util     = require(33),\n    OneOf    = require(23);\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n","\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(33);\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n","\"use strict\";\nmodule.exports = OneOf;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\n\nvar Field = require(15),\n    util  = require(33);\n\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n\n    /* istanbul ignore if */\n    if (!(fieldNames === undefined || Array.isArray(fieldNames)))\n        throw TypeError(\"fieldNames must be an Array\");\n\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */\n    this.oneof = fieldNames || []; // toJSON, marker\n\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */\n    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */\n\n/**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */\nOneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */\nOneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , this.options,\n        \"oneof\"   , this.oneof,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */\nfunction addFieldsToParent(oneof) {\n    if (oneof.parent)\n        for (var i = 0; i < oneof.fieldsArray.length; ++i)\n            if (!oneof.fieldsArray[i].parent)\n                oneof.parent.add(oneof.fieldsArray[i]);\n}\n\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */\nOneOf.prototype.add = function add(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    if (field.parent && field.parent !== this.parent)\n        field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */\nOneOf.prototype.remove = function remove(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    var index = this.fieldsArray.indexOf(field);\n\n    /* istanbul ignore if */\n    if (index < 0)\n        throw Error(field + \" is not a member of \" + this);\n\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n\n    /* istanbul ignore else */\n    if (index > -1) // theoretical\n        this.oneof.splice(index, 1);\n\n    field.partOf = null;\n    return this;\n};\n\n/**\n * @override\n */\nOneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for (var i = 0; i < this.oneof.length; ++i) {\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n\n/**\n * @override\n */\nOneOf.prototype.onRemove = function onRemove(parent) {\n    for (var i = 0, field; i < this.fieldsArray.length; ++i)\n        if ((field = this.fieldsArray[i]).parent)\n            field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */\n\n/**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */\nOneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length),\n        index = 0;\n    while (index < arguments.length)\n        fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor)\n            .add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(35);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(24);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(35);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Root;\n\n// extends Namespace\nvar Namespace = require(21);\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\n\nvar Field   = require(15),\n    Enum    = require(14),\n    OneOf   = require(23),\n    util    = require(33);\n\nvar Type,   // cyclic\n    parse,  // might be excluded\n    common; // \"\n\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */\nfunction Root(options) {\n    Namespace.call(this, \"\", options);\n\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */\n    this.deferred = [];\n\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */\n    this.files = [];\n}\n\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */\nRoot.fromJSON = function fromJSON(json, root) {\n    if (!root)\n        root = new Root();\n    if (json.options)\n        root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */\nRoot.prototype.resolvePath = util.path.resolve;\n\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.fetch = util.fetch;\n\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */\nfunction SYNC() {} // eslint-disable-line no-empty-function\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback)\n        return util.asPromise(load, self, filename, options);\n\n    var sync = callback === SYNC; // undocumented\n\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */\n        if (!callback)\n            return;\n        if (sync)\n            throw err;\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\")\n                source = JSON.parse(source);\n            if (!util.isString(source))\n                self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options),\n                    resolved,\n                    i = 0;\n                if (parsed.imports)\n                    for (; i < parsed.imports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))\n                            fetch(resolved);\n                if (parsed.weakImports)\n                    for (i = 0; i < parsed.weakImports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))\n                            fetch(resolved, true);\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued)\n            finish(null, self); // only once anyway\n    }\n\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1)\n            return;\n        self.files.push(filename);\n\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync)\n                process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak)\n                    finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */\n                if (!callback)\n                    return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */\n                    if (!weak)\n                        finish(err);\n                    else if (!queued) // can't be covered reliably\n                        finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename))\n        filename = [ filename ];\n    for (var i = 0, resolved; i < filename.length; ++i)\n        if (resolved = self.resolvePath(\"\", filename[i]))\n            fetch(resolved);\n\n    if (sync)\n        return self;\n    if (!queued)\n        finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */\n// function load(filename:string, [options:IParseOptions]):Promise<Root>\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */\nRoot.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode)\n        throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n\n/**\n * @override\n */\nRoot.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length)\n        throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n            return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n        }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */\nfunction tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)\n            if (!tryHandleExtension(this, object))\n                this.deferred.push(object);\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object.values; // expose enum values as property of its parent\n\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n\n        if (object instanceof Type) // Try to handle any deferred extensions\n            for (var i = 0; i < this.deferred.length;)\n                if (tryHandleExtension(this, this.deferred[i]))\n                    this.deferred.splice(i, 1);\n                else\n                    ++i;\n        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace\n            this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n\n    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n    // properties of namespaces just like static code does. This allows using a .d.ts generated for\n    // a static module with reflection-based solutions where the condition is met.\n};\n\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) { // remove its sister field\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else { // cancel the extension\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */\n                if (index > -1)\n                    this.deferred.splice(index, 1);\n            }\n        }\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose enum values\n\n    } else if (object instanceof Namespace) {\n\n        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace\n            this._handleRemove(object._nestedArray[i]);\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose namespaces\n\n    }\n};\n\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type   = Type_;\n    parse  = parse_;\n    common = common_;\n};\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(29);\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(35);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = Service;\n\n// extends Namespace\nvar Namespace = require(21);\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\n\nvar Method = require(20),\n    util   = require(33),\n    rpc    = require(28);\n\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */\nfunction Service(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */\n    this.methods = {}; // toJSON, marker\n\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */\n    this._methodsArray = null;\n}\n\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */\n\n/**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */\nService.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */\n    if (json.methods)\n        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)\n            service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested)\n        service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */\nService.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , inherited && inherited.options || undefined,\n        \"methods\" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\"  , inherited && inherited.nested || undefined,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */\nObject.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\n\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n\n/**\n * @override\n */\nService.prototype.get = function get(name) {\n    return util.getProp(this.methods, name)\n        || Namespace.prototype.get.call(this, name);\n};\n\n/**\n * @override\n */\nService.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for (var i = 0; i < methods.length; ++i)\n        methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n\n/**\n * @override\n */\nService.prototype.add = function add(object) {\n\n    /* istanbul ignore if */\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * @override\n */\nService.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n\n        /* istanbul ignore if */\n        if (this.methods[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */\nService.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\"r\",\"c\"], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n","\"use strict\";\nmodule.exports = Type;\n\n// extends Namespace\nvar Namespace = require(21);\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum      = require(14),\n    OneOf     = require(23),\n    Field     = require(15),\n    MapField  = require(18),\n    Service   = require(30),\n    Message   = require(19),\n    Reader    = require(24),\n    Writer    = require(38),\n    util      = require(33),\n    encoder   = require(13),\n    decoder   = require(12),\n    verifier  = require(36),\n    converter = require(11),\n    wrappers  = require(37);\n\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n                };\n            if (i)\n                Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nType.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"p\"], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n        if ((field = mtype._fieldsArray[i]).map) gen\n            (\"this%s={}\", util.safeProp(field.name));\n        else if (field.repeated) gen\n            (\"this%s=[]\", util.safeProp(field.name));\n    return gen\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n        (\"this[ks[i]]=p[ks[i]]\");\n    /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */\n\n/**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n            ? MapField.fromJSON\n            : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                ? Field.fromJSON\n                : nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"    , inherited && inherited.options || undefined,\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"      , this.group || undefined,\n        \"nested\"     , inherited && inherited.nested || undefined,\n        \"comment\"    , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n/**\n * @override\n */\nType.prototype.get = function get(name) {\n    return util.getProp(this.fields, name)\n        || util.getProp(this.oneofs, name)\n        || util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n            originalThis.fromObject = this.fromObject;\n            this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n            originalThis.toObject = this.toObject;\n            this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */\n\n/**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n","\"use strict\";\n\n/**\n * Common type constants.\n * @namespace\n */\nvar types = exports;\n\nvar util = require(33);\n\nvar s = [\n    \"double\",   // 0\n    \"float\",    // 1\n    \"int32\",    // 2\n    \"uint32\",   // 3\n    \"sint32\",   // 4\n    \"fixed32\",  // 5\n    \"sfixed32\", // 6\n    \"int64\",    // 7\n    \"uint64\",   // 8\n    \"sint64\",   // 9\n    \"fixed64\",  // 10\n    \"sfixed64\", // 11\n    \"bool\",     // 12\n    \"string\",   // 13\n    \"bytes\"     // 14\n];\n\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while (i < values.length) o[s[i + offset]] = values[i++];\n    return o;\n}\n\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */\ntypes.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */\ntypes.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */\ntypes.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */\ntypes.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */\ntypes.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n","\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(35);\n\nvar roots = require(27);\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(3);\nutil.fetch   = require(5);\nutil.path    = require(8);\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Returns the value of a property found directly in a given object.\n * @param {Object} object Source object\n * @param {string} prop Property name\n * @returns {*} Value or `undefined` if not set\n */\nutil.getProp = function get(object, prop) {\n    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(31);\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(14);\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(26))());\n    }\n});\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(35);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(4);\n\n// float handling accross browsers\nutil.float = require(6);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(7);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(10);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(9);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(34);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = verifier;\n\nvar Enum      = require(14),\n    util      = require(33);\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(%s){\", ref)\n                (\"default:\")\n                    (\"return%j\", invalid(field, \"enum value\"));\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen\n                    (\"break\")\n            (\"}\");\n        } else {\n            gen\n            (\"{\")\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n                (\"if(e)\")\n                    (\"return%j+e\", field.name + \".\")\n            (\"}\");\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\": gen\n                (\"if(!util.isInteger(%s))\", ref)\n                    (\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n                    (\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\": gen\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\n                    (\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\": gen\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n                    (\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\": gen\n                (\"if(!util.isString(%s))\", ref)\n                    (\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\": gen\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n                    (\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    switch (field.keyType) {\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\": gen\n            (\"if(!util.key32Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\": gen\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n                (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\": gen\n            (\"if(!util.key2Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n        (\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray,\n        seenFirstField = {};\n    if (oneofs.length) gen\n    (\"var p={}\");\n\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            ref   = \"m\" + util.safeProp(field.name);\n\n        if (field.optional) gen\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n        // map fields\n        if (field.map) { gen\n            (\"if(!util.isObject(%s))\", ref)\n                (\"return%j\", invalid(field, \"object\"))\n            (\"var k=Object.keys(%s)\", ref)\n            (\"for(var i=0;i<k.length;++i){\");\n                genVerifyKey(gen, field, \"k[i]\");\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n            (\"}\");\n\n        // repeated fields\n        } else if (field.repeated) { gen\n            (\"if(!Array.isArray(%s))\", ref)\n                (\"return%j\", invalid(field, \"array\"))\n            (\"for(var i=0;i<%s.length;++i){\", ref);\n                genVerifyValue(gen, field, i, ref + \"[i]\")\n            (\"}\");\n\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen\n            (\"if(p%s===1)\", oneofProp)\n                (\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen\n            (\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen\n        (\"}\");\n    }\n    return gen\n    (\"return null\");\n    /* eslint-enable no-unexpected-multiline */\n}","\"use strict\";\n\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */\nvar wrappers = exports;\n\nvar Message = require(19);\n\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n\n    fromObject: function(object) {\n\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n             // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\n                    object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n\n        return this.fromObject(object);\n    },\n\n    toObject: function(message, options) {\n\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type)\n                message = type.decode(message.value);\n        }\n\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ?\n                message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n\n        return this.toObject(message, options);\n    }\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(35);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(38);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(35);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"sourceRoot":"."}/*!
 * protobuf.js v7.3.2-postman.2 (c) 2016, daniel wirtz
 * compiled fri, 19 jul 2024 16:26:24 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
!function(g){"use strict";!function(r,e,t){var i=function t(i){var n=e[i];return n||r[i][0].call(n=e[i]={exports:{}},t,n,n.exports),n.exports}(t[0]);i.util.global.protobuf=i,"function"==typeof define&&define.amd&&define(["long"],function(t){return t&&t.isLong&&(i.util.Long=t,i.configure()),i}),"object"==typeof module&&module&&module.exports&&(module.exports=i)}({1:[function(t,i,n){i.exports=function(t,i){var n=Array(arguments.length-1),s=0,r=2,u=!0;for(;r<arguments.length;)n[s++]=arguments[r++];return new Promise(function(r,e){n[s]=function(t){if(u)if(u=!1,t)e(t);else{for(var i=Array(arguments.length-1),n=0;n<i.length;)i[n++]=arguments[n];r.apply(null,i)}};try{t.apply(i||null,n)}catch(t){u&&(u=!1,e(t))}})}},{}],2:[function(t,i,n){n.length=function(t){var i=t.length;if(!i)return 0;for(var n=0;1<--i%4&&"="==(t[0|i]||"");)++n;return Math.ceil(3*t.length)/4-n};for(var f=Array(64),h=Array(123),r=0;r<64;)h[f[r]=r<26?r+65:r<52?r+71:r<62?r-4:r-59|43]=r++;n.encode=function(t,i,n){for(var r,e=null,s=[],u=0,o=0;i<n;){var h=t[i++];switch(o){case 0:s[u++]=f[h>>2],r=(3&h)<<4,o=1;break;case 1:s[u++]=f[r|h>>4],r=(15&h)<<2,o=2;break;case 2:s[u++]=f[r|h>>6],s[u++]=f[63&h],o=0}8191<u&&((e=e||[]).push(String.fromCharCode.apply(String,s)),u=0)}return o&&(s[u++]=f[r],s[u++]=61,1===o&&(s[u++]=61)),e?(u&&e.push(String.fromCharCode.apply(String,s.slice(0,u))),e.join("")):String.fromCharCode.apply(String,s.slice(0,u))};var c="invalid encoding";n.decode=function(t,i,n){for(var r,e=n,s=0,u=0;u<t.length;){var o=t.charCodeAt(u++);if(61==o&&1<s)break;if((o=h[o])===g)throw Error(c);switch(s){case 0:r=o,s=1;break;case 1:i[n++]=r<<2|(48&o)>>4,r=o,s=2;break;case 2:i[n++]=(15&r)<<4|(60&o)>>2,r=o,s=3;break;case 3:i[n++]=(3&r)<<6|o,s=0}}if(1===s)throw Error(c);return n-e},n.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},{}],3:[function(t,i,n){function a(i,n){"string"==typeof i&&(n=i,i=g);var h=[];function f(t){if("string"!=typeof t){var i=c();if(a.verbose&&console.log("codegen: "+i),i="return "+i,t){for(var n=Object.keys(t),r=Array(n.length+1),e=Array(n.length),s=0;s<n.length;)r[s]=n[s],e[s]=t[n[s++]];return r[s]=i,Function.apply(null,r).apply(null,e)}return Function(i)()}for(var u=Array(arguments.length-1),o=0;o<u.length;)u[o]=arguments[++o];if(o=0,t=t.replace(/%([%dfijs])/g,function(t,i){var n=u[o++];switch(i){case"d":case"f":return""+ +(""+n);case"i":return""+Math.floor(n);case"j":return JSON.stringify(n);case"s":return""+n}return"%"}),o!==u.length)throw Error("parameter count mismatch");return h.push(t),f}function c(t){return"function "+(t||n||"")+"("+(i&&i.join(",")||"")+"){\n  "+h.join("\n  ")+"\n}"}return f.toString=c,f}(i.exports=a).verbose=!1},{}],4:[function(t,i,n){function r(){this.t={}}(i.exports=r).prototype.on=function(t,i,n){return(this.t[t]||(this.t[t]=[])).push({fn:i,ctx:n||this}),this},r.prototype.off=function(t,i){if(t===g)this.t={};else if(i===g)this.t[t]=[];else for(var n=this.t[t],r=0;r<n.length;)n[r].fn===i?n.splice(r,1):++r;return this},r.prototype.emit=function(t){var i=this.t[t];if(i){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<i.length;)i[r].fn.apply(i[r++].ctx,n)}return this}},{}],5:[function(t,i,n){i.exports=o;var s=t(1),u=t(7)("fs");function o(n,r,e){return r="function"==typeof r?(e=r,{}):r||{},e?!r.xhr&&u&&u.readFile?u.readFile(n,function(t,i){return t&&"undefined"!=typeof XMLHttpRequest?o.xhr(n,r,e):t?e(t):e(null,r.binary?i:i.toString("utf8"))}):o.xhr(n,r,e):s(o,this,n,r)}o.xhr=function(t,n,r){var e=new XMLHttpRequest;e.onreadystatechange=function(){if(4!==e.readyState)return g;if(0!==e.status&&200!==e.status)return r(Error("status "+e.status));if(n.binary){if(!(t=e.response))for(var t=[],i=0;i<e.responseText.length;++i)t.push(255&e.responseText.charCodeAt(i));return r(null,"undefined"!=typeof Uint8Array?new Uint8Array(t):t)}return r(null,e.responseText)},n.binary&&("overrideMimeType"in e&&e.overrideMimeType("text/plain; charset=x-user-defined"),e.responseType="arraybuffer"),e.open("GET",t),e.send()}},{1:1,7:7}],6:[function(t,i,n){function r(t){function i(t,i,n,r){var e=i<0?1:0;t(0===(i=e?-i:i)?0<1/i?0:2147483648:isNaN(i)?2143289344:34028234663852886e22<i?(e<<31|2139095040)>>>0:i<11754943508222875e-54?(e<<31|Math.round(i/1401298464324817e-60))>>>0:(e<<31|127+(t=Math.floor(Math.log(i)/Math.LN2))<<23|8388607&Math.round(i*Math.pow(2,-t)*8388608))>>>0,n,r)}function n(t,i,n){t=t(i,n),i=2*(t>>31)+1,n=t>>>23&255,t&=8388607;return 255==n?t?NaN:1/0*i:0==n?1401298464324817e-60*i*t:i*Math.pow(2,n-150)*(8388608+t)}function r(t,i,n){o[0]=t,i[n]=h[0],i[n+1]=h[1],i[n+2]=h[2],i[n+3]=h[3]}function e(t,i,n){o[0]=t,i[n]=h[3],i[n+1]=h[2],i[n+2]=h[1],i[n+3]=h[0]}function s(t,i){return h[0]=t[i],h[1]=t[i+1],h[2]=t[i+2],h[3]=t[i+3],o[0]}function u(t,i){return h[3]=t[i],h[2]=t[i+1],h[1]=t[i+2],h[0]=t[i+3],o[0]}var o,h,f,c,a;function l(t,i,n,r,e,s){var u,o=r<0?1:0;0===(r=o?-r:r)?(t(0,e,s+i),t(0<1/r?0:2147483648,e,s+n)):isNaN(r)?(t(0,e,s+i),t(2146959360,e,s+n)):17976931348623157e292<r?(t(0,e,s+i),t((o<<31|2146435072)>>>0,e,s+n)):r<22250738585072014e-324?(t((u=r/5e-324)>>>0,e,s+i),t((o<<31|u/4294967296)>>>0,e,s+n)):(t(4503599627370496*(u=r*Math.pow(2,-(r=1024===(r=Math.floor(Math.log(r)/Math.LN2))?1023:r)))>>>0,e,s+i),t((o<<31|r+1023<<20|1048576*u&1048575)>>>0,e,s+n))}function d(t,i,n,r,e){i=t(r,e+i),t=t(r,e+n),r=2*(t>>31)+1,e=t>>>20&2047,n=4294967296*(1048575&t)+i;return 2047==e?n?NaN:1/0*r:0==e?5e-324*r*n:r*Math.pow(2,e-1075)*(n+4503599627370496)}function v(t,i,n){f[0]=t,i[n]=c[0],i[n+1]=c[1],i[n+2]=c[2],i[n+3]=c[3],i[n+4]=c[4],i[n+5]=c[5],i[n+6]=c[6],i[n+7]=c[7]}function b(t,i,n){f[0]=t,i[n]=c[7],i[n+1]=c[6],i[n+2]=c[5],i[n+3]=c[4],i[n+4]=c[3],i[n+5]=c[2],i[n+6]=c[1],i[n+7]=c[0]}function p(t,i){return c[0]=t[i],c[1]=t[i+1],c[2]=t[i+2],c[3]=t[i+3],c[4]=t[i+4],c[5]=t[i+5],c[6]=t[i+6],c[7]=t[i+7],f[0]}function y(t,i){return c[7]=t[i],c[6]=t[i+1],c[5]=t[i+2],c[4]=t[i+3],c[3]=t[i+4],c[2]=t[i+5],c[1]=t[i+6],c[0]=t[i+7],f[0]}return"undefined"!=typeof Float32Array?(o=new Float32Array([-0]),h=new Uint8Array(o.buffer),a=128===h[3],t.writeFloatLE=a?r:e,t.writeFloatBE=a?e:r,t.readFloatLE=a?s:u,t.readFloatBE=a?u:s):(t.writeFloatLE=i.bind(null,m),t.writeFloatBE=i.bind(null,w),t.readFloatLE=n.bind(null,g),t.readFloatBE=n.bind(null,j)),"undefined"!=typeof Float64Array?(f=new Float64Array([-0]),c=new Uint8Array(f.buffer),a=128===c[7],t.writeDoubleLE=a?v:b,t.writeDoubleBE=a?b:v,t.readDoubleLE=a?p:y,t.readDoubleBE=a?y:p):(t.writeDoubleLE=l.bind(null,m,0,4),t.writeDoubleBE=l.bind(null,w,4,0),t.readDoubleLE=d.bind(null,g,0,4),t.readDoubleBE=d.bind(null,j,4,0)),t}function m(t,i,n){i[n]=255&t,i[n+1]=t>>>8&255,i[n+2]=t>>>16&255,i[n+3]=t>>>24}function w(t,i,n){i[n]=t>>>24,i[n+1]=t>>>16&255,i[n+2]=t>>>8&255,i[n+3]=255&t}function g(t,i){return(t[i]|t[i+1]<<8|t[i+2]<<16|t[i+3]<<24)>>>0}function j(t,i){return(t[i]<<24|t[i+1]<<16|t[i+2]<<8|t[i+3])>>>0}i.exports=r(r)},{}],7:[function(t,i,n){function r(t){try{var i=eval("require")(t);if(i&&(i.length||Object.keys(i).length))return i}catch(t){}return null}i.exports=r},{}],8:[function(t,i,n){var e=n.isAbsolute=function(t){return/^(?:\/|\w+:)/.test(t)},r=n.normalize=function(t){var i=(t=t.replace(/\\/g,"/").replace(/\/{2,}/g,"/")).split("/"),n=e(t),t="";n&&(t=i.shift()+"/");for(var r=0;r<i.length;)".."===i[r]?0<r&&".."!==i[r-1]?i.splice(--r,2):n?i.splice(r,1):++r:"."===i[r]?i.splice(r,1):++r;return t+i.join("/")};n.resolve=function(t,i,n){return n||(i=r(i)),!e(i)&&(t=(t=n?t:r(t)).replace(/(?:\/|^)[^/]+$/,"")).length?r(t+"/"+i):i}},{}],9:[function(t,i,n){i.exports=function(i,n,t){var r=t||8192,e=r>>>1,s=null,u=r;return function(t){if(t<1||e<t)return i(t);r<u+t&&(s=i(r),u=0);t=n.call(s,u,u+=t);return 7&u&&(u=1+(7|u)),t}}},{}],10:[function(t,i,n){n.length=function(t){for(var i,n=0,r=0;r<t.length;++r)(i=t.charCodeAt(r))<128?n+=1:i<2048?n+=2:55296==(64512&i)&&56320==(64512&t.charCodeAt(r+1))?(++r,n+=4):n+=3;return n},n.read=function(t,i,n){if(n-i<1)return"";for(var r,e=null,s=[],u=0;i<n;)(r=t[i++])<128?s[u++]=r:191<r&&r<224?s[u++]=(31&r)<<6|63&t[i++]:239<r&&r<365?(r=((7&r)<<18|(63&t[i++])<<12|(63&t[i++])<<6|63&t[i++])-65536,s[u++]=55296+(r>>10),s[u++]=56320+(1023&r)):s[u++]=(15&r)<<12|(63&t[i++])<<6|63&t[i++],8191<u&&((e=e||[]).push(String.fromCharCode.apply(String,s)),u=0);return e?(u&&e.push(String.fromCharCode.apply(String,s.slice(0,u))),e.join("")):String.fromCharCode.apply(String,s.slice(0,u))},n.write=function(t,i,n){for(var r,e,s=n,u=0;u<t.length;++u)(r=t.charCodeAt(u))<128?i[n++]=r:(r<2048?i[n++]=r>>6|192:(55296==(64512&r)&&56320==(64512&(e=t.charCodeAt(u+1)))?(++u,i[n++]=(r=65536+((1023&r)<<10)+(1023&e))>>18|240,i[n++]=r>>12&63|128):i[n++]=r>>12|224,i[n++]=r>>6&63|128),i[n++]=63&r|128);return n-s}},{}],11:[function(t,i,n){var l=t(14),d=t(33);function u(t,i,n,r){var e=!1;if(i.resolvedType)if(i.resolvedType instanceof l){t("switch(d%s){",r);for(var s=i.resolvedType.values,u=Object.keys(s),o=0;o<u.length;++o)s[u[o]]!==i.typeDefault||e||(t("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}',r,r,r),i.repeated||t("break"),e=!0),t("case%j:",u[o])("case %i:",s[u[o]])("m%s=%j",r,s[u[o]])("break");t("}")}else t('if(typeof d%s!=="object")',r)("throw TypeError(%j)",i.fullName+": object expected")("m%s=types[%i].fromObject(d%s)",r,n,r);else{var h=!1;switch(i.type){case"double":case"float":t("m%s=Number(d%s)",r,r);break;case"uint32":case"fixed32":t("m%s=d%s>>>0",r,r);break;case"int32":case"sint32":case"sfixed32":t("m%s=d%s|0",r,r);break;case"uint64":h=!0;case"int64":case"sint64":case"fixed64":case"sfixed64":t("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j",r,r,h)('else if(typeof d%s==="string")',r)("m%s=parseInt(d%s,10)",r,r)('else if(typeof d%s==="number")',r)("m%s=d%s",r,r)('else if(typeof d%s==="object")',r)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)",r,r,r,h?"true":"");break;case"bytes":t('if(typeof d%s==="string")',r)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)",r,r,r)("else if(d%s.length >= 0)",r)("m%s=d%s",r,r);break;case"string":t("m%s=String(d%s)",r,r);break;case"bool":t("m%s=Boolean(d%s)",r,r)}}return t}function v(t,i,n,r){if(i.resolvedType)i.resolvedType instanceof l?t("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s",r,n,r,r,n,r,r):t("d%s=types[%i].toObject(m%s,o)",r,n,r);else{var e=!1;switch(i.type){case"double":case"float":t("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s",r,r,r,r);break;case"uint64":e=!0;case"int64":case"sint64":case"fixed64":case"sfixed64":t('if(typeof m%s==="number")',r)("d%s=o.longs===String?String(m%s):m%s",r,r,r)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",r,r,r,r,e?"true":"",r);break;case"bytes":t("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",r,r,r,r,r);break;default:t("d%s=m%s",r,r)}}return t}n.fromObject=function(t){var i=t.fieldsArray,n=d.codegen(["d"],t.name+"$fromObject")("if(d instanceof this.ctor)")("return d");if(!i.length)return n("return new this.ctor");n("var m=new this.ctor");for(var r=0;r<i.length;++r){var e=i[r].resolve(),s=d.safeProp(e.name);e.map?(n("if(d%s){",s)('if(typeof d%s!=="object")',s)("throw TypeError(%j)",e.fullName+": object expected")("m%s={}",s)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){",s),u(n,e,r,s+"[ks[i]]")("}")("}")):e.repeated?(n("if(d%s){",s)("if(!Array.isArray(d%s))",s)("throw TypeError(%j)",e.fullName+": array expected")("m%s=[]",s)("for(var i=0;i<d%s.length;++i){",s),u(n,e,r,s+"[i]")("}")("}")):(e.resolvedType instanceof l||n("if(d%s!=null){",s),u(n,e,r,s),e.resolvedType instanceof l||n("}"))}return n("return m")},n.toObject=function(t){var i=t.fieldsArray.slice().sort(d.compareFieldsById);if(!i.length)return d.codegen()("return {}");for(var n=d.codegen(["m","o"],t.name+"$toObject")("if(!o)")("o={}")("var d={}"),r=[],e=[],s=[],u=0;u<i.length;++u)i[u].partOf||(i[u].resolve().repeated?r:i[u].map?e:s).push(i[u]);if(r.length){for(n("if(o.arrays||o.defaults){"),u=0;u<r.length;++u)n("d%s=[]",d.safeProp(r[u].name));n("}")}if(e.length){for(n("if(o.objects||o.defaults){"),u=0;u<e.length;++u)n("d%s={}",d.safeProp(e[u].name));n("}")}if(s.length){for(n("if(o.defaults){"),u=0;u<s.length;++u){var o,h=s[u],f=d.safeProp(h.name);h.resolvedType instanceof l?n("d%s=o.enums===String?%j:%j",f,h.resolvedType.valuesById[h.typeDefault],h.typeDefault):h.long?n("if(util.Long){")("var n=new util.Long(%i,%i,%j)",h.typeDefault.low,h.typeDefault.high,h.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n",f)("}else")("d%s=o.longs===String?%j:%i",f,h.typeDefault.toString(),h.typeDefault.toNumber()):h.bytes?(o="["+Array.prototype.slice.call(h.typeDefault).join(",")+"]",n("if(o.bytes===String)d%s=%j",f,String.fromCharCode.apply(String,h.typeDefault))("else{")("d%s=%s",f,o)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)",f,f)("}")):n("d%s=%j",f,h.typeDefault)}n("}")}for(var c=!1,u=0;u<i.length;++u){var h=i[u],a=t.i.indexOf(h),f=d.safeProp(h.name);h.map?(c||(c=!0,n("var ks2")),n("if(m%s&&(ks2=Object.keys(m%s)).length){",f,f)("d%s={}",f)("for(var j=0;j<ks2.length;++j){"),v(n,h,a,f+"[ks2[j]]")("}")):h.repeated?(n("if(m%s&&m%s.length){",f,f)("d%s=[]",f)("for(var j=0;j<m%s.length;++j){",f),v(n,h,a,f+"[j]")("}")):(n("if(m%s!=null&&m.hasOwnProperty(%j)){",f,h.name),v(n,h,a,f),h.partOf&&n("if(o.oneofs)")("d%s=%j",d.safeProp(h.partOf.name),h.name)),n("}")}return n("return d")}},{14:14,33:33}],12:[function(t,i,n){i.exports=function(t){var i=f.codegen(["r","l"],t.name+"$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor"+(t.fieldsArray.filter(function(t){return t.map}).length?",k,value":""))("while(r.pos<c){")("var t=r.uint32()");t.group&&i("if((t&7)===4)")("break");i("switch(t>>>3){");for(var n=0;n<t.fieldsArray.length;++n){var r=t.i[n].resolve(),e=r.resolvedType instanceof o?"int32":r.type,s="m"+f.safeProp(r.name);i("case %i: {",r.id),r.map?(i("if(%s===util.emptyObject)",s)("%s={}",s)("var c2 = r.uint32()+r.pos"),h.defaults[r.keyType]!==g?i("k=%j",h.defaults[r.keyType]):i("k=null"),h.defaults[e]!==g?i("value=%j",h.defaults[e]):i("value=null"),i("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break",r.keyType)("case 2:"),h.basic[e]===g?i("value=types[%i].decode(r,r.uint32())",n):i("value=r.%s()",e),i("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"),h.long[r.keyType]!==g?i('%s[typeof k==="object"?util.longToHash(k):k]=value',s):i("%s[k]=value",s)):r.repeated?(i("if(!(%s&&%s.length))",s,s)("%s=[]",s),h.packed[e]!==g&&i("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())",s,e)("}else"),h.basic[e]===g?i(r.resolvedType.group?"%s.push(types[%i].decode(r))":"%s.push(types[%i].decode(r,r.uint32()))",s,n):i("%s.push(r.%s())",s,e)):h.basic[e]===g?i(r.resolvedType.group?"%s=types[%i].decode(r)":"%s=types[%i].decode(r,r.uint32())",s,n):i("%s=r.%s()",s,e),i("break")("}")}for(i("default:")("r.skipType(t&7)")("break")("}")("}"),n=0;n<t.i.length;++n){var u=t.i[n];u.required&&i("if(!m.hasOwnProperty(%j))",u.name)("throw util.ProtocolError(%j,{instance:m})","missing required '"+u.name+"'")}return i("return m")};var o=t(14),h=t(32),f=t(33)},{14:14,32:32,33:33}],13:[function(t,i,n){i.exports=function(t){for(var i,n=a.codegen(["m","w"],t.name+"$encode")("if(!w)")("w=Writer.create()"),r=t.fieldsArray.slice().sort(a.compareFieldsById),e=0;e<r.length;++e){var s=r[e].resolve(),u=t.i.indexOf(s),o=s.resolvedType instanceof f?"int32":s.type,h=c.basic[o];i="m"+a.safeProp(s.name),s.map?(n("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){",i,s.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){",i)("w.uint32(%i).fork().uint32(%i).%s(ks[i])",(s.id<<3|2)>>>0,8|c.mapKey[s.keyType],s.keyType),h===g?n("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",u,i):n(".uint32(%i).%s(%s[ks[i]]).ldelim()",16|h,o,i),n("}")("}")):s.repeated?(n("if(%s!=null&&%s.length){",i,i),s.packed&&c.packed[o]!==g?n("w.uint32(%i).fork()",(s.id<<3|2)>>>0)("for(var i=0;i<%s.length;++i)",i)("w.%s(%s[i])",o,i)("w.ldelim()"):(n("for(var i=0;i<%s.length;++i)",i),h===g?l(n,s,u,i+"[i]"):n("w.uint32(%i).%s(%s[i])",(s.id<<3|h)>>>0,o,i)),n("}")):(s.optional&&n("if(%s!=null&&Object.hasOwnProperty.call(m,%j))",i,s.name),h===g?l(n,s,u,i):n("w.uint32(%i).%s(%s)",(s.id<<3|h)>>>0,o,i))}return n("return w")};var f=t(14),c=t(32),a=t(33);function l(t,i,n,r){i.resolvedType.group?t("types[%i].encode(%s,w.uint32(%i)).uint32(%i)",n,r,(i.id<<3|3)>>>0,(i.id<<3|4)>>>0):t("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",n,r,(i.id<<3|2)>>>0)}},{14:14,32:32,33:33}],14:[function(t,i,n){i.exports=s;var h=t(22),r=(((s.prototype=Object.create(h.prototype)).constructor=s).className="Enum",t(21)),e=t(33);function s(t,i,n,r,e,s){if(h.call(this,t,n),i&&"object"!=typeof i)throw TypeError("values must be an object");if(this.valuesById={},this.values=Object.create(this.valuesById),this.comment=r,this.comments=e||{},this.valuesOptions=s,this.reserved=g,i)for(var u=Object.keys(i),o=0;o<u.length;++o)"number"==typeof i[u[o]]&&(this.valuesById[this.values[u[o]]=i[u[o]]]=u[o])}s.fromJSON=function(t,i){t=new s(t,i.values,i.options,i.comment,i.comments);return t.reserved=i.reserved,t},s.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return e.toObject(["options",this.options,"valuesOptions",this.valuesOptions,"values",this.values,"reserved",this.reserved&&this.reserved.length?this.reserved:g,"comment",t?this.comment:g,"comments",t?this.comments:g])},s.prototype.add=function(t,i,n,r){if(!e.isString(t))throw TypeError("name must be a string");if(!e.isInteger(i))throw TypeError("id must be an integer");if(this.values[t]!==g)throw Error("duplicate name '"+t+"' in "+this);if(this.isReservedId(i))throw Error("id "+i+" is reserved in "+this);if(this.isReservedName(t))throw Error("name '"+t+"' is reserved in "+this);if(this.valuesById[i]!==g){if(!this.options||!this.options.allow_alias)throw Error("duplicate id "+i+" in "+this);this.values[t]=i}else this.valuesById[this.values[t]=i]=t;return r&&(this.valuesOptions===g&&(this.valuesOptions={}),this.valuesOptions[t]=r||null),this.comments[t]=n||null,this},s.prototype.remove=function(t){if(!e.isString(t))throw TypeError("name must be a string");var i=this.values[t];if(null==i)throw Error("name '"+t+"' does not exist in "+this);return delete this.valuesById[i],delete this.values[t],delete this.comments[t],this.valuesOptions&&delete this.valuesOptions[t],this},s.prototype.isReservedId=function(t){return r.isReservedId(this.reserved,t)},s.prototype.isReservedName=function(t){return r.isReservedName(this.reserved,t)}},{21:21,22:22,33:33}],15:[function(t,i,n){i.exports=u;var r,o=t(22),e=(((u.prototype=Object.create(o.prototype)).constructor=u).className="Field",t(14)),h=t(32),f=t(33),c=/^required|optional|repeated$/;function u(t,i,n,r,e,s,u){if(f.isObject(r)?(u=e,s=r,r=e=g):f.isObject(e)&&(u=s,s=e,e=g),o.call(this,t,s),!f.isInteger(i)||i<0)throw TypeError("id must be a non-negative integer");if(!f.isString(n))throw TypeError("type must be a string");if(r!==g&&!c.test(r=r.toString().toLowerCase()))throw TypeError("rule must be a string rule");if(e!==g&&!f.isString(e))throw TypeError("extend must be a string");this.rule=(r="proto3_optional"===r?"optional":r)&&"optional"!==r?r:g,this.type=n,this.id=i,this.extend=e||g,this.required="required"===r,this.optional=!this.required,this.repeated="repeated"===r,this.map=!1,this.message=null,this.partOf=null,this.typeDefault=null,this.defaultValue=null,this.long=!!f.Long&&h.long[n]!==g,this.bytes="bytes"===n,this.resolvedType=null,this.extensionField=null,this.declaringField=null,this.n=null,this.comment=u}u.fromJSON=function(t,i){return new u(t,i.id,i.type,i.rule,i.extend,i.options,i.comment)},Object.defineProperty(u.prototype,"packed",{get:function(){return null===this.n&&(this.n=!1!==this.getOption("packed")),this.n}}),u.prototype.setOption=function(t,i,n){return"packed"===t&&(this.n=null),o.prototype.setOption.call(this,t,i,n)},u.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return f.toObject(["rule","optional"!==this.rule&&this.rule||g,"type",this.type,"id",this.id,"extend",this.extend,"options",this.options,"comment",t?this.comment:g])},u.prototype.resolve=function(){var t;return this.resolved?this:((this.typeDefault=h.defaults[this.type])===g?(this.resolvedType=(this.declaringField||this).parent.lookupTypeOrEnum(this.type),this.resolvedType instanceof r?this.typeDefault=null:this.typeDefault=this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]):this.options&&this.options.proto3_optional&&(this.typeDefault=null),this.options&&null!=this.options.default&&(this.typeDefault=this.options.default,this.resolvedType instanceof e&&"string"==typeof this.typeDefault&&(this.typeDefault=this.resolvedType.values[this.typeDefault])),this.options&&(!0!==this.options.packed&&(this.options.packed===g||!this.resolvedType||this.resolvedType instanceof e)||delete this.options.packed,Object.keys(this.options).length||(this.options=g)),this.long?(this.typeDefault=f.Long.fromNumber(this.typeDefault,"u"==(this.type[0]||"")),Object.freeze&&Object.freeze(this.typeDefault)):this.bytes&&"string"==typeof this.typeDefault&&(f.base64.test(this.typeDefault)?f.base64.decode(this.typeDefault,t=f.newBuffer(f.base64.length(this.typeDefault)),0):f.utf8.write(this.typeDefault,t=f.newBuffer(f.utf8.length(this.typeDefault)),0),this.typeDefault=t),this.map?this.defaultValue=f.emptyObject:this.repeated?this.defaultValue=f.emptyArray:this.defaultValue=this.typeDefault,this.parent instanceof r&&(this.parent.ctor.prototype[this.name]=this.defaultValue),o.prototype.resolve.call(this))},u.d=function(n,r,e,s){return"function"==typeof r?r=f.decorateType(r).name:r&&"object"==typeof r&&(r=f.decorateEnum(r).name),function(t,i){f.decorateType(t.constructor).add(new u(i,n,r,e,{default:s}))}},u.r=function(t){r=t}},{14:14,22:22,32:32,33:33}],16:[function(t,i,n){var r=i.exports=t(17);r.build="light",r.load=function(t,i,n){return(i="function"==typeof i?(n=i,new r.Root):i||new r.Root).load(t,n)},r.loadSync=function(t,i){return(i=i||new r.Root).loadSync(t)},r.encoder=t(13),r.decoder=t(12),r.verifier=t(36),r.converter=t(11),r.ReflectionObject=t(22),r.Namespace=t(21),r.Root=t(26),r.Enum=t(14),r.Type=t(31),r.Field=t(15),r.OneOf=t(23),r.MapField=t(18),r.Service=t(30),r.Method=t(20),r.Message=t(19),r.wrappers=t(37),r.types=t(32),r.util=t(33),r.ReflectionObject.r(r.Root),r.Namespace.r(r.Type,r.Service,r.Enum),r.Root.r(r.Type),r.Field.r(r.Type)},{11:11,12:12,13:13,14:14,15:15,17:17,18:18,19:19,20:20,21:21,22:22,23:23,26:26,30:30,31:31,32:32,33:33,36:36,37:37}],17:[function(t,i,n){var r=n;function e(){r.util.r(),r.Writer.r(r.BufferWriter),r.Reader.r(r.BufferReader)}r.build="minimal",r.Writer=t(38),r.BufferWriter=t(39),r.Reader=t(24),r.BufferReader=t(25),r.util=t(35),r.rpc=t(28),r.roots=t(27),r.configure=e,e()},{24:24,25:25,27:27,28:28,35:35,38:38,39:39}],18:[function(t,i,n){i.exports=s;var u=t(15),r=(((s.prototype=Object.create(u.prototype)).constructor=s).className="MapField",t(32)),o=t(33);function s(t,i,n,r,e,s){if(u.call(this,t,i,r,g,g,e,s),!o.isString(n))throw TypeError("keyType must be a string");this.keyType=n,this.resolvedKeyType=null,this.map=!0}s.fromJSON=function(t,i){return new s(t,i.id,i.keyType,i.type,i.options,i.comment)},s.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return o.toObject(["keyType",this.keyType,"type",this.type,"id",this.id,"extend",this.extend,"options",this.options,"comment",t?this.comment:g])},s.prototype.resolve=function(){if(this.resolved)return this;if(r.mapKey[this.keyType]===g)throw Error("invalid key type: "+this.keyType);return u.prototype.resolve.call(this)},s.d=function(n,r,e){return"function"==typeof e?e=o.decorateType(e).name:e&&"object"==typeof e&&(e=o.decorateEnum(e).name),function(t,i){o.decorateType(t.constructor).add(new s(i,n,r,e))}}},{15:15,32:32,33:33}],19:[function(t,i,n){i.exports=e;var r=t(35);function e(t){if(t)for(var i=Object.keys(t),n=0;n<i.length;++n)this[i[n]]=t[i[n]]}e.create=function(t){return this.$type.create(t)},e.encode=function(t,i){return this.$type.encode(t,i)},e.encodeDelimited=function(t,i){return this.$type.encodeDelimited(t,i)},e.decode=function(t){return this.$type.decode(t)},e.decodeDelimited=function(t){return this.$type.decodeDelimited(t)},e.verify=function(t){return this.$type.verify(t)},e.fromObject=function(t){return this.$type.fromObject(t)},e.toObject=function(t,i){return this.$type.toObject(t,i)},e.prototype.toJSON=function(){return this.$type.toObject(this,r.toJSONOptions)}},{35:35}],20:[function(t,i,n){i.exports=r;var f=t(22),c=(((r.prototype=Object.create(f.prototype)).constructor=r).className="Method",t(33));function r(t,i,n,r,e,s,u,o,h){if(c.isObject(e)?(u=e,e=s=g):c.isObject(s)&&(u=s,s=g),i!==g&&!c.isString(i))throw TypeError("type must be a string");if(!c.isString(n))throw TypeError("requestType must be a string");if(!c.isString(r))throw TypeError("responseType must be a string");f.call(this,t,u),this.type=i||"rpc",this.requestType=n,this.requestStream=!!e||g,this.responseType=r,this.responseStream=!!s||g,this.resolvedRequestType=null,this.resolvedResponseType=null,this.comment=o,this.parsedOptions=h}r.fromJSON=function(t,i){return new r(t,i.type,i.requestType,i.responseType,i.requestStream,i.responseStream,i.options,i.comment,i.parsedOptions)},r.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return c.toObject(["type","rpc"!==this.type&&this.type||g,"requestType",this.requestType,"requestStream",this.requestStream,"responseType",this.responseType,"responseStream",this.responseStream,"options",this.options,"comment",t?this.comment:g,"parsedOptions",this.parsedOptions])},r.prototype.resolve=function(){return this.resolved?this:(this.resolvedRequestType=this.parent.lookupType(this.requestType),this.resolvedResponseType=this.parent.lookupType(this.responseType),f.prototype.resolve.call(this))}},{22:22,33:33}],21:[function(t,i,n){i.exports=a;var e,s,u,r=t(22),o=(((a.prototype=Object.create(r.prototype)).constructor=a).className="Namespace",t(15)),h=t(33),f=t(23);function c(t,i){if(!t||!t.length)return g;for(var n={},r=0;r<t.length;++r)n[t[r].name]=t[r].toJSON(i);return n}function a(t,i){r.call(this,t,i),this.nested=g,this.e=null}function l(t){return t.e=null,t}a.fromJSON=function(t,i){return new a(t,i.options).addJSON(i.nested)},a.arrayToJSON=c,a.isReservedId=function(t,i){if(t)for(var n=0;n<t.length;++n)if("string"!=typeof t[n]&&t[n][0]<=i&&t[n][1]>i)return!0;return!1},a.isReservedName=function(t,i){if(t)for(var n=0;n<t.length;++n)if(t[n]===i)return!0;return!1},Object.defineProperty(a.prototype,"nestedArray",{get:function(){return this.e||(this.e=h.toArray(this.nested))}}),a.prototype.toJSON=function(t){return h.toObject(["options",this.options,"nested",c(this.nestedArray,t)])},a.prototype.addJSON=function(t){if(t)for(var i,n=Object.keys(t),r=0;r<n.length;++r)i=t[n[r]],this.add((i.fields!==g?e:i.values!==g?u:i.methods!==g?s:i.id!==g?o:a).fromJSON(n[r],i));return this},a.prototype.get=function(t){return h.getProp(this.nested,t)||null},a.prototype.getEnum=function(t){if(this.nested&&this.nested[t]instanceof u)return this.nested[t].values;throw Error("no such enum: "+t)},a.prototype.add=function(t){if(!(t instanceof o&&t.extend!==g||t instanceof e||t instanceof f||t instanceof u||t instanceof s||t instanceof a))throw TypeError("object must be a valid nested object");if(this.nested){var i=this.get(t.name);if(i){if(!(i instanceof a&&t instanceof a)||i instanceof e||i instanceof s)throw Error("duplicate name '"+t.name+"' in "+this);for(var n=i.nestedArray,r=0;r<n.length;++r)t.add(n[r]);this.remove(i),this.nested||(this.nested={}),t.setOptions(i.options,!0)}}else this.nested={};return(this.nested[t.name]=t).onAdd(this),l(this)},a.prototype.remove=function(t){if(!(t instanceof r))throw TypeError("object must be a ReflectionObject");if(t.parent!==this)throw Error(t+" is not a member of "+this);return delete this.nested[t.name],Object.keys(this.nested).length||(this.nested=g),t.onRemove(this),l(this)},a.prototype.define=function(t,i){if(h.isString(t))t=t.split(".");else if(!Array.isArray(t))throw TypeError("illegal path");if(t&&t.length&&""===t[0])throw Error("path must be relative");for(var n=this;0<t.length;){var r=t.shift();if(n.nested&&n.nested[r]){if(!((n=n.nested[r])instanceof a))throw Error("path conflicts with non-namespace objects")}else n.add(n=new a(r))}return i&&n.addJSON(i),n},a.prototype.resolveAll=function(){for(var t=this.nestedArray,i=0;i<t.length;)t[i]instanceof a?t[i++].resolveAll():t[i++].resolve();return this.resolve()},a.prototype.lookup=function(t,i,n){if("boolean"==typeof i?(n=i,i=g):i&&!Array.isArray(i)&&(i=[i]),h.isString(t)&&t.length){if("."===t)return this.root;t=t.split(".")}else if(!t.length)return this;if(""===t[0])return this.root.lookup(t.slice(1),i);var r=this.get(t[0]);if(r){if(1===t.length){if(!i||~i.indexOf(r.constructor))return r}else if(r instanceof a&&(r=r.lookup(t.slice(1),i,!0)))return r}else for(var e=0;e<this.nestedArray.length;++e)if(this.e[e]instanceof a&&(r=this.e[e].lookup(t,i,!0)))return r;return null===this.parent||n?null:this.parent.lookup(t,i)},a.prototype.lookupType=function(t){var i=this.lookup(t,[e]);if(i)return i;throw Error("no such type: "+t)},a.prototype.lookupEnum=function(t){var i=this.lookup(t,[u]);if(i)return i;throw Error("no such Enum '"+t+"' in "+this)},a.prototype.lookupTypeOrEnum=function(t){var i=this.lookup(t,[e,u]);if(i)return i;throw Error("no such Type or Enum '"+t+"' in "+this)},a.prototype.lookupService=function(t){var i=this.lookup(t,[s]);if(i)return i;throw Error("no such Service '"+t+"' in "+this)},a.r=function(t,i,n){e=t,s=i,u=n}},{15:15,22:22,23:23,33:33}],22:[function(t,i,n){(i.exports=e).className="ReflectionObject";var r,u=t(33);function e(t,i){if(!u.isString(t))throw TypeError("name must be a string");if(i&&!u.isObject(i))throw TypeError("options must be an object");this.options=i,this.parsedOptions=null,this.name=t,this.parent=null,this.resolved=!1,this.comment=null,this.filename=null}Object.defineProperties(e.prototype,{root:{get:function(){for(var t=this;null!==t.parent;)t=t.parent;return t}},fullName:{get:function(){for(var t=[this.name],i=this.parent;i;)t.unshift(i.name),i=i.parent;return t.join(".")}}}),e.prototype.toJSON=function(){throw Error()},e.prototype.onAdd=function(t){this.parent&&this.parent!==t&&this.parent.remove(this),this.parent=t,this.resolved=!1;t=t.root;t instanceof r&&t.u(this)},e.prototype.onRemove=function(t){t=t.root;t instanceof r&&t.o(this),this.parent=null,this.resolved=!1},e.prototype.resolve=function(){return this.resolved||this.root instanceof r&&(this.resolved=!0),this},e.prototype.getOption=function(t){return this.options?this.options[t]:g},e.prototype.setOption=function(t,i,n){return n&&this.options&&this.options[t]!==g||((this.options||(this.options={}))[t]=i),this},e.prototype.setParsedOption=function(i,t,n){this.parsedOptions||(this.parsedOptions=[]);var r,e,s=this.parsedOptions;return n?(r=s.find(function(t){return Object.prototype.hasOwnProperty.call(t,i)}))?(e=r[i],u.setProperty(e,n,t)):((r={})[i]=u.setProperty({},n,t),s.push(r)):((e={})[i]=t,s.push(e)),this},e.prototype.setOptions=function(t,i){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)this.setOption(n[r],t[n[r]],i);return this},e.prototype.toString=function(){var t=this.constructor.className,i=this.fullName;return i.length?t+" "+i:t},e.r=function(t){r=t}},{33:33}],23:[function(t,i,n){i.exports=u;var e=t(22),r=(((u.prototype=Object.create(e.prototype)).constructor=u).className="OneOf",t(15)),s=t(33);function u(t,i,n,r){if(Array.isArray(i)||(n=i,i=g),e.call(this,t,n),i!==g&&!Array.isArray(i))throw TypeError("fieldNames must be an Array");this.oneof=i||[],this.fieldsArray=[],this.comment=r}function o(t){if(t.parent)for(var i=0;i<t.fieldsArray.length;++i)t.fieldsArray[i].parent||t.parent.add(t.fieldsArray[i])}u.fromJSON=function(t,i){return new u(t,i.oneof,i.options,i.comment)},u.prototype.toJSON=function(t){t=!!t&&!!t.keepComments;return s.toObject(["options",this.options,"oneof",this.oneof,"comment",t?this.comment:g])},u.prototype.add=function(t){if(t instanceof r)return t.parent&&t.parent!==this.parent&&t.parent.remove(t),this.oneof.push(t.name),this.fieldsArray.push(t),o(t.partOf=this),this;throw TypeError("field must be a Field")},u.prototype.remove=function(t){if(!(t instanceof r))throw TypeError("field must be a Field");var i=this.fieldsArray.indexOf(t);if(i<0)throw Error(t+" is not a member of "+this);return this.fieldsArray.splice(i,1),-1<(i=this.oneof.indexOf(t.name))&&this.oneof.splice(i,1),t.partOf=null,this},u.prototype.onAdd=function(t){e.prototype.onAdd.call(this,t);for(var i=0;i<this.oneof.length;++i){var n=t.get(this.oneof[i]);n&&!n.partOf&&(n.partOf=this).fieldsArray.push(n)}o(this)},u.prototype.onRemove=function(t){for(var i,n=0;n<this.fieldsArray.length;++n)(i=this.fieldsArray[n]).parent&&i.parent.remove(i);e.prototype.onRemove.call(this,t)},u.d=function(){for(var n=Array(arguments.length),t=0;t<arguments.length;)n[t]=arguments[t++];return function(t,i){s.decorateType(t.constructor).add(new u(i,n)),Object.defineProperty(t,i,{get:s.oneOfGetter(n),set:s.oneOfSetter(n)})}}},{15:15,22:22,33:33}],24:[function(t,i,n){i.exports=h;var r,e=t(35),s=e.LongBits,u=e.utf8;function o(t,i){return RangeError("index out of range: "+t.pos+" + "+(i||1)+" > "+t.len)}function h(t){this.buf=t,this.pos=0,this.len=t.length}function f(){return e.Buffer?function(t){return(h.create=function(t){return e.Buffer.isBuffer(t)?new r(t):a(t)})(t)}:a}var c,a="undefined"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new h(t);throw Error("illegal buffer")}:function(t){if(Array.isArray(t))return new h(t);throw Error("illegal buffer")};function l(){var t=new s(0,0),i=0;if(!(4<this.len-this.pos)){for(;i<3;++i){if(this.pos>=this.len)throw o(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*i)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*i)>>>0,t}for(;i<4;++i)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*i)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(i=0,4<this.len-this.pos){for(;i<5;++i)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*i+3)>>>0,this.buf[this.pos++]<128)return t}else for(;i<5;++i){if(this.pos>=this.len)throw o(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*i+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}function d(t,i){return(t[i-4]|t[i-3]<<8|t[i-2]<<16|t[i-1]<<24)>>>0}function v(){if(this.pos+8>this.len)throw o(this,8);return new s(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}h.create=f(),h.prototype.h=e.Array.prototype.subarray||e.Array.prototype.slice,h.prototype.uint32=(c=4294967295,function(){if(c=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(c=(c|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128||(c=(c|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128||(c=(c|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128||(c=(c|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128||!((this.pos+=5)>this.len))))))return c;throw this.pos=this.len,o(this,10)}),h.prototype.int32=function(){return 0|this.uint32()},h.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},h.prototype.bool=function(){return 0!==this.uint32()},h.prototype.fixed32=function(){if(this.pos+4>this.len)throw o(this,4);return d(this.buf,this.pos+=4)},h.prototype.sfixed32=function(){if(this.pos+4>this.len)throw o(this,4);return 0|d(this.buf,this.pos+=4)},h.prototype.float=function(){if(this.pos+4>this.len)throw o(this,4);var t=e.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},h.prototype.double=function(){if(this.pos+8>this.len)throw o(this,4);var t=e.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},h.prototype.bytes=function(){var t=this.uint32(),i=this.pos,n=this.pos+t;if(n>this.len)throw o(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(i,n):i===n?(t=e.Buffer)?t.alloc(0):new this.buf.constructor(0):this.h.call(this.buf,i,n)},h.prototype.string=function(){var t=this.bytes();return u.read(t,0,t.length)},h.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw o(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw o(this)}while(128&this.buf[this.pos++]);return this},h.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this},h.r=function(t){r=t,h.create=f(),r.r();var i=e.Long?"toLong":"toNumber";e.merge(h.prototype,{int64:function(){return l.call(this)[i](!1)},uint64:function(){return l.call(this)[i](!0)},sint64:function(){return l.call(this).zzDecode()[i](!1)},fixed64:function(){return v.call(this)[i](!0)},sfixed64:function(){return v.call(this)[i](!1)}})}},{35:35}],25:[function(t,i,n){i.exports=s;var r=t(24),e=((s.prototype=Object.create(r.prototype)).constructor=s,t(35));function s(t){r.call(this,t)}s.r=function(){e.Buffer&&(s.prototype.h=e.Buffer.prototype.slice)},s.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+t,this.len))},s.r()},{24:24,35:35}],26:[function(t,i,n){i.exports=h;var r,d,v,e=t(21),s=(((h.prototype=Object.create(e.prototype)).constructor=h).className="Root",t(15)),u=t(14),o=t(23),b=t(33);function h(t){e.call(this,"",t),this.deferred=[],this.files=[]}function p(){}h.fromJSON=function(t,i){return i=i||new h,t.options&&i.setOptions(t.options),i.addJSON(t.nested)},h.prototype.resolvePath=b.path.resolve,h.prototype.fetch=b.fetch,h.prototype.load=function t(i,s,e){"function"==typeof s&&(e=s,s=g);var u=this;if(!e)return b.asPromise(t,u,i,s);var o=e===p;function h(t,i){if(e){if(o)throw t;var n=e;e=null,n(t,i)}}function f(t){var i=t.lastIndexOf("google/protobuf/");if(-1<i){t=t.substring(i);if(t in v)return t}return null}function c(t,i){try{if(b.isString(i)&&"{"==(i[0]||"")&&(i=JSON.parse(i)),b.isString(i)){d.filename=t;var n,r=d(i,u,s),e=0;if(r.imports)for(;e<r.imports.length;++e)(n=f(r.imports[e])||u.resolvePath(t,r.imports[e]))&&a(n);if(r.weakImports)for(e=0;e<r.weakImports.length;++e)(n=f(r.weakImports[e])||u.resolvePath(t,r.weakImports[e]))&&a(n,!0)}else u.setOptions(i.options).addJSON(i.nested)}catch(t){h(t)}o||l||h(null,u)}function a(n,r){if(n=f(n)||n,!~u.files.indexOf(n))if(u.files.push(n),n in v)o?c(n,v[n]):(++l,setTimeout(function(){--l,c(n,v[n])}));else if(o){var t;try{t=b.fs.readFileSync(n).toString("utf8")}catch(t){return void(r||h(t))}c(n,t)}else++l,u.fetch(n,function(t,i){--l,e&&(t?r?l||h(null,u):h(t):c(n,i))})}var l=0;b.isString(i)&&(i=[i]);for(var n,r=0;r<i.length;++r)(n=u.resolvePath("",i[r]))&&a(n);return o?u:(l||h(null,u),g)},h.prototype.loadSync=function(t,i){if(b.isNode)return this.load(t,i,p);throw Error("not supported")},h.prototype.resolveAll=function(){if(this.deferred.length)throw Error("unresolvable extensions: "+this.deferred.map(function(t){return"'extend "+t.extend+"' in "+t.parent.fullName}).join(", "));return e.prototype.resolveAll.call(this)};var f=/^[A-Z]/;function c(t,i){var n,r=i.parent.lookup(i.extend);if(r)return n=new s(i.fullName,i.id,i.type,i.rule,g,i.options),r.get(n.name)||((n.declaringField=i).extensionField=n,r.add(n)),1}h.prototype.u=function(t){if(t instanceof s)t.extend===g||t.extensionField||c(0,t)||this.deferred.push(t);else if(t instanceof u)f.test(t.name)&&(t.parent[t.name]=t.values);else if(!(t instanceof o)){if(t instanceof r)for(var i=0;i<this.deferred.length;)c(0,this.deferred[i])?this.deferred.splice(i,1):++i;for(var n=0;n<t.nestedArray.length;++n)this.u(t.e[n]);f.test(t.name)&&(t.parent[t.name]=t)}},h.prototype.o=function(t){var i;if(t instanceof s)t.extend!==g&&(t.extensionField?(t.extensionField.parent.remove(t.extensionField),t.extensionField=null):-1<(i=this.deferred.indexOf(t))&&this.deferred.splice(i,1));else if(t instanceof u)f.test(t.name)&&delete t.parent[t.name];else if(t instanceof e){for(var n=0;n<t.nestedArray.length;++n)this.o(t.e[n]);f.test(t.name)&&delete t.parent[t.name]}},h.r=function(t,i,n){r=t,d=i,v=n}},{14:14,15:15,21:21,23:23,33:33}],27:[function(t,i,n){i.exports={}},{}],28:[function(t,i,n){n.Service=t(29)},{29:29}],29:[function(t,i,n){i.exports=r;var o=t(35);function r(t,i,n){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");o.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=!!i,this.responseDelimited=!!n}((r.prototype=Object.create(o.EventEmitter.prototype)).constructor=r).prototype.rpcCall=function t(n,i,r,e,s){if(!e)throw TypeError("request must be specified");var u=this;if(!s)return o.asPromise(t,u,n,i,r,e);if(!u.rpcImpl)return setTimeout(function(){s(Error("already ended"))},0),g;try{return u.rpcImpl(n,i[u.requestDelimited?"encodeDelimited":"encode"](e).finish(),function(t,i){if(t)return u.emit("error",t,n),s(t);if(null===i)return u.end(!0),g;if(!(i instanceof r))try{i=r[u.responseDelimited?"decodeDelimited":"decode"](i)}catch(t){return u.emit("error",t,n),s(t)}return u.emit("data",i,n),s(null,i)})}catch(t){return u.emit("error",t,n),setTimeout(function(){s(t)},0),g}},r.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},{35:35}],30:[function(t,i,n){i.exports=u;var r=t(21),s=(((u.prototype=Object.create(r.prototype)).constructor=u).className="Service",t(20)),o=t(33),h=t(28);function u(t,i){r.call(this,t,i),this.methods={},this.f=null}function e(t){return t.f=null,t}u.fromJSON=function(t,i){var n=new u(t,i.options);if(i.methods)for(var r=Object.keys(i.methods),e=0;e<r.length;++e)n.add(s.fromJSON(r[e],i.methods[r[e]]));return i.nested&&n.addJSON(i.nested),n.comment=i.comment,n},u.prototype.toJSON=function(t){var i=r.prototype.toJSON.call(this,t),n=!!t&&!!t.keepComments;return o.toObject(["options",i&&i.options||g,"methods",r.arrayToJSON(this.methodsArray,t)||{},"nested",i&&i.nested||g,"comment",n?this.comment:g])},Object.defineProperty(u.prototype,"methodsArray",{get:function(){return this.f||(this.f=o.toArray(this.methods))}}),u.prototype.get=function(t){return o.getProp(this.methods,t)||r.prototype.get.call(this,t)},u.prototype.resolveAll=function(){for(var t=this.methodsArray,i=0;i<t.length;++i)t[i].resolve();return r.prototype.resolve.call(this)},u.prototype.add=function(t){if(this.get(t.name))throw Error("duplicate name '"+t.name+"' in "+this);return t instanceof s?e((this.methods[t.name]=t).parent=this):r.prototype.add.call(this,t)},u.prototype.remove=function(t){if(t instanceof s){if(this.methods[t.name]!==t)throw Error(t+" is not a member of "+this);return delete this.methods[t.name],t.parent=null,e(this)}return r.prototype.remove.call(this,t)},u.prototype.create=function(t,i,n){for(var r,e=new h.Service(t,i,n),s=0;s<this.methodsArray.length;++s){var u=o.lcFirst((r=this.f[s]).resolve().name).replace(/[^$\w_]/g,"");e[u]=o.codegen(["r","c"],o.isReserved(u)?u+"_":u)("return this.rpcCall(m,q,s,r,c)")({m:r,q:r.resolvedRequestType.ctor,s:r.resolvedResponseType.ctor})}return e}},{20:20,21:21,28:28,33:33}],31:[function(t,i,n){i.exports=w;var u=t(21),o=(((w.prototype=Object.create(u.prototype)).constructor=w).className="Type",t(14)),h=t(23),f=t(15),c=t(18),a=t(30),e=t(19),s=t(24),l=t(38),d=t(33),v=t(13),b=t(12),p=t(36),y=t(11),m=t(37);function w(t,i){u.call(this,t,i),this.fields={},this.oneofs=g,this.extensions=g,this.reserved=g,this.group=g,this.c=null,this.i=null,this.a=null,this.l=null}function r(t){return t.c=t.i=t.a=null,delete t.encode,delete t.decode,delete t.verify,t}Object.defineProperties(w.prototype,{fieldsById:{get:function(){if(!this.c){this.c={};for(var t=Object.keys(this.fields),i=0;i<t.length;++i){var n=this.fields[t[i]],r=n.id;if(this.c[r])throw Error("duplicate id "+r+" in "+this);this.c[r]=n}}return this.c}},fieldsArray:{get:function(){return this.i||(this.i=d.toArray(this.fields))}},oneofsArray:{get:function(){return this.a||(this.a=d.toArray(this.oneofs))}},ctor:{get:function(){return this.l||(this.ctor=w.generateConstructor(this)())},set:function(t){for(var i=t.prototype,n=(i instanceof e||((t.prototype=new e).constructor=t,d.merge(t.prototype,i)),t.$type=t.prototype.$type=this,d.merge(t,e,!0),this.l=t,0);n<this.fieldsArray.length;++n)this.i[n].resolve();for(var r={},n=0;n<this.oneofsArray.length;++n)r[this.a[n].resolve().name]={get:d.oneOfGetter(this.a[n].oneof),set:d.oneOfSetter(this.a[n].oneof)};n&&Object.defineProperties(t.prototype,r)}}}),w.generateConstructor=function(t){for(var i,n=d.codegen(["p"],t.name),r=0;r<t.fieldsArray.length;++r)(i=t.i[r]).map?n("this%s={}",d.safeProp(i.name)):i.repeated&&n("this%s=[]",d.safeProp(i.name));return n("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]")},w.fromJSON=function(t,i){for(var n=new w(t,i.options),r=(n.extensions=i.extensions,n.reserved=i.reserved,Object.keys(i.fields)),e=0;e<r.length;++e)n.add((void 0!==i.fields[r[e]].keyType?c:f).fromJSON(r[e],i.fields[r[e]]));if(i.oneofs)for(r=Object.keys(i.oneofs),e=0;e<r.length;++e)n.add(h.fromJSON(r[e],i.oneofs[r[e]]));if(i.nested)for(r=Object.keys(i.nested),e=0;e<r.length;++e){var s=i.nested[r[e]];n.add((s.id!==g?f:s.fields!==g?w:s.values!==g?o:s.methods!==g?a:u).fromJSON(r[e],s))}return i.extensions&&i.extensions.length&&(n.extensions=i.extensions),i.reserved&&i.reserved.length&&(n.reserved=i.reserved),i.group&&(n.group=!0),i.comment&&(n.comment=i.comment),n},w.prototype.toJSON=function(t){var i=u.prototype.toJSON.call(this,t),n=!!t&&!!t.keepComments;return d.toObject(["options",i&&i.options||g,"oneofs",u.arrayToJSON(this.oneofsArray,t),"fields",u.arrayToJSON(this.fieldsArray.filter(function(t){return!t.declaringField}),t)||{},"extensions",this.extensions&&this.extensions.length?this.extensions:g,"reserved",this.reserved&&this.reserved.length?this.reserved:g,"group",this.group||g,"nested",i&&i.nested||g,"comment",n?this.comment:g])},w.prototype.resolveAll=function(){for(var t=this.fieldsArray,i=0;i<t.length;)t[i++].resolve();for(var n=this.oneofsArray,i=0;i<n.length;)n[i++].resolve();return u.prototype.resolveAll.call(this)},w.prototype.get=function(t){return d.getProp(this.fields,t)||d.getProp(this.oneofs,t)||d.getProp(this.nested,t)||null},w.prototype.add=function(t){if(this.get(t.name))throw Error("duplicate name '"+t.name+"' in "+this);if(t instanceof f&&t.extend===g){if((this.c||this.fieldsById)[t.id])throw Error("duplicate id "+t.id+" in "+this);if(this.isReservedId(t.id))throw Error("id "+t.id+" is reserved in "+this);if(this.isReservedName(t.name))throw Error("name '"+t.name+"' is reserved in "+this);return t.parent&&t.parent.remove(t),(this.fields[t.name]=t).message=this,t.onAdd(this),r(this)}return t instanceof h?(this.oneofs||(this.oneofs={}),(this.oneofs[t.name]=t).onAdd(this),r(this)):u.prototype.add.call(this,t)},w.prototype.remove=function(t){if(t instanceof f&&t.extend===g){if(this.fields&&this.fields[t.name]===t)return delete this.fields[t.name],t.parent=null,t.onRemove(this),r(this);throw Error(t+" is not a member of "+this)}if(t instanceof h){if(this.oneofs&&this.oneofs[t.name]===t)return delete this.oneofs[t.name],t.parent=null,t.onRemove(this),r(this);throw Error(t+" is not a member of "+this)}return u.prototype.remove.call(this,t)},w.prototype.isReservedId=function(t){return u.isReservedId(this.reserved,t)},w.prototype.isReservedName=function(t){return u.isReservedName(this.reserved,t)},w.prototype.create=function(t){return new this.ctor(t)},w.prototype.setup=function(){for(var t=this.fullName,i=[],n=0;n<this.fieldsArray.length;++n)i.push(this.i[n].resolve().resolvedType);this.encode=v(this)({Writer:l,types:i,util:d}),this.decode=b(this)({Reader:s,types:i,util:d}),this.verify=p(this)({types:i,util:d}),this.fromObject=y.fromObject(this)({types:i,util:d}),this.toObject=y.toObject(this)({types:i,util:d});var r,t=m[t];return t&&((r=Object.create(this)).fromObject=this.fromObject,this.fromObject=t.fromObject.bind(r),r.toObject=this.toObject,this.toObject=t.toObject.bind(r)),this},w.prototype.encode=function(t,i){return this.setup().encode(t,i)},w.prototype.encodeDelimited=function(t,i){return this.encode(t,i&&i.len?i.fork():i).ldelim()},w.prototype.decode=function(t,i){return this.setup().decode(t,i)},w.prototype.decodeDelimited=function(t){return t instanceof s||(t=s.create(t)),this.decode(t,t.uint32())},w.prototype.verify=function(t){return this.setup().verify(t)},w.prototype.fromObject=function(t){return this.setup().fromObject(t)},w.prototype.toObject=function(t,i){return this.setup().toObject(t,i)},w.d=function(i){return function(t){d.decorateType(t,i)}}},{11:11,12:12,13:13,14:14,15:15,18:18,19:19,21:21,23:23,24:24,30:30,33:33,36:36,37:37,38:38}],32:[function(t,i,n){var t=t(33),e=["double","float","int32","uint32","sint32","fixed32","sfixed32","int64","uint64","sint64","fixed64","sfixed64","bool","string","bytes"];function r(t,i){var n=0,r={};for(i|=0;n<t.length;)r[e[n+i]]=t[n++];return r}n.basic=r([1,5,0,0,0,5,5,0,0,0,1,1,0,2,2]),n.defaults=r([0,0,0,0,0,0,0,0,0,0,0,0,!1,"",t.emptyArray,null]),n.long=r([0,0,0,1,1],7),n.mapKey=r([0,0,0,5,5,0,0,0,1,1,0,2],2),n.packed=r([1,5,0,0,0,5,5,0,0,0,1,1,0])},{33:33}],33:[function(n,t,i){var r,e,s=t.exports=n(35),u=n(27),o=(s.codegen=n(3),s.fetch=n(5),s.path=n(8),s.fs=s.inquire("fs"),s.toArray=function(t){if(t){for(var i=Object.keys(t),n=Array(i.length),r=0;r<i.length;)n[r]=t[i[r++]];return n}return[]},s.toObject=function(t){for(var i={},n=0;n<t.length;){var r=t[n++],e=t[n++];e!==g&&(i[r]=e)}return i},/\\/g),h=/"/g,f=(s.isReserved=function(t){return/^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(t)},s.safeProp=function(t){return!/^[$\w_]+$/.test(t)||s.isReserved(t)?'["'+t.replace(o,"\\\\").replace(h,'\\"')+'"]':"."+t},s.getProp=function(t,i){return t&&Object.prototype.hasOwnProperty.call(t,i)?t[i]:g},s.ucFirst=function(t){return(t[0]||"").toUpperCase()+t.substring(1)},/_([a-z])/g),c=(s.camelCase=function(t){return t.substring(0,1)+t.substring(1).replace(f,function(t,i){return i.toUpperCase()})},s.compareFieldsById=function(t,i){return t.id-i.id},s.decorateType=function(t,i){return t.$type?(i&&t.$type.name!==i&&(s.decorateRoot.remove(t.$type),t.$type.name=i,s.decorateRoot.add(t.$type)),t.$type):(i=new(r=r||n(31))(i||t.name),s.decorateRoot.add(i),i.ctor=t,Object.defineProperty(t,"$type",{value:i,enumerable:!1}),Object.defineProperty(t.prototype,"$type",{value:i,enumerable:!1}),i)},0);s.decorateEnum=function(t){var i;return t.$type||(i=new(e=e||n(14))("Enum"+c++,t),s.decorateRoot.add(i),Object.defineProperty(t,"$type",{value:i,enumerable:!1}),i)},s.setProperty=function(t,i,n){if("object"!=typeof t)throw TypeError("dst must be an object");if(i)return function t(i,n,r){var e=n.shift();return"__proto__"!==e&&"prototype"!==e&&(0<n.length?i[e]=t(i[e]||{},n,r):((n=i[e])&&(r=[].concat(n).concat(r)),i[e]=r)),i}(t,i=i.split("."),n);throw TypeError("path must be specified")},Object.defineProperty(s,"decorateRoot",{get:function(){return u.decorated||(u.decorated=new(n(26)))}})},{14:14,26:26,27:27,3:3,31:31,35:35,5:5,8:8}],34:[function(t,i,n){i.exports=e;var r=t(35);function e(t,i){this.lo=t>>>0,this.hi=i>>>0}var s=e.zero=new e(0,0),u=(s.toNumber=function(){return 0},s.zzEncode=s.zzDecode=function(){return this},s.length=function(){return 1},e.zeroHash="\0\0\0\0\0\0\0\0",e.fromNumber=function(t){var i,n;return 0===t?s:(n=(t=(i=t<0)?-t:t)>>>0,t=(t-n)/4294967296>>>0,i&&(t=~t>>>0,n=~n>>>0,4294967295<++n&&(n=0,4294967295<++t&&(t=0))),new e(n,t))},e.from=function(t){if("number"==typeof t)return e.fromNumber(t);if(r.isString(t)){if(!r.Long)return e.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new e(t.low>>>0,t.high>>>0):s},e.prototype.toNumber=function(t){var i;return!t&&this.hi>>>31?(t=1+~this.lo>>>0,i=~this.hi>>>0,-(t+4294967296*(i=t?i:i+1>>>0))):this.lo+4294967296*this.hi},e.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,!!t):{low:0|this.lo,high:0|this.hi,unsigned:!!t}},String.prototype.charCodeAt);e.fromHash=function(t){return"\0\0\0\0\0\0\0\0"===t?s:new e((u.call(t,0)|u.call(t,1)<<8|u.call(t,2)<<16|u.call(t,3)<<24)>>>0,(u.call(t,4)|u.call(t,5)<<8|u.call(t,6)<<16|u.call(t,7)<<24)>>>0)},e.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},e.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},e.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},e.prototype.length=function(){var t=this.lo,i=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0==n?0==i?t<16384?t<128?1:2:t<2097152?3:4:i<16384?i<128?5:6:i<2097152?7:8:n<128?9:10}},{35:35}],35:[function(t,i,n){var r=n;function e(t,i,n){for(var r=Object.keys(i),e=0;e<r.length;++e)t[r[e]]!==g&&n||(t[r[e]]=i[r[e]]);return t}function s(t){function n(t,i){if(!(this instanceof n))return new n(t,i);Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:Error().stack||""}),i&&e(this,i)}return n.prototype=Object.create(Error.prototype,{constructor:{value:n,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return t},set:g,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),n}r.asPromise=t(1),r.base64=t(2),r.EventEmitter=t(4),r.float=t(6),r.inquire=t(7),r.utf8=t(10),r.pool=t(9),r.LongBits=t(34),r.isNode=!!("undefined"!=typeof global&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return"string"==typeof t||t instanceof String},r.isObject=function(t){return t&&"object"==typeof t},r.isset=r.isSet=function(t,i){var n=t[i];return null!=n&&t.hasOwnProperty(i)&&("object"!=typeof n||0<(Array.isArray(n)?n:Object.keys(n)).length)},r.Buffer=function(){try{var t=r.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r.v=null,r.b=null,r.newBuffer=function(t){return"number"==typeof t?r.Buffer?r.b(t):new r.Array(t):r.Buffer?r.v(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,i){t=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(t.lo,t.hi,i):t.toNumber(!!i)},r.merge=e,r.lcFirst=function(t){return(t[0]||"").toLowerCase()+t.substring(1)},r.newError=s,r.ProtocolError=s("ProtocolError"),r.oneOfGetter=function(t){for(var n={},i=0;i<t.length;++i)n[t[i]]=1;return function(){for(var t=Object.keys(this),i=t.length-1;-1<i;--i)if(1===n[t[i]]&&this[t[i]]!==g&&null!==this[t[i]])return t[i]}},r.oneOfSetter=function(n){return function(t){for(var i=0;i<n.length;++i)n[i]!==t&&delete this[n[i]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r.r=function(){var n=r.Buffer;n?(r.v=n.from!==Uint8Array.from&&n.from||function(t,i){return new n(t,i)},r.b=n.allocUnsafe||function(t){return new n(t)}):r.v=r.b=null}},{1:1,10:10,2:2,34:34,4:4,6:6,7:7,9:9}],36:[function(t,i,n){i.exports=function(t){var i=h.codegen(["m"],t.name+"$verify")('if(typeof m!=="object"||m===null)')("return%j","object expected"),n=t.oneofsArray,r={};n.length&&i("var p={}");for(var e=0;e<t.fieldsArray.length;++e){var s,u=t.i[e].resolve(),o="m"+h.safeProp(u.name);u.optional&&i("if(%s!=null&&m.hasOwnProperty(%j)){",o,u.name),u.map?(i("if(!util.isObject(%s))",o)("return%j",f(u,"object"))("var k=Object.keys(%s)",o)("for(var i=0;i<k.length;++i){"),function(t,i,n){switch(i.keyType){case"int32":case"uint32":case"sint32":case"fixed32":case"sfixed32":t("if(!util.key32Re.test(%s))",n)("return%j",f(i,"integer key"));break;case"int64":case"uint64":case"sint64":case"fixed64":case"sfixed64":t("if(!util.key64Re.test(%s))",n)("return%j",f(i,"integer|Long key"));break;case"bool":t("if(!util.key2Re.test(%s))",n)("return%j",f(i,"boolean key"))}}(i,u,"k[i]"),c(i,u,e,o+"[k[i]]")("}")):u.repeated?(i("if(!Array.isArray(%s))",o)("return%j",f(u,"array"))("for(var i=0;i<%s.length;++i){",o),c(i,u,e,o+"[i]")("}")):(u.partOf&&(s=h.safeProp(u.partOf.name),1===r[u.partOf.name]&&i("if(p%s===1)",s)("return%j",u.partOf.name+": multiple values"),r[u.partOf.name]=1,i("p%s=1",s)),c(i,u,e,o)),u.optional&&i("}")}return i("return null")};var u=t(14),h=t(33);function f(t,i){return t.name+": "+i+(t.repeated&&"array"!==i?"[]":t.map&&"object"!==i?"{k:"+t.keyType+"}":"")+" expected"}function c(t,i,n,r){if(i.resolvedType)if(i.resolvedType instanceof u){t("switch(%s){",r)("default:")("return%j",f(i,"enum value"));for(var e=Object.keys(i.resolvedType.values),s=0;s<e.length;++s)t("case %i:",i.resolvedType.values[e[s]]);t("break")("}")}else t("{")("var e=types[%i].verify(%s);",n,r)("if(e)")("return%j+e",i.name+".")("}");else switch(i.type){case"int32":case"uint32":case"sint32":case"fixed32":case"sfixed32":t("if(!util.isInteger(%s))",r)("return%j",f(i,"integer"));break;case"int64":case"uint64":case"sint64":case"fixed64":case"sfixed64":t("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))",r,r,r,r)("return%j",f(i,"integer|Long"));break;case"float":case"double":t('if(typeof %s!=="number")',r)("return%j",f(i,"number"));break;case"bool":t('if(typeof %s!=="boolean")',r)("return%j",f(i,"boolean"));break;case"string":t("if(!util.isString(%s))",r)("return%j",f(i,"string"));break;case"bytes":t('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',r,r,r)("return%j",f(i,"buffer"))}return t}},{14:14,33:33}],37:[function(t,i,n){var u=t(19);n[".google.protobuf.Any"]={fromObject:function(t){if(t&&t["@type"]){var i,n=t["@type"].substring(1+t["@type"].lastIndexOf("/")),n=this.lookup(n);if(n)return~(i="."==(t["@type"][0]||"")?t["@type"].slice(1):t["@type"]).indexOf("/")||(i="/"+i),this.create({type_url:i,value:n.encode(n.fromObject(t)).finish()})}return this.fromObject(t)},toObject:function(t,i){var n,r,e="",s="";return i&&i.json&&t.type_url&&t.value&&(s=t.type_url.substring(1+t.type_url.lastIndexOf("/")),e=t.type_url.substring(0,1+t.type_url.lastIndexOf("/")),(n=this.lookup(s))&&(t=n.decode(t.value))),!(t instanceof this.ctor)&&t instanceof u?(n=t.$type.toObject(t,i),r="."===t.$type.fullName[0]?t.$type.fullName.slice(1):t.$type.fullName,n["@type"]=s=(e=""===e?"type.googleapis.com/":e)+r,n):this.toObject(t,i)}}},{19:19}],38:[function(t,i,n){i.exports=a;var r,e=t(35),s=e.LongBits,u=e.base64,o=e.utf8;function h(t,i,n){this.fn=t,this.len=i,this.next=g,this.val=n}function f(){}function c(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function a(){this.len=0,this.head=new h(f,0,0),this.tail=this.head,this.states=null}function l(){return e.Buffer?function(){return(a.create=function(){return new r})()}:function(){return new a}}function d(t,i,n){i[n]=255&t}function v(t,i){this.len=t,this.next=g,this.val=i}function b(t,i,n){for(;t.hi;)i[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;127<t.lo;)i[n++]=127&t.lo|128,t.lo=t.lo>>>7;i[n++]=t.lo}function p(t,i,n){i[n]=255&t,i[n+1]=t>>>8&255,i[n+2]=t>>>16&255,i[n+3]=t>>>24}a.create=l(),a.alloc=function(t){return new e.Array(t)},e.Array!==Array&&(a.alloc=e.pool(a.alloc,e.Array.prototype.subarray)),a.prototype.p=function(t,i,n){return this.tail=this.tail.next=new h(t,i,n),this.len+=i,this},(v.prototype=Object.create(h.prototype)).fn=function(t,i,n){for(;127<t;)i[n++]=127&t|128,t>>>=7;i[n]=t},a.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new v((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},a.prototype.int32=function(t){return t<0?this.p(b,10,s.fromNumber(t)):this.uint32(t)},a.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},a.prototype.int64=a.prototype.uint64=function(t){t=s.from(t);return this.p(b,t.length(),t)},a.prototype.sint64=function(t){t=s.from(t).zzEncode();return this.p(b,t.length(),t)},a.prototype.bool=function(t){return this.p(d,1,t?1:0)},a.prototype.sfixed32=a.prototype.fixed32=function(t){return this.p(p,4,t>>>0)},a.prototype.sfixed64=a.prototype.fixed64=function(t){t=s.from(t);return this.p(p,4,t.lo).p(p,4,t.hi)},a.prototype.float=function(t){return this.p(e.float.writeFloatLE,4,t)},a.prototype.double=function(t){return this.p(e.float.writeDoubleLE,8,t)};var y=e.Array.prototype.set?function(t,i,n){i.set(t,n)}:function(t,i,n){for(var r=0;r<t.length;++r)i[n+r]=t[r]};a.prototype.bytes=function(t){var i,n=t.length>>>0;return n?(e.isString(t)&&(i=a.alloc(n=u.length(t)),u.decode(t,i,0),t=i),this.uint32(n).p(y,n,t)):this.p(d,1,0)},a.prototype.string=function(t){var i=o.length(t);return i?this.uint32(i).p(o.write,i,t):this.p(d,1,0)},a.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new h(f,0,0),this.len=0,this},a.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new h(f,0,0),this.len=0),this},a.prototype.ldelim=function(){var t=this.head,i=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=i,this.len+=n),this},a.prototype.finish=function(){for(var t=this.head.next,i=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,i,n),n+=t.len,t=t.next;return i},a.r=function(t){r=t,a.create=l(),r.r()}},{35:35}],39:[function(t,i,n){i.exports=s;var r=t(38),e=((s.prototype=Object.create(r.prototype)).constructor=s,t(35));function s(){r.call(this)}function u(t,i,n){t.length<40?e.utf8.write(t,i,n):i.utf8Write?i.utf8Write(t,n):i.write(t,n)}s.r=function(){s.alloc=e.b,s.writeBytesBuffer=e.Buffer&&e.Buffer.prototype instanceof Uint8Array&&"set"===e.Buffer.prototype.set.name?function(t,i,n){i.set(t,n)}:function(t,i,n){if(t.copy)t.copy(i,n,0,t.length);else for(var r=0;r<t.length;)i[n++]=t[r++]}},s.prototype.bytes=function(t){var i=(t=e.isString(t)?e.v(t,"base64"):t).length>>>0;return this.uint32(i),i&&this.p(s.writeBytesBuffer,i,t),this},s.prototype.string=function(t){var i=e.Buffer.byteLength(t);return this.uint32(i),i&&this.p(u,i,t),this},s.r()},{35:35,38:38}]},{},[16])}();
//# sourceMappingURL=protobuf.min.js.map
{"version":3,"sources":["lib/prelude.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/codegen/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/fetch/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/path/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/@protobufjs/utf8/index.js","../src/converter.js","../src/decoder.js","../src/encoder.js","../src/enum.js","../src/field.js","../src/index-light","../src/index-minimal.js","../src/mapfield.js","../src/message.js","../src/method.js","../src/namespace.js","../src/object.js","../src/oneof.js","../src/reader.js","../src/reader_buffer.js","../src/root.js","../src/roots.js","../src/rpc.js","../src/rpc/service.js","../src/service.js","../src/type.js","../src/types.js","../src/util.js","../src/util/longbits.js","../src/util/minimal.js","../src/verifier.js","../src/wrappers.js","../src/writer.js","../src/writer_buffer.js"],"names":["undefined","modules","cache","entries","protobuf","$require","name","$module","call","exports","util","global","define","amd","Long","isLong","configure","module","1","require","fn","ctx","params","Array","arguments","length","offset","index","pending","Promise","resolve","reject","err","apply","base64","string","p","n","Math","ceil","b64","s64","i","encode","buffer","start","end","t","parts","chunk","j","b","push","String","fromCharCode","slice","join","invalidEncoding","decode","c","charCodeAt","Error","test","codegen","functionParams","functionName","body","Codegen","formatStringOrScope","source","toString","verbose","console","log","scopeKeys","Object","keys","scopeParams","scopeValues","scopeOffset","Function","formatParams","formatOffset","replace","$0","$1","value","Number","floor","JSON","stringify","functionNameOverride","EventEmitter","this","_listeners","prototype","on","evt","off","listeners","splice","emit","args","fetch","asPromise","fs","filename","options","callback","xhr","readFile","contents","XMLHttpRequest","binary","onreadystatechange","readyState","status","response","responseText","Uint8Array","overrideMimeType","responseType","open","send","factory","writeFloat_ieee754","writeUint","val","buf","pos","sign","isNaN","round","exponent","LN2","pow","readFloat_ieee754","readUint","uint","mantissa","NaN","Infinity","writeFloat_f32_cpy","f32","f8b","writeFloat_f32_rev","readFloat_f32_cpy","readFloat_f32_rev","f64","le","writeDouble_ieee754","off0","off1","readDouble_ieee754","lo","hi","writeDouble_f64_cpy","writeDouble_f64_rev","readDouble_f64_cpy","readDouble_f64_rev","Float32Array","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","bind","writeUintLE","writeUintBE","readUintLE","readUintBE","Float64Array","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","inquire","moduleName","mod","eval","e","isAbsolute","path","normalize","split","absolute","prefix","shift","originPath","includePath","alreadyNormalized","alloc","size","SIZE","MAX","slab","utf8","len","read","write","c1","c2","Enum","genValuePartial_fromObject","gen","field","fieldIndex","prop","defaultAlreadyEmitted","resolvedType","values","typeDefault","repeated","fullName","isUnsigned","type","genValuePartial_toObject","converter","fromObject","mtype","fields","fieldsArray","safeProp","map","toObject","sort","compareFieldsById","repeatedFields","mapFields","normalFields","partOf","arrayDefault","valuesById","long","low","high","unsigned","toNumber","bytes","hasKs2","_fieldsArray","indexOf","filter","group","ref","id","types","defaults","keyType","basic","packed","rfield","required","wireType","mapKey","genTypePartial","optional","ReflectionObject","Namespace","create","constructor","className","comment","comments","valuesOptions","TypeError","reserved","fromJSON","json","enm","toJSON","toJSONOptions","keepComments","Boolean","add","isString","isInteger","isReservedId","isReservedName","allow_alias","remove","Field","Type","ruleRe","rule","extend","isObject","toLowerCase","message","defaultValue","extensionField","declaringField","_packed","defineProperty","get","getOption","setOption","ifNotSet","resolved","parent","lookupTypeOrEnum","proto3_optional","fromNumber","freeze","newBuffer","emptyObject","emptyArray","ctor","d","fieldId","fieldType","fieldRule","decorateType","decorateEnum","fieldName","default","_configure","Type_","build","load","root","Root","loadSync","encoder","decoder","verifier","OneOf","MapField","Service","Method","Message","wrappers","Writer","BufferWriter","Reader","BufferReader","rpc","roots","resolvedKeyType","fieldKeyType","fieldValueType","properties","$type","writer","encodeDelimited","reader","decodeDelimited","verify","object","requestType","requestStream","responseStream","parsedOptions","resolvedRequestType","resolvedResponseType","lookupType","arrayToJSON","array","obj","nested","_nestedArray","clearCache","namespace","addJSON","toArray","nestedArray","nestedJson","names","methods","getProp","getEnum","prev","setOptions","onAdd","onRemove","isArray","ptr","part","resolveAll","lookup","filterTypes","parentAlreadyChecked","found","lookupEnum","lookupService","Service_","Enum_","defineProperties","unshift","_handleAdd","_handleRemove","setParsedOption","propName","opt","newOpt","find","hasOwnProperty","newValue","setProperty","Root_","fieldNames","oneof","addFieldsToParent","oneofName","oneOfGetter","set","oneOfSetter","LongBits","indexOutOfRange","writeLength","RangeError","Buffer","isBuffer","create_array","readLongVarint","bits","readFixed32_end","readFixed64","_slice","subarray","uint32","int32","sint32","bool","fixed32","sfixed32","float","double","nativeBuffer","skip","skipType","BufferReader_","merge","int64","uint64","sint64","zzDecode","fixed64","sfixed64","utf8Slice","min","parse","common","deferred","files","SYNC","resolvePath","self","sync","finish","cb","getBundledFileName","idx","lastIndexOf","altname","substring","process","parsed","imports","weakImports","queued","weak","setTimeout","readFileSync","isNode","exposeRe","tryHandleExtension","sisterField","extendedType","parse_","common_","rpcImpl","requestDelimited","responseDelimited","rpcCall","method","requestCtor","responseCtor","request","endedByRPC","_methodsArray","service","inherited","methodsArray","rpcService","methodName","lcFirst","isReserved","m","q","s","oneofs","extensions","_fieldsById","_oneofsArray","_ctor","fieldsById","oneofsArray","generateConstructor","ctorProperties","setup","originalThis","wrapper","fork","ldelim","typeName","target","bake","o","safePropBackslashRe","key","safePropQuoteRe","camelCaseRe","ucFirst","str","toUpperCase","decorateEnumIndex","camelCase","a","decorateRoot","enumerable","dst","setProp","prevValue","concat","zero","zzEncode","zeroHash","from","parseInt","fromString","toLong","fromHash","hash","toHash","mask","part0","part1","part2","src","newError","CustomError","captureStackTrace","stack","writable","configurable","pool","versions","node","window","isFinite","isset","isSet","utf8Write","_Buffer_from","_Buffer_allocUnsafe","sizeOrArray","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","fromBits","ProtocolError","fieldMap","longs","enums","encoding","allocUnsafe","seenFirstField","oneofProp","invalid","genVerifyValue","expected","type_url","messageName","Op","next","noop","State","head","tail","states","writeByte","VarintOp","writeVarint64","writeFixed32","_push","writeBytes","reset","BufferWriter_","writeStringBuffer","writeBytesBuffer","copy","byteLength"],"mappings":"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","file":"protobuf.min.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = codegen;\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\r\nfunction codegen(functionParams, functionName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof functionParams === \"string\") {\r\n        functionName = functionParams;\r\n        functionParams = undefined;\r\n    }\r\n\r\n    var body = [];\r\n\r\n    /**\r\n     * Appends code to the function's body or finishes generation.\r\n     * @typedef Codegen\r\n     * @type {function}\r\n     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n     * @param {...*} [formatParams] Format parameters\r\n     * @returns {Codegen|Function} Itself or the generated function if finished\r\n     * @throws {Error} If format parameter counts do not match\r\n     */\r\n\r\n    function Codegen(formatStringOrScope) {\r\n        // note that explicit array handling below makes this ~50% faster\r\n\r\n        // finish the function\r\n        if (typeof formatStringOrScope !== \"string\") {\r\n            var source = toString();\r\n            if (codegen.verbose)\r\n                console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n            source = \"return \" + source;\r\n            if (formatStringOrScope) {\r\n                var scopeKeys   = Object.keys(formatStringOrScope),\r\n                    scopeParams = new Array(scopeKeys.length + 1),\r\n                    scopeValues = new Array(scopeKeys.length),\r\n                    scopeOffset = 0;\r\n                while (scopeOffset < scopeKeys.length) {\r\n                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                }\r\n                scopeParams[scopeOffset] = source;\r\n                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n            }\r\n            return Function(source)(); // eslint-disable-line no-new-func\r\n        }\r\n\r\n        // otherwise append to body\r\n        var formatParams = new Array(arguments.length - 1),\r\n            formatOffset = 0;\r\n        while (formatOffset < formatParams.length)\r\n            formatParams[formatOffset] = arguments[++formatOffset];\r\n        formatOffset = 0;\r\n        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n            var value = formatParams[formatOffset++];\r\n            switch ($1) {\r\n                case \"d\": case \"f\": return String(Number(value));\r\n                case \"i\": return String(Math.floor(value));\r\n                case \"j\": return JSON.stringify(value);\r\n                case \"s\": return String(value);\r\n            }\r\n            return \"%\";\r\n        });\r\n        if (formatOffset !== formatParams.length)\r\n            throw Error(\"parameter count mismatch\");\r\n        body.push(formatStringOrScope);\r\n        return Codegen;\r\n    }\r\n\r\n    function toString(functionNameOverride) {\r\n        return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n    }\r\n\r\n    Codegen.toString = toString;\r\n    return Codegen;\r\n}\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\r\ncodegen.verbose = false;\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\nmodule.exports = fetch;\r\n\r\nvar asPromise = require(1),\r\n    inquire   = require(7);\r\n\r\nvar fs = inquire(\"fs\");\r\n\r\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nfunction fetch(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (!options)\r\n        options = {};\r\n\r\n    if (!callback)\r\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\r\n\r\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\r\n    if (!options.xhr && fs && fs.readFile)\r\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\r\n            return err && typeof XMLHttpRequest !== \"undefined\"\r\n                ? fetch.xhr(filename, options, callback)\r\n                : err\r\n                ? callback(err)\r\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\r\n        });\r\n\r\n    // use the XHR version otherwise.\r\n    return fetch.xhr(filename, options, callback);\r\n}\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\r\n\r\n/**/\r\nfetch.xhr = function fetch_xhr(filename, options, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\r\n\r\n        if (xhr.readyState !== 4)\r\n            return undefined;\r\n\r\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\r\n        // reliably distinguished from an actually empty file for security reasons. feel free\r\n        // to send a pull request if you are aware of a solution.\r\n        if (xhr.status !== 0 && xhr.status !== 200)\r\n            return callback(Error(\"status \" + xhr.status));\r\n\r\n        // if binary data is expected, make sure that some sort of array is returned, even if\r\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\r\n        if (options.binary) {\r\n            var buffer = xhr.response;\r\n            if (!buffer) {\r\n                buffer = [];\r\n                for (var i = 0; i < xhr.responseText.length; ++i)\r\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\r\n            }\r\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\r\n        }\r\n        return callback(null, xhr.responseText);\r\n    };\r\n\r\n    if (options.binary) {\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\r\n        if (\"overrideMimeType\" in xhr)\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        xhr.responseType = \"arraybuffer\";\r\n    }\r\n\r\n    xhr.open(\"GET\", filename);\r\n    xhr.send();\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal path module to resolve Unix, Windows and URL paths alike.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar path = exports;\r\n\r\nvar isAbsolute =\r\n/**\r\n * Tests if the specified path is absolute.\r\n * @param {string} path Path to test\r\n * @returns {boolean} `true` if path is absolute\r\n */\r\npath.isAbsolute = function isAbsolute(path) {\r\n    return /^(?:\\/|\\w+:)/.test(path);\r\n};\r\n\r\nvar normalize =\r\n/**\r\n * Normalizes the specified path.\r\n * @param {string} path Path to normalize\r\n * @returns {string} Normalized path\r\n */\r\npath.normalize = function normalize(path) {\r\n    path = path.replace(/\\\\/g, \"/\")\r\n               .replace(/\\/{2,}/g, \"/\");\r\n    var parts    = path.split(\"/\"),\r\n        absolute = isAbsolute(path),\r\n        prefix   = \"\";\r\n    if (absolute)\r\n        prefix = parts.shift() + \"/\";\r\n    for (var i = 0; i < parts.length;) {\r\n        if (parts[i] === \"..\") {\r\n            if (i > 0 && parts[i - 1] !== \"..\")\r\n                parts.splice(--i, 2);\r\n            else if (absolute)\r\n                parts.splice(i, 1);\r\n            else\r\n                ++i;\r\n        } else if (parts[i] === \".\")\r\n            parts.splice(i, 1);\r\n        else\r\n            ++i;\r\n    }\r\n    return prefix + parts.join(\"/\");\r\n};\r\n\r\n/**\r\n * Resolves the specified include path against the specified origin path.\r\n * @param {string} originPath Path to the origin file\r\n * @param {string} includePath Include path relative to origin path\r\n * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized\r\n * @returns {string} Path to the include file\r\n */\r\npath.resolve = function resolve(originPath, includePath, alreadyNormalized) {\r\n    if (!alreadyNormalized)\r\n        includePath = normalize(includePath);\r\n    if (isAbsolute(includePath))\r\n        return includePath;\r\n    if (!alreadyNormalized)\r\n        originPath = normalize(originPath);\r\n    return (originPath = originPath.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? normalize(originPath + \"/\" + includePath) : includePath;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */\nvar converter = exports;\n\nvar Enum = require(14),\n    util = require(33);\n\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(d%s){\", prop);\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen\n                    (\"default:\")\n                        (\"if(typeof(d%s)===\\\"number\\\"){m%s=d%s;break}\", prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                                             // arrays, to avoid leaving holes.\n                        (\"break\");           // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen\n                (\"case%j:\", keys[i])\n                (\"case %i:\", values[keys[i]])\n                    (\"m%s=%j\", prop, values[keys[i]])\n                    (\"break\");\n            } gen\n            (\"}\");\n        } else gen\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\": gen\n                (\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\": gen\n                (\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(util.Long)\")\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n                    (\"m%s=d%s\", prop, prop)\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\": gen\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n                (\"else if(d%s.length >= 0)\", prop)\n                    (\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\": gen\n                (\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\": gen\n                (\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n            /* default: gen\n                (\"m%s=d%s\", prop, prop);\n                break; */\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray;\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n    (\"if(d instanceof this.ctor)\")\n        (\"return d\");\n    if (!fields.length) return gen\n    (\"return new this.ctor\");\n    gen\n    (\"var m=new this.ctor\");\n    for (var i = 0; i < fields.length; ++i) {\n        var field  = fields[i].resolve(),\n            prop   = util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) { gen\n    (\"if(d%s){\", prop)\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n        (\"m%s={}\", prop)\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n        (\"}\")\n    (\"}\");\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(d%s){\", prop)\n        (\"if(!Array.isArray(d%s))\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n        (\"m%s=[]\", prop)\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n        (\"}\")\n    (\"}\");\n\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen\n    (\"}\");\n        }\n    } return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen\n            (\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n            (\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n                break;\n            case \"bytes\": gen\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default: gen\n            (\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length)\n        return util.codegen()(\"return {}\");\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n    (\"if(!o)\")\n        (\"o={}\")\n    (\"var d={}\");\n\n    var repeatedFields = [],\n        mapFields = [],\n        normalFields = [],\n        i = 0;\n    for (; i < fields.length; ++i)\n        if (!fields[i].partOf)\n            ( fields[i].resolve().repeated ? repeatedFields\n            : fields[i].map ? mapFields\n            : normalFields).push(fields[i]);\n\n    if (repeatedFields.length) { gen\n    (\"if(o.arrays||o.defaults){\");\n        for (i = 0; i < repeatedFields.length; ++i) gen\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (mapFields.length) { gen\n    (\"if(o.objects||o.defaults){\");\n        for (i = 0; i < mapFields.length; ++i) gen\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (normalFields.length) { gen\n    (\"if(o.defaults){\");\n        for (i = 0; i < normalFields.length; ++i) {\n            var field = normalFields[i],\n                prop  = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen\n        (\"if(util.Long){\")\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n        (\"}else\")\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n        (\"else{\")\n            (\"d%s=%s\", prop, arrayDefault)\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n        (\"}\");\n            } else gen\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        } gen\n    (\"}\");\n    }\n    var hasKs2 = false;\n    for (i = 0; i < fields.length; ++i) {\n        var field = fields[i],\n            index = mtype._fieldsArray.indexOf(field),\n            prop  = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) { hasKs2 = true; gen\n    (\"var ks2\");\n            } gen\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n        (\"d%s={}\", prop)\n        (\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n        (\"}\");\n        } else if (field.repeated) { gen\n    (\"if(m%s&&m%s.length){\", prop, prop)\n        (\"d%s=[]\", prop)\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n        (\"}\");\n        } else { gen\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n        if (field.partOf) gen\n        (\"if(o.oneofs)\")\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen\n    (\"}\");\n    }\n    return gen\n    (\"return d\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n","\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(14),\n    types   = require(32),\n    util    = require(33);\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i: {\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\")\n            (\"}\");\n        // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n","\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(14),\n    types    = require(32),\n    util     = require(33);\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n","\"use strict\";\nmodule.exports = Enum;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\nvar Namespace = require(21),\n    util = require(33);\n\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */\nfunction Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */\n    this.valuesOptions = valuesOptions;\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"       , this.options,\n        \"valuesOptions\" , this.valuesOptions,\n        \"values\"        , this.values,\n        \"reserved\"      , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"       , keepComments ? this.comment : undefined,\n        \"comments\"      , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    if (options) {\n        if (this.valuesOptions === undefined)\n            this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions)\n        delete this.valuesOptions[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n","\"use strict\";\nmodule.exports = Field;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\n\nvar Enum  = require(14),\n    types = require(32),\n    util  = require(33);\n\nvar Type; // cyclic\n\nvar ruleRe = /^required|optional|repeated$/;\n\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */\nField.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction Field(name, id, type, rule, extend, options, comment) {\n\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n\n    ReflectionObject.call(this, name, options);\n\n    if (!util.isInteger(id) || id < 0)\n        throw TypeError(\"id must be a non-negative integer\");\n\n    if (!util.isString(type))\n        throw TypeError(\"type must be a string\");\n\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))\n        throw TypeError(\"rule must be a string rule\");\n\n    if (extend !== undefined && !util.isString(extend))\n        throw TypeError(\"extend must be a string\");\n\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */\n    if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n\n    /**\n     * Field type.\n     * @type {string}\n     */\n    this.type = type; // toJSON\n\n    /**\n     * Unique field id.\n     * @type {number}\n     */\n    this.id = id; // toJSON, marker\n\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */\n    this.extend = extend || undefined; // toJSON\n\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */\n    this.required = rule === \"required\";\n\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */\n    this.optional = !this.required;\n\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */\n    this.repeated = rule === \"repeated\";\n\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */\n    this.map = false;\n\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */\n    this.message = null;\n\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */\n    this.partOf = null;\n\n    /**\n     * The field type's default value.\n     * @type {*}\n     */\n    this.typeDefault = null;\n\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */\n    this.defaultValue = null;\n\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */\n    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */\n    this.bytes = type === \"bytes\";\n\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */\n    this.resolvedType = null;\n\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */\n    this.extensionField = null;\n\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */\n    this.declaringField = null;\n\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */\n    this._packed = null;\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */\nObject.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null)\n            this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n\n/**\n * @override\n */\nField.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") // clear cached before setting\n        this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */\n\n/**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */\n\n/**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */\nField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\"    , this.rule !== \"optional\" && this.rule || undefined,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */\nField.prototype.resolve = function resolve() {\n\n    if (this.resolved)\n        return this;\n\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type)\n            this.typeDefault = null;\n        else // instanceof Enum\n            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\")\n            this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))\n            delete this.options.packed;\n        if (!Object.keys(this.options).length)\n            this.options = undefined;\n    }\n\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n\n        /* istanbul ignore else */\n        if (Object.freeze)\n            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault))\n            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else\n            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n\n    // take special care of maps and repeated fields\n    if (this.map)\n        this.defaultValue = util.emptyObject;\n    else if (this.repeated)\n        this.defaultValue = util.emptyArray;\n    else\n        this.defaultValue = this.typeDefault;\n\n    // ensure proper value on prototype\n    if (this.parent instanceof Type)\n        this.parent.ctor.prototype[this.name] = this.defaultValue;\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */\nField.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\")\n        fieldType = util.decorateType(fieldType).name;\n\n    // enum reference: create a reflected copy of the enum and keep reuseing it\n    else if (fieldType && typeof fieldType === \"object\")\n        fieldType = util.decorateEnum(fieldType).name;\n\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { \"default\": defaultValue }));\n    };\n};\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */\n// like Field.d but without a default value\n\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n","\"use strict\";\nvar protobuf = module.exports = require(17);\n\nprotobuf.build = \"light\";\n\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */\nfunction load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root)\n        root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */\n// function load(filename:string, [root:Root]):Promise<Root>\n\nprotobuf.load = load;\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */\nfunction loadSync(filename, root) {\n    if (!root)\n        root = new protobuf.Root();\n    return root.loadSync(filename);\n}\n\nprotobuf.loadSync = loadSync;\n\n// Serialization\nprotobuf.encoder          = require(13);\nprotobuf.decoder          = require(12);\nprotobuf.verifier         = require(36);\nprotobuf.converter        = require(11);\n\n// Reflection\nprotobuf.ReflectionObject = require(22);\nprotobuf.Namespace        = require(21);\nprotobuf.Root             = require(26);\nprotobuf.Enum             = require(14);\nprotobuf.Type             = require(31);\nprotobuf.Field            = require(15);\nprotobuf.OneOf            = require(23);\nprotobuf.MapField         = require(18);\nprotobuf.Service          = require(30);\nprotobuf.Method           = require(20);\n\n// Runtime\nprotobuf.Message          = require(19);\nprotobuf.wrappers         = require(37);\n\n// Utility\nprotobuf.types            = require(32);\nprotobuf.util             = require(33);\n\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(38);\nprotobuf.BufferWriter = require(39);\nprotobuf.Reader       = require(24);\nprotobuf.BufferReader = require(25);\n\n// Utility\nprotobuf.util         = require(35);\nprotobuf.rpc          = require(28);\nprotobuf.roots        = require(27);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(15);\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types   = require(32),\n    util    = require(33);\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n    /* istanbul ignore if */\n    if (!util.isString(keyType))\n        throw TypeError(\"keyType must be a string\");\n\n    /**\n     * Key type.\n     * @type {string}\n     */\n    this.keyType = keyType; // toJSON, marker\n\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */\n    this.resolvedKeyType = null;\n\n    // Overrides Field#map\n    this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\" , this.keyType,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined)\n        throw Error(\"invalid key type: \" + this.keyType);\n\n    return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\")\n        fieldValueType = util.decorateType(fieldValueType).name;\n\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\n    else if (fieldValueType && typeof fieldValueType === \"object\")\n        fieldValueType = util.decorateEnum(fieldValueType).name;\n\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n","\"use strict\";\nmodule.exports = Message;\n\nvar util = require(35);\n\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */\nfunction Message(properties) {\n    // not used internally\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            this[keys[i]] = properties[keys[i]];\n}\n\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */\n\n/**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */\n\n/*eslint-disable valid-jsdoc*/\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.create = function create(properties) {\n    return this.$type.create(properties);\n};\n\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */\nMessage.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */\nMessage.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n};\n\n/*eslint-enable valid-jsdoc*/","\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(33);\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Options properly parsed into an object\n     */\n    this.parsedOptions = parsedOptions;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined,\n        \"parsedOptions\"  , this.parsedOptions,\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n","\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(15),\n    util     = require(33),\n    OneOf    = require(23);\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n","\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(33);\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n","\"use strict\";\nmodule.exports = OneOf;\n\n// extends ReflectionObject\nvar ReflectionObject = require(22);\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\n\nvar Field = require(15),\n    util  = require(33);\n\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n\n    /* istanbul ignore if */\n    if (!(fieldNames === undefined || Array.isArray(fieldNames)))\n        throw TypeError(\"fieldNames must be an Array\");\n\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */\n    this.oneof = fieldNames || []; // toJSON, marker\n\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */\n    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */\n\n/**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */\nOneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */\nOneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , this.options,\n        \"oneof\"   , this.oneof,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */\nfunction addFieldsToParent(oneof) {\n    if (oneof.parent)\n        for (var i = 0; i < oneof.fieldsArray.length; ++i)\n            if (!oneof.fieldsArray[i].parent)\n                oneof.parent.add(oneof.fieldsArray[i]);\n}\n\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */\nOneOf.prototype.add = function add(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    if (field.parent && field.parent !== this.parent)\n        field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */\nOneOf.prototype.remove = function remove(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    var index = this.fieldsArray.indexOf(field);\n\n    /* istanbul ignore if */\n    if (index < 0)\n        throw Error(field + \" is not a member of \" + this);\n\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n\n    /* istanbul ignore else */\n    if (index > -1) // theoretical\n        this.oneof.splice(index, 1);\n\n    field.partOf = null;\n    return this;\n};\n\n/**\n * @override\n */\nOneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for (var i = 0; i < this.oneof.length; ++i) {\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n\n/**\n * @override\n */\nOneOf.prototype.onRemove = function onRemove(parent) {\n    for (var i = 0, field; i < this.fieldsArray.length; ++i)\n        if ((field = this.fieldsArray[i]).parent)\n            field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */\n\n/**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */\nOneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length),\n        index = 0;\n    while (index < arguments.length)\n        fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor)\n            .add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(35);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(24);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(35);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Root;\n\n// extends Namespace\nvar Namespace = require(21);\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\n\nvar Field   = require(15),\n    Enum    = require(14),\n    OneOf   = require(23),\n    util    = require(33);\n\nvar Type,   // cyclic\n    parse,  // might be excluded\n    common; // \"\n\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */\nfunction Root(options) {\n    Namespace.call(this, \"\", options);\n\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */\n    this.deferred = [];\n\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */\n    this.files = [];\n}\n\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */\nRoot.fromJSON = function fromJSON(json, root) {\n    if (!root)\n        root = new Root();\n    if (json.options)\n        root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */\nRoot.prototype.resolvePath = util.path.resolve;\n\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.fetch = util.fetch;\n\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */\nfunction SYNC() {} // eslint-disable-line no-empty-function\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */\nRoot.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback)\n        return util.asPromise(load, self, filename, options);\n\n    var sync = callback === SYNC; // undocumented\n\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */\n        if (!callback)\n            return;\n        if (sync)\n            throw err;\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\")\n                source = JSON.parse(source);\n            if (!util.isString(source))\n                self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options),\n                    resolved,\n                    i = 0;\n                if (parsed.imports)\n                    for (; i < parsed.imports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))\n                            fetch(resolved);\n                if (parsed.weakImports)\n                    for (i = 0; i < parsed.weakImports.length; ++i)\n                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))\n                            fetch(resolved, true);\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued)\n            finish(null, self); // only once anyway\n    }\n\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1)\n            return;\n        self.files.push(filename);\n\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync)\n                process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak)\n                    finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */\n                if (!callback)\n                    return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */\n                    if (!weak)\n                        finish(err);\n                    else if (!queued) // can't be covered reliably\n                        finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename))\n        filename = [ filename ];\n    for (var i = 0, resolved; i < filename.length; ++i)\n        if (resolved = self.resolvePath(\"\", filename[i]))\n            fetch(resolved);\n\n    if (sync)\n        return self;\n    if (!queued)\n        finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */\n// function load(filename:string, [options:IParseOptions]):Promise<Root>\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */\nRoot.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode)\n        throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n\n/**\n * @override\n */\nRoot.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length)\n        throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n            return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n        }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */\nfunction tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)\n            if (!tryHandleExtension(this, object))\n                this.deferred.push(object);\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object.values; // expose enum values as property of its parent\n\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n\n        if (object instanceof Type) // Try to handle any deferred extensions\n            for (var i = 0; i < this.deferred.length;)\n                if (tryHandleExtension(this, this.deferred[i]))\n                    this.deferred.splice(i, 1);\n                else\n                    ++i;\n        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace\n            this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name))\n            object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n\n    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n    // properties of namespaces just like static code does. This allows using a .d.ts generated for\n    // a static module with reflection-based solutions where the condition is met.\n};\n\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */\nRoot.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) { // remove its sister field\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else { // cancel the extension\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */\n                if (index > -1)\n                    this.deferred.splice(index, 1);\n            }\n        }\n\n    } else if (object instanceof Enum) {\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose enum values\n\n    } else if (object instanceof Namespace) {\n\n        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace\n            this._handleRemove(object._nestedArray[i]);\n\n        if (exposeRe.test(object.name))\n            delete object.parent[object.name]; // unexpose namespaces\n\n    }\n};\n\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type   = Type_;\n    parse  = parse_;\n    common = common_;\n};\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(29);\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(35);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = Service;\n\n// extends Namespace\nvar Namespace = require(21);\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\n\nvar Method = require(20),\n    util   = require(33),\n    rpc    = require(28);\n\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */\nfunction Service(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */\n    this.methods = {}; // toJSON, marker\n\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */\n    this._methodsArray = null;\n}\n\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */\n\n/**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */\nService.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */\n    if (json.methods)\n        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)\n            service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested)\n        service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */\nService.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , inherited && inherited.options || undefined,\n        \"methods\" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\"  , inherited && inherited.nested || undefined,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */\nObject.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\n\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n\n/**\n * @override\n */\nService.prototype.get = function get(name) {\n    return util.getProp(this.methods, name)\n        || Namespace.prototype.get.call(this, name);\n};\n\n/**\n * @override\n */\nService.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for (var i = 0; i < methods.length; ++i)\n        methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n\n/**\n * @override\n */\nService.prototype.add = function add(object) {\n\n    /* istanbul ignore if */\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * @override\n */\nService.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n\n        /* istanbul ignore if */\n        if (this.methods[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */\nService.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\"r\",\"c\"], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n","\"use strict\";\nmodule.exports = Type;\n\n// extends Namespace\nvar Namespace = require(21);\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum      = require(14),\n    OneOf     = require(23),\n    Field     = require(15),\n    MapField  = require(18),\n    Service   = require(30),\n    Message   = require(19),\n    Reader    = require(24),\n    Writer    = require(38),\n    util      = require(33),\n    encoder   = require(13),\n    decoder   = require(12),\n    verifier  = require(36),\n    converter = require(11),\n    wrappers  = require(37);\n\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */\nfunction Type(name, options) {\n    Namespace.call(this, name, options);\n\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */\n    this.fields = {};  // toJSON, marker\n\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */\n    this.oneofs = undefined; // toJSON\n\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */\n    this.extensions = undefined; // toJSON\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */\n    this.group = undefined; // toJSON\n\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */\n    this._fieldsById = null;\n\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */\n    this._fieldsArray = null;\n\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */\n    this._oneofsArray = null;\n\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */\n    this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */\n    fieldsById: {\n        get: function() {\n\n            /* istanbul ignore if */\n            if (this._fieldsById)\n                return this._fieldsById;\n\n            this._fieldsById = {};\n            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n                var field = this.fields[names[i]],\n                    id = field.id;\n\n                /* istanbul ignore if */\n                if (this._fieldsById[id])\n                    throw Error(\"duplicate id \" + id + \" in \" + this);\n\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */\n    fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */\n    oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */\n    ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n\n            this._ctor = ctor;\n\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for (; i < /* initializes */ this.fieldsArray.length; ++i)\n                this._fieldsArray[i].resolve(); // ensures a proper value\n\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)\n                ctorProperties[this._oneofsArray[i].resolve().name] = {\n                    get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                    set: util.oneOfSetter(this._oneofsArray[i].oneof)\n                };\n            if (i)\n                Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nType.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"p\"], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)\n        if ((field = mtype._fieldsArray[i]).map) gen\n            (\"this%s={}\", util.safeProp(field.name));\n        else if (field.repeated) gen\n            (\"this%s=[]\", util.safeProp(field.name));\n    return gen\n    (\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n        (\"this[ks[i]]=p[ks[i]]\");\n    /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */\n\n/**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */\nType.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields),\n        i = 0;\n    for (; i < names.length; ++i)\n        type.add(\n            ( typeof json.fields[names[i]].keyType !== \"undefined\"\n            ? MapField.fromJSON\n            : Field.fromJSON )(names[i], json.fields[names[i]])\n        );\n    if (json.oneofs)\n        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)\n            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested)\n        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n            var nested = json.nested[names[i]];\n            type.add( // most to least likely\n                ( nested.id !== undefined\n                ? Field.fromJSON\n                : nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    if (json.extensions && json.extensions.length)\n        type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length)\n        type.reserved = json.reserved;\n    if (json.group)\n        type.group = true;\n    if (json.comment)\n        type.comment = json.comment;\n    return type;\n};\n\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"    , inherited && inherited.options || undefined,\n        \"oneofs\"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},\n        \"extensions\" , this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\"   , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\"      , this.group || undefined,\n        \"nested\"     , inherited && inherited.nested || undefined,\n        \"comment\"    , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nType.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while (i < fields.length)\n        fields[i++].resolve();\n    var oneofs = this.oneofsArray; i = 0;\n    while (i < oneofs.length)\n        oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n\n/**\n * @override\n */\nType.prototype.get = function get(name) {\n    return util.getProp(this.fields, name)\n        || util.getProp(this.oneofs, name)\n        || util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */\nType.prototype.add = function add(object) {\n\n    if (this.get(object.name))\n        throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])\n            throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id))\n            throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name))\n            throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n\n        if (object.parent)\n            object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs)\n            this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */\nType.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n\n        /* istanbul ignore if */\n        if (!this.fields || this.fields[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n\n        /* istanbul ignore if */\n        if (!this.oneofs || this.oneofs[object.name] !== object)\n            throw Error(object + \" is not a member of \" + this);\n\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nType.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */\nType.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */\nType.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n\n    var fullName = this.fullName,\n        types    = [];\n    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)\n        types.push(this._fieldsArray[i].resolve().resolvedType);\n\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer : Writer,\n        types  : types,\n        util   : util\n    });\n    this.decode = decoder(this)({\n        Reader : Reader,\n        types  : types,\n        util   : util\n    });\n    this.verify = verifier(this)({\n        types : types,\n        util  : util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types : types,\n        util  : util\n    });\n    this.toObject = converter.toObject(this)({\n        types : types,\n        util  : util\n    });\n\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n            originalThis.fromObject = this.fromObject;\n            this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n            originalThis.toObject = this.toObject;\n            this.toObject = wrapper.toObject.bind(originalThis);\n        // }\n    }\n\n    return this;\n};\n\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */\nType.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader))\n        reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */\nType.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */\nType.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */\nType.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */\n\n/**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */\nType.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n","\"use strict\";\n\n/**\n * Common type constants.\n * @namespace\n */\nvar types = exports;\n\nvar util = require(33);\n\nvar s = [\n    \"double\",   // 0\n    \"float\",    // 1\n    \"int32\",    // 2\n    \"uint32\",   // 3\n    \"sint32\",   // 4\n    \"fixed32\",  // 5\n    \"sfixed32\", // 6\n    \"int64\",    // 7\n    \"uint64\",   // 8\n    \"sint64\",   // 9\n    \"fixed64\",  // 10\n    \"sfixed64\", // 11\n    \"bool\",     // 12\n    \"string\",   // 13\n    \"bytes\"     // 14\n];\n\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while (i < values.length) o[s[i + offset]] = values[i++];\n    return o;\n}\n\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */\ntypes.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */\ntypes.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */\ntypes.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */\ntypes.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */\ntypes.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n","\"use strict\";\n\n/**\n * Various utility functions.\n * @namespace\n */\nvar util = module.exports = require(35);\n\nvar roots = require(27);\n\nvar Type, // cyclic\n    Enum;\n\nutil.codegen = require(3);\nutil.fetch   = require(5);\nutil.path    = require(8);\n\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */\nutil.fs = util.inquire(\"fs\");\n\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */\nutil.toArray = function toArray(object) {\n    if (object) {\n        var keys  = Object.keys(object),\n            array = new Array(keys.length),\n            index = 0;\n        while (index < keys.length)\n            array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */\nutil.toObject = function toObject(array) {\n    var object = {},\n        index  = 0;\n    while (index < array.length) {\n        var key = array[index++],\n            val = array[index++];\n        if (val !== undefined)\n            object[key] = val;\n    }\n    return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe     = /\"/g;\n\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nutil.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */\nutil.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n    return \".\" + prop;\n};\n\n/**\n * Returns the value of a property found directly in a given object.\n * @param {Object} object Source object\n * @param {string} prop Property name\n * @returns {*} Value or `undefined` if not set\n */\nutil.getProp = function get(object, prop) {\n    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;\n};\n\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.camelCase = function camelCase(str) {\n    return str.substring(0, 1)\n         + str.substring(1)\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\n};\n\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */\nutil.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */\nutil.decorateType = function decorateType(ctor, typeName) {\n\n    /* istanbul ignore if */\n    if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n\n    /* istanbul ignore next */\n    if (!Type)\n        Type = require(31);\n\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\n    return type;\n};\n\nvar decorateEnumIndex = 0;\n\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */\nutil.decorateEnum = function decorateEnum(object) {\n\n    /* istanbul ignore if */\n    if (object.$type)\n        return object.$type;\n\n    /* istanbul ignore next */\n    if (!Enum)\n        Enum = require(14);\n\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\n    return enm;\n};\n\n\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */\nutil.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n          return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue)\n                value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n\n    if (typeof dst !== \"object\")\n        throw TypeError(\"dst must be an object\");\n    if (!path)\n        throw TypeError(\"path must be specified\");\n\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */\nObject.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(26))());\n    }\n});\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(35);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(4);\n\n// float handling accross browsers\nutil.float = require(6);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(7);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(10);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(9);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(34);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = verifier;\n\nvar Enum      = require(14),\n    util      = require(33);\n\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\"+field.keyType+\"}\" : \"\") + \" expected\";\n}\n\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(%s){\", ref)\n                (\"default:\")\n                    (\"return%j\", invalid(field, \"enum value\"));\n            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen\n                (\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen\n                    (\"break\")\n            (\"}\");\n        } else {\n            gen\n            (\"{\")\n                (\"var e=types[%i].verify(%s);\", fieldIndex, ref)\n                (\"if(e)\")\n                    (\"return%j+e\", field.name + \".\")\n            (\"}\");\n        }\n    } else {\n        switch (field.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\": gen\n                (\"if(!util.isInteger(%s))\", ref)\n                    (\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)\n                    (\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\": gen\n                (\"if(typeof %s!==\\\"number\\\")\", ref)\n                    (\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\": gen\n                (\"if(typeof %s!==\\\"boolean\\\")\", ref)\n                    (\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\": gen\n                (\"if(!util.isString(%s))\", ref)\n                    (\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\": gen\n                (\"if(!(%s&&typeof %s.length===\\\"number\\\"||util.isString(%s)))\", ref, ref, ref)\n                    (\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */\n    switch (field.keyType) {\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\": gen\n            (\"if(!util.key32Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\": gen\n            (\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n                (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\": gen\n            (\"if(!util.key2Re.test(%s))\", ref)\n                (\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline */\n}\n\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n\n    var gen = util.codegen([\"m\"], mtype.name + \"$verify\")\n    (\"if(typeof m!==\\\"object\\\"||m===null)\")\n        (\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray,\n        seenFirstField = {};\n    if (oneofs.length) gen\n    (\"var p={}\");\n\n    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            ref   = \"m\" + util.safeProp(field.name);\n\n        if (field.optional) gen\n        (\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n\n        // map fields\n        if (field.map) { gen\n            (\"if(!util.isObject(%s))\", ref)\n                (\"return%j\", invalid(field, \"object\"))\n            (\"var k=Object.keys(%s)\", ref)\n            (\"for(var i=0;i<k.length;++i){\");\n                genVerifyKey(gen, field, \"k[i]\");\n                genVerifyValue(gen, field, i, ref + \"[k[i]]\")\n            (\"}\");\n\n        // repeated fields\n        } else if (field.repeated) { gen\n            (\"if(!Array.isArray(%s))\", ref)\n                (\"return%j\", invalid(field, \"array\"))\n            (\"for(var i=0;i<%s.length;++i){\", ref);\n                genVerifyValue(gen, field, i, ref + \"[i]\")\n            (\"}\");\n\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen\n            (\"if(p%s===1)\", oneofProp)\n                (\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen\n            (\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen\n        (\"}\");\n    }\n    return gen\n    (\"return null\");\n    /* eslint-enable no-unexpected-multiline */\n}","\"use strict\";\n\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */\nvar wrappers = exports;\n\nvar Message = require(19);\n\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */\n\n/**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */\n\n/**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */\n\n// Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n\n    fromObject: function(object) {\n\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n             // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ?\n                    object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n\n        return this.fromObject(object);\n    },\n\n    toObject: function(message, options) {\n\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */\n            if (type)\n                message = type.decode(message.value);\n        }\n\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ?\n                message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n\n        return this.toObject(message, options);\n    }\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(35);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(38);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(35);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"sourceRoot":"."}/*!
 * protobuf.js v7.3.2-postman.2 (c) 2016, daniel wirtz
 * compiled fri, 19 jul 2024 16:26:24 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
(function(undefined){"use strict";(function prelude(modules, cache, entries) {

    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
    // sources through a conflict-free require shim and is again wrapped within an iife that
    // provides a minification-friendly `undefined` var plus a global "use strict" directive
    // so that minification can remove the directives of each module.

    function $require(name) {
        var $module = cache[name];
        if (!$module)
            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);
        return $module.exports;
    }

    var protobuf = $require(entries[0]);

    // Expose globally
    protobuf.util.global.protobuf = protobuf;

    // Be nice to AMD
    if (typeof define === "function" && define.amd)
        define(["long"], function(Long) {
            if (Long && Long.isLong) {
                protobuf.util.Long = Long;
                protobuf.configure();
            }
            return protobuf;
        });

    // Be nice to CommonJS
    if (typeof module === "object" && module && module.exports)
        module.exports = protobuf;

})/* end of prelude */({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],4:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],5:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],6:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],7:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],8:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require(16);
protobuf.BufferWriter = require(17);
protobuf.Reader       = require(9);
protobuf.BufferReader = require(10);

// Utility
protobuf.util         = require(15);
protobuf.rpc          = require(12);
protobuf.roots        = require(11);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"10":10,"11":11,"12":12,"15":15,"16":16,"17":17,"9":9}],9:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require(15);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);

    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
        var nativeBuffer = util.Buffer;
        return nativeBuffer
            ? nativeBuffer.alloc(0)
            : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"15":15}],10:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require(9);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require(15);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"15":15,"9":9}],11:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],12:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require(13);

},{"13":13}],13:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require(15);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"15":15}],14:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require(15);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"15":15}],15:[function(require,module,exports){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require(1);

// converts to / from base64 encoded strings
util.base64 = require(2);

// base class of rpc.Service
util.EventEmitter = require(3);

// float handling accross browsers
util.float = require(4);

// requires modules optionally and hides the call from bundlers
util.inquire = require(5);

// converts to / from utf8 encoded strings
util.utf8 = require(7);

// provides a node-like buffer pool in the browser
util.pool = require(6);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require(14);

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true,
        },
        name: {
            get: function get() { return name; },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true,
        },
        toString: {
            value: function value() { return this.name + ": " + this.message; },
            writable: true,
            enumerable: false,
            configurable: true,
        },
    });

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

},{"1":1,"14":14,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7}],16:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require(15);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"15":15}],17:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require(16);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require(15);

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"15":15,"16":16}]},{},[8])

})();
//# sourceMappingURL=protobuf.js.map
{"version":3,"sources":["lib/prelude.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/@protobufjs/utf8/index.js","../src/index-minimal","../src/reader.js","../src/reader_buffer.js","../src/roots.js","../src/rpc.js","../src/rpc/service.js","../src/util/longbits.js","../src/util/minimal.js","../src/writer.js","../src/writer_buffer.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"protobuf.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(16);\nprotobuf.BufferWriter = require(17);\nprotobuf.Reader       = require(9);\nprotobuf.BufferReader = require(10);\n\n// Utility\nprotobuf.util         = require(15);\nprotobuf.rpc          = require(12);\nprotobuf.roots        = require(11);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(15);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(9);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(15);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(13);\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(15);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(15);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(3);\n\n// float handling accross browsers\nutil.float = require(4);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(5);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(7);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(6);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(14);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(15);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(16);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(15);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"sourceRoot":"."}/*!
 * protobuf.js v7.3.2-postman.2 (c) 2016, daniel wirtz
 * compiled fri, 19 jul 2024 16:26:24 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
!function(d){"use strict";!function(r,u,t){var n=function t(n){var i=u[n];return i||r[n][0].call(i=u[n]={exports:{}},t,i,i.exports),i.exports}(t[0]);n.util.global.protobuf=n,"function"==typeof define&&define.amd&&define(["long"],function(t){return t&&t.isLong&&(n.util.Long=t,n.configure()),n}),"object"==typeof module&&module&&module.exports&&(module.exports=n)}({1:[function(t,n,i){n.exports=function(t,n){var i=Array(arguments.length-1),e=0,r=2,s=!0;for(;r<arguments.length;)i[e++]=arguments[r++];return new Promise(function(r,u){i[e]=function(t){if(s)if(s=!1,t)u(t);else{for(var n=Array(arguments.length-1),i=0;i<n.length;)n[i++]=arguments[i];r.apply(null,n)}};try{t.apply(n||null,i)}catch(t){s&&(s=!1,u(t))}})}},{}],2:[function(t,n,i){i.length=function(t){var n=t.length;if(!n)return 0;for(var i=0;1<--n%4&&"="==(t[0|n]||"");)++i;return Math.ceil(3*t.length)/4-i};for(var f=Array(64),o=Array(123),r=0;r<64;)o[f[r]=r<26?r+65:r<52?r+71:r<62?r-4:r-59|43]=r++;i.encode=function(t,n,i){for(var r,u=null,e=[],s=0,h=0;n<i;){var o=t[n++];switch(h){case 0:e[s++]=f[o>>2],r=(3&o)<<4,h=1;break;case 1:e[s++]=f[r|o>>4],r=(15&o)<<2,h=2;break;case 2:e[s++]=f[r|o>>6],e[s++]=f[63&o],h=0}8191<s&&((u=u||[]).push(String.fromCharCode.apply(String,e)),s=0)}return h&&(e[s++]=f[r],e[s++]=61,1===h&&(e[s++]=61)),u?(s&&u.push(String.fromCharCode.apply(String,e.slice(0,s))),u.join("")):String.fromCharCode.apply(String,e.slice(0,s))};var c="invalid encoding";i.decode=function(t,n,i){for(var r,u=i,e=0,s=0;s<t.length;){var h=t.charCodeAt(s++);if(61==h&&1<e)break;if((h=o[h])===d)throw Error(c);switch(e){case 0:r=h,e=1;break;case 1:n[i++]=r<<2|(48&h)>>4,r=h,e=2;break;case 2:n[i++]=(15&r)<<4|(60&h)>>2,r=h,e=3;break;case 3:n[i++]=(3&r)<<6|h,e=0}}if(1===e)throw Error(c);return i-u},i.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},{}],3:[function(t,n,i){function r(){this.t={}}(n.exports=r).prototype.on=function(t,n,i){return(this.t[t]||(this.t[t]=[])).push({fn:n,ctx:i||this}),this},r.prototype.off=function(t,n){if(t===d)this.t={};else if(n===d)this.t[t]=[];else for(var i=this.t[t],r=0;r<i.length;)i[r].fn===n?i.splice(r,1):++r;return this},r.prototype.emit=function(t){var n=this.t[t];if(n){for(var i=[],r=1;r<arguments.length;)i.push(arguments[r++]);for(r=0;r<n.length;)n[r].fn.apply(n[r++].ctx,i)}return this}},{}],4:[function(t,n,i){function r(t){function n(t,n,i,r){var u=n<0?1:0;t(0===(n=u?-n:n)?0<1/n?0:2147483648:isNaN(n)?2143289344:34028234663852886e22<n?(u<<31|2139095040)>>>0:n<11754943508222875e-54?(u<<31|Math.round(n/1401298464324817e-60))>>>0:(u<<31|127+(t=Math.floor(Math.log(n)/Math.LN2))<<23|8388607&Math.round(n*Math.pow(2,-t)*8388608))>>>0,i,r)}function i(t,n,i){t=t(n,i),n=2*(t>>31)+1,i=t>>>23&255,t&=8388607;return 255==i?t?NaN:1/0*n:0==i?1401298464324817e-60*n*t:n*Math.pow(2,i-150)*(8388608+t)}function r(t,n,i){h[0]=t,n[i]=o[0],n[i+1]=o[1],n[i+2]=o[2],n[i+3]=o[3]}function u(t,n,i){h[0]=t,n[i]=o[3],n[i+1]=o[2],n[i+2]=o[1],n[i+3]=o[0]}function e(t,n){return o[0]=t[n],o[1]=t[n+1],o[2]=t[n+2],o[3]=t[n+3],h[0]}function s(t,n){return o[3]=t[n],o[2]=t[n+1],o[1]=t[n+2],o[0]=t[n+3],h[0]}var h,o,f,c,a;function l(t,n,i,r,u,e){var s,h=r<0?1:0;0===(r=h?-r:r)?(t(0,u,e+n),t(0<1/r?0:2147483648,u,e+i)):isNaN(r)?(t(0,u,e+n),t(2146959360,u,e+i)):17976931348623157e292<r?(t(0,u,e+n),t((h<<31|2146435072)>>>0,u,e+i)):r<22250738585072014e-324?(t((s=r/5e-324)>>>0,u,e+n),t((h<<31|s/4294967296)>>>0,u,e+i)):(t(4503599627370496*(s=r*Math.pow(2,-(r=1024===(r=Math.floor(Math.log(r)/Math.LN2))?1023:r)))>>>0,u,e+n),t((h<<31|r+1023<<20|1048576*s&1048575)>>>0,u,e+i))}function v(t,n,i,r,u){n=t(r,u+n),t=t(r,u+i),r=2*(t>>31)+1,u=t>>>20&2047,i=4294967296*(1048575&t)+n;return 2047==u?i?NaN:1/0*r:0==u?5e-324*r*i:r*Math.pow(2,u-1075)*(i+4503599627370496)}function w(t,n,i){f[0]=t,n[i]=c[0],n[i+1]=c[1],n[i+2]=c[2],n[i+3]=c[3],n[i+4]=c[4],n[i+5]=c[5],n[i+6]=c[6],n[i+7]=c[7]}function b(t,n,i){f[0]=t,n[i]=c[7],n[i+1]=c[6],n[i+2]=c[5],n[i+3]=c[4],n[i+4]=c[3],n[i+5]=c[2],n[i+6]=c[1],n[i+7]=c[0]}function y(t,n){return c[0]=t[n],c[1]=t[n+1],c[2]=t[n+2],c[3]=t[n+3],c[4]=t[n+4],c[5]=t[n+5],c[6]=t[n+6],c[7]=t[n+7],f[0]}function g(t,n){return c[7]=t[n],c[6]=t[n+1],c[5]=t[n+2],c[4]=t[n+3],c[3]=t[n+4],c[2]=t[n+5],c[1]=t[n+6],c[0]=t[n+7],f[0]}return"undefined"!=typeof Float32Array?(h=new Float32Array([-0]),o=new Uint8Array(h.buffer),a=128===o[3],t.writeFloatLE=a?r:u,t.writeFloatBE=a?u:r,t.readFloatLE=a?e:s,t.readFloatBE=a?s:e):(t.writeFloatLE=n.bind(null,d),t.writeFloatBE=n.bind(null,A),t.readFloatLE=i.bind(null,p),t.readFloatBE=i.bind(null,m)),"undefined"!=typeof Float64Array?(f=new Float64Array([-0]),c=new Uint8Array(f.buffer),a=128===c[7],t.writeDoubleLE=a?w:b,t.writeDoubleBE=a?b:w,t.readDoubleLE=a?y:g,t.readDoubleBE=a?g:y):(t.writeDoubleLE=l.bind(null,d,0,4),t.writeDoubleBE=l.bind(null,A,4,0),t.readDoubleLE=v.bind(null,p,0,4),t.readDoubleBE=v.bind(null,m,4,0)),t}function d(t,n,i){n[i]=255&t,n[i+1]=t>>>8&255,n[i+2]=t>>>16&255,n[i+3]=t>>>24}function A(t,n,i){n[i]=t>>>24,n[i+1]=t>>>16&255,n[i+2]=t>>>8&255,n[i+3]=255&t}function p(t,n){return(t[n]|t[n+1]<<8|t[n+2]<<16|t[n+3]<<24)>>>0}function m(t,n){return(t[n]<<24|t[n+1]<<16|t[n+2]<<8|t[n+3])>>>0}n.exports=r(r)},{}],5:[function(t,n,i){function r(t){try{var n=eval("require")(t);if(n&&(n.length||Object.keys(n).length))return n}catch(t){}return null}n.exports=r},{}],6:[function(t,n,i){n.exports=function(n,i,t){var r=t||8192,u=r>>>1,e=null,s=r;return function(t){if(t<1||u<t)return n(t);r<s+t&&(e=n(r),s=0);t=i.call(e,s,s+=t);return 7&s&&(s=1+(7|s)),t}}},{}],7:[function(t,n,i){i.length=function(t){for(var n,i=0,r=0;r<t.length;++r)(n=t.charCodeAt(r))<128?i+=1:n<2048?i+=2:55296==(64512&n)&&56320==(64512&t.charCodeAt(r+1))?(++r,i+=4):i+=3;return i},i.read=function(t,n,i){if(i-n<1)return"";for(var r,u=null,e=[],s=0;n<i;)(r=t[n++])<128?e[s++]=r:191<r&&r<224?e[s++]=(31&r)<<6|63&t[n++]:239<r&&r<365?(r=((7&r)<<18|(63&t[n++])<<12|(63&t[n++])<<6|63&t[n++])-65536,e[s++]=55296+(r>>10),e[s++]=56320+(1023&r)):e[s++]=(15&r)<<12|(63&t[n++])<<6|63&t[n++],8191<s&&((u=u||[]).push(String.fromCharCode.apply(String,e)),s=0);return u?(s&&u.push(String.fromCharCode.apply(String,e.slice(0,s))),u.join("")):String.fromCharCode.apply(String,e.slice(0,s))},i.write=function(t,n,i){for(var r,u,e=i,s=0;s<t.length;++s)(r=t.charCodeAt(s))<128?n[i++]=r:(r<2048?n[i++]=r>>6|192:(55296==(64512&r)&&56320==(64512&(u=t.charCodeAt(s+1)))?(++s,n[i++]=(r=65536+((1023&r)<<10)+(1023&u))>>18|240,n[i++]=r>>12&63|128):n[i++]=r>>12|224,n[i++]=r>>6&63|128),n[i++]=63&r|128);return i-e}},{}],8:[function(t,n,i){var r=i;function u(){r.util.n(),r.Writer.n(r.BufferWriter),r.Reader.n(r.BufferReader)}r.build="minimal",r.Writer=t(16),r.BufferWriter=t(17),r.Reader=t(9),r.BufferReader=t(10),r.util=t(15),r.rpc=t(12),r.roots=t(11),r.configure=u,u()},{10:10,11:11,12:12,15:15,16:16,17:17,9:9}],9:[function(t,n,i){n.exports=o;var r,u=t(15),e=u.LongBits,s=u.utf8;function h(t,n){return RangeError("index out of range: "+t.pos+" + "+(n||1)+" > "+t.len)}function o(t){this.buf=t,this.pos=0,this.len=t.length}function f(){return u.Buffer?function(t){return(o.create=function(t){return u.Buffer.isBuffer(t)?new r(t):a(t)})(t)}:a}var c,a="undefined"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new o(t);throw Error("illegal buffer")}:function(t){if(Array.isArray(t))return new o(t);throw Error("illegal buffer")};function l(){var t=new e(0,0),n=0;if(!(4<this.len-this.pos)){for(;n<3;++n){if(this.pos>=this.len)throw h(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*n)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*n)>>>0,t}for(;n<4;++n)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*n)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(n=0,4<this.len-this.pos){for(;n<5;++n)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*n+3)>>>0,this.buf[this.pos++]<128)return t}else for(;n<5;++n){if(this.pos>=this.len)throw h(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*n+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}function v(t,n){return(t[n-4]|t[n-3]<<8|t[n-2]<<16|t[n-1]<<24)>>>0}function w(){if(this.pos+8>this.len)throw h(this,8);return new e(v(this.buf,this.pos+=4),v(this.buf,this.pos+=4))}o.create=f(),o.prototype.i=u.Array.prototype.subarray||u.Array.prototype.slice,o.prototype.uint32=(c=4294967295,function(){if(c=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(c=(c|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128||(c=(c|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128||(c=(c|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128||(c=(c|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128||!((this.pos+=5)>this.len))))))return c;throw this.pos=this.len,h(this,10)}),o.prototype.int32=function(){return 0|this.uint32()},o.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},o.prototype.bool=function(){return 0!==this.uint32()},o.prototype.fixed32=function(){if(this.pos+4>this.len)throw h(this,4);return v(this.buf,this.pos+=4)},o.prototype.sfixed32=function(){if(this.pos+4>this.len)throw h(this,4);return 0|v(this.buf,this.pos+=4)},o.prototype.float=function(){if(this.pos+4>this.len)throw h(this,4);var t=u.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},o.prototype.double=function(){if(this.pos+8>this.len)throw h(this,4);var t=u.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},o.prototype.bytes=function(){var t=this.uint32(),n=this.pos,i=this.pos+t;if(i>this.len)throw h(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(n,i):n===i?(t=u.Buffer)?t.alloc(0):new this.buf.constructor(0):this.i.call(this.buf,n,i)},o.prototype.string=function(){var t=this.bytes();return s.read(t,0,t.length)},o.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw h(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw h(this)}while(128&this.buf[this.pos++]);return this},o.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this},o.n=function(t){r=t,o.create=f(),r.n();var n=u.Long?"toLong":"toNumber";u.merge(o.prototype,{int64:function(){return l.call(this)[n](!1)},uint64:function(){return l.call(this)[n](!0)},sint64:function(){return l.call(this).zzDecode()[n](!1)},fixed64:function(){return w.call(this)[n](!0)},sfixed64:function(){return w.call(this)[n](!1)}})}},{15:15}],10:[function(t,n,i){n.exports=e;var r=t(9),u=((e.prototype=Object.create(r.prototype)).constructor=e,t(15));function e(t){r.call(this,t)}e.n=function(){u.Buffer&&(e.prototype.i=u.Buffer.prototype.slice)},e.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+t,this.len))},e.n()},{15:15,9:9}],11:[function(t,n,i){n.exports={}},{}],12:[function(t,n,i){i.Service=t(13)},{13:13}],13:[function(t,n,i){n.exports=r;var h=t(15);function r(t,n,i){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");h.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=!!n,this.responseDelimited=!!i}((r.prototype=Object.create(h.EventEmitter.prototype)).constructor=r).prototype.rpcCall=function t(i,n,r,u,e){if(!u)throw TypeError("request must be specified");var s=this;if(!e)return h.asPromise(t,s,i,n,r,u);if(!s.rpcImpl)return setTimeout(function(){e(Error("already ended"))},0),d;try{return s.rpcImpl(i,n[s.requestDelimited?"encodeDelimited":"encode"](u).finish(),function(t,n){if(t)return s.emit("error",t,i),e(t);if(null===n)return s.end(!0),d;if(!(n instanceof r))try{n=r[s.responseDelimited?"decodeDelimited":"decode"](n)}catch(t){return s.emit("error",t,i),e(t)}return s.emit("data",n,i),e(null,n)})}catch(t){return s.emit("error",t,i),setTimeout(function(){e(t)},0),d}},r.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},{15:15}],14:[function(t,n,i){n.exports=u;var r=t(15);function u(t,n){this.lo=t>>>0,this.hi=n>>>0}var e=u.zero=new u(0,0),s=(e.toNumber=function(){return 0},e.zzEncode=e.zzDecode=function(){return this},e.length=function(){return 1},u.zeroHash="\0\0\0\0\0\0\0\0",u.fromNumber=function(t){var n,i;return 0===t?e:(i=(t=(n=t<0)?-t:t)>>>0,t=(t-i)/4294967296>>>0,n&&(t=~t>>>0,i=~i>>>0,4294967295<++i&&(i=0,4294967295<++t&&(t=0))),new u(i,t))},u.from=function(t){if("number"==typeof t)return u.fromNumber(t);if(r.isString(t)){if(!r.Long)return u.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new u(t.low>>>0,t.high>>>0):e},u.prototype.toNumber=function(t){var n;return!t&&this.hi>>>31?(t=1+~this.lo>>>0,n=~this.hi>>>0,-(t+4294967296*(n=t?n:n+1>>>0))):this.lo+4294967296*this.hi},u.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,!!t):{low:0|this.lo,high:0|this.hi,unsigned:!!t}},String.prototype.charCodeAt);u.fromHash=function(t){return"\0\0\0\0\0\0\0\0"===t?e:new u((s.call(t,0)|s.call(t,1)<<8|s.call(t,2)<<16|s.call(t,3)<<24)>>>0,(s.call(t,4)|s.call(t,5)<<8|s.call(t,6)<<16|s.call(t,7)<<24)>>>0)},u.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},u.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},u.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},u.prototype.length=function(){var t=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,i=this.hi>>>24;return 0==i?0==n?t<16384?t<128?1:2:t<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:i<128?9:10}},{15:15}],15:[function(t,n,i){var r=i;function u(t,n,i){for(var r=Object.keys(n),u=0;u<r.length;++u)t[r[u]]!==d&&i||(t[r[u]]=n[r[u]]);return t}function e(t){function i(t,n){if(!(this instanceof i))return new i(t,n);Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,i):Object.defineProperty(this,"stack",{value:Error().stack||""}),n&&u(this,n)}return i.prototype=Object.create(Error.prototype,{constructor:{value:i,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return t},set:d,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),i}r.asPromise=t(1),r.base64=t(2),r.EventEmitter=t(3),r.float=t(4),r.inquire=t(5),r.utf8=t(7),r.pool=t(6),r.LongBits=t(14),r.isNode=!!("undefined"!=typeof global&&global&&global.process&&global.process.versions&&global.process.versions.node),r.global=r.isNode&&global||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return"string"==typeof t||t instanceof String},r.isObject=function(t){return t&&"object"==typeof t},r.isset=r.isSet=function(t,n){var i=t[n];return null!=i&&t.hasOwnProperty(n)&&("object"!=typeof i||0<(Array.isArray(i)?i:Object.keys(i)).length)},r.Buffer=function(){try{var t=r.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r.r=null,r.u=null,r.newBuffer=function(t){return"number"==typeof t?r.Buffer?r.u(t):new r.Array(t):r.Buffer?r.r(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,n){t=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(t.lo,t.hi,n):t.toNumber(!!n)},r.merge=u,r.lcFirst=function(t){return(t[0]||"").toLowerCase()+t.substring(1)},r.newError=e,r.ProtocolError=e("ProtocolError"),r.oneOfGetter=function(t){for(var i={},n=0;n<t.length;++n)i[t[n]]=1;return function(){for(var t=Object.keys(this),n=t.length-1;-1<n;--n)if(1===i[t[n]]&&this[t[n]]!==d&&null!==this[t[n]])return t[n]}},r.oneOfSetter=function(i){return function(t){for(var n=0;n<i.length;++n)i[n]!==t&&delete this[i[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r.n=function(){var i=r.Buffer;i?(r.r=i.from!==Uint8Array.from&&i.from||function(t,n){return new i(t,n)},r.u=i.allocUnsafe||function(t){return new i(t)}):r.r=r.u=null}},{1:1,14:14,2:2,3:3,4:4,5:5,6:6,7:7}],16:[function(t,n,i){n.exports=a;var r,u=t(15),e=u.LongBits,s=u.base64,h=u.utf8;function o(t,n,i){this.fn=t,this.len=n,this.next=d,this.val=i}function f(){}function c(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function a(){this.len=0,this.head=new o(f,0,0),this.tail=this.head,this.states=null}function l(){return u.Buffer?function(){return(a.create=function(){return new r})()}:function(){return new a}}function v(t,n,i){n[i]=255&t}function w(t,n){this.len=t,this.next=d,this.val=n}function b(t,n,i){for(;t.hi;)n[i++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;127<t.lo;)n[i++]=127&t.lo|128,t.lo=t.lo>>>7;n[i++]=t.lo}function y(t,n,i){n[i]=255&t,n[i+1]=t>>>8&255,n[i+2]=t>>>16&255,n[i+3]=t>>>24}a.create=l(),a.alloc=function(t){return new u.Array(t)},u.Array!==Array&&(a.alloc=u.pool(a.alloc,u.Array.prototype.subarray)),a.prototype.e=function(t,n,i){return this.tail=this.tail.next=new o(t,n,i),this.len+=n,this},(w.prototype=Object.create(o.prototype)).fn=function(t,n,i){for(;127<t;)n[i++]=127&t|128,t>>>=7;n[i]=t},a.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new w((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},a.prototype.int32=function(t){return t<0?this.e(b,10,e.fromNumber(t)):this.uint32(t)},a.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},a.prototype.int64=a.prototype.uint64=function(t){t=e.from(t);return this.e(b,t.length(),t)},a.prototype.sint64=function(t){t=e.from(t).zzEncode();return this.e(b,t.length(),t)},a.prototype.bool=function(t){return this.e(v,1,t?1:0)},a.prototype.sfixed32=a.prototype.fixed32=function(t){return this.e(y,4,t>>>0)},a.prototype.sfixed64=a.prototype.fixed64=function(t){t=e.from(t);return this.e(y,4,t.lo).e(y,4,t.hi)},a.prototype.float=function(t){return this.e(u.float.writeFloatLE,4,t)},a.prototype.double=function(t){return this.e(u.float.writeDoubleLE,8,t)};var g=u.Array.prototype.set?function(t,n,i){n.set(t,i)}:function(t,n,i){for(var r=0;r<t.length;++r)n[i+r]=t[r]};a.prototype.bytes=function(t){var n,i=t.length>>>0;return i?(u.isString(t)&&(n=a.alloc(i=s.length(t)),s.decode(t,n,0),t=n),this.uint32(i).e(g,i,t)):this.e(v,1,0)},a.prototype.string=function(t){var n=h.length(t);return n?this.uint32(n).e(h.write,n,t):this.e(v,1,0)},a.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new o(f,0,0),this.len=0,this},a.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new o(f,0,0),this.len=0),this},a.prototype.ldelim=function(){var t=this.head,n=this.tail,i=this.len;return this.reset().uint32(i),i&&(this.tail.next=t.next,this.tail=n,this.len+=i),this},a.prototype.finish=function(){for(var t=this.head.next,n=this.constructor.alloc(this.len),i=0;t;)t.fn(t.val,n,i),i+=t.len,t=t.next;return n},a.n=function(t){r=t,a.create=l(),r.n()}},{15:15}],17:[function(t,n,i){n.exports=e;var r=t(16),u=((e.prototype=Object.create(r.prototype)).constructor=e,t(15));function e(){r.call(this)}function s(t,n,i){t.length<40?u.utf8.write(t,n,i):n.utf8Write?n.utf8Write(t,i):n.write(t,i)}e.n=function(){e.alloc=u.u,e.writeBytesBuffer=u.Buffer&&u.Buffer.prototype instanceof Uint8Array&&"set"===u.Buffer.prototype.set.name?function(t,n,i){n.set(t,i)}:function(t,n,i){if(t.copy)t.copy(n,i,0,t.length);else for(var r=0;r<t.length;)n[i++]=t[r++]}},e.prototype.bytes=function(t){var n=(t=u.isString(t)?u.r(t,"base64"):t).length>>>0;return this.uint32(n),n&&this.e(e.writeBytesBuffer,n,t),this},e.prototype.string=function(t){var n=u.Buffer.byteLength(t);return this.uint32(n),n&&this.e(s,n,t),this},e.n()},{15:15,16:16}]},{},[8])}();
//# sourceMappingURL=protobuf.min.js.map
{"version":3,"sources":["lib/prelude.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/@protobufjs/utf8/index.js","../src/index-minimal","../src/reader.js","../src/reader_buffer.js","../src/roots.js","../src/rpc.js","../src/rpc/service.js","../src/util/longbits.js","../src/util/minimal.js","../src/writer.js","../src/writer_buffer.js"],"names":["undefined","modules","cache","entries","protobuf","$require","name","$module","call","exports","util","global","define","amd","Long","isLong","configure","module","1","require","fn","ctx","params","Array","arguments","length","offset","index","pending","Promise","resolve","reject","err","apply","base64","string","p","n","Math","ceil","b64","s64","i","encode","buffer","start","end","t","parts","chunk","j","b","push","String","fromCharCode","slice","join","invalidEncoding","decode","c","charCodeAt","Error","test","EventEmitter","this","_listeners","prototype","on","evt","off","listeners","splice","emit","args","factory","writeFloat_ieee754","writeUint","val","buf","pos","sign","isNaN","round","exponent","floor","log","LN2","pow","readFloat_ieee754","readUint","uint","mantissa","NaN","Infinity","writeFloat_f32_cpy","f32","f8b","writeFloat_f32_rev","readFloat_f32_cpy","readFloat_f32_rev","f64","le","writeDouble_ieee754","off0","off1","readDouble_ieee754","lo","hi","writeDouble_f64_cpy","writeDouble_f64_rev","readDouble_f64_cpy","readDouble_f64_rev","Float32Array","Uint8Array","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","bind","writeUintLE","writeUintBE","readUintLE","readUintBE","Float64Array","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","inquire","moduleName","mod","eval","Object","keys","e","alloc","size","SIZE","MAX","slab","utf8","len","read","write","c1","c2","_configure","Writer","BufferWriter","Reader","BufferReader","build","rpc","roots","LongBits","indexOutOfRange","reader","writeLength","RangeError","create","Buffer","isBuffer","create_array","value","isArray","readLongVarint","bits","readFixed32_end","readFixed64","_slice","subarray","uint32","int32","sint32","bool","fixed32","sfixed32","float","double","bytes","nativeBuffer","constructor","skip","skipType","wireType","BufferReader_","merge","int64","uint64","sint64","zzDecode","fixed64","sfixed64","utf8Slice","min","toString","Service","rpcImpl","requestDelimited","responseDelimited","TypeError","Boolean","rpcCall","method","requestCtor","responseCtor","request","callback","self","asPromise","setTimeout","finish","response","endedByRPC","zero","toNumber","zzEncode","zeroHash","fromNumber","from","isString","parseInt","fromString","low","high","unsigned","toLong","fromHash","hash","toHash","mask","part0","part1","part2","dst","src","ifNotSet","newError","CustomError","message","properties","defineProperty","get","captureStackTrace","stack","writable","enumerable","configurable","set","pool","isNode","process","versions","node","window","emptyArray","freeze","emptyObject","isInteger","Number","isFinite","isObject","isset","isSet","obj","prop","hasOwnProperty","utf8Write","_Buffer_from","_Buffer_allocUnsafe","newBuffer","sizeOrArray","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","fromBits","lcFirst","str","toLowerCase","substring","ProtocolError","oneOfGetter","fieldNames","fieldMap","oneOfSetter","toJSONOptions","longs","enums","json","encoding","allocUnsafe","Op","next","noop","State","writer","head","tail","states","writeByte","VarintOp","writeVarint64","writeFixed32","_push","writeBytes","fork","reset","ldelim","BufferWriter_","writeStringBuffer","writeBytesBuffer","copy","byteLength"],"mappings":"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","file":"protobuf.min.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(16);\nprotobuf.BufferWriter = require(17);\nprotobuf.Reader       = require(9);\nprotobuf.BufferReader = require(10);\n\n// Utility\nprotobuf.util         = require(15);\nprotobuf.rpc          = require(12);\nprotobuf.roots        = require(11);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(15);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(9);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(15);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(13);\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(15);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(15);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(1);\n\n// converts to / from base64 encoded strings\nutil.base64 = require(2);\n\n// base class of rpc.Service\nutil.EventEmitter = require(3);\n\n// float handling accross browsers\nutil.float = require(4);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(5);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(7);\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(6);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(14);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(15);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(16);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(15);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"sourceRoot":"."}/*!
 * protobuf.js v7.3.2-postman.2 (c) 2016, daniel wirtz
 * compiled fri, 19 jul 2024 16:26:24 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
(function(undefined){"use strict";(function prelude(modules, cache, entries) {

    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
    // sources through a conflict-free require shim and is again wrapped within an iife that
    // provides a minification-friendly `undefined` var plus a global "use strict" directive
    // so that minification can remove the directives of each module.

    function $require(name) {
        var $module = cache[name];
        if (!$module)
            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);
        return $module.exports;
    }

    var protobuf = $require(entries[0]);

    // Expose globally
    protobuf.util.global.protobuf = protobuf;

    // Be nice to AMD
    if (typeof define === "function" && define.amd)
        define(["long"], function(Long) {
            if (Long && Long.isLong) {
                protobuf.util.Long = Long;
                protobuf.configure();
            }
            return protobuf;
        });

    // Be nice to CommonJS
    if (typeof module === "object" && module && module.exports)
        module.exports = protobuf;

})/* end of prelude */({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require(1),
    inquire   = require(7);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"1":1,"7":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [null_value]
     * @property {number} [number_value]
     * @property {string} [string_value]
     * @property {boolean} [bool_value]
     * @property {IStruct} [struct_value]
     * @property {IListValue} [list_value]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "null_value",
                    "number_value",
                    "string_value",
                    "bool_value",
                    "struct_value",
                    "list_value"
                ]
            }
        },
        fields: {
            null_value: {
                type: "NullValue",
                id: 1
            },
            number_value: {
                type: "double",
                id: 2
            },
            string_value: {
                type: "string",
                id: 3
            },
            bool_value: {
                type: "bool",
                id: 4
            },
            struct_value: {
                type: "Struct",
                id: 5
            },
            list_value: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require(15),
    util = require(37);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    var defaultAlreadyEmitted = false;
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                // enum unknown values passthrough
                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen
                    ("default:")
                        ("if(typeof(d%s)===\"number\"){m%s=d%s;break}", prop, prop, prop);
                    if (!field.repeated) gen // fallback to default value only for
                                             // arrays, to avoid leaving holes.
                        ("break");           // for non-repeated fields, just ignore
                    defaultAlreadyEmitted = true;
                }
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length >= 0)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-next-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"15":15,"37":37}],13:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require(15),
    types   = require(36),
    util    = require(37);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i: {", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break")
            ("}");
        // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"15":15,"36":36,"37":37}],14:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require(15),
    types    = require(36),
    util     = require(37);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

},{"15":15,"36":36,"37":37}],15:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require(24);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require(23),
    util = require(37);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum
 */
function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Values options, if any
     * @type {Object<string, Object<string, *>>|undefined}
     */
    this.valuesOptions = valuesOptions;

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"       , this.options,
        "valuesOptions" , this.valuesOptions,
        "values"        , this.values,
        "reserved"      , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"       , keepComments ? this.comment : undefined,
        "comments"      , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @param {Object.<string, *>|undefined} [options] Options, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment, options) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    if (options) {
        if (this.valuesOptions === undefined)
            this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
    }

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
        delete this.valuesOptions[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"23":23,"24":24,"37":37}],16:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require(24);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require(15),
    types = require(36),
    util  = require(37);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    if (rule === "proto3_optional") {
        rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    } else if (this.options && this.options.proto3_optional) {
        // proto3 scalar value marked optional; should default to null
        this.typeDefault = null;
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"15":15,"24":24,"36":36,"37":37}],17:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(18);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require(14);
protobuf.decoder          = require(13);
protobuf.verifier         = require(40);
protobuf.converter        = require(12);

// Reflection
protobuf.ReflectionObject = require(24);
protobuf.Namespace        = require(23);
protobuf.Root             = require(29);
protobuf.Enum             = require(15);
protobuf.Type             = require(35);
protobuf.Field            = require(16);
protobuf.OneOf            = require(25);
protobuf.MapField         = require(20);
protobuf.Service          = require(33);
protobuf.Method           = require(22);

// Runtime
protobuf.Message          = require(21);
protobuf.wrappers         = require(41);

// Utility
protobuf.types            = require(36);
protobuf.util             = require(37);

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"12":12,"13":13,"14":14,"15":15,"16":16,"18":18,"20":20,"21":21,"22":22,"23":23,"24":24,"25":25,"29":29,"33":33,"35":35,"36":36,"37":37,"40":40,"41":41}],18:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require(42);
protobuf.BufferWriter = require(43);
protobuf.Reader       = require(27);
protobuf.BufferReader = require(28);

// Utility
protobuf.util         = require(39);
protobuf.rpc          = require(31);
protobuf.roots        = require(30);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"27":27,"28":28,"30":30,"31":31,"39":39,"42":42,"43":43}],19:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require(17);

protobuf.build = "full";

// Parser
protobuf.tokenize         = require(34);
protobuf.parse            = require(26);
protobuf.common           = require(11);

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"11":11,"17":17,"26":26,"34":34}],20:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require(16);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require(36),
    util    = require(37);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"16":16,"36":36,"37":37}],21:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require(39);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"39":39}],22:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require(24);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require(37);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Options properly parsed into an object
     */
    this.parsedOptions = parsedOptions;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 * @property {string} comment Method comments
 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined,
        "parsedOptions"  , this.parsedOptions,
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"24":24,"37":37}],23:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require(24);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require(16),
    util     = require(37),
    OneOf    = require(25);

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}
 */

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return util.getProp(this.nested, name)
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

},{"16":16,"24":24,"25":25,"37":37}],24:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require(37);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"37":37}],25:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require(24);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require(16),
    util  = require(37);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"16":16,"24":24,"37":37}],26:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require(34),
    Root      = require(29),
    Type      = require(35),
    Field     = require(16),
    MapField  = require(20),
    OneOf     = require(25),
    Enum      = require(15),
    Service   = require(33),
    Method    = require(22),
    types     = require(36),
    util      = require(37);

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        var dummy = {options: undefined};
        dummy.setOption = function(name, value) {
          if (this.options === undefined) this.options = {};
          this.options[name] = value;
        };
        ifBlock(
            dummy,
            function parseRange_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(dummy, token);  // skip
                skip(";");
              } else
                throw illegal(token);
            },
            function parseRange_line() {
              parseInlineOptions(dummy);  // skip
            });
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-next-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "repeated":
                    parseField(type, token);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (isProto3) {
                        parseField(type, "proto3_optional");
                    } else {
                        parseField(type, "optional");
                    }
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }
        // Type names can consume multiple tokens, in multiple variants:
        //    package.subpackage   field       tokens: "package.subpackage" [TYPE NAME ENDS HERE] "field"
        //    package . subpackage field       tokens: "package" "." "subpackage" [TYPE NAME ENDS HERE] "field"
        //    package.  subpackage field       tokens: "package." "subpackage" [TYPE NAME ENDS HERE] "field"
        //    package  .subpackage field       tokens: "package" ".subpackage" [TYPE NAME ENDS HERE] "field"
        // Keep reading tokens until we get a type name with no period at the end,
        // and the next token does not start with a period.
        while (type.endsWith(".") || peek().startsWith(".")) {
            type += next();
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });

        if (rule === "proto3_optional") {
            // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
            var oneof = new OneOf("_" + name);
            field.setOption("proto3_optional", true);
            oneof.add(field);
            parent.add(oneof);
        } else {
            parent.add(field);
        }

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "repeated":
                    parseField(type, token);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (isProto3) {
                        parseField(type, "proto3_optional");
                    } else {
                        parseField(type, "optional");
                    }
                    break;

                case "message":
                    parseType(type, token);
                    break;

                case "enum":
                    parseEnum(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {
                options: undefined
            };
        dummy.setOption = function(name, value) {
            if (this.options === undefined)
                this.options = {};
            this.options[name] = value;
        };
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment, dummy.options);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        var option = name;
        var propName;

        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            option = name;
            token = peek();
            if (fqTypeRefRe.test(token)) {
                propName = token.slice(1); //remove '.' before property name
                name += token;
                next();
            }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        // { a: "foo" b { c: "bar" } }
        if (skip("{", true)) {
            var objectResult = {};

            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next())) {
                    throw illegal(token, "name");
                }
                if (token === null) {
                  throw illegal(token, "end of input");
                }

                var value;
                var propName = token;

                skip(":", true);

                if (peek() === "{")
                    value = parseOptionValue(parent, name + "." + token);
                else if (peek() === "[") {
                    // option (my_option) = {
                    //     repeated_value: [ "foo", "bar" ]
                    // };
                    value = [];
                    var lastValue;
                    if (skip("[", true)) {
                        do {
                            lastValue = readValue(true);
                            value.push(lastValue);
                        } while (skip(",", true));
                        skip("]");
                        if (typeof lastValue !== "undefined") {
                            setOption(parent, name + "." + token, lastValue);
                        }
                    }
                } else {
                    value = readValue(true);
                    setOption(parent, name + "." + token, value);
                }

                var prevValue = objectResult[propName];

                if (prevValue)
                    value = [].concat(prevValue).concat(value);

                objectResult[propName] = value;

                // Semicolons and commas can be optional
                skip(",", true);
                skip(";", true);
            }

            return objectResult;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        // Get the comment of the preceding line now (if one exists) in case the
        // method is defined across multiple lines.
        var commentText = cmnt();

        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                    parseField(parent, token, reference);
                    break;

                case "optional":
                    /* istanbul ignore if */
                    if (isProto3) {
                        parseField(parent, "proto3_optional", reference);
                    } else {
                        parseField(parent, "optional", reference);
                    }
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"15":15,"16":16,"20":20,"22":22,"25":25,"29":29,"33":33,"34":34,"35":35,"36":36,"37":37}],27:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require(39);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);

    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
        var nativeBuffer = util.Buffer;
        return nativeBuffer
            ? nativeBuffer.alloc(0)
            : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"39":39}],28:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require(27);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require(39);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"27":27,"39":39}],29:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require(23);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require(16),
    Enum    = require(15),
    OneOf   = require(25),
    util    = require(37);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        if (sync)
            throw err;
        var cb = callback;
        callback = null;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {
        filename = getBundledFileName(filename) || filename;

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        //do not allow to extend same field twice to prevent the error
        if (extendedType.get(sisterField.name)) {
            return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

},{"15":15,"16":16,"23":23,"25":25,"37":37}],30:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],31:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require(32);

},{"32":32}],32:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require(39);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"39":39}],33:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require(23);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require(22),
    util   = require(37),
    rpc    = require(31);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return util.getProp(this.methods, name)
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"22":22,"23":23,"31":31,"37":37}],34:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        lastCommentLine = 0,
        comments = {};

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @param {boolean} isLeading set if a leading comment
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end, isLeading) {
        var comment = {
            type: source.charAt(start++),
            lineEmpty: false,
            leading: isLeading,
        };
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                comment.lineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        comment.text = lines
            .join("\n")
            .trim();

        comments[line] = comment;
        lastCommentLine = line;
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/\//.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                    isLeadingComment = true;
                    ++line;
                }
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1, isLeadingComment);
                            // Trailing comment cannot not be multi-line,
                            // so leading comment state should be reset to handle potential next comments
                            isLeadingComment = true;
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset - 1)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                                if (!isLeadingComment) {
                                    // Trailing comment cannot not be multi-line
                                    break;
                                }
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset, isLeadingComment);
                            isLeadingComment = true;
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2, isLeadingComment);
                        isLeadingComment = true;
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === undefined) {
            comment = comments[line - 1];
            delete comments[line - 1];
            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
                ret = comment.leading ? comment.text : null;
            }
        } else {
            /* istanbul ignore else */
            if (lastCommentLine < trailingLine) {
                peek();
            }
            comment = comments[trailingLine];
            delete comments[trailingLine];
            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
                ret = comment.leading ? null : comment.text;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],35:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require(23);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require(15),
    OneOf     = require(25),
    Field     = require(16),
    MapField  = require(20),
    Service   = require(33),
    Message   = require(21),
    Reader    = require(27),
    Writer    = require(42),
    util      = require(37),
    encoder   = require(14),
    decoder   = require(13),
    verifier  = require(40),
    converter = require(12),
    wrappers  = require(41);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {Array.<number[]|string>} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return util.getProp(this.fields, name)
        || util.getProp(this.oneofs, name)
        || util.getProp(this.nested, name)
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"12":12,"13":13,"14":14,"15":15,"16":16,"20":20,"21":21,"23":23,"25":25,"27":27,"33":33,"37":37,"40":40,"41":41,"42":42}],36:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require(37);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"37":37}],37:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require(39);

var roots = require(30);

var Type, // cyclic
    Enum;

util.codegen = require(3);
util.fetch   = require(5);
util.path    = require(8);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Returns the value of a property found directly in a given object.
 * @param {Object} object Source object
 * @param {string} prop Property name
 * @returns {*} Value or `undefined` if not set
 */
util.getProp = function get(object, prop) {
    return object && Object.prototype.hasOwnProperty.call(object, prop) ? object[prop] : undefined;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require(35);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require(15);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst;
        }
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require(29))());
    }
});

},{"15":15,"29":29,"3":3,"30":30,"35":35,"39":39,"5":5,"8":8}],38:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require(39);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"39":39}],39:[function(require,module,exports){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require(1);

// converts to / from base64 encoded strings
util.base64 = require(2);

// base class of rpc.Service
util.EventEmitter = require(4);

// float handling accross browsers
util.float = require(6);

// requires modules optionally and hides the call from bundlers
util.inquire = require(7);

// converts to / from utf8 encoded strings
util.utf8 = require(10);

// provides a node-like buffer pool in the browser
util.pool = require(9);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require(38);

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true,
        },
        name: {
            get: function get() { return name; },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true,
        },
        toString: {
            value: function value() { return this.name + ": " + this.message; },
            writable: true,
            enumerable: false,
            configurable: true,
        },
    });

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

},{"1":1,"10":10,"2":2,"38":38,"4":4,"6":6,"7":7,"9":9}],40:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require(15),
    util      = require(37);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"15":15,"37":37}],41:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require(21);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].slice(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.slice(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"21":21}],42:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require(39);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"39":39}],43:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require(42);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require(39);

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"39":39,"42":42}]},{},[19])

})();
//# sourceMappingURL=protobuf.js.map
{"version":3,"sources":["lib/prelude.js","../node_modules/@protobufjs/aspromise/index.js","../node_modules/@protobufjs/base64/index.js","../node_modules/@protobufjs/codegen/index.js","../node_modules/@protobufjs/eventemitter/index.js","../node_modules/@protobufjs/fetch/index.js","../node_modules/@protobufjs/float/index.js","../node_modules/@protobufjs/inquire/index.js","../node_modules/@protobufjs/path/index.js","../node_modules/@protobufjs/pool/index.js","../node_modules/@protobufjs/utf8/index.js","../src/common.js","../src/converter.js","../src/decoder.js","../src/encoder.js","../src/enum.js","../src/field.js","../src/index-light.js","../src/index-minimal.js","../src/index","../src/mapfield.js","../src/message.js","../src/method.js","../src/namespace.js","../src/object.js","../src/oneof.js","../src/parse.js","../src/reader.js","../src/reader_buffer.js","../src/root.js","../src/roots.js","../src/rpc.js","../src/rpc/service.js","../src/service.js","../src/tokenize.js","../src/type.js","../src/types.js","../src/util.js","../src/util/longbits.js","../src/util/minimal.js","../src/verifier.js","../src/wrappers.js","../src/writer.js","../src/writer_buffer.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACz3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"protobuf.js","sourcesContent":["(function prelude(modules, cache, entries) {\n\n    // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS\n    // sources through a conflict-free require shim and is again wrapped within an iife that\n    // provides a minification-friendly `undefined` var plus a global \"use strict\" directive\n    // so that minification can remove the directives of each module.\n\n    function $require(name) {\n        var $module = cache[name];\n        if (!$module)\n            modules[name][0].call($module = cache[name] = { exports: {} }, $require, $module, $module.exports);\n        return $module.exports;\n    }\n\n    var protobuf = $require(entries[0]);\n\n    // Expose globally\n    protobuf.util.global.protobuf = protobuf;\n\n    // Be nice to AMD\n    if (typeof define === \"function\" && define.amd)\n        define([\"long\"], function(Long) {\n            if (Long && Long.isLong) {\n                protobuf.util.Long = Long;\n                protobuf.configure();\n            }\n            return protobuf;\n        });\n\n    // Be nice to CommonJS\n    if (typeof module === \"object\" && module && module.exports)\n        module.exports = protobuf;\n\n})/* end of prelude */","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = codegen;\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\r\nfunction codegen(functionParams, functionName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof functionParams === \"string\") {\r\n        functionName = functionParams;\r\n        functionParams = undefined;\r\n    }\r\n\r\n    var body = [];\r\n\r\n    /**\r\n     * Appends code to the function's body or finishes generation.\r\n     * @typedef Codegen\r\n     * @type {function}\r\n     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n     * @param {...*} [formatParams] Format parameters\r\n     * @returns {Codegen|Function} Itself or the generated function if finished\r\n     * @throws {Error} If format parameter counts do not match\r\n     */\r\n\r\n    function Codegen(formatStringOrScope) {\r\n        // note that explicit array handling below makes this ~50% faster\r\n\r\n        // finish the function\r\n        if (typeof formatStringOrScope !== \"string\") {\r\n            var source = toString();\r\n            if (codegen.verbose)\r\n                console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n            source = \"return \" + source;\r\n            if (formatStringOrScope) {\r\n                var scopeKeys   = Object.keys(formatStringOrScope),\r\n                    scopeParams = new Array(scopeKeys.length + 1),\r\n                    scopeValues = new Array(scopeKeys.length),\r\n                    scopeOffset = 0;\r\n                while (scopeOffset < scopeKeys.length) {\r\n                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                }\r\n                scopeParams[scopeOffset] = source;\r\n                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n            }\r\n            return Function(source)(); // eslint-disable-line no-new-func\r\n        }\r\n\r\n        // otherwise append to body\r\n        var formatParams = new Array(arguments.length - 1),\r\n            formatOffset = 0;\r\n        while (formatOffset < formatParams.length)\r\n            formatParams[formatOffset] = arguments[++formatOffset];\r\n        formatOffset = 0;\r\n        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n            var value = formatParams[formatOffset++];\r\n            switch ($1) {\r\n                case \"d\": case \"f\": return String(Number(value));\r\n                case \"i\": return String(Math.floor(value));\r\n                case \"j\": return JSON.stringify(value);\r\n                case \"s\": return String(value);\r\n            }\r\n            return \"%\";\r\n        });\r\n        if (formatOffset !== formatParams.length)\r\n            throw Error(\"parameter count mismatch\");\r\n        body.push(formatStringOrScope);\r\n        return Codegen;\r\n    }\r\n\r\n    function toString(functionNameOverride) {\r\n        return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n    }\r\n\r\n    Codegen.toString = toString;\r\n    return Codegen;\r\n}\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\r\ncodegen.verbose = false;\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\nmodule.exports = fetch;\r\n\r\nvar asPromise = require(1),\r\n    inquire   = require(7);\r\n\r\nvar fs = inquire(\"fs\");\r\n\r\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nfunction fetch(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (!options)\r\n        options = {};\r\n\r\n    if (!callback)\r\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\r\n\r\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\r\n    if (!options.xhr && fs && fs.readFile)\r\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\r\n            return err && typeof XMLHttpRequest !== \"undefined\"\r\n                ? fetch.xhr(filename, options, callback)\r\n                : err\r\n                ? callback(err)\r\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\r\n        });\r\n\r\n    // use the XHR version otherwise.\r\n    return fetch.xhr(filename, options, callback);\r\n}\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\r\n\r\n/**/\r\nfetch.xhr = function fetch_xhr(filename, options, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\r\n\r\n        if (xhr.readyState !== 4)\r\n            return undefined;\r\n\r\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\r\n        // reliably distinguished from an actually empty file for security reasons. feel free\r\n        // to send a pull request if you are aware of a solution.\r\n        if (xhr.status !== 0 && xhr.status !== 200)\r\n            return callback(Error(\"status \" + xhr.status));\r\n\r\n        // if binary data is expected, make sure that some sort of array is returned, even if\r\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\r\n        if (options.binary) {\r\n            var buffer = xhr.response;\r\n            if (!buffer) {\r\n                buffer = [];\r\n                for (var i = 0; i < xhr.responseText.length; ++i)\r\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\r\n            }\r\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\r\n        }\r\n        return callback(null, xhr.responseText);\r\n    };\r\n\r\n    if (options.binary) {\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\r\n        if (\"overrideMimeType\" in xhr)\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        xhr.responseType = \"arraybuffer\";\r\n    }\r\n\r\n    xhr.open(\"GET\", filename);\r\n    xhr.send();\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal path module to resolve Unix, Windows and URL paths alike.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar path = exports;\r\n\r\nvar isAbsolute =\r\n/**\r\n * Tests if the specified path is absolute.\r\n * @param {string} path Path to test\r\n * @returns {boolean} `true` if path is absolute\r\n */\r\npath.isAbsolute = function isAbsolute(path) {\r\n    return /^(?:\\/|\\w+:)/.test(path);\r\n};\r\n\r\nvar normalize =\r\n/**\r\n * Normalizes the specified path.\r\n * @param {string} path Path to normalize\r\n * @returns {string} Normalized path\r\n */\r\npath.normalize = function normalize(path) {\r\n    path = path.replace(/\\\\/g, \"/\")\r\n               .replace(/\\/{2,}/g, \"/\");\r\n    var parts    = path.split(\"/\"),\r\n        absolute = isAbsolute(path),\r\n        prefix   = \"\";\r\n    if (absolute)\r\n        prefix = parts.shift() + \"/\";\r\n    for (var i = 0; i < parts.length;) {\r\n        if (parts[i] === \"..\") {\r\n            if (i > 0 && parts[i - 1] !== \"..\")\r\n                parts.splice(--i, 2);\r\n            else if (absolute)\r\n                parts.splice(i, 1);\r\n            else\r\n                ++i;\r\n        } else if (parts[i] === \".\")\r\n            parts.splice(i, 1);\r\n        else\r\n            ++i;\r\n    }\r\n    return prefix + parts.join(\"/\");\r\n};\r\n\r\n/**\r\n * Resolves the specified include path against the specified origin path.\r\n * @param {string} originPath Path to the origin file\r\n * @param {string} includePath Include path relative to origin path\r\n * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized\r\n * @returns {string} Path to the include file\r\n */\r\npath.resolve = function resolve(originPath, includePath, alreadyNormalized) {\r\n    if (!alreadyNormalized)\r\n        includePath = normalize(includePath);\r\n    if (isAbsolute(includePath))\r\n        return includePath;\r\n    if (!alreadyNormalized)\r\n        originPath = normalize(originPath);\r\n    return (originPath = originPath.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? normalize(originPath + \"/\" + includePath) : includePath;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\nmodule.exports = common;\n\nvar commonRe = /\\/|\\./;\n\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */\nfunction common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };\n    }\n    common[name] = json;\n}\n\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\n\ncommon(\"any\", {\n\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */\n    Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\n\nvar timeType;\n\ncommon(\"duration\", {\n\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */\n    Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\n\ncommon(\"timestamp\", {\n\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */\n    Timestamp: timeType\n});\n\ncommon(\"empty\", {\n\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */\n    Empty: {\n        fields: {}\n    }\n});\n\ncommon(\"struct\", {\n\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */\n    Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [null_value]\n     * @property {number} [number_value]\n     * @property {string} [string_value]\n     * @property {boolean} [bool_value]\n     * @property {IStruct} [struct_value]\n     * @property {IListValue} [list_value]\n     * @memberof common\n     */\n    Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"null_value\",\n                    \"number_value\",\n                    \"string_value\",\n                    \"bool_value\",\n                    \"struct_value\",\n                    \"list_value\"\n                ]\n            }\n        },\n        fields: {\n            null_value: {\n                type: \"NullValue\",\n                id: 1\n            },\n            number_value: {\n                type: \"double\",\n                id: 2\n            },\n            string_value: {\n                type: \"string\",\n                id: 3\n            },\n            bool_value: {\n                type: \"bool\",\n                id: 4\n            },\n            struct_value: {\n                type: \"Struct\",\n                id: 5\n            },\n            list_value: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */\n    ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\n\ncommon(\"wrappers\", {\n\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */\n    Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */\n    UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */\n    BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */\n    StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */\n    BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\n\ncommon(\"field_mask\", {\n\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */\n    FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */\ncommon.get = function get(file) {\n    return common[file] || null;\n};\n","\"use strict\";\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */\nvar converter = exports;\n\nvar Enum = require(15),\n    util = require(37);\n\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) { gen\n            (\"switch(d%s){\", prop);\n            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen\n                    (\"default:\")\n                        (\"if(typeof(d%s)===\\\"number\\\"){m%s=d%s;break}\", prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                                             // arrays, to avoid leaving holes.\n                        (\"break\");           // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen\n                (\"case%j:\", keys[i])\n                (\"case %i:\", values[keys[i]])\n                    (\"m%s=%j\", prop, values[keys[i]])\n                    (\"break\");\n            } gen\n            (\"}\");\n        } else gen\n            (\"if(typeof d%s!==\\\"object\\\")\", prop)\n                (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n            (\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n                (\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\": gen\n                (\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\": gen\n                (\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n                (\"if(util.Long)\")\n                    (\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)\n                (\"else if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"m%s=parseInt(d%s,10)\", prop, prop)\n                (\"else if(typeof d%s===\\\"number\\\")\", prop)\n                    (\"m%s=d%s\", prop, prop)\n                (\"else if(typeof d%s===\\\"object\\\")\", prop)\n                    (\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\": gen\n                (\"if(typeof d%s===\\\"string\\\")\", prop)\n                    (\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)\n                (\"else if(d%s.length >= 0)\", prop)\n                    (\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\": gen\n                (\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\": gen\n                (\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n            /* default: gen\n                (\"m%s=d%s\", prop, prop);\n                break; */\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray;\n    var gen = util.codegen([\"d\"], mtype.name + \"$fromObject\")\n    (\"if(d instanceof this.ctor)\")\n        (\"return d\");\n    if (!fields.length) return gen\n    (\"return new this.ctor\");\n    gen\n    (\"var m=new this.ctor\");\n    for (var i = 0; i < fields.length; ++i) {\n        var field  = fields[i].resolve(),\n            prop   = util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) { gen\n    (\"if(d%s){\", prop)\n        (\"if(typeof d%s!==\\\"object\\\")\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": object expected\")\n        (\"m%s={}\", prop)\n        (\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")\n        (\"}\")\n    (\"}\");\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(d%s){\", prop)\n        (\"if(!Array.isArray(d%s))\", prop)\n            (\"throw TypeError(%j)\", field.fullName + \": array expected\")\n        (\"m%s=[]\", prop)\n        (\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")\n        (\"}\")\n    (\"}\");\n\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n    (\"if(d%s!=null){\", prop); // !== undefined && !== null\n        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen\n    (\"}\");\n        }\n    } return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen\n            (\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen\n            (\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch (field.type) {\n            case \"double\":\n            case \"float\": gen\n            (\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n                // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\": gen\n            (\"if(typeof m%s===\\\"number\\\")\", prop)\n                (\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)\n            (\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\": \"\", prop);\n                break;\n            case \"bytes\": gen\n            (\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default: gen\n            (\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nconverter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length)\n        return util.codegen()(\"return {}\");\n    var gen = util.codegen([\"m\", \"o\"], mtype.name + \"$toObject\")\n    (\"if(!o)\")\n        (\"o={}\")\n    (\"var d={}\");\n\n    var repeatedFields = [],\n        mapFields = [],\n        normalFields = [],\n        i = 0;\n    for (; i < fields.length; ++i)\n        if (!fields[i].partOf)\n            ( fields[i].resolve().repeated ? repeatedFields\n            : fields[i].map ? mapFields\n            : normalFields).push(fields[i]);\n\n    if (repeatedFields.length) { gen\n    (\"if(o.arrays||o.defaults){\");\n        for (i = 0; i < repeatedFields.length; ++i) gen\n        (\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (mapFields.length) { gen\n    (\"if(o.objects||o.defaults){\");\n        for (i = 0; i < mapFields.length; ++i) gen\n        (\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen\n    (\"}\");\n    }\n\n    if (normalFields.length) { gen\n    (\"if(o.defaults){\");\n        for (i = 0; i < normalFields.length; ++i) {\n            var field = normalFields[i],\n                prop  = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen\n        (\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen\n        (\"if(util.Long){\")\n            (\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)\n            (\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)\n        (\"}else\")\n            (\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen\n        (\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))\n        (\"else{\")\n            (\"d%s=%s\", prop, arrayDefault)\n            (\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)\n        (\"}\");\n            } else gen\n        (\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        } gen\n    (\"}\");\n    }\n    var hasKs2 = false;\n    for (i = 0; i < fields.length; ++i) {\n        var field = fields[i],\n            index = mtype._fieldsArray.indexOf(field),\n            prop  = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) { hasKs2 = true; gen\n    (\"var ks2\");\n            } gen\n    (\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)\n        (\"d%s={}\", prop)\n        (\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")\n        (\"}\");\n        } else if (field.repeated) { gen\n    (\"if(m%s&&m%s.length){\", prop, prop)\n        (\"d%s=[]\", prop)\n        (\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")\n        (\"}\");\n        } else { gen\n    (\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n        genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n        if (field.partOf) gen\n        (\"if(o.oneofs)\")\n            (\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen\n    (\"}\");\n    }\n    return gen\n    (\"return d\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n};\n","\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(15),\n    types   = require(36),\n    util    = require(37);\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i: {\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\")\n            (\"}\");\n        // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n","\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(15),\n    types    = require(36),\n    util     = require(37);\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n","\"use strict\";\nmodule.exports = Enum;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\n\nvar Namespace = require(23),\n    util = require(37);\n\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */\nfunction Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n\n    if (values && typeof values !== \"object\")\n        throw TypeError(\"values must be an object\");\n\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */\n    this.valuesById = {};\n\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */\n    this.values = Object.create(this.valuesById); // toJSON, marker\n\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */\n    this.comments = comments || {};\n\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */\n    this.valuesOptions = valuesOptions;\n\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */\n    this.reserved = undefined; // toJSON\n\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n\n    if (values)\n        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)\n            if (typeof values[keys[i]] === \"number\") // use forward entries only\n                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];\n}\n\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */\n\n/**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */\nEnum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */\nEnum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\"       , this.options,\n        \"valuesOptions\" , this.valuesOptions,\n        \"values\"        , this.values,\n        \"reserved\"      , this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\"       , keepComments ? this.comment : undefined,\n        \"comments\"      , keepComments ? this.comments : undefined\n    ]);\n};\n\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */\nEnum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (!util.isInteger(id))\n        throw TypeError(\"id must be an integer\");\n\n    if (this.values[name] !== undefined)\n        throw Error(\"duplicate name '\" + name + \"' in \" + this);\n\n    if (this.isReservedId(id))\n        throw Error(\"id \" + id + \" is reserved in \" + this);\n\n    if (this.isReservedName(name))\n        throw Error(\"name '\" + name + \"' is reserved in \" + this);\n\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias))\n            throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else\n        this.valuesById[this.values[name] = id] = name;\n\n    if (options) {\n        if (this.valuesOptions === undefined)\n            this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n\n    this.comments[name] = comment || null;\n    return this;\n};\n\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */\nEnum.prototype.remove = function remove(name) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    var val = this.values[name];\n    if (val == null)\n        throw Error(\"name '\" + name + \"' does not exist in \" + this);\n\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions)\n        delete this.valuesOptions[name];\n\n    return this;\n};\n\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nEnum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n","\"use strict\";\nmodule.exports = Field;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\n\nvar Enum  = require(15),\n    types = require(36),\n    util  = require(37);\n\nvar Type; // cyclic\n\nvar ruleRe = /^required|optional|repeated$/;\n\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */\nField.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction Field(name, id, type, rule, extend, options, comment) {\n\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n\n    ReflectionObject.call(this, name, options);\n\n    if (!util.isInteger(id) || id < 0)\n        throw TypeError(\"id must be a non-negative integer\");\n\n    if (!util.isString(type))\n        throw TypeError(\"type must be a string\");\n\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))\n        throw TypeError(\"rule must be a string rule\");\n\n    if (extend !== undefined && !util.isString(extend))\n        throw TypeError(\"extend must be a string\");\n\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */\n    if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n\n    /**\n     * Field type.\n     * @type {string}\n     */\n    this.type = type; // toJSON\n\n    /**\n     * Unique field id.\n     * @type {number}\n     */\n    this.id = id; // toJSON, marker\n\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */\n    this.extend = extend || undefined; // toJSON\n\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */\n    this.required = rule === \"required\";\n\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */\n    this.optional = !this.required;\n\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */\n    this.repeated = rule === \"repeated\";\n\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */\n    this.map = false;\n\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */\n    this.message = null;\n\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */\n    this.partOf = null;\n\n    /**\n     * The field type's default value.\n     * @type {*}\n     */\n    this.typeDefault = null;\n\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */\n    this.defaultValue = null;\n\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */\n    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */\n    this.bytes = type === \"bytes\";\n\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */\n    this.resolvedType = null;\n\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */\n    this.extensionField = null;\n\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */\n    this.declaringField = null;\n\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */\n    this._packed = null;\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */\nObject.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null)\n            this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n\n/**\n * @override\n */\nField.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") // clear cached before setting\n        this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */\n\n/**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */\n\n/**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */\nField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\"    , this.rule !== \"optional\" && this.rule || undefined,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */\nField.prototype.resolve = function resolve() {\n\n    if (this.resolved)\n        return this;\n\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type)\n            this.typeDefault = null;\n        else // instanceof Enum\n            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\")\n            this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))\n            delete this.options.packed;\n        if (!Object.keys(this.options).length)\n            this.options = undefined;\n    }\n\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n\n        /* istanbul ignore else */\n        if (Object.freeze)\n            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault))\n            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else\n            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n\n    // take special care of maps and repeated fields\n    if (this.map)\n        this.defaultValue = util.emptyObject;\n    else if (this.repeated)\n        this.defaultValue = util.emptyArray;\n    else\n        this.defaultValue = this.typeDefault;\n\n    // ensure proper value on prototype\n    if (this.parent instanceof Type)\n        this.parent.ctor.prototype[this.name] = this.defaultValue;\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */\nField.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\")\n        fieldType = util.decorateType(fieldType).name;\n\n    // enum reference: create a reflected copy of the enum and keep reuseing it\n    else if (fieldType && typeof fieldType === \"object\")\n        fieldType = util.decorateEnum(fieldType).name;\n\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { \"default\": defaultValue }));\n    };\n};\n\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */\n// like Field.d but without a default value\n\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n","\"use strict\";\nvar protobuf = module.exports = require(18);\n\nprotobuf.build = \"light\";\n\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */\nfunction load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root)\n        root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */\n// function load(filename:string, [root:Root]):Promise<Root>\n\nprotobuf.load = load;\n\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */\nfunction loadSync(filename, root) {\n    if (!root)\n        root = new protobuf.Root();\n    return root.loadSync(filename);\n}\n\nprotobuf.loadSync = loadSync;\n\n// Serialization\nprotobuf.encoder          = require(14);\nprotobuf.decoder          = require(13);\nprotobuf.verifier         = require(40);\nprotobuf.converter        = require(12);\n\n// Reflection\nprotobuf.ReflectionObject = require(24);\nprotobuf.Namespace        = require(23);\nprotobuf.Root             = require(29);\nprotobuf.Enum             = require(15);\nprotobuf.Type             = require(35);\nprotobuf.Field            = require(16);\nprotobuf.OneOf            = require(25);\nprotobuf.MapField         = require(20);\nprotobuf.Service          = require(33);\nprotobuf.Method           = require(22);\n\n// Runtime\nprotobuf.Message          = require(21);\nprotobuf.wrappers         = require(41);\n\n// Utility\nprotobuf.types            = require(36);\nprotobuf.util             = require(37);\n\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(42);\nprotobuf.BufferWriter = require(43);\nprotobuf.Reader       = require(27);\nprotobuf.BufferReader = require(28);\n\n// Utility\nprotobuf.util         = require(39);\nprotobuf.rpc          = require(31);\nprotobuf.roots        = require(30);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nvar protobuf = module.exports = require(17);\n\nprotobuf.build = \"full\";\n\n// Parser\nprotobuf.tokenize         = require(34);\nprotobuf.parse            = require(26);\nprotobuf.common           = require(11);\n\n// Configure parser\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\n","\"use strict\";\nmodule.exports = MapField;\n\n// extends Field\nvar Field = require(16);\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types   = require(36),\n    util    = require(37);\n\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n    /* istanbul ignore if */\n    if (!util.isString(keyType))\n        throw TypeError(\"keyType must be a string\");\n\n    /**\n     * Key type.\n     * @type {string}\n     */\n    this.keyType = keyType; // toJSON, marker\n\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */\n    this.resolvedKeyType = null;\n\n    // Overrides Field#map\n    this.map = true;\n}\n\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */\n\n/**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */\n\n/**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */\nMapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\" , this.keyType,\n        \"type\"    , this.type,\n        \"id\"      , this.id,\n        \"extend\"  , this.extend,\n        \"options\" , this.options,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * @override\n */\nMapField.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined)\n        throw Error(\"invalid key type: \" + this.keyType);\n\n    return Field.prototype.resolve.call(this);\n};\n\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\")\n        fieldValueType = util.decorateType(fieldValueType).name;\n\n    // enum reference value: create a reflected copy of the enum and keep reuseing it\n    else if (fieldValueType && typeof fieldValueType === \"object\")\n        fieldValueType = util.decorateEnum(fieldValueType).name;\n\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor)\n            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n","\"use strict\";\nmodule.exports = Message;\n\nvar util = require(39);\n\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */\nfunction Message(properties) {\n    // not used internally\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            this[keys[i]] = properties[keys[i]];\n}\n\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */\n\n/**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */\n\n/*eslint-disable valid-jsdoc*/\n\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.create = function create(properties) {\n    return this.$type.create(properties);\n};\n\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */\nMessage.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */\nMessage.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */\nMessage.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n};\n\n/*eslint-enable valid-jsdoc*/","\"use strict\";\nmodule.exports = Method;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\n\nvar util = require(37);\n\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */\nfunction Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n\n    /* istanbul ignore next */\n    if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n\n    /* istanbul ignore if */\n    if (!(type === undefined || util.isString(type)))\n        throw TypeError(\"type must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(requestType))\n        throw TypeError(\"requestType must be a string\");\n\n    /* istanbul ignore if */\n    if (!util.isString(responseType))\n        throw TypeError(\"responseType must be a string\");\n\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Method type.\n     * @type {string}\n     */\n    this.type = type || \"rpc\"; // toJSON\n\n    /**\n     * Request type.\n     * @type {string}\n     */\n    this.requestType = requestType; // toJSON, marker\n\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.requestStream = requestStream ? true : undefined; // toJSON\n\n    /**\n     * Response type.\n     * @type {string}\n     */\n    this.responseType = responseType; // toJSON\n\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */\n    this.responseStream = responseStream ? true : undefined; // toJSON\n\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */\n    this.resolvedRequestType = null;\n\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */\n    this.resolvedResponseType = null;\n\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */\n    this.comment = comment;\n\n    /**\n     * Options properly parsed into an object\n     */\n    this.parsedOptions = parsedOptions;\n}\n\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */\n\n/**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */\nMethod.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */\nMethod.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\"           , this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\"    , this.requestType,\n        \"requestStream\"  , this.requestStream,\n        \"responseType\"   , this.responseType,\n        \"responseStream\" , this.responseStream,\n        \"options\"        , this.options,\n        \"comment\"        , keepComments ? this.comment : undefined,\n        \"parsedOptions\"  , this.parsedOptions,\n    ]);\n};\n\n/**\n * @override\n */\nMethod.prototype.resolve = function resolve() {\n\n    /* istanbul ignore if */\n    if (this.resolved)\n        return this;\n\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n\n    return ReflectionObject.prototype.resolve.call(this);\n};\n","\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(16),\n    util     = require(37),\n    OneOf    = require(25);\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return util.getProp(this.nested, name)\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n","\"use strict\";\nmodule.exports = ReflectionObject;\n\nReflectionObject.className = \"ReflectionObject\";\n\nvar util = require(37);\n\nvar Root; // cyclic\n\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */\nfunction ReflectionObject(name, options) {\n\n    if (!util.isString(name))\n        throw TypeError(\"name must be a string\");\n\n    if (options && !util.isObject(options))\n        throw TypeError(\"options must be an object\");\n\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */\n    this.options = options; // toJSON\n\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */\n    this.parsedOptions = null;\n\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */\n    this.parent = null;\n\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */\n    this.resolved = false;\n\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */\n    this.comment = null;\n\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */\n    this.filename = null;\n}\n\nObject.defineProperties(ReflectionObject.prototype, {\n\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */\n    root: {\n        get: function() {\n            var ptr = this;\n            while (ptr.parent !== null)\n                ptr = ptr.parent;\n            return ptr;\n        }\n    },\n\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */\n    fullName: {\n        get: function() {\n            var path = [ this.name ],\n                ptr = this.parent;\n            while (ptr) {\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */\nReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */\nReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent)\n        this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleAdd(this);\n};\n\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */\nReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root)\n        root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved)\n        return this;\n    if (this.root instanceof Root)\n        this.resolved = true; // only if part of a root\n    return this;\n};\n\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */\nReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options)\n        return this.options[name];\n    return undefined;\n};\n\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined)\n        (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function (opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */\nReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options)\n        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)\n            this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */\nReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className,\n        fullName  = this.fullName;\n    if (fullName.length)\n        return className + \" \" + fullName;\n    return className;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n","\"use strict\";\nmodule.exports = OneOf;\n\n// extends ReflectionObject\nvar ReflectionObject = require(24);\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\n\nvar Field = require(16),\n    util  = require(37);\n\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */\nfunction OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n\n    /* istanbul ignore if */\n    if (!(fieldNames === undefined || Array.isArray(fieldNames)))\n        throw TypeError(\"fieldNames must be an Array\");\n\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */\n    this.oneof = fieldNames || []; // toJSON, marker\n\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */\n    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */\n    this.comment = comment;\n}\n\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */\n\n/**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */\nOneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */\nOneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\" , this.options,\n        \"oneof\"   , this.oneof,\n        \"comment\" , keepComments ? this.comment : undefined\n    ]);\n};\n\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */\nfunction addFieldsToParent(oneof) {\n    if (oneof.parent)\n        for (var i = 0; i < oneof.fieldsArray.length; ++i)\n            if (!oneof.fieldsArray[i].parent)\n                oneof.parent.add(oneof.fieldsArray[i]);\n}\n\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */\nOneOf.prototype.add = function add(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    if (field.parent && field.parent !== this.parent)\n        field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */\nOneOf.prototype.remove = function remove(field) {\n\n    /* istanbul ignore if */\n    if (!(field instanceof Field))\n        throw TypeError(\"field must be a Field\");\n\n    var index = this.fieldsArray.indexOf(field);\n\n    /* istanbul ignore if */\n    if (index < 0)\n        throw Error(field + \" is not a member of \" + this);\n\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n\n    /* istanbul ignore else */\n    if (index > -1) // theoretical\n        this.oneof.splice(index, 1);\n\n    field.partOf = null;\n    return this;\n};\n\n/**\n * @override\n */\nOneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for (var i = 0; i < this.oneof.length; ++i) {\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n\n/**\n * @override\n */\nOneOf.prototype.onRemove = function onRemove(parent) {\n    for (var i = 0, field; i < this.fieldsArray.length; ++i)\n        if ((field = this.fieldsArray[i]).parent)\n            field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */\n\n/**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */\nOneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length),\n        index = 0;\n    while (index < arguments.length)\n        fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor)\n            .add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n","\"use strict\";\nmodule.exports = parse;\n\nparse.filename = null;\nparse.defaults = { keepCase: false };\n\nvar tokenize  = require(34),\n    Root      = require(29),\n    Type      = require(35),\n    Field     = require(16),\n    MapField  = require(20),\n    OneOf     = require(25),\n    Enum      = require(15),\n    Service   = require(33),\n    Method    = require(22),\n    types     = require(36),\n    util      = require(37);\n\nvar base10Re    = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re    = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re     = /^0[0-7]+$/,\n    base8NegRe  = /^-?0[0-7]+$/,\n    numberRe    = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe   = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */\n\n/**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */\n\n/**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */\n\n/**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */\nfunction parse(source, root, options) {\n    /* eslint-disable callback-return */\n    if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options)\n        options = parse.defaults;\n\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false),\n        next = tn.next,\n        push = tn.push,\n        peek = tn.peek,\n        skip = tn.skip,\n        cmnt = tn.cmnt;\n\n    var head = true,\n        pkg,\n        imports,\n        weakImports,\n        syntax,\n        isProto3 = false;\n\n    var ptr = root;\n\n    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;\n\n    /* istanbul ignore next */\n    function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch)\n            parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n\n    function readString() {\n        var values = [],\n            token;\n        do {\n            /* istanbul ignore if */\n            if ((token = next()) !== \"\\\"\" && token !== \"'\")\n                throw illegal(token);\n\n            values.push(next());\n            skip(token);\n            token = peek();\n        } while (token === \"\\\"\" || token === \"'\");\n        return values.join(\"\");\n    }\n\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch (token) {\n            case \"'\":\n            case \"\\\"\":\n                push(token);\n                return readString();\n            case \"true\": case \"TRUE\":\n                return true;\n            case \"false\": case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n\n            /* istanbul ignore else */\n            if (acceptTypeRef && typeRefRe.test(token))\n                return token;\n\n            /* istanbul ignore next */\n            throw illegal(token, \"value\");\n        }\n    }\n\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\"))\n                target.push(readString());\n            else\n                target.push([ start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start ]);\n        } while (skip(\",\", true));\n        var dummy = {options: undefined};\n        dummy.setOption = function(name, value) {\n          if (this.options === undefined) this.options = {};\n          this.options[name] = value;\n        };\n        ifBlock(\n            dummy,\n            function parseRange_block(token) {\n              /* istanbul ignore else */\n              if (token === \"option\") {\n                parseOption(dummy, token);  // skip\n                skip(\";\");\n              } else\n                throw illegal(token);\n            },\n            function parseRange_line() {\n              parseInlineOptions(dummy);  // skip\n            });\n    }\n\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch (token) {\n            case \"inf\": case \"INF\": case \"Inf\":\n                return sign * Infinity;\n            case \"nan\": case \"NAN\": case \"Nan\": case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token))\n            return sign * parseInt(token, 10);\n        if (base16Re.test(token))\n            return sign * parseInt(token, 16);\n        if (base8Re.test(token))\n            return sign * parseInt(token, 8);\n\n        /* istanbul ignore else */\n        if (numberRe.test(token))\n            return sign * parseFloat(token);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"number\", insideTryCatch);\n    }\n\n    function parseId(token, acceptNegative) {\n        switch (token) {\n            case \"max\": case \"MAX\": case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n\n        /* istanbul ignore if */\n        if (!acceptNegative && token.charAt(0) === \"-\")\n            throw illegal(token, \"id\");\n\n        if (base10NegRe.test(token))\n            return parseInt(token, 10);\n        if (base16NegRe.test(token))\n            return parseInt(token, 16);\n\n        /* istanbul ignore else */\n        if (base8NegRe.test(token))\n            return parseInt(token, 8);\n\n        /* istanbul ignore next */\n        throw illegal(token, \"id\");\n    }\n\n    function parsePackage() {\n\n        /* istanbul ignore if */\n        if (pkg !== undefined)\n            throw illegal(\"package\");\n\n        pkg = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(pkg))\n            throw illegal(pkg, \"name\");\n\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch (token) {\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n                // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n\n    function parseSyntax() {\n        skip(\"=\");\n        syntax = readString();\n        isProto3 = syntax === \"proto3\";\n\n        /* istanbul ignore if */\n        if (!isProto3 && syntax !== \"proto2\")\n            throw illegal(syntax, \"syntax\");\n\n        skip(\";\");\n    }\n\n    function parseCommon(parent, token) {\n        switch (token) {\n\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n\n            case \"message\":\n                parseType(parent, token);\n                return true;\n\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n\n            case \"service\":\n                parseService(parent, token);\n                return true;\n\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if(typeof obj.comment !== \"string\") {\n              obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while ((token = next()) !== \"}\")\n                fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse)\n                fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment))\n                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n\n    function parseType(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"type name\");\n\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token))\n                return;\n\n            switch (token) {\n\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n\n                default:\n                    /* istanbul ignore if */\n                    if (!isProto3 || !typeRefRe.test(token))\n                        throw illegal(token);\n\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n    }\n\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while (type.endsWith(\".\") || peek().startsWith(\".\")) {\n            type += next();\n        }\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(type))\n            throw illegal(type, \"type\");\n\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        name = applyCase(name);\n        skip(\"=\");\n\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\n        // all known packable types and anything that could be an enum (= is not a basic type).\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))\n            field.setOption(\"packed\", false, /* ifNotSet */ true);\n    }\n\n    function parseGroup(parent, rule) {\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName)\n            name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch (token) {\n\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n\n                case \"optional\":\n                    /* istanbul ignore if */\n                    if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n\n                case \"message\":\n                    parseType(type, token);\n                    break;\n\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n\n                /* istanbul ignore next */\n                default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type)\n              .add(field);\n    }\n\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n\n        /* istanbul ignore if */\n        if (types.mapKey[keyType] === undefined)\n            throw illegal(keyType, \"type\");\n\n        skip(\",\");\n        var valueType = next();\n\n        /* istanbul ignore if */\n        if (!typeRefRe.test(valueType))\n            throw illegal(valueType, \"type\");\n\n        skip(\">\");\n        var name = next();\n\n        /* istanbul ignore if */\n        if (!nameRe.test(name))\n            throw illegal(name, \"name\");\n\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n\n            /* istanbul ignore else */\n            if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else\n                throw illegal(token);\n\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n\n    function parseOneOf(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n\n    function parseEnum(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next()))\n            throw illegal(token, \"name\");\n\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n          switch(token) {\n            case \"option\":\n              parseOption(enm, token);\n              skip(\";\");\n              break;\n\n            case \"reserved\":\n              readRanges(enm.reserved || (enm.reserved = []), true);\n              break;\n\n            default:\n              parseEnumValue(enm, token);\n          }\n        });\n        parent.add(enm);\n    }\n\n    function parseEnumValue(parent, token) {\n\n        /* istanbul ignore if */\n        if (!nameRe.test(token))\n            throw illegal(token, \"name\");\n\n        skip(\"=\");\n        var value = parseId(next(), true),\n            dummy = {\n                options: undefined\n            };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined)\n                this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dumm